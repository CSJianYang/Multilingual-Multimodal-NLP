[
    {
        "title": "Edit Distance",
        "question_content": "Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.\nYou have the following three operations permitted on a word:\n\n\tInsert a character\n\tDelete a character\n\tReplace a character\n\n&nbsp;\nExample 1:\n\nInput: word1 = \"horse\", word2 = \"ros\"\nOutput: 3\nExplanation: \nhorse -> rorse (replace 'h' with 'r')\nrorse -> rose (remove 'r')\nrose -> ros (remove 'e')\n\nExample 2:\n\nInput: word1 = \"intention\", word2 = \"execution\"\nOutput: 5\nExplanation: \nintention -> inention (remove 't')\ninention -> enention (replace 'i' with 'e')\nenention -> exention (replace 'n' with 'x')\nexention -> exection (replace 'n' with 'c')\nexection -> execution (insert 'u')\n\n&nbsp;\nConstraints:\n\n\t0 <= word1.length, word2.length <= 500\n\tword1 and word2 consist of lowercase English letters.",
        "solutions": [
            {
                "id": 159295,
                "title": "python-solutions-and-intuition",
                "content": "For those having difficulty cracking dynamic programming solutions, I find it easiest to solve by first starting with a naive, but working recursive implementation. It\\'s essential to do so, because dynamic programming is basically recursion with caching. With this workflow, deciphering dynamic programming problems becomes just a little more manageable for us normal people. :)\\n\\n**Thought process:**\\nGiven two strings, we\\'re tasked with finding the minimum number of transformations we need to make to arrive with equivalent strings. From the get-go, there doesn\\'t seem to be any way around trying all possibilities, and in this, possibilities refers to inserting, deleting, or replacing a character. Recursion is usually a good choice for trying all possilbilities. \\n\\nWhenever we write recursive functions, we\\'ll need some way to terminate, or else we\\'ll end up overflowing the stack via infinite recursion. With strings, the natural state to keep track of is the index. We\\'ll need two indexes, one for word1 and one for word2. Now we just need to handle our base cases, and recursive cases. \\nWhat happens when we\\'re done with either word? Some thought will tell you that the minimum number of transformations is simply to insert the rest of the other word. This is our base case. What about when we\\'re not done with either string? We\\'ll either match the currently indexed characters in both strings, or mismatch. In the first case, we don\\'t incur any penalty, and we can continue to compare the rest of the strings by recursing on the rest of both strings. In the case of a mismatch, we either insert, delete, or replace. To recap:\\n1. base case: word1 = \"\" or word2 = \"\" => return length of other string\\n2. recursive case: word1[0] == word2[0] => recurse on word1[1:] and word2[1:]\\n3. recursive case: word1[0] != word2[0] => recurse by inserting, deleting, or replacing \\n\\nAnd in Python:\\n```\\nclass Solution:\\n    def minDistance(self, word1, word2):\\n        \"\"\"Naive recursive solution\"\"\"\\n        if not word1 and not word2:\\n            return 0\\n        if not word1:\\n            return len(word2)\\n        if not word2:\\n            return len(word1)\\n        if word1[0] == word2[0]:\\n            return self.minDistance(word1[1:], word2[1:])\\n        insert = 1 + self.minDistance(word1, word2[1:])\\n        delete = 1 + self.minDistance(word1[1:], word2)\\n        replace = 1 + self.minDistance(word1[1:], word2[1:])\\n        return min(insert, replace, delete)\\n```\\n\\nWith a solution in hand, we\\'re ecstatic and we go to submit our code. All is well until we see the dreaded red text... **TIME LIMIT EXCEEDED**. What did we do wrong? Let\\'s look at a simple example, and for sake of brevity I\\'ll annotate the minDistance function as ```md```. \\n\\nword1 = \"horse\"\\nword2 = \"hello\"\\n\\nThe tree of recursive calls, 3 levels deep, looks like the following. I\\'ve highlighted recursive calls with multiple invocations. So now we see that we\\'re repeating work. I\\'m not going to try and analyze the runtime of this solution, but it\\'s exponential. \\n\\n```\\nmd(\"horse\", \"hello\")\\n\\tmd(\"orse\", \"ello\")\\n\\t\\tmd(\"orse\", \"llo\")\\n\\t\\t\\tmd(\"orse\", \"lo\")\\n\\t\\t\\tmd(\"rse\", \"llo\") <- \\n\\t\\t\\tmd(\"rse\", \"lo\")\\n\\t\\tmd(\"rse\", \"ello\")\\n\\t\\t\\tmd(\"rse\", \"llo\") <-\\n\\t\\t\\tmd(\"se\", \"ello\")\\n\\t\\t\\tmd(\"se\", \"llo\") <<-\\n\\t\\tmd(\"rse\", \"llo\")\\n\\t\\t\\tmd(\"rse\", \"llo\") <-\\n\\t\\t\\tmd(\"se\", \"llo\") <<-\\n\\t\\t\\tmd(\"se\", \"lo\")\\n```\\n\\nThe way we fix this is by **caching**. We save intermediate computations in a dictionary and if we recur on the same subproblem, instead of doing the same work again, we return the saved value. Here is the memoized solution, where we build from bigger subproblems to smaller subproblems (top-down).\\n```\\nclass Solution:\\n    def minDistance(self, word1, word2, i, j, memo):\\n        \"\"\"Memoized solution\"\"\"\\n        if i == len(word1) and j == len(word2):\\n            return 0\\n        if i == len(word1):\\n            return len(word2) - j\\n        if j == len(word2):\\n            return len(word1) - i\\n\\n        if (i, j) not in memo:\\n            if word1[i] == word2[j]:\\n                ans = self.minDistance2(word1, word2, i + 1, j + 1, memo)\\n            else: \\n                insert = 1 + self.minDistance2(word1, word2, i, j + 1, memo)\\n                delete = 1 + self.minDistance2(word1, word2, i + 1, j, memo)\\n                replace = 1 + self.minDistance2(word1, word2, i + 1, j + 1, memo)\\n                ans = min(insert, delete, replace)\\n            memo[(i, j)] = ans\\n        return memo[(i, j)]\\n```\\n\\nOf course, an interative implementation is usually better than its recursive counterpart because we don\\'t risk blowing up our stack in case the number of recursive calls is very deep. We can also use a 2D array to do essentially the same thing as the dictionary of cached values. When we do this, we build up solutions from smaller subproblems to bigger subproblems (bottom-up). In this case, since we are no longer \"recurring\" in the traditional sense, we initialize our 2D table with base constraints. The first row and column of the table has known values since if one string is empty, we simply add the length of the non-empty string since that is the minimum number of edits necessary to arrive at equivalent strings. For both the memoized and dynamic programming solutions, the runtime is ```O(mn)``` and the space complexity is ```O(mn)``` where m and n are the lengths of word1 and word2, respectively.\\n```\\nclass Solution:\\n    def minDistance(self, word1, word2):\\n        \"\"\"Dynamic programming solution\"\"\"\\n        m = len(word1)\\n        n = len(word2)\\n        table = [[0] * (n + 1) for _ in range(m + 1)]\\n\\n        for i in range(m + 1):\\n            table[i][0] = i\\n        for j in range(n + 1):\\n            table[0][j] = j\\n\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                if word1[i - 1] == word2[j - 1]:\\n                    table[i][j] = table[i - 1][j - 1]\\n                else:\\n                    table[i][j] = 1 + min(table[i - 1][j], table[i][j - 1], table[i - 1][j - 1])\\n        return table[-1][-1]\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minDistance(self, word1, word2):\\n        \"\"\"Naive recursive solution\"\"\"\\n        if not word1 and not word2:\\n            return 0\\n        if not word1:\\n            return len(word2)\\n        if not word2:\\n            return len(word1)\\n        if word1[0] == word2[0]:\\n            return self.minDistance(word1[1:], word2[1:])\\n        insert = 1 + self.minDistance(word1, word2[1:])\\n        delete = 1 + self.minDistance(word1[1:], word2)\\n        replace = 1 + self.minDistance(word1[1:], word2[1:])\\n        return min(insert, replace, delete)\\n```\n```md```\n```\\nmd(\"horse\", \"hello\")\\n\\tmd(\"orse\", \"ello\")\\n\\t\\tmd(\"orse\", \"llo\")\\n\\t\\t\\tmd(\"orse\", \"lo\")\\n\\t\\t\\tmd(\"rse\", \"llo\") <- \\n\\t\\t\\tmd(\"rse\", \"lo\")\\n\\t\\tmd(\"rse\", \"ello\")\\n\\t\\t\\tmd(\"rse\", \"llo\") <-\\n\\t\\t\\tmd(\"se\", \"ello\")\\n\\t\\t\\tmd(\"se\", \"llo\") <<-\\n\\t\\tmd(\"rse\", \"llo\")\\n\\t\\t\\tmd(\"rse\", \"llo\") <-\\n\\t\\t\\tmd(\"se\", \"llo\") <<-\\n\\t\\t\\tmd(\"se\", \"lo\")\\n```\n```\\nclass Solution:\\n    def minDistance(self, word1, word2, i, j, memo):\\n        \"\"\"Memoized solution\"\"\"\\n        if i == len(word1) and j == len(word2):\\n            return 0\\n        if i == len(word1):\\n            return len(word2) - j\\n        if j == len(word2):\\n            return len(word1) - i\\n\\n        if (i, j) not in memo:\\n            if word1[i] == word2[j]:\\n                ans = self.minDistance2(word1, word2, i + 1, j + 1, memo)\\n            else: \\n                insert = 1 + self.minDistance2(word1, word2, i, j + 1, memo)\\n                delete = 1 + self.minDistance2(word1, word2, i + 1, j, memo)\\n                replace = 1 + self.minDistance2(word1, word2, i + 1, j + 1, memo)\\n                ans = min(insert, delete, replace)\\n            memo[(i, j)] = ans\\n        return memo[(i, j)]\\n```\n```O(mn)```\n```O(mn)```\n```\\nclass Solution:\\n    def minDistance(self, word1, word2):\\n        \"\"\"Dynamic programming solution\"\"\"\\n        m = len(word1)\\n        n = len(word2)\\n        table = [[0] * (n + 1) for _ in range(m + 1)]\\n\\n        for i in range(m + 1):\\n            table[i][0] = i\\n        for j in range(n + 1):\\n            table[0][j] = j\\n\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                if word1[i - 1] == word2[j - 1]:\\n                    table[i][j] = table[i - 1][j - 1]\\n                else:\\n                    table[i][j] = 1 + min(table[i - 1][j], table[i][j - 1], table[i - 1][j - 1])\\n        return table[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25846,
                "title": "c-o-n-space-dp",
                "content": "To apply DP, we define the state `dp[i][j]` to be the minimum number of operations to convert `word1[0..i)` to `word2[0..j)`.\\n\\nFor the base case, that is, to convert a string to an empty string, the mininum number of operations (deletions) is just the length of the string. So we have `dp[i][0] = i` and `dp[0][j] = j`.\\n\\nFor the general case to convert `word1[0..i)` to `word2[0..j)`, we break this problem down into sub-problems. Suppose we have already known how to convert `word1[0..i - 1)` to `word2[0..j - 1)` (`dp[i - 1][j - 1]`), if  `word1[i - 1] == word2[j - 1]`, then no more operation is needed and `dp[i][j] = dp[i - 1][j - 1]`.\\n\\nIf `word1[i - 1] != word2[j - 1]`, we need to consider three cases.\\n\\n 1. **Replace** `word1[i - 1]` by `word2[j - 1]` (`dp[i][j] = dp[i - 1][j - 1] + 1`);\\n 2. If `word1[0..i - 1) = word2[0..j)` then **delete** `word1[i - 1]` (`dp[i][j] = dp[i - 1][j] + 1`);\\n 3. If `word1[0..i) + word2[j - 1] = word2[0..j)` then **insert** `word2[j - 1]` to `word1[0..i)` (`dp[i][j] = dp[i][j - 1] + 1`).\\n\\nSo when `word1[i - 1] != word2[j - 1]`, `dp[i][j]` will just be the minimum of the above three cases.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = word1.size(), n = word2.size();\\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\\n        for (int i = 1; i <= m; i++) {\\n            dp[i][0] = i;\\n        }\\n        for (int j = 1; j <= n; j++) {\\n            dp[0][j] = j;\\n        }\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (word1[i - 1] == word2[j - 1]) {\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                } else {\\n                    dp[i][j] = min(dp[i - 1][j - 1], min(dp[i][j - 1], dp[i - 1][j])) + 1;\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```\\n\\nNote that each time when we update `dp[i][j]`, we only need `dp[i - 1][j - 1]`, `dp[i][j - 1]` and `dp[i - 1][j]`. We may optimize the space of the code to use only two vectors.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = word1.size(), n = word2.size();\\n        vector<int> pre(n + 1, 0), cur(n + 1, 0);\\n        for (int j = 1; j <= n; j++) {\\n            pre[j] = j;\\n        }\\n        for (int i = 1; i <= m; i++) {\\n            cur[0] = i;\\n            for (int j = 1; j <= n; j++) {\\n                if (word1[i - 1] == word2[j - 1]) {\\n                    cur[j] = pre[j - 1];\\n                } else {\\n                    cur[j] = min(pre[j - 1], min(cur[j - 1], pre[j])) + 1;\\n                }\\n            }\\n            fill(pre.begin(), pre.end(), 0);\\n            swap(pre, cur);\\n        }\\n        return pre[n];\\n    }\\n};\\n```\\n\\nOr even just one vector.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = word1.size(), n = word2.size(), pre;\\n        vector<int> cur(n + 1, 0);\\n        for (int j = 1; j <= n; j++) {\\n            cur[j] = j;\\n        }\\n        for (int i = 1; i <= m; i++) {\\n            pre = cur[0];\\n            cur[0] = i;\\n            for (int j = 1; j <= n; j++) {\\n                int temp = cur[j];\\n                if (word1[i - 1] == word2[j - 1]) {\\n                    cur[j] = pre;\\n                } else {\\n                    cur[j] = min(pre, min(cur[j - 1], cur[j])) + 1;\\n                }\\n                pre = temp;\\n            }\\n        }\\n        return cur[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = word1.size(), n = word2.size();\\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\\n        for (int i = 1; i <= m; i++) {\\n            dp[i][0] = i;\\n        }\\n        for (int j = 1; j <= n; j++) {\\n            dp[0][j] = j;\\n        }\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (word1[i - 1] == word2[j - 1]) {\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                } else {\\n                    dp[i][j] = min(dp[i - 1][j - 1], min(dp[i][j - 1], dp[i - 1][j])) + 1;\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = word1.size(), n = word2.size();\\n        vector<int> pre(n + 1, 0), cur(n + 1, 0);\\n        for (int j = 1; j <= n; j++) {\\n            pre[j] = j;\\n        }\\n        for (int i = 1; i <= m; i++) {\\n            cur[0] = i;\\n            for (int j = 1; j <= n; j++) {\\n                if (word1[i - 1] == word2[j - 1]) {\\n                    cur[j] = pre[j - 1];\\n                } else {\\n                    cur[j] = min(pre[j - 1], min(cur[j - 1], pre[j])) + 1;\\n                }\\n            }\\n            fill(pre.begin(), pre.end(), 0);\\n            swap(pre, cur);\\n        }\\n        return pre[n];\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = word1.size(), n = word2.size(), pre;\\n        vector<int> cur(n + 1, 0);\\n        for (int j = 1; j <= n; j++) {\\n            cur[j] = j;\\n        }\\n        for (int i = 1; i <= m; i++) {\\n            pre = cur[0];\\n            cur[0] = i;\\n            for (int j = 1; j <= n; j++) {\\n                int temp = cur[j];\\n                if (word1[i - 1] == word2[j - 1]) {\\n                    cur[j] = pre;\\n                } else {\\n                    cur[j] = min(pre, min(cur[j - 1], cur[j])) + 1;\\n                }\\n                pre = temp;\\n            }\\n        }\\n        return cur[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25895,
                "title": "step-by-step-explanation-of-how-to-optimize-the-solution-from-simple-recursion-to-dp",
                "content": "First we may want to consider recursion.\\n```\\npublic class Solution {\\n    /**\\n     * Recursive solution.\\n     * For each poisition, check three subproblem:\\n     * 1. insert\\n     * 2. delete\\n     * 3. replace\\n     * We only modify the first string since no matter which one we choose, the result is the same. \\n     * Got TLE since we recursively solve the same subproblem several times.\\n     * Appromixately O(len1 ^ 3) time in the worst case.\\n     * Need to optimize it using cache, which is the idea of dynamic programming. \\n     * The key point is to find out the subproblem we have solved duplicately and cache the recursion.\\n     * Noticed that each subproblem is specificed by i and j pointer, so we can cache the result of these subproblems. \\n     */\\n    public int minDistance(String word1, String word2) {\\n        if (word1 == null || word1.length() == 0) return word2.length();\\n        if (word2 == null || word2.length() == 0) return word1.length();\\n        \\n        return match(word1, word2, 0, 0);\\n    }\\n    \\n    private int match(String s1, String s2, int i, int j) {\\n        //If one of the string's pointer have reached the end of it\\n        if (s1.length() == i) {\\n            return s2.length() - j;\\n        }\\n        if (s2.length() == j) {\\n            return s1.length() - i;\\n        }\\n        \\n        int res;\\n        //If current poisition is the same.\\n        if (s1.charAt(i) == s2.charAt(j)) {\\n            res = match(s1, s2, i + 1, j + 1);\\n        } else {\\n            //Case1: insert\\n            int insert = match(s1, s2, i, j + 1);\\n            //Case2: delete\\n            int delete = match(s1, s2, i + 1, j);\\n            //Case3: replace\\n            int replace = match(s1, s2, i + 1, j + 1);\\n            res = Math.min(Math.min(insert, delete), replace) + 1;\\n        }\\n        \\n        return res;\\n    }\\n}  \\n```\\nThis got TLE. based on the analysis above, we may try DP. \\n```\\npublic class Solution {\\n    /**\\n     * Optimization using dynamic programming\\n     * Top-down solution\\n     * O(len1 * len2) time, O(len1 * len2) space\\n     */\\n    public int minDistance(String word1, String word2) {\\n        if (word1 == null || word2 == null) return -1;\\n        if (word1.length() == 0) return word2.length();\\n        if (word2.length() == 0) return word1.length();\\n        \\n        char[] c1 = word1.toCharArray();\\n        char[] c2 = word2.toCharArray();\\n        \\n        int[][] cache = new int[c1.length][c2.length];\\n        for (int i = 0; i < c1.length; i++) {\\n            for (int j = 0; j < c2.length; j++) {\\n                cache[i][j] = -1;\\n            }\\n        }\\n        \\n        return match(c1, c2, 0, 0, cache);\\n    }\\n    \\n    private int match(char[] c1, char[] c2, int i, int j, int[][] cache) {\\n        if (c1.length == i) return c2.length - j;\\n        if (c2.length == j) return c1.length - i;\\n        \\n        if (cache[i][j] != -1) {\\n            return cache[i][j];\\n        }\\n        \\n        if (c1[i] == c2[j]) {\\n            cache[i][j] = match(c1, c2, i + 1, j + 1, cache);\\n        } else {\\n            //Case1: insert\\n            int insert = match(c1, c2, i, j + 1, cache);\\n            //Case2: delete\\n            int delete = match(c1, c2, i + 1, j, cache);\\n            //Case3: replace\\n            int replace = match(c1, c2, i + 1, j + 1, cache);\\n            \\n            cache[i][j] = Math.min(Math.min(insert, delete), replace) + 1;\\n        }\\n        \\n        return cache[i][j];\\n    }\\n    \\n    \\n    \\n    \\n    /**\\n     * Bottom-up approach\\n     */\\n    public int minDistance(String word1, String word2) {\\n        if (word1 == null || word2 == null) return -1;\\n        if (word1.length() == 0) return word2.length();\\n        if (word2.length() == 0) return word1.length();\\n        \\n        char[] c1 = word1.toCharArray();\\n        char[] c2 = word2.toCharArray();\\n        \\n        int[][] matched = new int[c1.length + 1][c2.length + 1];\\n        //matched[length of c1 already been matched][length of c2 already been matched]\\n        \\n        for (int i = 0; i <= c1.length; i++) {\\n            matched[i][0] = i;\\n        }\\n        for (int j = 0; j <= c2.length; j++) {\\n            matched[0][j] = j;\\n        }\\n        \\n        for (int i = 0; i < c1.length; i++) {\\n            for (int j = 0; j < c2.length; j++) {\\n                if (c1[i] == c2[j]) {\\n                    matched[i + 1][j + 1] = matched[i][j];\\n                } else {\\n                    matched[i + 1][j + 1] = Math.min(Math.min(matched[i][j + 1], matched[i + 1][j]), matched[i][j]) + 1;\\n                    //Since it is bottom up, we are considering in the ascending order of indexes.\\n                    //Insert means plus 1 to j, delete means plus 1 to i, replace means plus 1 to both i and j. \\n                    //above sequence is delete, insert and replace. \\n                }\\n            }\\n        }\\n        \\n        return matched[c1.length][c2.length];\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    /**\\n     * Recursive solution.\\n     * For each poisition, check three subproblem:\\n     * 1. insert\\n     * 2. delete\\n     * 3. replace\\n     * We only modify the first string since no matter which one we choose, the result is the same. \\n     * Got TLE since we recursively solve the same subproblem several times.\\n     * Appromixately O(len1 ^ 3) time in the worst case.\\n     * Need to optimize it using cache, which is the idea of dynamic programming. \\n     * The key point is to find out the subproblem we have solved duplicately and cache the recursion.\\n     * Noticed that each subproblem is specificed by i and j pointer, so we can cache the result of these subproblems. \\n     */\\n    public int minDistance(String word1, String word2) {\\n        if (word1 == null || word1.length() == 0) return word2.length();\\n        if (word2 == null || word2.length() == 0) return word1.length();\\n        \\n        return match(word1, word2, 0, 0);\\n    }\\n    \\n    private int match(String s1, String s2, int i, int j) {\\n        //If one of the string's pointer have reached the end of it\\n        if (s1.length() == i) {\\n            return s2.length() - j;\\n        }\\n        if (s2.length() == j) {\\n            return s1.length() - i;\\n        }\\n        \\n        int res;\\n        //If current poisition is the same.\\n        if (s1.charAt(i) == s2.charAt(j)) {\\n            res = match(s1, s2, i + 1, j + 1);\\n        } else {\\n            //Case1: insert\\n            int insert = match(s1, s2, i, j + 1);\\n            //Case2: delete\\n            int delete = match(s1, s2, i + 1, j);\\n            //Case3: replace\\n            int replace = match(s1, s2, i + 1, j + 1);\\n            res = Math.min(Math.min(insert, delete), replace) + 1;\\n        }\\n        \\n        return res;\\n    }\\n}  \\n```\n```\\npublic class Solution {\\n    /**\\n     * Optimization using dynamic programming\\n     * Top-down solution\\n     * O(len1 * len2) time, O(len1 * len2) space\\n     */\\n    public int minDistance(String word1, String word2) {\\n        if (word1 == null || word2 == null) return -1;\\n        if (word1.length() == 0) return word2.length();\\n        if (word2.length() == 0) return word1.length();\\n        \\n        char[] c1 = word1.toCharArray();\\n        char[] c2 = word2.toCharArray();\\n        \\n        int[][] cache = new int[c1.length][c2.length];\\n        for (int i = 0; i < c1.length; i++) {\\n            for (int j = 0; j < c2.length; j++) {\\n                cache[i][j] = -1;\\n            }\\n        }\\n        \\n        return match(c1, c2, 0, 0, cache);\\n    }\\n    \\n    private int match(char[] c1, char[] c2, int i, int j, int[][] cache) {\\n        if (c1.length == i) return c2.length - j;\\n        if (c2.length == j) return c1.length - i;\\n        \\n        if (cache[i][j] != -1) {\\n            return cache[i][j];\\n        }\\n        \\n        if (c1[i] == c2[j]) {\\n            cache[i][j] = match(c1, c2, i + 1, j + 1, cache);\\n        } else {\\n            //Case1: insert\\n            int insert = match(c1, c2, i, j + 1, cache);\\n            //Case2: delete\\n            int delete = match(c1, c2, i + 1, j, cache);\\n            //Case3: replace\\n            int replace = match(c1, c2, i + 1, j + 1, cache);\\n            \\n            cache[i][j] = Math.min(Math.min(insert, delete), replace) + 1;\\n        }\\n        \\n        return cache[i][j];\\n    }\\n    \\n    \\n    \\n    \\n    /**\\n     * Bottom-up approach\\n     */\\n    public int minDistance(String word1, String word2) {\\n        if (word1 == null || word2 == null) return -1;\\n        if (word1.length() == 0) return word2.length();\\n        if (word2.length() == 0) return word1.length();\\n        \\n        char[] c1 = word1.toCharArray();\\n        char[] c2 = word2.toCharArray();\\n        \\n        int[][] matched = new int[c1.length + 1][c2.length + 1];\\n        //matched[length of c1 already been matched][length of c2 already been matched]\\n        \\n        for (int i = 0; i <= c1.length; i++) {\\n            matched[i][0] = i;\\n        }\\n        for (int j = 0; j <= c2.length; j++) {\\n            matched[0][j] = j;\\n        }\\n        \\n        for (int i = 0; i < c1.length; i++) {\\n            for (int j = 0; j < c2.length; j++) {\\n                if (c1[i] == c2[j]) {\\n                    matched[i + 1][j + 1] = matched[i][j];\\n                } else {\\n                    matched[i + 1][j + 1] = Math.min(Math.min(matched[i][j + 1], matched[i + 1][j]), matched[i][j]) + 1;\\n                    //Since it is bottom up, we are considering in the ascending order of indexes.\\n                    //Insert means plus 1 to j, delete means plus 1 to i, replace means plus 1 to both i and j. \\n                    //above sequence is delete, insert and replace. \\n                }\\n            }\\n        }\\n        \\n        return matched[c1.length][c2.length];\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25849,
                "title": "java-dp-solution-o-nm",
                "content": "Let following be the function definition :-\\n\\nf(i, j) := minimum cost (or steps) required to convert first i characters of word1 to first j characters of word2\\n\\nCase 1: word1[i] == word2[j], i.e. the ith the jth character matches.\\n\\n> f(i, j) = f(i - 1, j - 1)\\n\\nCase 2: word1[i] != word2[j], then we must either insert, delete or replace, whichever is cheaper\\n\\n> f(i, j) = 1 + min { f(i, j - 1), f(i - 1, j), f(i - 1, j - 1) }\\n\\n1. f(i, j - 1) represents insert operation\\n2. f(i - 1, j) represents delete operation\\n3. f(i - 1, j - 1) represents replace operation\\n\\nHere, we consider any operation from word1 to word2. It means, when we say insert operation, we insert a new character after word1 that matches the jth character of word2. So, now have to match i characters of word1 to j - 1 characters of word2. Same goes for other 2 operations as well.\\n\\nNote that the problem is symmetric. The insert operation in one direction (i.e. from word1 to word2) is same as delete operation in other. So, we could choose any direction.\\n\\nAbove equations become the recursive definitions for DP.\\n\\nBase Case: \\n\\n> f(0, k) = f(k, 0) = k\\n\\nBelow is the direct bottom-up translation of this recurrent relation. It is only important to take care of 0-based index with actual code :-\\n\\n    public class Solution {\\n        public int minDistance(String word1, String word2) {\\n            int m = word1.length();\\n            int n = word2.length();\\n            \\n            int[][] cost = new int[m + 1][n + 1];\\n            for(int i = 0; i <= m; i++)\\n                cost[i][0] = i;\\n            for(int i = 1; i <= n; i++)\\n                cost[0][i] = i;\\n            \\n            for(int i = 0; i < m; i++) {\\n                for(int j = 0; j < n; j++) {\\n                    if(word1.charAt(i) == word2.charAt(j))\\n                        cost[i + 1][j + 1] = cost[i][j];\\n                    else {\\n                        int a = cost[i][j];\\n                        int b = cost[i][j + 1];\\n                        int c = cost[i + 1][j];\\n                        cost[i + 1][j + 1] = a < b ? (a < c ? a : c) : (b < c ? b : c);\\n                        cost[i + 1][j + 1]++;\\n                    }\\n                }\\n            }\\n            return cost[m][n];\\n        }\\n    }\\n\\nTime complexity : If n is the length of word1, m of word2, because of the two indented loops, it is O(nm)",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n        public int minDistance(String word1, String word2) {\\n            int m = word1.length();\\n            int n = word2.length();\\n            \\n            int[][] cost = new int[m + 1][n + 1];\\n            for(int i = 0; i <= m; i++)\\n                cost[i][0] = i;\\n            for(int i = 1; i <= n; i++)\\n                cost[0][i] = i;\\n            \\n            for(int i = 0; i < m; i++) {\\n                for(int j = 0; j < n; j++) {\\n                    if(word1.charAt(i) == word2.charAt(j))\\n                        cost[i + 1][j + 1] = cost[i][j];\\n                    else {\\n                        int a = cost[i][j];\\n                        int b = cost[i][j + 1];\\n                        int c = cost[i + 1][j];\\n                        cost[i + 1][j + 1] = a < b ? (a < c ? a : c) : (b < c ? b : c);\\n                        cost[i + 1][j + 1]++;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3230662,
                "title": "clean-codes-full-explanation-dynamic-programming-c-java-python3",
                "content": "# Intuition :\\n- Here we have to find the minimum edit distance problem between two strings word1 and word2. \\n- The minimum edit distance is defined as the minimum number of operations required to transform one string into another.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach :\\n- The approach here that I am using is dynamic programming. The idea is to build a 2D matrix dp where `dp[i][j] `represents the minimum number of operations required to transform the substring `word1[0...i-1]` into the substring `word2[0...j-1].`\\n# How is Matrix built :\\n- The matrix is built iteratively using the following recurrence relation:\\n1. If `word1[i-1] == word2[j-1]`, then `dp[i][j] = dp[i-1][j-1]`. That is, no operation is required because the characters at positions `i-1` and `j-1` are already the same.\\n2. Otherwise, `dp[i][j]` is the minimum of the following three values:\\n- `dp[i-1][j-1] + 1`: replace the character at position `i-1` in `word1` with the character at position `j-1` in` word2`.\\n- `dp[i-1][j] + 1`: delete the character at position `i-1` in `word1.`\\n- `dp[i][j-1] + 1`: insert the character at position `j-1` in `word2` into `word1` at position `i`.\\n# The base cases are:\\n- `dp[i][0] = i`: transforming `word1[0...i-1]` into an empty string requires `i` deletions.\\n- `dp[0][j] = j`: transforming an empty string into `word2[0...j-1] `requires `j` insertions.\\n<!-- Describe your approach to solving the problem. -->\\n# Final Step :\\n- Finally, return `dp[m][n]`, which represents the minimum number of operations required to transform `word1 `into `word2`, where `m` is the length of `word1` and `n` is the length of `word2`.\\n\\n# Complexity\\n- Time complexity : O(mn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(mn)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\\n# Codes [C++ |Java |Python3] : With Comments\\n```C++ []\\nclass Solution {\\n public:\\n  int minDistance(string word1, string word2) {\\n    const int m = word1.length();//first word length\\n    const int n = word2.length();//second word length\\n    // dp[i][j] := min # of operations to convert word1[0..i) to word2[0..j)\\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1));\\n\\n    for (int i = 1; i <= m; ++i)\\n      dp[i][0] = i;\\n\\n    for (int j = 1; j <= n; ++j)\\n      dp[0][j] = j;\\n\\n    for (int i = 1; i <= m; ++i)\\n      for (int j = 1; j <= n; ++j)\\n        if (word1[i - 1] == word2[j - 1])//same characters\\n          dp[i][j] = dp[i - 1][j - 1];//no operation\\n        else\\n          dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;\\n                             //replace       //delete        //insert\\n    return dp[m][n];\\n  }\\n};\\n```\\n```Java []\\nclass Solution {\\n  public int minDistance(String word1, String word2) {\\n    final int m = word1.length();//first word length\\n    final int n = word2.length();///second word length\\n    // dp[i][j] := min # of operations to convert word1[0..i) to word2[0..j)\\n    int[][] dp = new int[m + 1][n + 1];\\n\\n    for (int i = 1; i <= m; ++i)\\n      dp[i][0] = i;\\n\\n    for (int j = 1; j <= n; ++j)\\n      dp[0][j] = j;\\n\\n    for (int i = 1; i <= m; ++i)\\n      for (int j = 1; j <= n; ++j)\\n        if (word1.charAt(i - 1) == word2.charAt(j - 1))//same characters\\n          dp[i][j] = dp[i - 1][j - 1];//no operation\\n        else\\n          dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1])) + 1;                      //replace               //delete        //insert\\n\\n    return dp[m][n];\\n  }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n  def minDistance(self, word1: str, word2: str) -> int:\\n    m = len(word1)\\n    n = len(word2)\\n    # dp[i][j] := min # Of operations to convert word1[0..i) to word2[0..j)\\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\\n\\n    for i in range(1, m + 1):\\n      dp[i][0] = i\\n\\n    for j in range(1, n + 1):\\n      dp[0][j] = j\\n\\n    for i in range(1, m + 1):\\n      for j in range(1, n + 1):\\n        if word1[i - 1] == word2[j - 1]:\\n          dp[i][j] = dp[i - 1][j - 1]\\n        else:\\n          dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1\\n\\n    return dp[m][n]\\n```\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n![ezgif-3-22a360561c.gif](https://assets.leetcode.com/users/images/399bb888-6ae6-4614-a338-fe33088c118d_1677378017.7506878.gif)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\n```C++ []\\nclass Solution {\\n public:\\n  int minDistance(string word1, string word2) {\\n    const int m = word1.length();//first word length\\n    const int n = word2.length();//second word length\\n    // dp[i][j] := min # of operations to convert word1[0..i) to word2[0..j)\\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1));\\n\\n    for (int i = 1; i <= m; ++i)\\n      dp[i][0] = i;\\n\\n    for (int j = 1; j <= n; ++j)\\n      dp[0][j] = j;\\n\\n    for (int i = 1; i <= m; ++i)\\n      for (int j = 1; j <= n; ++j)\\n        if (word1[i - 1] == word2[j - 1])//same characters\\n          dp[i][j] = dp[i - 1][j - 1];//no operation\\n        else\\n          dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;\\n                             //replace       //delete        //insert\\n    return dp[m][n];\\n  }\\n};\\n```\n```Java []\\nclass Solution {\\n  public int minDistance(String word1, String word2) {\\n    final int m = word1.length();//first word length\\n    final int n = word2.length();///second word length\\n    // dp[i][j] := min # of operations to convert word1[0..i) to word2[0..j)\\n    int[][] dp = new int[m + 1][n + 1];\\n\\n    for (int i = 1; i <= m; ++i)\\n      dp[i][0] = i;\\n\\n    for (int j = 1; j <= n; ++j)\\n      dp[0][j] = j;\\n\\n    for (int i = 1; i <= m; ++i)\\n      for (int j = 1; j <= n; ++j)\\n        if (word1.charAt(i - 1) == word2.charAt(j - 1))//same characters\\n          dp[i][j] = dp[i - 1][j - 1];//no operation\\n        else\\n          dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1])) + 1;                      //replace               //delete        //insert\\n\\n    return dp[m][n];\\n  }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n  def minDistance(self, word1: str, word2: str) -> int:\\n    m = len(word1)\\n    n = len(word2)\\n    # dp[i][j] := min # Of operations to convert word1[0..i) to word2[0..j)\\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\\n\\n    for i in range(1, m + 1):\\n      dp[i][0] = i\\n\\n    for j in range(1, n + 1):\\n      dp[0][j] = j\\n\\n    for i in range(1, m + 1):\\n      for j in range(1, n + 1):\\n        if word1[i - 1] == word2[j - 1]:\\n          dp[i][j] = dp[i - 1][j - 1]\\n        else:\\n          dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1\\n\\n    return dp[m][n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25911,
                "title": "my-o-mn-time-and-o-n-space-solution-using-dp-with-explanation",
                "content": "Use f[i][j] to represent the shortest edit distance between word1[0,i) and word2[0, j). Then compare the last character of word1[0,i) and word2[0,j), which are c and d respectively (c == word1[i-1], d == word2[j-1]):\\n\\nif c == d, then : f[i][j] = f[i-1][j-1]\\n\\nOtherwise we can use three operations to convert word1 to word2:\\n\\n(a) if we replaced c with d: f[i][j] = f[i-1][j-1] + 1;\\n\\n(b) if we added d after c: f[i][j] = f[i][j-1] + 1;\\n\\n(c) if we deleted c: f[i][j] = f[i-1][j] + 1;\\n\\n\\nNote that f[i][j] only depends on f[i-1][j-1], f[i-1][j] and f[i][j-1], therefore we can reduce the space to O(n) by using only the (i-1)th array and previous updated element(f[i][j-1]). \\n\\n\\n\\n     int minDistance(string word1, string word2) {\\n        \\n            int l1 = word1.size();\\n            int l2 = word2.size();\\n        \\n            vector<int> f(l2+1, 0);\\n            for (int j = 1; j <= l2; ++j)\\n                f[j] = j;\\n        \\n            for (int i = 1; i <= l1; ++i)\\n            {\\n                int prev = i;\\n                for (int j = 1; j <= l2; ++j)\\n                {\\n                    int cur;\\n                    if (word1[i-1] == word2[j-1]) {\\n                        cur = f[j-1];\\n                    } else {\\n                        cur = min(min(f[j-1], prev), f[j]) + 1;\\n                    }\\n        \\n                    f[j-1] = prev;\\n                    prev = cur;\\n                }\\n                f[l2] = prev;\\n            }\\n            return f[l2];\\n        \\n        }  \\n\\n\\nActually at first glance I thought this question was similar to Word Ladder and I tried to solve it using BFS(pretty stupid huh?). But in fact, the main difference is that there's a strict restriction on the intermediate words in Word Ladder problem, while there's no restriction in this problem.  If we added some restriction on intermediate words for this question, I don't think this DP solution would still work.",
                "solutionTags": [],
                "code": "Use f[i][j] to represent the shortest edit distance between word1[0,i) and word2[0, j). Then compare the last character of word1[0,i) and word2[0,j), which are c and d respectively (c == word1[i-1], d == word2[j-1]):\\n\\nif c == d, then : f[i][j] = f[i-1][j-1]\\n\\nOtherwise we can use three operations to convert word1 to word2:\\n\\n(a) if we replaced c with d: f[i][j] = f[i-1][j-1] + 1;\\n\\n(b) if we added d after c: f[i][j] = f[i][j-1] + 1;\\n\\n(c) if we deleted c: f[i][j] = f[i-1][j] + 1;\\n\\n\\nNote that f[i][j] only depends on f[i-1][j-1], f[i-1][j] and f[i][j-1], therefore we can reduce the space to O(n) by using only the (i-1)th array and previous updated element(f[i][j-1]). \\n\\n\\n\\n     int minDistance(string word1, string word2) {\\n        \\n            int l1 = word1.size();\\n            int l2 = word2.size();\\n        \\n            vector<int> f(l2+1, 0);\\n            for (int j = 1; j <= l2; ++j)\\n                f[j] = j;\\n        \\n            for (int i = 1; i <= l1; ++i)\\n            {\\n                int prev = i;\\n                for (int j = 1; j <= l2; ++j)\\n                {\\n                    int cur;\\n                    if (word1[i-1] == word2[j-1]) {\\n                        cur = f[j-1];\\n                    } else {\\n                        cur = min(min(f[j-1], prev), f[j]) + 1;\\n                    }\\n        \\n                    f[j-1] = prev;\\n                    prev = cur;\\n                }\\n                f[l2] = prev;\\n            }\\n            return f[l2];\\n        \\n        }  \\n\\n\\nActually at first glance I thought this question was similar to Word Ladder and I tried to solve it using BFS(pretty stupid huh?). But in fact, the main difference is that there's a strict restriction on the intermediate words in Word Ladder problem, while there's no restriction in this problem.  If we added some restriction on intermediate words for this question, I don't think this DP solution would still work.",
                "codeTag": "Unknown"
            },
            {
                "id": 662240,
                "title": "c-easy-dp-solution-well-commented",
                "content": "```\\nint minDistance(string word1, string word2) {\\n// Create a table to store results of subproblems\\n        int dp[word1.size()+1][word2.size()+1];\\n// If first string is empty, only option is to \\n// insert all characters of second string \\n        for(int k=0; k<=word1.size(); k++)\\n            dp[k][0] = k;\\n// If second string is empty, only option is to \\n// remove all characters of first string\\n        for(int k=0; k<=word2.size(); k++)\\n            dp[0][k] = k;\\n// Fill dp[][] in bottom up manner \\n        for(int i=1; i<=word1.size(); i++){\\n            for(int j=1; j<=word2.size(); j++){\\n//if characters at current position in 2 strings are equal\\n//there will be no new operation so copy value from previous position\\n                if(word1[i-1] == word2[j-1])\\n                    dp[i][j] = dp[i-1][j-1];\\n// If the last character is different, consider all \\n// possibilities and find the minimum\\n                else\\n                    dp[i][j] = 1 + min({dp[i][j - 1], // Insert \\n                                   dp[i - 1][j], // Remove \\n                                   dp[i - 1][j - 1]}); // Replace \\n            }\\n        }\\n        \\n        return dp[word1.size()][word2.size()];\\n    }\\n```\\n**Upvotes are encouraging**",
                "solutionTags": [],
                "code": "```\\nint minDistance(string word1, string word2) {\\n// Create a table to store results of subproblems\\n        int dp[word1.size()+1][word2.size()+1];\\n// If first string is empty, only option is to \\n// insert all characters of second string \\n        for(int k=0; k<=word1.size(); k++)\\n            dp[k][0] = k;\\n// If second string is empty, only option is to \\n// remove all characters of first string\\n        for(int k=0; k<=word2.size(); k++)\\n            dp[0][k] = k;\\n// Fill dp[][] in bottom up manner \\n        for(int i=1; i<=word1.size(); i++){\\n            for(int j=1; j<=word2.size(); j++){\\n//if characters at current position in 2 strings are equal\\n//there will be no new operation so copy value from previous position\\n                if(word1[i-1] == word2[j-1])\\n                    dp[i][j] = dp[i-1][j-1];\\n// If the last character is different, consider all \\n// possibilities and find the minimum\\n                else\\n                    dp[i][j] = 1 + min({dp[i][j - 1], // Insert \\n                                   dp[i - 1][j], // Remove \\n                                   dp[i - 1][j - 1]}); // Replace \\n            }\\n        }\\n        \\n        return dp[word1.size()][word2.size()];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1217663,
                "title": "edit-distance-cpp-recursive-memoization-top-down-all-approaches-with-explanation",
                "content": "\\nThis problem is little bit tricky but don\\'t worry we will solve it together.\\nBasically, after reading the question carefully we can see that **we have two choices, either the character will be same or not same**.\\n\\n* So, In the first choice, if the character will be same we don\\'t have to do anything except for the fact that we have to call the function for the rest of the string.\\n\\n* For the second choice, if the character will not be the same we have three operations to do inorder to convert the word1 to word2\\n\\t1. Insert a character\\n\\t2. Delete a character\\n\\t3. Replace a character\\n\\nNow, Let\\'s talk about the operations that we have to perform on word1, I\\'m trying from the right side you can try from left also, depends on you.\\n\\n* So, for **Insert operation**, say for ex - we have two strings\\n`s1 = \"abc\" , s2 = \"bcd\" , m = 3 , n = 3` **i.e.** \\nlengths of the strings respectively `m` and `n` are pointing to the last characters of the string. So we will insert a character  from right side in `s1` and after inserting character string will be `\"abcd\"` and the `m` which  was pointing to `c` in `s1` will be at the same position but the `n` which was pointing to `d` in `s2` now, will point to `c` in `s2` i.e. `m, n-1` for the rest of the function calls.\\n\\n* Now, for **Delete operation**, same example\\n`s1 = \"abc\", s2=\"bcd\", m=3, n=3`\\n`m` and `n` are pointing to the last characters of the string. Now, after deleting a character from `s1` , the `m` will be `m-1` , but the `n`  will be same i.e. `m-1, n`  for the rest of the function calls.\\n\\n* Now, for the **Replace operation**, same example\\n`s1 = \"abc\", s2=\"bcd\", m=3, n=3`\\n`m` and `n` are pointing to the last characters of the string. Ultimately, the character at corresponding positions in strings will be the same after replacing the character in `s1` by\\nthe character in `s2`, \\n**Example** - `\"abc\", \"bcd\"` => replacing c by d => `\"abd\", \"bcd\"`\\nNow, call for the rest of the string, so here `m` will be `m-1` and `n` will be `n-1` , i.e. `m-1, n-1` for the rest of the function calls.\\n\\nNow, we have to take minimum of all the three operations and add to 1\\n\\n* And Let\\'s talk about **base conditions**\\n**Example** - `s1 = \"abc\", s2 = \"bcd\", m=3, n=3`  lengths of strings respectively\\n1. if `m = 0` , then Obviously, we have to insert `n`  characters from `s2`  in `s1`  to make `s2`. \\n2. if `n = 0` , then Obviously, we have to delete `m`  characters in `s1`  to make `s2`.\\n\\n**Recursive**\\n```\\nclass Solution {\\npublic:\\n    //Time: O(min(3^m, 3^n)), Space: O(N);\\n    int minDistance(string word1, string word2) {\\n        int m = word1.length(), n = word2.length();\\n        return editDistance(word1, word2, m, n);\\n    }\\n    \\n    int editDistance(string& word1, string& word2, int m, int n){\\n\\t\\t\\n\\t\\t//base condition\\n        if(m == 0) return n;\\n        if(n == 0) return m;\\n        \\n        if(word1[m-1] == word2[n-1]) \\n\\t\\t\\treturn editDistance(word1, word2, m-1, n-1);\\n        else{\\n            int insertChar = editDistance(word1, word2, m, n-1);\\n            int deleteChar = editDistance(word1, word2, m-1, n);\\n            int replaceChar = editDistance(word1, word2, m-1, n-1);\\n            \\n            return 1 + min({insertChar, deleteChar, replaceChar});\\n        }\\n    }\\n};\\n```\\n\\n**Recursive + Memoization - TopDown**\\n```\\nclass Solution {\\npublic:\\n    //Time: O(m*n), Space: O(m*n);\\n    int minDistance(string word1, string word2) {\\n        int m = word1.length(), n = word2.length();\\n        vector<vector<int>> memo(m+1, vector<int>(n+1, -1));\\n        return editDistance(word1, word2, m, n, memo);\\n    }\\n    \\n    int editDistance(string& word1, string& word2, int m, int n, vector<vector<int>>& memo){\\n        if(m == 0) return memo[m][n] = n;\\n        if(n == 0) return memo[m][n] = m;\\n        \\n        if(memo[m][n] != -1)\\n            return memo[m][n];\\n        \\n        if(word1[m-1] == word2[n-1]) \\n            return memo[m][n] = editDistance(word1, word2, m-1, n-1, memo);\\n        else{\\n            int insertChar = editDistance(word1, word2, m, n-1, memo);\\n            int deleteChar = editDistance(word1, word2, m-1, n, memo);\\n            int replaceChar = editDistance(word1, word2, m-1, n-1, memo);\\n            \\n            return memo[m][n] = 1 + min({insertChar, deleteChar, replaceChar});\\n        }\\n    }\\n};\\n```\\n\\n**BottomUp**\\n```\\nclass Solution {\\npublic:\\n    //Time: O(m*n), Space: O(m*n);\\n    int minDistance(string word1, string word2) {\\n        int m = word1.length(), n = word2.length();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));\\n        \\n        //Base conditions\\n        for(int i=0; i<m+1; i++)\\n            dp[i][0] = i;\\n        \\n        for(int j=0; j<n+1; j++)\\n            dp[0][j] = j;\\n        \\n        //solving the sub-problems\\n        for(int i=1; i<m+1; i++){\\n            for(int j=1; j<n+1; j++){\\n                if(word1[i-1] == word2[j-1])\\n                    dp[i][j] = dp[i-1][j-1];\\n                else{\\n                    int insertChar = dp[i][j-1];\\n                    int deleteChar = dp[i-1][j];\\n                    int replaceChar = dp[i-1][j-1];\\n                    \\n                    dp[i][j] = 1 + min({insertChar, deleteChar, replaceChar});\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Time: O(min(3^m, 3^n)), Space: O(N);\\n    int minDistance(string word1, string word2) {\\n        int m = word1.length(), n = word2.length();\\n        return editDistance(word1, word2, m, n);\\n    }\\n    \\n    int editDistance(string& word1, string& word2, int m, int n){\\n\\t\\t\\n\\t\\t//base condition\\n        if(m == 0) return n;\\n        if(n == 0) return m;\\n        \\n        if(word1[m-1] == word2[n-1]) \\n\\t\\t\\treturn editDistance(word1, word2, m-1, n-1);\\n        else{\\n            int insertChar = editDistance(word1, word2, m, n-1);\\n            int deleteChar = editDistance(word1, word2, m-1, n);\\n            int replaceChar = editDistance(word1, word2, m-1, n-1);\\n            \\n            return 1 + min({insertChar, deleteChar, replaceChar});\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    //Time: O(m*n), Space: O(m*n);\\n    int minDistance(string word1, string word2) {\\n        int m = word1.length(), n = word2.length();\\n        vector<vector<int>> memo(m+1, vector<int>(n+1, -1));\\n        return editDistance(word1, word2, m, n, memo);\\n    }\\n    \\n    int editDistance(string& word1, string& word2, int m, int n, vector<vector<int>>& memo){\\n        if(m == 0) return memo[m][n] = n;\\n        if(n == 0) return memo[m][n] = m;\\n        \\n        if(memo[m][n] != -1)\\n            return memo[m][n];\\n        \\n        if(word1[m-1] == word2[n-1]) \\n            return memo[m][n] = editDistance(word1, word2, m-1, n-1, memo);\\n        else{\\n            int insertChar = editDistance(word1, word2, m, n-1, memo);\\n            int deleteChar = editDistance(word1, word2, m-1, n, memo);\\n            int replaceChar = editDistance(word1, word2, m-1, n-1, memo);\\n            \\n            return memo[m][n] = 1 + min({insertChar, deleteChar, replaceChar});\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    //Time: O(m*n), Space: O(m*n);\\n    int minDistance(string word1, string word2) {\\n        int m = word1.length(), n = word2.length();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));\\n        \\n        //Base conditions\\n        for(int i=0; i<m+1; i++)\\n            dp[i][0] = i;\\n        \\n        for(int j=0; j<n+1; j++)\\n            dp[0][j] = j;\\n        \\n        //solving the sub-problems\\n        for(int i=1; i<m+1; i++){\\n            for(int j=1; j<n+1; j++){\\n                if(word1[i-1] == word2[j-1])\\n                    dp[i][j] = dp[i-1][j-1];\\n                else{\\n                    int insertChar = dp[i][j-1];\\n                    int deleteChar = dp[i-1][j];\\n                    int replaceChar = dp[i-1][j-1];\\n                    \\n                    dp[i][j] = 1 + min({insertChar, deleteChar, replaceChar});\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1475220,
                "title": "python-3-solutions-top-down-dp-bottom-up-dp-o-n-in-space-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Top down DP**\\n- Let `dp(i, j)` is the minimum number of operations required to convert `s1[0..i-1]` string to `s2[0..j-1]` string.\\n- Then `dp(len(s1), len(s2))` is our result.\\n- To compute `dp(i, j)`:\\n\\t- Base case: \\n\\t\\t- If `i == 0` then we need to insert `j` chars to convert `\"\"` into `s2[0..j-1]`\\n\\t\\t- If `j == 0` then we need to delete `i` chars to convert `s1[0..i-1]` into `\"\"`.\\n\\t- If `s1[i-1] == s2[j-1]` then `dp(i, j) = dp(i-1, j-1)`.\\n\\t- Else: Choose the minimum cost among 3 operators\\n\\t\\t- Delete: `dp(i-1, j) + 1`\\n\\t\\t- Insert: `dp(i, j-1) + 1`\\n\\t\\t- Replace: `dp(i-1, j-1) + 1`\\n```python\\nclass Solution:\\n    def minDistance(self, s1: str, s2: str) -> int:\\n        @lru_cache(None)\\n        def dp(i, j):\\n            if i == 0: return j  # Need to insert j chars\\n            if j == 0: return i  # Need to delete i chars\\n            if s1[i-1] == s2[j-1]:\\n                return dp(i-1, j-1)\\n            return min(dp(i-1, j), dp(i, j-1), dp(i-1, j-1)) + 1\\n        \\n        return dp(len(s1), len(s2))\\n```\\nComplexity:\\n- Time: `O(M*N)`, where `M <= 500` is length of `s1` string, `N <= 500` is length of `s2` string.\\n- Space: `O(M*N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Bottom up DP**\\n- Just convert **Top down DP** into **Bottom up DP**.\\n```python\\nclass Solution:\\n    def minDistance(self, s1: str, s2: str) -> int:\\n        m, n = len(s1), len(s2)\\n        dp = [[-1] * (n+1) for _ in range(m+1)]\\n        for i in range(m+1):\\n            for j in range(n+1):\\n                if i == 0:\\n                    dp[i][j] = j  # Need to insert `j` chars to become s2[:j]\\n                elif j == 0:\\n                    dp[i][j] = i  # Need to delete `i` chars to become \"\"\\n                elif s1[i-1] == s2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\\n        return dp[m][n]\\n```\\nComplexity:\\n- Time: `O(M*N)`, where `M <= 500` is length of `s1` string, `N <= 500` is length of `s2` string.\\n- Space: `O(M*N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 3: Bottom up DP (Space Optimized)**\\n- Since we build our dp rows by rows, we access only previous dp state `dpPrev` and current dp state `dp`.\\n- So we can optimize to `O(N)` in Space Complexity.\\n```python\\nclass Solution:\\n    def minDistance(self, s1: str, s2: str) -> int:\\n        m, n = len(s1), len(s2)\\n        dp, dpPrev = [-1] * (n+1), [-1] * (n+1)\\n        for i in range(m+1):\\n            for j in range(n+1):\\n                if i == 0:\\n                    dp[j] = j  # Need to insert `j` chars to become s2[:j]\\n                elif j == 0:\\n                    dp[j] = i  # Need to delete `i` chars to become \"\"\\n                elif s1[i-1] == s2[j-1]:\\n                    dp[j] = dpPrev[j-1]\\n                else:\\n                    dp[j] = min(dpPrev[j], dp[j-1], dpPrev[j-1]) + 1\\n            dp, dpPrev = dpPrev, dp\\n        return dpPrev[n]\\n```\\nComplexity:\\n- Time: `O(M*N)`, where `M <= 500` is length of `s1` string, `N <= 500` is length of `s2` string.\\n- Space: `O(N)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minDistance(self, s1: str, s2: str) -> int:\\n        @lru_cache(None)\\n        def dp(i, j):\\n            if i == 0: return j  # Need to insert j chars\\n            if j == 0: return i  # Need to delete i chars\\n            if s1[i-1] == s2[j-1]:\\n                return dp(i-1, j-1)\\n            return min(dp(i-1, j), dp(i, j-1), dp(i-1, j-1)) + 1\\n        \\n        return dp(len(s1), len(s2))\\n```\n```python\\nclass Solution:\\n    def minDistance(self, s1: str, s2: str) -> int:\\n        m, n = len(s1), len(s2)\\n        dp = [[-1] * (n+1) for _ in range(m+1)]\\n        for i in range(m+1):\\n            for j in range(n+1):\\n                if i == 0:\\n                    dp[i][j] = j  # Need to insert `j` chars to become s2[:j]\\n                elif j == 0:\\n                    dp[i][j] = i  # Need to delete `i` chars to become \"\"\\n                elif s1[i-1] == s2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\\n        return dp[m][n]\\n```\n```python\\nclass Solution:\\n    def minDistance(self, s1: str, s2: str) -> int:\\n        m, n = len(s1), len(s2)\\n        dp, dpPrev = [-1] * (n+1), [-1] * (n+1)\\n        for i in range(m+1):\\n            for j in range(n+1):\\n                if i == 0:\\n                    dp[j] = j  # Need to insert `j` chars to become s2[:j]\\n                elif j == 0:\\n                    dp[j] = i  # Need to delete `i` chars to become \"\"\\n                elif s1[i-1] == s2[j-1]:\\n                    dp[j] = dpPrev[j-1]\\n                else:\\n                    dp[j] = min(dpPrev[j], dp[j-1], dpPrev[j-1]) + 1\\n            dp, dpPrev = dpPrev, dp\\n        return dpPrev[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 501094,
                "title": "c-recursive-memoization-and-tabulation-method",
                "content": "Recursive \\n```\\nclass Solution {\\npublic:\\n    \\n    int editDis(string& word1, string& word2, int n1, int n2)\\n    {\\n        if(n1 == 0)\\n            return n2;\\n        if(n2 == 0)\\n            return n1;\\n       // cout<<n1<<\" \"<<n2<<endl;\\n        if(word1[n1-1] == word2[n2-1]) {\\n            return editDis(word1, word2, n1-1, n2-1);\\n        }\\n            \\n        return 1+min(editDis(word1, word2, n1, n2-1),\\n                  min(editDis(word1, word2, n1-1, n2),\\n                  editDis(word1, word2, n1-1, n2-1)));\\n    }\\n    \\n    int minDistance(string word1, string word2) {\\n        int n1 = word1.size();\\n        int n2 = word2.size();\\n        return editDis(word1, word2, n1, n2);\\n        \\n    }\\n};\\n```\\nMemoization:\\n```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    \\n    int editDis(string& word1, string& word2, int n1, int n2)\\n    {\\n        if(n1 == 0)\\n            return n2;\\n        if(n2 == 0)\\n            return n1;\\n       // cout<<n1<<\" \"<<n2<<endl;\\n        if(dp[n1][n2] !=-1)\\n        {\\n            return dp[n1][n2];\\n        }\\n        if(word1[n1-1] == word2[n2-1]) {\\n            dp[n1][n2] = editDis(word1, word2, n1-1, n2-1);\\n            return dp[n1][n2];\\n        }\\n            \\n        dp[n1][n2]=  1+min(editDis(word1, word2, n1, n2-1),\\n                  min(editDis(word1, word2, n1-1, n2),\\n                  editDis(word1, word2, n1-1, n2-1)));\\n        return dp[n1][n2];\\n    }\\n    \\n    int minDistance(string word1, string word2) {\\n        int n1 = word1.size();\\n        int n2 = word2.size();\\n        for(int i=0;i<=n1+1;i++)\\n        {\\n            for(int j=0;j<=n2+1;j++)\\n            {\\n                dp[i][j] = -1;\\n            }\\n        }\\n        dp[n1][n2] = editDis(word1, word2, n1, n2);\\n        return dp[n1][n2];\\n        \\n    }\\n};\\n```\\n\\nTabulation\\n```\\nclass Solution {\\npublic:    \\n    int minDistance(string word1, string word2) {\\n        int n1 = word1.size();\\n        int n2 = word2.size();\\n        int dp[n1+2][n2+2];\\n        \\n        for(int i=0;i<n1+1;i++)\\n        {\\n             dp[i][0] = i;\\n        }\\n        \\n        for(int i=0;i<n2+1;i++)\\n        {\\n             dp[0][i] = i;\\n        }\\n        \\n        for(int i=1;i<n1+1;i++)\\n        {\\n            for(int j=1;j<n2+1;j++)\\n            {\\n                if(word1[i-1] == word2[j-1])\\n                {\\n                    dp[i][j] = dp[i-1][j-1];\\n                } else {\\n                  dp[i][j] = 1+min(dp[i-1][j],min(dp[i][j-1], dp[i-1][j-1]));\\n                }\\n            }\\n        }\\n        return dp[n1][n2];\\n\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int editDis(string& word1, string& word2, int n1, int n2)\\n    {\\n        if(n1 == 0)\\n            return n2;\\n        if(n2 == 0)\\n            return n1;\\n       // cout<<n1<<\" \"<<n2<<endl;\\n        if(word1[n1-1] == word2[n2-1]) {\\n            return editDis(word1, word2, n1-1, n2-1);\\n        }\\n            \\n        return 1+min(editDis(word1, word2, n1, n2-1),\\n                  min(editDis(word1, word2, n1-1, n2),\\n                  editDis(word1, word2, n1-1, n2-1)));\\n    }\\n    \\n    int minDistance(string word1, string word2) {\\n        int n1 = word1.size();\\n        int n2 = word2.size();\\n        return editDis(word1, word2, n1, n2);\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    \\n    int editDis(string& word1, string& word2, int n1, int n2)\\n    {\\n        if(n1 == 0)\\n            return n2;\\n        if(n2 == 0)\\n            return n1;\\n       // cout<<n1<<\" \"<<n2<<endl;\\n        if(dp[n1][n2] !=-1)\\n        {\\n            return dp[n1][n2];\\n        }\\n        if(word1[n1-1] == word2[n2-1]) {\\n            dp[n1][n2] = editDis(word1, word2, n1-1, n2-1);\\n            return dp[n1][n2];\\n        }\\n            \\n        dp[n1][n2]=  1+min(editDis(word1, word2, n1, n2-1),\\n                  min(editDis(word1, word2, n1-1, n2),\\n                  editDis(word1, word2, n1-1, n2-1)));\\n        return dp[n1][n2];\\n    }\\n    \\n    int minDistance(string word1, string word2) {\\n        int n1 = word1.size();\\n        int n2 = word2.size();\\n        for(int i=0;i<=n1+1;i++)\\n        {\\n            for(int j=0;j<=n2+1;j++)\\n            {\\n                dp[i][j] = -1;\\n            }\\n        }\\n        dp[n1][n2] = editDis(word1, word2, n1, n2);\\n        return dp[n1][n2];\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:    \\n    int minDistance(string word1, string word2) {\\n        int n1 = word1.size();\\n        int n2 = word2.size();\\n        int dp[n1+2][n2+2];\\n        \\n        for(int i=0;i<n1+1;i++)\\n        {\\n             dp[i][0] = i;\\n        }\\n        \\n        for(int i=0;i<n2+1;i++)\\n        {\\n             dp[0][i] = i;\\n        }\\n        \\n        for(int i=1;i<n1+1;i++)\\n        {\\n            for(int j=1;j<n2+1;j++)\\n            {\\n                if(word1[i-1] == word2[j-1])\\n                {\\n                    dp[i][j] = dp[i-1][j-1];\\n                } else {\\n                  dp[i][j] = 1+min(dp[i-1][j],min(dp[i][j-1], dp[i-1][j-1]));\\n                }\\n            }\\n        }\\n        return dp[n1][n2];\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 274951,
                "title": "python-classic-dp",
                "content": "Suppose ```dp[i][j]``` records the edit distance between ```word1[:i]``` and ```word2[:j]```. And now we proceed to ```word1[i]``` and ```word2[j]```. \\n1. If they are equal, then edit distance between ```word1[:i+1]``` and  ```word2[:j+1]``` are the same as ```dp[i][j]```. Or ```dp[i+1][j+1] = dp[i][j]```.\\n2. Otherwise, we need to determine which of \"delete\", \"insert\", \"replace\" produces the lowest edit distance. Since each operation cost 1 distance, \"delete\"\\'s cost is 1 extra distance plus edit distance between ```word1[:i]``` and ```word2[:j+1]``` as we delete ```word1[i]```. Or ```dp[i+1][j+1] = dp[i][j+1]+1```. Similiarly, \"insert\" produces ```dp[i+1][j+1] = dp[i+1][j]+1``` and \"replace\" produces ```dp[i+1][j+1] = dp[i][j]+1```. And we just pick the minimum from these three.\\n\\nThus, our recurrsion equation is \\n```\\ndp[i+1][j+1] = dp[i][j] if word1[i]==word2[j] else min(dp[i][j], dp[i+1][j], dp[i][j+1]) + 1\\n```\\nOne head row and left column are inserted in dp array for base. We can viewed it as each word has an empty string at the begining and empty string is not equal to any character. So initially, ```dp[0][j] = j``` and ```dp[i][0] = i```\\n```\\ndef minDistance(word1, word2):\\n\\tm, n = len(word1), len(word2)\\n\\tdp = [list(range(n+1))]+[[r+1]+[0]*n for r in range(m)]\\n\\tfor i in range(m):\\n\\t\\tfor j in range(n):\\n\\t\\t\\tdp[i+1][j+1] = dp[i][j] if word1[i]==word2[j] else min(dp[i][j], dp[i+1][j], dp[i][j+1]) + 1\\n\\treturn dp[m][n]\\n```\\nBoth time and space complexity is O(mn). m, n stands for length of word1 and word2.\\nAnd we can implement a rolling1D DP since only two rows of DP table are actually used. So space complexity could be reduced to O(min(m,n)):\\n```\\ndef minDistance(word1, word2):\\n\\tm, n = len(word1), len(word2)  # switch word1 and word2 if m < n to ensure n \\u2264 m\\n\\tcurr = list(range(n+1))\\n\\tfor i in range(m):\\n\\t\\tprev, curr = curr, [i+1] + [0] * n\\n\\t\\tfor j in range(n):\\n\\t\\t\\tcurr[j+1] = prev[j] if word1[i] == word2[j] else min(curr[j], prev[j], prev[j+1]) + 1\\n\\treturn curr[n]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```dp[i][j]```\n```word1[:i]```\n```word2[:j]```\n```word1[i]```\n```word2[j]```\n```word1[:i+1]```\n```word2[:j+1]```\n```dp[i][j]```\n```dp[i+1][j+1] = dp[i][j]```\n```word1[:i]```\n```word2[:j+1]```\n```word1[i]```\n```dp[i+1][j+1] = dp[i][j+1]+1```\n```dp[i+1][j+1] = dp[i+1][j]+1```\n```dp[i+1][j+1] = dp[i][j]+1```\n```\\ndp[i+1][j+1] = dp[i][j] if word1[i]==word2[j] else min(dp[i][j], dp[i+1][j], dp[i][j+1]) + 1\\n```\n```dp[0][j] = j```\n```dp[i][0] = i```\n```\\ndef minDistance(word1, word2):\\n\\tm, n = len(word1), len(word2)\\n\\tdp = [list(range(n+1))]+[[r+1]+[0]*n for r in range(m)]\\n\\tfor i in range(m):\\n\\t\\tfor j in range(n):\\n\\t\\t\\tdp[i+1][j+1] = dp[i][j] if word1[i]==word2[j] else min(dp[i][j], dp[i+1][j], dp[i][j+1]) + 1\\n\\treturn dp[m][n]\\n```\n```\\ndef minDistance(word1, word2):\\n\\tm, n = len(word1), len(word2)  # switch word1 and word2 if m < n to ensure n \\u2264 m\\n\\tcurr = list(range(n+1))\\n\\tfor i in range(m):\\n\\t\\tprev, curr = curr, [i+1] + [0] * n\\n\\t\\tfor j in range(n):\\n\\t\\t\\tcurr[j+1] = prev[j] if word1[i] == word2[j] else min(curr[j], prev[j], prev[j+1]) + 1\\n\\treturn curr[n]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 25959,
                "title": "my-accepted-java-solution",
                "content": "Hi: \\n\\nThis is a very interesting question and I found a [youtube video][1] that helps a lot.\\nBasically the idea is to build up the solution step by step and keep track of the previous optimal solution in a 2D array. In this 2D array dp, dp[i][j] means the operation needed to transform word1(0, i) to word2(0,j). \\n\\nThere can be three conditions:\\n\\n1, word1[i] == word2[j] : then no operation needed. dp[i][j] == dp[i-1][j-1]\\n\\n2, Do one operation on word1[i-1][j]. dp[i][j] = dp[i-1][j] + 1\\n\\n3, Do one operation on word2[i][j-1]. dp[i][j] = dp[i][j-1] + 1\\n\\nfor 2 and 3, the reason it works is that we know the optimal ways to transfrom word1(0,i) to word2(0,j-1) and word1(0,i-1) to word(0,j) ( Delete (\"abc\" to \"ab\") or Insert (\"ab\" to \"abc\") ). Now all we need to one more operation.\\n\\nThe code will be:\\n\\n    public int minDistance(String word1, String word2) {\\n        if (word1.equals(word2)) {\\n            return 0;\\n        }\\n        if (word1.length() == 0 || word2.length() == 0) {\\n            return Math.abs(word1.length() - word2.length());\\n        }\\n        int[][] dp = new int[word1.length() + 1][word2.length() + 1];\\n        for (int i = 0; i <= word1.length(); i++) {\\n            dp[i][0] = i;\\n        }\\n        for (int i = 0; i <= word2.length(); i++) {\\n            dp[0][i] = i;\\n        }\\n        for (int i = 1; i <= word1.length(); i++) {\\n            for (int j = 1; j <= word2.length(); j++) {\\n                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                } else {\\n                    dp[i][j] = Math.min(dp[i-1][j-1], Math.min(dp[i-1][j], dp[i][j-1])) + 1;\\n                }\\n            }\\n        }\\n        return dp[word1.length()][word2.length()];\\n    }\\n\\n Remeber that we start from dp[0][0], which is an empty string to an empty string. \\n\\n\\n  [1]: https://www.youtube.com/watch?v=z_CB7Gih_Mg",
                "solutionTags": [],
                "code": "Hi: \\n\\nThis is a very interesting question and I found a [youtube video][1] that helps a lot.\\nBasically the idea is to build up the solution step by step and keep track of the previous optimal solution in a 2D array. In this 2D array dp, dp[i][j] means the operation needed to transform word1(0, i) to word2(0,j). \\n\\nThere can be three conditions:\\n\\n1, word1[i] == word2[j] : then no operation needed. dp[i][j] == dp[i-1][j-1]\\n\\n2, Do one operation on word1[i-1][j]. dp[i][j] = dp[i-1][j] + 1\\n\\n3, Do one operation on word2[i][j-1]. dp[i][j] = dp[i][j-1] + 1\\n\\nfor 2 and 3, the reason it works is that we know the optimal ways to transfrom word1(0,i) to word2(0,j-1) and word1(0,i-1) to word(0,j) ( Delete (\"abc\" to \"ab\") or Insert (\"ab\" to \"abc\") ). Now all we need to one more operation.\\n\\nThe code will be:\\n\\n    public int minDistance(String word1, String word2) {\\n        if (word1.equals(word2)) {\\n            return 0;\\n        }\\n        if (word1.length() == 0 || word2.length() == 0) {\\n            return Math.abs(word1.length() - word2.length());\\n        }\\n        int[][] dp = new int[word1.length() + 1][word2.length() + 1];\\n        for (int i = 0; i <= word1.length(); i++) {\\n            dp[i][0] = i;\\n        }\\n        for (int i = 0; i <= word2.length(); i++) {\\n            dp[0][i] = i;\\n        }\\n        for (int i = 1; i <= word1.length(); i++) {\\n            for (int j = 1; j <= word2.length(); j++) {\\n                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                } else {\\n                    dp[i][j] = Math.min(dp[i-1][j-1], Math.min(dp[i-1][j], dp[i][j-1])) + 1;\\n                }\\n            }\\n        }\\n        return dp[word1.length()][word2.length()];\\n    }\\n\\n Remeber that we start from dp[0][0], which is an empty string to an empty string. \\n\\n\\n  [1]: https://www.youtube.com/watch?v=z_CB7Gih_Mg",
                "codeTag": "Unknown"
            },
            {
                "id": 1596206,
                "title": "java-dp-detailed-explanation-easy-to-understand",
                "content": "### Explanation:\\n\\n![image](https://assets.leetcode.com/users/images/70ee0a89-9a54-44b2-8106-70ef5054f543_1637868770.0880988.jpeg)\\n![image](https://assets.leetcode.com/users/images/89dc90b2-7c8e-4aee-82c8-b4988e78ed06_1637868770.3484263.jpeg)\\n![image](https://assets.leetcode.com/users/images/676e42a2-e7bd-4df2-9010-524be2f91a36_1637868769.804625.jpeg)\\n\\n<br/>\\n\\n### Code:\\n\\n```\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        int l1 = word1.length();\\n        int l2 = word2.length();\\n        int[][] dp = new int[l1+1][l2+1];\\n        \\n        // Base cases\\n        // Initializing First row\\n        for(int i=0; i <= l2; i++)\\n            dp[0][i] = i;        \\n        // Initializing First col\\n        for(int i=0; i <= l1; i++)\\n            dp[i][0] = i;\\n        \\n        for(int i=1; i <= l1; i++){\\n            for(int j=1; j <= l2; j++){\\n                if(word1.charAt(i-1) == word2.charAt(j-1))\\n                    dp[i][j] = dp[i-1][j-1];\\n                else\\n                    dp[i][j] = 1 + Math.min(dp[i-1][j-1], // replace\\n                                            Math.min(dp[i-1][j], // delete\\n                                                     dp[i][j-1]) // insert\\n                                           ); \\n            }\\n        }\\n        \\n        return dp[l1][l2];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        int l1 = word1.length();\\n        int l2 = word2.length();\\n        int[][] dp = new int[l1+1][l2+1];\\n        \\n        // Base cases\\n        // Initializing First row\\n        for(int i=0; i <= l2; i++)\\n            dp[0][i] = i;        \\n        // Initializing First col\\n        for(int i=0; i <= l1; i++)\\n            dp[i][0] = i;\\n        \\n        for(int i=1; i <= l1; i++){\\n            for(int j=1; j <= l2; j++){\\n                if(word1.charAt(i-1) == word2.charAt(j-1))\\n                    dp[i][j] = dp[i-1][j-1];\\n                else\\n                    dp[i][j] = 1 + Math.min(dp[i-1][j-1], // replace\\n                                            Math.min(dp[i-1][j], // delete\\n                                                     dp[i][j-1]) // insert\\n                                           ); \\n            }\\n        }\\n        \\n        return dp[l1][l2];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25951,
                "title": "standard-dp-solution",
                "content": "    int minDistance(string word1, string word2) {\\n        int  m = word1.length(), n = word2.length();\\n        if (m == 0) return n;\\n        if (n == 0) return m;\\n        \\n        // table[i][j]: distance from words1.substr(0, i) to words2.substr(0, j) \\n        int table[m+1][n+1];\\n        for (int i = 0; i <= m; ++i) table[i][0] = i;\\n        for (int j = 0; j <= n; ++j) table[0][j] = j;\\n        // table[i][j] is the min distance between the next three values\\n        // from table[i-1][j], table[i][j-1], or table[i-1][j-1] to table[i][j]\\n        for (int i = 1; i <= m; ++i) {\\n            for (int j = 1; j <= n; ++j) {\\n                int cost = (word1[i-1] == word2[j-1] ? 0 : 1);\\n                table[i][j] = min(min(table[i-1][j] + 1, table[i][j-1] + 1), table[i-1][j-1] + cost);\\n            }\\n        }\\n        \\n        return table[m][n];\\n    }",
                "solutionTags": [],
                "code": "    int minDistance(string word1, string word2) {\\n        int  m = word1.length(), n = word2.length();\\n        if (m == 0) return n;\\n        if (n == 0) return m;\\n        \\n        // table[i][j]: distance from words1.substr(0, i) to words2.substr(0, j) \\n        int table[m+1][n+1];\\n        for (int i = 0; i <= m; ++i) table[i][0] = i;\\n        for (int j = 0; j <= n; ++j) table[0][j] = j;\\n        // table[i][j] is the min distance between the next three values\\n        // from table[i-1][j], table[i][j-1], or table[i-1][j-1] to table[i][j]\\n        for (int i = 1; i <= m; ++i) {\\n            for (int j = 1; j <= n; ++j) {\\n                int cost = (word1[i-1] == word2[j-1] ? 0 : 1);\\n                table[i][j] = min(min(table[i-1][j] + 1, table[i][j-1] + 1), table[i-1][j-1] + cost);\\n            }\\n        }\\n        \\n        return table[m][n];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 25896,
                "title": "easy-to-understand-recursive-dp-solution-beats-99-6",
                "content": "```\\npublic class Solution {\\n    int[][] dp;\\n    \\n    public int minDistance(String word1, String word2) {\\n\\tdp = new int[word1.length()][word2.length()];\\n\\t    \\n        return minDistanceHelper(word1, word2, 0, 0);\\n    }\\n    \\n    private int minDistanceHelper(String word1, String word2, int index1, int index2) {\\n        if (index1 == word1.length()) return word2.length() - index2;\\n        if (index2 == word2.length()) return word1.length() - index1;\\n\\t    \\n\\tif (dp[index1][index2] > 0) return dp[index1][index2];\\n        \\n        int result;\\n        if (word1.charAt(index1) == word2.charAt(index2)) {\\n            result = minDistanceHelper(word1, word2, index1+1, index2+1);\\n        } else {\\n            // replace char\\n            result = 1 + minDistanceHelper(word1, word2, index1+1, index2+1);\\n            \\n            // delete char from word1\\n            result = Math.min(result, 1 + minDistanceHelper(word1, word2, index1+1, index2));\\n            \\n            // delete char from word2\\n            result = Math.min(result, 1 + minDistanceHelper(word1, word2, index1, index2+1));\\n        }\\n        \\n\\tdp[index1][index2] = result;\\n\\treturn result;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "class Solution {\\n    int[][] dp;\\n    \\n    public int minDistance(String word1, String word2) {\\n\\tdp = new int[word1.length()][word2.length()];\\n\\t    \\n        return minDistanceHelper(word1, word2, 0, 0);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2992667,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    \\n    int solve(int i, int j, string &s, string &t){\\n        if(i<0 && j<0)\\n            return 0;\\n        \\n        if(i < 0 && j>=0){\\n            return j+1;\\n        }\\n        \\n        if(i>=0 && j<0){\\n            return i+1;\\n        }\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        int l = 1000, r = 1000, z = 1000, p = 1000;\\n        if(s[i] == t[j]){\\n            l = solve(i-1,j-1,s,t);\\n        }\\n        else{\\n            r = 1 + solve(i-1,j,s,t);\\n            z = 1 + solve(i-1,j-1,s,t);\\n            p = 1 + solve(i,j-1,s,t);\\n        }\\n        \\n        return dp[i][j] = min(l,min(r,min(z,p)));\\n    }\\n    \\n    \\n    int minDistance(string s, string t) {\\n        dp.resize(s.size()+1,vector<int>(t.size()+1,-1));\\n        return solve(s.size(),t.size(),s,t);\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        n = len(word1)\\n        m = len(word2)\\n        \\n        to_visit = [(0, 0)]\\n        visited = set()\\n        dist = 0\\n        while to_visit:\\n            nxt_lvl = []\\n            while to_visit:\\n                i, j = to_visit.pop()\\n                if (i, j) in visited:\\n                    continue\\n                while i < n and j < m and word1[i] == word2[j]:\\n                    i += 1\\n                    j += 1\\n                if i == n and j == m:\\n                    return dist\\n                if (i, j + 1) not in visited:\\n                    nxt_lvl.append((i, j + 1))\\n                if (i + 1, j) not in visited:\\n                    nxt_lvl.append((i + 1, j))\\n                if (i + 1, j + 1) not in visited:\\n                    nxt_lvl.append((i + 1, j + 1))\\n                visited.add((i, j))\\n            dist += 1\\n            to_visit = nxt_lvl\\n```\\n\\n```Java []\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        if (word1.length() < word2.length()) {\\n            return minDistance(word2, word1);\\n        }\\n        char[] w1 = word1.toCharArray(), w2 = word2.toCharArray();\\n        int[] dp = new int[w2.length];\\n        int last = 0;\\n        int diag = 0;\\n        for (int i = 0; i < dp.length; i++) {\\n            dp[i] = dp.length - i;\\n        }\\n        for (int i = w1.length - 1; i > -1; i--) {\\n            last = w1.length - i;\\n            diag = w1.length - 1 - i;\\n            for (int j = w2.length - 1; j > -1; j--) {\\n                int tmp = dp[j];\\n                if (w1[i] == w2[j]) {\\n                    last = dp[j] = diag;\\n                } else {\\n                    last = dp[j] = Math.min(diag, Math.min(dp[j], last)) + 1;\\n                }\\n                diag = tmp;\\n            }\\n        }\\n        return last;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    \\n    int solve(int i, int j, string &s, string &t){\\n        if(i<0 && j<0)\\n            return 0;\\n        \\n        if(i < 0 && j>=0){\\n            return j+1;\\n        }\\n        \\n        if(i>=0 && j<0){\\n            return i+1;\\n        }\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        int l = 1000, r = 1000, z = 1000, p = 1000;\\n        if(s[i] == t[j]){\\n            l = solve(i-1,j-1,s,t);\\n        }\\n        else{\\n            r = 1 + solve(i-1,j,s,t);\\n            z = 1 + solve(i-1,j-1,s,t);\\n            p = 1 + solve(i,j-1,s,t);\\n        }\\n        \\n        return dp[i][j] = min(l,min(r,min(z,p)));\\n    }\\n    \\n    \\n    int minDistance(string s, string t) {\\n        dp.resize(s.size()+1,vector<int>(t.size()+1,-1));\\n        return solve(s.size(),t.size(),s,t);\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        n = len(word1)\\n        m = len(word2)\\n        \\n        to_visit = [(0, 0)]\\n        visited = set()\\n        dist = 0\\n        while to_visit:\\n            nxt_lvl = []\\n            while to_visit:\\n                i, j = to_visit.pop()\\n                if (i, j) in visited:\\n                    continue\\n                while i < n and j < m and word1[i] == word2[j]:\\n                    i += 1\\n                    j += 1\\n                if i == n and j == m:\\n                    return dist\\n                if (i, j + 1) not in visited:\\n                    nxt_lvl.append((i, j + 1))\\n                if (i + 1, j) not in visited:\\n                    nxt_lvl.append((i + 1, j))\\n                if (i + 1, j + 1) not in visited:\\n                    nxt_lvl.append((i + 1, j + 1))\\n                visited.add((i, j))\\n            dist += 1\\n            to_visit = nxt_lvl\\n```\n```Java []\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        if (word1.length() < word2.length()) {\\n            return minDistance(word2, word1);\\n        }\\n        char[] w1 = word1.toCharArray(), w2 = word2.toCharArray();\\n        int[] dp = new int[w2.length];\\n        int last = 0;\\n        int diag = 0;\\n        for (int i = 0; i < dp.length; i++) {\\n            dp[i] = dp.length - i;\\n        }\\n        for (int i = w1.length - 1; i > -1; i--) {\\n            last = w1.length - i;\\n            diag = w1.length - 1 - i;\\n            for (int j = w2.length - 1; j > -1; j--) {\\n                int tmp = dp[j];\\n                if (w1[i] == w2[j]) {\\n                    last = dp[j] = diag;\\n                } else {\\n                    last = dp[j] = Math.min(diag, Math.min(dp[j], last)) + 1;\\n                }\\n                diag = tmp;\\n            }\\n        }\\n        return last;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25879,
                "title": "python-easy-to-understand-dp-solutions-o-m-n-o-n-space",
                "content": "```\\nclass Solution(object):\\n    # O(n) space\\n    def minDistance(self, word1, word2):\\n        h, w = len(word1)+1, len(word2)+1\\n        pre = [i for i in range(w)]\\n        for i in range(1, h):\\n            cur = [i for _ in range(w)]\\n            for j in range(1, w):\\n                cur[j] = min(pre[j-1]+(word1[i-1] != word2[j-1]), pre[j]+1, cur[j-1]+1)\\n            pre = cur\\n        return pre[-1]\\n    \\n    # O(m*n) space\\n    def minDistance1(self, word1, word2):\\n        h, w = len(word1)+1, len(word2)+1\\n        dp = [[0 for _ in range(w)] for _ in range(h)]\\n        for i in range(h):\\n            dp[i][0] = i\\n        for j in range(w):\\n            dp[0][j] = j\\n        for i in range(1, h):\\n            for j in range(1, w):\\n                dp[i][j] = min(dp[i-1][j-1]+(word1[i-1]!=word2[j-1]), dp[i-1][j]+1, dp[i][j-1]+1)\\n        return dp[-1][-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    # O(n) space\\n    def minDistance(self, word1, word2):\\n        h, w = len(word1)+1, len(word2)+1\\n        pre = [i for i in range(w)]\\n        for i in range(1, h):\\n            cur = [i for _ in range(w)]\\n            for j in range(1, w):\\n                cur[j] = min(pre[j-1]+(word1[i-1] != word2[j-1]), pre[j]+1, cur[j-1]+1)\\n            pre = cur\\n        return pre[-1]\\n    \\n    # O(m*n) space\\n    def minDistance1(self, word1, word2):\\n        h, w = len(word1)+1, len(word2)+1\\n        dp = [[0 for _ in range(w)] for _ in range(h)]\\n        for i in range(h):\\n            dp[i][0] = i\\n        for j in range(w):\\n            dp[0][j] = j\\n        for i in range(1, h):\\n            for j in range(1, w):\\n                dp[i][j] = min(dp[i-1][j-1]+(word1[i-1]!=word2[j-1]), dp[i-1][j]+1, dp[i][j-1]+1)\\n        return dp[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25914,
                "title": "concise-java-dp-solution-with-comments",
                "content": "    public int minDistance(String word1, String word2) {\\n    \\t// dp[i][j] : minimum steps to convert i long word1 and j long word2\\n    \\tint dp[][] = new int[word1.length() + 1][word2.length() + 1];\\n    \\n    \\tfor (int i = 0; i <= word1.length(); i++) dp[i][0] = i;    \\t\\n    \\tfor (int j = 0; j <= word2.length(); j++) dp[0][j] = j; \\n    \\t \\n    \\tfor (int i = 1;i <= word1.length(); i++) {\\n    \\t\\tfor (int j = 1; j<= word2.length(); j++) {\\n    \\t\\t\\tif (word1.charAt(i-1) == word2.charAt(j-1))// <--\\n    \\t\\t\\t\\tdp[i][j] = dp[i-1][j-1];\\n    \\t\\t\\telse \\n                    // dp[i-1][j-1] : replace word1(i) with word2(j), because word1(0, i-1) == word2(0, j-1);\\n                    // dp[i  ][j-1] : delete word(j)\\n                    // dp[i-1][j  ] : delete word(i), because word1(0, i-1) == word2(0, j)\\n    \\t\\t\\t\\tdp[i][j] = Math.min(dp[i-1][j-1], Math.min(dp[i][j-1], dp[i-1][j])) + 1; \\n    \\t\\t}\\n    \\t}\\n    \\treturn dp[word1.length()][word2.length()];\\n    }",
                "solutionTags": [],
                "code": "    public int minDistance(String word1, String word2) {\\n    \\t// dp[i][j] : minimum steps to convert i long word1 and j long word2\\n    \\tint dp[][] = new int[word1.length() + 1][word2.length() + 1];\\n    \\n    \\tfor (int i = 0; i <= word1.length(); i++) dp[i][0] = i;    \\t\\n    \\tfor (int j = 0; j <= word2.length(); j++) dp[0][j] = j; \\n    \\t \\n    \\tfor (int i = 1;i <= word1.length(); i++) {\\n    \\t\\tfor (int j = 1; j<= word2.length(); j++) {\\n    \\t\\t\\tif (word1.charAt(i-1) == word2.charAt(j-1))// <--\\n    \\t\\t\\t\\tdp[i][j] = dp[i-1][j-1];\\n    \\t\\t\\telse \\n                    // dp[i-1][j-1] : replace word1(i) with word2(j), because word1(0, i-1) == word2(0, j-1);\\n                    // dp[i  ][j-1] : delete word(j)\\n                    // dp[i-1][j  ] : delete word(i), because word1(0, i-1) == word2(0, j)\\n    \\t\\t\\t\\tdp[i][j] = Math.min(dp[i-1][j-1], Math.min(dp[i][j-1], dp[i-1][j])) + 1; \\n    \\t\\t}\\n    \\t}\\n    \\treturn dp[word1.length()][word2.length()];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3230707,
                "title": "memoization-tabulation-space-optimization-dp-c-commented",
                "content": "# Consider\\uD83D\\uDC4D\\n```\\n                    Please Upvote If You Find It Helpful\\n```\\n# Intuition\\n    In this question we have to find the **Minimum Operations** to convert `word1` to `word2`.\\n    So, what are the posibilities : \\n        If both letters are equal then simply decrease index\\n        Otherwise there are three posibilities:\\n            We can `Insert` a letter\\n            We can `Delete` a letter\\n            We can `Replace` a letter\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n**Space Optimization**\\n```\\nclass Solution {\\npublic:\\n    // Space Optimization - TC: O(n * m), SC: O(m)\\n    int minDistance(string word1, string word2) {\\n    int n = word1.size(), m = word2.size();\\n    // We make dp array 1 indexed\\n    // Initialize two vectors to store the values of the previous and current rows of the dp array\\n    vector<int> prev(m+1, 0), curr(m+1, 0);\\n    // Initialize the first row of the dp array to the numbers 0, 1, 2, ..., m\\n    for(int j=0;j<=m;j++) prev[j] = j;\\n    // Iterate through each row of the dp array\\n    for(int i=1;i<=n;i++){\\n        // Set the first element of the current row to i\\n        curr[0] = i;\\n        // Iterate through each column of the dp array\\n        for(int j=1;j<=m;j++){\\n            // If the two characters are equal, no operation is needed\\n            if(word1[i-1] == word2[j-1])\\n                curr[j] = prev[j-1];\\n            else {\\n                // If the two characters are different, consider three possible operations:\\n                // Insertion: add 1 to the minimum value among prev[j], curr[j-1], and prev[j-1]\\n                curr[j] = 1 + min(prev[j], min(curr[j-1], prev[j-1]));\\n            }\\n        }\\n        // Update the previous row to be equal to the current row\\n        prev = curr;\\n    }\\n    // Return the value of the last element of the dp array, which represents the minimum edit distance\\n    return prev[m];\\n}\\n};\\n```\\n**Tabulation**\\n```\\n// Tabulation - TC: O(n * m), SC: O(n * m)\\n    int minDistance(string word1, string word2) {\\n        int n = word1.size(), m = word2.size();\\n        // We make dp array 1 indexed\\n        vector<vector<int>> dp(n+1, vector<int>(m+1, 0));\\n        for(int i=0;i<=n;i++) dp[i][0] = i;\\n        for(int j=0;j<=m;j++) dp[0][j] = j;\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(word1[i-1] == word2[j-1]) dp[i][j] = dp[i-1][j-1];\\n                else\\n// Delete - dp[i-1][j], Insert - dp[i][j-1], Replace - dp[i-1][j-1]\\n                    dp[i][j] = 1 + min(dp[i-1][j], \\n        min(dp[i][j-1], dp[i-1][j-1]));\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n```\\n**Memoization** \\n```\\n//Memoization - TC: O(n * m), SC: O(n * m) + O(n + m)\\n    int find(string word1, string word2, int i, int j, vector<vector<int>>& dp){\\n        if(j < 0) return i+1;\\n        if(i < 0) return j+1;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        if(word1[i] == word2[j]) return find(word1, word2, i-1, j-1, dp);\\n        return dp[i][j] = 1 + min(find(word1, word2, i-1, j, dp), \\n        min(find(word1, word2, i, j-1, dp), find(word1, word2, i-1, j-1, dp)));\\n    }\\n    int minDistance(string word1, string word2) {\\n        int n = word1.size(), m = word2.size();\\n        vector<vector<int>> dp(n+1, vector<int>(m+1, -1));\\n        return find(word1, word2, n-1, m-1, dp);\\n    }\\n```\\n```\\n            Give a \\uD83D\\uDC4D. It motivates me alot\\n```\\nLet\\'s Connect On [Linkedin](https://www.linkedin.com/in/naman-agarwal-0551aa1aa/)",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\n                    Please Upvote If You Find It Helpful\\n```\n```\\nclass Solution {\\npublic:\\n    // Space Optimization - TC: O(n * m), SC: O(m)\\n    int minDistance(string word1, string word2) {\\n    int n = word1.size(), m = word2.size();\\n    // We make dp array 1 indexed\\n    // Initialize two vectors to store the values of the previous and current rows of the dp array\\n    vector<int> prev(m+1, 0), curr(m+1, 0);\\n    // Initialize the first row of the dp array to the numbers 0, 1, 2, ..., m\\n    for(int j=0;j<=m;j++) prev[j] = j;\\n    // Iterate through each row of the dp array\\n    for(int i=1;i<=n;i++){\\n        // Set the first element of the current row to i\\n        curr[0] = i;\\n        // Iterate through each column of the dp array\\n        for(int j=1;j<=m;j++){\\n            // If the two characters are equal, no operation is needed\\n            if(word1[i-1] == word2[j-1])\\n                curr[j] = prev[j-1];\\n            else {\\n                // If the two characters are different, consider three possible operations:\\n                // Insertion: add 1 to the minimum value among prev[j], curr[j-1], and prev[j-1]\\n                curr[j] = 1 + min(prev[j], min(curr[j-1], prev[j-1]));\\n            }\\n        }\\n        // Update the previous row to be equal to the current row\\n        prev = curr;\\n    }\\n    // Return the value of the last element of the dp array, which represents the minimum edit distance\\n    return prev[m];\\n}\\n};\\n```\n```\\n// Tabulation - TC: O(n * m), SC: O(n * m)\\n    int minDistance(string word1, string word2) {\\n        int n = word1.size(), m = word2.size();\\n        // We make dp array 1 indexed\\n        vector<vector<int>> dp(n+1, vector<int>(m+1, 0));\\n        for(int i=0;i<=n;i++) dp[i][0] = i;\\n        for(int j=0;j<=m;j++) dp[0][j] = j;\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(word1[i-1] == word2[j-1]) dp[i][j] = dp[i-1][j-1];\\n                else\\n// Delete - dp[i-1][j], Insert - dp[i][j-1], Replace - dp[i-1][j-1]\\n                    dp[i][j] = 1 + min(dp[i-1][j], \\n        min(dp[i][j-1], dp[i-1][j-1]));\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n```\n```\\n//Memoization - TC: O(n * m), SC: O(n * m) + O(n + m)\\n    int find(string word1, string word2, int i, int j, vector<vector<int>>& dp){\\n        if(j < 0) return i+1;\\n        if(i < 0) return j+1;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        if(word1[i] == word2[j]) return find(word1, word2, i-1, j-1, dp);\\n        return dp[i][j] = 1 + min(find(word1, word2, i-1, j, dp), \\n        min(find(word1, word2, i, j-1, dp), find(word1, word2, i-1, j-1, dp)));\\n    }\\n    int minDistance(string word1, string word2) {\\n        int n = word1.size(), m = word2.size();\\n        vector<vector<int>> dp(n+1, vector<int>(m+1, -1));\\n        return find(word1, word2, n-1, m-1, dp);\\n    }\\n```\n```\\n            Give a \\uD83D\\uDC4D. It motivates me alot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 428527,
                "title": "javascript-solution",
                "content": "### The Idea\\n1. Use lavenshtein distance algorithm and dynamic programming implementation\\n2. Build a matrix from word1 and word2, each cell represents the minimum difference between the words up the current character\\n3. Each cell is trying to become the locally minimum difference, so we have 3 options, 1 + left cell, 1 + top cell, 1 + diagonal (two characters aren\\'t the same) or 0 + diagonal (two characters are the same)\\n``` javascript\\nvar minDistance = function(word1, word2) {\\n    let dp = Array(word1.length+1).fill(null).map(()=>(Array(word2.length+1).fill(0)));\\n\\n    for (let i=0;i<dp.length;i++) {\\n        dp[i][0] = i\\n    }\\n\\n    for (let i=0;i<dp[0].length;i++) {\\n        dp[0][i] = i\\n    }\\n\\n    for (let i = 1;i<dp.length;i++) {\\n        for (let j=1;j<dp[0].length;j++) {\\n            dp[i][j] = Math.min(\\n                            dp[i-1][j]+1, // left\\n                            dp[i][j-1]+1, // right\\n                            dp[i-1][j-1] + (word1[i-1]!=word2[j-1]?1:0) // diagonal\\n                        );\\n        }\\n    }\\n    return dp[dp.length-1][dp[0].length-1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\nvar minDistance = function(word1, word2) {\\n    let dp = Array(word1.length+1).fill(null).map(()=>(Array(word2.length+1).fill(0)));\\n\\n    for (let i=0;i<dp.length;i++) {\\n        dp[i][0] = i\\n    }\\n\\n    for (let i=0;i<dp[0].length;i++) {\\n        dp[0][i] = i\\n    }\\n\\n    for (let i = 1;i<dp.length;i++) {\\n        for (let j=1;j<dp[0].length;j++) {\\n            dp[i][j] = Math.min(\\n                            dp[i-1][j]+1, // left\\n                            dp[i][j-1]+1, // right\\n                            dp[i-1][j-1] + (word1[i-1]!=word2[j-1]?1:0) // diagonal\\n                        );\\n        }\\n    }\\n    return dp[dp.length-1][dp[0].length-1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3231367,
                "title": "python-3-8-lines-w-comments-t-m-100-78",
                "content": "```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n\\n        w1, w2 = len(word1), len(word2)\\n        \\n        @lru_cache(None)\\n        def dp(i, j):\\n\\n            if i >= w1             : return w2-j                # word1 used up, so all inserts\\n            if j >= w2             : return w1-i                # word2 used up, so all deletes\\n            if word1[i] == word2[j]: return dp(i+1, j+1)        # letters match, so no operation\\n\\n            return min(dp(i,j+1), dp(i+1,j), dp(i+1,j+1)) + 1   # insert, delete, replace\\n\\n        return dp(0,0)\\n```\\n[https://leetcode.com/problems/edit-distance/submissions/905093377/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*MN*) and space complexity is *O*(*MN*), in which *M, N* ~ `len(word1),len(word2)`.\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n\\n        w1, w2 = len(word1), len(word2)\\n        \\n        @lru_cache(None)\\n        def dp(i, j):\\n\\n            if i >= w1             : return w2-j                # word1 used up, so all inserts\\n            if j >= w2             : return w1-i                # word2 used up, so all deletes\\n            if word1[i] == word2[j]: return dp(i+1, j+1)        # letters match, so no operation\\n\\n            return min(dp(i,j+1), dp(i+1,j), dp(i+1,j+1)) + 1   # insert, delete, replace\\n\\n        return dp(0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1980878,
                "title": "java-c-python-javascript-kotlin-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "***Hello it would be my pleasure to introduce myself Darian.***\\n\\n<iframe src=\"https://leetcode.com/playground/kMGrBJeX/shared\" frameBorder=\"0\" width=\"1000\" height=\"1000\"></iframe>\\n\\n***Consider upvote if useful! Hopefully it can be used in your advantage!***\\n***Take care brother, peace, love!***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Kotlin"
                ],
                "code": "***Hello it would be my pleasure to introduce myself Darian.***\\n\\n<iframe src=\"https://leetcode.com/playground/kMGrBJeX/shared\" frameBorder=\"0\" width=\"1000\" height=\"1000\"></iframe>\\n\\n***Consider upvote if useful! Hopefully it can be used in your advantage!***\\n***Take care brother, peace, love!***",
                "codeTag": "Unknown"
            },
            {
                "id": 25987,
                "title": "dynamic-programming-solution-in-c-with-algorithm-description",
                "content": "**Algorithm Description**  \\n\\n\\n----------\\n\\n - Step 1:\\n\\nSet  n to be the length of *word1*;\\nSet m to be the length of *word2*.  \\nIf n = 0, return m and exit.  \\nIf m = 0, return n  and exit.  \\nConstruct a matrix containing 0...n rows and 0...m columns.  \\n  \\n\\n - Step 2:\\n\\nInitialize the first row       to 0...n.  \\nInitialize the first column to 0...m.  \\n  \\n\\n - Step 3:\\n\\nExamine each character of *word1* (i from 1 to  n).\\n\\n - Step 4:\\n\\nExamine each character of *word2*  (j from 1 to m).\\n\\n - Step 5:\\n\\nIf word1[i] == word2[j], the cost = 0.  \\nIf word1[i] !=  word2[j], the cost = 1.  \\n  \\n\\n - Step 6:\\n\\n   \\nSet cell A [i, j] of the matrix equal to the minimum of:  \\na) The cell immediately **above** plus 1:                               A[i - 1, j]    + 1.  \\nb) The cell immediately **to the left** plus 1:                          A[i,  j - 1]    + 1.  \\nc) The cell diagonally **above and to the left** plus the cost: A[i - 1, j - 1] + cost.  \\n  \\n\\n - Step 7:\\n\\n   \\nAfter the iteration steps (3, 4, 5, 6) are complete, the distance is found in cell A[n, m]. \\n\\n\\n----------\\n\\n\\nHere is the code:\\n\\n    int minDistance(string word1, string word2) {\\n        // Step 1\\n        int n = word1.size(), m = word2.size();\\n        if (n == 0)  return m;\\n        if (m == 0)  return n;\\n        int A[n + 1][m + 1];\\n\\n        // Step 2\\n        for (int i = 0; i <= n; ++i)  A[i][0] = i;\\n        for (int j = 0; j <= m; ++j)  A[0][j] = j;\\n        \\n        for (int i = 1; i <= n; ++i) {  // Step 3\\n            char word1_i = word1[i-1];\\n            for (int j = 1; j <= m; ++j) {  // Step 4\\n                char word2_j = word2[j-1];\\n                int cost = (word1_i == word2_j) ? 0 : 1;  // Step 5\\n                A[i][j] = min(min(A[i-1][j]+1, A[i][j-1]+1), A[i-1][j-1]+cost);// Step 6\\n            }\\n        }\\n        return A[n][m];  // Step 7\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "**Algorithm Description**  \\n\\n\\n----------\\n\\n - Step 1:\\n\\nSet  n to be the length of *word1*;\\nSet m to be the length of *word2*.  \\nIf n = 0, return m and exit.  \\nIf m = 0, return n  and exit.  \\nConstruct a matrix containing 0...n rows and 0...m columns.  \\n  \\n\\n - Step 2:\\n\\nInitialize the first row       to 0...n.  \\nInitialize the first column to 0...m.  \\n  \\n\\n - Step 3:\\n\\nExamine each character of *word1* (i from 1 to  n).\\n\\n - Step 4:\\n\\nExamine each character of *word2*  (j from 1 to m).\\n\\n - Step 5:\\n\\nIf word1[i] == word2[j], the cost = 0.  \\nIf word1[i] !=  word2[j], the cost = 1.  \\n  \\n\\n - Step 6:\\n\\n   \\nSet cell A [i, j] of the matrix equal to the minimum of:  \\na) The cell immediately **above** plus 1:                               A[i - 1, j]    + 1.  \\nb) The cell immediately **to the left** plus 1:                          A[i,  j - 1]    + 1.  \\nc) The cell diagonally **above and to the left** plus the cost: A[i - 1, j - 1] + cost.  \\n  \\n\\n - Step 7:\\n\\n   \\nAfter the iteration steps (3, 4, 5, 6) are complete, the distance is found in cell A[n, m]. \\n\\n\\n----------\\n\\n\\nHere is the code:\\n\\n    int minDistance(string word1, string word2) {\\n        // Step 1\\n        int n = word1.size(), m = word2.size();\\n        if (n == 0)  return m;\\n        if (m == 0)  return n;\\n        int A[n + 1][m + 1];\\n\\n        // Step 2\\n        for (int i = 0; i <= n; ++i)  A[i][0] = i;\\n        for (int j = 0; j <= m; ++j)  A[0][j] = j;\\n        \\n        for (int i = 1; i <= n; ++i) {  // Step 3\\n            char word1_i = word1[i-1];\\n            for (int j = 1; j <= m; ++j) {  // Step 4\\n                char word2_j = word2[j-1];\\n                int cost = (word1_i == word2_j) ? 0 : 1;  // Step 5\\n                A[i][j] = min(min(A[i-1][j]+1, A[i][j-1]+1), A[i-1][j-1]+cost);// Step 6\\n            }\\n        }\\n        return A[n][m];  // Step 7\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1519242,
                "title": "java-tc-o-mn-sc-o-min-m-n-space-optimized-dp-solution",
                "content": "```java\\n/**\\n * Space Optimized Dynamic Programming solution\\n *\\n * dp[i][j] = the minimum number of operations to convert word1[0 .. i-1] to word2[0 .. j-1]\\n *\\n * Time Complexity: O(M * N)\\n *\\n * Space Complexity: O(min(M, N)).\\n *\\n * M = Length string word1. N = Length of string word2.\\n */\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        if (word1 == null || word2 == null) {\\n            throw new IllegalArgumentException(\"Input strings are null\");\\n        }\\n\\n        int insertCost = 1;\\n        int deleteCost = 1;\\n        int replaceCost = 1;\\n        int l1 = word1.length();\\n        int l2 = word2.length();\\n\\n        if (l1 == 0) {\\n            return l2 * insertCost;\\n        }\\n        if (l2 == 0) {\\n            return l1 * deleteCost;\\n        }\\n        // Bellow condition can be used only if all three costs are same.\\n        if (l1 > l2) {\\n            return minDistance(word2, word1);\\n        }\\n\\n        int[] dp = new int[l1 + 1];\\n        // Setting DP array for 0th column of 2D DP array. Here l2 is blank, thus we\\n        // have to delete everything in l1.\\n        for (int i = 1; i <= l1; i++) {\\n            dp[i] = dp[i - 1] + deleteCost;\\n        }\\n\\n        for (int j = 1; j <= l2; j++) {\\n            int prev = dp[0];\\n            dp[0] += insertCost; // l1 is blank, Inserting l2 chars in l1.\\n            char c2 = word2.charAt(j - 1);\\n            for (int i = 1; i <= l1; i++) {\\n                char c1 = word1.charAt(i - 1);\\n                int temp = dp[i];\\n                // Both chars are same, so the distance will also remain same as dp[i-1][j-1]\\n                if (c1 == c2) {\\n                    dp[i] = prev;\\n                } else {\\n                    // Replace l1[i - 1] by l2[j - 1] ==> dp[i][j] = dp[i - 1][j - 1] + 1\\n                    // Delete l1[i-1] from l1[0..i-1] ==> dp[i-1][j] + 1\\n                    // Insert l2[j-1] into l1[0..i-1] ==> dp[i][j-1] + 1\\n                    dp[i] = Math.min(prev + replaceCost, Math.min(dp[i - 1] + deleteCost, dp[i] + insertCost));\\n                }\\n                prev = temp;\\n            }\\n        }\\n\\n        return dp[l1];\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other similar questions on LeetCode:\\n- [221. Maximal Square](https://leetcode.com/problems/maximal-square/discuss/1519235/Java-or-TC:-O(MN)-or-SC:-O(min(MN))-or-Space-optimized-DP-solution)\\n- [161. One Edit Distance](https://leetcode.com/problems/one-edit-distance/discuss/1519249/Java-or-TC:-O(min(ST))-or-SC:-O(min(ST))-or-Optimal-One-Pass-solution)\\n",
                "solutionTags": [
                    "Java",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```java\\n/**\\n * Space Optimized Dynamic Programming solution\\n *\\n * dp[i][j] = the minimum number of operations to convert word1[0 .. i-1] to word2[0 .. j-1]\\n *\\n * Time Complexity: O(M * N)\\n *\\n * Space Complexity: O(min(M, N)).\\n *\\n * M = Length string word1. N = Length of string word2.\\n */\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        if (word1 == null || word2 == null) {\\n            throw new IllegalArgumentException(\"Input strings are null\");\\n        }\\n\\n        int insertCost = 1;\\n        int deleteCost = 1;\\n        int replaceCost = 1;\\n        int l1 = word1.length();\\n        int l2 = word2.length();\\n\\n        if (l1 == 0) {\\n            return l2 * insertCost;\\n        }\\n        if (l2 == 0) {\\n            return l1 * deleteCost;\\n        }\\n        // Bellow condition can be used only if all three costs are same.\\n        if (l1 > l2) {\\n            return minDistance(word2, word1);\\n        }\\n\\n        int[] dp = new int[l1 + 1];\\n        // Setting DP array for 0th column of 2D DP array. Here l2 is blank, thus we\\n        // have to delete everything in l1.\\n        for (int i = 1; i <= l1; i++) {\\n            dp[i] = dp[i - 1] + deleteCost;\\n        }\\n\\n        for (int j = 1; j <= l2; j++) {\\n            int prev = dp[0];\\n            dp[0] += insertCost; // l1 is blank, Inserting l2 chars in l1.\\n            char c2 = word2.charAt(j - 1);\\n            for (int i = 1; i <= l1; i++) {\\n                char c1 = word1.charAt(i - 1);\\n                int temp = dp[i];\\n                // Both chars are same, so the distance will also remain same as dp[i-1][j-1]\\n                if (c1 == c2) {\\n                    dp[i] = prev;\\n                } else {\\n                    // Replace l1[i - 1] by l2[j - 1] ==> dp[i][j] = dp[i - 1][j - 1] + 1\\n                    // Delete l1[i-1] from l1[0..i-1] ==> dp[i-1][j] + 1\\n                    // Insert l2[j-1] into l1[0..i-1] ==> dp[i][j-1] + 1\\n                    dp[i] = Math.min(prev + replaceCost, Math.min(dp[i - 1] + deleteCost, dp[i] + insertCost));\\n                }\\n                prev = temp;\\n            }\\n        }\\n\\n        return dp[l1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25878,
                "title": "evolve-from-brute-force-to-dp",
                "content": "We only need to edit one word because insert a char to word1 is equivalent to delete a char in word2 and vise versa. Replace a char in word1 is equivalent to replace a char in word2.\\n1. O(3^max(n1,n2)) We edit word 1 only and there are 3 operations\\n* c++\\n```\\n    int minDistance(string word1, string word2) {\\n        return minDistance(0,0,word1,word2);\\n    }\\n    int minDistance(int p1, int p2, string &word1, string &word2) {\\n        if(p1==word1.size()) return word2.size()-p2; //dist between a string and an empty string\\n        if(p2==word2.size()) return word1.size()-p1;\\n        if(word1[p1]==word2[p2]) return minDistance(p1+1,p2+1,word1,word2);\\n        int ins = minDistance(p1,p2+1,word1,word2);\\n        int del = minDistance(p1+1,p2,word1,word2);\\n        int rpl = minDistance(p1+1,p2+1,word1,word2);\\n        return min(ins,min(del,rpl))+1;\\n    }\\n```\\n* java\\n```\\n\\tpublic int minDistance(String word1, String word2) {\\n        return minDist(0,0,word1,word2);  \\n    }\\n    private int minDist(int p1, int p2, String word1, String word2) {\\n        int s1=word1.length(),s2=word2.length();\\n        if(p1==s1) return s2-p2; //We only edit word1, but since both insert and delete are allowed, word1 may not finish first\\n        if(p2==s2) return s1-p1; //The two ternimation checks make sure both indexes are valid\\n        if(word1.charAt(p1)==word2.charAt(p2)) \\n            return minDist(p1+1,p2+1,word1,word2);\\n        int ins = minDist(p1,p2+1,word1,word2);\\n        int del = minDist(p1+1,p2,word1,word2);\\n        int rep = minDist(p1+1,p2+1,word1,word2);\\n        return Math.min(ins, Math.min(del, rep))+1;\\n    }\\n}\\n```\\n2. O(n1n2) memorization\\n* c++\\n```\\n    int minDistance(string word1, string word2) {\\n        vector<vector<int>> mem(word1.size(),vector<int>(word2.size(),-1));\\n        return minDistance(0,0,word1,word2,mem);\\n    }\\n    int minDistance(int p1, int p2, string &word1, string &word2,vector<vector<int>>& mem) {\\n        if(p1==word1.size()) return word2.size()-p2;\\n        if(p2==word2.size()) return word1.size()-p1;\\n        if(mem[p1][p2]>=0) return mem[p1][p2];\\n        if(word1[p1]==word2[p2]) return mem[p1][p2]=minDistance(p1+1,p2+1,word1,word2,mem);\\n        int ins = minDistance(p1,p2+1,word1,word2,mem);\\n        int del = minDistance(p1+1,p2,word1,word2,mem);\\n        int rpl = minDistance(p1+1,p2+1,word1,word2,mem);\\n        return mem[p1][p2] = min(ins,min(del,rpl))+1;\\n    }\\n```\\n* java\\n```\\n\\tpublic int minDistance(String word1, String word2) {\\n        Integer[][] mem=new Integer[word1.length()][word2.length()];\\n        return minDist(0,0,word1,word2,mem);  \\n    }\\n    private int minDist(int p1, int p2, String word1, String word2, Integer[][] mem) {\\n        int s1=word1.length(),s2=word2.length();\\n        if(p1==s1) return s2-p2; //We only edit word1, but since both insert and delete are allowed, word1 may not finish first\\n        if(p2==s2) return s1-p1; //The two ternimation checks make sure both indexes are valid\\n        if(mem[p1][p2]!=null) return mem[p1][p2];\\n        if(word1.charAt(p1)==word2.charAt(p2)) \\n            return mem[p1][p2]=minDist(p1+1,p2+1,word1,word2,mem);\\n        int ins = minDist(p1,p2+1,word1,word2,mem);\\n        int del = minDist(p1+1,p2,word1,word2,mem);\\n        int rep = minDist(p1+1,p2+1,word1,word2,mem);\\n        return mem[p1][p2]=Math.min(ins, Math.min(del, rep))+1;\\n    }\\n```\\n3. O(n1n2) dp\\n* c++\\n```\\n    int minDistance(string word1, string word2) {\\n        int n1 = word1.size(),n2=word2.size();\\n        vector<vector<int>> dp(n1+1,vector<int>(n2+1));\\n        for(int i=0;i<n1;i++) dp[i][n2] = n1-i;\\n        for(int j=0;j<n2;j++) dp[n1][j] = n2-j;\\n        for(int i=n1-1;i>=0;i--)\\n            for(int j=n2-1;j>=0;j--) \\n                dp[i][j] = word1[i]==word2[j]? dp[i+1][j+1] : min(min(dp[i][j+1],dp[i+1][j]),dp[i+1][j+1])+1;\\n        return dp[0][0];\\n    }\\n```\\n* java\\n```\\n\\tpublic int minDistance(String word1, String word2) {\\n        int n1=word1.length(), n2=word2.length();\\n        int[][] dp=new int[n1+1][n2+1];\\n        for(int i=0;i<n1;i++) dp[i][n2]=n1-i;\\n        for(int i=0;i<n2;i++) dp[n1][i]=n2-i;\\n        for(int i=n1-1;i>=0;i--)\\n            for(int j=n2-1;j>=0;j--) {\\n                if(word1.charAt(i)==word2.charAt(j))\\n                    dp[i][j]=dp[i+1][j+1];\\n                else {\\n                    dp[i][j]=Math.min(dp[i][j+1],Math.min(dp[i+1][j],dp[i+1][j+1]))+1;\\n                }\\n            }\\n        return dp[0][0];  \\n    }\\n```\\n4. linear space dp\\n```\\n    int minDistance(string word1, string word2) {\\n        int s1=word1.size(),s2=word2.size();\\n        vector<int> dp(s1+1);\\n        iota(dp.rbegin(),dp.rend(),0);\\n        for(int i=s2-1;i>=0;i--) {\\n            int i1j1 = dp[s1];\\n            dp[s1] = s2-i;\\n            for(int j=s1-1;j>=0;j--) {\\n                int temp=dp[j];\\n                dp[j]=min(dp[j+1]+1,min(dp[j]+1,i1j1+(word2[i]!=word1[j])));\\n                i1j1=temp;\\n            }\\n        }\\n        return dp[0];\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\n    int minDistance(string word1, string word2) {\\n        return minDistance(0,0,word1,word2);\\n    }\\n    int minDistance(int p1, int p2, string &word1, string &word2) {\\n        if(p1==word1.size()) return word2.size()-p2; //dist between a string and an empty string\\n        if(p2==word2.size()) return word1.size()-p1;\\n        if(word1[p1]==word2[p2]) return minDistance(p1+1,p2+1,word1,word2);\\n        int ins = minDistance(p1,p2+1,word1,word2);\\n        int del = minDistance(p1+1,p2,word1,word2);\\n        int rpl = minDistance(p1+1,p2+1,word1,word2);\\n        return min(ins,min(del,rpl))+1;\\n    }\\n```\n```\\n\\tpublic int minDistance(String word1, String word2) {\\n        return minDist(0,0,word1,word2);  \\n    }\\n    private int minDist(int p1, int p2, String word1, String word2) {\\n        int s1=word1.length(),s2=word2.length();\\n        if(p1==s1) return s2-p2; //We only edit word1, but since both insert and delete are allowed, word1 may not finish first\\n        if(p2==s2) return s1-p1; //The two ternimation checks make sure both indexes are valid\\n        if(word1.charAt(p1)==word2.charAt(p2)) \\n            return minDist(p1+1,p2+1,word1,word2);\\n        int ins = minDist(p1,p2+1,word1,word2);\\n        int del = minDist(p1+1,p2,word1,word2);\\n        int rep = minDist(p1+1,p2+1,word1,word2);\\n        return Math.min(ins, Math.min(del, rep))+1;\\n    }\\n}\\n```\n```\\n    int minDistance(string word1, string word2) {\\n        vector<vector<int>> mem(word1.size(),vector<int>(word2.size(),-1));\\n        return minDistance(0,0,word1,word2,mem);\\n    }\\n    int minDistance(int p1, int p2, string &word1, string &word2,vector<vector<int>>& mem) {\\n        if(p1==word1.size()) return word2.size()-p2;\\n        if(p2==word2.size()) return word1.size()-p1;\\n        if(mem[p1][p2]>=0) return mem[p1][p2];\\n        if(word1[p1]==word2[p2]) return mem[p1][p2]=minDistance(p1+1,p2+1,word1,word2,mem);\\n        int ins = minDistance(p1,p2+1,word1,word2,mem);\\n        int del = minDistance(p1+1,p2,word1,word2,mem);\\n        int rpl = minDistance(p1+1,p2+1,word1,word2,mem);\\n        return mem[p1][p2] = min(ins,min(del,rpl))+1;\\n    }\\n```\n```\\n\\tpublic int minDistance(String word1, String word2) {\\n        Integer[][] mem=new Integer[word1.length()][word2.length()];\\n        return minDist(0,0,word1,word2,mem);  \\n    }\\n    private int minDist(int p1, int p2, String word1, String word2, Integer[][] mem) {\\n        int s1=word1.length(),s2=word2.length();\\n        if(p1==s1) return s2-p2; //We only edit word1, but since both insert and delete are allowed, word1 may not finish first\\n        if(p2==s2) return s1-p1; //The two ternimation checks make sure both indexes are valid\\n        if(mem[p1][p2]!=null) return mem[p1][p2];\\n        if(word1.charAt(p1)==word2.charAt(p2)) \\n            return mem[p1][p2]=minDist(p1+1,p2+1,word1,word2,mem);\\n        int ins = minDist(p1,p2+1,word1,word2,mem);\\n        int del = minDist(p1+1,p2,word1,word2,mem);\\n        int rep = minDist(p1+1,p2+1,word1,word2,mem);\\n        return mem[p1][p2]=Math.min(ins, Math.min(del, rep))+1;\\n    }\\n```\n```\\n    int minDistance(string word1, string word2) {\\n        int n1 = word1.size(),n2=word2.size();\\n        vector<vector<int>> dp(n1+1,vector<int>(n2+1));\\n        for(int i=0;i<n1;i++) dp[i][n2] = n1-i;\\n        for(int j=0;j<n2;j++) dp[n1][j] = n2-j;\\n        for(int i=n1-1;i>=0;i--)\\n            for(int j=n2-1;j>=0;j--) \\n                dp[i][j] = word1[i]==word2[j]? dp[i+1][j+1] : min(min(dp[i][j+1],dp[i+1][j]),dp[i+1][j+1])+1;\\n        return dp[0][0];\\n    }\\n```\n```\\n\\tpublic int minDistance(String word1, String word2) {\\n        int n1=word1.length(), n2=word2.length();\\n        int[][] dp=new int[n1+1][n2+1];\\n        for(int i=0;i<n1;i++) dp[i][n2]=n1-i;\\n        for(int i=0;i<n2;i++) dp[n1][i]=n2-i;\\n        for(int i=n1-1;i>=0;i--)\\n            for(int j=n2-1;j>=0;j--) {\\n                if(word1.charAt(i)==word2.charAt(j))\\n                    dp[i][j]=dp[i+1][j+1];\\n                else {\\n                    dp[i][j]=Math.min(dp[i][j+1],Math.min(dp[i+1][j],dp[i+1][j+1]))+1;\\n                }\\n            }\\n        return dp[0][0];  \\n    }\\n```\n```\\n    int minDistance(string word1, string word2) {\\n        int s1=word1.size(),s2=word2.size();\\n        vector<int> dp(s1+1);\\n        iota(dp.rbegin(),dp.rend(),0);\\n        for(int i=s2-1;i>=0;i--) {\\n            int i1j1 = dp[s1];\\n            dp[s1] = s2-i;\\n            for(int j=s1-1;j>=0;j--) {\\n                int temp=dp[j];\\n                dp[j]=min(dp[j+1]+1,min(dp[j]+1,i1j1+(word2[i]!=word1[j])));\\n                i1j1=temp;\\n            }\\n        }\\n        return dp[0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 25989,
                "title": "my-dp-solution-in-c-with-comments",
                "content": "   \\n\\n    int minDistance(string word1, string word2) {\\n        // DP talbe, i is the position in word1, and j is the position in word2\\n        vector<vector<int>> distance(word1.length()+1, vector<int>(word2.length()+1, 0));\\n        \\n        // when i or j=0 means empty string, the distance is the length of another string\\n        for(int i=0; i<distance.size(); i++)\\n            for(int j=0; j< distance[0].size();j++){\\n                if(i == 0)\\n                    distance[i][j] = j;\\n                else if(j == 0)\\n                    distance[i][j] = i;\\n            }\\n        \\n        // if word1[i]==word2[j], then the distance of i and j is the previous i and j\\n        // otherwise we either replace, insert or delete a char\\n        // when insert a char to word1 it means we are trying to match word1 at i-1 to word2 at j\\n        // when delete a char from word1 it equals to insert a char to word2, which\\n        // means we are trying to match word1 at i to word2 at j-1\\n        // when replace a char to word1, then we add one step to previous i and j\\n        for(int i=1; i< distance.size(); i++)\\n            for(int j=1; j<distance[0].size(); j++){\\n                if(word1[i-1] == word2[j-1])\\n                    distance[i][j] = distance[i-1][j-1];\\n                else\\n                    distance[i][j] = 1+ min(distance[i-1][j-1], min(distance[i-1][j], distance[i][j-1]));\\n            }\\n            \\n        return distance[word1.length()][word2.length()];\\n    }",
                "solutionTags": [],
                "code": "   \\n\\n    int minDistance(string word1, string word2) {\\n        // DP talbe, i is the position in word1, and j is the position in word2\\n        vector<vector<int>> distance(word1.length()+1, vector<int>(word2.length()+1, 0));\\n        \\n        // when i or j=0 means empty string, the distance is the length of another string\\n        for(int i=0; i<distance.size(); i++)\\n            for(int j=0; j< distance[0].size();j++){\\n                if(i == 0)\\n                    distance[i][j] = j;\\n                else if(j == 0)\\n                    distance[i][j] = i;\\n            }\\n        \\n        // if word1[i]==word2[j], then the distance of i and j is the previous i and j\\n        // otherwise we either replace, insert or delete a char\\n        // when insert a char to word1 it means we are trying to match word1 at i-1 to word2 at j\\n        // when delete a char from word1 it equals to insert a char to word2, which\\n        // means we are trying to match word1 at i to word2 at j-1\\n        // when replace a char to word1, then we add one step to previous i and j\\n        for(int i=1; i< distance.size(); i++)\\n            for(int j=1; j<distance[0].size(); j++){\\n                if(word1[i-1] == word2[j-1])\\n                    distance[i][j] = distance[i-1][j-1];\\n                else\\n                    distance[i][j] = 1+ min(distance[i-1][j-1], min(distance[i-1][j], distance[i][j-1]));\\n            }\\n            \\n        return distance[word1.length()][word2.length()];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1915729,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func minDistance(_ word1: String, _ word2: String) -> Int {\\n        let row = word1.count + 1\\n        let col = word2.count + 1\\n        let chs1  = Array(word1)\\n        let chs2  = Array(word2)\\n        var dp: [[Int]] = Array(repeating: Array(repeating: 0, count: col), count: row)\\n        \\n        for i in 0..<row { \\n            for j in 0..<col {\\n                if i == 0 {\\n                    dp[i][j] = j\\n                \\n                } else if j == 0 {\\n                    dp[i][j] = i\\n                \\n                } else if chs1[i - 1] == chs2[j - 1] {\\n                    dp[i][j] = dp[i - 1][j - 1]\\n                \\n                } else {\\n                    dp[i][j] = 1 + min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1])\\n                }\\n            }\\n        }\\n        \\n        return dp[row - 1][col - 1]\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minDistance(_ word1: String, _ word2: String) -> Int {\\n        let row = word1.count + 1\\n        let col = word2.count + 1\\n        let chs1  = Array(word1)\\n        let chs2  = Array(word2)\\n        var dp: [[Int]] = Array(repeating: Array(repeating: 0, count: col), count: row)\\n        \\n        for i in 0..<row { \\n            for j in 0..<col {\\n                if i == 0 {\\n                    dp[i][j] = j\\n                \\n                } else if j == 0 {\\n                    dp[i][j] = i\\n                \\n                } else if chs1[i - 1] == chs2[j - 1] {\\n                    dp[i][j] = dp[i - 1][j - 1]\\n                \\n                } else {\\n                    dp[i][j] = 1 + min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1])\\n                }\\n            }\\n        }\\n        \\n        return dp[row - 1][col - 1]\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1359663,
                "title": "java-recursion-memoization-easy",
                "content": "Memoization Code is much better than recursion, yes DP is more fast than memoization. I put this because lots of students get confused while doing memoization\\n To do any Dp question, follow these three steps :-\\n1. Try to make solution via recursion\\n2. Try to make solution via memoization\\n3. then move to Dp\\n```    \\n    //Memoization Code\\n     public int minDistance(String word1, String word2) {\\n         int m = word1.length();\\n         int n = word2.length();\\n         int storage[][] = new int[m+1][n+1];\\n         for(int i=0;i<=m;i++){\\n             for(int j=0;j<=n;j++){\\n             storage[i][j] = -1;\\n             }\\n         }\\n         \\n         return editMemo(word1,word2,storage);\\n     }\\n    \\n    public int editMemo(String word1, String word2, int storage[][]){\\n        int m = word1.length();\\n         int n = word2.length();\\n        if(storage[m][n] != -1){\\n            return storage[m][n];\\n        }\\n        if(m==0) return storage[m][n] = n;\\n        if(n==0) return storage[m][n] = m;\\n         if(word1.charAt(0) == word2.charAt(0)){\\n            return storage[m][n] = editMemo(word1.substring(1),word2.substring(1),storage);\\n         }else{\\n               //insert\\n            int insert = editMemo(word1,word2.substring(1),storage);\\n             //delete\\n            int delete = editMemo(word1.substring(1),word2,storage);\\n             //replace \\n            int replace = editMemo(word1.substring(1),word2.substring(1),storage);\\n              storage[m][n] = 1 + Math.min(insert,Math.min(delete,replace));\\n         }\\n        return storage[m][n];\\n    }\\n    \\n```    \\n    \\n\\t\\n   It gives us TLE, because strings present in test cases can be so long\\n   ```\\n   // Recursion Solution\\n    public int minDistance(String word1, String word2) {\\n         if(word1.length() == 0){\\n             return word2.length();\\n         }\\n         if(word2.length() == 0){\\n             return word1.length();\\n         }\\n        \\n         if(word1.charAt(0) == word2.charAt(0)){\\n             return minDistance(word1.substring(1),word2.substring(1));\\n        }else{\\n             //insert\\n             int insert = minDistance(word1,word2.substring(1));\\n              //delete\\n             int delete = minDistance(word1.substring(1),word2);\\n              //replace \\n             int replace = minDistance(word1.substring(1),word2.substring(1));\\n               return 1 + Math.min(insert,Math.min(delete,replace));\\n         }\\n     }\\n\\t ```\\n**If you like this, please upvote and like this**",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```    \\n    //Memoization Code\\n     public int minDistance(String word1, String word2) {\\n         int m = word1.length();\\n         int n = word2.length();\\n         int storage[][] = new int[m+1][n+1];\\n         for(int i=0;i<=m;i++){\\n             for(int j=0;j<=n;j++){\\n             storage[i][j] = -1;\\n             }\\n         }\\n         \\n         return editMemo(word1,word2,storage);\\n     }\\n    \\n    public int editMemo(String word1, String word2, int storage[][]){\\n        int m = word1.length();\\n         int n = word2.length();\\n        if(storage[m][n] != -1){\\n            return storage[m][n];\\n        }\\n        if(m==0) return storage[m][n] = n;\\n        if(n==0) return storage[m][n] = m;\\n         if(word1.charAt(0) == word2.charAt(0)){\\n            return storage[m][n] = editMemo(word1.substring(1),word2.substring(1),storage);\\n         }else{\\n               //insert\\n            int insert = editMemo(word1,word2.substring(1),storage);\\n             //delete\\n            int delete = editMemo(word1.substring(1),word2,storage);\\n             //replace \\n            int replace = editMemo(word1.substring(1),word2.substring(1),storage);\\n              storage[m][n] = 1 + Math.min(insert,Math.min(delete,replace));\\n         }\\n        return storage[m][n];\\n    }\\n    \\n```\n```\\n   // Recursion Solution\\n    public int minDistance(String word1, String word2) {\\n         if(word1.length() == 0){\\n             return word2.length();\\n         }\\n         if(word2.length() == 0){\\n             return word1.length();\\n         }\\n        \\n         if(word1.charAt(0) == word2.charAt(0)){\\n             return minDistance(word1.substring(1),word2.substring(1));\\n        }else{\\n             //insert\\n             int insert = minDistance(word1,word2.substring(1));\\n              //delete\\n             int delete = minDistance(word1.substring(1),word2);\\n              //replace \\n             int replace = minDistance(word1.substring(1),word2.substring(1));\\n               return 1 + Math.min(insert,Math.min(delete,replace));\\n         }\\n     }\\n\\t ```",
                "codeTag": "Unknown"
            },
            {
                "id": 662992,
                "title": "javascript-dynamic-programming-concise-code-with-explanation",
                "content": "This is one of the problems taken directly from a farily well known algorithm.\\n\\nMinimum edit distance / Levenshtein Distance\\nWhat are the minimal # of edits (change, add, delete char) to convert 1 string to another\\nIt\\'s a DP problem, looking at a character at a time.  \\n\\nFor each chacter, you either don\\'t need to change it, you need to delete it, or you need to change it.\\nKeep doing that character after character for each possibility and since we are interested in the minimum number of changes, just keep track of the lowest #.\\n\\nTake a look at this great visual explanation:\\nhttps://www.youtube.com/watch?v=We3YDTzNXEk\\n\\n```\\nvar minDistance = function(word1, word2) {\\n  let dp = Array(word1.length+1).fill().map(()=>Array(word2.length+1)); // Get our DP matrix setup, no need for default values since we\\'ll be filling each each of them\\n  \\n  for (let r=0; r<=word1.length; r++) {\\n    for (let c=0; c<=word2.length; c++) {\\n      if (r==0) dp[0][c] = c; // here we setup the initial row\\n      else if (c==0) dp[r][0] = r; // here the initial column\\n      else if (word1[r-1] == word2[c-1]) //now, if the letter is the same, cost is the same as the upper left cost\\n        dp[r][c] = dp[r-1][c-1];\\n      else //letters are different, so we will either need to change or delete one of the letters so prev cost +1 operation\\n        dp[r][c] = Math.min(dp[r][c-1],dp[r-1][c-1], dp[r-1][c]) +1;\\n    }\\n  }\\n  return dp[word1.length][word2.length]; //return the cost at the end of the string\\n};\\n```\\n\\nIf this explanation helped, please upvote this post so others can notice it.  Cheers!",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar minDistance = function(word1, word2) {\\n  let dp = Array(word1.length+1).fill().map(()=>Array(word2.length+1)); // Get our DP matrix setup, no need for default values since we\\'ll be filling each each of them\\n  \\n  for (let r=0; r<=word1.length; r++) {\\n    for (let c=0; c<=word2.length; c++) {\\n      if (r==0) dp[0][c] = c; // here we setup the initial row\\n      else if (c==0) dp[r][0] = r; // here the initial column\\n      else if (word1[r-1] == word2[c-1]) //now, if the letter is the same, cost is the same as the upper left cost\\n        dp[r][c] = dp[r-1][c-1];\\n      else //letters are different, so we will either need to change or delete one of the letters so prev cost +1 operation\\n        dp[r][c] = Math.min(dp[r][c-1],dp[r-1][c-1], dp[r-1][c]) +1;\\n    }\\n  }\\n  return dp[word1.length][word2.length]; //return the cost at the end of the string\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 662497,
                "title": "java-c-python3-with-detailed-explanation",
                "content": "```\\nEXPLANATION:-\\n\\nIn this problem, we need to convert w1 to w2 with minimum number of operations\\n\\nLet\\'s see how to solve this problem.\\n\\nCase 1:-\\n   w1 = ab,  w2 = \"\"\\n   result = 2.\\n   we can convert w1 to w2 by \\n   deleting all the characters in w1.\\n   So, result is 2.\\nCase 2:-\\n   w1 = \"\", w2 = ab\\n   we can convert w1 to w2, \\n   by inserting a and b it w1.\\n   So, result is 2.\\nCase 3:-\\n   w1 = a,  w2 = a\\n   w1 and w2 are equal.\\n   So, result is 0.\\n   \\nCase 4:-\\n    w1 = a,  w2 = b\\n\\tHere, w1 and w2 are not equal.\\n\\tSo, What to do now.\\n\\tWe have three operations\\n\\t1. insert\\n\\t2. delete\\n\\t3. replace\\n\\tperform three operations on w1.\\n\\tand take minimum result.\\n\\t\\n\\tw1 = a,  w2 = b.\\n\\tindex1 = 0\\n\\tindex2 = 0\\n\\toperations = 0\\n\\t\\n\\t1.insert \\n\\t\\n\\tinsert b to w1.\\n\\tSo, w1 = ba, w2 = b\\n\\toperations is increased by since we have inserted a character.\\n\\toperations = 1\\n\\tNow, w1[index1] == w2[index2],\\n\\tSo, ignore those characters and check remaining characters.\\n    So, w1 = a, w2 = \"\" (after ignoring first characters as they are same)\\n\\tThis is same as case 1.\\n\\twe can w2 from w1 by deleting \\'a\\'.\\n\\tSo, delete \\'a\\'\\n\\t- >  operations = 2.\\n\\n\\t 2. Delete:-\\n\\n\\t w1 = a, w2 = b, operations = 0\\n\\t delete a character from w1\\n\\t So, operations = 1\\n\\t w1 = \"\", w2 = b\\n\\t this is same as case 2.\\n\\t we can w2 from w1 by inserting \\'b\\' to w1.\\n\\t So, insert \\'b\\'.\\n\\t - > operations = 2.\\n\\n\\t 3. replace:\\n\\t \\n\\t  w1 = a, w2 = b, operations = 0\\n\\t  replace a with b.\\n\\t  operations = 1.\\n\\t  w1 = w2\\n\\t  So, operations = 1.\\n  \\n\\t  Now, choose minimum of (insert, delete, replace) = min(2, 2, 1)\\n  \\n\\t  So, result = 1 to convert a to b.\\n  \\n  This is the idea behind this.\\n  \\n  IF YOU HAVE ANY DOUBTS, FEEL FREE TO ASK.\\n \\xA0IF YOU UNDERSTAND, DON\\'T FORGET TO UPVOTE.\\n```\\n```\\n\\nJava : -\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n\\t\\tint M = word1.length();\\n\\t\\tint N = word2.length();\\n\\t\\tint dp[][] = new int[M + 1][N + 1];\\n\\t\\tif (M * N == 0)\\n\\t\\t\\treturn M + N;\\n\\n\\t\\tfor (int i = 0; i <= M; i++) {\\n\\t\\t\\tdp[i][0] = i;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i <= N; i++) {\\n\\t\\t\\tdp[0][i] = i;\\n\\t\\t}\\n\\n\\t\\tfor (int i = 1; i <= M; i++) {\\n\\t\\t\\tfor (int j = 1; j <= N; j++) {\\n\\t\\t\\t\\tif (word1.charAt(i - 1) == word2.charAt(j - 1)) {\\n\\t\\t\\t\\t\\tdp[i][j] = dp[i - 1][j - 1];\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdp[i][j] = Math.min(dp[i - 1][j], Math.min(dp[i][j - 1], dp[i - 1][j - 1])) + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[M][N];\\n\\n\\t}\\n}\\n\\nC++:-\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n\\t\\tint M = word1.size();\\n\\t\\tint N = word2.size();\\n\\t\\tvector<vector<int>> dp(M + 1, vector<int>(N + 1, 0));\\n\\t\\tif (M * N == 0)\\n\\t\\t\\treturn M + N;\\n\\n\\t\\tfor (int i = 0; i <= M; i++) {\\n\\t\\t\\tdp[i][0] = i;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i <= N; i++) {\\n\\t\\t\\tdp[0][i] = i;\\n\\t\\t}\\n\\n\\t\\tfor (int i = 1; i <= M; i++) {\\n\\t\\t\\tfor (int j = 1; j <= N; j++) {\\n\\t\\t\\t\\tif (word1.at(i - 1) == word2.at(j - 1)) {\\n\\t\\t\\t\\t\\tdp[i][j] = dp[i - 1][j - 1];\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdp[i][j] = min(dp[i - 1][j], min(dp[i][j - 1], dp[i - 1][j - 1])) + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[M][N];\\n    }\\n};\\n\\nPython3:-\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        M, N = len(word1), len(word2)\\n        if M * N == 0:\\n            return M + N\\n        dp = [[0] * (N + 1) for i in range(M + 1)]\\n\\n        for i in range(M + 1):\\n            dp[i][0] = i\\n        for i in range(N + 1):\\n            dp[0][i] = i\\n        for i in range(1, M + 1):\\n            for j in range(1, N + 1):\\n                if word1[i - 1] == word2[j - 1]:\\n                    dp[i][j] = dp[i - 1][j - 1]\\n                else:\\n                    dp[i][j] = 1 + min(dp[i - 1][j], min(dp[i][j - 1], dp[i - 1][j - 1]))\\n        return dp[M][N]\\n```",
                "solutionTags": [],
                "code": "```\\nEXPLANATION:-\\n\\nIn this problem, we need to convert w1 to w2 with minimum number of operations\\n\\nLet\\'s see how to solve this problem.\\n\\nCase 1:-\\n   w1 = ab,  w2 = \"\"\\n   result = 2.\\n   we can convert w1 to w2 by \\n   deleting all the characters in w1.\\n   So, result is 2.\\nCase 2:-\\n   w1 = \"\", w2 = ab\\n   we can convert w1 to w2, \\n   by inserting a and b it w1.\\n   So, result is 2.\\nCase 3:-\\n   w1 = a,  w2 = a\\n   w1 and w2 are equal.\\n   So, result is 0.\\n   \\nCase 4:-\\n    w1 = a,  w2 = b\\n\\tHere, w1 and w2 are not equal.\\n\\tSo, What to do now.\\n\\tWe have three operations\\n\\t1. insert\\n\\t2. delete\\n\\t3. replace\\n\\tperform three operations on w1.\\n\\tand take minimum result.\\n\\t\\n\\tw1 = a,  w2 = b.\\n\\tindex1 = 0\\n\\tindex2 = 0\\n\\toperations = 0\\n\\t\\n\\t1.insert \\n\\t\\n\\tinsert b to w1.\\n\\tSo, w1 = ba, w2 = b\\n\\toperations is increased by since we have inserted a character.\\n\\toperations = 1\\n\\tNow, w1[index1] == w2[index2],\\n\\tSo, ignore those characters and check remaining characters.\\n    So, w1 = a, w2 = \"\" (after ignoring first characters as they are same)\\n\\tThis is same as case 1.\\n\\twe can w2 from w1 by deleting \\'a\\'.\\n\\tSo, delete \\'a\\'\\n\\t- >  operations = 2.\\n\\n\\t 2. Delete:-\\n\\n\\t w1 = a, w2 = b, operations = 0\\n\\t delete a character from w1\\n\\t So, operations = 1\\n\\t w1 = \"\", w2 = b\\n\\t this is same as case 2.\\n\\t we can w2 from w1 by inserting \\'b\\' to w1.\\n\\t So, insert \\'b\\'.\\n\\t - > operations = 2.\\n\\n\\t 3. replace:\\n\\t \\n\\t  w1 = a, w2 = b, operations = 0\\n\\t  replace a with b.\\n\\t  operations = 1.\\n\\t  w1 = w2\\n\\t  So, operations = 1.\\n  \\n\\t  Now, choose minimum of (insert, delete, replace) = min(2, 2, 1)\\n  \\n\\t  So, result = 1 to convert a to b.\\n  \\n  This is the idea behind this.\\n  \\n  IF YOU HAVE ANY DOUBTS, FEEL FREE TO ASK.\\n \\xA0IF YOU UNDERSTAND, DON\\'T FORGET TO UPVOTE.\\n```\n```\\n\\nJava : -\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n\\t\\tint M = word1.length();\\n\\t\\tint N = word2.length();\\n\\t\\tint dp[][] = new int[M + 1][N + 1];\\n\\t\\tif (M * N == 0)\\n\\t\\t\\treturn M + N;\\n\\n\\t\\tfor (int i = 0; i <= M; i++) {\\n\\t\\t\\tdp[i][0] = i;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i <= N; i++) {\\n\\t\\t\\tdp[0][i] = i;\\n\\t\\t}\\n\\n\\t\\tfor (int i = 1; i <= M; i++) {\\n\\t\\t\\tfor (int j = 1; j <= N; j++) {\\n\\t\\t\\t\\tif (word1.charAt(i - 1) == word2.charAt(j - 1)) {\\n\\t\\t\\t\\t\\tdp[i][j] = dp[i - 1][j - 1];\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdp[i][j] = Math.min(dp[i - 1][j], Math.min(dp[i][j - 1], dp[i - 1][j - 1])) + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[M][N];\\n\\n\\t}\\n}\\n\\nC++:-\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n\\t\\tint M = word1.size();\\n\\t\\tint N = word2.size();\\n\\t\\tvector<vector<int>> dp(M + 1, vector<int>(N + 1, 0));\\n\\t\\tif (M * N == 0)\\n\\t\\t\\treturn M + N;\\n\\n\\t\\tfor (int i = 0; i <= M; i++) {\\n\\t\\t\\tdp[i][0] = i;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i <= N; i++) {\\n\\t\\t\\tdp[0][i] = i;\\n\\t\\t}\\n\\n\\t\\tfor (int i = 1; i <= M; i++) {\\n\\t\\t\\tfor (int j = 1; j <= N; j++) {\\n\\t\\t\\t\\tif (word1.at(i - 1) == word2.at(j - 1)) {\\n\\t\\t\\t\\t\\tdp[i][j] = dp[i - 1][j - 1];\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdp[i][j] = min(dp[i - 1][j], min(dp[i][j - 1], dp[i - 1][j - 1])) + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[M][N];\\n    }\\n};\\n\\nPython3:-\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        M, N = len(word1), len(word2)\\n        if M * N == 0:\\n            return M + N\\n        dp = [[0] * (N + 1) for i in range(M + 1)]\\n\\n        for i in range(M + 1):\\n            dp[i][0] = i\\n        for i in range(N + 1):\\n            dp[0][i] = i\\n        for i in range(1, M + 1):\\n            for j in range(1, N + 1):\\n                if word1[i - 1] == word2[j - 1]:\\n                    dp[i][j] = dp[i - 1][j - 1]\\n                else:\\n                    dp[i][j] = 1 + min(dp[i - 1][j], min(dp[i][j - 1], dp[i - 1][j - 1]))\\n        return dp[M][N]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 162330,
                "title": "very-detailed-explanation-recursive-dp-in-java",
                "content": "The first step towards solving a DP problem is to build up the recursion tree. Once you have done it, it could be optimized using memoization, or a bottoms-up. Memoization is no brainer but bottoms-up takes a bit to get it right. I will try to outline how to build up the recursive solution and then move to DP from there. \\n\\nThis algorithm is based on standard L-distance, where would you do something of this sort:\\n```\\nif two characters are not equal:\\n\\t//cost to replace\\n\\tint replaceCount = 1 + function(s1, i+1, s2, j+1); // add 1 to the cost of replacing a character and go to the next set of characters.\\n\\t//cost to delete.\\n\\tint deleteCount = 1 + function(s1, i+1, s2, j); //add 1 to the cost of deleting the current char from string 1 and move to the next character from the first string assuming the current character won\\'t be considered anymore.\\n\\t//cost to add.\\n\\tint addCount = 1 + function(s1, i, s2, j+1);//add 1 to the cost of adding a new character to the second string and compare it with the current character from string 1. \\n```\\n\\nBased on the fact above, you could come up with the following recursive code:\\n```\\nprivate int helper(String s1,  int i, String s2, int j) {\\n        if (i == s1.length()) {\\n            //the first word came to an end.\\n            return s2.length()-j;\\n        } else if (j == s2.length()) {\\n            return s1.length() - i;\\n        } else if (s1.charAt(i) == s2.charAt(j)) {\\n            return helper(s1, i+1, s2, j+1);            \\n        }\\n        else {\\n            //replace.\\n            int replaceCount = 1 + helper(s1, i+1, s2, j+1);\\n            //delete.\\n            int deleteCount = 1 + helper(s1, i+1, s2, j);\\n            //add.\\n            int addCount = 1 + helper(s1, i, s2, j+1);\\n            return Math.min(replaceCount,Math.min(deleteCount, addCount));\\n        }\\n    }\\n\\t\\t\\nAnd, call it with helper(word1,0,word2,0).\\n```\\n\\nThe above does exhaustive traversal causing an exponential time complexity. You could fix it to make O(m*n) by doing memoization and I won\\'t discuss it here.\\n\\nDoing a bottoms-up DP requires us to think differently. You solve the first problem and then use that to solve the next problem. If you look at our recursive solution above, we are doing exactly the oppostive. We can\\'t use the recursive equation as it is since our solution of the current stack depends on the next stack and DP requires us to think it in the opposite way. So we will rewrite our recursive equation to suit this need. Here is the code for that:\\n\\n```\\n    private int helper_rec(String s1,  int i, String s2, int j) {\\n        if (i < 0) {\\n            //the first word came to an end.\\n            return j+1;\\n        } else if (j < 0) {\\n            return i+1;\\n        } else if (s1.charAt(i) == s2.charAt(j)) {\\n            return helper_rec(s1, i-1, s2, j-1);            \\n        }\\n        else {\\n            //replace.\\n            int replaceCount = 1 + helper_rec(s1, i-1, s2, j-1);\\n            //delete.\\n            int deleteCount = 1 + helper_rec(s1, i-1, s2, j);\\n            //add.\\n            int addCount = 1 + helper_rec(s1, i, s2, j-1);\\n            return Math.min(replaceCount,Math.min(deleteCount, addCount));\\n        }\\n    }\\n```\\n\\nWe are now good. We are building the solution from the previous solution and this is what the DP requires. Now to use the DP, here is what we need to consider:\\n1. Creating a 2-d array that may represent both words.\\n2. Thinking about an index \"0\" that is always initialized with some value for both i and j.\\n3. How to use the recursive condition from the above.\\n\\n```\\n1. For the first part, just create an array with the size of those words.\\nint[][] arr = new int[word1.length()+1][word2.length()+1];\\n\\n2. Initialization is a bit tricky but we could assume that the index \\'0\\' is basically an empty  string and how could we convert a string  to an empty string. Here is how we initialize that part:\\n        //set the boundary conditions.\\n        for (int i = 0; i<arr.length; i++) {\\n            arr[i][0] = i; \\n        }\\n        \\n        for (int j = 0; j<arr[0].length; j++) {\\n            arr[0][j] = j; \\n        }\\n\\t\\t\\t\\t\\n3. Using recursive condition: it is pretty much straight-foward:\\n //replace.\\n                    int replaceCount = 1 + arr[i-1][j-1];\\n                    //delete.\\n                    int deleteCount = 1 + arr[i-1][j]; \\n                    //add.\\n                    int addCount = 1 + arr[i][j-1];\\n                    arr[i][j] =  Math.min(replaceCount,Math.min(deleteCount, addCount));\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tThe above is an equivalent of our recursive equation where the position of the index is actually a subscript of an  array.\\n\\t\\t\\t\\n\\t\\t\\t\\nThe only other thing to remember is when the characters match, we want to reuse the last known cost. That\\'s if the characters match at arr[i][j], the new cost will be arr[i-1][j-1] since that will still apply to our next set of iterations.\\n```\\n\\nHere is the working code for the above:\\n```\\n    public int minDistance(String word1, String word2) {\\n        //return helper_rec(word1, word1.length()-1, word2, word2.length()-1);        \\n        int[][] arr = new int[word1.length()+1][word2.length()+1];\\n        //set the boundary conditions.\\n        for (int i = 0; i<arr.length; i++) {\\n            arr[i][0] = i; \\n        }\\n        \\n        for (int j = 0; j<arr[0].length; j++) {\\n            arr[0][j] = j; \\n        }\\n        \\n         for (int i=1; i<=word1.length();i++){\\n             for (int j=1; j<=word2.length() ;j++) {\\n                 if (word1.charAt(i-1) != word2.charAt(j-1)) {\\n                     //replace.\\n                    int replaceCount = 1 + arr[i-1][j-1];\\n                    //delete.\\n                    int deleteCount = 1 + arr[i-1][j]; \\n                    //add.\\n                    int addCount = 1 + arr[i][j-1];\\n                    arr[i][j] =  Math.min(replaceCount,Math.min(deleteCount, addCount));\\n                 } else {\\n                     arr[i][j] = arr[i-1][j-1];\\n                 }\\n             }\\n         }   \\n        \\n        return arr[word1.length()][word2.length()];\\n    }\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nif two characters are not equal:\\n\\t//cost to replace\\n\\tint replaceCount = 1 + function(s1, i+1, s2, j+1); // add 1 to the cost of replacing a character and go to the next set of characters.\\n\\t//cost to delete.\\n\\tint deleteCount = 1 + function(s1, i+1, s2, j); //add 1 to the cost of deleting the current char from string 1 and move to the next character from the first string assuming the current character won\\'t be considered anymore.\\n\\t//cost to add.\\n\\tint addCount = 1 + function(s1, i, s2, j+1);//add 1 to the cost of adding a new character to the second string and compare it with the current character from string 1. \\n```\n```\\nprivate int helper(String s1,  int i, String s2, int j) {\\n        if (i == s1.length()) {\\n            //the first word came to an end.\\n            return s2.length()-j;\\n        } else if (j == s2.length()) {\\n            return s1.length() - i;\\n        } else if (s1.charAt(i) == s2.charAt(j)) {\\n            return helper(s1, i+1, s2, j+1);            \\n        }\\n        else {\\n            //replace.\\n            int replaceCount = 1 + helper(s1, i+1, s2, j+1);\\n            //delete.\\n            int deleteCount = 1 + helper(s1, i+1, s2, j);\\n            //add.\\n            int addCount = 1 + helper(s1, i, s2, j+1);\\n            return Math.min(replaceCount,Math.min(deleteCount, addCount));\\n        }\\n    }\\n\\t\\t\\nAnd, call it with helper(word1,0,word2,0).\\n```\n```\\n    private int helper_rec(String s1,  int i, String s2, int j) {\\n        if (i < 0) {\\n            //the first word came to an end.\\n            return j+1;\\n        } else if (j < 0) {\\n            return i+1;\\n        } else if (s1.charAt(i) == s2.charAt(j)) {\\n            return helper_rec(s1, i-1, s2, j-1);            \\n        }\\n        else {\\n            //replace.\\n            int replaceCount = 1 + helper_rec(s1, i-1, s2, j-1);\\n            //delete.\\n            int deleteCount = 1 + helper_rec(s1, i-1, s2, j);\\n            //add.\\n            int addCount = 1 + helper_rec(s1, i, s2, j-1);\\n            return Math.min(replaceCount,Math.min(deleteCount, addCount));\\n        }\\n    }\\n```\n```\\n1. For the first part, just create an array with the size of those words.\\nint[][] arr = new int[word1.length()+1][word2.length()+1];\\n\\n2. Initialization is a bit tricky but we could assume that the index \\'0\\' is basically an empty  string and how could we convert a string  to an empty string. Here is how we initialize that part:\\n        //set the boundary conditions.\\n        for (int i = 0; i<arr.length; i++) {\\n            arr[i][0] = i; \\n        }\\n        \\n        for (int j = 0; j<arr[0].length; j++) {\\n            arr[0][j] = j; \\n        }\\n\\t\\t\\t\\t\\n3. Using recursive condition: it is pretty much straight-foward:\\n //replace.\\n                    int replaceCount = 1 + arr[i-1][j-1];\\n                    //delete.\\n                    int deleteCount = 1 + arr[i-1][j]; \\n                    //add.\\n                    int addCount = 1 + arr[i][j-1];\\n                    arr[i][j] =  Math.min(replaceCount,Math.min(deleteCount, addCount));\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tThe above is an equivalent of our recursive equation where the position of the index is actually a subscript of an  array.\\n\\t\\t\\t\\n\\t\\t\\t\\nThe only other thing to remember is when the characters match, we want to reuse the last known cost. That\\'s if the characters match at arr[i][j], the new cost will be arr[i-1][j-1] since that will still apply to our next set of iterations.\\n```\n```\\n    public int minDistance(String word1, String word2) {\\n        //return helper_rec(word1, word1.length()-1, word2, word2.length()-1);        \\n        int[][] arr = new int[word1.length()+1][word2.length()+1];\\n        //set the boundary conditions.\\n        for (int i = 0; i<arr.length; i++) {\\n            arr[i][0] = i; \\n        }\\n        \\n        for (int j = 0; j<arr[0].length; j++) {\\n            arr[0][j] = j; \\n        }\\n        \\n         for (int i=1; i<=word1.length();i++){\\n             for (int j=1; j<=word2.length() ;j++) {\\n                 if (word1.charAt(i-1) != word2.charAt(j-1)) {\\n                     //replace.\\n                    int replaceCount = 1 + arr[i-1][j-1];\\n                    //delete.\\n                    int deleteCount = 1 + arr[i-1][j]; \\n                    //add.\\n                    int addCount = 1 + arr[i][j-1];\\n                    arr[i][j] =  Math.min(replaceCount,Math.min(deleteCount, addCount));\\n                 } else {\\n                     arr[i][j] = arr[i-1][j-1];\\n                 }\\n             }\\n         }   \\n        \\n        return arr[word1.length()][word2.length()];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 25969,
                "title": "my-clean-java-solution-with-o-n-space-in-17-lines",
                "content": "    public class Solution {\\n        public int minDistance(String word1, String word2) {\\n            int[] d = new int[word2.length() + 1];\\n            for (int i = 0; i <= word2.length(); ++i) d[i] = i;\\n            for (int i = 1; i <= word1.length(); ++i) {\\n                int prev = d[0];\\n                d[0] = i;\\n                for (int j = 1; j <= word2.length(); ++j) {\\n                    int tmp = d[j];\\n                    d[j] = Math.min(d[j - 1], d[j]) + 1;\\n                    d[j] = Math.min(d[j], prev + (word1.charAt(i -1) == word2.charAt(j - 1) ? 0: 1));\\n                    prev = tmp;\\n                }\\n            }\\n            return d[word2.length()];\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int minDistance(String word1, String word2) {\\n            int[] d = new int[word2.length() + 1];\\n            for (int i = 0; i <= word2.length(); ++i) d[i] = i;\\n            for (int i = 1; i <= word1.length(); ++i) {\\n                int prev = d[0];\\n                d[0] = i;\\n                for (int j = 1; j <= word2.length(); ++j) {\\n                    int tmp = d[j];\\n                    d[j] = Math.min(d[j - 1], d[j]) + 1;\\n                    d[j] = Math.min(d[j], prev + (word1.charAt(i -1) == word2.charAt(j - 1) ? 0: 1));\\n                    prev = tmp;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3230647,
                "title": "look-at-once-solutions-in-java-python-and-c-with-video-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo solve this problem, we can use dynamic programming. We will create a 2D array to store the minimum number of operations required to convert a substring of word1 to a substring of word2.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLet dp[i][j] be the minimum number of operations required to convert the first i characters of word1 to the first j characters of word2. We will fill up this 2D array from top to bottom and from left to right.\\n\\nIf `word1[i-1] == word2[j-1]`, then no operation is required to convert `word1[0:i-1]` to `word2[0:j-1]`. Therefore, `dp[i][j] = dp[i-1][j-1]`.\\n\\nIf `word1[i-1] != word2[j-1]`, then we have three options:\\n\\n1. Replace: Replace the i-th character of word1 with the j-th character of word2. `dp[i][j] = dp[i-1][j-1] + 1`.\\n\\n2. Delete: Delete the i-th character of word1.` dp[i][j] = dp[i-1][j] + 1`.\\n\\n3. Insert: Insert the j-th character of word2 into word1. `dp[i][j] = dp[i][j-1] + 1`.\\n\\nThe final answer will be stored in `dp[word1.length()][word2.length()]`.\\n\\n# Video reference\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/ZkgBinDx9Kg\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n![image.png](https://assets.leetcode.com/users/images/2b37d2cc-3ca9-4b0c-866d-48abc59d8fa5_1677216789.1769023.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\\n\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the dynamic programming solution is $$O(mn)$$, where m and n are the lengths of word1 and word2, respectively. This is because we fill up a 2D array of size (m+1) x (n+1) using nested loops.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nThe space complexity of the dynamic programming solution is $$O(mn)$$, where m and n are the lengths of word1 and word2, respectively. This is because we use a 2D array of size (m+1) x (n+1) to store the minimum number of operations required to convert substrings of word1 to substrings of word2.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        int[][] dp = new int[word1.length()+1][word2.length()+1];\\n        \\n        for (int i = 0; i <= word1.length(); i++) {\\n            dp[i][0] = i;\\n        }\\n        \\n        for (int j = 0; j <= word2.length(); j++) {\\n            dp[0][j] = j;\\n        }\\n        \\n        for (int i = 1; i <= word1.length(); i++) {\\n            for (int j = 1; j <= word2.length(); j++) {\\n                if (word1.charAt(i-1) == word2.charAt(j-1)) {\\n                    dp[i][j] = dp[i-1][j-1];\\n                } else {\\n                    dp[i][j] = Math.min(dp[i-1][j-1], Math.min(dp[i-1][j], dp[i][j-1])) + 1;\\n                }\\n            }\\n        }\\n        \\n        return dp[word1.length()][word2.length()];\\n    }\\n}\\n\\n```\\n```javascript []\\nvar minDistance = function(word1, word2) {\\n    const m = word1.length;\\n    const n = word2.length;\\n    const dp = new Array(m+1).fill(null).map(() => new Array(n+1).fill(null));\\n    \\n    for (let i = 0; i <= m; i++) {\\n        dp[i][0] = i;\\n    }\\n    \\n    for (let j = 0; j <= n; j++) {\\n        dp[0][j] = j;\\n    }\\n    \\n    for (let i = 1; i <= m; i++) {\\n        for (let j = 1; j <= n; j++) {\\n            if (word1[i-1] === word2[j-1]) {\\n                dp[i][j] = dp[i-1][j-1];\\n            } else {\\n                dp[i][j] = Math.min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1;\\n            }\\n        }\\n    }\\n    \\n    return dp[m][n];\\n};\\n\\n```\\n```python []\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m, n = len(word1), len(word2)\\n        dp = [[0] * (n+1) for _ in range(m+1)]\\n        \\n        for i in range(m+1):\\n            dp[i][0] = i\\n        \\n        for j in range(n+1):\\n            dp[0][j] = j\\n        \\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                if word1[i-1] == word2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1\\n        \\n        return dp[m][n]\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = word1.length();\\n        int n = word2.length();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1));\\n        \\n        for (int i = 0; i <= m; i++) {\\n            dp[i][0] = i;\\n        }\\n        \\n        for (int j = 0; j <= n; j++) {\\n            dp[0][j] = j;\\n        }\\n        \\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (word1[i-1] == word2[j-1]) {\\n                    dp[i][j] = dp[i-1][j-1];\\n                } else {\\n                    dp[i][j] = min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1])) + 1;\\n                }\\n            }\\n        }\\n        \\n        return dp[m][n];\\n    }\\n};\\n`````\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\n```java []\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        int[][] dp = new int[word1.length()+1][word2.length()+1];\\n        \\n        for (int i = 0; i <= word1.length(); i++) {\\n            dp[i][0] = i;\\n        }\\n        \\n        for (int j = 0; j <= word2.length(); j++) {\\n            dp[0][j] = j;\\n        }\\n        \\n        for (int i = 1; i <= word1.length(); i++) {\\n            for (int j = 1; j <= word2.length(); j++) {\\n                if (word1.charAt(i-1) == word2.charAt(j-1)) {\\n                    dp[i][j] = dp[i-1][j-1];\\n                } else {\\n                    dp[i][j] = Math.min(dp[i-1][j-1], Math.min(dp[i-1][j], dp[i][j-1])) + 1;\\n                }\\n            }\\n        }\\n        \\n        return dp[word1.length()][word2.length()];\\n    }\\n}\\n\\n```\n```javascript []\\nvar minDistance = function(word1, word2) {\\n    const m = word1.length;\\n    const n = word2.length;\\n    const dp = new Array(m+1).fill(null).map(() => new Array(n+1).fill(null));\\n    \\n    for (let i = 0; i <= m; i++) {\\n        dp[i][0] = i;\\n    }\\n    \\n    for (let j = 0; j <= n; j++) {\\n        dp[0][j] = j;\\n    }\\n    \\n    for (let i = 1; i <= m; i++) {\\n        for (let j = 1; j <= n; j++) {\\n            if (word1[i-1] === word2[j-1]) {\\n                dp[i][j] = dp[i-1][j-1];\\n            } else {\\n                dp[i][j] = Math.min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1;\\n            }\\n        }\\n    }\\n    \\n    return dp[m][n];\\n};\\n\\n```\n```python []\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m, n = len(word1), len(word2)\\n        dp = [[0] * (n+1) for _ in range(m+1)]\\n        \\n        for i in range(m+1):\\n            dp[i][0] = i\\n        \\n        for j in range(n+1):\\n            dp[0][j] = j\\n        \\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                if word1[i-1] == word2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1\\n        \\n        return dp[m][n]\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = word1.length();\\n        int n = word2.length();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1));\\n        \\n        for (int i = 0; i <= m; i++) {\\n            dp[i][0] = i;\\n        }\\n        \\n        for (int j = 0; j <= n; j++) {\\n            dp[0][j] = j;\\n        }\\n        \\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (word1[i-1] == word2[j-1]) {\\n                    dp[i][j] = dp[i-1][j-1];\\n                } else {\\n                    dp[i][j] = min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1])) + 1;\\n                }\\n            }\\n        }\\n        \\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1707160,
                "title": "leetcode-the-hard-way-0072-edit-distance-hard",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord Study Group](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [Screencast](https://www.youtube.com/watch?v=5by6g9bxPW8&list=PLBu4Bche1aEU-8z7xl3-B9lfw_DJtT_xs&index=26) if you are interested.\\n\\n---\\n\\nEdit distance is a classic DP problem. It is used to quantify the dissimilarity of two given strings by counting the minimum possible number of operations required to transform one string into the other. \\n\\nGiven that the constraints, we assume that a O(m * n) solution would pass. \\n\\nLet\\'s define ``dp[i][j]`` as the minimum edit distance between the first i character of ``word1`` and the first ``j`` characters of ``word2``. In example 1, ``dp[3][2]``would be the edit distance between ``word1[1..3]`` (HOR) and ``word2[1..2]``(RO). \\n\\nIf the last character is the same, then ``dp[i][j]`` would be ``dp[i - 1][j - 1]`` because we don\\'t need to perform any operation. Otherwise, we need to perform either one. There are three possible ways to do the transformation.\\n\\n- We can transform ``word1[1..i]`` to ``word2[1..j-1]`` by adding ``word2[j]`` afterwards to get ``word2[1..j]``.\\n- We can transform ``word1[1..i-1]`` to ``word2[1..j]`` by deleting ``word1[i]``.\\n- We can transform ``word1[1..i-1]`` to ``word2[1..j-1]`` by exchanging the original ``word1[i]`` for ``word2[j]``.\\n\\nTherefore, the transition would be ``dp[i][j] = 1 + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])`` if ``word1[i]`` is not equal to ``word2[j]``.\\n\\nWhat is the base case then? The base case is simply an edit distance between the empty string and non-empty string, i.e. ``dp[i][0] = i`` and ``dp[0][j] = j``. The answer would be ``dp[m][n]``. This algorithm is also known as Wagner\\u2013Fischer algorithm.\\n\\n![image](https://assets.leetcode.com/users/images/00774ca9-da4e-4873-a6c5-9d7596b60b19_1642775600.173192.png)\\n\\nTime Complexity: O(m * n)\\nSpace Complexity: O(m * n)\\n\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = (int) word1.size();\\n        int n = (int) word2.size();\\n        int dp[m + 1][n + 1];\\n        memset(dp, 0, sizeof(dp));\\n        for (int i = 1; i <= m; i++) dp[i][0] = i;\\n        for (int j = 1; j <= n; j++) dp[0][j] = j;\\n        for (int i = 1; i <= m; i++){\\n            for(int j = 1; j <= n; j++){\\n                if(word1[i - 1] == word2[j - 1]) { // a = b\\n                    dp[i][j] = dp[i - 1][j - 1]; \\n                } else {\\n                    // find out the min cost for all three actions\\n                    dp[i][j] = 1 + min({\\n                        dp[i - 1][j - 1], // replace a with b\\n                        dp[i - 1][j],     // delete a\\n                        dp[i][j - 1]      // insert b after a\\n                    });\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```\\n\\n```py\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m, n = len(word1), len(word2)\\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\\n        for i in range(1, m + 1): dp[i][0] = i\\n        for j in range(1, n + 1): dp[0][j] = j\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                if word1[i - 1] == word2[j - 1]:\\n                    # a == b\\n                    dp[i][j] = dp[i - 1][j - 1]\\n                else:\\n                    # find out the min cost for all three actions\\n                    # dp[i - 1][j - 1]: replace a with b\\n                    # dp[i - 1][j]: delete a\\n                    # dp[i - 1][j]: insert b after a\\n                    dp[i][j] = 1 + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\\n        return dp[m][n]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = (int) word1.size();\\n        int n = (int) word2.size();\\n        int dp[m + 1][n + 1];\\n        memset(dp, 0, sizeof(dp));\\n        for (int i = 1; i <= m; i++) dp[i][0] = i;\\n        for (int j = 1; j <= n; j++) dp[0][j] = j;\\n        for (int i = 1; i <= m; i++){\\n            for(int j = 1; j <= n; j++){\\n                if(word1[i - 1] == word2[j - 1]) { // a = b\\n                    dp[i][j] = dp[i - 1][j - 1]; \\n                } else {\\n                    // find out the min cost for all three actions\\n                    dp[i][j] = 1 + min({\\n                        dp[i - 1][j - 1], // replace a with b\\n                        dp[i - 1][j],     // delete a\\n                        dp[i][j - 1]      // insert b after a\\n                    });\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```\n```py\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m, n = len(word1), len(word2)\\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\\n        for i in range(1, m + 1): dp[i][0] = i\\n        for j in range(1, n + 1): dp[0][j] = j\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                if word1[i - 1] == word2[j - 1]:\\n                    # a == b\\n                    dp[i][j] = dp[i - 1][j - 1]\\n                else:\\n                    # find out the min cost for all three actions\\n                    # dp[i - 1][j - 1]: replace a with b\\n                    # dp[i - 1][j]: delete a\\n                    # dp[i - 1][j]: insert b after a\\n                    dp[i][j] = 1 + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\\n        return dp[m][n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1402780,
                "title": "begineerfriendly-java-c",
                "content": "**\\nFirstly go and read the code this is further explaination to my code you will get the explaination better after reading the code once\\nand this explaination is also covering the aswer to the comment .\\n\\ni m just checking at every index whether that character is equal or not, if equal I just have to move further  , but in case characters are not equal we can have 3 operations, ins, del, replace. and we are storing the minimum out of these three in the DP array.\\n\\nlet\\'s say s1 as \"abc\" and s2 as \"abd\" ,and we are at index 2, always if found both characters are different \\n\\n// Insertion (dp[i][j-1])\\nI m always inserting at the right of the current char\\n\\ns1 - \"abc\" s2 - \"abd\"\\ni is at c in s1 \\nj is at d in s2.\\n\\nafter insertion\\ns1 become \"abcd\", s2 remain the same \"abd\" ,\\ni is currently at c in s1 \\nand j  is currently at d in s2 , but as we have inserted a \\'d\\' in s1 we have to decrement j , i remains the same \\ni = I;    j = j-1;\\n\\n// deletion   ( dp[i-1][j] )\\n\\n if I chooses to delete c , instead of inserting d  , in this case if I m deleting c then I have to decrement i , but j remains the same.\\ns1 - \"abc\" s2 - \"abd\"\\n          i is at c in s1\\n\\t\\t  j is at d in s2\\n\\t\\t  \\nafter deletion s1 - \"ab\" s2 - \"abd\"\\n          as we have deleted c from s1 we should decrement i , but we will only decrement j once we found character equal to d in s1\\n         I = i-1 , j = j;\\n\\n// replace (dp[i-1][j-1])\\n\\nif I choose to replace i m making the current characters equal then I need to decrement both indices , I, j , because current characters are equal \\nnow we only have to check for remaining string\\n\\nex ----- s1 - \"abc\" s2 - \"abd\"\\nif I choose to replace  \\'c\\'  by  \\'d\\'   then both the strings become\\ns1 ---- \"abd\" s2 ---- \"abd\"\\n              as i is at d in s1 \\n\\t\\t\\t  and also j is at d in s2 , and both the characters are equal we just have to decrement both.\\n   I = i-1 , j = j-1;\\t\\n   \\n   \\n\\t\\nNote we are decrementing j only when both the character matches**\\n\\t\\n\\t//\\tif character matches then just decrement both the index , but if they don\\'t matches then store the minimum possibl;e value by applying\\n\\t\\t// each operation at that particular index.\\n\\t\\t\\n\\t\\tJava code\\n\\t\\t\\t\\n\\t\\t\\tclass Solution {\\n\\t\\t\\t\\tpublic int minDistance(String s1, String s2) {\\n\\t\\t\\t\\t\\tint n = s1.length();\\n\\t\\t\\t\\t\\tint m = s2.length();\\n\\t\\t\\t\\t\\tint[][] dp = new int[n+1][m+1];\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// base cases will contain the length of string which is not empty\\n\\t\\t\\t\\t\\t//because to convert empty string to another string we need no of operations = length of string\\n\\t\\t\\t\\t\\tfor(int i=0;i<=n;i++){\\n\\t\\t\\t\\t\\t\\tdp[i][0] = i;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tfor(int i=0;i<=m;i++){\\n\\t\\t\\t\\t\\t\\tdp[0][i] = i;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\t\\t\\t\\tfor(int j=1;j<=m;j++){\\n\\t\\t\\t\\t\\t\\t\\tif(s1.charAt(i-1) == s2.charAt(j-1)){\\n\\t\\t\\t\\t\\t\\t\\t//as characters are the same we are just decreasing the index\\n\\t\\t\\t\\t\\t\\t\\t\\tdp[i][j] = dp[i-1][j-1];\\n\\t\\t\\t\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\t\\t//chars are not the same now we have to put the minimum ans out of ans obtained by  insertion,deletion,replace  \\n\\t\\t\\t\\t\\t\\t\\t\\t//\\tminimum answer              min(insertion , deletion )          min(deletion,replace)             \\n\\t\\t\\t\\t\\t\\t\\t\\tdp[i][j] = 1 + Math.min( Math.min(dp[i][j-1] ,dp[i-1][j]) , Math.min(dp[i-1][j] ,dp[i-1][j-1]) );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn dp[n][m];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t//If the post was helpful please upvote , any query can be asked in the comments\\n\\t\\t\\t//thankyou for your upvote\\n\\t\\t\\t\\n\\t\\t\\t\\nC++ Code --------- Logic is same in both only difference is in syntax............\\n\\n\\t//\\tif character matches then just decrement both the index , but if they don\\'t matches then store the minimum possibl;e value by applying\\n\\t\\t// each operation at that particular index.\\n\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint minDistance(string s1, string s2) {\\n\\t\\t\\t\\tint n = s1.length();\\n\\t\\t\\t\\tint m = s2.length();\\n\\t\\t\\t\\tint dp[n+1][m+1];\\n\\n\\t\\t\\t\\t\\t// base cases will contain the length of string which is not empty\\n\\t\\t\\t\\t\\t//because to convert empty string to another string we need no of operations = length of string\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\tfor(int i=0;i<=n;i++){\\n\\t\\t\\t\\t\\tdp[i][0] = i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor(int i=0;i<=m;i++){\\n\\t\\t\\t\\t\\tdp[0][i] = i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\t\\t\\tfor(int j =1;j<=m;j++){\\n\\t\\t\\t\\t\\t//as characters are the same we are just decreasing the index\\n\\t\\t\\t\\t\\t\\tif(s1[i-1] == s2[j-1]){\\n\\t\\t\\t\\t\\t\\t\\tdp[i][j] = dp[i-1][j-1];\\n\\t\\t\\t\\t\\t\\t}else{\\n\\t//chars are not the same now we have to put the minimum ans out of ans obtained by  insertion,deletion,replace \\n\\t//\\tminimum answer    =          min(  min(insertion , deletion )  ,  min(deletion,replace)   )          \\n\\t\\t\\t\\t\\t\\t\\tdp[i][j] = 1+ min(min(dp[i][j-1] , dp[i-1][j]) , min(dp[i-1][j-1] , dp[i-1][j-1]));\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn dp[n][m];\\n\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t//If the post was helpful please upvote , any query can be asked in the comments\\n\\t\\t\\t//thankyou for your upvote\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t",
                "solutionTags": [
                    "Java",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\t\\t\\t\\tpublic int minDistance(String s1, String s2) {\\n\\t\\t\\t\\t\\tint n = s1.length();\\n\\t\\t\\t\\t\\tint m = s2.length();\\n\\t\\t\\t\\t\\tint[][] dp = new int[n+1][m+1];\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// base cases will contain the length of string which is not empty\\n\\t\\t\\t\\t\\t//because to convert empty string to another string we need no of operations = length of string\\n\\t\\t\\t\\t\\tfor(int i=0;i<=n;i++){\\n\\t\\t\\t\\t\\t\\tdp[i][0] = i;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1391563,
                "title": "c-3-steps-solution-easy-concise-explanation-complexities",
                "content": "* ###  **THIS PROBLEM IS A VERY CLASSICAL PROBLEM OF DP**\\n**EXPLANATION:**\\n1. **`THE IDEA IS VERY VERY SIMPLE, IF YOU UNDERSTAND THE RECURSIVE CODE LOGIC THEN, CONVERT IT INTO DP IS CAKEWALK !!! :)`**\\n\\n1. **`IN THIS PROBLEM WE\\'RE GIVEN A TWO STRINGS \"Word1\" && \"Word2\". WE NEED TO CONVERT FIRST STRING TO SECOND, WITH THE HELP OF THREE OPERATIONS (INSERT, DELETE, REPLACE)..`**\\n\\n1. **`STEP 1: WHEN BOTH CHARACTERS OF STRING MATCHES WE DO NOT HAVE TO DO ANYTHING (ANY OPERATIONS). JUST SIMPLY RECURR FOR NEXT ELEMENTS IN BOTH STRINGS`!**\\n1. **`STEP 2: WHEN CHARACTERS DOESN\\'T MATCH, WE NEED TO DO THREE OPERATIONS THAT IS`:**\\n        **`a) INSERT :  editDist(w1, w2, n, m - 1) :- Decrement second string size, cuz we have to insert character according to second string`** \\n        **`b) DELETE :  editDist(w1, w2, n - 1, m) :- Decrement first string size, cuz we to convert first string to second string =, by deleting characters`** \\n        **`c) REPLACE : editDist(w1, w2, n - 1, m - 1) :- Again, decrement Both string size, cuz let assume we replaced the character of second string with the character                                                    of first string. Hence, both characters are same again.`**  \\n1. **`STEP 3: TAKE THE MINIMUM OF THREE SUB-RESULTS.`**\\n### **RECURSIVE SOLUTION :- T.L.E. (Not Accepted)**\\n```\\n// Recursive Code\\nclass Solution {\\npublic:\\n    int editDist(string &w1, string &w2, int n, int m){\\n        if(n == 0)                          // Base Case 1 : If first string is empty, simply return second string len. Because, we need atleast second\\n            return m;                       //               string size or len to convert first into second\\n        else if(m == 0)\\n                return n;                   // Base Case2 2: Vice-Versa of above base case\\n        else if(w1[n - 1] == w2[m - 1])\\n               return editDist(w1, w2, n - 1, m - 1); //  when both characters are matched don\\'t need to do any operations \\n        else               \\n            return 1 + min({editDist(w1, w2, n, m - 1), editDist(w1, w2, n - 1, m), editDist(w1, w2, n - 1, m - 1)});  // When characters Doesn\\'t match \\n    }                                                                                                          // we need to do Three Operations as \\n    int minDistance(string word1, string word2) {                                                          // Mentioned Above & Take the minimum of them\\n        int n = word1.size(), m = word2.size();\\n        return editDist(word1, word2, n, m);\\n    }\\n};\\n```\\n**TIME COMPLEXITY : `O(3^N)`, Where, `N = (m + n)`, n : size of word1 & m  : size of word2** \\n**SPACE COMPLEXITY : `O(constant)`, ignoring recusrion stack**\\n```\\n```\\n### **DP SOLUTION: TOP-DOWN OR MEMOIZATION (Accepted)**\\n* **Runtime : 10ms**\\n```\\n// Memoized Code (Top-Down)\\nclass Solution {\\npublic:\\n    int editDist(string &w1, string &w2, int n, int m, vector<vector<int>>& memo){\\n        if(n == 0)\\n            return m;\\n        if(m == 0)\\n                return n;\\n        if(memo[n][m] != -1)\\n            return memo[n][m];\\n        if(w1[n - 1] == w2[m - 1]){\\n            memo[n][m] = editDist(w1, w2, n - 1, m - 1, memo); //  when both characters are matched don\\'t need to do any operations\\n            return memo[n][m];\\n        }\\n        else{               // When characters Doesn\\'t match we need to do Three Operations as Mentioned Above & Take the minimum of them\\n            memo[n][m] = 1 + min({editDist(w1, w2, n, m - 1, memo), editDist(w1, w2, n - 1, m, memo), editDist(w1, w2, n - 1, m - 1, memo)});\\n            return memo[n][m];\\n        }\\n    }\\n    int minDistance(string word1, string word2) {\\n        int n = word1.size(), m = word2.size();\\n        vector<vector<int>> memo(n + 1, vector<int> (m + 1, -1));\\n        return editDist(word1, word2, n, m, memo);\\n    }\\n};\\n```\\n**TIME COMPLEXITY : `O(n * m)`, Where, n : size of word1 & m  : size of word2** \\n**SPACE COMPLEXITY : `O(n * m)`, For using 2D array Aux space & Again, ignoring recusrion stack**\\n```\\n```\\n### **DP SOLUTION: BOTTOM-UP OR TABULATION (Accepted)**\\n* **Runtime : 4ms**\\n```\\n// Tabulation Code (Bottom-Up)\\nclass Solution {\\npublic:\\n    int minDistance(string w1, string w2) {\\n        int n = w1.size(), m = w2.size();\\n        vector<vector<int>> dp(n + 1, vector<int> (m + 1, 0));\\n        for(int i = 0; i <= n; ++i)     // Base Case 1:\\n            dp[i][0] = i;\\n        \\n        for(int j = 0; j <=m; ++j)      // Base Case 2: \\n            dp[0][j] = j;\\n        \\n        for (int i = 1; i <= n; ++i) {\\n            for (int j = 1; j <= m; ++j) {\\n                if(w1[i - 1] == w2[j - 1])          //  when both characters are matched don\\'t need to do any operations\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                else                               // When characters Doesn\\'t match we need to do Three Operations as Mentioned Above & Take the minimum of them\\n                    dp[i][j] = 1 + min({dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1]});\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```\\n**TIME COMPLEXITY : `O(n * m)`, Where, n : size of word1 & m  : size of word2** \\n**SPACE COMPLEXITY :  `O(n * m)`, For using 2D array Aux space**\\n\\nif you find any mistakes pls, drop a comment\\nif it makes any sense **Pls Upvote :)**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n// Recursive Code\\nclass Solution {\\npublic:\\n    int editDist(string &w1, string &w2, int n, int m){\\n        if(n == 0)                          // Base Case 1 : If first string is empty, simply return second string len. Because, we need atleast second\\n            return m;                       //               string size or len to convert first into second\\n        else if(m == 0)\\n                return n;                   // Base Case2 2: Vice-Versa of above base case\\n        else if(w1[n - 1] == w2[m - 1])\\n               return editDist(w1, w2, n - 1, m - 1); //  when both characters are matched don\\'t need to do any operations \\n        else               \\n            return 1 + min({editDist(w1, w2, n, m - 1), editDist(w1, w2, n - 1, m), editDist(w1, w2, n - 1, m - 1)});  // When characters Doesn\\'t match \\n    }                                                                                                          // we need to do Three Operations as \\n    int minDistance(string word1, string word2) {                                                          // Mentioned Above & Take the minimum of them\\n        int n = word1.size(), m = word2.size();\\n        return editDist(word1, word2, n, m);\\n    }\\n};\\n```\n```\\n```\n```\\n// Memoized Code (Top-Down)\\nclass Solution {\\npublic:\\n    int editDist(string &w1, string &w2, int n, int m, vector<vector<int>>& memo){\\n        if(n == 0)\\n            return m;\\n        if(m == 0)\\n                return n;\\n        if(memo[n][m] != -1)\\n            return memo[n][m];\\n        if(w1[n - 1] == w2[m - 1]){\\n            memo[n][m] = editDist(w1, w2, n - 1, m - 1, memo); //  when both characters are matched don\\'t need to do any operations\\n            return memo[n][m];\\n        }\\n        else{               // When characters Doesn\\'t match we need to do Three Operations as Mentioned Above & Take the minimum of them\\n            memo[n][m] = 1 + min({editDist(w1, w2, n, m - 1, memo), editDist(w1, w2, n - 1, m, memo), editDist(w1, w2, n - 1, m - 1, memo)});\\n            return memo[n][m];\\n        }\\n    }\\n    int minDistance(string word1, string word2) {\\n        int n = word1.size(), m = word2.size();\\n        vector<vector<int>> memo(n + 1, vector<int> (m + 1, -1));\\n        return editDist(word1, word2, n, m, memo);\\n    }\\n};\\n```\n```\\n```\n```\\n// Tabulation Code (Bottom-Up)\\nclass Solution {\\npublic:\\n    int minDistance(string w1, string w2) {\\n        int n = w1.size(), m = w2.size();\\n        vector<vector<int>> dp(n + 1, vector<int> (m + 1, 0));\\n        for(int i = 0; i <= n; ++i)     // Base Case 1:\\n            dp[i][0] = i;\\n        \\n        for(int j = 0; j <=m; ++j)      // Base Case 2: \\n            dp[0][j] = j;\\n        \\n        for (int i = 1; i <= n; ++i) {\\n            for (int j = 1; j <= m; ++j) {\\n                if(w1[i - 1] == w2[j - 1])          //  when both characters are matched don\\'t need to do any operations\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                else                               // When characters Doesn\\'t match we need to do Three Operations as Mentioned Above & Take the minimum of them\\n                    dp[i][j] = 1 + min({dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1]});\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1006113,
                "title": "recursion-and-memoization-aditya-verma-approach",
                "content": "Do upvote, if found helpful.\\n\\nRecursive - \\n\\n```\\nclass Solution {\\npublic:\\n\\n    int fun(string a, string b, int i, int j)\\n    {\\n        if(i<0)\\n        return j+1; \\n\\n        if(j<0)\\n        return i+1;\\n\\n        if(a[i]==b[j])\\n        return fun(a,b,i-1,j-1);\\n\\n        else\\n        return 1 + min(fun(a,b,i-1,j), min(fun(a,b,i,j-1),fun(a,b,i-1,j-1))); \\n    }\\n\\n    \\n    int minDistance(string a, string b) \\n    {\\n        int n = a.size();\\n        int m = b.size();\\n\\n        return fun(a,b,n-1,m-1);   \\n    }\\n};\\n```\\n\\nMemoization - \\n\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> dp;\\n\\n    int fun(string a, string b, int i, int j)\\n    {\\n        if(i<0)\\n        return j+1; \\n\\n        if(j<0)\\n        return i+1;\\n\\n        if(dp[i][j]!=-1)\\n        return dp[i][j];\\n\\n        if(a[i]==b[j])\\n        return dp[i][j] = fun(a,b,i-1,j-1);\\n\\n        else\\n        return dp[i][j] = 1 + min(fun(a,b,i-1,j), min(fun(a,b,i,j-1),fun(a,b,i-1,j-1))); \\n    }\\n\\n    \\n    int minDistance(string a, string b) \\n    {\\n        int n = a.size();\\n        int m = b.size();\\n\\n        dp.clear();\\n        dp.resize(n+1,vector<int> (m+1,-1));\\n        return fun(a,b,n-1,m-1);   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int fun(string a, string b, int i, int j)\\n    {\\n        if(i<0)\\n        return j+1; \\n\\n        if(j<0)\\n        return i+1;\\n\\n        if(a[i]==b[j])\\n        return fun(a,b,i-1,j-1);\\n\\n        else\\n        return 1 + min(fun(a,b,i-1,j), min(fun(a,b,i,j-1),fun(a,b,i-1,j-1))); \\n    }\\n\\n    \\n    int minDistance(string a, string b) \\n    {\\n        int n = a.size();\\n        int m = b.size();\\n\\n        return fun(a,b,n-1,m-1);   \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> dp;\\n\\n    int fun(string a, string b, int i, int j)\\n    {\\n        if(i<0)\\n        return j+1; \\n\\n        if(j<0)\\n        return i+1;\\n\\n        if(dp[i][j]!=-1)\\n        return dp[i][j];\\n\\n        if(a[i]==b[j])\\n        return dp[i][j] = fun(a,b,i-1,j-1);\\n\\n        else\\n        return dp[i][j] = 1 + min(fun(a,b,i-1,j), min(fun(a,b,i,j-1),fun(a,b,i-1,j-1))); \\n    }\\n\\n    \\n    int minDistance(string a, string b) \\n    {\\n        int n = a.size();\\n        int m = b.size();\\n\\n        dp.clear();\\n        dp.resize(n+1,vector<int> (m+1,-1));\\n        return fun(a,b,n-1,m-1);   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 273352,
                "title": "java-7m-dp-solution-with-detailed-explanation",
                "content": "we use a array ```dist``` to save the minimum distance of substring of ```word1``` and ```word2```, i.e., ```dist[i][j]``` denotes the minimum distance of ```word1.substring(0, i)``` and ```word2.substring(0, j)```.\\nApparently, ```dist[0][j] = j``` and ```dist[i][0] = i```.\\nWhen we calculate ```dist[i][j]```, we first compare ```word1[i]``` and ```word2[j]```, if ```word1[i]``` equals ```word2[j]```, then ```dist[i][j]``` equals ```dist[i - 1][j - 1]```. If ```word1[i] != word2[j]```, then we have three operations:\\n1. replace word1[i] with word2[j] (```dist[i - 1][j - 1] + 1```)\\n2. delete word1[i] (```dist[i - 1][j] + 1```)\\n3. delete word2[j] (```dist[i][j - 1] + 1```)\\n\\nNote that insert and delete are symmetric operations, so we choice 2 is equal to insert character to word2 and choice 3 is equal to insert character to word1.\\n```\\npublic int minDistance(String word1, String word2) {\\n\\tint dist[][] = new int[word1.length() + 1][word2.length() + 1];\\n\\tfor(int i = 0; i < word1.length(); i++) \\n\\t\\tdist[i + 1][0] = i + 1;\\n\\tfor(int i = 0; i < word2.length(); i++)\\n\\t\\tdist[0][i + 1] = i + 1;\\n\\tfor(int i = 0; i < word1.length(); i++) {\\n\\t\\tfor(int j = 0; j < word2.length(); j++) {\\n\\t\\t\\tif( word1.charAt(i) == word2.charAt(j) )\\n\\t\\t\\t\\tdist[i + 1][j + 1] = dist[i][j];\\n\\t\\t\\telse\\n\\t\\t\\t\\tdist[i + 1][j + 1] = Math.min(Math.min(dist[i][j + 1], dist[i + 1][j]) + 1, dist[i][j] + 1);\\n\\t\\t}\\n\\t}\\n\\treturn dist[word1.length()][word2.length()];\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```dist```\n```word1```\n```word2```\n```dist[i][j]```\n```word1.substring(0, i)```\n```word2.substring(0, j)```\n```dist[0][j] = j```\n```dist[i][0] = i```\n```dist[i][j]```\n```word1[i]```\n```word2[j]```\n```word1[i]```\n```word2[j]```\n```dist[i][j]```\n```dist[i - 1][j - 1]```\n```word1[i] != word2[j]```\n```dist[i - 1][j - 1] + 1```\n```dist[i - 1][j] + 1```\n```dist[i][j - 1] + 1```\n```\\npublic int minDistance(String word1, String word2) {\\n\\tint dist[][] = new int[word1.length() + 1][word2.length() + 1];\\n\\tfor(int i = 0; i < word1.length(); i++) \\n\\t\\tdist[i + 1][0] = i + 1;\\n\\tfor(int i = 0; i < word2.length(); i++)\\n\\t\\tdist[0][i + 1] = i + 1;\\n\\tfor(int i = 0; i < word1.length(); i++) {\\n\\t\\tfor(int j = 0; j < word2.length(); j++) {\\n\\t\\t\\tif( word1.charAt(i) == word2.charAt(j) )\\n\\t\\t\\t\\tdist[i + 1][j + 1] = dist[i][j];\\n\\t\\t\\telse\\n\\t\\t\\t\\tdist[i + 1][j + 1] = Math.min(Math.min(dist[i][j + 1], dist[i + 1][j]) + 1, dist[i][j] + 1);\\n\\t\\t}\\n\\t}\\n\\treturn dist[word1.length()][word2.length()];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3230529,
                "title": "c-easiest-approach-with-best-explanation-beats-100-using-dp",
                "content": "# Intuition\\nThe problem requires finding the minimum number of operations required to convert one string to another. We can perform three types of operations: insert a character, delete a character, or replace a character.\\n\\nTo solve this problem, we can use dynamic programming. We can create a matrix where the rows represent the characters in the first string and the columns represent the characters in the second string. We can fill the matrix using a bottom-up approach.\\n\\nThe base case is when one of the strings is empty. In this case, the minimum number of operations required is equal to the length of the non-empty string.\\n\\nFor the general case, we can use the following recurrence relation: if the current characters in the two strings match, the minimum number of operations required is the same as the minimum number of operations required to convert the first i-1 characters in the first string to the first j-1 characters in the second string. Otherwise, we can either insert a character, delete a character, or replace a character. We can take the minimum of these three options and add one to get the minimum number of operations required to convert the first i characters in the first string to the first j characters in the second string.\\n\\nThe final answer is stored in the bottom-right corner of the matrix.<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nHere\\'s the step-by-step approach:\\n\\n1. Initialize a matrix dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2, respectively.\\n2. Fill in the base cases:\\ndp[i][0] = i for i from 0 to m.\\ndp[0][j] = j for j from 0 to n.\\n3. For each i from 1 to m and each j from 1 to n, compute the value of dp[i][j] as follows:\\n4. If word1[i-1] is equal to word2[j-1], then dp[i][j] = dp[i-1][j-1]. Otherwise, dp[i][j] is the minimum of the following three values plus 1:\\na) dp[i][j-1], which represents inserting a character in word1.\\nb) dp[i-1][j], which represents deleting a character in word1.\\nc) dp[i-1][j-1], which represents replacing a character in word1.\\n5. Return dp[m][n], which is the minimum number of operations required to convert word1 to word2.\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the solution is O(mn), where m and n are the lengths of the input strings. This is because we need to fill in an (m+1) x (n+1) matrix, and each cell takes constant time to fill.\\n\\n- Space complexity: O(mn)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = word1.length();\\n        int n = word2.length();\\n        \\n        vector<vector<int>> dp(m+1, vector<int>(n+1));\\n        \\n        for (int i = 0; i <= m; i++) {\\n            dp[i][0] = i;\\n        }\\n        \\n        for (int j = 0; j <= n; j++) {\\n            dp[0][j] = j;\\n        }\\n        \\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (word1[i-1] == word2[j-1]) {\\n                    dp[i][j] = dp[i-1][j-1];\\n                } else {\\n                    dp[i][j] = 1 + min({dp[i][j-1], dp[i-1][j], dp[i-1][j-1]});\\n                }\\n            }\\n        }\\n        \\n        return dp[m][n];\\n    }\\n};\\n//\\uD83D\\uDC47please upvote if you liked my approach and explanation\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = word1.length();\\n        int n = word2.length();\\n        \\n        vector<vector<int>> dp(m+1, vector<int>(n+1));\\n        \\n        for (int i = 0; i <= m; i++) {\\n            dp[i][0] = i;\\n        }\\n        \\n        for (int j = 0; j <= n; j++) {\\n            dp[0][j] = j;\\n        }\\n        \\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (word1[i-1] == word2[j-1]) {\\n                    dp[i][j] = dp[i-1][j-1];\\n                } else {\\n                    dp[i][j] = 1 + min({dp[i][j-1], dp[i-1][j], dp[i-1][j-1]});\\n                }\\n            }\\n        }\\n        \\n        return dp[m][n];\\n    }\\n};\\n//\\uD83D\\uDC47please upvote if you liked my approach and explanation\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2176745,
                "title": "python-recursive-memoization-tabular-dp-with-detailed-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/ebd26aeb-c4c8-45bd-90cb-1d01670b37b9_1655779370.086117.jpeg)\\n![image](https://assets.leetcode.com/users/images/8114c2a7-9765-4868-a01c-76eccc8d6c0f_1655779380.6150026.jpeg)\\n![image](https://assets.leetcode.com/users/images/fbf87ad1-e78e-4e9c-9c5f-d4b95385bf98_1655779388.4014256.jpeg)\\n\\n\\n\\n**Recursive**:\\n```\\nclass Solution:\\n    def minDistance(self, w1: str, w2: str) -> int:\\n        def solve(w1, w2, n, m): \\n            # Base Case if any one of w1 or w2 is empty \\n            if n == 0 or m == 0: return m or n\\n            \\n            elif w1[n-1] == w2[m-1]:\\n                return solve(w1, w2, n-1, m-1)\\n            \\n            else:\\n                return 1 + min(\\n                                solve(w1, w2, n-1, m-1),  # Replace\\n                                solve(w1, w2, n-1, m),    # Delete\\n                                solve(w1, w2, n, m-1)     # Insert\\n                                )\\n        \\n        return solve(w1, w2, len(w1), len(w2))\\n    \\n\\n# Time Limit Exceeded\\n# We need to use Memoization in this Solution to avoid repetative same calculation of sub-problems\\n```\\n\\n**Memoization**:\\n```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        memo = {}\\n        \\n        def dfs(i, j):\\n            if i == 0 or j == 0: return j or i\\n                        \\n            if (i,j) in memo:\\n                return memo[(i,j)]\\n            \\n            if word1[i-1] == word2[j-1]:\\n                ans = dfs(i-1, j-1)\\n            else: \\n                ans = 1 + min(dfs(i, j-1), dfs(i-1, j), dfs(i-1, j-1))\\n                \\n            memo[(i,j)] = ans\\n            return memo[(i,j)]\\n        \\n        return dfs(len(word1), len(word2))\\n\\t\\t\\n# Time: O(N^2)\\n# Space: O(N^2)\\n```\\n\\n\\n**Tabular DP**:\\n```\\nclass Solution:\\n    def minDistance(self, w1: str, w2: str) -> int:\\n        n = len(w1); m = len(w2)\\n        \\n        dp = [[0]*(m+1) for i in range(n+1)]\\n        \\n        for j in range(m+1): # Base Case 0th row where len(w1) = 0\\n            dp[0][j] = j\\n        \\n        for i in range(n+1): # Base Case 0th column where len(w2) = 0\\n            dp[i][0] = i\\n        \\n        for i in range(1, n+1):\\n            for j in range(1, m+1):\\n                if w1[i-1] == w2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = 1 + min(\\n                                        dp[i-1][j-1],  # Replace \\n                                        dp[i-1][j],    # Delete\\n                                        dp[i][j-1]     # Insert\\n                                        )\\n        \\n        return dp[-1][-1]\\n\\t\\t\\n# Time: O(N^2)\\n# Space: O(N^2)\\n```\\n\\nAll Concepts of DP: **https://github.com/SamirPaul1/DSAlgo/tree/main/02_Dynamic-Programming**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def minDistance(self, w1: str, w2: str) -> int:\\n        def solve(w1, w2, n, m): \\n            # Base Case if any one of w1 or w2 is empty \\n            if n == 0 or m == 0: return m or n\\n            \\n            elif w1[n-1] == w2[m-1]:\\n                return solve(w1, w2, n-1, m-1)\\n            \\n            else:\\n                return 1 + min(\\n                                solve(w1, w2, n-1, m-1),  # Replace\\n                                solve(w1, w2, n-1, m),    # Delete\\n                                solve(w1, w2, n, m-1)     # Insert\\n                                )\\n        \\n        return solve(w1, w2, len(w1), len(w2))\\n    \\n\\n# Time Limit Exceeded\\n# We need to use Memoization in this Solution to avoid repetative same calculation of sub-problems\\n```\n```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        memo = {}\\n        \\n        def dfs(i, j):\\n            if i == 0 or j == 0: return j or i\\n                        \\n            if (i,j) in memo:\\n                return memo[(i,j)]\\n            \\n            if word1[i-1] == word2[j-1]:\\n                ans = dfs(i-1, j-1)\\n            else: \\n                ans = 1 + min(dfs(i, j-1), dfs(i-1, j), dfs(i-1, j-1))\\n                \\n            memo[(i,j)] = ans\\n            return memo[(i,j)]\\n        \\n        return dfs(len(word1), len(word2))\\n\\t\\t\\n# Time: O(N^2)\\n# Space: O(N^2)\\n```\n```\\nclass Solution:\\n    def minDistance(self, w1: str, w2: str) -> int:\\n        n = len(w1); m = len(w2)\\n        \\n        dp = [[0]*(m+1) for i in range(n+1)]\\n        \\n        for j in range(m+1): # Base Case 0th row where len(w1) = 0\\n            dp[0][j] = j\\n        \\n        for i in range(n+1): # Base Case 0th column where len(w2) = 0\\n            dp[i][0] = i\\n        \\n        for i in range(1, n+1):\\n            for j in range(1, m+1):\\n                if w1[i-1] == w2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = 1 + min(\\n                                        dp[i-1][j-1],  # Replace \\n                                        dp[i-1][j],    # Delete\\n                                        dp[i][j-1]     # Insert\\n                                        )\\n        \\n        return dp[-1][-1]\\n\\t\\t\\n# Time: O(N^2)\\n# Space: O(N^2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 695493,
                "title": "dp-solution-easy-fast",
                "content": "```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        #dp[i][j] will be the least distance from word1[:i] to word2[:j]\\n        dp = [[0 for _ in range(len(word2)+1)] for _ in range(len(word1)+1)]\\n        for i in range(len(word1)+1):\\n            dp[i][0] = i\\n            for j in range(1,len(word2)+1):\\n                if i == 0:\\n                    dp[0][j] = j\\n                elif word1[i-1] == word2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1])+1\\n        return dp[-1][-1]  \\n                                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        #dp[i][j] will be the least distance from word1[:i] to word2[:j]\\n        dp = [[0 for _ in range(len(word2)+1)] for _ in range(len(word1)+1)]\\n        for i in range(len(word1)+1):\\n            dp[i][0] = i\\n            for j in range(1,len(word2)+1):\\n                if i == 0:\\n                    dp[0][j] = j\\n                elif word1[i-1] == word2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1])+1\\n        return dp[-1][-1]  \\n                                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232992,
                "title": "3-best-approaches-recursion-memorization-tabulation",
                "content": "# Please upvote if you like these solutions\\n\\n# Approach\\n**Recursive Approach**\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity : O(3^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n class Solution {\\n     public int minDistance(String word1, String word2) {\\n         int n = word1.length();\\n         int m = word2.length();\\n\\n         return minDistanceRec(word1, word2, n, m);\\n     }\\n\\n     public int minDistanceRec(String word1,  String word2, int n, int m) {\\n         if(n == 0 || m == 0){\\n             return n == 0 ? m : n;\\n         }\\n\\n         if(word1.charAt(n - 1) == word2.charAt(m - 1)){\\n             return minDistanceRec(word1, word2, n - 1, m - 1);\\n         }\\n         else{\\n             int replace = minDistanceRec(word1, word2, n - 1, m - 1);\\n             int delete = minDistanceRec(word1, word2, n - 1, m);\\n             int insert = minDistanceRec(word1, word2, n, m - 1);\\n             return Math.min(replace, Math.min(delete, insert)) + 1;\\n         }\\n     }\\n }\\n\\n```\\n\\n\\n---\\n\\n\\n# Approach\\n**Memorization Approach**\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity : O(m * n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(m * n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n class Solution {\\n     public int minDistance(String word1, String word2) {\\n         int n = word1.length();\\n         int m = word2.length();\\n\\n         int [][] memo = new int [n + 1][m + 1];\\n         for(int [] d : memo)\\n             Arrays.fill(d, -1);\\n\\n         return minDistanceMemo(word1, word2, n, m, memo);\\n     }\\n\\n     public int minDistanceMemo(String word1,  String word2, int n, int m, int [][] memo) {\\n         if(n == 0 || m == 0){\\n             return memo[n][m] = n == 0 ? m : n;\\n         }\\n\\n         if(memo[n][m] != -1)\\n             return memo[n][m];\\n\\n         if(word1.charAt(n - 1) == word2.charAt(m - 1)){\\n             memo[n][m] = minDistanceMemo(word1, word2, n - 1, m - 1, memo);\\n         }\\n         else{\\n             int replace = minDistanceMemo(word1, word2, n - 1, m - 1, memo);\\n             int delete = minDistanceMemo(word1, word2, n - 1, m, memo);\\n             int insert = minDistanceMemo(word1, word2, n, m - 1, memo);\\n             memo[n][m] = Math.min(replace, Math.min(delete, insert)) + 1;\\n         }\\n         return memo[n][m];\\n     }\\n }\\n\\n```\\n\\n\\n---\\n\\n\\n# Approach\\n**Tabulation Approach**\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity : O(m * n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(m * n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        int n = word1.length();\\n        int m = word2.length();\\n\\n        int [][] dp = new int [n + 1][m + 1];\\n        for(int [] d : dp)\\n            Arrays.fill(d, -1);\\n\\n        return minDistanceTab(word1, word2, n, m, dp);\\n    }\\n\\n    public int minDistanceTab(String word1,  String word2, int N, int M, int [][] dp) {\\n        for(int n = 0; n <= N; n++){\\n            for(int m = 0; m <= M; m++){\\n                if(n == 0 || m == 0){\\n                    dp[n][m] = n == 0 ? m : n;\\n                    continue;\\n                }\\n\\n                if(word1.charAt(n - 1) == word2.charAt(m - 1)){\\n                    dp[n][m] = dp[n - 1][m - 1];\\n                }\\n                else{\\n                    int replace = dp[n - 1][m - 1];;\\n                    int delete = dp[n - 1][m];;\\n                    int insert = dp[n][m - 1];;\\n                    dp[n][m] = Math.min(replace, Math.min(delete, insert)) + 1;\\n                }\\n            }\\n        }\\n        return dp[N][M];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n class Solution {\\n     public int minDistance(String word1, String word2) {\\n         int n = word1.length();\\n         int m = word2.length();\\n\\n         return minDistanceRec(word1, word2, n, m);\\n     }\\n\\n     public int minDistanceRec(String word1,  String word2, int n, int m) {\\n         if(n == 0 || m == 0){\\n             return n == 0 ? m : n;\\n         }\\n\\n         if(word1.charAt(n - 1) == word2.charAt(m - 1)){\\n             return minDistanceRec(word1, word2, n - 1, m - 1);\\n         }\\n         else{\\n             int replace = minDistanceRec(word1, word2, n - 1, m - 1);\\n             int delete = minDistanceRec(word1, word2, n - 1, m);\\n             int insert = minDistanceRec(word1, word2, n, m - 1);\\n             return Math.min(replace, Math.min(delete, insert)) + 1;\\n         }\\n     }\\n }\\n\\n```\n```\\n class Solution {\\n     public int minDistance(String word1, String word2) {\\n         int n = word1.length();\\n         int m = word2.length();\\n\\n         int [][] memo = new int [n + 1][m + 1];\\n         for(int [] d : memo)\\n             Arrays.fill(d, -1);\\n\\n         return minDistanceMemo(word1, word2, n, m, memo);\\n     }\\n\\n     public int minDistanceMemo(String word1,  String word2, int n, int m, int [][] memo) {\\n         if(n == 0 || m == 0){\\n             return memo[n][m] = n == 0 ? m : n;\\n         }\\n\\n         if(memo[n][m] != -1)\\n             return memo[n][m];\\n\\n         if(word1.charAt(n - 1) == word2.charAt(m - 1)){\\n             memo[n][m] = minDistanceMemo(word1, word2, n - 1, m - 1, memo);\\n         }\\n         else{\\n             int replace = minDistanceMemo(word1, word2, n - 1, m - 1, memo);\\n             int delete = minDistanceMemo(word1, word2, n - 1, m, memo);\\n             int insert = minDistanceMemo(word1, word2, n, m - 1, memo);\\n             memo[n][m] = Math.min(replace, Math.min(delete, insert)) + 1;\\n         }\\n         return memo[n][m];\\n     }\\n }\\n\\n```\n```\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        int n = word1.length();\\n        int m = word2.length();\\n\\n        int [][] dp = new int [n + 1][m + 1];\\n        for(int [] d : dp)\\n            Arrays.fill(d, -1);\\n\\n        return minDistanceTab(word1, word2, n, m, dp);\\n    }\\n\\n    public int minDistanceTab(String word1,  String word2, int N, int M, int [][] dp) {\\n        for(int n = 0; n <= N; n++){\\n            for(int m = 0; m <= M; m++){\\n                if(n == 0 || m == 0){\\n                    dp[n][m] = n == 0 ? m : n;\\n                    continue;\\n                }\\n\\n                if(word1.charAt(n - 1) == word2.charAt(m - 1)){\\n                    dp[n][m] = dp[n - 1][m - 1];\\n                }\\n                else{\\n                    int replace = dp[n - 1][m - 1];;\\n                    int delete = dp[n - 1][m];;\\n                    int insert = dp[n][m - 1];;\\n                    dp[n][m] = Math.min(replace, Math.min(delete, insert)) + 1;\\n                }\\n            }\\n        }\\n        return dp[N][M];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230538,
                "title": "python3-easy-solution",
                "content": "**Python3 Solution**\\n```python\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m, n = len(word1), len(word2)\\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\\n        # base case - i steps away\\n        for i in range(1, m + 1):\\n            dp[i][0] = i\\n        for j in range(1, n + 1):\\n            dp[0][j] = j\\n        # each step has four possibilities\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                # same character, i and j move ahead together\\n                if word1[i - 1] == word2[j - 1]:\\n                    dp[i][j] = dp[i - 1][j - 1]\\n                # find min of insert, replace, remove a character\\n                else:\\n                    dp[i][j] = min(\\n                        dp[i - 1][j] + 1,\\n                        dp[i][j - 1] + 1,\\n                        dp[i - 1][j - 1] + 1\\n                    )\\n        \\n        return dp[m][n]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m, n = len(word1), len(word2)\\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\\n        # base case - i steps away\\n        for i in range(1, m + 1):\\n            dp[i][0] = i\\n        for j in range(1, n + 1):\\n            dp[0][j] = j\\n        # each step has four possibilities\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                # same character, i and j move ahead together\\n                if word1[i - 1] == word2[j - 1]:\\n                    dp[i][j] = dp[i - 1][j - 1]\\n                # find min of insert, replace, remove a character\\n                else:\\n                    dp[i][j] = min(\\n                        dp[i - 1][j] + 1,\\n                        dp[i][j - 1] + 1,\\n                        dp[i - 1][j - 1] + 1\\n                    )\\n        \\n        return dp[m][n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2736119,
                "title": "dp-4-approaches-recursion-memoization-tabulation-and-space-optimization",
                "content": "**Approach 1 : Recursion**\\n\\n```\\nint solve(int i, int j, string &str1, string &str2){     \\n        if(j<0){\\n            return i+1;\\n        }\\n        if(i<0){\\n            return j+1;\\n        }\\n        if(str1[i]==str2[j]){\\n            return solve(i-1,j-1,str1,str2);\\n        }\\n        else{\\n            int insert = 1 + solve(i,j-1,str1,str2);\\n            int deleted = 1 + solve(i-1,j,str1,str2);\\n            int replace = 1 + solve(i-1,j-1,str1,str2);\\n            return min(min(insert,deleted),replace);\\n        }\\n    }\\n    \\n    int minDistance(string word1, string word2) {\\n        int n = word1.size();\\n        int m = word2.size();\\n        return solve(n-1,m-1,word1,word2);\\n    }\\n```\\n\\nTime : exponential\\nSpace : O(m+n) for stack space     => m = word1.size() and n = word2.size()\\n\\n**Approach 2 : Memoization**\\n\\n```\\nint solve(int i, int j, string &str1, string &str2, vector<vector<int>>&dp){     \\n        if(j<0){\\n            return i+1;\\n        }\\n        if(i<0){\\n            return j+1;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        if(str1[i]==str2[j]){\\n            return dp[i][j] = solve(i-1,j-1,str1,str2,dp);\\n        }\\n        else{\\n            int insert = 1 + solve(i,j-1,str1,str2,dp);\\n            int deleted = 1 + solve(i-1,j,str1,str2,dp);\\n            int replace = 1 + solve(i-1,j-1,str1,str2,dp);\\n            return dp[i][j] = min(min(insert,deleted),replace);\\n        }\\n    }\\n    \\n    int minDistance(string word1, string word2) {\\n        int n = word1.size();\\n        int m = word2.size();\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        return solve(n-1,m-1,word1,word2,dp);\\n    }\\n```\\n\\nTime : O(m.n)   => m = word1.size() and n = word2.size()\\nSpace : O(m+n) stack space and O(m.n)  for dp space\\n\\n**Approach 3 : Tabulation**\\n\\n```\\n       int minDistance(string word1, string word2) {\\n        int n = word1.size();\\n        int m = word2.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,0));\\n       \\n        for(int i=0;i<n+1;i++){\\n            dp[i][0]=i;\\n        }\\n        for(int j=1;j<m+1;j++){\\n            dp[0][j]=j;\\n        }\\n       \\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<m+1;j++){\\n                if(word1[i-1]==word2[j-1])\\n                    dp[i][j] = dp[i-1][j-1];\\n                else{\\n                    int insert = 1 + dp[i][j-1];\\n                    int deleted = 1 + dp[i-1][j];\\n                    int replace = 1 + dp[i-1][j-1];\\n                    dp[i][j] = min(min(insert,deleted),replace);                    \\n                }        \\n            }\\n        }\\n        return dp[n][m];\\n    }\\n```\\n\\nTime : O(m.n)   => m = word1.size() and n = word2.size()\\nSpace : O(m.n)  for dp space\\n\\n**Approach 4 : Space optimized to O(m) **\\n\\n```\\n     int minDistance(string word1, string word2) {\\n        int n = word1.size();\\n        int m = word2.size();\\n        vector<int>prev(m+1,0),curr(m+1,0);\\n        \\n        for(int i=0;i<m+1;i++){\\n            prev[i]=i;\\n        }\\n        for(int i=1;i<n+1;i++){\\n            curr[0] = i;\\n            for(int j=1;j<m+1;j++){\\n                if(word1[i-1]==word2[j-1])\\n                    curr[j] = prev[j-1];\\n                else{\\n                    int insert = 1 + curr[j-1];\\n                    int deleted = 1 + prev[j];\\n                    int replace = 1 + prev[j-1];\\n                    curr[j] = min(min(insert,deleted),replace);                    \\n                }        \\n            }\\n            prev = curr;\\n        }\\n        \\n        return prev[m];\\n    }\\n```\\n\\nTime : O(m.n)   => m = word1.size() and n = word2.size()\\nSpace : O(m)  for dp \\n\\n\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint solve(int i, int j, string &str1, string &str2){     \\n        if(j<0){\\n            return i+1;\\n        }\\n        if(i<0){\\n            return j+1;\\n        }\\n        if(str1[i]==str2[j]){\\n            return solve(i-1,j-1,str1,str2);\\n        }\\n        else{\\n            int insert = 1 + solve(i,j-1,str1,str2);\\n            int deleted = 1 + solve(i-1,j,str1,str2);\\n            int replace = 1 + solve(i-1,j-1,str1,str2);\\n            return min(min(insert,deleted),replace);\\n        }\\n    }\\n    \\n    int minDistance(string word1, string word2) {\\n        int n = word1.size();\\n        int m = word2.size();\\n        return solve(n-1,m-1,word1,word2);\\n    }\\n```\n```\\nint solve(int i, int j, string &str1, string &str2, vector<vector<int>>&dp){     \\n        if(j<0){\\n            return i+1;\\n        }\\n        if(i<0){\\n            return j+1;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        if(str1[i]==str2[j]){\\n            return dp[i][j] = solve(i-1,j-1,str1,str2,dp);\\n        }\\n        else{\\n            int insert = 1 + solve(i,j-1,str1,str2,dp);\\n            int deleted = 1 + solve(i-1,j,str1,str2,dp);\\n            int replace = 1 + solve(i-1,j-1,str1,str2,dp);\\n            return dp[i][j] = min(min(insert,deleted),replace);\\n        }\\n    }\\n    \\n    int minDistance(string word1, string word2) {\\n        int n = word1.size();\\n        int m = word2.size();\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        return solve(n-1,m-1,word1,word2,dp);\\n    }\\n```\n```\\n       int minDistance(string word1, string word2) {\\n        int n = word1.size();\\n        int m = word2.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,0));\\n       \\n        for(int i=0;i<n+1;i++){\\n            dp[i][0]=i;\\n        }\\n        for(int j=1;j<m+1;j++){\\n            dp[0][j]=j;\\n        }\\n       \\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<m+1;j++){\\n                if(word1[i-1]==word2[j-1])\\n                    dp[i][j] = dp[i-1][j-1];\\n                else{\\n                    int insert = 1 + dp[i][j-1];\\n                    int deleted = 1 + dp[i-1][j];\\n                    int replace = 1 + dp[i-1][j-1];\\n                    dp[i][j] = min(min(insert,deleted),replace);                    \\n                }        \\n            }\\n        }\\n        return dp[n][m];\\n    }\\n```\n```\\n     int minDistance(string word1, string word2) {\\n        int n = word1.size();\\n        int m = word2.size();\\n        vector<int>prev(m+1,0),curr(m+1,0);\\n        \\n        for(int i=0;i<m+1;i++){\\n            prev[i]=i;\\n        }\\n        for(int i=1;i<n+1;i++){\\n            curr[0] = i;\\n            for(int j=1;j<m+1;j++){\\n                if(word1[i-1]==word2[j-1])\\n                    curr[j] = prev[j-1];\\n                else{\\n                    int insert = 1 + curr[j-1];\\n                    int deleted = 1 + prev[j];\\n                    int replace = 1 + prev[j-1];\\n                    curr[j] = min(min(insert,deleted),replace);                    \\n                }        \\n            }\\n            prev = curr;\\n        }\\n        \\n        return prev[m];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2605989,
                "title": "lcs-explained-python-c-javascript",
                "content": "* We can use **longest common subsequence** method with little bit modification.\\n* In **LCS** we only check that the corresponding letter is equal or not and according to it we fill out the matrix cell.\\n* Here in this problem we have to perform **three types** of operations so every cell of the dp matrix will be filled out with the operation that has **minimum step**.\\n* `if  word1[i-1] == word2[j-1]:`\\n\\t* ` dp[i][j] = dp[i][j] = dp[i-1][j-1]` means both letters are same so we don\\'t need to perform any operation so number of steps will remain same as previous step.\\n* `if word1[i-1] != word2[j-1]:`\\n\\t* case 1: we will replace the current letter of word1 with current letter of word2 --> `dp[i-1][j-1] + 1` steps.\\n\\t* case 2: we have reached at the end of word2 but in word1 there is an extra letter that we have to delete from word1 -->` dp[i-1][j] + 1` steps.\\n\\t* case 3: we have reached at the end of the word1 but there is an extra letter in word2 that we have to insert in word1 --> `dp[i][j-1] + 1` steps.\\n\\t* `dp[i][j] = min(case1, case2, case3)`\\n--------------------\\n<iframe src=\"https://leetcode.com/playground/XwdC88g8/shared\" frameBorder=\"0\" width=\"800\" height=\"520\"></iframe>\\n\\n-----------\\n**Upvote the post if you find it helpful.\\nHappy coding.**",
                "solutionTags": [
                    "Python",
                    "C",
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "* We can use **longest common subsequence** method with little bit modification.\\n* In **LCS** we only check that the corresponding letter is equal or not and according to it we fill out the matrix cell.\\n* Here in this problem we have to perform **three types** of operations so every cell of the dp matrix will be filled out with the operation that has **minimum step**.\\n* `if  word1[i-1] == word2[j-1]:`\\n\\t* ` dp[i][j] = dp[i][j] = dp[i-1][j-1]` means both letters are same so we don\\'t need to perform any operation so number of steps will remain same as previous step.\\n* `if word1[i-1] != word2[j-1]:`\\n\\t* case 1: we will replace the current letter of word1 with current letter of word2 --> `dp[i-1][j-1] + 1` steps.\\n\\t* case 2: we have reached at the end of word2 but in word1 there is an extra letter that we have to delete from word1 -->` dp[i-1][j] + 1` steps.\\n\\t* case 3: we have reached at the end of the word1 but there is an extra letter in word2 that we have to insert in word1 --> `dp[i][j-1] + 1` steps.\\n\\t* `dp[i][j] = min(case1, case2, case3)`\\n--------------------\\n<iframe src=\"https://leetcode.com/playground/XwdC88g8/shared\" frameBorder=\"0\" width=\"800\" height=\"520\"></iframe>\\n\\n-----------\\n**Upvote the post if you find it helpful.\\nHappy coding.**",
                "codeTag": "Unknown"
            },
            {
                "id": 1821599,
                "title": "easy-solution-dp-based-c-95-fast-solution",
                "content": "```\\n  int minDistance(string word1, string word2) {\\n        \\n        int m=word1.length(),n=word2.length();\\n        \\n        int dp[m+1][n+1];\\n        \\n        for(int i=0;i<=m;i++)\\n            dp[i][0]=i;\\n        \\n        for(int i=0;i<=n;i++)\\n            dp[0][i]=i;\\n        \\n        for(int i=1;i<=m;i++)\\n        {\\n            for(int j=1;j<=n;j++)\\n            {\\n                if(word1[i-1]==word2[j-1])\\n                    dp[i][j]=dp[i-1][j-1];\\n                else{\\n                    dp[i][j] = 1+ min(dp[i][j - 1], min(dp[i - 1][j], dp[i - 1][j - 1]));\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n  int minDistance(string word1, string word2) {\\n        \\n        int m=word1.length(),n=word2.length();\\n        \\n        int dp[m+1][n+1];\\n        \\n        for(int i=0;i<=m;i++)\\n            dp[i][0]=i;\\n        \\n        for(int i=0;i<=n;i++)\\n            dp[0][i]=i;\\n        \\n        for(int i=1;i<=m;i++)\\n        {\\n            for(int j=1;j<=n;j++)\\n            {\\n                if(word1[i-1]==word2[j-1])\\n                    dp[i][j]=dp[i-1][j-1];\\n                else{\\n                    dp[i][j] = 1+ min(dp[i][j - 1], min(dp[i - 1][j], dp[i - 1][j - 1]));\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1262290,
                "title": "maybe-better-than-o-mn-heap-solution-python-beats-99-o-m-n-log-m-n-not-sure",
                "content": "![image](https://assets.leetcode.com/users/images/1e61e11a-f3e8-4d0a-92c3-f2565c7360b0_1623299142.487367.png)\\n\\n\\nKeep a minheap and chop off 1 character at a time. To avoid using too much space with substring splicing, we can move pointers `i` and `j` instead.\\n\\nKeep a minheap with items in there form `(distance, i, j)`\\nWhere `word1[:i]` and `word[:j]` have an edit distance of `distance`\\n\\n1. Pop from the heap to give current lowest edit distance and string index pair\\n2. If word1 and word2 from pointers  `i` and `j`  are **both exactly exact same**:\\n\\t=>  return the `distance` , don\\'t need to increment the distance anymore\\n\\t\\n3. Do the following if `i` and `j` are unvisited (if we are visiting the same `i` and `j` again, that means the distance is not lower than previously seen, so we should ignore it)\\n\\t4.  if the characters at `i` and `j` match, **no change needed** , increment both word pointers but keep distance the same\\n\\t5.  Otherwise, increment distance and:\\n\\t\\t6. Add **delete from word1** case (`i+1`)\\n\\t\\t7. Add **delete from word2** case (`j+1`)\\n\\t\\t8. Add **replace current character** case (`i+1`) and (`j+1`)\\n\\n```python\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m, n = len(word1), len(word2)\\n        heap = [(0, 0, 0)]\\n        seen = set()\\n        \\n        while heap:\\n            distance, i, j = heappop(heap)\\n            if word1[i:] == word2[j:]:\\n                return distance\\n\\t\\t\\n            if ((i, j) not in seen):\\n                seen.add((i, j))\\n                if (i < m and j < n and word1[i] == word2[j]):\\n                    heappush(heap, (distance, i+1, j+1))\\n                else:\\n                    for di, dj in (1,0), (0,1), (1,1):\\n                        next_i, next_j = i+di, j+dj\\n                        if (next_i <= m and next_j <= n):\\n                            heappush(heap, (distance+1, next_i, next_j))\\n```\\n\\n\\n**Time complexity**\\n\\nAssuming length of `word1` is `m` and length of `word2` is `n`\\nFor each of the `m` characters and `n` that modify the heap at most 3 times. Thus the heap size can be at most `(m+n)*3` = `m+n`\\n\\nThus all heap operations are  `O(log(m+n))`\\nWhich is done for all `m+n` items thus `O((m+n)log(m+n))`\\nIf this is true, than this is better than the typical `O(mn)` DP solution.\\nThough it might just be `O(mn*log(mn))` with a good average case...\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m, n = len(word1), len(word2)\\n        heap = [(0, 0, 0)]\\n        seen = set()\\n        \\n        while heap:\\n            distance, i, j = heappop(heap)\\n            if word1[i:] == word2[j:]:\\n                return distance\\n\\t\\t\\n            if ((i, j) not in seen):\\n                seen.add((i, j))\\n                if (i < m and j < n and word1[i] == word2[j]):\\n                    heappush(heap, (distance, i+1, j+1))\\n                else:\\n                    for di, dj in (1,0), (0,1), (1,1):\\n                        next_i, next_j = i+di, j+dj\\n                        if (next_i <= m and next_j <= n):\\n                            heappush(heap, (distance+1, next_i, next_j))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3854887,
                "title": "diagram-explanation-recursion-memoization-dp-o-3-n-to-o-n-m",
                "content": "# Recursive Solution (Naive Approach)\\n## How ?\\n\\n1. Pure Recursive Approach (`PureRecursive` function):\\nThe `PureRecursive` function calculates the minimum edit distance between two strings `word1` and `word2` using a purely recursive approach. It tries to find the minimum number of operations (insert, delete, or replace) required to convert `word1` into `word2`. The function starts from the last characters of both strings and recursively checks if the characters are the same or different. If they are the same, it moves to the previous characters and continues the comparison. If they are different, it explores all three possible operations (insert, delete, replace) and calculates the minimum distance for each case. The function returns the minimum distance obtained.\\n\\nTime complexity: Exponential. Since for each character in `word1`, the function has three recursive calls (insert, delete, replace), the time complexity grows exponentially with the length of the strings.\\n\\nSpace complexity: O(m+n), where \\'m\\' is the length of `word1` and \\'n\\' is the length of `word2`. The space complexity is determined by the depth of the recursive calls and the maximum size of the function call stack.\\n\\n```\\nint PureRecursive(string &word1, string &word2,int m, int n){\\n        if(m == 0) return n;\\n        if(n == 0) return m;\\n        if(word1[m-1] == word2[n-1]){\\n            return PureRecursive(word1,word2,m-1,n-1);\\n        }\\n        else{\\n            return 1 + min(PureRecursive(word1,word2,m-1,n-1),min(PureRecursive(word1,word2,m-1,n),PureRecursive(word1,word2,m,n-1)));\\n        }\\n    }\\n    int minDistance(string word1, string word2) {\\n        vector<vector<int>> dp(word1.size() + 1, std::vector<int>(word2.size() + 1, -1));\\n        return bottomUpDp(word1,word2,word1.size(),word2.size(),dp);\\n    }\\n};\\n\\n```\\n\\n# Memoization Approach\\n\\n## How?\\nThe given function `recur` is a recursive solution to the Minimum Edit Distance problem with memoization  (also known as memoization). It calculates the minimum edit distance between two strings `word1` and `word2`.\\n\\nThe function takes the following parameters:\\n- `word1`: A reference to the first string.\\n- `word2`: A reference to the second string.\\n- `m`: The current index in `word1` (0-based).\\n- `n`: The current index in `word2` (0-based).\\n- `dp`: A 2D vector representing the memoization table to store intermediate results.\\n\\nThe idea behind the memoization approach is to store the results of subproblems in the `dp` table to avoid redundant computations. This way, if we encounter the same subproblem during the recursion, we can directly use the precomputed value from the `dp` table instead of recalculating it.\\n\\nHere\\'s how the function works:\\n1. Base cases:\\n   - If `m` (index in `word1`) becomes 0, it means we have processed all characters in `word1`, so we return the remaining length of `word2` (`n`). This is because, at this point, we would need to insert `n` characters from `word2` into `word1` to match them.\\n   - If `n` (index in `word2`) becomes 0, it means we have processed all characters in `word2`, so we return the remaining length of `word1` (`m`). This is because, at this point, we would need to delete `m` characters from `word1` to match them with the empty string.\\n\\n2. Check if the result for the current subproblem exists in the `dp` table (`dp[m - 1][n - 1]`). If it does, we directly return the precomputed value, avoiding redundant computation.\\n\\n3. If the characters at the current indices (`word1[m - 1]` and `word2[n - 1]`) are equal, it means no edit is required, and we can move on to the previous characters (index `m - 1` and `n - 1`) to find the solution for the subproblem. We recursively call `recur(word1, word2, m - 1, n - 1, dp)` to compute the minimum edit distance for this case.\\n\\n4. If the characters at the current indices are different, it means we have three options: insert, delete, or replace a character to make the strings similar. We recursively call `recur` for each option and compute the minimum edit distance among them. The result is stored in the `dp` table (`dp[m - 1][n - 1]`) for future reference.\\n\\n5. Finally, we return the computed value for the current subproblem.\\n\\nOverall, the memoization approach reduces the time complexity by avoiding redundant calculations of the same subproblems and improves the performance compared to the pure recursive solution.\\n\\nPlease note that before calling the `recur` function, you need to initialize the `dp` table with `-1` to indicate that the results for subproblems are not yet computed. The `minDistance` function takes care of this initialization and calls the `recur` function with the appropriate arguments.\\n\\nMemoizationn Table:\\n\\n\\n|     | e | x | e | c | u | t | i | o | n |\\n|-----|---|---|---|---|---|---|---|---|---|\\n| i   | -1 | -1 | -1 | -1 | -1 | -1 | -1 | -1 | -1 |\\n| n   | -1 | -1 | -1 | -1 | -1 | -1 | -1 | -1 | -1 |\\n| t   | -1 | -1 | -1 | -1 | -1 | -1 | -1 | -1 | -1 |\\n| e   | -1 | -1 | -1 | -1 | -1 | -1 | -1 | -1 | -1 |\\n| n   | -1 | -1 | -1 | -1 | -1 | -1 | -1 | -1 | -1 |\\n| t   | -1 | -1 | -1 | -1 | -1 | -1 | -1 | -1 | -1 |\\n| i   | -1 | -1 | -1 | -1 | -1 | -1 | -1 | -1 | -1 |\\n| o   | -1 | -1 | -1 | -1 | -1 | -1 | -1 | -1 | -1 |\\n| n   | -1 | -1 | -1 | -1 | -1 | -1 | -1 | -1 | -1 |\\n\\nIn this table, the headers for both rows and columns represent the characters from \"intention\" and \"execution.\" The cells are filled with -1, indicating that the minimum edit distance has not been computed for any of the substrings yet.\\n\\nConverts to :\\n<body>\\n    <table>\\n        <tr>\\n            <td></td>\\n            <td>e</td>\\n            <td>x</td>\\n            <td>e</td>\\n            <td>c</td>\\n            <td>u</td>\\n            <td>t</td>\\n            <td>i</td>\\n            <td>o</td>\\n            <td>n</td>\\n            <td>-</td>\\n        </tr>\\n        <tr>\\n            <td>i</td>\\n            <td>1</td>\\n            <td>2</td>\\n            <td>3</td>\\n            <td>4</td>\\n            <td>5</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n        </tr>\\n        <tr>\\n            <td>n</td>\\n            <td>2</td>\\n            <td>2</td>\\n            <td>3</td>\\n            <td>4</td>\\n            <td>5</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n        </tr>\\n        <tr>\\n            <td>t</td>\\n            <td>3</td>\\n            <td>3</td>\\n            <td>3</td>\\n            <td>4</td>\\n            <td>5</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n        </tr>\\n        <tr>\\n            <td>e</td>\\n            <td>3</td>\\n            <td>4</td>\\n            <td>3</td>\\n            <td>4</td>\\n            <td>5</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n        </tr>\\n        <tr>\\n            <td>n</td>\\n            <td>4</td>\\n            <td>4</td>\\n            <td>4</td>\\n            <td style=\"background-color: grey\">4</td>\\n            <td>5</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n        </tr>\\n        <tr>\\n            <td>t</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td>5</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n        </tr>\\n        <tr>\\n            <td>i</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td>5</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n        </tr>\\n        <tr>\\n            <td>o</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td>5</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n        </tr>\\n        <tr>\\n            <td>n</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: skyblue; color : black;\">5<sup>(m-1,n-1)</sup></td>\\n            <td style=\"background-color: grey\">-1</td>\\n        </tr>\\n        <tr>\\n            <td>-</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n        </tr>\\n    </table>\\n</body>\\n</html>\\n\\nMemoization Solution\\n\\n```\\nint Memoization(string &word1, string &word2,int m, int n,vector<vector<int>>&mem){\\n            if (m == 0)\\n                return n; //If the word1 length becomes zero, obvious that we are left with the cost of n\\n            if (n == 0)\\n                return m; //If the word2 length becomes zero, obvious that we are left with the cost of m\\n\\n            if (mem[m - 1][n - 1] != -1)\\n                return mem[m - 1][n - 1];\\n\\n            if (word1[m - 1] == word2[n - 1])\\n            {\\n                mem[m - 1][n - 1] = Memoization(word1, word2, m - 1, n - 1, mem);\\n                return mem[m - 1][n - 1];\\n            }\\n            else\\n            {\\n                mem[m - 1][n - 1] = 1 + min(Memoization(word1, word2, m - 1, n - 1, mem), min(Memoization(word1, word2, m - 1, n, mem), Memoization(word1, word2, m, n - 1, mem)));\\n                return mem[m - 1][n - 1];\\n            }\\n        }\\n\\n```\\n\\n# DP Solution :\\n## How ?\\n1. Bottom-Up Dynamic Programming Approach (`minDistance` function):\\nThe `minDistance` function calculates the minimum edit distance between two strings `word1` and `word2` using the Bottom-Up Dynamic Programming approach. It creates a DP table (2D array) of size `(m+1) x (n+1)` to store the minimum edit distance values for all subproblems.\\n\\nThe idea behind the Bottom-Up DP approach is to fill the DP table from smaller subproblems to the larger ones iteratively, avoiding redundant computations. The DP table `dp[i][j]` represents the minimum edit distance between the first `i` characters of `word1` and the first `j` characters of `word2`.\\n\\nThe DP table is filled in a bottom-up manner as follows:\\n- For `i = 0` or `j = 0`, `dp[i][j]` is initialized to `i` or `j`, respectively. This is because the minimum edit distance between an empty string and a string of length \\'x\\' is \\'x\\' (number of insertions or deletions needed).\\n- For `i > 0` and `j > 0`, if `word1[i-1]` is equal to `word2[j-1]`, then there is no edit needed, and `dp[i][j]` is set to `dp[i-1][j-1]`.\\n- If `word1[i-1]` is not equal to `word2[j-1]`, then `dp[i][j]` is calculated as the minimum of three cases: \\n    1. Replace: `1 + dp[i-1][j-1]`\\n    2. Insert: `1 + dp[i][j-1]`\\n    3. Delete: `1 + dp[i-1][j]`\\n\\nThe final answer is stored in `dp[m][n]`, which represents the minimum edit distance between the entire `word1` and `word2`.\\n\\nTime complexity: O(m * n), where \\'m\\' is the length of `word1` and \\'n\\' is the length of `word2`. The DP table is filled iteratively in a bottom-up manner, so each cell takes constant time to compute.\\n\\nSpace complexity: O(m * n), where \\'m\\' is the length of `word1` and \\'n\\' is the length of `word2`. The DP table of size `(m+1) x (n+1)` is used to store the intermediate results.\\nTable will look like this after the Complete assignment\\n<body>\\n    <table>\\n        <tr>\\n            <th> </th>\\n            <th>0</th>\\n            <th>1</th>\\n            <th>2</th>\\n            <th>3</th>\\n            <th>4</th>\\n            <th>5</th>\\n            <th>6</th>\\n            <th>7</th>\\n            <th>8</th>\\n            <th>9</th>\\n        </tr>\\n        <tr>\\n            <th>0</th>\\n            <td>0</td>\\n            <td>1</td>\\n            <td>2</td>\\n            <td>3</td>\\n            <td>4</td>\\n            <td>5</td>\\n            <td>6</td>\\n            <td>7</td>\\n            <td>8</td>\\n            <td>9</td>\\n        </tr>\\n        <tr>\\n            <th>1</th>\\n            <td>1</td>\\n            <td style=\"background-color: gray; color: black;\">1</td>\\n            <td>2</td>\\n            <td>3</td>\\n            <td>4</td>\\n            <td>5</td>\\n            <td>6</td>\\n            <td>6</td>\\n            <td>7</td>\\n            <td>8</td>\\n        </tr>\\n        <tr>\\n            <th>2</th>\\n            <td>2</td>\\n            <td>2</td>\\n            <td style=\"background-color: gray; color: black;\">2</td>\\n            <td>3</td>\\n            <td>4</td>\\n            <td>5</td>\\n            <td>6</td>\\n            <td>7</td>\\n            <td>7</td>\\n            <td>7</td>\\n        </tr>\\n        <tr>\\n            <th>3</th>\\n            <td>3</td>\\n            <td>3</td>\\n            <td>3</td>\\n            <td style=\"background-color: gray; color: black;\">3</td>\\n            <td>4</td>\\n            <td>5</td>\\n            <td>5</td>\\n            <td>6</td>\\n            <td>7</td>\\n            <td>8</td>\\n        </tr>\\n        <tr>\\n            <th>4</th>\\n            <td>3</td>\\n            <td>4</td>\\n            <td>3</td>\\n            <td>4</td>\\n            <td style=\"background-color: gray; color: black;\">4</td>\\n            <td>5</td>\\n            <td>6</td>\\n            <td>6</td>\\n            <td>7</td>\\n            <td>8</td>\\n        </tr>\\n        <tr>\\n            <th>5</th>\\n            <td>4</td>\\n            <td>4</td>\\n            <td>4</td>\\n            <td>4</td>\\n            <td>4</td>\\n            <td style=\"background-color: gray; color: black;\">5</td>\\n            <td>6</td>\\n            <td>7</td>\\n            <td>7</td>\\n            <td>7</td>\\n        </tr>\\n        <tr>\\n            <th>6</th>\\n            <td>5</td>\\n            <td>5</td>\\n            <td>5</td>\\n            <td>5</td>\\n            <td>5</td>\\n            <td>5</td>\\n            <td style=\"background-color: gray; color: black;\">6</td>\\n            <td>7</td>\\n            <td>8</td>\\n            <td>8</td>\\n        </tr>\\n        <tr>\\n            <th>7</th>\\n            <td>6</td>\\n            <td>6</td>\\n            <td>6</td>\\n            <td>6</td>\\n            <td>6</td>\\n            <td>6</td>\\n            <td>6</td>\\n            <td style=\"background-color: gray; color: black;\">5</td>\\n            <td>6</td>\\n            <td>7</td>\\n        </tr>\\n        <tr>\\n            <th>8</th>\\n            <td>7</td>\\n            <td>7</td>\\n            <td>7</td>\\n            <td>7</td>\\n            <td>7</td>\\n            <td>7</td>\\n            <td>7</td>\\n            <td>6</td>\\n            <td style=\"background-color: gray; color: black;\">5</td>\\n            <td>6</td>\\n        </tr>\\n        <tr>\\n            <th>9</th>\\n            <td>8</td>\\n            <td>8</td>\\n            <td>8</td>\\n            <td>8</td>\\n            <td>8</td>\\n            <td>8</td>\\n            <td>8</td>\\n            <td>7</td>\\n            <td>6</td>\\n            <td style=\"background-color: skyblue; color : black;\">5<sup>(m,n)</sup></td>\\n        </tr>\\n    </table>\\n</body>\\n</html>\\n\\n## Code :\\n\\n```\\nclass Solution {\\npublic:\\n    int bottomUpDp(string &word1, string &word2, int m, int n, vector<vector<int>>& dp){\\n        // Initialize base cases\\n        for (int i = 0; i <= m; i++) {\\n            dp[i][0] = i;   //rows\\n        }\\n        for (int j = 0; j <= n; j++) {\\n            dp[0][j] = j;   //columns\\n        }\\n\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (word1[i - 1] == word2[j - 1]) {\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                } else {\\n                    dp[i][j] = 1 + min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1]));\\n                // Carefully observe the recursive code is converted to iterative approach which tries to find the solution in dp table instead of recursive calls\\n                }\\n            }\\n\\n        }\\n\\n        return dp[m][n];\\n    }\\n\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint PureRecursive(string &word1, string &word2,int m, int n){\\n        if(m == 0) return n;\\n        if(n == 0) return m;\\n        if(word1[m-1] == word2[n-1]){\\n            return PureRecursive(word1,word2,m-1,n-1);\\n        }\\n        else{\\n            return 1 + min(PureRecursive(word1,word2,m-1,n-1),min(PureRecursive(word1,word2,m-1,n),PureRecursive(word1,word2,m,n-1)));\\n        }\\n    }\\n    int minDistance(string word1, string word2) {\\n        vector<vector<int>> dp(word1.size() + 1, std::vector<int>(word2.size() + 1, -1));\\n        return bottomUpDp(word1,word2,word1.size(),word2.size(),dp);\\n    }\\n};\\n\\n```\n```\\nint Memoization(string &word1, string &word2,int m, int n,vector<vector<int>>&mem){\\n            if (m == 0)\\n                return n; //If the word1 length becomes zero, obvious that we are left with the cost of n\\n            if (n == 0)\\n                return m; //If the word2 length becomes zero, obvious that we are left with the cost of m\\n\\n            if (mem[m - 1][n - 1] != -1)\\n                return mem[m - 1][n - 1];\\n\\n            if (word1[m - 1] == word2[n - 1])\\n            {\\n                mem[m - 1][n - 1] = Memoization(word1, word2, m - 1, n - 1, mem);\\n                return mem[m - 1][n - 1];\\n            }\\n            else\\n            {\\n                mem[m - 1][n - 1] = 1 + min(Memoization(word1, word2, m - 1, n - 1, mem), min(Memoization(word1, word2, m - 1, n, mem), Memoization(word1, word2, m, n - 1, mem)));\\n                return mem[m - 1][n - 1];\\n            }\\n        }\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int bottomUpDp(string &word1, string &word2, int m, int n, vector<vector<int>>& dp){\\n        // Initialize base cases\\n        for (int i = 0; i <= m; i++) {\\n            dp[i][0] = i;   //rows\\n        }\\n        for (int j = 0; j <= n; j++) {\\n            dp[0][j] = j;   //columns\\n        }\\n\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (word1[i - 1] == word2[j - 1]) {\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                } else {\\n                    dp[i][j] = 1 + min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1]));\\n                // Carefully observe the recursive code is converted to iterative approach which tries to find the solution in dp table instead of recursive calls\\n                }\\n            }\\n\\n        }\\n\\n        return dp[m][n];\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2027225,
                "title": "c-dp-solution-recursive-memorization-tabulation-space-optimized-to-single-1d-array",
                "content": "### Recursive\\n```\\nclass Solution {\\npublic:\\n    int solve(int i, int j, string &s1, string &s2){\\n        //Base Case\\n        if(i<0) return j + 1;\\n        if(j<0) return i + 1;\\n        if(s1[i]==s2[j]) return solve(i-1,j-1,s1,s2);\\n        \\n        //Insert the matching character so reduce the j no effect on i due to insertion\\n        int ins = solve(i,j-1,s1,s2); \\n        \\n        // Delete the character so reduce the i but no effect on j\\n        int del = solve(i-1,j,s1,s2); \\n        \\n        // Replace with matching character so reduce i and j both\\n        int rep = solve(i-1,j-1,s1,s2);\\n        \\n        return 1 + min({ins, del, rep});\\n    }\\n    \\n    int minDistance(string s1, string s2) {\\n        int m = s1.size(), n = s2.size();\\n        return solve(m,n,s1,s2);\\n    }\\n};\\n```\\n\\n### Memorization\\n```\\nclass Solution {\\npublic:\\n    int solve(int i, int j, string &s1, string &s2,vector<vector<int>> &dp){\\n        //Base Case\\n        if(i<0) return j + 1;\\n        if(j<0) return i + 1;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        if(s1[i]==s2[j]) return dp[i][j] = solve(i-1,j-1,s1,s2, dp);\\n        \\n        //Insert the matching character so reduce the j no effect on i due to insertion\\n        int ins = solve(i,j-1,s1,s2, dp); \\n        \\n        // Delete the character so reduce the i but no effect on j\\n        int del = solve(i-1,j,s1,s2, dp); \\n        \\n        // Replace with matching character so reduce i and j both\\n        int rep = solve(i-1,j-1,s1,s2, dp);\\n        \\n        return dp[i][j] = 1 + min({ins, del, rep});\\n    }\\n    \\n    int minDistance(string s1, string s2) {\\n        int m = s1.size(), n = s2.size();\\n        vector<vector<int>> dp(m, vector<int>(n,-1));\\n        return solve(m-1,n-1,s1,s2,dp);\\n    }\\n};\\n```\\n\\n### Tabulation\\n```\\n// Used 1-Based Indexing\\nclass Solution {\\npublic:    \\n    int minDistance(string s1, string s2) {\\n        int m = s1.size(), n = s2.size();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1));\\n        \\n        //Base Case\\n        for(int j=0;j<=n;j++) dp[0][j] = j;\\n        for(int i=0;i<=m;i++) dp[i][0] = i;\\n        \\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                if(s1[i-1]==s2[j-1]) dp[i][j] = dp[i-1][j-1];\\n                else{\\n                    int ins = dp[i][j-1];\\n                    int del = dp[i-1][j];\\n                    int rep = dp[i-1][j-1];\\n                    dp[i][j] = 1 + min({ins, del, rep});\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```\\n\\n### Space-Optimized\\n```\\nclass Solution {\\npublic:    \\n    int minDistance(string s1, string s2) {\\n        int m = s1.size(), n = s2.size();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1));\\n        vector<int> prev(n+1), cur(n+1);\\n        \\n        for(int i=0;i<=m;i++){\\n            for(int j=0;j<=n;j++){\\n                if(i==0) cur[j] = j;\\n                else if(j==0) cur[j] = i;\\n                else if(s1[i-1]==s2[j-1]) cur[j] = prev[j-1];\\n                else{\\n                    int ins = cur[j-1];\\n                    int del = prev[j];\\n                    int rep = prev[j-1];\\n                    cur[j] = 1 + min({ins, del, rep});\\n                }\\n            }\\n            prev = cur;\\n        }\\n        return prev[n];\\n    }\\n};\\n```\\n\\n### Further Optimized\\n```\\nclass Solution {\\npublic:    \\n    int minDistance(string s1, string s2) {\\n        int m = s1.size(), n = s2.size();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1));\\n        vector<int> prev(n+1);\\n        int topLeft, top, left;\\n        for(int i=0;i<=m;i++){\\n            for(int j=0;j<=n;j++){\\n                if(i==0) left = j;\\n                else if(j==0) left = i;\\n                else{\\n                    top = prev[j];\\n                    if(s1[i-1]==s2[j-1]) left = topLeft;\\n                    else left = 1 + min({topLeft, top, left});   \\n                }\\n                topLeft = prev[j];\\n                prev[j] = left;\\n            }\\n        }\\n        return prev[n];\\n    }\\n};\\n```\\n#### Please Upvote if you like the solution and comment your queries",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i, int j, string &s1, string &s2){\\n        //Base Case\\n        if(i<0) return j + 1;\\n        if(j<0) return i + 1;\\n        if(s1[i]==s2[j]) return solve(i-1,j-1,s1,s2);\\n        \\n        //Insert the matching character so reduce the j no effect on i due to insertion\\n        int ins = solve(i,j-1,s1,s2); \\n        \\n        // Delete the character so reduce the i but no effect on j\\n        int del = solve(i-1,j,s1,s2); \\n        \\n        // Replace with matching character so reduce i and j both\\n        int rep = solve(i-1,j-1,s1,s2);\\n        \\n        return 1 + min({ins, del, rep});\\n    }\\n    \\n    int minDistance(string s1, string s2) {\\n        int m = s1.size(), n = s2.size();\\n        return solve(m,n,s1,s2);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int solve(int i, int j, string &s1, string &s2,vector<vector<int>> &dp){\\n        //Base Case\\n        if(i<0) return j + 1;\\n        if(j<0) return i + 1;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        if(s1[i]==s2[j]) return dp[i][j] = solve(i-1,j-1,s1,s2, dp);\\n        \\n        //Insert the matching character so reduce the j no effect on i due to insertion\\n        int ins = solve(i,j-1,s1,s2, dp); \\n        \\n        // Delete the character so reduce the i but no effect on j\\n        int del = solve(i-1,j,s1,s2, dp); \\n        \\n        // Replace with matching character so reduce i and j both\\n        int rep = solve(i-1,j-1,s1,s2, dp);\\n        \\n        return dp[i][j] = 1 + min({ins, del, rep});\\n    }\\n    \\n    int minDistance(string s1, string s2) {\\n        int m = s1.size(), n = s2.size();\\n        vector<vector<int>> dp(m, vector<int>(n,-1));\\n        return solve(m-1,n-1,s1,s2,dp);\\n    }\\n};\\n```\n```\\n// Used 1-Based Indexing\\nclass Solution {\\npublic:    \\n    int minDistance(string s1, string s2) {\\n        int m = s1.size(), n = s2.size();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1));\\n        \\n        //Base Case\\n        for(int j=0;j<=n;j++) dp[0][j] = j;\\n        for(int i=0;i<=m;i++) dp[i][0] = i;\\n        \\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                if(s1[i-1]==s2[j-1]) dp[i][j] = dp[i-1][j-1];\\n                else{\\n                    int ins = dp[i][j-1];\\n                    int del = dp[i-1][j];\\n                    int rep = dp[i-1][j-1];\\n                    dp[i][j] = 1 + min({ins, del, rep});\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:    \\n    int minDistance(string s1, string s2) {\\n        int m = s1.size(), n = s2.size();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1));\\n        vector<int> prev(n+1), cur(n+1);\\n        \\n        for(int i=0;i<=m;i++){\\n            for(int j=0;j<=n;j++){\\n                if(i==0) cur[j] = j;\\n                else if(j==0) cur[j] = i;\\n                else if(s1[i-1]==s2[j-1]) cur[j] = prev[j-1];\\n                else{\\n                    int ins = cur[j-1];\\n                    int del = prev[j];\\n                    int rep = prev[j-1];\\n                    cur[j] = 1 + min({ins, del, rep});\\n                }\\n            }\\n            prev = cur;\\n        }\\n        return prev[n];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:    \\n    int minDistance(string s1, string s2) {\\n        int m = s1.size(), n = s2.size();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1));\\n        vector<int> prev(n+1);\\n        int topLeft, top, left;\\n        for(int i=0;i<=m;i++){\\n            for(int j=0;j<=n;j++){\\n                if(i==0) left = j;\\n                else if(j==0) left = i;\\n                else{\\n                    top = prev[j];\\n                    if(s1[i-1]==s2[j-1]) left = topLeft;\\n                    else left = 1 + min({topLeft, top, left});   \\n                }\\n                topLeft = prev[j];\\n                prev[j] = left;\\n            }\\n        }\\n        return prev[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1817536,
                "title": "c-recursive-memoization-and-dp",
                "content": "**Recursive:**\\n```\\nint editDistance(string s, string t)\\n{\\n    if (s.size() == 0 || t.size() == 0)\\n        return max(s.size(), t.size());\\n    if (s[0] == t[0])\\n        return editDistance(s.substr(1), t.substr(1));\\n    else\\n    {\\n        // insert\\n        int a = 1 + editDistance(s.substr(1), t);\\n        // delete\\n        int b = 1 + editDistance(s, t.substr(1));\\n        // replace\\n        int c = 1 + editDistance(s.substr(1), t.substr(1));\\n        return min(a, min(b, c));\\n    }\\n}\\n\\nint minDistance(string s, string t) {\\n\\treturn editDistance(s,t)\\n}\\n```\\n\\n**Memoization:**\\n```\\nint editDistance2(string s, string t, vector<vector<int>> ans)\\n{\\n    int m = s.size();\\n    int n = t.size();\\n    if (s.size() == 0 || t.size() == 0)\\n        return max(s.size(), t.size());\\n    if (ans[m][n] != -1)\\n        return ans[m][n];\\n    if (s[0] == t[0])\\n    {\\n        ans[m][n] = editDistance2(s.substr(1), t.substr(1), ans);\\n        return ans[m][n];\\n    }\\n    else\\n    {\\n        // insert\\n        int a = 1 + editDistance2(s.substr(1), t, ans);\\n        // delete\\n        int b = 1 + editDistance2(s, t.substr(1), ans);\\n        // replace\\n        int c = 1 + editDistance2(s.substr(1), t.substr(1), ans);\\n        ans[m][n] = min(a, min(b, c));\\n        return ans[m][n];\\n    }\\n}\\nint minDistance(string s, string t) {\\n    vector<vector<int>> ans(s.size() + 1, vector<int>(t.size() + 1, -1));\\n\\treturn editDistance2(s,t)\\n}\\n```\\n\\n**DP:**\\n```\\nint minDistance(string s, string t) {\\n        int m = s.size();\\n    int n = t.size();\\n\\n    int **ans = new int *[m + 1];\\n    for (int i = 0; i <= m; i++)\\n    {\\n        ans[i] = new int[n + 1];\\n    }\\n\\n    // Fill the 0th row with 0\\n    for (int j = 0; j <= n; j++)\\n    {\\n        ans[0][j] = j;\\n    }\\n    // Fill the 0th row with 0\\n    for (int i = 0; i <= m; i++)\\n    {\\n        ans[i][0] = i;\\n    }\\n    // Fill the remaining row with shortest Distances\\n    for (int i = 1; i <= m; i++)\\n    {\\n        for (int j = 1; j <= n; j++)\\n        {\\n            if (s[m - i] == t[n - j])\\n                ans[i][j] = ans[i - 1][j - 1];\\n            else\\n            {\\n                int a = 1 + ans[i - 1][j];\\n                int b = 1 + ans[i][j - 1];\\n                int c = 1 + ans[i - 1][j - 1];\\n                ans[i][j] = min(a, min(b, c));\\n            }\\n        }\\n    }\\n    return ans[m][n];\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint editDistance(string s, string t)\\n{\\n    if (s.size() == 0 || t.size() == 0)\\n        return max(s.size(), t.size());\\n    if (s[0] == t[0])\\n        return editDistance(s.substr(1), t.substr(1));\\n    else\\n    {\\n        // insert\\n        int a = 1 + editDistance(s.substr(1), t);\\n        // delete\\n        int b = 1 + editDistance(s, t.substr(1));\\n        // replace\\n        int c = 1 + editDistance(s.substr(1), t.substr(1));\\n        return min(a, min(b, c));\\n    }\\n}\\n\\nint minDistance(string s, string t) {\\n\\treturn editDistance(s,t)\\n}\\n```\n```\\nint editDistance2(string s, string t, vector<vector<int>> ans)\\n{\\n    int m = s.size();\\n    int n = t.size();\\n    if (s.size() == 0 || t.size() == 0)\\n        return max(s.size(), t.size());\\n    if (ans[m][n] != -1)\\n        return ans[m][n];\\n    if (s[0] == t[0])\\n    {\\n        ans[m][n] = editDistance2(s.substr(1), t.substr(1), ans);\\n        return ans[m][n];\\n    }\\n    else\\n    {\\n        // insert\\n        int a = 1 + editDistance2(s.substr(1), t, ans);\\n        // delete\\n        int b = 1 + editDistance2(s, t.substr(1), ans);\\n        // replace\\n        int c = 1 + editDistance2(s.substr(1), t.substr(1), ans);\\n        ans[m][n] = min(a, min(b, c));\\n        return ans[m][n];\\n    }\\n}\\nint minDistance(string s, string t) {\\n    vector<vector<int>> ans(s.size() + 1, vector<int>(t.size() + 1, -1));\\n\\treturn editDistance2(s,t)\\n}\\n```\n```\\nint minDistance(string s, string t) {\\n        int m = s.size();\\n    int n = t.size();\\n\\n    int **ans = new int *[m + 1];\\n    for (int i = 0; i <= m; i++)\\n    {\\n        ans[i] = new int[n + 1];\\n    }\\n\\n    // Fill the 0th row with 0\\n    for (int j = 0; j <= n; j++)\\n    {\\n        ans[0][j] = j;\\n    }\\n    // Fill the 0th row with 0\\n    for (int i = 0; i <= m; i++)\\n    {\\n        ans[i][0] = i;\\n    }\\n    // Fill the remaining row with shortest Distances\\n    for (int i = 1; i <= m; i++)\\n    {\\n        for (int j = 1; j <= n; j++)\\n        {\\n            if (s[m - i] == t[n - j])\\n                ans[i][j] = ans[i - 1][j - 1];\\n            else\\n            {\\n                int a = 1 + ans[i - 1][j];\\n                int b = 1 + ans[i][j - 1];\\n                int c = 1 + ans[i - 1][j - 1];\\n                ans[i][j] = min(a, min(b, c));\\n            }\\n        }\\n    }\\n    return ans[m][n];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 662522,
                "title": "java-dp-easy-solution-with-explanation-well-commented",
                "content": "```\\nclass Solution {\\n    public int minDistance(String str1, String str2) {\\n        int m = str1.length();\\n        int n = str2.length();\\n        int dp[][] = new int[m + 1][n + 1]; \\n        // Fill d[][] in bottom up manner \\n        for (int i = 0; i <= m; i++) { \\n            for (int j = 0; j <= n; j++) { \\n                // If first string is empty, only option is to \\n                // insert all characters of second string \\n                \\n                if (i == 0) dp[i][j] = j; // Min. operations = j \\n                \\n                // If second string is empty, only option is to \\n                // remove all characters of second string \\n                \\n                else if (j == 0) \\n                    dp[i][j] = i; // Min. operations = i \\n                \\n                // If last characters are same, ignore last char \\n                // and recur for remaining string \\n                \\n                else if (str1.charAt(i - 1) == str2.charAt(j - 1)) \\n                    dp[i][j] = dp[i - 1][j - 1]; \\n  \\n                // If the last character is different, consider all \\n                // possibilities and find the minimum \\n                else\\n                    dp[i][j] = 1 + Math.min(Math.min(dp[i][j - 1], // Insert \\n                                       dp[i - 1][j]), // Remove \\n                                       dp[i - 1][j - 1]); // Replace \\n            } \\n        } \\n  \\n        return dp[m][n]; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minDistance(String str1, String str2) {\\n        int m = str1.length();\\n        int n = str2.length();\\n        int dp[][] = new int[m + 1][n + 1]; \\n        // Fill d[][] in bottom up manner \\n        for (int i = 0; i <= m; i++) { \\n            for (int j = 0; j <= n; j++) { \\n                // If first string is empty, only option is to \\n                // insert all characters of second string \\n                \\n                if (i == 0) dp[i][j] = j; // Min. operations = j \\n                \\n                // If second string is empty, only option is to \\n                // remove all characters of second string \\n                \\n                else if (j == 0) \\n                    dp[i][j] = i; // Min. operations = i \\n                \\n                // If last characters are same, ignore last char \\n                // and recur for remaining string \\n                \\n                else if (str1.charAt(i - 1) == str2.charAt(j - 1)) \\n                    dp[i][j] = dp[i - 1][j - 1]; \\n  \\n                // If the last character is different, consider all \\n                // possibilities and find the minimum \\n                else\\n                    dp[i][j] = 1 + Math.min(Math.min(dp[i][j - 1], // Insert \\n                                       dp[i - 1][j]), // Remove \\n                                       dp[i - 1][j - 1]); // Replace \\n            } \\n        } \\n  \\n        return dp[m][n]; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 662340,
                "title": "c-dp",
                "content": "**Case 1 :**\\nIf first string is empty, only option is to insert all characters of second string\\n**Case 2 :**\\nIf second string is empty, only option is to remove all characters of second string\\n**Options :**\\n* dp [i-1][j - 1] -> If we replace the character.\\n* dp [i][j - 1] -> If we delete the character.\\n* dp [i - 1][j] -> If we insert the character.\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = word1.length();\\n        int n = word2.length();\\n        vector<vector<int>> dp(n + 1, vector<int> (m + 1, 0));\\n\\t\\t\\n        for(int i = 1; i <= n; i++){ \\n            dp[i][0] = 1 + dp[i - 1][0];\\n        }\\n        for(int i = 1; i <= m; i++){\\n            dp[0][i] = 1 + dp[0][i - 1];\\n        }\\n        \\n        for(int i = 1; i <= n; i++){\\n            for(int j = 1; j <= m; j++){\\n              \\n                if(word2[i - 1] == word1[j - 1]){\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                }\\n                else{\\n                    dp[i][j] = 1 + min({dp[i - 1][j - 1], dp[i][j - 1], dp[i - 1][j]});\\n                }\\n               \\n            } \\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = word1.length();\\n        int n = word2.length();\\n        vector<vector<int>> dp(n + 1, vector<int> (m + 1, 0));\\n\\t\\t\\n        for(int i = 1; i <= n; i++){ \\n            dp[i][0] = 1 + dp[i - 1][0];\\n        }\\n        for(int i = 1; i <= m; i++){\\n            dp[0][i] = 1 + dp[0][i - 1];\\n        }\\n        \\n        for(int i = 1; i <= n; i++){\\n            for(int j = 1; j <= m; j++){\\n              \\n                if(word2[i - 1] == word1[j - 1]){\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                }\\n                else{\\n                    dp[i][j] = 1 + min({dp[i - 1][j - 1], dp[i][j - 1], dp[i - 1][j]});\\n                }\\n               \\n            } \\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 234043,
                "title": "c-well-commented-solution-with-explanation-dp",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int minDistance(string word1, string word2);\\n};\\n\\n/* Returns the minimum edit distance between the 2 strings */\\nint Solution :: minDistance(string str_1, string str_2)\\n{\\n    // Store the length of the two strings\\n    int lenFirst = str_1.length();\\n    int lenSecond = str_2.length();\\n    \\n    // Make a 2d vector of (len_first+1)*(len_second+1), since we are going to access the [len_first][len_second] element\\n    vector<vector<int>> dp;\\n    \\n    // Resize the vector to appropriate dimensions and initialise it with zero\\n    dp.resize(lenFirst+1);\\n    for(auto &row_vec : dp)\\n        row_vec.resize(lenSecond+1);\\n    \\n    /* DP definitions */\\n    /* dp[i][j] returns the edit distance of the first i elements of str_1 and first j elements of str_2 */\\n    \\n    \\n    /* dp[0][0] = 0\\n     * dp[0][j] = j First string is empty,  only insertions can happen\\n     * dp[i][0] = i Second string is empty, only deletions can happen\\n     * Compactly, dp[i][j] = max(i,j) if one of them is zero\\n     */\\n    \\n    // Fill the rest of the matrix \\n    for(int i=0; i<=(lenFirst); i++)\\n    {\\n        for(int j=0; j<=(lenSecond); j++)\\n        {\\n            // Base case, as discussed above\\n            if(i==0 || j==0)\\n                dp[i][j] = max(i,j);\\n                \\n            // If the last characters match, just remove them and calclulate for the left half\\n            else if(str_1[i-1] == str_2[j-1]) dp[i][j] = dp[i-1][j-1];\\n            \\n            // Else, the last character doesn\\'t match\\n            else\\n            {\\n                // Insert a new matching character at the end of first string. The last character matches now. \\n                int insert = 1 + dp[i][j-1];\\n                \\n                // Delete the last character of the first string\\n                int _delete = 1 + dp[i-1][j];\\n                \\n                // Replace the last character of the first string. Now, the last character matches. \\n                int replace = 1 + dp[i-1][j-1];\\n                \\n                // Take the best possible of all outcomes\\n                dp[i][j] = min({insert, _delete, replace});\\n            }\\n        }\\n    }\\n    \\n    // Return the edit distance of str_1 and str_2\\n    return dp[lenFirst][lenSecond];\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int minDistance(string word1, string word2);\\n};\\n\\n/* Returns the minimum edit distance between the 2 strings */\\nint Solution :: minDistance(string str_1, string str_2)\\n{\\n    // Store the length of the two strings\\n    int lenFirst = str_1.length();\\n    int lenSecond = str_2.length();\\n    \\n    // Make a 2d vector of (len_first+1)*(len_second+1), since we are going to access the [len_first][len_second] element\\n    vector<vector<int>> dp;\\n    \\n    // Resize the vector to appropriate dimensions and initialise it with zero\\n    dp.resize(lenFirst+1);\\n    for(auto &row_vec : dp)\\n        row_vec.resize(lenSecond+1);\\n    \\n    /* DP definitions */\\n    /* dp[i][j] returns the edit distance of the first i elements of str_1 and first j elements of str_2 */\\n    \\n    \\n    /* dp[0][0] = 0\\n     * dp[0][j] = j First string is empty,  only insertions can happen\\n     * dp[i][0] = i Second string is empty, only deletions can happen\\n     * Compactly, dp[i][j] = max(i,j) if one of them is zero\\n     */\\n    \\n    // Fill the rest of the matrix \\n    for(int i=0; i<=(lenFirst); i++)\\n    {\\n        for(int j=0; j<=(lenSecond); j++)\\n        {\\n            // Base case, as discussed above\\n            if(i==0 || j==0)\\n                dp[i][j] = max(i,j);\\n                \\n            // If the last characters match, just remove them and calclulate for the left half\\n            else if(str_1[i-1] == str_2[j-1]) dp[i][j] = dp[i-1][j-1];\\n            \\n            // Else, the last character doesn\\'t match\\n            else\\n            {\\n                // Insert a new matching character at the end of first string. The last character matches now. \\n                int insert = 1 + dp[i][j-1];\\n                \\n                // Delete the last character of the first string\\n                int _delete = 1 + dp[i-1][j];\\n                \\n                // Replace the last character of the first string. Now, the last character matches. \\n                int replace = 1 + dp[i-1][j-1];\\n                \\n                // Take the best possible of all outcomes\\n                dp[i][j] = min({insert, _delete, replace});\\n            }\\n        }\\n    }\\n    \\n    // Return the edit distance of str_1 and str_2\\n    return dp[lenFirst][lenSecond];\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1933524,
                "title": "step-by-step-explanation-from-brute-force-to-optimised-dp",
                "content": "\\n***It took a lot of time and efforts to make this post please upvote if you like it and found helpful !*** \\n\\n**Step By Step Explanation :-**\\n\\n For each poisition, check three subproblem:\\n      1. insert\\n      2. delete\\n      3. replace\\n\\nI was having trouble with this and figuring out the recurrences for the edit operations. i and j basically keep track of the current characters that are getting compared, each operation shifts them differently. **The important thing to note is that we are simulating the edit operations by moving i and j around**, not actually changing the input strings.\\n\\n**EXAMPLE**\\nc1 = sample, c2 = example\\ni = 0 (s), j = 0 (e)\\n**Replace** is simplest for me to understand, we replace the cur char with the char we need from word2. We then increment i and j to look at the next char.\\n*Replace -> match(c1,c2, i+1, j+1)*\\nc1 = eample, c2 = example\\ni = 1 (a), j = 1 (x)\\n\\n**Delete** removes the first character, shifting word 1 character to left. Since we do not actually delete the char, incrementing i simulates skipping this char.\\n*Delete -> match(c1, c2, i+1, j)*\\nc1 = sample, c2 = example\\ni = 1 (a) , j = 0 (e)\\n\\n**Insert** is the opposite of delete, we insert the char we need, shifting word 1 to the right. Since we do not actually add a char, leave i alone. It\\'s the similar as doing:\\n\\n  c1 = \"e\" + c1;\\n  match(c1,c2,i+1,j+1) //Since we added \"e\", i+1 would point to \"s\"\\n*Insert -> match(c1, c2, i, j+1)*\\nc1 = esample, c2 = example\\ni = 0 (s), j = 1 (x)\\n\\nHopefully I made sense, let me know if I can try to clarify more. I only recently was able to understand. Now lets jump to the Code part !\\n\\n***Method 1 : Recursion \\nTime Complexity : O(3^(min(len1,len2))  \\nSpace Complexity : O(n)***\\n\\n```\\nclass Solution {\\npublic:\\n    int editDistance(int i , int j , string& s1 , string& s2)\\n    {\\n        if (i == word1.size()) return word2.size() - j;\\n        if (j == word2.size()) return word1.size() - i;\\n        if( s1[i] == s2[j] ) return editDistance(i+1 , j+1, s1, s2);\\n        return 1 + min( editDistance(i , j+1, s1, s2), min( editDistance(i+1 , j, s1, s2),  editDistance(i+1 , j+1, s1, s2)));  // Didn\\'t Got it , No issue again go through the explanation !\\n    }\\n   \\n    int minDistance(string word1, string word2) {\\n    return editDistance(0, 0, word1 , word2);\\n    }\\n};\\n```\\nOfcourse It will give TLE , so for it we will precompute sub - problem and will store it in bottom - up and top - down manner using Dynamic Programming!\\n\\n\\n***Method 2 : Recursion + Memorisation ( Top - Down Approach )***\\n Time Complexity   :  O(len1 x len2) \\n Space Complexity : O(len1 x len2) \\n\\n```\\nclass Solution {\\npublic:\\n    int editDistance(int i , int j , string& s1 , string& s2, vector<vector<int>>&dp)\\n    {\\n        if(i == size(s1) ) return size(s2) - j;\\n        if(j == size(s2) ) return size(s1) - i;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        if( s1[i] == s2[j] ) return dp[i][j] = editDistance(i+1 , j+1, s1, s2, dp);\\n        return dp[i][j] = 1 + min( editDistance(i , j+1, s1, s2, dp), min( editDistance(i+1 , j, s1, s2, dp),  editDistance(i+1 , j+1, s1, s2, dp)));\\n    }\\n   \\n    int minDistance(string word1, string word2) {\\n    vector<vector<int>>dp(size(word1), vector<int>(size(word2), -1));\\n    return editDistance(0, 0, word1 , word2, dp);\\n    }\\n};\\n```\\n\\n\\n***Method 3 : Tabulation ( Bottom - Up Approach)*** \\n***Time Complexity   : O(len1 x len2)\\nSpace Complexity : O(len1 x len2)***\\n\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n    int n = size(word1); int m = size(word2);\\n    vector<vector<int>>dp(n+1, vector<int>(m+1,0));\\n    for(int i = 0 ; i <= n; i++) dp[i][0] = i;\\n    for(int j = 0 ; j <= m; j++) dp[0][j] = j;\\n    \\n    for(int i = 0 ; i < n; i++)\\n    {\\n        for(int j = 0 ; j < m; j++)\\n        {\\n           if( word1[i] == word2[j] ) \\n           dp[i+1][j+1] = dp[i][j];\\n           else\\n           dp[i + 1][j + 1] = min({dp[i][j + 1], dp[i + 1][j], dp[i][j]}) + 1;\\n\\t\\t   //Since it is bottom up, we are considering in the ascending order of indexes.\\n           //Insert means plus 1 to j, delete means plus 1 to i, replace means plus 1 to both i and j. \\n           //above sequence is delete, insert and replace. \\n        }\\n    }\\n    \\n    return dp[n][m];\\n    }\\n};\\n```\\n\\n***It took a lot of time and efforts to make this post please upvote if you like it and found helpful !***",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int editDistance(int i , int j , string& s1 , string& s2)\\n    {\\n        if (i == word1.size()) return word2.size() - j;\\n        if (j == word2.size()) return word1.size() - i;\\n        if( s1[i] == s2[j] ) return editDistance(i+1 , j+1, s1, s2);\\n        return 1 + min( editDistance(i , j+1, s1, s2), min( editDistance(i+1 , j, s1, s2),  editDistance(i+1 , j+1, s1, s2)));  // Didn\\'t Got it , No issue again go through the explanation !\\n    }\\n   \\n    int minDistance(string word1, string word2) {\\n    return editDistance(0, 0, word1 , word2);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int editDistance(int i , int j , string& s1 , string& s2, vector<vector<int>>&dp)\\n    {\\n        if(i == size(s1) ) return size(s2) - j;\\n        if(j == size(s2) ) return size(s1) - i;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        if( s1[i] == s2[j] ) return dp[i][j] = editDistance(i+1 , j+1, s1, s2, dp);\\n        return dp[i][j] = 1 + min( editDistance(i , j+1, s1, s2, dp), min( editDistance(i+1 , j, s1, s2, dp),  editDistance(i+1 , j+1, s1, s2, dp)));\\n    }\\n   \\n    int minDistance(string word1, string word2) {\\n    vector<vector<int>>dp(size(word1), vector<int>(size(word2), -1));\\n    return editDistance(0, 0, word1 , word2, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n    int n = size(word1); int m = size(word2);\\n    vector<vector<int>>dp(n+1, vector<int>(m+1,0));\\n    for(int i = 0 ; i <= n; i++) dp[i][0] = i;\\n    for(int j = 0 ; j <= m; j++) dp[0][j] = j;\\n    \\n    for(int i = 0 ; i < n; i++)\\n    {\\n        for(int j = 0 ; j < m; j++)\\n        {\\n           if( word1[i] == word2[j] ) \\n           dp[i+1][j+1] = dp[i][j];\\n           else\\n           dp[i + 1][j + 1] = min({dp[i][j + 1], dp[i + 1][j], dp[i][j]}) + 1;\\n\\t\\t   //Since it is bottom up, we are considering in the ascending order of indexes.\\n           //Insert means plus 1 to j, delete means plus 1 to i, replace means plus 1 to both i and j. \\n           //above sequence is delete, insert and replace. \\n        }\\n    }\\n    \\n    return dp[n][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 928349,
                "title": "java-top-down-memo",
                "content": "```\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        final int m = word1.length();\\n        final int n = word2.length();\\n        final int[][] memo = new int[m][n];\\n        \\n        return minDistHelper(word1, word2, m, n, memo);\\n    }\\n    \\n    private int minDistHelper(String word1, String word2, int m, int n, int[][] memo) {\\n        \\n        if(m == 0) {\\n            return n;\\n        }\\n        \\n        if(n == 0) {\\n            return m;\\n        }\\n        \\n        if(memo[m - 1][n - 1] != 0) {\\n            return memo[m - 1][n - 1];\\n        }\\n        \\n        if(word1.charAt(m - 1) == word2.charAt(n - 1)) {\\n            return minDistHelper(word1, word2, m - 1, n - 1, memo);\\n        }\\n        \\n        int insert = minDistHelper(word1, word2, m, n - 1, memo);\\n        int remove = minDistHelper(word1, word2, m - 1, n, memo);\\n        int replace = minDistHelper(word1, word2, m - 1, n - 1, memo);\\n        \\n        memo[m - 1][n - 1] = 1 + Math.min(insert, Math.min(remove, replace));\\n        return memo[m - 1][n - 1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        final int m = word1.length();\\n        final int n = word2.length();\\n        final int[][] memo = new int[m][n];\\n        \\n        return minDistHelper(word1, word2, m, n, memo);\\n    }\\n    \\n    private int minDistHelper(String word1, String word2, int m, int n, int[][] memo) {\\n        \\n        if(m == 0) {\\n            return n;\\n        }\\n        \\n        if(n == 0) {\\n            return m;\\n        }\\n        \\n        if(memo[m - 1][n - 1] != 0) {\\n            return memo[m - 1][n - 1];\\n        }\\n        \\n        if(word1.charAt(m - 1) == word2.charAt(n - 1)) {\\n            return minDistHelper(word1, word2, m - 1, n - 1, memo);\\n        }\\n        \\n        int insert = minDistHelper(word1, word2, m, n - 1, memo);\\n        int remove = minDistHelper(word1, word2, m - 1, n, memo);\\n        int replace = minDistHelper(word1, word2, m - 1, n - 1, memo);\\n        \\n        memo[m - 1][n - 1] = 1 + Math.min(insert, Math.min(remove, replace));\\n        return memo[m - 1][n - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 894150,
                "title": "a-straightforward-solution-python-faster-than-98-6",
                "content": "The idea is to find the recursive relation. \\n\\nIf `s1[i] == s2[j]`, then `f(i, j) = f(i - 1, j - 1)`\\nOtherwise, \\n    `f(i, j) = min(1 + f(i, j - 1), 1 + f(i - 1, j), 1 + f(i - 1, j - 1))`\\nwhich corresponds to insert, delete and replace.\\n\\n```\\nclass Solution:\\n    def minDistance(self, s1: str, s2: str) -> int:\\n\\n        @lru_cache(maxsize=None)\\n        def f(i, j):\\n            if i == 0 and j == 0: return 0\\n            if i == 0 or j == 0: return i or j\\n            if s1[i - 1] == s2[j - 1]:\\n                return f(i - 1, j - 1)\\n            return min(1 + f(i, j - 1), 1 + f(i - 1, j), 1 + f(i - 1, j - 1))\\n\\n        m, n = len(s1), len(s2)\\n        return f(m, n)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def minDistance(self, s1: str, s2: str) -> int:\\n\\n        @lru_cache(maxsize=None)\\n        def f(i, j):\\n            if i == 0 and j == 0: return 0\\n            if i == 0 or j == 0: return i or j\\n            if s1[i - 1] == s2[j - 1]:\\n                return f(i - 1, j - 1)\\n            return min(1 + f(i, j - 1), 1 + f(i - 1, j), 1 + f(i - 1, j - 1))\\n\\n        m, n = len(s1), len(s2)\\n        return f(m, n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 662356,
                "title": "easiest-solution-dp-w-explanation",
                "content": "This is also considered as levenshtein distance algorithm. \\nTime = O(mn)\\nSpace = O(mn)\\nHere, we can improve this method by using only 2 rows instead of the entire 2d array.\\n\\nHere, we have to find the minimum no of operations to convert one string to another. \\nAlso, this will get harder with longer strings so our best friend here will be dynamic programming.\\nWe can construct a 2d array/matrix to store all the possible least no. operations to convert one string to another.\\n\\n\\t0 1 2 3 4\\n0\\n1\\n2\\n3\\n4\\n5\\nWe have to initialize our matrix like this^ to add values into it. \\nHere these two axis represent two strings.\\nWe have taken 0 in the beginning which acts as our base case. So it will look something like this:\\n       \\n\\t0 1 2 3 4\\n0  0 0 0 0 0 \\n1  0\\n2  0\\n3  0\\n4  0\\n5  0\\nThis is our base case and now we\\'ll just use dp to find all the values. \\nOur formula will be \\nif string2[i] == string1[j] # means if two letters are equal:\\nmatrix[i][j] = matrix[i - 1][j - 1] because it will give us min no of operations\\n\\nelse:(if the letters that we\\'re comparing are not equal, then well check all the values, above it, to the left if it and to the left diagonal) find min of these and add 1 to it.\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  \\nCode:\\n\\n\\tclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        edits = [[x for x in range(len(word1) + 1)] for y in range(len(word2) + 1)] #initialize 2d\\n        for i in range(1, len(word2) + 1): #initailize first column(012345)\\n            edits[i][0] = edits[i - 1][0] + 1\\n        for i in range(1, len(word2) + 1):\\n            for j in range(1, len(word1) + 1):\\n                if word2[i - 1] == word1[j - 1]: #if same just check diaginal\\n                    edits[i][j] = edits[i - 1][j - 1]\\n                else:\\n                    edits[i][j] = 1 + min(edits[i - 1][j - 1], edits[i][j - 1], edits[i - 1][j]) #check all three vals, find min and add 1\\n        return edits[-1][-1] #return final val of our 2d matrix(last row last col)\\n\\t\\t\\nIf you have any questions, feel free to comment down below. I\\'m also gonna implement this using only two rows which will save some space. \\n                        \\n            \\n        \\n            \\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "This is also considered as levenshtein distance algorithm. \\nTime = O(mn)\\nSpace = O(mn)\\nHere, we can improve this method by using only 2 rows instead of the entire 2d array.\\n\\nHere, we have to find the minimum no of operations to convert one string to another. \\nAlso, this will get harder with longer strings so our best friend here will be dynamic programming.\\nWe can construct a 2d array/matrix to store all the possible least no. operations to convert one string to another.\\n\\n\\t0 1 2 3 4\\n0\\n1\\n2\\n3\\n4\\n5\\nWe have to initialize our matrix like this^ to add values into it. \\nHere these two axis represent two strings.\\nWe have taken 0 in the beginning which acts as our base case. So it will look something like this:\\n       \\n\\t0 1 2 3 4\\n0  0 0 0 0 0 \\n1  0\\n2  0\\n3  0\\n4  0\\n5  0\\nThis is our base case and now we\\'ll just use dp to find all the values. \\nOur formula will be \\nif string2[i] == string1[j] # means if two letters are equal:\\nmatrix[i][j] = matrix[i - 1][j - 1] because it will give us min no of operations\\n\\nelse:(if the letters that we\\'re comparing are not equal, then well check all the values, above it, to the left if it and to the left diagonal) find min of these and add 1 to it.\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  \\nCode:\\n\\n\\tclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        edits = [[x for x in range(len(word1) + 1)] for y in range(len(word2) + 1)] #initialize 2d\\n        for i in range(1, len(word2) + 1): #initailize first column(012345)\\n            edits[i][0] = edits[i - 1][0] + 1\\n        for i in range(1, len(word2) + 1):\\n            for j in range(1, len(word1) + 1):\\n                if word2[i - 1] == word1[j - 1]: #if same just check diaginal\\n                    edits[i][j] = edits[i - 1][j - 1]\\n                else:\\n                    edits[i][j] = 1 + min(edits[i - 1][j - 1], edits[i][j - 1], edits[i - 1][j]) #check all three vals, find min and add 1\\n        return edits[-1][-1] #return final val of our 2d matrix(last row last col)\\n\\t\\t\\nIf you have any questions, feel free to comment down below. I\\'m also gonna implement this using only two rows which will save some space. \\n                        \\n            \\n        \\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 479377,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8 The **ART** of dynamic programming](https://leetcode.com/discuss/general-discussion/712010/the-art-of-dynamic-programming-an-intuitive-approach-from-apprentice-to-master/)\\n\\n1. **A**ll possibilities are considered via brute-force top-down depth-first-search\\n2. **R**emember each subproblems\\' optimal solution via a DP memo\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n4. Memory optimization from O(N<sup>2</sup>) to O(N) by replacing `dp` matrix with previous/current rows\\n\\n---\\n\\n**Kotlin Solutions:**\\n\\n1. **A**ll possibilities are considered via brute-force top-down depth-first-search\\n```\\nclass Solution {\\n    fun minDistance(s: String, t: String): Int {\\n        var (M, N) = listOf(s.length, t.length)\\n        fun go(i: Int = 0, j: Int = 0): Int {\\n            if (i == M || j == N)\\n                return M - i + N - j\\n            var a = (if (s[i] != t[j]) 1 else 0) + go(i + 1, j + 1)\\n            var b = 1 + go(i + 1, j)\\n            var c = 1 + go(i, j + 1)\\n            return listOf(a, b, c).min()!!\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n2. **R**emember each subproblems\\' optimal solution via a DP memo\\n```\\nclass Solution {\\n    fun minDistance(s: String, t: String): Int {\\n        var (M, N) = listOf(s.length, t.length)\\n        var m = mutableMapOf<String, Int>()\\n        fun go(i: Int = 0, j: Int = 0): Int {\\n            if (i == M || j == N)\\n                return M - i + N - j\\n            var k = \"$i,$j\"\\n            if (!m.contains(k)) {\\n                var a = (if (s[i] != t[j]) 1 else 0) + go(i + 1, j + 1)\\n                var b = 1 + go(i + 1, j)\\n                var c = 1 + go(i, j + 1)\\n                m[k] = listOf(a, b, c).min()!!\\n            }\\n            return m[k]!!\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\n    fun minDistance(s: String, t: String): Int {\\n        var (M, N) = listOf(s.length, t.length)\\n        var dp = Array(M + 1) { IntArray(N + 1) { 0 } }\\n        for (i in 1..M) dp[i][0] = 1 + dp[i - 1][0]\\n        for (j in 1..N) dp[0][j] = 1 + dp[0][j - 1]\\n        for (i in 1..M) {\\n            for (j in 1..N) {\\n                var a = (if (s[i - 1] != t[j - 1]) 1 else 0) + dp[i - 1][j - 1]\\n                var b = 1 + dp[i - 1][j]\\n                var c = 1 + dp[i][j - 1]\\n                dp[i][j] = listOf(a, b, c).min()!!\\n            }\\n        }\\n        return dp[M][N]\\n    }\\n}\\n```\\n\\n4. Memory optimization from O(N<sup>2</sup>) to O(N) by replacing `dp` matrix with previous/current rows\\n```\\nclass Solution {\\n    fun minDistance(s: String, t: String): Int {\\n        var (M, N) = listOf(s.length, t.length)\\n        var cur = IntArray(N + 1) { 0 }\\n        for (j in 1..N) cur[j] = 1 + cur[j - 1]\\n        for (i in 1..M) {\\n            var pre = cur.copyOf()\\n            ++cur[0]\\n            for (j in 1..N) {\\n                var a = (if (s[i - 1] != t[j - 1]) 1 else 0) + pre[j - 1]\\n                var b = 1 + pre[j]\\n                var c = 1 + cur[j - 1]\\n                cur[j] = listOf(a, b, c).min()!!\\n            }\\n        }\\n        return cur[N]\\n    }\\n}\\n```\\n\\n---\\n\\n**Javascript Solutions:**\\n\\n1. **A**ll possibilities are considered via brute-force top-down depth-first-search\\n```\\nlet minDistance = (s, t) => {\\n    let [M, N] = [s.length, t.length];\\n    let go = (i = 0, j = 0) => {\\n        if (i == M || j == N)\\n            return M - i + N - j;\\n        let a = Number(s[i] != t[j]) + go(i + 1, j + 1),\\n            b = 1 + go(i + 1, j),\\n            c = 1 + go(i, j + 1);\\n        return Math.min(a, b, c);\\n    };\\n    return go();\\n};\\n```\\n\\n2. **R**emember each subproblems\\' optimal solution via a DP memo\\n```\\nlet minDistance = (s, t, m = new Map()) => {\\n    let [M, N] = [s.length, t.length];\\n    let go = (i = 0, j = 0) => {\\n        if (i == M || j == N)\\n            return M - i + N - j;\\n        let k = `${i},${j}`;\\n        if (!m.has(k)) {\\n            let a = Number(s[i] != t[j]) + go(i + 1, j + 1),\\n                b = 1 + go(i + 1, j),\\n                c = 1 + go(i, j + 1);\\n            m.set(k, Math.min(a, b, c));\\n        }\\n        return m.get(k);\\n    };\\n    return go();\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nlet minDistance = (s, t, m = new Map()) => {\\n    let [M, N] = [s.length, t.length];\\n    let dp = [...Array(M + 1)].map(_ => Array(N + 1).fill(0));\\n    for (let i = 1; i <= M; ++i) dp[i][0] = 1 + dp[i - 1][0];\\n    for (let j = 1; j <= N; ++j) dp[0][j] = 1 + dp[0][j - 1];\\n    for (let i = 1; i <= M; ++i) {\\n        for (let j = 1; j <= N; ++j) {\\n            let a = Number(s[i - 1] != t[j - 1]) + dp[i - 1][j - 1],\\n                b = 1 + dp[i - 1][j],\\n                c = 1 + dp[i][j - 1];\\n            dp[i][j] = Math.min(a, b, c);\\n        }\\n    }\\n    return dp[M][N];\\n};\\n```\\n\\n4. Memory optimization from O(N<sup>2</sup>) to O(N) by replacing `dp` matrix with previous/current rows\\n```\\nlet minDistance = (s, t, m = new Map()) => {\\n    let [M, N] = [s.length, t.length];\\n    let cur = Array(N + 1).fill(0);\\n    for (let j = 1; j <= N; ++j) cur[j] = 1 + cur[j - 1];\\n    for (let i = 1; i <= M; ++i) {\\n        let pre = [...cur];\\n        ++cur[0];\\n        for (let j = 1; j <= N; ++j) {\\n            let a = Number(s[i - 1] != t[j - 1]) + pre[j - 1],\\n                b = 1 + pre[j],\\n                c = 1 + cur[j - 1];\\n            cur[j] = Math.min(a, b, c);\\n        }\\n    }\\n    return cur[N];\\n};\\n```\\n\\n---\\n\\n**Python3 Solutions:**\\n\\n1. **A**ll possibilities are considered via brute-force top-down depth-first-search\\n```\\nclass Solution:\\n    def minDistance(self, s: str, t: str) -> int:\\n        M, N = len(s), len(t)\\n        def go(i = 0, j = 0):\\n            if i == M or j == N:\\n                return M - i + N - j\\n            a = int(s[i] != t[j]) + go(i + 1, j + 1)\\n            b = 1 + go(i + 1, j)\\n            c = 1 + go(i, j + 1)\\n            return min(a, b, c)\\n        return go()\\n```\\n\\n2. **R**emember each subproblems\\' optimal solution via a DP memo\\n```\\nclass Solution:\\n    def minDistance(self, s: str, t: str) -> int:\\n        M, N = len(s), len(t)\\n        @cache\\n        def go(i = 0, j = 0):\\n            if i == M or j == N:\\n                return M - i + N - j\\n            a = int(s[i] != t[j]) + go(i + 1, j + 1)\\n            b = 1 + go(i + 1, j)\\n            c = 1 + go(i, j + 1)\\n            return min(a, b, c)\\n        return go()\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution:\\n    def minDistance(self, s: str, t: str) -> int:\\n        M, N = len(s), len(t)\\n        dp = [[0] * (N + 1) for _ in range(M + 1)]\\n        for i in range(1, M + 1): dp[i][0] = 1 + dp[i - 1][0]\\n        for j in range(1, N + 1): dp[0][j] = 1 + dp[0][j - 1]\\n        for i in range(1, M + 1):\\n            for j in range(1, N + 1):\\n                a = int(s[i - 1] != t[j - 1]) + dp[i - 1][j - 1]\\n                b = 1 + dp[i - 1][j]\\n                c = 1 + dp[i][j - 1]\\n                dp[i][j] = min(a, b, c)\\n        return dp[M][N]\\n```\\n\\n4. Memory optimization from O(N<sup>2</sup>) to O(N) by replacing `dp` matrix with previous/current rows\\n```\\nclass Solution:\\n    def minDistance(self, s: str, t: str) -> int:\\n        M, N = len(s), len(t)\\n        cur = [0] * (N + 1)\\n        for j in range(1, N + 1): cur[j] = 1 + cur[j - 1]\\n        for i in range(1, M + 1):\\n            pre = cur[:]\\n            cur[0] += 1\\n            for j in range(1, N + 1):\\n                a = int(s[i - 1] != t[j - 1]) + pre[j - 1]\\n                b = 1 + pre[j]\\n                c = 1 + cur[j - 1]\\n                cur[j] = min(a, b, c)\\n        return cur[N]\\n```\\n\\n---\\n\\n**C++ Solutions:**\\n\\n1. **A**ll possibilities are considered via brute-force top-down depth-first-search\\n```\\nclass Solution {\\npublic:\\n    using fun = function<int(int, int)>;\\n    int minDistance(string s, string t) {\\n        int M = s.size(),\\n            N = t.size();\\n        fun go = [&](auto i, auto j) {\\n            if (i == M || j == N)\\n                return M - i + N - j;\\n            auto a = int(s[i] != t[j]) + go(i + 1, j + 1),\\n                 b = 1 + go(i + 1, j),\\n                 c = 1 + go(i, j + 1);\\n            return min({ a, b, c });\\n        };\\n        return go(0, 0);\\n    }\\n};\\n```\\n\\n2. **R**emember each subproblems\\' optimal solution via a DP memo\\n```\\nclass Solution {\\npublic:\\n    using fun = function<int(int, int)>;\\n    using Map = unordered_map<string, int>;\\n    int minDistance(string s, string t, Map m = {}) {\\n        int M = s.size(),\\n            N = t.size();\\n        auto key = [](auto i, auto j) {\\n            stringstream ss; ss << i << \",\" << j;\\n            return ss.str();\\n        };\\n        fun go = [&](auto i, auto j) {\\n            if (i == M || j == N)\\n                return M - i + N - j;\\n            auto k = key(i, j);\\n            if (m.find(k) == m.end()) {\\n                auto a = int(s[i] != t[j]) + go(i + 1, j + 1),\\n                     b = 1 + go(i + 1, j),\\n                     c = 1 + go(i, j + 1);\\n                m[k] = min({ a, b, c });\\n            }\\n            return m[k];\\n        };\\n        return go(0, 0);\\n    }\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int minDistance(string s, string t) {\\n        int M = s.size(),\\n            N = t.size();\\n        VVI dp(M + 1, VI(N + 1));\\n        for (auto i{ 1 }; i <= M; ++i) dp[i][0] = 1 + dp[i - 1][0];\\n        for (auto j{ 1 }; j <= N; ++j) dp[0][j] = 1 + dp[0][j - 1];\\n        for (auto i{ 1 }; i <= M; ++i) {\\n            for (auto j{ 1 }; j <= N; ++j) {\\n                auto a = int(s[i - 1] != t[j - 1]) + dp[i - 1][j - 1],\\n                     b = 1 + dp[i - 1][j],\\n                     c = 1 + dp[i][j - 1];\\n                dp[i][j] = min({ a, b, c });\\n            }\\n        }\\n        return dp[M][N];\\n    }\\n};\\n```\\n\\n4. Memory optimization from O(N<sup>2</sup>) to O(N) by replacing `dp` matrix with previous/current rows\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int minDistance(string s, string t) {\\n        int M = s.size(),\\n            N = t.size();\\n        VI cur(N + 1);\\n        for (auto j{ 1 }; j <= N; ++j) cur[j] = 1 + cur[j - 1];\\n        for (auto i{ 1 }; i <= M; ++i) {\\n            auto pre{ cur };\\n            ++cur[0];\\n            for (auto j{ 1 }; j <= N; ++j) {\\n                auto a = int(s[i - 1] != t[j - 1]) + pre[j - 1],\\n                     b = 1 + pre[j],\\n                     c = 1 + cur[j - 1];\\n                cur[j] = min({ a, b, c });\\n            }\\n        }\\n        return cur[N];\\n    }\\n};\\n```\\n\\n---\\n\\n**Legacy Solutions from October 2, 2020:**\\n\\nLet `i` and `j` be non-inclusive indexes of strings `A` and `B` which denote each corresponding substring of `A[0..i)` and `B[0..j)`.  Let `M` and `N` be the length of `A` and `B`.  Thus initially `i = M` and `j = N` (ie. `A == A[0..i=M)` and `B == B[0..j=N)`).  Recursively consider the last character of `A` and `B`, ie. `A[i - 1]` and `B[j - 1]`, there are 4 use cases:\\n\\n1. If the last characters match, then there is no penalty, move onto the sub-problems without the last characters\\n2. If the last characters mismatch, then the last character in `A` can be replaced with the last character in `B` xor the last character in `B` can be replaced with the last character in `A` to make these characters match.  This replacement is an arbitrary choice with penalty of `1`\\n3. If the last characters mismatch, then we can insert a character in `A` xor we can delete a character from `B`.  The insertion/deletion is an arbitrary choice with penalty of `1`\\n4. If the last characters mismatch, then we can insert a character in `B` xor we can delete a character from `A`.  The insertion/deletion is an arbitrary choice with penalty of `1`\\n\\n---\\n\\n**Example use case 1:** the last character `x` is a match.  There is no penalty.\\n```\\nA = ...x\\nB = ...x\\n```\\n\\n**Example use case 2:** the last character `x` is a mismatch.  Regardless of the arbitrary \"fix\" choosen, there is a penalty of `1` for this replacement.\\n```\\nA = ...x\\nB = ...y\\n```\\n\\n* If we replace `x` with `y` in `A`, then this use case 2 mismatch is \"fixed\" as follows:\\n```\\nA = ...y\\nB = ...y\\n```\\n\\n* If we replace `y` with `x` in `B`, then this use case 2 mismatch is \"fixed\" as follows:\\n```\\nA = ...x\\nB = ...x\\n```\\n\\n**Example use case 3:** the last character `z` is a mismatch.  Regardless of the arbitrary \"fix\" choosen, there is a penalty of `1` for this insertion/deletion.\\n```\\nA = xy\\nB = xyz\\n```\\n\\n* If we insert `z` in `A`, then this use case 3 mismatch is \"fixed\" as follows:\\n```\\nA = xyz\\nB = xyz\\n```\\n\\n* If we delete `z` from `B`, then this use case 3 mismatch is \"fixed\" as follows:\\n```\\nA = xy\\nB = xy\\n```\\n\\n**Example use case 4:** the last character `z` is a mismatch.  Regardless of the arbitrary \"fix\" choosen, there is a penalty of `1` for this insertion/deletion.\\n```\\nA = xyz\\nB = xy\\n```\\n\\n* If we insert `z` in `B`, then this use case 3 mismatch is \"fixed\" as follows:\\n```\\nA = xyz\\nB = xyz\\n```\\n\\n* If we delete `z` from `A`, then this use case 3 mismatch is \"fixed\" as follows:\\n```\\nA = xy\\nB = xy\\n```\\n\\n---\\n\\n**Javascript Solutions:**\\n\\n*Javascript: Top-Down TLE without Memo*\\n```\\nlet minDistance = (A, B) => {\\n    let go = (A, B, i, j) => {\\n        if (!i || !j)\\n            return i + j; // \\uD83D\\uDED1 base case: we have exhausted A or B, return \"leftover\" distance\\n        return Math.min(\\n            go(A, B, i - 1, j - 1) + Number(A[i - 1] != B[j - 1]), // \\u2705 match xor \\u274C mismatch\\n            go(A, B, i - 1, j) + 1, // \\u274C insertion\\n            go(A, B, i, j - 1) + 1  // \\u274C deletion\\n        );\\n    };\\n    return go(A, B, A.length, B.length);\\n};\\n```\\n\\n*Javascript: Top-Down with Memo*\\n```\\nlet minDistance = (A, B) => {\\n    let go = (A, B, i, j, memo = {}) => {\\n        let key = `${i},${j}`; // \\uD83D\\uDD11 \\n        if (memo[key])\\n            return memo[key]; // \\uD83E\\uDD14 memo\\n        if (!i || !j)\\n            return memo[key] = i + j; // \\uD83D\\uDED1 base case: we have exhausted A or B, return \"leftover\" distance\\n        return memo[key] = Math.min(\\n            go(A, B, i - 1, j - 1, memo) + Number(A[i - 1] != B[j - 1]), // \\u2705 match xor \\u274C mismatch\\n            go(A, B, i - 1, j, memo) + 1, // \\u274C insertion \\n            go(A, B, i, j - 1, memo) + 1  // \\u274C deletion\\n        );\\n    };\\n    return go(A, B, A.length, B.length);\\n};\\n```\\n\\n*Javascript: Bottom-Up with full DP matrix*\\n```\\nlet minDistance = (A, B) => {\\n    let [M, N] = [A.length, B.length];\\n    let dp = [...Array(M + 1)].map(row => Array(N + 1).fill(0)); // \\uD83E\\uDD14 memo\\n    for (let i = 0; i <= M; ++i) dp[i][0] = i; // \\uD83D\\uDED1 base case: we have exhausted B, return \"leftover\" distance\\n    for (let j = 0; j <= N; ++j) dp[0][j] = j; // \\uD83D\\uDED1 base case: we have exhausted A, return \"leftover\" distance\\n    for (let i = 1; i <= M; ++i)\\n        for (let j = 1; j <= N; ++j)\\n            dp[i][j] = Math.min(\\n                dp[i - 1][j - 1] + Number(A[i - 1] != B[j - 1]), // \\u2705 match xor \\u274C mismatch\\n                dp[i - 1][j] + 1, // \\u274C insertion \\n                dp[i][j - 1] + 1, // \\u274C deletion\\n            );\\n    return dp[M][N];\\n};\\n```\\n\\n*Javascript: Bottom-Up with memory optimization to only store previous and current rows of the DP matrix*\\n```\\nlet minDistance = (A, B) => {\\n    let [M, N] = [A.length, B.length];\\n    let pre = [...Array(N + 1)].map((_, i) => i); // \\uD83E\\uDD14 memo \\uD83D\\uDED1 base case: we have exhausted A or B, return \"leftover\" distance\\n    for (let i = 1; i <= M; ++i) {\\n        let cur = [...pre]; // \\uD83E\\uDD14 generate current from previous\\n        cur[0] = i; // \\uD83D\\uDED1 base case: we have exhausted A or B, return \"leftover\" distance\\n        for (let j = 1; j <= N; ++j) {\\n            cur[j] = Math.min(\\n                pre[j - 1] + Number(A[i - 1] != B[j - 1]), // \\u2705 match xor \\u274C mismatch\\n                pre[j] + 1,     // \\u274C insertion \\n                cur[j - 1] + 1, // \\u274C deletion\\n            );\\n        }\\n        [pre, cur] = [cur, pre]; // swap\\n    }\\n    return pre[N];\\n};\\n```\\n\\n---\\n\\n**C++ Solutions:**\\n\\n*C++: Top-Down TLE without Memo*\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string A, string B) {\\n        return go(A, B, A.size(), B.size());\\n    }\\nprivate:\\n    int go(string& A, string& B, int i, int j) {\\n        if (!i || !j)\\n            return i + j; // \\uD83D\\uDED1 base case: we have exhausted A or B, return \"leftover\" distance\\n        return min({\\n            go(A, B, i - 1, j - 1) + int(A[i - 1] != B[j - 1]), // \\u2705 match xor \\u274C mismatch\\n            go(A, B, i - 1, j) + 1, // \\u274C insertion\\n            go(A, B, i, j - 1) + 1  // \\u274C deletion\\n        });\\n    }\\n};\\n```\\n\\n*C++: Top-Down with Memo*\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string A, string B) {\\n        return go(A, B, A.size(), B.size());\\n    }\\nprivate:\\n    using Memo = unordered_map<string, int>;\\n    int go(string& A, string& B, int i, int j, Memo&& memo = {}) {\\n        stringstream ss; ss << i << \",\" << j;\\n        auto key = ss.str(); // \\uD83D\\uDD11\\n        if (memo.find(key) != memo.end())\\n            return memo[key]; // \\uD83E\\uDD14 memo\\n        if (!i || !j)\\n            return memo[key] = i + j;\\n        return memo[key] = min({\\n            go(A, B, i - 1, j - 1, move(memo)) + int(A[i - 1] != B[j - 1]), // \\u2705 match xor \\u274C mismatch\\n            go(A, B, i - 1, j, move(memo)) + 1, // \\u274C insertion\\n            go(A, B, i, j - 1, move(memo)) + 1  // \\u274C deletion\\n        });\\n    }\\n};\\n```\\n\\n*C++: Bottom-Up with full DP matrix*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int minDistance(string A, string B) {\\n        auto [M, N] = make_tuple(A.size(), B.size());\\n        VVI dp(M + 1, VI(N + 1)); // \\uD83E\\uDD14 memo\\n        for (auto i = 0; i <= M; ++i) dp[i][0] = i; // \\uD83D\\uDED1 base case: we have exhausted B, return \"leftover\" distance\\n        for (auto j = 0; j <= N; ++j) dp[0][j] = j; // \\uD83D\\uDED1 base case: we have exhausted A, return \"leftover\" distance\\n        for (auto i = 1; i <= M; ++i)\\n            for (auto j = 1; j <= N; ++j)\\n                dp[i][j] = min({\\n                    dp[i - 1][j - 1] + int(A[i - 1] != B[j - 1]), // \\u2705 match xor \\u274C mismatch\\n                    dp[i - 1][j] + 1, // \\u274C insertion \\n                    dp[i][j - 1] + 1, // \\u274C deletion\\n                });\\n        return dp[M][N];\\n    }\\n};\\n```\\n\\n*C++: Bottom-Up with memory optimization to only store previous and current rows of the DP matrix*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int minDistance(string A, string B) {\\n        auto [M, N] = make_tuple(A.size(), B.size());\\n        VI pre(N + 1); // \\uD83E\\uDD14 memo\\n        iota(pre.begin(), pre.end(), 0); // \\uD83D\\uDED1 base case: we have exhausted A or B, i is the \"leftover\" distance\\n        for (auto i = 1; i <= M; ++i) {\\n            auto cur{ pre }; // \\uD83E\\uDD14 generate current from previous\\n            cur[0] = i; // \\uD83D\\uDED1 base case: we have exhausted A or B, i is the \"leftover\" distance\\n            for (auto j = 1; j <= N; ++j) {\\n                cur[j] = min({\\n                    pre[j - 1] + int(A[i - 1] != B[j - 1]), // \\u2705 match xor \\u274C mismatch\\n                    pre[j] + 1,     // \\u274C insertion \\n                    cur[j - 1] + 1, // \\u274C deletion\\n                });\\n            }\\n            swap(pre, cur);\\n        }\\n        return pre[N];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun minDistance(s: String, t: String): Int {\\n        var (M, N) = listOf(s.length, t.length)\\n        fun go(i: Int = 0, j: Int = 0): Int {\\n            if (i == M || j == N)\\n                return M - i + N - j\\n            var a = (if (s[i] != t[j]) 1 else 0) + go(i + 1, j + 1)\\n            var b = 1 + go(i + 1, j)\\n            var c = 1 + go(i, j + 1)\\n            return listOf(a, b, c).min()!!\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun minDistance(s: String, t: String): Int {\\n        var (M, N) = listOf(s.length, t.length)\\n        var m = mutableMapOf<String, Int>()\\n        fun go(i: Int = 0, j: Int = 0): Int {\\n            if (i == M || j == N)\\n                return M - i + N - j\\n            var k = \"$i,$j\"\\n            if (!m.contains(k)) {\\n                var a = (if (s[i] != t[j]) 1 else 0) + go(i + 1, j + 1)\\n                var b = 1 + go(i + 1, j)\\n                var c = 1 + go(i, j + 1)\\n                m[k] = listOf(a, b, c).min()!!\\n            }\\n            return m[k]!!\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun minDistance(s: String, t: String): Int {\\n        var (M, N) = listOf(s.length, t.length)\\n        var dp = Array(M + 1) { IntArray(N + 1) { 0 } }\\n        for (i in 1..M) dp[i][0] = 1 + dp[i - 1][0]\\n        for (j in 1..N) dp[0][j] = 1 + dp[0][j - 1]\\n        for (i in 1..M) {\\n            for (j in 1..N) {\\n                var a = (if (s[i - 1] != t[j - 1]) 1 else 0) + dp[i - 1][j - 1]\\n                var b = 1 + dp[i - 1][j]\\n                var c = 1 + dp[i][j - 1]\\n                dp[i][j] = listOf(a, b, c).min()!!\\n            }\\n        }\\n        return dp[M][N]\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun minDistance(s: String, t: String): Int {\\n        var (M, N) = listOf(s.length, t.length)\\n        var cur = IntArray(N + 1) { 0 }\\n        for (j in 1..N) cur[j] = 1 + cur[j - 1]\\n        for (i in 1..M) {\\n            var pre = cur.copyOf()\\n            ++cur[0]\\n            for (j in 1..N) {\\n                var a = (if (s[i - 1] != t[j - 1]) 1 else 0) + pre[j - 1]\\n                var b = 1 + pre[j]\\n                var c = 1 + cur[j - 1]\\n                cur[j] = listOf(a, b, c).min()!!\\n            }\\n        }\\n        return cur[N]\\n    }\\n}\\n```\n```\\nlet minDistance = (s, t) => {\\n    let [M, N] = [s.length, t.length];\\n    let go = (i = 0, j = 0) => {\\n        if (i == M || j == N)\\n            return M - i + N - j;\\n        let a = Number(s[i] != t[j]) + go(i + 1, j + 1),\\n            b = 1 + go(i + 1, j),\\n            c = 1 + go(i, j + 1);\\n        return Math.min(a, b, c);\\n    };\\n    return go();\\n};\\n```\n```\\nlet minDistance = (s, t, m = new Map()) => {\\n    let [M, N] = [s.length, t.length];\\n    let go = (i = 0, j = 0) => {\\n        if (i == M || j == N)\\n            return M - i + N - j;\\n        let k = `${i},${j}`;\\n        if (!m.has(k)) {\\n            let a = Number(s[i] != t[j]) + go(i + 1, j + 1),\\n                b = 1 + go(i + 1, j),\\n                c = 1 + go(i, j + 1);\\n            m.set(k, Math.min(a, b, c));\\n        }\\n        return m.get(k);\\n    };\\n    return go();\\n};\\n```\n```\\nlet minDistance = (s, t, m = new Map()) => {\\n    let [M, N] = [s.length, t.length];\\n    let dp = [...Array(M + 1)].map(_ => Array(N + 1).fill(0));\\n    for (let i = 1; i <= M; ++i) dp[i][0] = 1 + dp[i - 1][0];\\n    for (let j = 1; j <= N; ++j) dp[0][j] = 1 + dp[0][j - 1];\\n    for (let i = 1; i <= M; ++i) {\\n        for (let j = 1; j <= N; ++j) {\\n            let a = Number(s[i - 1] != t[j - 1]) + dp[i - 1][j - 1],\\n                b = 1 + dp[i - 1][j],\\n                c = 1 + dp[i][j - 1];\\n            dp[i][j] = Math.min(a, b, c);\\n        }\\n    }\\n    return dp[M][N];\\n};\\n```\n```\\nlet minDistance = (s, t, m = new Map()) => {\\n    let [M, N] = [s.length, t.length];\\n    let cur = Array(N + 1).fill(0);\\n    for (let j = 1; j <= N; ++j) cur[j] = 1 + cur[j - 1];\\n    for (let i = 1; i <= M; ++i) {\\n        let pre = [...cur];\\n        ++cur[0];\\n        for (let j = 1; j <= N; ++j) {\\n            let a = Number(s[i - 1] != t[j - 1]) + pre[j - 1],\\n                b = 1 + pre[j],\\n                c = 1 + cur[j - 1];\\n            cur[j] = Math.min(a, b, c);\\n        }\\n    }\\n    return cur[N];\\n};\\n```\n```\\nclass Solution:\\n    def minDistance(self, s: str, t: str) -> int:\\n        M, N = len(s), len(t)\\n        def go(i = 0, j = 0):\\n            if i == M or j == N:\\n                return M - i + N - j\\n            a = int(s[i] != t[j]) + go(i + 1, j + 1)\\n            b = 1 + go(i + 1, j)\\n            c = 1 + go(i, j + 1)\\n            return min(a, b, c)\\n        return go()\\n```\n```\\nclass Solution:\\n    def minDistance(self, s: str, t: str) -> int:\\n        M, N = len(s), len(t)\\n        @cache\\n        def go(i = 0, j = 0):\\n            if i == M or j == N:\\n                return M - i + N - j\\n            a = int(s[i] != t[j]) + go(i + 1, j + 1)\\n            b = 1 + go(i + 1, j)\\n            c = 1 + go(i, j + 1)\\n            return min(a, b, c)\\n        return go()\\n```\n```\\nclass Solution:\\n    def minDistance(self, s: str, t: str) -> int:\\n        M, N = len(s), len(t)\\n        dp = [[0] * (N + 1) for _ in range(M + 1)]\\n        for i in range(1, M + 1): dp[i][0] = 1 + dp[i - 1][0]\\n        for j in range(1, N + 1): dp[0][j] = 1 + dp[0][j - 1]\\n        for i in range(1, M + 1):\\n            for j in range(1, N + 1):\\n                a = int(s[i - 1] != t[j - 1]) + dp[i - 1][j - 1]\\n                b = 1 + dp[i - 1][j]\\n                c = 1 + dp[i][j - 1]\\n                dp[i][j] = min(a, b, c)\\n        return dp[M][N]\\n```\n```\\nclass Solution:\\n    def minDistance(self, s: str, t: str) -> int:\\n        M, N = len(s), len(t)\\n        cur = [0] * (N + 1)\\n        for j in range(1, N + 1): cur[j] = 1 + cur[j - 1]\\n        for i in range(1, M + 1):\\n            pre = cur[:]\\n            cur[0] += 1\\n            for j in range(1, N + 1):\\n                a = int(s[i - 1] != t[j - 1]) + pre[j - 1]\\n                b = 1 + pre[j]\\n                c = 1 + cur[j - 1]\\n                cur[j] = min(a, b, c)\\n        return cur[N]\\n```\n```\\nclass Solution {\\npublic:\\n    using fun = function<int(int, int)>;\\n    int minDistance(string s, string t) {\\n        int M = s.size(),\\n            N = t.size();\\n        fun go = [&](auto i, auto j) {\\n            if (i == M || j == N)\\n                return M - i + N - j;\\n            auto a = int(s[i] != t[j]) + go(i + 1, j + 1),\\n                 b = 1 + go(i + 1, j),\\n                 c = 1 + go(i, j + 1);\\n            return min({ a, b, c });\\n        };\\n        return go(0, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using fun = function<int(int, int)>;\\n    using Map = unordered_map<string, int>;\\n    int minDistance(string s, string t, Map m = {}) {\\n        int M = s.size(),\\n            N = t.size();\\n        auto key = [](auto i, auto j) {\\n            stringstream ss; ss << i << \",\" << j;\\n            return ss.str();\\n        };\\n        fun go = [&](auto i, auto j) {\\n            if (i == M || j == N)\\n                return M - i + N - j;\\n            auto k = key(i, j);\\n            if (m.find(k) == m.end()) {\\n                auto a = int(s[i] != t[j]) + go(i + 1, j + 1),\\n                     b = 1 + go(i + 1, j),\\n                     c = 1 + go(i, j + 1);\\n                m[k] = min({ a, b, c });\\n            }\\n            return m[k];\\n        };\\n        return go(0, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int minDistance(string s, string t) {\\n        int M = s.size(),\\n            N = t.size();\\n        VVI dp(M + 1, VI(N + 1));\\n        for (auto i{ 1 }; i <= M; ++i) dp[i][0] = 1 + dp[i - 1][0];\\n        for (auto j{ 1 }; j <= N; ++j) dp[0][j] = 1 + dp[0][j - 1];\\n        for (auto i{ 1 }; i <= M; ++i) {\\n            for (auto j{ 1 }; j <= N; ++j) {\\n                auto a = int(s[i - 1] != t[j - 1]) + dp[i - 1][j - 1],\\n                     b = 1 + dp[i - 1][j],\\n                     c = 1 + dp[i][j - 1];\\n                dp[i][j] = min({ a, b, c });\\n            }\\n        }\\n        return dp[M][N];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int minDistance(string s, string t) {\\n        int M = s.size(),\\n            N = t.size();\\n        VI cur(N + 1);\\n        for (auto j{ 1 }; j <= N; ++j) cur[j] = 1 + cur[j - 1];\\n        for (auto i{ 1 }; i <= M; ++i) {\\n            auto pre{ cur };\\n            ++cur[0];\\n            for (auto j{ 1 }; j <= N; ++j) {\\n                auto a = int(s[i - 1] != t[j - 1]) + pre[j - 1],\\n                     b = 1 + pre[j],\\n                     c = 1 + cur[j - 1];\\n                cur[j] = min({ a, b, c });\\n            }\\n        }\\n        return cur[N];\\n    }\\n};\\n```\n```\\nA = ...x\\nB = ...x\\n```\n```\\nA = ...x\\nB = ...y\\n```\n```\\nA = ...y\\nB = ...y\\n```\n```\\nA = ...x\\nB = ...x\\n```\n```\\nA = xy\\nB = xyz\\n```\n```\\nA = xyz\\nB = xyz\\n```\n```\\nA = xy\\nB = xy\\n```\n```\\nA = xyz\\nB = xy\\n```\n```\\nA = xyz\\nB = xyz\\n```\n```\\nA = xy\\nB = xy\\n```\n```\\nlet minDistance = (A, B) => {\\n    let go = (A, B, i, j) => {\\n        if (!i || !j)\\n            return i + j; // \\uD83D\\uDED1 base case: we have exhausted A or B, return \"leftover\" distance\\n        return Math.min(\\n            go(A, B, i - 1, j - 1) + Number(A[i - 1] != B[j - 1]), // \\u2705 match xor \\u274C mismatch\\n            go(A, B, i - 1, j) + 1, // \\u274C insertion\\n            go(A, B, i, j - 1) + 1  // \\u274C deletion\\n        );\\n    };\\n    return go(A, B, A.length, B.length);\\n};\\n```\n```\\nlet minDistance = (A, B) => {\\n    let go = (A, B, i, j, memo = {}) => {\\n        let key = `${i},${j}`; // \\uD83D\\uDD11 \\n        if (memo[key])\\n            return memo[key]; // \\uD83E\\uDD14 memo\\n        if (!i || !j)\\n            return memo[key] = i + j; // \\uD83D\\uDED1 base case: we have exhausted A or B, return \"leftover\" distance\\n        return memo[key] = Math.min(\\n            go(A, B, i - 1, j - 1, memo) + Number(A[i - 1] != B[j - 1]), // \\u2705 match xor \\u274C mismatch\\n            go(A, B, i - 1, j, memo) + 1, // \\u274C insertion \\n            go(A, B, i, j - 1, memo) + 1  // \\u274C deletion\\n        );\\n    };\\n    return go(A, B, A.length, B.length);\\n};\\n```\n```\\nlet minDistance = (A, B) => {\\n    let [M, N] = [A.length, B.length];\\n    let dp = [...Array(M + 1)].map(row => Array(N + 1).fill(0)); // \\uD83E\\uDD14 memo\\n    for (let i = 0; i <= M; ++i) dp[i][0] = i; // \\uD83D\\uDED1 base case: we have exhausted B, return \"leftover\" distance\\n    for (let j = 0; j <= N; ++j) dp[0][j] = j; // \\uD83D\\uDED1 base case: we have exhausted A, return \"leftover\" distance\\n    for (let i = 1; i <= M; ++i)\\n        for (let j = 1; j <= N; ++j)\\n            dp[i][j] = Math.min(\\n                dp[i - 1][j - 1] + Number(A[i - 1] != B[j - 1]), // \\u2705 match xor \\u274C mismatch\\n                dp[i - 1][j] + 1, // \\u274C insertion \\n                dp[i][j - 1] + 1, // \\u274C deletion\\n            );\\n    return dp[M][N];\\n};\\n```\n```\\nlet minDistance = (A, B) => {\\n    let [M, N] = [A.length, B.length];\\n    let pre = [...Array(N + 1)].map((_, i) => i); // \\uD83E\\uDD14 memo \\uD83D\\uDED1 base case: we have exhausted A or B, return \"leftover\" distance\\n    for (let i = 1; i <= M; ++i) {\\n        let cur = [...pre]; // \\uD83E\\uDD14 generate current from previous\\n        cur[0] = i; // \\uD83D\\uDED1 base case: we have exhausted A or B, return \"leftover\" distance\\n        for (let j = 1; j <= N; ++j) {\\n            cur[j] = Math.min(\\n                pre[j - 1] + Number(A[i - 1] != B[j - 1]), // \\u2705 match xor \\u274C mismatch\\n                pre[j] + 1,     // \\u274C insertion \\n                cur[j - 1] + 1, // \\u274C deletion\\n            );\\n        }\\n        [pre, cur] = [cur, pre]; // swap\\n    }\\n    return pre[N];\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minDistance(string A, string B) {\\n        return go(A, B, A.size(), B.size());\\n    }\\nprivate:\\n    int go(string& A, string& B, int i, int j) {\\n        if (!i || !j)\\n            return i + j; // \\uD83D\\uDED1 base case: we have exhausted A or B, return \"leftover\" distance\\n        return min({\\n            go(A, B, i - 1, j - 1) + int(A[i - 1] != B[j - 1]), // \\u2705 match xor \\u274C mismatch\\n            go(A, B, i - 1, j) + 1, // \\u274C insertion\\n            go(A, B, i, j - 1) + 1  // \\u274C deletion\\n        });\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minDistance(string A, string B) {\\n        return go(A, B, A.size(), B.size());\\n    }\\nprivate:\\n    using Memo = unordered_map<string, int>;\\n    int go(string& A, string& B, int i, int j, Memo&& memo = {}) {\\n        stringstream ss; ss << i << \",\" << j;\\n        auto key = ss.str(); // \\uD83D\\uDD11\\n        if (memo.find(key) != memo.end())\\n            return memo[key]; // \\uD83E\\uDD14 memo\\n        if (!i || !j)\\n            return memo[key] = i + j;\\n        return memo[key] = min({\\n            go(A, B, i - 1, j - 1, move(memo)) + int(A[i - 1] != B[j - 1]), // \\u2705 match xor \\u274C mismatch\\n            go(A, B, i - 1, j, move(memo)) + 1, // \\u274C insertion\\n            go(A, B, i, j - 1, move(memo)) + 1  // \\u274C deletion\\n        });\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int minDistance(string A, string B) {\\n        auto [M, N] = make_tuple(A.size(), B.size());\\n        VVI dp(M + 1, VI(N + 1)); // \\uD83E\\uDD14 memo\\n        for (auto i = 0; i <= M; ++i) dp[i][0] = i; // \\uD83D\\uDED1 base case: we have exhausted B, return \"leftover\" distance\\n        for (auto j = 0; j <= N; ++j) dp[0][j] = j; // \\uD83D\\uDED1 base case: we have exhausted A, return \"leftover\" distance\\n        for (auto i = 1; i <= M; ++i)\\n            for (auto j = 1; j <= N; ++j)\\n                dp[i][j] = min({\\n                    dp[i - 1][j - 1] + int(A[i - 1] != B[j - 1]), // \\u2705 match xor \\u274C mismatch\\n                    dp[i - 1][j] + 1, // \\u274C insertion \\n                    dp[i][j - 1] + 1, // \\u274C deletion\\n                });\\n        return dp[M][N];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int minDistance(string A, string B) {\\n        auto [M, N] = make_tuple(A.size(), B.size());\\n        VI pre(N + 1); // \\uD83E\\uDD14 memo\\n        iota(pre.begin(), pre.end(), 0); // \\uD83D\\uDED1 base case: we have exhausted A or B, i is the \"leftover\" distance\\n        for (auto i = 1; i <= M; ++i) {\\n            auto cur{ pre }; // \\uD83E\\uDD14 generate current from previous\\n            cur[0] = i; // \\uD83D\\uDED1 base case: we have exhausted A or B, i is the \"leftover\" distance\\n            for (auto j = 1; j <= N; ++j) {\\n                cur[j] = min({\\n                    pre[j - 1] + int(A[i - 1] != B[j - 1]), // \\u2705 match xor \\u274C mismatch\\n                    pre[j] + 1,     // \\u274C insertion \\n                    cur[j - 1] + 1, // \\u274C deletion\\n                });\\n            }\\n            swap(pre, cur);\\n        }\\n        return pre[N];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 151449,
                "title": "python-dp-solution",
                "content": "```\\ndef minDistance(self, word1, word2):\\n        \"\"\"\\n        :type word1: str\\n        :type word2: str\\n        :rtype: int\\n        \"\"\"\\n        m = len(word1)\\n        n = len(word2)\\n        dp = [[0 for i in range(n+1)] for j in range(m+1)]\\n        for i in range(m+1):\\n            for j in range(n+1):\\n                if i== 0:\\n                    dp[i][j] = j\\n                elif j == 0:\\n                    dp[i][j] = i\\n                elif word1[i-1] == word2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = 1 + min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1])\\n        return dp[m][n]   \\n```",
                "solutionTags": [],
                "code": "```\\ndef minDistance(self, word1, word2):\\n        \"\"\"\\n        :type word1: str\\n        :type word2: str\\n        :rtype: int\\n        \"\"\"\\n        m = len(word1)\\n        n = len(word2)\\n        dp = [[0 for i in range(n+1)] for j in range(m+1)]\\n        for i in range(m+1):\\n            for j in range(n+1):\\n                if i== 0:\\n                    dp[i][j] = j\\n                elif j == 0:\\n                    dp[i][j] = i\\n                elif word1[i-1] == word2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = 1 + min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1])\\n        return dp[m][n]   \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 133086,
                "title": "from-brute-force-to-dp",
                "content": "### Brute Force\\n```\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        return minDistanceFrom(word1, word2, 0, 0);\\n    }\\n    private int minDistanceFrom(String s1, String s2, int i1, int i2) {\\n        if (i1 == s1.length()) // Inserts all the remaining characters of s2\\n            return s2.length() - i2;\\n\\n        if (i2 == s2.length()) // Deletes all the remaining characters of s1\\n            return s1.length() - i1;\\n\\n        if (s1.charAt(i1) == s2.charAt(i2)) {\\n            return minDistanceFrom(s1, s2, i1 + 1, i2 + 1);\\n        } else {\\n            int dist1 = 1 + minDistanceFrom(s1, s2, i1 + 1, i2); // Deletes s1[i1] from s1\\n            int dist2 = 1 + minDistanceFrom(s1, s2, i1, i2 + 1); // Inserts s2[i2] to s1\\n            int dist3 = 1 + minDistanceFrom(s1, s2, i1 + 1, i2 + 1); // Replaces s1[i1] with s2[i2]\\n\\n            return Math.min(dist1, Math.min(dist2, dist3));\\n        }\\n    }\\n}\\n```\\n### Top-down DP\\nA two-dimensional array might be used to store results of all subproblems, in order to overcome overlapping subproblems.\\n```\\nclass Solution {\\n    private Integer[][] dp;\\n    public int minDistance(String word1, String word2) {\\n        dp = new Integer[word1.length() + 1][word2.length() + 1];\\n        return minDistanceFrom(word1, word2, 0, 0);\\n    }\\n    private int minDistanceFrom(String s1, String s2, int i1, int i2) {\\n        if (i1 == s1.length()) // Inserts all the remaining characters of s2\\n            return s2.length() - i2;\\n\\n        if (i2 == s2.length()) // Deletes all the remaining characters of s1\\n            return s1.length() - i1;\\n        \\n        if (dp[i1][i2] != null)\\n            return dp[i1][i2];\\n        \\n        if (s1.charAt(i1) == s2.charAt(i2)) {\\n            return dp[i1][i2] = minDistanceFrom(s1, s2, i1 + 1, i2 + 1);\\n        } else {\\n            int dist1 = 1 + minDistanceFrom(s1, s2, i1 + 1, i2); // Deletes s1[i1] from s1\\n            int dist2 = 1 + minDistanceFrom(s1, s2, i1, i2 + 1); // Inserts s2[i2] to s1\\n            int dist3 = 1 + minDistanceFrom(s1, s2, i1 + 1, i2 + 1); // Replaces s1[i1] with s2[i2]\\n\\n            return dp[i1][i2] = Math.min(dist1, Math.min(dist2, dist3));\\n        }\\n    }\\n}\\n```\\n### Bottom-up DP\\n```\\n    public int minDistance(String s1, String s2) {\\n        int[][] dp = new int[s1.length() + 1][s2.length() + 1];\\n\\n        for (int i1 = 0; i1 <= s1.length(); i1++)\\n            dp[i1][0] = i1;\\n\\n        for (int i2 = 0; i2 <= s2.length(); i2++)\\n            dp[0][i2] = i2;\\n\\n        for (int i1 = 1; i1 <= s1.length(); i1++) {\\n            for (int i2 = 1; i2 <= s2.length(); i2++) {\\n                if (s1.charAt(i1 - 1) == s2.charAt(i2 - 1)) {\\n                    dp[i1][i2] = dp[i1 - 1][i2 - 1];\\n                } else {\\n                    int dist1 = 1 + dp[i1 - 1][i2]; // Deletes s1[i1] from s1\\n                    int dist2 = 1 + dp[i1][i2 - 1]; // Inserts s2[i2] to s1\\n                    int dist3 = 1 + dp[i1 - 1][i2 - 1]; // Replaces s1[i1] with s2[i2]\\n                    \\n                    dp[i1][i2] = Math.min(dist1, Math.min(dist2, dist3));\\n                }\\n            }\\n        }\\n\\n        return dp[s1.length()][s2.length()];\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        return minDistanceFrom(word1, word2, 0, 0);\\n    }\\n    private int minDistanceFrom(String s1, String s2, int i1, int i2) {\\n        if (i1 == s1.length()) // Inserts all the remaining characters of s2\\n            return s2.length() - i2;\\n\\n        if (i2 == s2.length()) // Deletes all the remaining characters of s1\\n            return s1.length() - i1;\\n\\n        if (s1.charAt(i1) == s2.charAt(i2)) {\\n            return minDistanceFrom(s1, s2, i1 + 1, i2 + 1);\\n        } else {\\n            int dist1 = 1 + minDistanceFrom(s1, s2, i1 + 1, i2); // Deletes s1[i1] from s1\\n            int dist2 = 1 + minDistanceFrom(s1, s2, i1, i2 + 1); // Inserts s2[i2] to s1\\n            int dist3 = 1 + minDistanceFrom(s1, s2, i1 + 1, i2 + 1); // Replaces s1[i1] with s2[i2]\\n\\n            return Math.min(dist1, Math.min(dist2, dist3));\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private Integer[][] dp;\\n    public int minDistance(String word1, String word2) {\\n        dp = new Integer[word1.length() + 1][word2.length() + 1];\\n        return minDistanceFrom(word1, word2, 0, 0);\\n    }\\n    private int minDistanceFrom(String s1, String s2, int i1, int i2) {\\n        if (i1 == s1.length()) // Inserts all the remaining characters of s2\\n            return s2.length() - i2;\\n\\n        if (i2 == s2.length()) // Deletes all the remaining characters of s1\\n            return s1.length() - i1;\\n        \\n        if (dp[i1][i2] != null)\\n            return dp[i1][i2];\\n        \\n        if (s1.charAt(i1) == s2.charAt(i2)) {\\n            return dp[i1][i2] = minDistanceFrom(s1, s2, i1 + 1, i2 + 1);\\n        } else {\\n            int dist1 = 1 + minDistanceFrom(s1, s2, i1 + 1, i2); // Deletes s1[i1] from s1\\n            int dist2 = 1 + minDistanceFrom(s1, s2, i1, i2 + 1); // Inserts s2[i2] to s1\\n            int dist3 = 1 + minDistanceFrom(s1, s2, i1 + 1, i2 + 1); // Replaces s1[i1] with s2[i2]\\n\\n            return dp[i1][i2] = Math.min(dist1, Math.min(dist2, dist3));\\n        }\\n    }\\n}\\n```\n```\\n    public int minDistance(String s1, String s2) {\\n        int[][] dp = new int[s1.length() + 1][s2.length() + 1];\\n\\n        for (int i1 = 0; i1 <= s1.length(); i1++)\\n            dp[i1][0] = i1;\\n\\n        for (int i2 = 0; i2 <= s2.length(); i2++)\\n            dp[0][i2] = i2;\\n\\n        for (int i1 = 1; i1 <= s1.length(); i1++) {\\n            for (int i2 = 1; i2 <= s2.length(); i2++) {\\n                if (s1.charAt(i1 - 1) == s2.charAt(i2 - 1)) {\\n                    dp[i1][i2] = dp[i1 - 1][i2 - 1];\\n                } else {\\n                    int dist1 = 1 + dp[i1 - 1][i2]; // Deletes s1[i1] from s1\\n                    int dist2 = 1 + dp[i1][i2 - 1]; // Inserts s2[i2] to s1\\n                    int dist3 = 1 + dp[i1 - 1][i2 - 1]; // Replaces s1[i1] with s2[i2]\\n                    \\n                    dp[i1][i2] = Math.min(dist1, Math.min(dist2, dist3));\\n                }\\n            }\\n        }\\n\\n        return dp[s1.length()][s2.length()];\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25902,
                "title": "c-recursive-dfs-8ms",
                "content": "Scan from the start while backtracking and exploring insert, delete and replace options, of course only when characters mismatch. As you can see below, memoization helps to short-circuit numerous paths.\\nMore details at [link](https://msreekan.com/2016/08/13/edit-distance/)\\n![alt text](https://tekrants.files.wordpress.com/2016/08/editdistance.jpg)\\n\\n```\\nvoid ml(char* w1, int o1, int l1, char* w2, int o2, int l2,\\n        unsigned char *dp)\\n{\\n    int offst = o1 * (l2 + 1) + o2, od = (o1 + 1) * (l2 + 1) + o2;\\n    int oi = o1 * (l2 + 1) + o2 + 1, r = 0;\\n\\n    if (o1 == l1 || o2 == l2) // end of string, return remaining bytes\\n        dp[offst] = (o1 == l1) ? l2 - o2 : l1 - o1;\\n\\n    /* If the minimum distance for strings at [o1..l1] & [o2..l2] is\\n       not already calculated, then figure out the same */\\n    else if (dp[offst] == MAX_CHAR)\\n    {\\n        if (w1[o1] != w2[o2]) // unequal characters\\n        {\\n            ml(w1, o1 + 1, l1, w2, o2, l2, dp); // delete\\n            ml(w1, o1, l1, w2, o2 + 1, l2, dp); // insert\\n            r++;\\n        }\\n\\n        ml(w1, o1 + 1, l1, w2, o2 + 1, l2, dp); // replace/chars equal\\n        dp[offst] = (r > 0) ? (MIN_INT(dp[od + 1] + r, dp[od] + r,\\n                    dp[oi] + r)) : dp[od + 1]; // pick minimum\\n    }\\n}\\n\\nint minDistance(char *word1, char * word2)\\n{\\n    int l1 = strlen(word1), l2 = strlen(word2), md = 0;\\n    unsigned char *dp = malloc((l1 + 1) * (l2 + 1) * sizeof(unsigned char));\\n\\n    /* Validate */\\n    if (!dp) return 0;\\n\\n    /* Initialize buffer */\\n    memset(dp, MAX_CHAR, (l1 + 1) * (l2 + 1));\\n\\n    /* Get the minimum distance */\\n    ml(word1, 0, l1, word2, 0, l2, dp);\\n    md = dp[0];\\n    free(dp);\\n    return md;\\n}\\n```\\n\\nEDIT : Just posted more details at the blog [link](https://msreekan.com/2016/08/13/edit-distance/)",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nvoid ml(char* w1, int o1, int l1, char* w2, int o2, int l2,\\n        unsigned char *dp)\\n{\\n    int offst = o1 * (l2 + 1) + o2, od = (o1 + 1) * (l2 + 1) + o2;\\n    int oi = o1 * (l2 + 1) + o2 + 1, r = 0;\\n\\n    if (o1 == l1 || o2 == l2) // end of string, return remaining bytes\\n        dp[offst] = (o1 == l1) ? l2 - o2 : l1 - o1;\\n\\n    /* If the minimum distance for strings at [o1..l1] & [o2..l2] is\\n       not already calculated, then figure out the same */\\n    else if (dp[offst] == MAX_CHAR)\\n    {\\n        if (w1[o1] != w2[o2]) // unequal characters\\n        {\\n            ml(w1, o1 + 1, l1, w2, o2, l2, dp); // delete\\n            ml(w1, o1, l1, w2, o2 + 1, l2, dp); // insert\\n            r++;\\n        }\\n\\n        ml(w1, o1 + 1, l1, w2, o2 + 1, l2, dp); // replace/chars equal\\n        dp[offst] = (r > 0) ? (MIN_INT(dp[od + 1] + r, dp[od] + r,\\n                    dp[oi] + r)) : dp[od + 1]; // pick minimum\\n    }\\n}\\n\\nint minDistance(char *word1, char * word2)\\n{\\n    int l1 = strlen(word1), l2 = strlen(word2), md = 0;\\n    unsigned char *dp = malloc((l1 + 1) * (l2 + 1) * sizeof(unsigned char));\\n\\n    /* Validate */\\n    if (!dp) return 0;\\n\\n    /* Initialize buffer */\\n    memset(dp, MAX_CHAR, (l1 + 1) * (l2 + 1));\\n\\n    /* Get the minimum distance */\\n    ml(word1, 0, l1, word2, 0, l2, dp);\\n    md = dp[0];\\n    free(dp);\\n    return md;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3527933,
                "title": "dynamic-programming-logic-bottom-to-up",
                "content": "# Dynamic programming:\\n```\\nclass Solution:\\n    def minDistance(self, s: str, t: str) -> int:\\n        dp=[[0]*(len(t)+1) for i in range(len(s)+1)]\\n        for k in range(len(s)+1):\\n            dp[k][len(t)]=len(s)-k\\n        for k in range(len(t)+1):\\n            dp[len(s)][k]=len(t)-k\\n        for i in range(len(s)-1,-1,-1):\\n            for j in range(len(t)-1,-1,-1):\\n                if s[i]==t[j]:\\n                    dp[i][j]=dp[i+1][j+1]\\n                else:\\n                    dp[i][j]=1+min(dp[i+1][j+1],dp[i+1][j],dp[i][j+1])\\n        return dp[0][0]        \\t\\t\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minDistance(self, s: str, t: str) -> int:\\n        dp=[[0]*(len(t)+1) for i in range(len(s)+1)]\\n        for k in range(len(s)+1):\\n            dp[k][len(t)]=len(s)-k\\n        for k in range(len(t)+1):\\n            dp[len(s)][k]=len(t)-k\\n        for i in range(len(s)-1,-1,-1):\\n            for j in range(len(t)-1,-1,-1):\\n                if s[i]==t[j]:\\n                    dp[i][j]=dp[i+1][j+1]\\n                else:\\n                    dp[i][j]=1+min(dp[i+1][j+1],dp[i+1][j],dp[i][j+1])\\n        return dp[0][0]        \\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232410,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int n1 = word1.size();\\n        int n2 = word2.size(); \\n        vector<vector<int>> dp(n1, vector<int>(n2, -1));\\n        return helper(n1-1, n2-1, word1, word2, dp);\\n    }\\n\\n    int helper(int i, int j, string &s1, string &s2,vector<vector<int>> &dp){\\n        if(i < 0){\\n            return j+1;\\n        }\\n        if(j < 0){\\n            return i+1;\\n        }\\n        if(s1[i] ==  s2[j]){\\n            return dp[i][j] = helper(i-1, j-1, s1, s2, dp);\\n        }\\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n        int min1 = helper(i-1, j, s1, s2, dp);\\n        int min2 = helper(i, j-1, s1, s2, dp);\\n        int min3 = helper(i-1, j-1, s1, s2, dp);\\n        return dp[i][j] = 1 + min(min(min1, min2), min3);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int n1 = word1.size();\\n        int n2 = word2.size(); \\n        vector<vector<int>> dp(n1, vector<int>(n2, -1));\\n        return helper(n1-1, n2-1, word1, word2, dp);\\n    }\\n\\n    int helper(int i, int j, string &s1, string &s2,vector<vector<int>> &dp){\\n        if(i < 0){\\n            return j+1;\\n        }\\n        if(j < 0){\\n            return i+1;\\n        }\\n        if(s1[i] ==  s2[j]){\\n            return dp[i][j] = helper(i-1, j-1, s1, s2, dp);\\n        }\\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n        int min1 = helper(i-1, j, s1, s2, dp);\\n        int min2 = helper(i, j-1, s1, s2, dp);\\n        int min3 = helper(i-1, j-1, s1, s2, dp);\\n        return dp[i][j] = 1 + min(min(min1, min2), min3);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231996,
                "title": "c-bottom-top-dp-o-n-space",
                "content": "\\n# Code with O(nm) space\\n```\\npublic class Solution {\\n    public int MinDistance(string word1, string word2) {\\n        var m = word1.Length;\\n        var n = word2.Length;\\n        var dp = new int[m+1, n+1];\\n\\n        for(var i = 0; i <= m; i++)\\n        {\\n            dp[i, 0] = i;\\n        }\\n\\n        for(var j = 0; j <= n; j++)\\n        {\\n            dp[0, j] = j;    \\n        }\\n\\n        for(var i = 0; i < m; i++)\\n        {\\n            for(var j = 0; j < n; j++)\\n            {\\n                if(word1[i] == word2[j])\\n                {\\n                    dp[i+1, j+1] = Min(dp[i, j], dp[i, j+1] + 1, dp[i+1, j] + 1);\\n                }\\n                else\\n                {\\n                    dp[i+1, j+1] = Min(dp[i, j], dp[i, j+1], dp[i+1, j]) + 1;\\n                }\\n            }\\n        }\\n\\n        return dp[m, n];\\n\\n        int Min(params int[] arr)\\n        {\\n            return arr.Min();\\n        }\\n    }\\n}\\n```\\n\\n# Optimized Code with O(n) space\\n```\\npublic class Solution {\\n    public int MinDistance(string word1, string word2) {\\n        var m = word1.Length;\\n        var n = word2.Length;\\n        // var dp = new int[m+1, n+1];\\n        var prevRow = new int[n+1];\\n\\n        // for(var i = 0; i <= m; i++)\\n        // {\\n        //     dp[i, 0] = i;\\n        // }\\n\\n        for(var j = 0; j <= n; j++)\\n        {\\n            // dp[0, j] = j;    \\n            prevRow[j] = j;\\n        }\\n\\n        for(var i = 0; i < m; i++)\\n        {\\n            var curRow = new int[n+1];\\n            curRow[0] = i + 1;\\n\\n            for(var j = 0; j < n; j++)\\n            {\\n                if(word1[i] == word2[j])\\n                {\\n                    // dp[i+1, j+1] = Min(dp[i, j], dp[i, j+1] + 1, dp[i+1, j] + 1);\\n                    curRow[j+1] = Min(prevRow[j], prevRow[j+1] + 1, curRow[j] + 1);\\n                }\\n                else\\n                {\\n                    // dp[i+1, j+1] = Min(dp[i, j], dp[i, j+1], dp[i+1, j]) + 1;\\n                    curRow[j+1] = Min(prevRow[j], prevRow[j+1], curRow[j]) + 1;\\n                }\\n            }\\n            prevRow = curRow;\\n        }\\n\\n        // return dp[m, n];\\n        return prevRow[n];\\n\\n        int Min(params int[] arr)\\n        {\\n            return arr.Min();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinDistance(string word1, string word2) {\\n        var m = word1.Length;\\n        var n = word2.Length;\\n        var dp = new int[m+1, n+1];\\n\\n        for(var i = 0; i <= m; i++)\\n        {\\n            dp[i, 0] = i;\\n        }\\n\\n        for(var j = 0; j <= n; j++)\\n        {\\n            dp[0, j] = j;    \\n        }\\n\\n        for(var i = 0; i < m; i++)\\n        {\\n            for(var j = 0; j < n; j++)\\n            {\\n                if(word1[i] == word2[j])\\n                {\\n                    dp[i+1, j+1] = Min(dp[i, j], dp[i, j+1] + 1, dp[i+1, j] + 1);\\n                }\\n                else\\n                {\\n                    dp[i+1, j+1] = Min(dp[i, j], dp[i, j+1], dp[i+1, j]) + 1;\\n                }\\n            }\\n        }\\n\\n        return dp[m, n];\\n\\n        int Min(params int[] arr)\\n        {\\n            return arr.Min();\\n        }\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int MinDistance(string word1, string word2) {\\n        var m = word1.Length;\\n        var n = word2.Length;\\n        // var dp = new int[m+1, n+1];\\n        var prevRow = new int[n+1];\\n\\n        // for(var i = 0; i <= m; i++)\\n        // {\\n        //     dp[i, 0] = i;\\n        // }\\n\\n        for(var j = 0; j <= n; j++)\\n        {\\n            // dp[0, j] = j;    \\n            prevRow[j] = j;\\n        }\\n\\n        for(var i = 0; i < m; i++)\\n        {\\n            var curRow = new int[n+1];\\n            curRow[0] = i + 1;\\n\\n            for(var j = 0; j < n; j++)\\n            {\\n                if(word1[i] == word2[j])\\n                {\\n                    // dp[i+1, j+1] = Min(dp[i, j], dp[i, j+1] + 1, dp[i+1, j] + 1);\\n                    curRow[j+1] = Min(prevRow[j], prevRow[j+1] + 1, curRow[j] + 1);\\n                }\\n                else\\n                {\\n                    // dp[i+1, j+1] = Min(dp[i, j], dp[i, j+1], dp[i+1, j]) + 1;\\n                    curRow[j+1] = Min(prevRow[j], prevRow[j+1], curRow[j]) + 1;\\n                }\\n            }\\n            prevRow = curRow;\\n        }\\n\\n        // return dp[m, n];\\n        return prevRow[n];\\n\\n        int Min(params int[] arr)\\n        {\\n            return arr.Min();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231533,
                "title": "golang-dynamic-programming-with-explanation",
                "content": "# Intuition\\nWe will have to draw a table to help understand how DP works in this solution:\\n\\n||empty str|r|o|s|\\n|:-:|:-:|:-:|:-:|:-:|\\n|empty str|0|1|2|3|\\n|h|1|1|2|3|\\n|o|2|2|1|2|\\n|r|3|2|2|2|\\n|s|4|3|3|2|\\n|e|5|4|4|**3**|\\n\\nIn this table, the number in the cells stands for **the minimum operation times** needed to transform from `word1` to `word2`. Note we only care about the first `n` chars when we fill the `nth` row or cols!\\n\\nFor example, we only care about `hor` when we are dealing with `row \\'r\\'`.\\n\\nMore specifically:\\n1. In `row \\'h\\'`, `col \\'r\\'`, we only care about how to transform from \\'h\\' to \\'r\\'.\\n2. In `row \\'o\\'`, `col \\'r\\'`, we only care about how to transform from \\'ho\\' to \\'r\\'.\\n3.  In `row \\'r\\'`, `col \\'o\\'`, we only care about how to transform from \\'hor\\' to \\'ro\\'.\\n4. ... I believe you get the point! \\uD83D\\uDE0A\\n\\nWhat we will do is to find a way to quickly fill the table! The number in the bottom-right of the table will be our answer.\\n\\nWhen you mannually fill this table, I believe you can find some certain rules:\\n+ the number in the first col (i.e. `col \\'empty str\\'`) always equals to the **row index**. This is because we need to remove every char in `word2` to get a empty `word1`!\\n+ If the last char of `word2` is identical to the last char of `word1`, the operation number should be the same as `table[i-1][j-1]` (just imagine we are dealing with `table[i][j]`)! This is because **if the last char of the two words are the same, we need no more extra operation**!\\n+ If the last char of `word2` is different from the last char of `word1`, we will have to look at these 3 cells: `table[i][j - 1]`, `table[i - 1][j - 1]` and `table[i - 1][j]`. We will fill `table[i][j]` with the minimum number plus 1. This is because **we have to deal with this char difference (plus 1), and we will choose the optimal way to conduct the former transformation**!\\n\\n# Code\\n```\\nfunc minDistance(word1 string, word2 string) int {\\n    pre := make([]int, len(word2) + 1)\\n    cur := make([]int, len(word2) + 1)\\n    for i := 0; i < len(pre); i++ {\\n        pre[i] = i\\n    }\\n    for i := 1; i <= len(word1); i++ {\\n        cur[0] = i\\n        for j := 1; j < len(pre); j++ {\\n            if word1[i - 1] != word2[j - 1] {\\n                cur[j] = min(cur[j - 1], pre[j - 1], pre[j]) + 1\\n            } else {\\n                cur[j] = pre[j - 1]\\n            }\\n        }\\n        tmp := make([]int, len(cur))\\n        copy(tmp, cur)\\n        pre = tmp\\n    }\\n    return pre[len(word2)]\\n}\\n\\nfunc min(nums ...int) int {\\n    ans := nums[0]\\n    for _, v := range nums {\\n        if v < ans {\\n            ans = v\\n        }\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunc minDistance(word1 string, word2 string) int {\\n    pre := make([]int, len(word2) + 1)\\n    cur := make([]int, len(word2) + 1)\\n    for i := 0; i < len(pre); i++ {\\n        pre[i] = i\\n    }\\n    for i := 1; i <= len(word1); i++ {\\n        cur[0] = i\\n        for j := 1; j < len(pre); j++ {\\n            if word1[i - 1] != word2[j - 1] {\\n                cur[j] = min(cur[j - 1], pre[j - 1], pre[j]) + 1\\n            } else {\\n                cur[j] = pre[j - 1]\\n            }\\n        }\\n        tmp := make([]int, len(cur))\\n        copy(tmp, cur)\\n        pre = tmp\\n    }\\n    return pre[len(word2)]\\n}\\n\\nfunc min(nums ...int) int {\\n    ans := nums[0]\\n    for _, v := range nums {\\n        if v < ans {\\n            ans = v\\n        }\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3230623,
                "title": "daily-leetcode-solution-easy-c-solution",
                "content": "```\\n//Memoisation\\nclass Solution {\\npublic:\\n    int fun(int i,int j,string& word1,string& word2,vector<vector<int>> &dp)\\n    {\\n        if(j<0){\\n            return i+1;\\n        }\\n        if(i<0){\\n            return j+1;\\n        }\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        if(word1[i]==word2[j]){\\n            return dp[i][j]=fun(i-1,j-1,word1,word2,dp);\\n        }\\n        int ins=1+fun(i,j-1,word1,word2,dp);\\n        int del=1+fun(i-1,j,word1,word2,dp);\\n        int rep=1+fun(i-1,j-1,word1,word2,dp);\\n        return dp[i][j]=min(ins,min(del,rep));\\n    }\\n    int minDistance(string word1, string word2) {\\n        int m=word1.size();\\n        int n=word2.size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return fun(m-1,n-1,word1,word2,dp);\\n    }\\n};\\n```\\n```\\n//Tabulation\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m=word1.size();\\n        int n=word2.size();\\n        vector<vector<int>> dp(m+1,vector<int>(n+1,0));\\n        for(int j=0;j<=n;j++){\\n            dp[0][j]=j;\\n        }\\n        for(int i=0;i<=m;i++){\\n            dp[i][0]=i;\\n        }\\n        for(int i=1;i<=m;i++)\\n        {\\n            for(int j=1;j<=n;j++){\\n                if(word1[i-1]==word2[j-1]){\\n                    dp[i][j]=dp[i-1][j-1];\\n                    continue;\\n                }\\n                int ins=1+dp[i][j-1];\\n                int del=1+dp[i-1][j];\\n                int rep=1+dp[i-1][j-1];\\n                dp[i][j]=min(ins,min(del,rep));        \\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n//Memoisation\\nclass Solution {\\npublic:\\n    int fun(int i,int j,string& word1,string& word2,vector<vector<int>> &dp)\\n    {\\n        if(j<0){\\n            return i+1;\\n        }\\n        if(i<0){\\n            return j+1;\\n        }\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        if(word1[i]==word2[j]){\\n            return dp[i][j]=fun(i-1,j-1,word1,word2,dp);\\n        }\\n        int ins=1+fun(i,j-1,word1,word2,dp);\\n        int del=1+fun(i-1,j,word1,word2,dp);\\n        int rep=1+fun(i-1,j-1,word1,word2,dp);\\n        return dp[i][j]=min(ins,min(del,rep));\\n    }\\n    int minDistance(string word1, string word2) {\\n        int m=word1.size();\\n        int n=word2.size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return fun(m-1,n-1,word1,word2,dp);\\n    }\\n};\\n```\n```\\n//Tabulation\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m=word1.size();\\n        int n=word2.size();\\n        vector<vector<int>> dp(m+1,vector<int>(n+1,0));\\n        for(int j=0;j<=n;j++){\\n            dp[0][j]=j;\\n        }\\n        for(int i=0;i<=m;i++){\\n            dp[i][0]=i;\\n        }\\n        for(int i=1;i<=m;i++)\\n        {\\n            for(int j=1;j<=n;j++){\\n                if(word1[i-1]==word2[j-1]){\\n                    dp[i][j]=dp[i-1][j-1];\\n                    continue;\\n                }\\n                int ins=1+dp[i][j-1];\\n                int del=1+dp[i-1][j];\\n                int rep=1+dp[i-1][j-1];\\n                dp[i][j]=min(ins,min(del,rep));        \\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3063353,
                "title": "optimized-c-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor each index in string S1, there are three options for matching that index with string S2. Replace a character, delete a character, or insert a character at its index. So you can think in terms of string match paths. With no consistent data, there\\'s no way to find out other than trying all possible methods. To do this, you have to use recursion.\\n\\n**Step 1: Index the problem**:\\n\\n>  We need two indices for iterating over both the strings.\\n\\n\\n**Step 2: Try all possible options given the index.**\\n\\n> We have the cases of MATCH and MISMATCH\\n\\n1. MATCH: If the i and the j characters of word1 and word2 match, then we must reduce both the indices and calculate the solution for f(i-1,j-1)\\n2. MISMATCH : If the i and the j characters of word1 and word2 mismatch, then we  have three possiblities: \\n      - **Insert**: We insert word2[j] in word1 at position i and thus call the function f(i, j-1).\\n      - **Delete**: We delete the word1[i] character and thus call the function f(i-1,j).\\n      - **Replace**: We simply replace the word1[i] with word2[j], thus we should call f(i-1,j-1).\\n\\n**Step 3: Return the minimum value of all choices.**\\n1. MATCH: return f(i-1,j-1)\\n2. MISMATCH: return 1 + min({f(i-1,j), f(i,j-1), f(i-1,j-1)})\\n\\n#### BASE CASES\\n\\n1. if i<0 then return j;\\n2. if j<0 then return i;\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can memoize the above recursive formula, but we will use Tabulation to avoid extra recursive stack space and Recursion Overhead.\\n\\n> In order to implement the Tabulation, we need to take care of the negative indices. Thus we shift ourselves to 1-based indexing.\\n\\nPROCEDURE:\\n\\n1. We initialise a 2D vector with the first col filled with the row numbers and the first row filled with row numbers.\\n2. Fill the matrix using the recursive formulation.\\n3. Return dp[n][m] as the answer.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string &word1, string &word2) {\\n        int n = word1.size(), m = word2.size();\\n        vector<vector<int>> dp(n+1,vector<int> (m+1,0));\\n        for(int row = 1;row<=n;row++)\\n            dp[row][0] = row;\\n        for(int col = 1;col<=m;col++)\\n            dp[0][col] = col;\\n        for(int i = 1;i<=n;i++){\\n            for(int j = 1;j<=m;j++){\\n                if(word1[i-1] == word2[j-1])\\n                    dp[i][j] = dp[i-1][j-1];\\n                else\\n                    dp[i][j] = 1 + min({dp[i-1][j], dp[i-1][j-1], dp[i][j-1]});\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string &word1, string &word2) {\\n        int n = word1.size(), m = word2.size();\\n        vector<vector<int>> dp(n+1,vector<int> (m+1,0));\\n        for(int row = 1;row<=n;row++)\\n            dp[row][0] = row;\\n        for(int col = 1;col<=m;col++)\\n            dp[0][col] = col;\\n        for(int i = 1;i<=n;i++){\\n            for(int j = 1;j<=m;j++){\\n                if(word1[i-1] == word2[j-1])\\n                    dp[i][j] = dp[i-1][j-1];\\n                else\\n                    dp[i][j] = 1 + min({dp[i-1][j], dp[i-1][j-1], dp[i][j-1]});\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2818044,
                "title": "java-dp-tabulation",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(m * n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m * n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        int m = word1.length();\\n        int n = word2.length();\\n\\n        int[][] dp = new int[m + 1][n + 1];\\n        int ans;\\n\\n        for(int i = 0; i <= m; i++){\\n            dp[i][0] = i;\\n        }\\n        for(int i = 0; i <= n; i++){\\n            dp[0][i] = i;\\n        }\\n\\n        for(int i = 1; i <= m; i++){\\n            for(int j = 1; j <= n; j++){\\n                ans = dp[i - 1][j - 1];\\n\\n                if(word1.charAt(m - i) != word2.charAt(n - j)){\\n                    ans = 1 + Math.min(ans, Math.min(dp[i][j - 1], dp[i - 1][j]));\\n                }\\n\\n                dp[i][j] = ans;\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        int m = word1.length();\\n        int n = word2.length();\\n\\n        int[][] dp = new int[m + 1][n + 1];\\n        int ans;\\n\\n        for(int i = 0; i <= m; i++){\\n            dp[i][0] = i;\\n        }\\n        for(int i = 0; i <= n; i++){\\n            dp[0][i] = i;\\n        }\\n\\n        for(int i = 1; i <= m; i++){\\n            for(int j = 1; j <= n; j++){\\n                ans = dp[i - 1][j - 1];\\n\\n                if(word1.charAt(m - i) != word2.charAt(n - j)){\\n                    ans = 1 + Math.min(ans, Math.min(dp[i][j - 1], dp[i - 1][j]));\\n                }\\n\\n                dp[i][j] = ans;\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2579271,
                "title": "c-most-detailed-from-recursive-to-space-optmisation",
                "content": "## Approach:\\n\\n--> Here we can follow string matching method where we will match every character using 2 variables `i and j where i will traverse s1 and j will traverse s2` and then we will have 2 conditions:\\n\\n1. If they are matching:\\n\\t- then we will simply decrease both i and j \\n\\t- we are not applying any step here\\n2. If they are not matching:\\n\\t- Then we have 3 possibilities here:\\n\\t\\t- Insert s[j] character at that place\\n\\t\\t- Delete this character and decrease i\\n\\t\\t- Replace ith character with s[j]\\n\\t\\t- we are applying any one of the step here so we will add 1 to total steps.\\n\\t\\t\\n--> Let\\'s see all these conditions in bit detail:\\n\\n### If they are not matching:\\n\\n**1. If we insert s[j] character at that place:**\\n\\nTake a look at this example:\\n\\n![image](https://assets.leetcode.com/users/images/92c6e07c-3694-4fa5-8efc-5bbb83e3243c_1663240869.4235468.png)\\n\\nHere we will just decrease `j` because we have added jth character so they are matched.\\n```cpp\\n1 + solve(i,j-1);\\n```\\n\\n**2. If we delete the ith character:**\\n\\nThen we will simply decrease `i`.\\n```cpp\\n1 + solve(i-1,j);\\n```\\n\\n**3. If we replace the ith character:**\\n\\nHere we will ofcourse replace the ith character with s[j] and then they both will match and we will decrease both `i and j`.\\n```cpp\\n1 + solve(i-1,j-1);\\n```\\n\\nAt last take the `minimum` of these 3 steps:\\n\\n### If they are matching:\\n\\njust decrease both i and j but don\\'t add 1 in steps because we haven\\'t performed any step here.\\n\\n```cpp\\nsolve(i-1,j-1);\\n```\\n\\n## Base case:\\n\\nHere we will have 2 conditions:\\n\\n1. If we have traversed all s1 string means i is negative and j is still have some value.\\n\\t- For example we have to make `ros` from `horse` and we have traversed whole horse string and j is at character `o` then we will have to make `ro` from empty string, so here we will perform `2 insert operations`.\\n\\t- so if i becomes negative then we will return `j+1`.\\n2. If we have traversed all s2 string means j is negative and i is still have some value.\\n\\t- For example in `ros and horse` we have traversed whole `ros` and i is at `r` character so that means we have to make empty string from `hor` so we will have to perform `3 deletion operation to make it empty string`. \\n\\t- So if j becomes negative then we will return `i+1`.\\n\\n```cpp\\nif(i < 0){\\n\\treturn j+1;\\n}\\nif(j < 0){\\n\\treturn i+1;\\n}\\n```\\n\\n## Recursive code:\\n\\n```cpp\\nint solve(int i,int j,string &s1,string &s2){\\n\\tif(i < 0){\\n\\t\\treturn j+1;\\n\\t}\\n\\tif(j < 0){\\n\\t\\treturn i+1;\\n\\t}\\n\\tif(s1[i] == s2[j]){\\n\\t\\treturn solve(i-1,j-1,s1,s2);\\n\\t}\\n\\telse{\\n\\t\\treturn 1 + min(min(solve(i,j-1,s1,s2),solve(i-1,j,s1,s2)), solve(i-1,j-1,s1,s2));\\n\\t}\\n}\\n```\\n\\n## Memoization Code:\\n\\n```cpp\\nint solve(int i,int j,string &s1,string &s2,vector<vector<int>>&dp){\\n\\tif(i < 0){\\n\\t\\treturn j+1;\\n\\t}\\n\\tif(j < 0){\\n\\t\\treturn i+1;\\n\\t}\\n\\tif(dp[i][j] != -1){\\n\\t\\treturn dp[i][j];\\n\\t}\\n\\tif(s1[i] == s2[j]){\\n\\t\\treturn dp[i][j] = solve(i-1,j-1,s1,s2,dp);\\n\\t}\\n\\telse{\\n\\t\\treturn dp[i][j] =  1 + min(min(solve(i,j-1,s1,s2,dp),solve(i-1,j,s1,s2,dp)), solve(i-1,j-1,s1,s2,dp));\\n\\t}\\n}\\nint main(){\\n\\t// n is size of s1 and m is size of s2\\n\\tvector<vector<int>>dp(n,vector<int>(m,-1));\\n\\treturn solve(n-1,m-1,s1,s2,dp);\\n}\\n```\\n\\n```\\nTime complexity: O(NxM)\\nSpace complexity: O(NxM) + stack space of O(N+M)\\n```\\n\\n## Tabulation Code:\\n\\n--> Let\\'s use tabulation to remove the stack space.\\n\\nSo in tabulation we just have to do one smaller change which will be `we will use 1 based indexing here` because in base case we are checking if i or j becomes negative but it\\'s not possible here so that\\'s why we will use 1 based indexing and our dp array size will be `N+1xM+1`\\n\\nAlso during checking the characters we will have to check like this:\\n```cpp\\nif(s1[i-1] == s2[j-1]);\\n```\\n\\nAlso in base case if `i` is 0 then we will add `j` for it instead of j+1 because we are following 1 based indexing and same for j also.\\n\\n```cpp\\nint minDistance(string s1, string s2) {\\n        int n = s1.size(),m = s2.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,0));\\n        // if j is 0\\n        for(int i=0;i<=n;i++){\\n            dp[i][0] = i;\\n        }\\n        // if i is 0\\n\\t\\t// starting from 1 because we have already considered dp[0][0] in above loop\\n        for(int j=1;j<=m;j++){\\n            dp[0][j] = j;\\n        }\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(s1[i-1] == s2[j-1]){\\n                    dp[i][j] = dp[i-1][j-1];\\n                }else{\\n                    dp[i][j] = 1 + min(min(dp[i][j-1],dp[i-1][j]),dp[i-1][j-1]);\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n```\\n\\n## Space optimisation:\\n\\n--> Here we can see that we are only required previous row(dp[i-1]) and current row (dp[i]) to find answer for current row.\\n\\nSo we will make 2 separate arrays `prev and curr` which will act as rows and after each inner iteration, we will swap them.\\n\\nNow here we can see for every `i=0` we have to put `0,1,2,3..` as j so we will initialise prev as `0,1,2,3...` and also for every `j=0` we have to put `0,1,2,3...` i.e every row\\'s first element will be current index so after each inner iteration we will do `curr[0] = i`.\\n\\nSo let\\'s optimise the space complexity:\\n\\n```cpp\\nint minDistance(string s1, string s2) {\\n\\tint n = s1.size(),m = s2.size();\\n\\tvector<int>prev(m+1,0),curr(m+1,0);\\n\\tfor(int j=1;j<=m;j++){\\n\\t\\tprev[j] = j;\\n\\t}\\n\\tfor(int i=1;i<=n;i++){\\n\\t// Initialising first element after each iteration\\n\\t\\tcurr[0] = i;\\n\\t\\tfor(int j=1;j<=m;j++){\\n\\t\\t\\tif(s1[i-1] == s2[j-1]){\\n\\t\\t\\t\\tcurr[j] = prev[j-1];\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tcurr[j] = 1 + min(min(curr[j-1],prev[j]),prev[j-1]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// swapping prev and curr\\n\\t\\tprev = curr;\\n\\t}\\n\\treturn prev[m];\\n}\\n```\\n\\n```\\nTime complexity: O(NxM)\\nSpace complexity: O(M)\\n```\\n\\n----\\n\\nIf you want to see more solutions like this find it [here](https://github.com/shivam1317/DSA-Notes)\\nThanks for reading.\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\n1 + solve(i,j-1);\\n```\n```cpp\\n1 + solve(i-1,j);\\n```\n```cpp\\n1 + solve(i-1,j-1);\\n```\n```cpp\\nsolve(i-1,j-1);\\n```\n```cpp\\nif(i < 0){\\n\\treturn j+1;\\n}\\nif(j < 0){\\n\\treturn i+1;\\n}\\n```\n```cpp\\nint solve(int i,int j,string &s1,string &s2){\\n\\tif(i < 0){\\n\\t\\treturn j+1;\\n\\t}\\n\\tif(j < 0){\\n\\t\\treturn i+1;\\n\\t}\\n\\tif(s1[i] == s2[j]){\\n\\t\\treturn solve(i-1,j-1,s1,s2);\\n\\t}\\n\\telse{\\n\\t\\treturn 1 + min(min(solve(i,j-1,s1,s2),solve(i-1,j,s1,s2)), solve(i-1,j-1,s1,s2));\\n\\t}\\n}\\n```\n```cpp\\nint solve(int i,int j,string &s1,string &s2,vector<vector<int>>&dp){\\n\\tif(i < 0){\\n\\t\\treturn j+1;\\n\\t}\\n\\tif(j < 0){\\n\\t\\treturn i+1;\\n\\t}\\n\\tif(dp[i][j] != -1){\\n\\t\\treturn dp[i][j];\\n\\t}\\n\\tif(s1[i] == s2[j]){\\n\\t\\treturn dp[i][j] = solve(i-1,j-1,s1,s2,dp);\\n\\t}\\n\\telse{\\n\\t\\treturn dp[i][j] =  1 + min(min(solve(i,j-1,s1,s2,dp),solve(i-1,j,s1,s2,dp)), solve(i-1,j-1,s1,s2,dp));\\n\\t}\\n}\\nint main(){\\n\\t// n is size of s1 and m is size of s2\\n\\tvector<vector<int>>dp(n,vector<int>(m,-1));\\n\\treturn solve(n-1,m-1,s1,s2,dp);\\n}\\n```\n```\\nTime complexity: O(NxM)\\nSpace complexity: O(NxM) + stack space of O(N+M)\\n```\n```cpp\\nif(s1[i-1] == s2[j-1]);\\n```\n```cpp\\nint minDistance(string s1, string s2) {\\n        int n = s1.size(),m = s2.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,0));\\n        // if j is 0\\n        for(int i=0;i<=n;i++){\\n            dp[i][0] = i;\\n        }\\n        // if i is 0\\n\\t\\t// starting from 1 because we have already considered dp[0][0] in above loop\\n        for(int j=1;j<=m;j++){\\n            dp[0][j] = j;\\n        }\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(s1[i-1] == s2[j-1]){\\n                    dp[i][j] = dp[i-1][j-1];\\n                }else{\\n                    dp[i][j] = 1 + min(min(dp[i][j-1],dp[i-1][j]),dp[i-1][j-1]);\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n```\n```cpp\\nint minDistance(string s1, string s2) {\\n\\tint n = s1.size(),m = s2.size();\\n\\tvector<int>prev(m+1,0),curr(m+1,0);\\n\\tfor(int j=1;j<=m;j++){\\n\\t\\tprev[j] = j;\\n\\t}\\n\\tfor(int i=1;i<=n;i++){\\n\\t// Initialising first element after each iteration\\n\\t\\tcurr[0] = i;\\n\\t\\tfor(int j=1;j<=m;j++){\\n\\t\\t\\tif(s1[i-1] == s2[j-1]){\\n\\t\\t\\t\\tcurr[j] = prev[j-1];\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tcurr[j] = 1 + min(min(curr[j-1],prev[j]),prev[j-1]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// swapping prev and curr\\n\\t\\tprev = curr;\\n\\t}\\n\\treturn prev[m];\\n}\\n```\n```\\nTime complexity: O(NxM)\\nSpace complexity: O(M)\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2268259,
                "title": "java-solution-memoization-tabulation-dp",
                "content": "Both Memoization And Tabulation solutions are given below, you can choose any.\\nIf you like the approach, then UPVOTE :) please\\n\\nMemoization Solution:\\ndist(s1 , s2 , i , j-1 , dp) => It implies insertion at end (I have not said replacing) hypothetically\\ndist(s1 , s2 , i-1 , j , dp) => It implies deletion\\ndist(s1 , s2 , i-1 , j-1 , dp) => It implies replacing\\n```\\nclass Solution {\\n    public int minDistance(String w1, String w2) {\\n        int l1 = w1.length();\\n        int l2 = w2.length();\\n        \\n        int[][] dp = new int[l1][l2];\\n        for(int i = 0 ; i < l1 ; i++)\\n            for(int j = 0 ; j < l2 ; j++)\\n                dp[i][j] = -1;\\n        return dist(w1 , w2 , l1-1, l2-1 , dp);    \\n    }\\n    \\n    public int dist(String s1, String s2 , int i , int j , int[][] dp){\\n        if(i < 0)   return j+1;\\n        if(j < 0) return i+1;\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        if(s1.charAt(i) == s2.charAt(j))    return dp[i][j] = dist(s1 , s2 , i-1 , j-1 , dp);\\n        \\n        return dp[i][j] = 1+Math.min(dist(s1 , s2 , i , j-1 , dp) , Math.min(dist(s1 , s2 , i-1 , j , dp) , dist(s1 , s2 , i-1 , j-1 , dp)));\\n    }\\n}\\n```\\n\\nTabulation Solution:\\n```\\nclass Solution {\\n    public int minDistance(String w1, String w2) {\\n        int l1 = w1.length();\\n        int l2 = w2.length();\\n        \\n        int[][] dp = new int[l1+1][l2+1];\\n        for(int i = 0 ; i <= l1 ; i++)\\n            dp[i][0] = i;\\n        \\n        for(int j = 0 ; j <= l2 ; j++)\\n            dp[0][j] = j;\\n        \\n        for(int i = 1 ; i <= l1 ; i++)\\n            for(int j = 1 ; j <= l2 ; j++){\\n                if(w1.charAt(i-1) == w2.charAt(j-1))   dp[i][j] = dp[i-1][j-1];\\n        \\n                else    dp[i][j] = 1 + Math.min(dp[i][j-1] , Math.min(dp[i-1][j] , dp[i-1][j-1]));\\n            }\\n        \\n        return dp[l1][l2];\\n    }\\n} \\n```\\nHaven\\'t UPVOTED yet, can do it now :)",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int minDistance(String w1, String w2) {\\n        int l1 = w1.length();\\n        int l2 = w2.length();\\n        \\n        int[][] dp = new int[l1][l2];\\n        for(int i = 0 ; i < l1 ; i++)\\n            for(int j = 0 ; j < l2 ; j++)\\n                dp[i][j] = -1;\\n        return dist(w1 , w2 , l1-1, l2-1 , dp);    \\n    }\\n    \\n    public int dist(String s1, String s2 , int i , int j , int[][] dp){\\n        if(i < 0)   return j+1;\\n        if(j < 0) return i+1;\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        if(s1.charAt(i) == s2.charAt(j))    return dp[i][j] = dist(s1 , s2 , i-1 , j-1 , dp);\\n        \\n        return dp[i][j] = 1+Math.min(dist(s1 , s2 , i , j-1 , dp) , Math.min(dist(s1 , s2 , i-1 , j , dp) , dist(s1 , s2 , i-1 , j-1 , dp)));\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minDistance(String w1, String w2) {\\n        int l1 = w1.length();\\n        int l2 = w2.length();\\n        \\n        int[][] dp = new int[l1+1][l2+1];\\n        for(int i = 0 ; i <= l1 ; i++)\\n            dp[i][0] = i;\\n        \\n        for(int j = 0 ; j <= l2 ; j++)\\n            dp[0][j] = j;\\n        \\n        for(int i = 1 ; i <= l1 ; i++)\\n            for(int j = 1 ; j <= l2 ; j++){\\n                if(w1.charAt(i-1) == w2.charAt(j-1))   dp[i][j] = dp[i-1][j-1];\\n        \\n                else    dp[i][j] = 1 + Math.min(dp[i][j-1] , Math.min(dp[i-1][j] , dp[i-1][j-1]));\\n            }\\n        \\n        return dp[l1][l2];\\n    }\\n} \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2180656,
                "title": "python3-solution-using-dp-top-down-approach",
                "content": "```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        dp = {}\\n        \\n        def getResult(i,j):\\n            if i == len(word1) and j == len(word2):\\n                return 0\\n            if i == len(word1):\\n                return len(word2) - j\\n            if j == len(word2):\\n                return len(word1) - i\\n\\n            if (i, j) not in dp:\\n                if word1[i] == word2[j]:\\n                    ans = getResult(i + 1, j + 1)\\n                else: \\n                    insert = 1 + getResult(i, j + 1)\\n                    delete = 1 + getResult(i + 1, j)\\n                    replace = 1 + getResult(i + 1, j + 1)\\n                    ans = min(insert, delete, replace)\\n                dp[(i, j)] = ans\\n            return dp[(i, j)]\\n        \\n        return getResult(0,0)\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        dp = {}\\n        \\n        def getResult(i,j):\\n            if i == len(word1) and j == len(word2):\\n                return 0\\n            if i == len(word1):\\n                return len(word2) - j\\n            if j == len(word2):\\n                return len(word1) - i\\n\\n            if (i, j) not in dp:\\n                if word1[i] == word2[j]:\\n                    ans = getResult(i + 1, j + 1)\\n                else: \\n                    insert = 1 + getResult(i, j + 1)\\n                    delete = 1 + getResult(i + 1, j)\\n                    replace = 1 + getResult(i + 1, j + 1)\\n                    ans = min(insert, delete, replace)\\n                dp[(i, j)] = ans\\n            return dp[(i, j)]\\n        \\n        return getResult(0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1204823,
                "title": "c-three-solutions-recursion-top-down-bottom-up-dp",
                "content": "**Recursive Solution\\nTime Complexity - O (3 ^ max(a, b))\\nSpace Complexity - O (1)**\\n\\n```\\nint minDist(string a, string b, int i, int j) {\\n        if (i == -1) {\\n            return j + 1;\\n        }\\n        if (j == -1) {\\n            return i + 1;\\n        }\\n        if (a[i] == b[j]) {\\n            return minDist(a, b, i - 1, j - 1);\\n        }\\n        else {\\n            int add = minDist(a, b, i, j - 1);\\n            int replace = minDist(a, b, i - 1, j - 1);\\n            int remove = minDist(a, b, i - 1, j);\\n            \\n            return 1 + min(min(add, replace), remove);\\n        }\\n    }\\n```\\n\\n<br>\\n<hr>\\n<br>\\n\\n**Top Down DP Solution**\\n\\n```\\nint minDist(string a, string b, int i, int j, vector <vector <int>> dp) {\\n        if (i == -1) {\\n            return j + 1;\\n        }\\n        if (j == -1) {\\n            return i + 1;\\n        }\\n        if (dp[i][j] != -1) {\\n            return dp[i][j];\\n        }\\n        if (a[i] == b[j]) {\\n            dp[i][j] =  minDist(a, b, i - 1, j - 1, dp);\\n            return dp[i][j];\\n        }\\n        else {\\n            int add = minDist(a, b, i, j - 1, dp);\\n            int replace = minDist(a, b, i - 1, j - 1, dp);\\n            int remove = minDist(a, b, i - 1, j, dp);\\n            \\n            dp[i][j] =  1 + min(min(add, replace), remove);\\n            return dp[i][j];\\n        }\\n    }\\n```\\n\\n<br>\\n<hr>\\n<br>\\n\\n**Bottom Up DP Solution\\nTime Complexity - O (a * b)\\nSpace Complexity - O (a * b)**\\n\\n```\\nint minDist(string a, string b) {\\n        vector <vector <int>> dp(a.length() + 1, vector <int>(b.length() + 1, -1));\\n        \\n        for (int i = 0; i < a.length() + 1; i++) {\\n            for (int j = 0; j < b.length() + 1; j++) {\\n                if (i == 0) {\\n                    dp[i][j] = j;\\n                }\\n                else if (j == 0) {\\n                    dp[i][j] = i;\\n                }\\n                else {\\n                    if (a[i - 1] == b[j - 1]) {\\n                        dp[i][j] = dp[i - 1][j - 1];\\n                    }\\n                    else {\\n                        int add = dp[i][j - 1];\\n                        int replace = dp[i- 1][j - 1];\\n                        int remove = dp[i - 1][j];\\n                        \\n                        dp[i][j] = 1 + min(min(add, replace), remove);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[a.length()][b.length()];\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint minDist(string a, string b, int i, int j) {\\n        if (i == -1) {\\n            return j + 1;\\n        }\\n        if (j == -1) {\\n            return i + 1;\\n        }\\n        if (a[i] == b[j]) {\\n            return minDist(a, b, i - 1, j - 1);\\n        }\\n        else {\\n            int add = minDist(a, b, i, j - 1);\\n            int replace = minDist(a, b, i - 1, j - 1);\\n            int remove = minDist(a, b, i - 1, j);\\n            \\n            return 1 + min(min(add, replace), remove);\\n        }\\n    }\\n```\n```\\nint minDist(string a, string b, int i, int j, vector <vector <int>> dp) {\\n        if (i == -1) {\\n            return j + 1;\\n        }\\n        if (j == -1) {\\n            return i + 1;\\n        }\\n        if (dp[i][j] != -1) {\\n            return dp[i][j];\\n        }\\n        if (a[i] == b[j]) {\\n            dp[i][j] =  minDist(a, b, i - 1, j - 1, dp);\\n            return dp[i][j];\\n        }\\n        else {\\n            int add = minDist(a, b, i, j - 1, dp);\\n            int replace = minDist(a, b, i - 1, j - 1, dp);\\n            int remove = minDist(a, b, i - 1, j, dp);\\n            \\n            dp[i][j] =  1 + min(min(add, replace), remove);\\n            return dp[i][j];\\n        }\\n    }\\n```\n```\\nint minDist(string a, string b) {\\n        vector <vector <int>> dp(a.length() + 1, vector <int>(b.length() + 1, -1));\\n        \\n        for (int i = 0; i < a.length() + 1; i++) {\\n            for (int j = 0; j < b.length() + 1; j++) {\\n                if (i == 0) {\\n                    dp[i][j] = j;\\n                }\\n                else if (j == 0) {\\n                    dp[i][j] = i;\\n                }\\n                else {\\n                    if (a[i - 1] == b[j - 1]) {\\n                        dp[i][j] = dp[i - 1][j - 1];\\n                    }\\n                    else {\\n                        int add = dp[i][j - 1];\\n                        int replace = dp[i- 1][j - 1];\\n                        int remove = dp[i - 1][j];\\n                        \\n                        dp[i][j] = 1 + min(min(add, replace), remove);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[a.length()][b.length()];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 776867,
                "title": "javascript-clean-recursive-dp",
                "content": "```javascript\\nvar minDistance = function(word1, word2) {\\n    const memo = new Map();\\n    \\n    function run(w1, w2) {\\n        if(memo.has(`${w1}-${w2}`)) return memo.get(`${w1}-${w2}`)\\n        if(w1 >= word1.length && w2 >= word2.length) return 0;\\n        \\n        // if it\\'s a match\\n        if(word1[w1] === word2[w2]) return run(w1+1, w2+1);\\n        \\n        let insert = Infinity, del = Infinity, replace = Infinity;\\n        \\n        // insert\\n        if(w2 < word2.length) insert = run(w1, w2+1);\\n        \\n        // delete\\n        if(w1 < word1.length) del = run(w1+1, w2);\\n        \\n        // replace\\n        if(w1 < word1.length && w2 < word2.length) replace = run(w1+1, w2+1);\\n        \\n        const res = Math.min(insert, del, replace) + 1;\\n        memo.set(`${w1}-${w2}`, res);\\n        return res;\\n    }\\n    return run(0, 0)\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```javascript\\nvar minDistance = function(word1, word2) {\\n    const memo = new Map();\\n    \\n    function run(w1, w2) {\\n        if(memo.has(`${w1}-${w2}`)) return memo.get(`${w1}-${w2}`)\\n        if(w1 >= word1.length && w2 >= word2.length) return 0;\\n        \\n        // if it\\'s a match\\n        if(word1[w1] === word2[w2]) return run(w1+1, w2+1);\\n        \\n        let insert = Infinity, del = Infinity, replace = Infinity;\\n        \\n        // insert\\n        if(w2 < word2.length) insert = run(w1, w2+1);\\n        \\n        // delete\\n        if(w1 < word1.length) del = run(w1+1, w2);\\n        \\n        // replace\\n        if(w1 < word1.length && w2 < word2.length) replace = run(w1+1, w2+1);\\n        \\n        const res = Math.min(insert, del, replace) + 1;\\n        memo.set(`${w1}-${w2}`, res);\\n        return res;\\n    }\\n    return run(0, 0)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 662438,
                "title": "recursion-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(int i, int j, string s1, string s2, vector<vector<int>> &dp)\\n    {\\n        if(i == s1.length() && j == s2.length()) return 0;\\n        if(i == s1.length()) return s2.length()-j;\\n        if(j == s2.length()) return s1.length()-i;\\n        int &ans = dp[i][j];\\n        if(ans != -1) return ans;\\n        ans = INT_MAX;\\n        if(s1[i] == s2[j])\\n        {\\n            ans = solve(i+1, j+1, s1, s2, dp);\\n        }\\n        else\\n        {\\n            ans = min(ans, solve(i, j+1, s1, s2, dp));\\n            ans = min(ans, solve(i+1, j+1, s1, s2, dp));\\n            ans = min(ans, solve(i+1, j, s1, s2, dp));\\n            ans = ans + 1;\\n        }\\n        return ans;\\n    }\\n    int minDistance(string s1, string s2) {\\n        vector<vector<int>> dp(1001, vector<int>(1001, -1));\\n        return solve(0, 0, s1, s2, dp);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i, int j, string s1, string s2, vector<vector<int>> &dp)\\n    {\\n        if(i == s1.length() && j == s2.length()) return 0;\\n        if(i == s1.length()) return s2.length()-j;\\n        if(j == s2.length()) return s1.length()-i;\\n        int &ans = dp[i][j];\\n        if(ans != -1) return ans;\\n        ans = INT_MAX;\\n        if(s1[i] == s2[j])\\n        {\\n            ans = solve(i+1, j+1, s1, s2, dp);\\n        }\\n        else\\n        {\\n            ans = min(ans, solve(i, j+1, s1, s2, dp));\\n            ans = min(ans, solve(i+1, j+1, s1, s2, dp));\\n            ans = min(ans, solve(i+1, j, s1, s2, dp));\\n            ans = ans + 1;\\n        }\\n        return ans;\\n    }\\n    int minDistance(string s1, string s2) {\\n        vector<vector<int>> dp(1001, vector<int>(1001, -1));\\n        return solve(0, 0, s1, s2, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 662428,
                "title": "rust-bottom-up-dp-with-explanations-o-m-n-time-o-n-space-0-ms-faster-than-100",
                "content": "#### Solution\\n\\n```rust\\nimpl Solution {\\n    pub fn min_distance(word1: String, word2: String) -> i32 {\\n        // Treat characters as raw bytes, as it allows us to directly access the underlying arrays:\\n        let (word1, word2) = (word1.as_bytes(), word2.as_bytes());\\n\\n        // Allocate memory in one-go, as it is typically faster:\\n        let mut dist = Vec::with_capacity(word2.len() + 1);\\n\\n        // Base case: we need to delete j characters in word2 in order to match the empty string word1:\\n        for j in 0..=word2.len() {\\n            dist.push(j)\\n        }\\n\\n        // Use a second vector to store distances for i - 1.\\n\\t\\t// This uses less memory than having a matrix of size (m, n), \\n\\t\\t// and we always just use the previous row in the matrix anyway:\\n        let mut prev_dist = dist.clone();\\n\\n        for i in 1..=word1.len() {\\n            for j in 0..=word2.len() {\\n                if j == 0 {\\n                    dist[j] += 1; // Base case: we need to insert a character in order to match word1.\\n                } else if word1[i - 1] == word2[j - 1] {\\n                    // No difference, don\\'t increment the edit distance:\\n                    dist[j] = prev_dist[j - 1];\\n                } else {\\n                    // Either insert, delete or replace a character: increment the edit distance by one:\\n                    dist[j] = dist[j].min(dist[j - 1]).min(prev_dist[j - 1]) + 1;\\n                }\\n            }\\n            prev_dist.copy_from_slice(&dist); // Backup the distances for this row using memcpy.\\n        }\\n        dist[word2.len()] as i32\\n    }\\n}\\n```\\n\\nThis algorithm gradually calculates the edit distance by iterating over the characters of the two provided words. `dist` and `prev_dist` represent two consecutive rows in the following distances matrix:\\n\\n<img src=\"https://assets.leetcode.com/users/marccarre/image_1590915262.png\" width=\"180px\" />\\n\\n#### Performance\\n\\n> Runtime: 0 ms, faster than 100.00% of Rust online submissions for Edit Distance.\\n> Memory Usage: 2.1 MB, less than 100.00% of Rust online submissions for Edit Distance.\\n",
                "solutionTags": [
                    "Rust",
                    "Dynamic Programming"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn min_distance(word1: String, word2: String) -> i32 {\\n        // Treat characters as raw bytes, as it allows us to directly access the underlying arrays:\\n        let (word1, word2) = (word1.as_bytes(), word2.as_bytes());\\n\\n        // Allocate memory in one-go, as it is typically faster:\\n        let mut dist = Vec::with_capacity(word2.len() + 1);\\n\\n        // Base case: we need to delete j characters in word2 in order to match the empty string word1:\\n        for j in 0..=word2.len() {\\n            dist.push(j)\\n        }\\n\\n        // Use a second vector to store distances for i - 1.\\n\\t\\t// This uses less memory than having a matrix of size (m, n), \\n\\t\\t// and we always just use the previous row in the matrix anyway:\\n        let mut prev_dist = dist.clone();\\n\\n        for i in 1..=word1.len() {\\n            for j in 0..=word2.len() {\\n                if j == 0 {\\n                    dist[j] += 1; // Base case: we need to insert a character in order to match word1.\\n                } else if word1[i - 1] == word2[j - 1] {\\n                    // No difference, don\\'t increment the edit distance:\\n                    dist[j] = prev_dist[j - 1];\\n                } else {\\n                    // Either insert, delete or replace a character: increment the edit distance by one:\\n                    dist[j] = dist[j].min(dist[j - 1]).min(prev_dist[j - 1]) + 1;\\n                }\\n            }\\n            prev_dist.copy_from_slice(&dist); // Backup the distances for this row using memcpy.\\n        }\\n        dist[word2.len()] as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 313925,
                "title": "swift-85-beat-using-dynamic-programming-solution-o-n-m-quadratic-speed-eazy-breezy",
                "content": "```\\nclass Solution {\\n    func minDistance(_ word1: String, _ word2: String) -> Int {\\n        \\n        if word1.count == 0 { return word2.count }\\n        if word2.count == 0 { return word1.count }\\n        \\n        var grid = [[Int]](repeating: [Int](repeating: 0, count: word2.count + 1), count: word1.count + 1)\\n        \\n        for x in 0...word1.count { grid[x][0] = x }\\n        for y in 0...word2.count { grid[0][y] = y }\\n        \\n        var word1 = Array(word1)\\n        var word2 = Array(word2)\\n        \\n        for x in 1...word1.count {\\n            for y in 1...word2.count {\\n                if word1[x - 1] == word2[y - 1] {\\n                    grid[x][y] = grid[x-1][y-1]\\n                } else {   \\n                    grid[x][y] = min(grid[x-1][y], min(grid[x-1][y-1], grid[x][y-1])) + 1\\n                }       \\n            }\\n        }\\n        return grid[word1.count][word2.count]\\n    }\\n}\\n```\\n\\nBoom, you\\'re on the payroll now. Winner winner, chicken dinner. I guess that\\'s why they call it the blues.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func minDistance(_ word1: String, _ word2: String) -> Int {\\n        \\n        if word1.count == 0 { return word2.count }\\n        if word2.count == 0 { return word1.count }\\n        \\n        var grid = [[Int]](repeating: [Int](repeating: 0, count: word2.count + 1), count: word1.count + 1)\\n        \\n        for x in 0...word1.count { grid[x][0] = x }\\n        for y in 0...word2.count { grid[0][y] = y }\\n        \\n        var word1 = Array(word1)\\n        var word2 = Array(word2)\\n        \\n        for x in 1...word1.count {\\n            for y in 1...word2.count {\\n                if word1[x - 1] == word2[y - 1] {\\n                    grid[x][y] = grid[x-1][y-1]\\n                } else {   \\n                    grid[x][y] = min(grid[x-1][y], min(grid[x-1][y-1], grid[x][y-1])) + 1\\n                }       \\n            }\\n        }\\n        return grid[word1.count][word2.count]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 261880,
                "title": "java-dp-solution-beats-99-81-on-runtime-bottonup-space-o-n",
                "content": "\\n__Recursive Approach__(TLE) : In this Approach for Word1 we have 3 Operations which are Insert, Delete or Replace.\\n\\nIf the First character of both of the Words are same then we need not to perform any of the Operation but if the Character is not same then we need to check which of the Operation among the insert, delete or replace will give the minimum answer.\\n\\nSo to find the minimum answer we need to check all of the 3 Possible Operations and then we will check among them which is minimum and then simply return the answer.\\n\\n**In Case the Character of both of the Word is Matching**\\nSimply Skip the similar character and hunt for the dissimilar One in the Word1.\\n\\n**In Case the Character we are Checking is not matching with the Character of Word1**\\n1. __Insert__ : In this Case we will Insert in Word1 the same Character as that of the Word2 so that we can make the Word1 to match Word2.\\n2. __Delete__ : In this Case we will Delete the Character from the Word1 as the character was not matching with the Word2.\\n3. __Replace__ : We will replace the dissimilar Character of the Word1 with Word2.\\n\\nNote : After calculating the Minimum of all of the Possible 3 Operations then we need to Add 1 to the answer as We have not included the cost of current Operation. \\nFor e.g.,\\nword1 = \"horse\"\\nword2 = \"ros\"\\n\\n```\\n                          (horse, ros)\\n// First Character of both the Words are Different then 3 Operations will be Performed\\n\\t\\t\\t      /             |            \\\\\\n\\t\\t     (Insert)        (Delete)       (Replace)\\n\\t\\t\\t   |                |                |\\n\\t\\t(rhorse, ros)       (orse,ros)       (rorse,ros) \\n// It is to be noted that the first Character of Word1 will surely become same as that of the Word2. In order to get minimun answer we need to perfrom such Operations Otherwise we will not get the Optimized answer.\\n               |                |                |  // We can directly write this stage in next Operations\\n          (horse, os)      (orse, ros)        (orse, os) \\n\\t\\t /     |     \\\\          .                  |  //Simply Skip the Character\\n(horse, s) (orse, ros) (orse, s).               (rse, s)\\n    .           .          .    .                   .\\n    .           .          .                        .\\n    .           .          .                        .\\n\\tSo on.\\n```\\n**Base Case** : Base Condition should be if any of the Word is consumed completely then we need to stop working as not we cannot check if the characters are same or not.\\n\\nIn the Base case, 3 Cases are Possible :\\n1. **Both of the Word are Consumed** : Then ans is zero as the empty Strings are also equal.\\n2. **Word1 is Consumed** : In this case Word2 is available and now our work is to convert the empty String into the Word1, So we need to perform Insertions Equal to length of the Word2. Hence we can return the Length of the Word2.\\n3.  **Word2 is Consumed** : In this case Word1 is available and now our work is to convert the this String into the Empty, So we need to perform deletions Equal to length of the Word1. Hence we can return the Length of the Word1.\\n\\nSo we will return Math.max(Word1.length(), Word1.length());\\n```\\npublic static int helper(String s1, String s2){\\n\\t\\tif(s1.length() == 0 || s2.length() == 0){ // If length any of the Length is Consumed completely\\n\\t\\t\\treturn Math.max(s1.length(), s2.length()); // Discussed Above\\n\\t\\t}\\n\\n\\t\\tif(s1.charAt(0) == s2.charAt(0)){ // If the Character matches\\n\\t\\t\\treturn helper(s1.substring(1),s2.substring(1)); // Skip both of the Characters\\n\\t\\t}else{\\n\\t\\t\\tint insert = helper(s1, s2.substring(1)); // In case of Insertion Consume the S2 character\\n\\t\\t\\tint delete = helper(s1.substring(1), s2); // In case of Deletion Consume the S1 character\\n\\t\\t\\tint replace = helper(s1.substring(1), s2.substring(1)); // In case of Replace Consume the characters from both of the Strings\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\treturn Math.min(insert, Math.min(delete, replace)) + 1; //Return the minimum Operations among the 3 Operations + 1.\\n\\t\\t}\\n\\t}\\n```\\n\\n**TopDown Approach** : This Approach is Similar as discussed Above but In this Approach we will create and Save the calculated answer in an Array called as Storage.\\n```\\npublic static int helperTD(String s1, String s2, int[][] strg){\\n\\t\\tif(s1.length() == 0 || s2.length() == 0){\\n\\t\\t\\treturn Math.max(s1.length(), s2.length());\\n\\t\\t}\\n\\t\\tint n = s1.length();\\n\\t\\tint m = s2.length();\\n\\t\\tif(strg[n][m] != 0){  //If we have Already Calculated the Answer\\n\\t\\t\\treturn strg[n][m]; // return the Saved Answer\\n\\t\\t}\\n\\t\\t\\n\\t\\tif(s1.charAt(0) == s2.charAt(0)){\\n\\t\\t\\tstrg[n][m] = helperTD(s1.substring(1),s2.substring(1), strg); // Saving Answer\\n\\t\\t\\treturn strg[n][m];\\n\\t\\t}else{\\n\\t\\t\\tint insert = helperTD(s1, s2.substring(1), strg);\\n\\t\\t\\tint delete = helperTD(s1.substring(1), s2, strg);\\n\\t\\t\\tint replace = helperTD(s1.substring(1), s2.substring(1), strg);\\n\\t\\t\\tstrg[n][m] = Math.min(insert, Math.min(delete, replace)) + 1; // Storing the calculated answer\\n\\t\\t\\treturn strg[n][m]; // return the Calculated Answer\\n\\t\\t}\\n\\t}\\n```\\n\\n**BottomUp Approach** : \\n```\\npublic static int helperBU(String s1, String s2){\\n\\t\\tint[][] strg = new int[s1.length() + 1][s2.length() + 1];\\n\\t\\tfor(int i = s1.length();i >= 0;i--){\\n\\t\\t\\tfor(int j = s2.length();j >= 0;j--){\\n\\t\\t\\t\\tif(i == s1.length()){\\n\\t\\t\\t\\t\\tstrg[i][j] = s2.length() - j;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(j == s2.length()){\\n\\t\\t\\t\\t\\tstrg[i][j] = s1.length() - i;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(s1.charAt(i) == s2.charAt(j)){\\n\\t\\t\\t\\t\\tstrg[i][j] = strg[i + 1][j + 1];\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tint insert = strg[i][j + 1];\\n\\t\\t\\t\\t\\tint delete = strg[i + 1][j];\\n\\t\\t\\t\\t\\tint replace = strg[i + 1][j + 1];\\n\\t\\t\\t\\t\\tstrg[i][j] = Math.min(insert, Math.min(delete, replace)) + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn strg[0][0];\\n\\t}\\n```\\n\\n**BottomUp Efficient(Beats 99.81 % on Runtime)**\\n\\n```\\npublic static int helperBU_Eff(String s1, String s2){\\n\\t\\tint[] strg = new int[s2.length() + 1];\\n\\t\\tfor(int i = s1.length();i >= 0;i--){\\n\\t\\t\\tint save = 0;\\n\\t\\t\\tfor(int j = s2.length();j >= 0;j--){\\n\\t\\t\\t\\tif(i == s1.length()){\\n\\t\\t\\t\\t\\tstrg[j] = s2.length() - j;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(j == s2.length()){\\n\\t\\t\\t\\t\\tsave = strg[j];\\n\\t\\t\\t\\t\\tstrg[j] = s1.length() - i;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(s1.charAt(i) == s2.charAt(j)){\\n\\t\\t\\t\\t\\tint temp = save;\\n\\t\\t\\t\\t\\tsave = strg[j];\\n\\t\\t\\t\\t\\tstrg[j] = temp;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tint insert = strg[j + 1];\\n\\t\\t\\t\\t\\tint delete = strg[j];\\n\\t\\t\\t\\t\\tint replace = save;\\n\\t\\t\\t\\t\\tsave = strg[j];\\n\\t\\t\\t\\t\\tstrg[j] = Math.min(insert, Math.min(delete, replace)) + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn strg[0];\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\n                          (horse, ros)\\n// First Character of both the Words are Different then 3 Operations will be Performed\\n\\t\\t\\t      /             |            \\\\\\n\\t\\t     (Insert)        (Delete)       (Replace)\\n\\t\\t\\t   |                |                |\\n\\t\\t(rhorse, ros)       (orse,ros)       (rorse,ros) \\n// It is to be noted that the first Character of Word1 will surely become same as that of the Word2. In order to get minimun answer we need to perfrom such Operations Otherwise we will not get the Optimized answer.\\n               |                |                |  // We can directly write this stage in next Operations\\n          (horse, os)      (orse, ros)        (orse, os) \\n\\t\\t /     |     \\\\          .                  |  //Simply Skip the Character\\n(horse, s) (orse, ros) (orse, s).               (rse, s)\\n    .           .          .    .                   .\\n    .           .          .                        .\\n    .           .          .                        .\\n\\tSo on.\\n```\n```\\npublic static int helper(String s1, String s2){\\n\\t\\tif(s1.length() == 0 || s2.length() == 0){ // If length any of the Length is Consumed completely\\n\\t\\t\\treturn Math.max(s1.length(), s2.length()); // Discussed Above\\n\\t\\t}\\n\\n\\t\\tif(s1.charAt(0) == s2.charAt(0)){ // If the Character matches\\n\\t\\t\\treturn helper(s1.substring(1),s2.substring(1)); // Skip both of the Characters\\n\\t\\t}else{\\n\\t\\t\\tint insert = helper(s1, s2.substring(1)); // In case of Insertion Consume the S2 character\\n\\t\\t\\tint delete = helper(s1.substring(1), s2); // In case of Deletion Consume the S1 character\\n\\t\\t\\tint replace = helper(s1.substring(1), s2.substring(1)); // In case of Replace Consume the characters from both of the Strings\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\treturn Math.min(insert, Math.min(delete, replace)) + 1; //Return the minimum Operations among the 3 Operations + 1.\\n\\t\\t}\\n\\t}\\n```\n```\\npublic static int helperTD(String s1, String s2, int[][] strg){\\n\\t\\tif(s1.length() == 0 || s2.length() == 0){\\n\\t\\t\\treturn Math.max(s1.length(), s2.length());\\n\\t\\t}\\n\\t\\tint n = s1.length();\\n\\t\\tint m = s2.length();\\n\\t\\tif(strg[n][m] != 0){  //If we have Already Calculated the Answer\\n\\t\\t\\treturn strg[n][m]; // return the Saved Answer\\n\\t\\t}\\n\\t\\t\\n\\t\\tif(s1.charAt(0) == s2.charAt(0)){\\n\\t\\t\\tstrg[n][m] = helperTD(s1.substring(1),s2.substring(1), strg); // Saving Answer\\n\\t\\t\\treturn strg[n][m];\\n\\t\\t}else{\\n\\t\\t\\tint insert = helperTD(s1, s2.substring(1), strg);\\n\\t\\t\\tint delete = helperTD(s1.substring(1), s2, strg);\\n\\t\\t\\tint replace = helperTD(s1.substring(1), s2.substring(1), strg);\\n\\t\\t\\tstrg[n][m] = Math.min(insert, Math.min(delete, replace)) + 1; // Storing the calculated answer\\n\\t\\t\\treturn strg[n][m]; // return the Calculated Answer\\n\\t\\t}\\n\\t}\\n```\n```\\npublic static int helperBU(String s1, String s2){\\n\\t\\tint[][] strg = new int[s1.length() + 1][s2.length() + 1];\\n\\t\\tfor(int i = s1.length();i >= 0;i--){\\n\\t\\t\\tfor(int j = s2.length();j >= 0;j--){\\n\\t\\t\\t\\tif(i == s1.length()){\\n\\t\\t\\t\\t\\tstrg[i][j] = s2.length() - j;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(j == s2.length()){\\n\\t\\t\\t\\t\\tstrg[i][j] = s1.length() - i;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(s1.charAt(i) == s2.charAt(j)){\\n\\t\\t\\t\\t\\tstrg[i][j] = strg[i + 1][j + 1];\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tint insert = strg[i][j + 1];\\n\\t\\t\\t\\t\\tint delete = strg[i + 1][j];\\n\\t\\t\\t\\t\\tint replace = strg[i + 1][j + 1];\\n\\t\\t\\t\\t\\tstrg[i][j] = Math.min(insert, Math.min(delete, replace)) + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn strg[0][0];\\n\\t}\\n```\n```\\npublic static int helperBU_Eff(String s1, String s2){\\n\\t\\tint[] strg = new int[s2.length() + 1];\\n\\t\\tfor(int i = s1.length();i >= 0;i--){\\n\\t\\t\\tint save = 0;\\n\\t\\t\\tfor(int j = s2.length();j >= 0;j--){\\n\\t\\t\\t\\tif(i == s1.length()){\\n\\t\\t\\t\\t\\tstrg[j] = s2.length() - j;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(j == s2.length()){\\n\\t\\t\\t\\t\\tsave = strg[j];\\n\\t\\t\\t\\t\\tstrg[j] = s1.length() - i;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(s1.charAt(i) == s2.charAt(j)){\\n\\t\\t\\t\\t\\tint temp = save;\\n\\t\\t\\t\\t\\tsave = strg[j];\\n\\t\\t\\t\\t\\tstrg[j] = temp;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tint insert = strg[j + 1];\\n\\t\\t\\t\\t\\tint delete = strg[j];\\n\\t\\t\\t\\t\\tint replace = save;\\n\\t\\t\\t\\t\\tsave = strg[j];\\n\\t\\t\\t\\t\\tstrg[j] = Math.min(insert, Math.min(delete, replace)) + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn strg[0];\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 25921,
                "title": "easy-understanding-java-solution-using-dp-with-memorization-beats-about-99-solutions",
                "content": "\\n    public int minDistance(String word1, String word2) {\\n        char[] w1 = word1.toCharArray(), w2 = word2.toCharArray();\\n        int[][] memo = new int[w1.length+1][w2.length+1];\\n        return minDistanceHelper(w1, w2, 0, 0, memo);\\n    }\\n    \\n    public int minDistanceHelper(char[] w1, char[] w2, int w1Index, int w2Index, int[][] memo) {\\n        if(w1Index == w1.length) return w2.length - w2Index;\\n        if(w2Index == w2.length) return w1.length - w1Index;\\n\\n        if(memo[w1Index][w2Index] != 0) return memo[w1Index][w2Index];\\n\\n        if(w1[w1Index] == w2[w2Index]) {\\n            memo[w1Index][w2Index] = minDistanceHelper(w1, w2, w1Index+1, w2Index+1, memo);\\n        } else {\\n            int opt1 = minDistanceHelper(w1, w2, w1Index+1, w2Index, memo);\\n            int opt2 = minDistanceHelper(w1, w2, w1Index, w2Index+1, memo);\\n            int opt3 = minDistanceHelper(w1, w2, w1Index+1, w2Index+1, memo);\\n            memo[w1Index][w2Index] = Math.min(opt1, Math.min(opt2, opt3)) + 1;\\n        }\\n        return memo[w1Index][w2Index];\\n    }",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "\\n    public int minDistance(String word1, String word2) {\\n        char[] w1 = word1.toCharArray(), w2 = word2.toCharArray();\\n        int[][] memo = new int[w1.length+1][w2.length+1];\\n        return minDistanceHelper(w1, w2, 0, 0, memo);\\n    }\\n    \\n    public int minDistanceHelper(char[] w1, char[] w2, int w1Index, int w2Index, int[][] memo) {\\n        if(w1Index == w1.length) return w2.length - w2Index;\\n        if(w2Index == w2.length) return w1.length - w1Index;\\n\\n        if(memo[w1Index][w2Index] != 0) return memo[w1Index][w2Index];\\n\\n        if(w1[w1Index] == w2[w2Index]) {\\n            memo[w1Index][w2Index] = minDistanceHelper(w1, w2, w1Index+1, w2Index+1, memo);\\n        } else {\\n            int opt1 = minDistanceHelper(w1, w2, w1Index+1, w2Index, memo);\\n            int opt2 = minDistanceHelper(w1, w2, w1Index, w2Index+1, memo);\\n            int opt3 = minDistanceHelper(w1, w2, w1Index+1, w2Index+1, memo);\\n            memo[w1Index][w2Index] = Math.min(opt1, Math.min(opt2, opt3)) + 1;\\n        }\\n        return memo[w1Index][w2Index];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 25939,
                "title": "ac-python-212-ms-dp-solution-o-mn-time-o-n-space",
                "content": "This is similar to the longest common subsequence problem. Dynamic programming is intuitive.\\n\\n    def minDistance(self, word1, word2):\\n        if len(word1) == 0 or len(word2) == 0:\\n            return max(len(word1), len(word2))\\n        dist = range(len(word2) + 1)\\n        for i in xrange(len(word1)):\\n            dist_ij, dist[0] = i, i + 1\\n            for j in xrange(len(word2)):\\n                if word1[i] == word2[j]:\\n                    dist_ij, dist[j + 1] = dist[j + 1], dist_ij\\n                else:\\n                    dist_ij, dist[j + 1] = dist[j + 1], min(dist[j], dist[j + 1], dist_ij) + 1\\n        return dist[-1]\\n\\n\\n    # 1146 / 1146 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 212 ms\\n    # 96.23%\\n\\n\\nThe relations of DP are\\n\\n    # keep the last char:      dist(i + 1, j + 1) = dist(i, j)\\n    # insert the last char:    dist(i + 1, j + 1) = dist(i + 1, j) + 1\\n    # replace the last char:   dist(i + 1, j + 1) = dist(i, j)     + 1\\n    # remove the last char:    dist(i + 1, j + 1) = dist(i, j + 1) + 1",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "This is similar to the longest common subsequence problem. Dynamic programming is intuitive.\\n\\n    def minDistance(self, word1, word2):\\n        if len(word1) == 0 or len(word2) == 0:\\n            return max(len(word1), len(word2))\\n        dist = range(len(word2) + 1)\\n        for i in xrange(len(word1)):\\n            dist_ij, dist[0] = i, i + 1\\n            for j in xrange(len(word2)):\\n                if word1[i] == word2[j]:\\n                    dist_ij, dist[j + 1] = dist[j + 1], dist_ij\\n                else:\\n                    dist_ij, dist[j + 1] = dist[j + 1], min(dist[j], dist[j + 1], dist_ij) + 1\\n        return dist[-1]\\n\\n\\n    # 1146 / 1146 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 212 ms\\n    # 96.23%\\n\\n\\nThe relations of DP are\\n\\n    # keep the last char:      dist(i + 1, j + 1) = dist(i, j)\\n    # insert the last char:    dist(i + 1, j + 1) = dist(i + 1, j) + 1\\n    # replace the last char:   dist(i + 1, j + 1) = dist(i, j)     + 1\\n    # remove the last char:    dist(i + 1, j + 1) = dist(i, j + 1) + 1",
                "codeTag": "Python3"
            },
            {
                "id": 25870,
                "title": "my-none-recursive-solution",
                "content": "Hello, I've finish this problem without recursion. Any comment on how i can improve on the code?   Thanks. \\nIs there a reason why people are doing recursive builds? (Space vs time?)\\n\\n\\n    public class Solution {\\n            public int minDistance(String word1, String word2) {\\n                int [][] result = new int[word1.length()+1][word2.length()+1];\\n                //set up deletion into null string;\\n                for(int i=0;i<=word1.length();i++) result[i][0]=i;\\n                for(int j=0;j<=word2.length();j++) result[0][j]=j;\\n                for(int i=1;i<=word1.length();i++)\\n                {\\n                    for(int j=1;j<=word2.length();j++)\\n                    {\\n                        int del = result[i-1][j] +1;\\n                        int ins = result[i][j-1] +1;\\n                        int rep = result[i-1][j-1];\\n                        if(word1.charAt(i-1)!=word2.charAt(j-1)) \\n                        {\\n                            rep+=1;\\n                        }\\n                        int min = Math.min(del,ins);\\n                        min = Math.min(min,rep);\\n                        result[i][j]=min;\\n                    }\\n                }\\n                return result[word1.length()][word2.length()];\\n            }\\n        }",
                "solutionTags": [],
                "code": "class Solution {\\n            public int minDistance(String word1, String word2) {\\n                int [][] result = new int[word1.length()+1][word2.length()+1];\\n                //set up deletion into null string;\\n                for(int i=0;i<=word1.length();i++) result[i][0]=i;\\n                for(int j=0;j<=word2.length();j++) result[0][j]=j;\\n                for(int i=1;i<=word1.length();i++)\\n                {\\n                    for(int j=1;j<=word2.length();j++)\\n                    {\\n                        int del = result[i-1][j] +1;\\n                        int ins = result[i][j-1] +1;\\n                        int rep = result[i-1][j-1];\\n                        if(word1.charAt(i-1)!=word2.charAt(j-1)) \\n                        {\\n                            rep+=1;\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 3817915,
                "title": "0-n-space-solution",
                "content": "# PLS UPVOTE MY SOLUTION IF YOPU LIKE AND COMMENT FOR ANY DISCUSSION\\n# Dynamic Programming (Tabulation) with Space Optimization:\\n# Approach\\nThe function spacopti is used to find the minimum edit distance using dynamic programming (tabulation) with space optimization.\\nIt initializes two vectors curr and next to store intermediate results during the computation.\\nThe next vector is pre-filled with values representing the minimum number of operations needed to transform the suffix of string b into an empty string (i.e., characters are deleted).\\nTabulation Loop:\\n\\nThe tabulation loop iterates over the indices of a and b from the end to the beginning.\\nIt computes the minimum edit distance for each pair of substrings a[i:] and b[j:], storing the result in the curr vector.\\nThe curr vector is updated iteratively as the loop progresses.\\nMatching Characters:\\n\\nIf the characters at a[i] and b[j] are the same, the function updates the ans variable with the value from next[j+1]. This represents the minimum edit distance for the remaining substrings a[i+1:] and b[j+1:].\\nMismatching Characters:\\n\\nIf the characters at a[i] and b[j] are different, the function calculates three possible operations (insertion, deletion, and replacement) and updates the ans variable with the minimum value among them.\\nSpace Optimization:\\n\\nInstead of using two separate vectors for curr and next, the function uses only curr for tabulation. The next vector is effectively replaced by curr in each iteration, updating the values accordingly.\\nOutput:\\n\\nThe minDistance function returns the result of the dynamic programming (tabulation) function spacopti(word1, word2), which represents the minimum number of operations required to transform word1 into word2.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# CODE\\n```\\nclass Solution {\\npublic:\\n\\nint spacopti(string& a, string& b)\\n{\\n    vector<int>curr(b.length()+11,0);\\n    vector<int>next(b.length()+111,0);\\n    for(int j =0;j<b.length();j++)\\n    {\\n        next[j]=b.length()-j;\\n    }\\n\\n\\n    for(int i=a.length();i>=0;i--)\\n    {\\n        for(int j = b.length();j>=0;j--)\\n        {\\n            int ans=0;\\n            curr[b.length()]=a.length()-i;\\n            if(a[i]==b[j])\\n            {\\n                ans= next[j+1];\\n            }\\n            else\\n            {\\n                int insert= 1 + curr[j+1];\\n                int deleteans= 1 + next[j];\\n                int replace= 1 + next[j+1];\\n                ans = min(insert , min(deleteans , replace));\\n            }\\n            curr[j]=ans;\\n        }\\n        next=curr;\\n    }\\n    return next[0];\\n}\\n\\n    int minDistance(string word1, string word2) {\\n        return spacopti(word1,word2);\\n\\n    }\\n};\\n```\\n# Recursive Function with Memoization:\\n# Approach\\n\\n\\nThe function solve is a recursive function that takes two strings a and b, along with two indices i and j, representing the current position in a and b.\\nThe function calculates the minimum distance (number of operations) required to transform the substring a[i:] into the substring b[j:].\\nThe function uses memoization to store the results of subproblems in a 2D dp array. The dp array is used to avoid redundant calculations for overlapping subproblems.\\nBase Cases:\\n\\nIf the index i reaches the end of string a, the remaining characters in b need to be inserted to match a, so the function returns b.length() - j.\\nIf the index j reaches the end of string b, the remaining characters in a need to be deleted to match b, so the function returns a.length() - i.\\nMemoization:\\n\\nThe function checks if the result for the current subproblem (i.e., solve(a, b, i, j, dp)) is already calculated and stored in the dp array. If so, it returns the stored result, avoiding redundant calculations.\\nMatching Characters:\\n\\nIf the characters at a[i] and b[j] are the same, no operation is required, so the function calls itself with i+1 and j+1.\\nMismatching Characters:\\n\\nIf the characters at a[i] and b[j] are different, the function considers three possible operations (insertion, deletion, and replacement) and calculates the minimum distance by recursively calling itself with different indices and adding one for the operation performed.\\nMain Function:\\n\\nThe minDistance function initializes the dp array with -1 and calls the recursive function solve with the two strings word1 and word2, along with initial indices 0 and 0.\\nOutput:\\n\\nThe minDistance function returns the minimum number of operations required to transform word1 into word2.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(N*N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint solve(string& a, string& b,int i,int j ,vector<vector<int>>& dp)\\n{\\n      int ans=0;\\n    if(a.length()==i)\\n    {\\n        return b.length()-j;\\n    }\\n    if(b.length()==j)\\n    {\\n        return a.length()-i;\\n    }\\n    if(dp[i][j]!=-1)\\n    {\\n        return dp[i][j];\\n    }\\n    if(a[i]==b[j])\\n    {\\n        return solve(a,b,i+1,j+1,dp);\\n    }\\n  \\n    else\\n    {\\n        int insert= 1 + solve(a,b,i,j+1,dp);\\n\\n        int deleteans= 1 + solve(a,b,i+1,j,dp);\\n\\n        int replace= 1 + solve(a,b,i+1,j+1,dp);\\n        ans = min(insert , min(deleteans , replace));\\n    }\\n    return dp[i][j]=ans;\\n\\n}\\n    int minDistance(string word1, string word2) {\\n        vector<vector<int>>dp(word1.length()+11,vector<int>(word2.length()+11,-1));\\n        return solve(word1,word2,0,0,dp);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nint spacopti(string& a, string& b)\\n{\\n    vector<int>curr(b.length()+11,0);\\n    vector<int>next(b.length()+111,0);\\n    for(int j =0;j<b.length();j++)\\n    {\\n        next[j]=b.length()-j;\\n    }\\n\\n\\n    for(int i=a.length();i>=0;i--)\\n    {\\n        for(int j = b.length();j>=0;j--)\\n        {\\n            int ans=0;\\n            curr[b.length()]=a.length()-i;\\n            if(a[i]==b[j])\\n            {\\n                ans= next[j+1];\\n            }\\n            else\\n            {\\n                int insert= 1 + curr[j+1];\\n                int deleteans= 1 + next[j];\\n                int replace= 1 + next[j+1];\\n                ans = min(insert , min(deleteans , replace));\\n            }\\n            curr[j]=ans;\\n        }\\n        next=curr;\\n    }\\n    return next[0];\\n}\\n\\n    int minDistance(string word1, string word2) {\\n        return spacopti(word1,word2);\\n\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\nint solve(string& a, string& b,int i,int j ,vector<vector<int>>& dp)\\n{\\n      int ans=0;\\n    if(a.length()==i)\\n    {\\n        return b.length()-j;\\n    }\\n    if(b.length()==j)\\n    {\\n        return a.length()-i;\\n    }\\n    if(dp[i][j]!=-1)\\n    {\\n        return dp[i][j];\\n    }\\n    if(a[i]==b[j])\\n    {\\n        return solve(a,b,i+1,j+1,dp);\\n    }\\n  \\n    else\\n    {\\n        int insert= 1 + solve(a,b,i,j+1,dp);\\n\\n        int deleteans= 1 + solve(a,b,i+1,j,dp);\\n\\n        int replace= 1 + solve(a,b,i+1,j+1,dp);\\n        ans = min(insert , min(deleteans , replace));\\n    }\\n    return dp[i][j]=ans;\\n\\n}\\n    int minDistance(string word1, string word2) {\\n        vector<vector<int>>dp(word1.length()+11,vector<int>(word2.length()+11,-1));\\n        return solve(word1,word2,0,0,dp);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592016,
                "title": "dp-c-memoization",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\nint solve(int i,int j,int &n,int &m,string &a,string &b,vector<vector<int>> &dp){\\n    if(i==n)return m-j;\\n    if(j==m)return n-i;\\n    if(dp[i][j] != -1)return dp[i][j];\\n    if(a[i]==b[j]){\\n        dp[i][j] = solve(i+1,j+1,n,m,a,b,dp);\\n    }else{\\n        dp[i][j] = min({solve(i+1,j,n,m,a,b,dp),solve(i,j+1,n,m,a,b,dp),solve(i+1,j+1,n,m,a,b,dp)})+1;\\n    }\\n    return dp[i][j];\\n}\\n    int minDistance(string a, string b) {\\n        int n = a.length(),m=b.length();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        return solve(0,0,n,m,a,b,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint solve(int i,int j,int &n,int &m,string &a,string &b,vector<vector<int>> &dp){\\n    if(i==n)return m-j;\\n    if(j==m)return n-i;\\n    if(dp[i][j] != -1)return dp[i][j];\\n    if(a[i]==b[j]){\\n        dp[i][j] = solve(i+1,j+1,n,m,a,b,dp);\\n    }else{\\n        dp[i][j] = min({solve(i+1,j,n,m,a,b,dp),solve(i,j+1,n,m,a,b,dp),solve(i+1,j+1,n,m,a,b,dp)})+1;\\n    }\\n    return dp[i][j];\\n}\\n    int minDistance(string a, string b) {\\n        int n = a.length(),m=b.length();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        return solve(0,0,n,m,a,b,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281006,
                "title": "easy-python-solution-using-dp-75-runtime",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def minDistance(self, word1, word2):\\n        \"\"\"\\n        :type word1: str\\n        :type word2: str\\n        :rtype: int\\n        \"\"\"\\n        l1=len(word1)\\n        l2=len(word2)\\n        dp=[[0]*(l2+1) for i in range(l1+1)]\\n        cnt=0\\n        for i in range(l1+1):\\n            for j in range(l2+1):\\n                if i==0:\\n                    dp[i][j]=j\\n                elif j==0:\\n                    dp[i][j]=i\\n                elif word1[i-1]==word2[j-1]:\\n                    dp[i][j]=dp[i-1][j-1]\\n                else:\\n                    dp[i][j]=min(dp[i][j-1],dp[i-1][j],dp[i-1][j-1])+1\\n        return dp[-1][-1]\\n```",
                "solutionTags": [
                    "Python",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def minDistance(self, word1, word2):\\n        \"\"\"\\n        :type word1: str\\n        :type word2: str\\n        :rtype: int\\n        \"\"\"\\n        l1=len(word1)\\n        l2=len(word2)\\n        dp=[[0]*(l2+1) for i in range(l1+1)]\\n        cnt=0\\n        for i in range(l1+1):\\n            for j in range(l2+1):\\n                if i==0:\\n                    dp[i][j]=j\\n                elif j==0:\\n                    dp[i][j]=i\\n                elif word1[i-1]==word2[j-1]:\\n                    dp[i][j]=dp[i-1][j-1]\\n                else:\\n                    dp[i][j]=min(dp[i][j-1],dp[i-1][j],dp[i-1][j-1])+1\\n        return dp[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231326,
                "title": "python-short-and-clean-2-solutions-recursive-dp-optimised-iterative-dp",
                "content": "# Approach: Recursive DP\\n1. Let `min_dist` be a function which takes indices `i1` and `i2` from `word1` and `word2` respectively, and returns the minimum operations needed to make `word1[:i1] == word2[:i2]`.\\n\\n2. Notice that if `word1[i1] == word2[i2]`, then no operations, i.e\\n    `min_dist(i1, i2) = min_dist(i1 - 1, i2 - 1)`\\n\\n3. And if `word1[i1] != word2[i2]`, then check all 3 operations, i.e\\n    `a = min_dist(i1 - 1, i2 - 1)` (Replace `word1[i1]` with `word2[i2]`)\\n    `b = min_dist(i1, i2 - 1)` (Insert `word2[i2]` in `word1`)\\n    `c = min_dist(i1 - 1, i2)` (Delete `word1[i1]`)\\n    `min_dist(i1, i2) = min(a, b, c)` (Best of all)\\n\\n4. This can be implemented by recursively calling the `min_dist` function.\\n\\n5. Since the problem has overlapping sub-problems and optimal sub-structure we can memoize the calls to `min_dist` to optimize the complexity.\\n\\n# Complexity\\n- Time complexity: $$O(n1 * n2)$$\\n\\n- Space complexity: $$O(n1 * n2)$$\\n\\nwhere,\\n`n1 is length of word1`,\\n`n2 is length of word2`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        @cache\\n        def min_distance(i1: int, i2: int) -> int:\\n            if not i1 or not i2: return max(i1, i2)\\n            \\n            return (\\n                min_distance(i1 - 1, i2 - 1)\\n                if word1[i1 - 1] == word2[i2 - 1] \\n                else 1 + min(\\n                    min_distance(i1 - 1, i2 - 1),\\n                    min_distance(i1, i2 - 1),\\n                    min_distance(i1 - 1, i2),\\n                )\\n            )\\n        \\n        return min_distance(len(word1), len(word2))\\n\\n\\n```\\n\\n---\\n# Approach: Iterative Space Optimized DP\\n1. Same as the recursive approach, but notice that at any given time we are only interesting in 3 previous states `min_dist(i, j) = min(a, b, c)`.\\n\\n2. We can optimise the space complexity by reducing the memoization from 2D space of `i and j` into 1D space of `i or j`.\\n\\n# Complexity\\n- Time complexity: $$O(n1 * n2)$$\\n\\n- Space complexity: $$O(min(n1, n2))$$\\n\\nwhere,\\n`n1 is length of word1`,\\n`n2 is length of word2`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        w1, w2 = (word1, word2) if len(word1) < len(word2) else (word2, word1)\\n        n1, n2 = len(w1), len(w2)\\n\\n        dp = list(range(n1 + 1))\\n        for i in range(n2):\\n            prev, dp[0] = dp[0], dp[0] + 1\\n            for j in range(n1):\\n                k = j + 1\\n                prev, dp[k] = dp[k], prev if w1[j] == w2[i] else min(prev, dp[k - 1], dp[k]) + 1\\n        \\n        return dp[-1]\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        @cache\\n        def min_distance(i1: int, i2: int) -> int:\\n            if not i1 or not i2: return max(i1, i2)\\n            \\n            return (\\n                min_distance(i1 - 1, i2 - 1)\\n                if word1[i1 - 1] == word2[i2 - 1] \\n                else 1 + min(\\n                    min_distance(i1 - 1, i2 - 1),\\n                    min_distance(i1, i2 - 1),\\n                    min_distance(i1 - 1, i2),\\n                )\\n            )\\n        \\n        return min_distance(len(word1), len(word2))\\n\\n\\n```\n```python\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        w1, w2 = (word1, word2) if len(word1) < len(word2) else (word2, word1)\\n        n1, n2 = len(w1), len(w2)\\n\\n        dp = list(range(n1 + 1))\\n        for i in range(n2):\\n            prev, dp[0] = dp[0], dp[0] + 1\\n            for j in range(n1):\\n                k = j + 1\\n                prev, dp[k] = dp[k], prev if w1[j] == w2[i] else min(prev, dp[k - 1], dp[k]) + 1\\n        \\n        return dp[-1]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230679,
                "title": "python-easy-to-understand-bottom-up-dp-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code Upvote Please\\uD83D\\uDE09\\uD83D\\uDC4D and Help Me \\uD83D\\uDE4C\\uD83E\\uDD1E\\u2764\\n```\\nclass Solution(object):\\n    def minDistance(self, word1, word2):\\n        \"\"\"\\n        :type word1: str\\n        :type word2: str\\n        :rtype: int\\n        \"\"\"\\n        len1 = len(word1)\\n        len2 = len(word2)\\n        dp = [[-1] * (len2+1) for _ in range(len1+1)]\\n        \\n        for i in range(len1+1):\\n            for j in range(len2+1):\\n                if i == 0:\\n                    dp[i][j] = j  \\n                elif j == 0:\\n                    dp[i][j] = i  \\n                elif word1[i-1] == word2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\\n        return dp[len1][len2]\\n        \\n        \\n        \\n        \\n\\n```",
                "solutionTags": [
                    "Python",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def minDistance(self, word1, word2):\\n        \"\"\"\\n        :type word1: str\\n        :type word2: str\\n        :rtype: int\\n        \"\"\"\\n        len1 = len(word1)\\n        len2 = len(word2)\\n        dp = [[-1] * (len2+1) for _ in range(len1+1)]\\n        \\n        for i in range(len1+1):\\n            for j in range(len2+1):\\n                if i == 0:\\n                    dp[i][j] = j  \\n                elif j == 0:\\n                    dp[i][j] = i  \\n                elif word1[i-1] == word2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\\n        return dp[len1][len2]\\n        \\n        \\n        \\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230499,
                "title": "daily-leetcoding-challenge-february-day-26",
                "content": "This problem is the Daily LeetCoding Challenge for February, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/edit-distance/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/edit-distance/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2656519,
                "title": "memoization-tabulation-space-optimisation-c-beginner-friendly",
                "content": "```\\n// MEMOIZATION\\n// class Solution {\\n// public:\\n//     int f(int i, int j, string word1, string word2,vector<vector<int>> &dp){\\n//         if(i == 0) return j;\\n//         if(j == 0) return i;\\n//         if(dp[i][j] != -1) return dp[i][j];\\n//         if(word1[i-1] == word2[j-1]){\\n//             return dp[i][j] = f(i-1,j-1,word1,word2,dp);\\n//         }\\n//         return dp[i][j] = 1 + min(f(i-1,j-1,word1,word2,dp),min(f(i,j-1,word1,word2,dp),f(i-1,j,word1,word2,dp)));     \\n//     }\\n//     int minDistance(string word1, string word2) {\\n//         int n = word1.length();\\n//         int m = word2.length();\\n//         vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n//         return f(n,m,word1,word2,dp);\\n//     }\\n// };\\n// TABULATION\\n// class Solution {\\n// public:\\n//     int minDistance(string w1, string w2) {\\n//         int n = w1.length();\\n//         int m = w2.length();\\n//         vector<vector<int>> dp(n+1,vector<int>(m+1,0));\\n        \\n//         for(int j=0;j<=m;j++) dp[0][j] = j;\\n//         for(int i=0;i<=n;i++) dp[i][0] = i;\\n        \\n//         for(int i=1;i<=n;i++){\\n//             for(int j=1;j<=m;j++){\\n//                 if(w1[i-1] == w2[j-1]){\\n//                     dp[i][j] = dp[i-1][j-1];    \\n//                 }else{\\n//                     dp[i][j] = 1 + min(dp[i-1][j-1],min(dp[i-1][j],dp[i][j-1]));\\n//                 }\\n                \\n//             }\\n//         }\\n//         return dp[n][m];\\n//     }\\n// };\\n// SPACE OPTIMISATION\\nclass Solution {\\npublic:\\n    int minDistance(string w1, string w2) {\\n        int n = w1.length();\\n        int m = w2.length();\\n        vector<int> curr(m+1,0),prev(m+1,0);\\n        \\n        for(int j=0;j<=m;j++) prev[j] = j;\\n        \\n        for(int i=1;i<=n;i++){\\n            curr[0] = i;\\n            for(int j=1;j<=m;j++){\\n                if(w1[i-1] == w2[j-1]){\\n                    curr[j] = prev[j-1];    \\n                }else{\\n                    curr[j] = 1 + min(prev[j-1],min(prev[j],curr[j-1]));\\n                }\\n                \\n            }\\n            prev = curr;\\n        }\\n        return prev[m];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n// MEMOIZATION\\n// class Solution {\\n// public:\\n//     int f(int i, int j, string word1, string word2,vector<vector<int>> &dp){\\n//         if(i == 0) return j;\\n//         if(j == 0) return i;\\n//         if(dp[i][j] != -1) return dp[i][j];\\n//         if(word1[i-1] == word2[j-1]){\\n//             return dp[i][j] = f(i-1,j-1,word1,word2,dp);\\n//         }\\n//         return dp[i][j] = 1 + min(f(i-1,j-1,word1,word2,dp),min(f(i,j-1,word1,word2,dp),f(i-1,j,word1,word2,dp)));     \\n//     }\\n//     int minDistance(string word1, string word2) {\\n//         int n = word1.length();\\n//         int m = word2.length();\\n//         vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n//         return f(n,m,word1,word2,dp);\\n//     }\\n// };\\n// TABULATION\\n// class Solution {\\n// public:\\n//     int minDistance(string w1, string w2) {\\n//         int n = w1.length();\\n//         int m = w2.length();\\n//         vector<vector<int>> dp(n+1,vector<int>(m+1,0));\\n        \\n//         for(int j=0;j<=m;j++) dp[0][j] = j;\\n//         for(int i=0;i<=n;i++) dp[i][0] = i;\\n        \\n//         for(int i=1;i<=n;i++){\\n//             for(int j=1;j<=m;j++){\\n//                 if(w1[i-1] == w2[j-1]){\\n//                     dp[i][j] = dp[i-1][j-1];    \\n//                 }else{\\n//                     dp[i][j] = 1 + min(dp[i-1][j-1],min(dp[i-1][j],dp[i][j-1]));\\n//                 }\\n                \\n//             }\\n//         }\\n//         return dp[n][m];\\n//     }\\n// };\\n// SPACE OPTIMISATION\\nclass Solution {\\npublic:\\n    int minDistance(string w1, string w2) {\\n        int n = w1.length();\\n        int m = w2.length();\\n        vector<int> curr(m+1,0),prev(m+1,0);\\n        \\n        for(int j=0;j<=m;j++) prev[j] = j;\\n        \\n        for(int i=1;i<=n;i++){\\n            curr[0] = i;\\n            for(int j=1;j<=m;j++){\\n                if(w1[i-1] == w2[j-1]){\\n                    curr[j] = prev[j-1];    \\n                }else{\\n                    curr[j] = 1 + min(prev[j-1],min(prev[j],curr[j-1]));\\n                }\\n                \\n            }\\n            prev = curr;\\n        }\\n        return prev[m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2571257,
                "title": "simple-python-solution-recursive-and-dp-both-solutions",
                "content": "\\nRecursive (with memoization - lrucache)\\n```python\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n\\n        n = len(word1)\\n        m = len(word2)\\n\\n        @cache\\n        def mdistance(i, j):\\n\\n            if i == n or j == m:\\n                return (m - j) + (n - i) #if i is n, we will need m-j insert operations\\n\\n            operations = min(\\n                mdistance(i + 1, j) + 1, #deletion\\n                mdistance(i, j + 1) + 1, # insertion\\n                mdistance(i + 1, j + 1) + (0 if word1[i] == word2[j] else 1), # if char is not same replace\\n            )\\n            return operations\\n\\n        return mdistance(0, 0)\\n\\n```\\n\\nDP (tabular)\\n\\n```python\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n\\n        n = len(word1)\\n        m = len(word2)\\n\\n        mem = [([0] * (n + 1)) for _ in range(m + 1)]\\n\\n        for i in range(1, m + 1):\\n            mem[i][0] = i\\n        for j in range(1, n + 1):\\n            mem[0][j] = j\\n\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                mem[i][j] = min(\\n                    mem[i - 1][j] + 1,\\n                    mem[i][j - 1] + 1,\\n                    mem[i - 1][j - 1] + (0 if word1[j - 1] == word2[i - 1] else 1),\\n                )\\n\\n        return mem[m][n]\\n```\\n\\nTime complexity: `O(n*m)` for both\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n\\n        n = len(word1)\\n        m = len(word2)\\n\\n        @cache\\n        def mdistance(i, j):\\n\\n            if i == n or j == m:\\n                return (m - j) + (n - i) #if i is n, we will need m-j insert operations\\n\\n            operations = min(\\n                mdistance(i + 1, j) + 1, #deletion\\n                mdistance(i, j + 1) + 1, # insertion\\n                mdistance(i + 1, j + 1) + (0 if word1[i] == word2[j] else 1), # if char is not same replace\\n            )\\n            return operations\\n\\n        return mdistance(0, 0)\\n\\n```\n```python\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n\\n        n = len(word1)\\n        m = len(word2)\\n\\n        mem = [([0] * (n + 1)) for _ in range(m + 1)]\\n\\n        for i in range(1, m + 1):\\n            mem[i][0] = i\\n        for j in range(1, n + 1):\\n            mem[0][j] = j\\n\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                mem[i][j] = min(\\n                    mem[i - 1][j] + 1,\\n                    mem[i][j - 1] + 1,\\n                    mem[i - 1][j - 1] + (0 if word1[j - 1] == word2[i - 1] else 1),\\n                )\\n\\n        return mem[m][n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2344318,
                "title": "reach-form-recursion-to-dp-in-simple-change-in-code",
                "content": "**Recursive Function - **\\n```\\n   int fun(string &s1, string &s2, int n, int m){\\n        if(n == 0)                          // Base Case 1 : If first string is empty return second string len. Because, we need to put all the characters from scratch\\n            return m;                       //               string size convert first into second\\n        else if(m == 0)\\n                return n;                   // Base Case2 2: Vice-Versa of above base case\\n        else if(s1[n - 1] == s2[m - 1])\\n               return fun(s1, s2, n - 1, m - 1); //  when both characters are matched call the function for smaller input by reducing the size of both the strings\\n        else               \\n            return 1 + min({fun(s1,s2, n, m - 1), fun(s1, s2, n - 1, m), fun(s1, s2, n - 1, m - 1)});  // When characters Doesn\\'t match we will perform all the 3 operations insert , delete , replace and give the minimum one.\\n    } \\n```\\nNow let us try to convert the recursive code in dp - In Aditya Verma\\'s style\\uD83D\\uDE0E\\nreplace n with i and m with j in bottom-up dp. In initialization put the values of i and j.\\n```\\n    int minDistance(string str1, string str2) {\\n        int n = str1.size();\\n        int m = str2.size();\\n        \\n        int dp[n+1][m+1];                       //Initialization based on our base condition of recursion.\\n        for(int i = 0 ; i<=n ; i++)\\n            dp[i][0] = i;\\n        for(int j = 0 ; j<=m ; j++)\\n            dp[0][j] = j;\\n\\t\\t\\t\\n\\t\\t\\t//Inserting values in dp table- same as recursion condition.\\n        \\n        for(int i = 1 ; i<=n ; i++){\\n            for(int j = 1 ; j<=m ; j++){\\n                if(str1[i-1]==str2[j-1])\\n                    dp[i][j] = dp[i-1][j-1];\\n                else\\n                    dp[i][j] = 1 + min({dp[i-1][j] , dp[i][j-1] , dp[i-1][j-1]});\\n            }\\n        }\\n        \\n        return dp[n][m];\\n         }\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\n   int fun(string &s1, string &s2, int n, int m){\\n        if(n == 0)                          // Base Case 1 : If first string is empty return second string len. Because, we need to put all the characters from scratch\\n            return m;                       //               string size convert first into second\\n        else if(m == 0)\\n                return n;                   // Base Case2 2: Vice-Versa of above base case\\n        else if(s1[n - 1] == s2[m - 1])\\n               return fun(s1, s2, n - 1, m - 1); //  when both characters are matched call the function for smaller input by reducing the size of both the strings\\n        else               \\n            return 1 + min({fun(s1,s2, n, m - 1), fun(s1, s2, n - 1, m), fun(s1, s2, n - 1, m - 1)});  // When characters Doesn\\'t match we will perform all the 3 operations insert , delete , replace and give the minimum one.\\n    } \\n```\n```\\n    int minDistance(string str1, string str2) {\\n        int n = str1.size();\\n        int m = str2.size();\\n        \\n        int dp[n+1][m+1];                       //Initialization based on our base condition of recursion.\\n        for(int i = 0 ; i<=n ; i++)\\n            dp[i][0] = i;\\n        for(int j = 0 ; j<=m ; j++)\\n            dp[0][j] = j;\\n\\t\\t\\t\\n\\t\\t\\t//Inserting values in dp table- same as recursion condition.\\n        \\n        for(int i = 1 ; i<=n ; i++){\\n            for(int j = 1 ; j<=m ; j++){\\n                if(str1[i-1]==str2[j-1])\\n                    dp[i][j] = dp[i-1][j-1];\\n                else\\n                    dp[i][j] = 1 + min({dp[i-1][j] , dp[i][j-1] , dp[i-1][j-1]});\\n            }\\n        }\\n        \\n        return dp[n][m];\\n         }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1608072,
                "title": "c-clean-recursive-dp-memoization-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>>dp;\\n    \\n    int recurs(string& word1, string& word2,int i,int j)\\n    {\\n        if(i>=word1.size()&&j>=word2.size())\\n             return 0;\\n        \\n        if(i>=word1.size())\\n             return word2.size()-j; // all remaining need to be added\\n        \\n        if(j>=word2.size())\\n             return word1.size()-i; // all remaining need to be removed\\n        \\n        if(dp[i][j]!=-1)\\n              return dp[i][j];\\n        \\n        if(word1[i]==word2[j])\\n             return dp[i][j]=recurs(word1,word2,i+1,j+1);\\n        else\\n        {\\n            int a=recurs(word1,word2,i+1,j+1)+1;//replace\\n            int b=recurs(word1,word2,i+1,j)+1;//delete\\n            int c=recurs(word1,word2,i,j+1)+1;//insert\\n            c=min(b,c);\\n            return dp[i][j]=min(a,c);\\n        }\\n        \\n       \\n    }\\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    int minDistance(string word1, string word2) {\\n        dp.resize(word1.size(),vector<int>(word2.size(),-1));\\n        \\n        return recurs(word1,word2,0,0);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>>dp;\\n    \\n    int recurs(string& word1, string& word2,int i,int j)\\n    {\\n        if(i>=word1.size()&&j>=word2.size())\\n             return 0;\\n        \\n        if(i>=word1.size())\\n             return word2.size()-j; // all remaining need to be added\\n        \\n        if(j>=word2.size())\\n             return word1.size()-i; // all remaining need to be removed\\n        \\n        if(dp[i][j]!=-1)\\n              return dp[i][j];\\n        \\n        if(word1[i]==word2[j])\\n             return dp[i][j]=recurs(word1,word2,i+1,j+1);\\n        else\\n        {\\n            int a=recurs(word1,word2,i+1,j+1)+1;//replace\\n            int b=recurs(word1,word2,i+1,j)+1;//delete\\n            int c=recurs(word1,word2,i,j+1)+1;//insert\\n            c=min(b,c);\\n            return dp[i][j]=min(a,c);\\n        }\\n        \\n       \\n    }\\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    int minDistance(string word1, string word2) {\\n        dp.resize(word1.size(),vector<int>(word2.size(),-1));\\n        \\n        return recurs(word1,word2,0,0);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603750,
                "title": "memoized-commented-solution",
                "content": "class Solution {\\npublic:\\n    \\n    string w1, w2;\\n    \\n    int dp[505][505];\\n    \\n    int solve(int i, int j){\\n        int ans = INT_MAX;\\n        \\n        if(i==w1.length() && j<w2.length()){\\n            //use insert op\\n            return dp[i][j]= min(ans,1+solve(i,j+1));\\n        }\\n        \\n        if(j==w2.length() && i<w1.length()){\\n            //use delete op\\n            return dp[i][j]= min(ans,1+solve(i+1,j));\\n        }\\n        \\n        if(i==w1.length() && j==w2.length()){\\n            return dp[i][j]=0;\\n        }\\n        \\n        if(dp[i][j]!=INT_MAX){\\n            return dp[i][j];\\n        }\\n        \\n        if(w1[i]==w2[j]){\\n            ans = min(ans,solve(i+1,j+1));\\n        }\\n        else{\\n            //insert\\n            ans = min(ans,1+solve(i,j+1));\\n            //delete\\n            ans = min(ans,1+solve(i+1,j));\\n            //replace\\n            ans = min(ans,1+solve(i+1,j+1));\\n        }\\n        return dp[i][j]=ans;\\n    }\\n    \\n    int minDistance(string word1, string word2) {\\n        //O(N^2)\\n        w1 = word1;\\n        w2 = word2;\\n        for(int i=0;i<505;i++){\\n            for(int j=0;j<505;j++){\\n                dp[i][j]=INT_MAX;\\n            }\\n        }\\n        return solve(0,0);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    string w1, w2;\\n    \\n    int dp[505][505];\\n    \\n    int solve(int i, int j){\\n        int ans = INT_MAX;\\n        \\n        if(i==w1.length() && j<w2.length()){\\n            //use insert op\\n            return dp[i][j]= min(ans,1+solve(i,j+1));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1413460,
                "title": "c-o-n-n-time-o-n-n-space-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDistance(string s, string t) {\\n        // Code here\\n        // This is a dp arroach :\\n        int n = s.size();\\n        int m = t.size();\\n        int dp[n+1][m+1];\\n        // dp[i][j] => edit distance for the string s[0...i-1] && t[0...j-1];\\n        for(int i=0;i<n+1;i++)\\n        {\\n            dp[i][0] = i;\\n        }\\n        for(int j=0;j<m+1;j++)\\n        {\\n            dp[0][j] = j;\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=m;j++)\\n            {\\n                if(s[i-1] == t[j-1])\\n                dp[i][j] = dp[i-1][j-1];\\n                else\\n                {\\n                    dp[i][j] = 1 + min(dp[i-1][j-1],min(dp[i-1][j],dp[i][j-1]));\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n        \\n    \\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string s, string t) {\\n        // Code here\\n        // This is a dp arroach :\\n        int n = s.size();\\n        int m = t.size();\\n        int dp[n+1][m+1];\\n        // dp[i][j] => edit distance for the string s[0...i-1] && t[0...j-1];\\n        for(int i=0;i<n+1;i++)\\n        {\\n            dp[i][0] = i;\\n        }\\n        for(int j=0;j<m+1;j++)\\n        {\\n            dp[0][j] = j;\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=m;j++)\\n            {\\n                if(s[i-1] == t[j-1])\\n                dp[i][j] = dp[i-1][j-1];\\n                else\\n                {\\n                    dp[i][j] = 1 + min(dp[i-1][j-1],min(dp[i-1][j],dp[i][j-1]));\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n        \\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368674,
                "title": "java-using-dp-simple-and-clean",
                "content": "```\\nclass Solution {\\n    public int minDistance(String s, String t) {\\n\\t\\tif (s.isEmpty() || t.isEmpty())\\n\\t\\t\\treturn Math.max(s.length(), t.length());\\n\\t\\tint[][] dp = new int[s.length() + 1][t.length() + 1];\\n\\t\\tfor (int i = 0; i < t.length() + 1; i++) dp[0][i] = i;\\n\\t\\tfor (int i = 0; i < s.length() + 1; i++) dp[i][0] = i;\\n\\t\\tfor (int i = 1; i < s.length() + 1; i++) {\\n\\t\\t\\tfor (int j = 1; j < t.length() + 1; j++) {\\n\\t\\t\\t\\tif (s.charAt(i - 1) == t.charAt(j - 1)) dp[i][j] = dp[i - 1][j - 1];\\n\\t\\t\\t\\telse dp[i][j] = Math.min(dp[i - 1][j], Math.min(dp[i][j - 1], dp[i - 1][j - 1])) + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[s.length()][t.length()];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minDistance(String s, String t) {\\n\\t\\tif (s.isEmpty() || t.isEmpty())\\n\\t\\t\\treturn Math.max(s.length(), t.length());\\n\\t\\tint[][] dp = new int[s.length() + 1][t.length() + 1];\\n\\t\\tfor (int i = 0; i < t.length() + 1; i++) dp[0][i] = i;\\n\\t\\tfor (int i = 0; i < s.length() + 1; i++) dp[i][0] = i;\\n\\t\\tfor (int i = 1; i < s.length() + 1; i++) {\\n\\t\\t\\tfor (int j = 1; j < t.length() + 1; j++) {\\n\\t\\t\\t\\tif (s.charAt(i - 1) == t.charAt(j - 1)) dp[i][j] = dp[i - 1][j - 1];\\n\\t\\t\\t\\telse dp[i][j] = Math.min(dp[i - 1][j], Math.min(dp[i][j - 1], dp[i - 1][j - 1])) + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[s.length()][t.length()];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1077256,
                "title": "recursion-dp",
                "content": "recursion, exponential\\n```\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        return recur(word1,word2,0,0);\\n    }\\n    \\n    int recur(String word1, String word2, int index1, int index2) {\\n        int n1 = word1.length(), n2 = word2.length();\\n        if(n2==index2) return n1-index1;\\n        if(n1==index1) return n2-index2;\\n        \\n        if(word1.charAt(index1)== word2.charAt(index2)) {\\n            return recur(word1,word2,index1+1,index2+1);\\n        } else {\\n            int c1 = 1+recur(word1, word2,index1,index2+1); //insert\\n            int c2 = 1+recur(word1, word2,index1+1,index2); //delete\\n            int c3 = 1+recur(word1, word2,index1+1,index2+1); //replace\\n            return Math.min(c1,Math.min(c2,c3));\\n        }\\n    }\\n}\\n```\\ndp, time = O(mn), space = O(mn)\\n```\\nclass Solution {\\n\\n    public int minDistance(String word1, String word2) {\\n        \\n        int n1= word1.length(), n2=word2.length();\\n        if(n1==0) return n2;\\n        if(n2==0) return n1;\\n        int[][] dp = new int[n1+1][n2+1];\\n        //base\\n         for(int i =0;i<n1+1;i++)  {    \\n            dp[i][0] = i; //delete \\n         }\\n\\n         for(int j =0;j<n2+1;j++)  {    \\n            dp[0][j] = j; //add \\n         }\\n         \\n        for(int i = 1;i<n1+1; i++) {\\n            for(int j = 1;j<n2+1; j++) {\\n            \\n                if(word1.charAt(i-1) ==word2.charAt(j-1)) {\\n                    dp[i][j] = dp[i-1][j-1];\\n                } else {\\n                    int c1 = dp[i-1][j]; //insert \\n                    int c2 = dp[i][j-1]; //delete\\n                    int c3 = dp[i-1][j-1]; //replace            \\n                    dp[i][j] =1+ Math.min(Math.min(c1,c2),c3);\\n                }\\n            }\\n        }\\n        return dp[n1][n2];\\n    }\\n}\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        return recur(word1,word2,0,0);\\n    }\\n    \\n    int recur(String word1, String word2, int index1, int index2) {\\n        int n1 = word1.length(), n2 = word2.length();\\n        if(n2==index2) return n1-index1;\\n        if(n1==index1) return n2-index2;\\n        \\n        if(word1.charAt(index1)== word2.charAt(index2)) {\\n            return recur(word1,word2,index1+1,index2+1);\\n        } else {\\n            int c1 = 1+recur(word1, word2,index1,index2+1); //insert\\n            int c2 = 1+recur(word1, word2,index1+1,index2); //delete\\n            int c3 = 1+recur(word1, word2,index1+1,index2+1); //replace\\n            return Math.min(c1,Math.min(c2,c3));\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n\\n    public int minDistance(String word1, String word2) {\\n        \\n        int n1= word1.length(), n2=word2.length();\\n        if(n1==0) return n2;\\n        if(n2==0) return n1;\\n        int[][] dp = new int[n1+1][n2+1];\\n        //base\\n         for(int i =0;i<n1+1;i++)  {    \\n            dp[i][0] = i; //delete \\n         }\\n\\n         for(int j =0;j<n2+1;j++)  {    \\n            dp[0][j] = j; //add \\n         }\\n         \\n        for(int i = 1;i<n1+1; i++) {\\n            for(int j = 1;j<n2+1; j++) {\\n            \\n                if(word1.charAt(i-1) ==word2.charAt(j-1)) {\\n                    dp[i][j] = dp[i-1][j-1];\\n                } else {\\n                    int c1 = dp[i-1][j]; //insert \\n                    int c2 = dp[i][j-1]; //delete\\n                    int c3 = dp[i-1][j-1]; //replace            \\n                    dp[i][j] =1+ Math.min(Math.min(c1,c2),c3);\\n                }\\n            }\\n        }\\n        return dp[n1][n2];\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1043703,
                "title": "java-recursion-memoization-explanation",
                "content": "## For any DP question there are 2 parts: \\n1) Base case: Always think of what the smallest possible input could be. In our case, lengths of string word1 and word2 (let M = length of word1 & N = length of word2).\\nSo, base case is if(M==0 || N==0). \\nIf M==0, we simply insert all n characters of word2 into it and return N.\\nIf N==0, we simply delete all m characters in word2 and return M.\\nBasically we return Max(M,N). If both are 0, it returns 0.\\n\\n2) Choice tree\\nLet\\'s say at an instant we have the first m characters of word1 and the first n characters of word2. How do we solve the question for this instance? ```minDist(word1, word2, m, n)  ```\\nOur strategy is to keep on reducing the input step-by-step and check the last characters of both the inputs. For the last characters, we have 2 possibilities.\\n* Both characters are same ( word1.charAt(m) == word2.charAt(n) )\\nWe don\\'t need any operation because both characters are same.\\nSimply reduce the input length and return ```minDist(word1, word2, m-1, n-1) ```\\n* Characters are different  ( word1.charAt(m-1) != word2.charAt(n-1) )\\nNow we have 3 possibilities:\\n\\t1.  Insert the character word2.charAt(n) after the current index \\'m\\' of word1 \\n\\tSince we inserted a new character in word1 to match word2.charAt(n). keep m same and reduce n by 1. ```return 1 + minDist(word1, word2, m, n-1)``` (1 is the cost of the insertion operation).\\n\\t2.  Delete the character word1.charAt(m). \\n\\tSince we deleted a character from word1 because it didn\\'t match with word2.charAt(n).\\n\\tDecrease m by 1 and keep n the same. ```return 1 + minDist(word1, word2, m-1, n)``` (1 is the cost of the deletion operation). \\n\\t3.  Substitute the character word1.charAt(m) with word2.charAt(n). Decrease m and n both by 1. ```return 1 + minDist(word1, word2, m-1, n-1)``` (1 is the cost of the substitution operation). \\n\\n\\tNow, simply take the minimum of what these 3 possibilities and return it as the answer for this instance of the function call ```minDist(word1, word2, m, n)```\\n\\tThen just use a 2D matrix(dp) to store the solution for memoization.\\n\\tTime complexity: O(MN)\\n```\\n\\tpublic int minDist(String x, String y, int m, int n, int dp[][]){\\n        if(m==0 || n==0)\\n            return Math.max(m,n);\\n        if(x.charAt(m-1)==y.charAt(n-1))\\n            return minDist(x,y,m-1,n-1, dp);\\n    \\n        if(dp[m][n-1]==-1) dp[m][n-1] = 1+minDist(x, y, m, n-1, dp);\\n        if(dp[m-1][n]==-1) dp[m-1][n] = 1+minDist(x, y, m-1, n, dp);\\n        if(dp[m-1][n-1]==-1) dp[m-1][n-1] = 1+minDist(x, y, m-1, n-1, dp);\\n        \\n        return dp[m][n] = Math.min(Math.min(dp[m-1][n-1],dp[m-1][n]), dp[m][n-1]);\\n        \\n    }\\n    public int minDistance(String word1, String word2) {\\n        int m=word1.length(), n=word2.length();\\n        int t[][]=new int[m+1][n+1];\\n        for(int i=0;i<=m;i++)\\n            for(int j=0;j<=n;j++)\\n                t[i][j]=-1;\\n        return minDist(word1, word2, m, n, t);\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```minDist(word1, word2, m, n)  ```\n```minDist(word1, word2, m-1, n-1) ```\n```return 1 + minDist(word1, word2, m, n-1)```\n```return 1 + minDist(word1, word2, m-1, n)```\n```return 1 + minDist(word1, word2, m-1, n-1)```\n```minDist(word1, word2, m, n)```\n```\\n\\tpublic int minDist(String x, String y, int m, int n, int dp[][]){\\n        if(m==0 || n==0)\\n            return Math.max(m,n);\\n        if(x.charAt(m-1)==y.charAt(n-1))\\n            return minDist(x,y,m-1,n-1, dp);\\n    \\n        if(dp[m][n-1]==-1) dp[m][n-1] = 1+minDist(x, y, m, n-1, dp);\\n        if(dp[m-1][n]==-1) dp[m-1][n] = 1+minDist(x, y, m-1, n, dp);\\n        if(dp[m-1][n-1]==-1) dp[m-1][n-1] = 1+minDist(x, y, m-1, n-1, dp);\\n        \\n        return dp[m][n] = Math.min(Math.min(dp[m-1][n-1],dp[m-1][n]), dp[m][n-1]);\\n        \\n    }\\n    public int minDistance(String word1, String word2) {\\n        int m=word1.length(), n=word2.length();\\n        int t[][]=new int[m+1][n+1];\\n        for(int i=0;i<=m;i++)\\n            for(int j=0;j<=n;j++)\\n                t[i][j]=-1;\\n        return minDist(word1, word2, m, n, t);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 313920,
                "title": "c-96-beaten-using-dp-o-n-m-quadratic-speed-using-smart-lawz-kaboom",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        \\n        int aGrid[word1.size() + 1][word2.size() + 1];\\n        memset(aGrid, 0, sizeof(aGrid));\\n        \\n        aGrid[0][0] = 0;\\n        for (int x=1;x<=word1.size();x++) { aGrid[x][0] = x; }\\n        for (int y=1;y<=word2.size();y++) { aGrid[0][y] = y; }\\n        \\n        for (int x=1;x<=word1.size();x++) {\\n            for (int y=1;y<=word2.size();y++) {\\n                if (word1[x-1] == word2[y-1]) {\\n                    aGrid[x][y] = aGrid[x-1][y-1];\\n                } else {   \\n                    aGrid[x][y] = 1 + min(aGrid[x-1][y-1], min(aGrid[x-1][y], aGrid[x][y-1]));\\n                }\\n            }\\n        }\\n        \\n        return aGrid[word1.size()][word2.size()];\\n    }\\n};\\n```\\n\\nShip it in, ship it out. Now you\\'re on the payroll, living large. Boom, baby.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        \\n        int aGrid[word1.size() + 1][word2.size() + 1];\\n        memset(aGrid, 0, sizeof(aGrid));\\n        \\n        aGrid[0][0] = 0;\\n        for (int x=1;x<=word1.size();x++) { aGrid[x][0] = x; }\\n        for (int y=1;y<=word2.size();y++) { aGrid[0][y] = y; }\\n        \\n        for (int x=1;x<=word1.size();x++) {\\n            for (int y=1;y<=word2.size();y++) {\\n                if (word1[x-1] == word2[y-1]) {\\n                    aGrid[x][y] = aGrid[x-1][y-1];\\n                } else {   \\n                    aGrid[x][y] = 1 + min(aGrid[x-1][y-1], min(aGrid[x-1][y], aGrid[x][y-1]));\\n                }\\n            }\\n        }\\n        \\n        return aGrid[word1.size()][word2.size()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 301791,
                "title": "wrong-test-case",
                "content": "Hi guys, I think this case is wrong. \\n```\\nInput:\\n\"zoologicoarchaeologist\"\\n\"zoogeologist\"\\nOutput:\\n9\\nExpected:\\n10\\n```\\nThe expected response should be 9. I confirmed it with different methods:\\n* Online Levenshtein calculator: https://planetcalc.com/1721/\\n* Manual:\\n![image](https://assets.leetcode.com/users/no6thing/image_1559170315.png)\\n\\nWhat you think?\\n\\n",
                "solutionTags": [],
                "code": "```\\nInput:\\n\"zoologicoarchaeologist\"\\n\"zoogeologist\"\\nOutput:\\n9\\nExpected:\\n10\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 227181,
                "title": "javascript-solution",
                "content": "```\\nvar minDistance = function(word1, word2) {\\n    const dp = initializeDp(word1, word2)\\n    constructDp(dp, word1, word2)\\n    return dp[word1.length][word2.length]\\n}\\n\\nconst initializeDp = (word1, word2) => {\\n    const dp = Array(word1.length + 1).fill().map(() => Array(word2.length + 1).fill())\\n    const rows = dp.length\\n    const cols = dp[0].length\\n    for (let i = 0; i < rows; i++) {\\n        dp[i][0] = i\\n    }\\n    for (let i = 1; i < cols; i++) {\\n        dp[0][i] = i\\n    }\\n    return dp\\n}\\n\\nconst constructDp = (dp, word1, word2) => {\\n    const rows = dp.length\\n    const cols = dp[0].length\\n    for (let i = 1; i < rows; i++) {\\n        for (let j = 1; j < cols; j++) {\\n            if (word1[i - 1] === word2[j - 1]) {\\n                dp[i][j] = dp[i - 1][j - 1]\\n            } else {\\n                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar minDistance = function(word1, word2) {\\n    const dp = initializeDp(word1, word2)\\n    constructDp(dp, word1, word2)\\n    return dp[word1.length][word2.length]\\n}\\n\\nconst initializeDp = (word1, word2) => {\\n    const dp = Array(word1.length + 1).fill().map(() => Array(word2.length + 1).fill())\\n    const rows = dp.length\\n    const cols = dp[0].length\\n    for (let i = 0; i < rows; i++) {\\n        dp[i][0] = i\\n    }\\n    for (let i = 1; i < cols; i++) {\\n        dp[0][i] = i\\n    }\\n    return dp\\n}\\n\\nconst constructDp = (dp, word1, word2) => {\\n    const rows = dp.length\\n    const cols = dp[0].length\\n    for (let i = 1; i < rows; i++) {\\n        for (let j = 1; j < cols; j++) {\\n            if (word1[i - 1] === word2[j - 1]) {\\n                dp[i][j] = dp[i - 1][j - 1]\\n            } else {\\n                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 25954,
                "title": "uses-longest-increasing-subsequence-subset-enumeration-dfs",
                "content": "My solution finds the longest matching pattern of string 1 in  string 2. \\nSo for word1 = \"adbac\" and word2 = \"abc\" , the longest matching pattern (not necessarily continuous) is \"abc\" \\nHow ? we can remove 'd' & second 'a' from \"adbac\" to get \"abc\". \\nThe way I find the longest matching pattern is through longest increasing subsequence . (standard dp)          \\nAfter than, the minimum can be found using simple math.\\n\\n\\n    public class Solution {\\n    \\n    List<List<Integer>> sequences = new ArrayList<List<Integer>>();\\n    void printer(List<Integer> seq){\\n        for(int i=0;i<seq.size();i++)\\n            System.out.print(seq.get(i) + \" \");\\n        System.out.println();\\n    }\\n    void form(int cur,List<Integer> sequence,List<List<Integer>>array){\\n        if(cur == array.size()){\\n            List<Integer> copy = new ArrayList<Integer>();\\n            for(int i=0; i<sequence.size();i++)\\n                copy.add(sequence.get(i));\\n            sequences.add(copy);\\n            return;\\n        }\\n        List<Integer> options = array.get(cur);\\n        for(int i=0;i<options.size();i++){\\n            sequence.add(options.get(i));\\n            form(cur+1,sequence,array);\\n            sequence.remove(sequence.size()-1);\\n        }\\n    }\\n    \\n    # find longest increasing subsequence for a given sequence\\n    List<Integer> get_lis (List<Integer> sequence){\\n        List<Integer> dp = new ArrayList<Integer>();\\n        Map<Integer,Integer> path = new HashMap<Integer,Integer>();\\n        List<Integer> lis = new ArrayList<Integer>();\\n        dp.add(1);\\n        path.put(0,-1);\\n        int maxpos = 0;\\n        for(int i=1;i<sequence.size();i++){\\n            if(sequence.get(i) == -1){\\n                dp.add(-1);\\n                continue;\\n            }\\n            dp.add(1);\\n            path.put(i,-1);\\n            for(int j=0;j<i;j++){\\n                if(sequence.get(j) < sequence.get(i) && dp.get(j) >= dp.get(i)){\\n                    dp.set(i,dp.get(j)+1);\\n                    path.put(i,j);\\n                }\\n            }\\n            if(dp.get(i)>dp.get(maxpos))\\n                maxpos = i;\\n        }\\n        Set<Integer> in_lis = new HashSet<Integer>();\\n        int pos = maxpos;\\n        while(true){\\n            if(pos == -1)\\n                break;\\n            in_lis.add(pos);\\n            pos = path.get(pos);\\n        }\\n        int count = 0;\\n        for(int i=0;i<sequence.size();i++){\\n            if(in_lis.contains(i)){\\n                lis.add(sequence.get(i));\\n                count++;\\n            }\\n            else\\n                lis.add(-1);\\n        }\\n        lis.add(count);\\n        return lis;\\n    }\\n    \\n    public int minDistance(String word1, String word2) {\\n        \\n       # form a map from characters that appear in word2 to a list of indices they appear in\\n        \\n        HashMap<Character,List<Integer>> map = new HashMap<Character,List<Integer>>();\\n        for(int i=0;i<word2.length();i++){\\n            char c = word2.charAt(i);\\n            if(!map.containsKey(c)){\\n                ArrayList<Integer> l = new ArrayList<Integer>();\\n                l.add(i);\\n                map.put(c,l);\\n            }\\n            else{\\n                List<Integer> l = map.get(c);\\n                l.add(i);\\n            }\\n        }\\n        \\n        # form a map from each index in word1 to the possible positions of that character in word2\\n        List<List<Integer>> array = new ArrayList<List<Integer>>();\\n        for(int i=0;i<word1.length();i++){\\n            char c = word1.charAt(i);\\n            List<Integer> l;\\n            if(!map.containsKey(c)){\\n               l = new ArrayList<Integer>();\\n               l.add(-1);\\n            }\\n            else\\n                l = map.get(c);\\n            array.add(l);\\n        }\\n        \\n        \\n        List<Integer> sequence = new ArrayList<Integer>();      #empty sequence just for the purpose of DFS\\n        \\n        # from the above map, each index in word1 can have multiple values. For example, for word1 = \"abc\"\\n        and word2 = \"aad\" , the values for index 0 ('a') for word1 are 0 and 1, because  'a' appears at\\n        indices 0 and 1 in word2. So we form all sequences for all possible values of each index of word1.\\n        \\n        form(0,sequence,array);                 # form all possible sequences\\n        \\n        \\n        # the following part gets the maximum longest possible subsequence from all possible sequences\\n        List<Integer> final_lis = new ArrayList<Integer>();\\n        int maxlen=0;\\n        for(int i=0; i<sequences.size();i++){\\n            sequence = sequences.get(i);\\n            List<Integer> lis = get_lis(sequence);\\n            int lislen = lis.get(lis.size()-1);\\n            if(lislen>maxlen){\\n                maxlen = lislen;\\n                lis.remove(lis.size()-1);\\n                final_lis = lis;\\n            }\\n        }\\n        \\n        #simple math to get the final answer\\n        int answer = 0;\\n        int i=0;\\n        int previ=0;\\n        int prevval=0;\\n        while(i<final_lis.size()){\\n            if(final_lis.get(i) == -1){\\n                i++;\\n                continue;\\n            }\\n            \\n            int diff1 = final_lis.get(i) - prevval -1;\\n            int diff2 = i - previ -1;\\n            answer += Math.max(diff1,diff2);\\n            previ = i;\\n            prevval = final_lis.get(i);\\n            i++;\\n        }\\n        \\n        int diff1 = word1.length() - previ;\\n        int diff2 = word2.length() - prevval;\\n        answer += Math.max(diff1,diff2);\\n        return answer;\\n    }\\n        \\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n    List<List<Integer>> sequences = new ArrayList<List<Integer>>();\\n    void printer(List<Integer> seq){\\n        for(int i=0;i<seq.size();i++)\\n            System.out.print(seq.get(i) + \" \");\\n        System.out.println();\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3926498,
                "title": "python-91-89-faster-dp-memoization-tabulation",
                "content": "```\\n\\'\\'\\'\\nExample: s1: \\'horse\\'\\n         s2: \\'ros\\'\\n\\nCase1: Inserting a Character\\n\\nNow if we have to match the strings by insertions, what would we do?: \\n\\nWe would have placed an \\u2018s\\u2019 at index 5 of S1.\\nSuppose i now point to s at index 5 of S1 and j points are already pointing to s at index j of S2.\\nNow, we hit the condition, where characters do match. (as mentioned in case 1).\\nTherefore, we will decrement i and j by 1. They will now point to index 4 and 1 respectively.\\n\\nNow, the number of operations we did were only 1 (inserting s at index 5) but do we need to really insert the \\u2018s\\u2019 at index 5 and modify the string? The answer is simply NO. As we see that inserting a character (here \\u2018s\\u2019 at index 5), we will eventually get to the third step. So we can just return 1+ f(i,j-1) as i remains there only after insertion and j decrements by 1. We can say that we have hypothetically inserted character s.\\n\\nCase 2: Deleting a character \\n\\nConsider the same example,\\n\\nWe can simply delete the character at index 4 and check from the next index.\\n\\nNow, j remains at its original index and we decrement i by 1. We perform 1 operation, therefore we will recursively call 1+f(i-1,j).\\n\\nCase3: Replacing a character \\n\\nConsider the same example,\\n\\n\\nIf we replace the character \\u2018e\\u2019 at index 4 of S1 with \\u2018s\\u2019, we have matched both the characters ourselves. We again hit the case of character matching, therefore we decrement both i and j by 1. As the number of operations performed is 1, we will return 1+f(i-1,j-1).\\n\\nTo summarise, these are the three choices we have in case characters don\\u2019t match:\\n\\nreturn 1+f(i-1,j) // Insertion of character.\\nreturn 1+f(i,j-1) // Deletion of character.\\nreturn 1+f(i-1,j-1) // Replacement of character.\\n\\'\\'\\'\\n\\n#Recursion \\n#Time Complexity: O(2^(m+n))\\n#Space Complexity: O(m+n)\\nclass Solution1:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        def solve(i,j):\\n            if i==0:\\n                return j\\n            if j==0:\\n                return i\\n            if word1[i-1]==word2[j-1]:\\n                return solve(i-1,j-1)\\n            else:\\n                return 1 + min(solve(i,j-1),solve(i-1,j),solve(i-1,j-1))\\n        m,n=len(word1),len(word2)\\n        return solve(m,n)\\n    \\n#Memoization (Top-Down)\\n#Time Complexity: O(m*n)\\n#Space Complexity: O(m+n) + O(m*n)\\nclass Solution2:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        def solve(i,j):\\n            if i==0:\\n                return j\\n            if j==0:\\n                return i\\n            if dp[i][j]!=-1:\\n                return dp[i][j]\\n            if word1[i-1]==word2[j-1]:\\n                dp[i][j]=solve(i-1,j-1)\\n                return dp[i][j]\\n            else:\\n                dp[i][j]=1 + min(solve(i,j-1),solve(i-1,j),solve(i-1,j-1))\\n                return dp[i][j]\\n        m,n=len(word1),len(word2)\\n        dp=[[-1 for j in range(n+1)] for i in range(m+1)]\\n        return solve(m,n)\\n    \\nclass Solution3:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m,n = len(word1),len(word2)\\n        dp = [[0 for j in range(n+1)] for i in range(m+1)]\\n        for i in range(m+1):\\n            dp[i][0] = i\\n        for j in range(n+1):\\n            dp[0][j] = j\\n        for i in range(1,m+1):\\n            for j in range(1,n+1):\\n                if word1[i-1] == word2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = 1 + min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1])\\n        return dp[m][n]\\n    \\n#Space Optimization\\n#Time Complexity: O(m*n)\\n#Space Complexity: O(n)\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m,n = len(word1),len(word2)\\n        prev=[0]*(n+1)\\n        curr=[0]*(n+1)\\n        for j in range(n+1):\\n            prev[j]=j\\n        for i in range(1,m+1):\\n            curr[0]=i\\n            for j in range(1,n+1):\\n                if word1[i-1] == word2[j-1]:\\n                    curr[j] = prev[j-1]\\n                else:\\n                    curr[j] = 1 + min(prev[j-1], prev[j], curr[j-1])\\n            prev=curr[:]\\n        return prev[n]\\n```\\n**An upovte will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n\\'\\'\\'\\nExample: s1: \\'horse\\'\\n         s2: \\'ros\\'\\n\\nCase1: Inserting a Character\\n\\nNow if we have to match the strings by insertions, what would we do?: \\n\\nWe would have placed an \\u2018s\\u2019 at index 5 of S1.\\nSuppose i now point to s at index 5 of S1 and j points are already pointing to s at index j of S2.\\nNow, we hit the condition, where characters do match. (as mentioned in case 1).\\nTherefore, we will decrement i and j by 1. They will now point to index 4 and 1 respectively.\\n\\nNow, the number of operations we did were only 1 (inserting s at index 5) but do we need to really insert the \\u2018s\\u2019 at index 5 and modify the string? The answer is simply NO. As we see that inserting a character (here \\u2018s\\u2019 at index 5), we will eventually get to the third step. So we can just return 1+ f(i,j-1) as i remains there only after insertion and j decrements by 1. We can say that we have hypothetically inserted character s.\\n\\nCase 2: Deleting a character \\n\\nConsider the same example,\\n\\nWe can simply delete the character at index 4 and check from the next index.\\n\\nNow, j remains at its original index and we decrement i by 1. We perform 1 operation, therefore we will recursively call 1+f(i-1,j).\\n\\nCase3: Replacing a character \\n\\nConsider the same example,\\n\\n\\nIf we replace the character \\u2018e\\u2019 at index 4 of S1 with \\u2018s\\u2019, we have matched both the characters ourselves. We again hit the case of character matching, therefore we decrement both i and j by 1. As the number of operations performed is 1, we will return 1+f(i-1,j-1).\\n\\nTo summarise, these are the three choices we have in case characters don\\u2019t match:\\n\\nreturn 1+f(i-1,j) // Insertion of character.\\nreturn 1+f(i,j-1) // Deletion of character.\\nreturn 1+f(i-1,j-1) // Replacement of character.\\n\\'\\'\\'\\n\\n#Recursion \\n#Time Complexity: O(2^(m+n))\\n#Space Complexity: O(m+n)\\nclass Solution1:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        def solve(i,j):\\n            if i==0:\\n                return j\\n            if j==0:\\n                return i\\n            if word1[i-1]==word2[j-1]:\\n                return solve(i-1,j-1)\\n            else:\\n                return 1 + min(solve(i,j-1),solve(i-1,j),solve(i-1,j-1))\\n        m,n=len(word1),len(word2)\\n        return solve(m,n)\\n    \\n#Memoization (Top-Down)\\n#Time Complexity: O(m*n)\\n#Space Complexity: O(m+n) + O(m*n)\\nclass Solution2:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        def solve(i,j):\\n            if i==0:\\n                return j\\n            if j==0:\\n                return i\\n            if dp[i][j]!=-1:\\n                return dp[i][j]\\n            if word1[i-1]==word2[j-1]:\\n                dp[i][j]=solve(i-1,j-1)\\n                return dp[i][j]\\n            else:\\n                dp[i][j]=1 + min(solve(i,j-1),solve(i-1,j),solve(i-1,j-1))\\n                return dp[i][j]\\n        m,n=len(word1),len(word2)\\n        dp=[[-1 for j in range(n+1)] for i in range(m+1)]\\n        return solve(m,n)\\n    \\nclass Solution3:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m,n = len(word1),len(word2)\\n        dp = [[0 for j in range(n+1)] for i in range(m+1)]\\n        for i in range(m+1):\\n            dp[i][0] = i\\n        for j in range(n+1):\\n            dp[0][j] = j\\n        for i in range(1,m+1):\\n            for j in range(1,n+1):\\n                if word1[i-1] == word2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = 1 + min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1])\\n        return dp[m][n]\\n    \\n#Space Optimization\\n#Time Complexity: O(m*n)\\n#Space Complexity: O(n)\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m,n = len(word1),len(word2)\\n        prev=[0]*(n+1)\\n        curr=[0]*(n+1)\\n        for j in range(n+1):\\n            prev[j]=j\\n        for i in range(1,m+1):\\n            curr[0]=i\\n            for j in range(1,n+1):\\n                if word1[i-1] == word2[j-1]:\\n                    curr[j] = prev[j-1]\\n                else:\\n                    curr[j] = 1 + min(prev[j-1], prev[j], curr[j-1])\\n            prev=curr[:]\\n        return prev[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3759099,
                "title": "c-solution-using-memoization-with-explaination",
                "content": "# Approach\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- **Perameters**\\nHere we are maintaining 2 indexes.i1 is for s1 and i2 is for s2.\\nn1 is size of s1 and n2 is size of s2.\\n\\n- **All possiblities**\\n\\nwe have 2 possiblites for each of the indexes.\\n1.first is if both indexes contains smae character if it is then we increase both of the indexes.\\n2.If it is not then\\nwe can do one of 3 operations.\\n1)insert 2)replace 3)delete\\n-->for insertion : When performing an insertion operation, we assume that we have added the character s2[i2] at the position s1[i1] in s1. At this point, both s1[i1] and s2[i2] contain the same character.\\nIdeally, since both indexes should cover the same characters, we would increase both i1 and i2. However, in this case, we are considering the modified s1, which hypothetically has one additional character. But since we are not actually changing s1, we do not increment i1. Instead, we only increment i2 to move to the next character in s2.\\n\\n-->for deletion we assume we have deleted s1[i1] so we increment by 1.\\n\\n-->for replacement we assume we replace s1[i1] is replaced by s2[i2] so we increment both i1 and i2.\\n\\n- **Base cases**\\n\\ni1>=n1 : we can understand this base cases by one example\\n\\ns1 : horse\\ns2 : ros\\n\\nsuppose we delete all the element of s1 so now our i1 is pointing to n1 and i2 is pointing to 0.as we have delete all the element of s1 now we have to insert all the element of s2. so number of operation should be size of s2 this base case will cover all of these scenario.\\n so it will return n2-0 which is n2. which is our answer.\\n\\ni2>=n2 : for same example \\n\\nsuppose we insert all the element of s2 into s1 but we haven\\'t deleted any of the element of s2.so now we have to delete all the old characters of n2 . this base cases will cover all of these kind of scenario. so it will return n1-0 which is n1. which is our answer.\\n\\n\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n1 * n2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n1 * n2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int helper(int i1,int i2,string s1,string s2,int n1,int n2,vector<vector<int>>& dp)\\n    {\\n        if(i1>=n1)\\n            return n2-i2;\\n        if(i2>=n2)\\n            return n1-i1;\\n        if(dp[i1][i2]!=-1)\\n            return dp[i1][i2];\\n        if(s1[i1]==s2[i2])\\n            return helper(i1+1,i2+1,s1,s2,n1,n2,dp);\\n        int insert=helper(i1,i2+1,s1,s2,n1,n2,dp);\\n        int del=helper(i1+1,i2,s1,s2,n1,n2,dp);\\n        int rep=helper(i1+1,i2+1,s1,s2,n1,n2,dp);\\n        return dp[i1][i2]=1+min(insert,min(del,rep));\\n    }\\n    int minDistance(string word1, string word2) {\\n        \\n        int n1=word1.size();\\n        int n2=word2.size();\\n        vector<vector<int>> dp(n1,vector<int>(n2,-1));\\n        return helper(0,0,word1,word2,n1,n2,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(int i1,int i2,string s1,string s2,int n1,int n2,vector<vector<int>>& dp)\\n    {\\n        if(i1>=n1)\\n            return n2-i2;\\n        if(i2>=n2)\\n            return n1-i1;\\n        if(dp[i1][i2]!=-1)\\n            return dp[i1][i2];\\n        if(s1[i1]==s2[i2])\\n            return helper(i1+1,i2+1,s1,s2,n1,n2,dp);\\n        int insert=helper(i1,i2+1,s1,s2,n1,n2,dp);\\n        int del=helper(i1+1,i2,s1,s2,n1,n2,dp);\\n        int rep=helper(i1+1,i2+1,s1,s2,n1,n2,dp);\\n        return dp[i1][i2]=1+min(insert,min(del,rep));\\n    }\\n    int minDistance(string word1, string word2) {\\n        \\n        int n1=word1.size();\\n        int n2=word2.size();\\n        vector<vector<int>> dp(n1,vector<int>(n2,-1));\\n        return helper(0,0,word1,word2,n1,n2,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3753229,
                "title": "tabulation-dp-c-easy-to-understand",
                "content": "### Please upvote if you found it useful!\\n\\n```\\n    int minDistance(string word1, string word2) {\\n        const int l1 = word1.size();\\n        const int l2 = word2.size();\\n        vector<vector<int>> dp(l1+1,vector<int>(l2+1,0));\\n        for(int i=0;i<=l1;++i){\\n            dp[i][0] = i;\\n        }\\n        for(int i=0;i<=l2;++i){\\n            dp[0][i] = i;\\n        }\\n        dp[0][0] = 0;\\n        for(int i=1;i<=l1;++i){\\n            for(int j=1;j<=l2;++j){\\n                if(word1[i-1]==word2[j-1]){dp[i][j] = dp[i-1][j-1];}\\n                else{dp[i][j] = 1+min({dp[i-1][j-1],dp[i-1][j],dp[i][j-1]});}\\n            }\\n        }\\n        return dp[l1][l2];\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n    int minDistance(string word1, string word2) {\\n        const int l1 = word1.size();\\n        const int l2 = word2.size();\\n        vector<vector<int>> dp(l1+1,vector<int>(l2+1,0));\\n        for(int i=0;i<=l1;++i){\\n            dp[i][0] = i;\\n        }\\n        for(int i=0;i<=l2;++i){\\n            dp[0][i] = i;\\n        }\\n        dp[0][0] = 0;\\n        for(int i=1;i<=l1;++i){\\n            for(int j=1;j<=l2;++j){\\n                if(word1[i-1]==word2[j-1]){dp[i][j] = dp[i-1][j-1];}\\n                else{dp[i][j] = 1+min({dp[i-1][j-1],dp[i-1][j],dp[i][j-1]});}\\n            }\\n        }\\n        return dp[l1][l2];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3296233,
                "title": "iterative-short-sweet-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDistance(string s1, string s2) {\\n        int m = s1.length(),n=s2.length(),i,j;\\n        vector<vector<int>> dp(m+1,vector<int>(n+1,0));\\n        for(i = 0; i <= m; i++){\\n            for(j = 0; j <= n; j++){\\n                if(i==0&&j==0){\\n                    dp[i][j] = 0;\\n                }else if(i==0){\\n                    dp[i][j] = j;\\n                }else if(j==0){\\n                    dp[i][j] = i;\\n                }\\n                else if(s1[i-1]==s2[j-1]){\\n                    dp[i][j] = dp[i-1][j-1];\\n                }else{\\n                    dp[i][j] = min({dp[i-1][j],dp[i][j-1],dp[i-1][j-1]})+1;\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string s1, string s2) {\\n        int m = s1.length(),n=s2.length(),i,j;\\n        vector<vector<int>> dp(m+1,vector<int>(n+1,0));\\n        for(i = 0; i <= m; i++){\\n            for(j = 0; j <= n; j++){\\n                if(i==0&&j==0){\\n                    dp[i][j] = 0;\\n                }else if(i==0){\\n                    dp[i][j] = j;\\n                }else if(j==0){\\n                    dp[i][j] = i;\\n                }\\n                else if(s1[i-1]==s2[j-1]){\\n                    dp[i][j] = dp[i-1][j-1];\\n                }else{\\n                    dp[i][j] = min({dp[i-1][j],dp[i][j-1],dp[i-1][j-1]})+1;\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235589,
                "title": "beginner-friendly-step-by-step-elaboration-with-video-solution-java",
                "content": "# Intuition\\nThe solution below is self explanatory. \\nIf you understand **Bangla**, you can see this video for step by step clear explanation:\\n\\nhttps://youtu.be/lWocPDgqFIo\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nRecursion With Memorization. Bottom Up Approach.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(M*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(M*N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code [Java]\\n```\\nclass Solution {\\n    Integer memo[][];\\n    int w1Len, w2Len;\\n    public int minDistance(String word1, String word2) {\\n        memo = new Integer[word1.length() + 1][word2.length() + 1];\\n        w1Len = word1.length();\\n        w2Len = word2.length();\\n        return minDistanceRecur(word1, word2, 0, 0);\\n    }\\n\\n    int minDistanceRecur(String word1, String word2, int word1Index, int word2Index) {\\n        if (word1Index == w1Len) {\\n            // return how many remaining for word2\\n            return w2Len-word2Index;\\n        }\\n        if (word2Index == w2Len) {\\n            // return how many remaining for word1\\n            return w1Len-word1Index;\\n        }\\n        if (memo[word1Index][word2Index] != null) {\\n            return memo[word1Index][word2Index];\\n        }\\n        int minEditDistance = 0;\\n        if (word1.charAt(word1Index) == word2.charAt(word2Index)) {\\n            minEditDistance = minDistanceRecur(word1, word2, word1Index + 1, word2Index + 1);\\n        }\\n        else {\\n            // insert in word1 or, delete from word1\\n            int insertOperation = minDistanceRecur(word1, word2, word1Index + 1, word2Index);\\n            // delete from word2 or, insert in word2\\n            int deleteOperation = minDistanceRecur(word1, word2, word1Index, word2Index+1);\\n            // replace so, the i\\'th index of both word1 and word2 becomes equal. Now we move to i+1 th index for both.\\n            int replaceOperation = minDistanceRecur(word1, word2, word1Index + 1, word2Index + 1);\\n            minEditDistance = Math.min(insertOperation, Math.min(deleteOperation, replaceOperation)) + 1;\\n        }\\n        memo[word1Index][word2Index] = minEditDistance;\\n        return minEditDistance;\\n    }\\n}\\n```\\n\\n![3549-pepepopcorn.png](https://assets.leetcode.com/users/images/3ec73dd1-878d-4bc2-bf53-1096d00472ab_1677485929.702025.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Integer memo[][];\\n    int w1Len, w2Len;\\n    public int minDistance(String word1, String word2) {\\n        memo = new Integer[word1.length() + 1][word2.length() + 1];\\n        w1Len = word1.length();\\n        w2Len = word2.length();\\n        return minDistanceRecur(word1, word2, 0, 0);\\n    }\\n\\n    int minDistanceRecur(String word1, String word2, int word1Index, int word2Index) {\\n        if (word1Index == w1Len) {\\n            // return how many remaining for word2\\n            return w2Len-word2Index;\\n        }\\n        if (word2Index == w2Len) {\\n            // return how many remaining for word1\\n            return w1Len-word1Index;\\n        }\\n        if (memo[word1Index][word2Index] != null) {\\n            return memo[word1Index][word2Index];\\n        }\\n        int minEditDistance = 0;\\n        if (word1.charAt(word1Index) == word2.charAt(word2Index)) {\\n            minEditDistance = minDistanceRecur(word1, word2, word1Index + 1, word2Index + 1);\\n        }\\n        else {\\n            // insert in word1 or, delete from word1\\n            int insertOperation = minDistanceRecur(word1, word2, word1Index + 1, word2Index);\\n            // delete from word2 or, insert in word2\\n            int deleteOperation = minDistanceRecur(word1, word2, word1Index, word2Index+1);\\n            // replace so, the i\\'th index of both word1 and word2 becomes equal. Now we move to i+1 th index for both.\\n            int replaceOperation = minDistanceRecur(word1, word2, word1Index + 1, word2Index + 1);\\n            minEditDistance = Math.min(insertOperation, Math.min(deleteOperation, replaceOperation)) + 1;\\n        }\\n        memo[word1Index][word2Index] = minEditDistance;\\n        return minEditDistance;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233545,
                "title": "python3-56-ms-faster-than-99-95-of-python3",
                "content": "![image](https://assets.leetcode.com/users/images/222526f8-ed70-43bf-a0c4-72c76ed4f424_1677429728.1260953.png)\\n```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        if word1 == word2:\\n            return 0\\n        if len(word1) == 0 or len(word2) == 0:\\n            return max(len(word1), len(word2))            \\n        w1 = list(word1)\\n        w2 = list(word2)        \\n        num = 0\\n        queue = deque()\\n        queue.append((0, 0))\\n        visited = set()\\n        while len(queue) > 0:\\n            for _ in range(len(queue)):\\n                i, j = queue.popleft()\\n                if (i, j) in visited:\\n                    continue\\n                visited.add((i, j))\\n                while i < len(w1) and j < len(w2) and w1[i] == w2[j]:\\n                    i += 1\\n                    j += 1\\n                if i == len(w1) and j == len(w2):\\n                    return num\\n                queue.append((i, j + 1))\\n                queue.append((i + 1, j + 1))\\n                queue.append((i + 1, j))\\n            num += 1\\n```\\nThis code is an implementation of a Breadth-First Search (BFS) algorithm to solve the minimum edit distance problem between two words. The minimum edit distance is defined as the minimum number of operations (insertions, deletions, substitutions) needed to transform one string into another.\\n\\nHere\\'s a step-by-step breakdown of the code:\\n1. The function minDistance takes two string arguments word1 and word2 and returns an integer representing the minimum edit distance between the two strings.\\n1. The function first checks if the two input strings are the same. If they are, the minimum edit distance is zero, and the function returns immediately.\\n1. If either of the input strings is empty, the minimum edit distance is the length of the non-empty string. Therefore, the function returns the maximum length between the two strings.\\n1. Next, the input strings are converted into lists of characters w1 and w2.\\n1. A variable num is initialized to zero. This variable will be used to keep track of the number of operations needed to transform word1 into word2.\\n1. A deque object queue is created to hold the coordinates of the current position in the matrix. The initial position is (0, 0), which corresponds to the first character of both strings.\\n1. A set visited is created to keep track of visited positions.\\n1. A while loop runs until the queue is empty. Within the loop, a for loop is used to process all the elements currently in the queue.\\n1. The i and j indices of the current position are obtained from the leftmost element of the queue, and the leftmost element is removed from the queue.\\n1. If the position (i, j) has been visited before, it is skipped.\\n1. The loop moves the i and j indices until the characters at positions w1[i] and w2[j] are different. This means that there is an operation needed at this position.\\n1. If both i and j have reached the end of their respective strings, the minimum edit distance has been found, and the function returns the current value of num.\\n1. The three possible edit operations (insertion, deletion, and substitution) are added to the queue.\\n1. The num variable is incremented at the end of each iteration of the while loop.\\n1. If the end of the function is reached without finding a solution, the function returns num, which represents the minimum number of operations needed to transform word1 into word2.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        if word1 == word2:\\n            return 0\\n        if len(word1) == 0 or len(word2) == 0:\\n            return max(len(word1), len(word2))            \\n        w1 = list(word1)\\n        w2 = list(word2)        \\n        num = 0\\n        queue = deque()\\n        queue.append((0, 0))\\n        visited = set()\\n        while len(queue) > 0:\\n            for _ in range(len(queue)):\\n                i, j = queue.popleft()\\n                if (i, j) in visited:\\n                    continue\\n                visited.add((i, j))\\n                while i < len(w1) and j < len(w2) and w1[i] == w2[j]:\\n                    i += 1\\n                    j += 1\\n                if i == len(w1) and j == len(w2):\\n                    return num\\n                queue.append((i, j + 1))\\n                queue.append((i + 1, j + 1))\\n                queue.append((i + 1, j))\\n            num += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232618,
                "title": "c-code-dp-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nApplication of DP\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m=word1.size();\\n        int n=word2.size();\\n        int dp[m+1][n+1];\\n        for(int i=0;i<=m;i++)\\n        {\\n            dp[i][0]=i;\\n        }\\n        for(int j=0;j<=n;j++)\\n        {\\n            dp[0][j]=j;\\n\\n        }\\n        \\n        for(int i=1;i<=m;i++)\\n        {\\n            for(int j=1;j<=n;j++)\\n            {\\n                if(word1[i-1]==word2[j-1])\\n                {\\n                    dp[i][j]=dp[i-1][j-1];\\n                    \\n                }\\n                else \\n                {   int mini=min(dp[i-1][j],dp[i][j-1]);\\n                    dp[i][j]=1+ min(dp[i-1][j-1],mini);\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m=word1.size();\\n        int n=word2.size();\\n        int dp[m+1][n+1];\\n        for(int i=0;i<=m;i++)\\n        {\\n            dp[i][0]=i;\\n        }\\n        for(int j=0;j<=n;j++)\\n        {\\n            dp[0][j]=j;\\n\\n        }\\n        \\n        for(int i=1;i<=m;i++)\\n        {\\n            for(int j=1;j<=n;j++)\\n            {\\n                if(word1[i-1]==word2[j-1])\\n                {\\n                    dp[i][j]=dp[i-1][j-1];\\n                    \\n                }\\n                else \\n                {   int mini=min(dp[i-1][j],dp[i][j-1]);\\n                    dp[i][j]=1+ min(dp[i-1][j-1],mini);\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231952,
                "title": "dynamic-programming",
                "content": "# Intuition & Approach\\nhttps://youtu.be/rOHeIwyAO9g\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int n = word1.size(), m = word2.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1));\\n\\n        for (int i = 0; i <= n; ++i) {\\n            for (int j = 0; j <= m; ++j) {\\n                if (!i || !j)\\n                    dp[i][j] = i + j;\\n                else if (word1[i - 1] == word2[j - 1])\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                else\\n                    dp[i][j] = 1 + min({\\n                        dp[i][j - 1],    // insert\\n                        dp[i - 1][j],    // delete\\n                        dp[i - 1][j - 1] // replace\\n                    });\\n            }\\n        }\\n\\n        return dp[n][m];\\n    }\\n};\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int n, m;\\n    vector<vector<int>> dp;\\n    \\n    int minDistance(string word1, string word2) {\\n        n = word1.size(), m = word2.size();\\n        dp = vector<vector<int>>(n + 1, vector<int>(m + 1, -1));\\n        \\n        return solve(n, m, word1, word2);\\n    }\\n    \\n    int solve(int i, int j, string &str1, string &str2) {\\n        if (!i || !j) return i + j;\\n        \\n        int &ret = dp[i][j];\\n        if (~ret) return ret;\\n        \\n        if (str1[i - 1] == str2[j - 1])\\n            return ret = solve(i - 1, j - 1, str1, str2);\\n\\n        return ret = 1 + min({\\n            solve(i, j - 1, str1, str2),    // insert\\n            solve(i - 1, j, str1, str2),    // delete\\n            solve(i - 1, j - 1, str1, str2) // replace\\n        });\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int n = word1.size(), m = word2.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1));\\n\\n        for (int i = 0; i <= n; ++i) {\\n            for (int j = 0; j <= m; ++j) {\\n                if (!i || !j)\\n                    dp[i][j] = i + j;\\n                else if (word1[i - 1] == word2[j - 1])\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                else\\n                    dp[i][j] = 1 + min({\\n                        dp[i][j - 1],    // insert\\n                        dp[i - 1][j],    // delete\\n                        dp[i - 1][j - 1] // replace\\n                    });\\n            }\\n        }\\n\\n        return dp[n][m];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int n, m;\\n    vector<vector<int>> dp;\\n    \\n    int minDistance(string word1, string word2) {\\n        n = word1.size(), m = word2.size();\\n        dp = vector<vector<int>>(n + 1, vector<int>(m + 1, -1));\\n        \\n        return solve(n, m, word1, word2);\\n    }\\n    \\n    int solve(int i, int j, string &str1, string &str2) {\\n        if (!i || !j) return i + j;\\n        \\n        int &ret = dp[i][j];\\n        if (~ret) return ret;\\n        \\n        if (str1[i - 1] == str2[j - 1])\\n            return ret = solve(i - 1, j - 1, str1, str2);\\n\\n        return ret = 1 + min({\\n            solve(i, j - 1, str1, str2),    // insert\\n            solve(i - 1, j, str1, str2),    // delete\\n            solve(i - 1, j - 1, str1, str2) // replace\\n        });\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231173,
                "title": "c-solution-with-explanation-let-s-code-it",
                "content": "# Upvote if you found this solution helpful\\uD83D\\uDD25\\n\\n# Approach\\nTo solve this question the first approach which comes to my mind is to explore all the paths and return the path with minimum number of steps.\\nTo solve these kind of questions try to first solve them using recursion and then use memoization to reduce the complexity.\\nWe can start comparing the strings from back, one character at a time.\\nThere are three main cases which we need to keep in mind:-\\n1. Replace the character\\n2. Insert a character\\n3. Remove a character\\n\\nBase condition:-\\n1. String 1 -> empty\\n2. String 2 -> empty\\n3. Both the characters are same\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int n1 = word1.size();\\n        int n2 = word2.size(); \\n        //initialize a dp vector\\n        vector<vector<int>> dp(n1, vector<int>(n2, -1));\\n\\n        //start comparing the strings from end\\n        return helper(n1-1, n2-1, word1, word2, dp);\\n    }\\n\\n    int helper(int i, int j, string &s1, string &s2,vector<vector<int>> &dp){\\n        //if string 1 is empty\\n        if(i < 0){\\n            return j+1;\\n        }\\n        //if string 2 is empty\\n        if(j < 0){\\n            return i+1;\\n        }\\n        //if both the characters are same\\n        if(s1[i] ==  s2[j]){\\n            return dp[i][j] = helper(i-1, j-1, s1, s2, dp);\\n        }\\n\\n        //if we have already calculate the result for corresponding i and j\\n        //there is no need to solve further and return the ans\\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n\\n        //if we remove an element\\n        int min1 = helper(i-1, j, s1, s2, dp);\\n        //if we insert an element\\n        int min2 = helper(i, j-1, s1, s2, dp);\\n        //if we replace an element\\n        int min3 = helper(i-1, j-1, s1, s2, dp);\\n\\n        return dp[i][j] = 1 + min(min(min1, min2), min3);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int n1 = word1.size();\\n        int n2 = word2.size(); \\n        //initialize a dp vector\\n        vector<vector<int>> dp(n1, vector<int>(n2, -1));\\n\\n        //start comparing the strings from end\\n        return helper(n1-1, n2-1, word1, word2, dp);\\n    }\\n\\n    int helper(int i, int j, string &s1, string &s2,vector<vector<int>> &dp){\\n        //if string 1 is empty\\n        if(i < 0){\\n            return j+1;\\n        }\\n        //if string 2 is empty\\n        if(j < 0){\\n            return i+1;\\n        }\\n        //if both the characters are same\\n        if(s1[i] ==  s2[j]){\\n            return dp[i][j] = helper(i-1, j-1, s1, s2, dp);\\n        }\\n\\n        //if we have already calculate the result for corresponding i and j\\n        //there is no need to solve further and return the ans\\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n\\n        //if we remove an element\\n        int min1 = helper(i-1, j, s1, s2, dp);\\n        //if we insert an element\\n        int min2 = helper(i, j-1, s1, s2, dp);\\n        //if we replace an element\\n        int min3 = helper(i-1, j-1, s1, s2, dp);\\n\\n        return dp[i][j] = 1 + min(min(min1, min2), min3);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230771,
                "title": "simple-tabulation-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m*n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m*n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) \\n    {\\n        int n=word1.size();\\n        int m=word2.size();\\n        int h[n+1][m+1];\\n        for(int i=0;i<m+1;i++)\\n        {\\n           h[0][i]=i;\\n        }\\n        for(int i=0;i<n+1;i++)\\n        {\\n           h[i][0]=i;\\n        }\\n        for(int i=1;i<n+1;i++)\\n        {\\n           for(int j=1;j<m+1;j++)\\n           {\\n              if(word1[i-1]==word2[j-1])\\n              {\\n                 h[i][j]=h[i-1][j-1];\\n              }\\n              else\\n              {\\n                 h[i][j]=min(1+h[i-1][j-1],min(1+h[i-1][j],1+h[i][j-1]));\\n              }\\n           }\\n        }\\n        return h[n][m];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) \\n    {\\n        int n=word1.size();\\n        int m=word2.size();\\n        int h[n+1][m+1];\\n        for(int i=0;i<m+1;i++)\\n        {\\n           h[0][i]=i;\\n        }\\n        for(int i=0;i<n+1;i++)\\n        {\\n           h[i][0]=i;\\n        }\\n        for(int i=1;i<n+1;i++)\\n        {\\n           for(int j=1;j<m+1;j++)\\n           {\\n              if(word1[i-1]==word2[j-1])\\n              {\\n                 h[i][j]=h[i-1][j-1];\\n              }\\n              else\\n              {\\n                 h[i][j]=min(1+h[i-1][j-1],min(1+h[i-1][j],1+h[i][j-1]));\\n              }\\n           }\\n        }\\n        return h[n][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181609,
                "title": "72-edit-distance-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- We use a 2D dp array dp with dimensions (m+1) x (n+1), where m and n are the lengths of word1 and word2, respectively.\\n- dp[i][j] represents the minimum number of operations required to convert the first i characters of word1 to the first j characters of word2.\\n- Initially, if one of the strings is empty, the min number of operations is inserting all characters from the other string, so we fill the first row and first column with i and j, respectively.\\n- For each i and j, we compare the characters word1[i-1] and word2[j-1]. If they are the same, we don\\'t need to perform any operation, so dp[i][j] takes the value of dp[i-1][j-1]. If they are different, we find the minimum of three operations: replace, insert, delete, and update dp[i][j] accordingly.\\n- Finally, the minimum number of operations required is stored in dp[m][n].\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m, n = len(word1), len(word2)\\n        dp = [[0 for j in range(n+1)] for i in range(m+1)]\\n        \\n        # if one of the strings is empty, the min number of operations is inserting all characters from the other string\\n        for i in range(1, m+1):\\n            dp[i][0] = i\\n        for j in range(1, n+1):\\n            dp[0][j] = j\\n        \\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                # if the characters are the same, we don\\'t need to perform any operation\\n                if word1[i-1] == word2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    # find the minimum of three operations: replace, insert, delete\\n                    dp[i][j] = min(dp[i-1][j-1]+1, dp[i-1][j]+1, dp[i][j-1]+1)\\n        \\n        return dp[m][n]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m, n = len(word1), len(word2)\\n        dp = [[0 for j in range(n+1)] for i in range(m+1)]\\n        \\n        # if one of the strings is empty, the min number of operations is inserting all characters from the other string\\n        for i in range(1, m+1):\\n            dp[i][0] = i\\n        for j in range(1, n+1):\\n            dp[0][j] = j\\n        \\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                # if the characters are the same, we don\\'t need to perform any operation\\n                if word1[i-1] == word2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    # find the minimum of three operations: replace, insert, delete\\n                    dp[i][j] = min(dp[i-1][j-1]+1, dp[i-1][j]+1, dp[i][j-1]+1)\\n        \\n        return dp[m][n]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3076353,
                "title": "c-easy-solution-tabulation-memoization",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:  \\n    int f(int i,int j,string w1, string w2,vector<vector<int>>&dp){\\n        if(i==0) return j;\\n        if(j==0) return i;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        if(w1[i-1]==w2[j-1]) return 0+f(i-1,j-1,w1,w2,dp);\\n        else return dp[i][j]= 1+min(f(i-1,j-1,w1,w2,dp),min(f(i,j-1,w1,w2,dp),f(i-1,j,w1,w2,dp)));\\n        \\n    }\\n    int minDistance(string w1, string w2) {\\n        int n=w1.size();\\n        int m=w2.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1));\\n        for(int i=0;i<=n;i++) dp[i][0]=i;\\n        for(int j=0;j<=m;j++) dp[0][j]=j;\\n        \\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(w1[i-1]==w2[j-1]) dp[i][j]=dp[i-1][j-1];\\n                else  dp[i][j]= 1+min(dp[i-1][j-1],min(dp[i][j-1],dp[i-1][j]));\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:  \\n    int f(int i,int j,string w1, string w2,vector<vector<int>>&dp){\\n        if(i==0) return j;\\n        if(j==0) return i;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        if(w1[i-1]==w2[j-1]) return 0+f(i-1,j-1,w1,w2,dp);\\n        else return dp[i][j]= 1+min(f(i-1,j-1,w1,w2,dp),min(f(i,j-1,w1,w2,dp),f(i-1,j,w1,w2,dp)));\\n        \\n    }\\n    int minDistance(string w1, string w2) {\\n        int n=w1.size();\\n        int m=w2.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1));\\n        for(int i=0;i<=n;i++) dp[i][0]=i;\\n        for(int j=0;j<=m;j++) dp[0][j]=j;\\n        \\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(w1[i-1]==w2[j-1]) dp[i][j]=dp[i-1][j-1];\\n                else  dp[i][j]= 1+min(dp[i-1][j-1],min(dp[i][j-1],dp[i-1][j]));\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050516,
                "title": "memoization-tabulation-space-optimization-c",
                "content": "# Memoization\\n```\\nclass Solution {\\n    int dfs(int i, int j, string &s, string &t, vector<vector<int>> &dp) {\\n        if(j == 0) return i;\\n        if(i == 0) return j;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        if(s[i - 1] == t[j - 1]) return dp[i][j] = dfs(i - 1, j - 1, s, t, dp);\\n        return dp[i][j] = 1 + min(dfs(i - 1, j - 1, s, t, dp), min(dfs(i, j - 1, s, t, dp), dfs(i - 1, j, s, t, dp)));\\n    }\\npublic:\\n    int minDistance(string s, string t) {\\n        int n = s.size(), m = t.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1, -1));\\n\\n        return dfs(n, m, s, t, dp);\\n    }\\n};\\n```\\n\\n# Tabulation\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string s, string t) {\\n        int n = s.size(), m = t.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1));\\n\\n        for(int i=0; i<=n; i++) dp[i][0] = i;\\n        for(int j=0; j<=m; j++) dp[0][j] = j;\\n\\n        for(int i=1; i<=n; i++) {\\n            for(int j=1; j<=m; j++) {\\n                if(s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j - 1];\\n                else dp[i][j] = 1 + min(dp[i - 1][j - 1], min(dp[i][j - 1], dp[i - 1][j]));\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```\\n\\n# Space Optimization\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string s, string t) {\\n        int n = s.size(), m = t.size();\\n        vector<int> dp(m + 1), temp(m + 1);\\n\\n        for(int j=0; j<=m; j++) dp[j] = j;\\n\\n        for(int i=1; i<=n; i++) {\\n            temp[0] = i;\\n            for(int j=1; j<=m; j++) {\\n                if(s[i - 1] == t[j - 1]) temp[j] = dp[j - 1];\\n                else temp[j] = 1 + min(dp[j - 1], min(temp[j - 1], dp[j]));\\n            }\\n            dp = temp;\\n        }\\n        return dp[m];\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int dfs(int i, int j, string &s, string &t, vector<vector<int>> &dp) {\\n        if(j == 0) return i;\\n        if(i == 0) return j;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        if(s[i - 1] == t[j - 1]) return dp[i][j] = dfs(i - 1, j - 1, s, t, dp);\\n        return dp[i][j] = 1 + min(dfs(i - 1, j - 1, s, t, dp), min(dfs(i, j - 1, s, t, dp), dfs(i - 1, j, s, t, dp)));\\n    }\\npublic:\\n    int minDistance(string s, string t) {\\n        int n = s.size(), m = t.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1, -1));\\n\\n        return dfs(n, m, s, t, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minDistance(string s, string t) {\\n        int n = s.size(), m = t.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1));\\n\\n        for(int i=0; i<=n; i++) dp[i][0] = i;\\n        for(int j=0; j<=m; j++) dp[0][j] = j;\\n\\n        for(int i=1; i<=n; i++) {\\n            for(int j=1; j<=m; j++) {\\n                if(s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j - 1];\\n                else dp[i][j] = 1 + min(dp[i - 1][j - 1], min(dp[i][j - 1], dp[i - 1][j]));\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minDistance(string s, string t) {\\n        int n = s.size(), m = t.size();\\n        vector<int> dp(m + 1), temp(m + 1);\\n\\n        for(int j=0; j<=m; j++) dp[j] = j;\\n\\n        for(int i=1; i<=n; i++) {\\n            temp[0] = i;\\n            for(int j=1; j<=m; j++) {\\n                if(s[i - 1] == t[j - 1]) temp[j] = dp[j - 1];\\n                else temp[j] = 1 + min(dp[j - 1], min(temp[j - 1], dp[j]));\\n            }\\n            dp = temp;\\n        }\\n        return dp[m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015013,
                "title": "3-java-solution-from-brute-force-to-top-down-to-bottom-up",
                "content": "It is quite similar to below leetcode problem ->\\nhttps://leetcode.com/problems/delete-operation-for-two-strings/solutions/3014824/3-java-solution-from-brute-force-to-top-down-to-bottomup/?orderBy=most_votes\\n\\nThe only addition here is that instead of two operations we have third also.\\n# Brute force (TLE)\\n```\\npublic int minDistance(String word1, String word2) {\\n    int n = word1.length();\\n    int m = word2.length();\\n    return helper(word1,word2,n-1,m-1);\\n}\\nprivate int helper(String s,String t,int i,int j) {\\n    if(i<0) {\\n        return j+1;\\n    }\\n    if(j<0) {\\n        return i+1;\\n    }\\n    if(s.charAt(i)==t.charAt(j)) {\\n        return helper(s,t,i-1,j-1);\\n    }\\n    return Math.min(helper(s,t,i-1,j),Math.min(helper(s,t,i-1,j-1),helper(s,t,i,j-1)))+1;\\n}\\n```\\n# TOP Down DP\\n```\\npublic int minDistance(String word1, String word2) {\\n    int n = word1.length();\\n    int m = word2.length();\\n    return helper(word1,word2,n-1,m-1,new Integer[n][m]);\\n}\\nprivate int helper(String s,String t,int i,int j,Integer[][] memo) {\\n    if(i<0) {\\n        return j+1;\\n    }\\n    if(j<0) {\\n        return i+1;\\n    }\\n    if(memo[i][j]!=null) {\\n        return memo[i][j];\\n    }\\n    if(s.charAt(i)==t.charAt(j)) {\\n        return memo[i][j]=helper(s,t,i-1,j-1,memo);\\n    }\\n    return memo[i][j]=Math.min(helper(s,t,i-1,j,memo),Math.min(helper(s,t,i-1,j-1,memo),helper(s,t,i,j-1,memo)))+1;\\n}\\n```\\n\\n# Bottom Up DP\\n```\\npublic int minDistance(String s, String t) {\\n    int n = s.length();\\n    int m = t.length();\\n    int[][] memo = new int[n+1][m+1];\\n    for(int i=0;i<=n;i++) {\\n        for(int j=0;j<=m;j++) {\\n            if(i==0||j==0) {\\n                memo[i][j]=i==0?j:i;\\n            }\\n            else if(s.charAt(i-1)==t.charAt(j-1)) {\\n                memo[i][j]=memo[i-1][j-1];\\n            } else {\\n                memo[i][j]=Math.min(memo[i][j-1],Math.min(memo[i-1][j],memo[i-1][j-1]))+1;\\n            }\\n        }\\n    }\\n    return memo[n][m];\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int minDistance(String word1, String word2) {\\n    int n = word1.length();\\n    int m = word2.length();\\n    return helper(word1,word2,n-1,m-1);\\n}\\nprivate int helper(String s,String t,int i,int j) {\\n    if(i<0) {\\n        return j+1;\\n    }\\n    if(j<0) {\\n        return i+1;\\n    }\\n    if(s.charAt(i)==t.charAt(j)) {\\n        return helper(s,t,i-1,j-1);\\n    }\\n    return Math.min(helper(s,t,i-1,j),Math.min(helper(s,t,i-1,j-1),helper(s,t,i,j-1)))+1;\\n}\\n```\n```\\npublic int minDistance(String word1, String word2) {\\n    int n = word1.length();\\n    int m = word2.length();\\n    return helper(word1,word2,n-1,m-1,new Integer[n][m]);\\n}\\nprivate int helper(String s,String t,int i,int j,Integer[][] memo) {\\n    if(i<0) {\\n        return j+1;\\n    }\\n    if(j<0) {\\n        return i+1;\\n    }\\n    if(memo[i][j]!=null) {\\n        return memo[i][j];\\n    }\\n    if(s.charAt(i)==t.charAt(j)) {\\n        return memo[i][j]=helper(s,t,i-1,j-1,memo);\\n    }\\n    return memo[i][j]=Math.min(helper(s,t,i-1,j,memo),Math.min(helper(s,t,i-1,j-1,memo),helper(s,t,i,j-1,memo)))+1;\\n}\\n```\n```\\npublic int minDistance(String s, String t) {\\n    int n = s.length();\\n    int m = t.length();\\n    int[][] memo = new int[n+1][m+1];\\n    for(int i=0;i<=n;i++) {\\n        for(int j=0;j<=m;j++) {\\n            if(i==0||j==0) {\\n                memo[i][j]=i==0?j:i;\\n            }\\n            else if(s.charAt(i-1)==t.charAt(j-1)) {\\n                memo[i][j]=memo[i-1][j-1];\\n            } else {\\n                memo[i][j]=Math.min(memo[i][j-1],Math.min(memo[i-1][j],memo[i-1][j-1]))+1;\\n            }\\n        }\\n    }\\n    return memo[n][m];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2966079,
                "title": "c-clean-and-easy-solution-dp-recursive-top-down-bottom-up-space-optimised",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n*m)\\n\\n- Space complexity:\\nO(m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(string &a, string &b, int i, int j){\\n        if(i >= a.size()){\\n            return (b.size()-j);\\n        }\\n        if(j >= b.size()){\\n            return (a.size()-i);\\n        }\\n\\n        int ans;\\n        if(a[i] == b[j]){\\n            ans = solve(a, b, i+1, j+1);\\n        }\\n        else{\\n            int ins = 1 + solve(a, b, i, j+1);\\n            int dlt = 1 + solve(a, b, i+1, j);\\n            int rep = 1 + solve(a, b, i+1, j+1);\\n\\n            ans = min(ins, min(dlt, rep));\\n        }\\n\\n        return ans;\\n    }\\n\\n    int solveMem(string &a, string &b, int i, int j, vector<vector<int>> &dp){\\n        if(i >= a.size()){\\n            return (b.size()-j);\\n        }\\n        if(j >= b.size()){\\n            return (a.size()-i);\\n        }\\n\\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n\\n        int ans;\\n        if(a[i] == b[j]){\\n            ans = solveMem(a, b, i+1, j+1, dp);\\n        }\\n        else{\\n            int ins = 1 + solveMem(a, b, i, j+1, dp);\\n            int dlt = 1 + solveMem(a, b, i+1, j, dp);\\n            int rep = 1 + solveMem(a, b, i+1, j+1, dp);\\n\\n            ans = min(ins, min(dlt, rep));\\n        }\\n\\n        return dp[i][j] = ans;\\n    }\\n\\n    int solveTab(string &a, string &b){\\n        vector<vector<int>> dp(a.size()+1, vector<int>(b.size()+1, 0));\\n\\n        for(int j = 0; j <= b.size(); j++){\\n            dp[a.size()][j] = b.size() - j; \\n        }\\n\\n        for(int i = 0; i <= a.size(); i++){\\n            dp[i][b.size()] = a.size() - i;\\n        }\\n\\n        for(int i = a.size()-1; i >= 0; i--){\\n            for(int j = b.size()-1; j >= 0; j--){\\n\\n                int ans;\\n                if(a[i] == b[j]){\\n                    ans = dp[i+1][j+1];\\n                }\\n                else{\\n                    int ins = 1 + dp[i][j+1];\\n                    int dlt = 1 + dp[i+1][j];\\n                    int rep = 1 + dp[i+1][j+1];\\n\\n                    ans = min(ins, min(dlt, rep));\\n                }\\n\\n                dp[i][j] = ans;\\n            }\\n        }\\n\\n        return dp[0][0];\\n    }\\n\\n    int solveSO(string a, string b){\\n\\n        vector<int> curr(b.size() + 1, 0);\\n        vector<int> next(b.size() + 1, 0);\\n\\n        for(int j = 0; j <= b.size(); j++){\\n            next[j] = b.size() - j;\\n        }\\n\\n        for(int i = a.size()-1; i >= 0; i--){\\n\\n            // Very Imp, This came from base case\\n            curr[b.size()] = a.size() - i;\\n\\n            for(int j = b.size()-1; j >= 0; j--){\\n\\n                int ans;\\n                if(a[i] == b[j]){\\n                    ans = next[j+1];\\n                }\\n                else{\\n                    int ins = 1 + curr[j+1];\\n                    int dlt = 1 + next[j];\\n                    int rep = 1 + next[j+1];\\n\\n                    ans = min(ins, min(dlt, rep));\\n                }\\n\\n                curr[j] = ans;\\n            }\\n\\n            next = curr;\\n        }\\n\\n        return curr[0];\\n    }\\n\\n    int minDistance(string a, string b) {\\n\\n        // vector<vector<int>> dp(a.size(), vector<int>(b.size(), -1));\\n        // return solveMem(a, b, 0, 0);\\n\\n        if(a.size() == 0) return b.size();\\n        if(b.size() == 0) return a.size();\\n\\n        return solveSO(a, b);\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int solve(string &a, string &b, int i, int j){\\n        if(i >= a.size()){\\n            return (b.size()-j);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2798723,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[505][505];\\n    string s, t;\\n\\n    int solve(int i, int j) {     \\n        if(i == s.size()) return t.size()-j;\\n        if(j == t.size()) return s.size()-i;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int ans;\\n        if(s[i] == t[j]) ans = solve(i+1, j+1);\\n        else {\\n            int deleted = 1 + solve(i+1, j);\\n            int inserted = 1 + solve(i, j+1);\\n            int replaced = 1 + solve(i+1, j+1);\\n            ans = min({deleted, inserted, replaced});\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    \\n    int minDistance(string word1, string word2) {\\n        memset(dp, -1, sizeof(dp));\\n        s = word1;\\n        t = word2;\\n        int ans = solve(0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[505][505];\\n    string s, t;\\n\\n    int solve(int i, int j) {     \\n        if(i == s.size()) return t.size()-j;\\n        if(j == t.size()) return s.size()-i;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int ans;\\n        if(s[i] == t[j]) ans = solve(i+1, j+1);\\n        else {\\n            int deleted = 1 + solve(i+1, j);\\n            int inserted = 1 + solve(i, j+1);\\n            int replaced = 1 + solve(i+1, j+1);\\n            ans = min({deleted, inserted, replaced});\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    \\n    int minDistance(string word1, string word2) {\\n        memset(dp, -1, sizeof(dp));\\n        s = word1;\\n        t = word2;\\n        int ans = solve(0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2793686,
                "title": "linear-python-solution-top-down-and-bottom-up",
                "content": "# Intuition\\nStep 1: Express the problem in terms of indexes.\\nStep 2: Explore all possibilities at a given index\\nStep 3: Return the minimum of the choices\\n\\n\\n# Approach\\n\\nAs we see there are overlapping subproblems in the recursive tree, \\n1.\\tCreate a dp array of size [N][M] where N and M are lengths of S1 and S2    respectively.\\n2.\\tWe initialize the dp array to -1.\\n3.\\tWhenever we want to find the answer of particular parameters (say f(ind1, ind2)), we first check whether the answer is  already calculated using the dp array (i.e. dp[ind][ind2]!= -1 ). If yes, simply return the value from the dp array\\n4.\\tIf not, then we are finding the answer for the given value for the first time, we will use the recursive relation as usual but before returning from the function, we will set dp[ind][ind2] to the solution we get.\\n\\n# Complexity\\n- Time complexity: O(n*m)\\n\\n\\n- Space complexity: O(n*M)\\n\\n\\n**Dp( Tabulation)**\\n# Code\\n```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        l1=len(word1)\\n        l2=len(word2)\\n        dp=[[-1]*(l1+1) for i in range(l2+1)]\\n        for i in range(l1+1):\\n            (dp[0])[i]=i\\n        for i in range(l2+1):\\n            (dp[i])[0]=i\\n\\n        for j in range(1,l2+1):\\n            for i in range(1,l1+1):\\n                if word1[i-1]==word2[j-1]:\\n                    (dp[j])[i]=(dp[j-1])[i-1]\\n                else:\\n                    insert=(dp[j-1])[i]\\n                    delete=(dp[j])[i-1]\\n                    replace=(dp[j-1])[i-1]\\n                    (dp[j])[i]=1+ min(insert,delete,replace)\\n                    \\n  \\n  \\n\\n\\n        return (dp[l2])[l1]\\n        \\n\\n\\n\\n\\n```\\n# Dp Memoization  Method\\n```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        def fun(word1,word2,i,j,dp):\\n            if i<0:\\n                return j+1\\n            if j<0:\\n                return i+1\\n            if (dp[j])[i]!=-1:\\n                return (dp[j])[i]\\n            elif word1[i]==word2[j]:\\n\\n                (dp[j])[i]=fun(word1,word2,i-1,j-1,dp)\\n                return (dp[j])[i]\\n            insert=fun(word1,word2,i,j-1,dp)\\n            delete=fun(word1,word2,i-1,j,dp)\\n            replace=fun(word1,word2,i-1,j-1,dp)\\n            (dp[j])[i]=1+ min(insert,delete,replace)\\n            return (dp[j])[i]\\n```\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        l1=len(word1)\\n        l2=len(word2)\\n        dp=[[-1]*(l1+1) for i in range(l2+1)]\\n        for i in range(l1+1):\\n            (dp[0])[i]=i\\n        for i in range(l2+1):\\n            (dp[i])[0]=i\\n\\n        for j in range(1,l2+1):\\n            for i in range(1,l1+1):\\n                if word1[i-1]==word2[j-1]:\\n                    (dp[j])[i]=(dp[j-1])[i-1]\\n                else:\\n                    insert=(dp[j-1])[i]\\n                    delete=(dp[j])[i-1]\\n                    replace=(dp[j-1])[i-1]\\n                    (dp[j])[i]=1+ min(insert,delete,replace)\\n                    \\n  \\n  \\n\\n\\n        return (dp[l2])[l1]\\n        \\n\\n\\n\\n\\n```\n```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        def fun(word1,word2,i,j,dp):\\n            if i<0:\\n                return j+1\\n            if j<0:\\n                return i+1\\n            if (dp[j])[i]!=-1:\\n                return (dp[j])[i]\\n            elif word1[i]==word2[j]:\\n\\n                (dp[j])[i]=fun(word1,word2,i-1,j-1,dp)\\n                return (dp[j])[i]\\n            insert=fun(word1,word2,i,j-1,dp)\\n            delete=fun(word1,word2,i-1,j,dp)\\n            replace=fun(word1,word2,i-1,j-1,dp)\\n            (dp[j])[i]=1+ min(insert,delete,replace)\\n            return (dp[j])[i]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2769402,
                "title": "java-solutions",
                "content": "```\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        int l1 = word1.length();\\n        int l2 = word2.length();\\n        int[][] dp = new int[l1+1][l2+1];\\n        \\n        // Base cases\\n        // Initializing First row\\n        for(int i=0; i <= l2; i++)\\n            dp[0][i] = i;        \\n        // Initializing First col\\n        for(int i=0; i <= l1; i++)\\n            dp[i][0] = i;\\n        \\n        for(int i=1; i <= l1; i++){\\n            for(int j=1; j <= l2; j++){\\n                if(word1.charAt(i-1) == word2.charAt(j-1))\\n                    dp[i][j] = dp[i-1][j-1];\\n                else\\n                    dp[i][j] = 1 + Math.min(dp[i-1][j-1], // replace\\n                                            Math.min(dp[i-1][j], // delete\\n                                                     dp[i][j-1]) // insert\\n                                           ); \\n            }\\n        }\\n        \\n        return dp[l1][l2];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        int l1 = word1.length();\\n        int l2 = word2.length();\\n        int[][] dp = new int[l1+1][l2+1];\\n        \\n        // Base cases\\n        // Initializing First row\\n        for(int i=0; i <= l2; i++)\\n            dp[0][i] = i;        \\n        // Initializing First col\\n        for(int i=0; i <= l1; i++)\\n            dp[i][0] = i;\\n        \\n        for(int i=1; i <= l1; i++){\\n            for(int j=1; j <= l2; j++){\\n                if(word1.charAt(i-1) == word2.charAt(j-1))\\n                    dp[i][j] = dp[i-1][j-1];\\n                else\\n                    dp[i][j] = 1 + Math.min(dp[i-1][j-1], // replace\\n                                            Math.min(dp[i-1][j], // delete\\n                                                     dp[i][j-1]) // insert\\n                                           ); \\n            }\\n        }\\n        \\n        return dp[l1][l2];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2766502,
                "title": "i-tried-to-give-a-proper-explaination-of-both-dp-and-recursive-sol",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(string s1,string s2,int m,int n,vector<vector<int>> & dp){\\n        if(m==0) return n;\\n        if(n==0) return m;\\n\\t\\t\\n        if(dp[m][n]!=-1) return dp[m][n];\\n\\t\\t\\n        if(s1[m-1]==s2[n-1])\\n            return dp[m-1][n-1]=solve(s1,s2,m-1,n-1,dp);\\n\\t\\t\\t\\n        if(s1[m-1]!=s2[n-1]){ \\n            dp[m-1][n-1]=solve(s1,s2,m-1,n-1,dp);\\n            dp[m][n-1]=solve(s1,s2,m,n-1,dp);\\n            dp[m-1][n]=solve(s1,s2,m-1,n,dp);\\n            return 1+min(dp[m-1][n],min(dp[m-1][n-1],dp[m][n-1]));}\\n\\t\\t\\t\\n        return 0;\\n    }\\npublic:\\n    int minDistance(string word1, string word2) {\\n         vector<vector<int>> vec(word1.size() +1 , vector<int> (word2.size()+1, -1));\\n        return solve(word1,word2,word1.size(),word2.size(),vec);\\n    }\\n};\\n\\n\\nclass Solution1 {//Recursive solution TLE\\npublic:\\n    int solve(string s1,string s2,int m,int n){\\n        if(m==0) return n;\\n        if(n==0) return m;\\n        if(s1[m-1]==s2[n-1]) return solve(s1,s2,m-1,n-1);\\n        if(s1[m-1]!=s2[n-1]) return 1+min(solve(s1,s2,m-1,n),min(solve(s1,s2,m-1,n-1),solve(s1,s2,m,n-1)));\\n        return 0;\\n    }\\npublic:\\n    int minDistance(string word1, string word2) {\\n        return solve(word1,word2,word1.size(),word2.size());\\n    }\\n};\\n```\\n\\n\\nA.) So to understand this solution you gotta know the recursive solution of this so lets see some cases here :\\n1.  what if we have any of the strings empty what would be the number of operation here obviously that would be      length of the other non empty array yepp it would be :                                                                                                                                                                       ` if(m==0) return n;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  if(n==0) return m;`\\n2. well now case 2 what if both of the last charectors are same obviously it would require no operations so yeah we move to the next charectors of the string without any count to the charectors : \\n                                              ` if(s1[m-1]==s2[n-1]) return solve(s1,s2,m-1,n-1);`\\n3. now now lets see the three operation : \\n\\t\\t\\t\\t\\t\\t\\tlets take first operation that would be delete :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\twhat if the 2 strings are : \"execun\"\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"execu\"\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tyeah you would delete that g so you would move to the                                                                                               left by one in 1st word : solve(s1,s2,m-1,n)\\n\\t\\t\\t\\t\\t\\t\\tlets take second operation that would be replace :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\twhat if the 2 strings are : \"execg\"\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"execu\"\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tyeah you would replace that g so you would move to the                                                                                             left by one in 1st word  and 2nd word: solve(s1,s2,m-1,n)\\n\\t\\t\\t\\t\\t\\t\\tlets take second operation that would be insert :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\twhat if the 2 strings are : \"exec\"\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"execu\"\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tyeah you would replace that g so you would move to the                                                                                             left by one in 1st word  and 2nd word: solve(s1,s2,m-1,n-1)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t    now that min is there cuz obviously we need to return that min operation value (just think it as the                           division of to sub problems )\\n\\t\\t\\t\\t\\t\\t\\nB.) and that code with dp vector we actually used that one to reduce the number of recursive calll\\nnote -  sorry if couldnt explain it that well any suggestions from you guys are really appreciable Thankyou!\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(string s1,string s2,int m,int n,vector<vector<int>> & dp){\\n        if(m==0) return n;\\n        if(n==0) return m;\\n\\t\\t\\n        if(dp[m][n]!=-1) return dp[m][n];\\n\\t\\t\\n        if(s1[m-1]==s2[n-1])\\n            return dp[m-1][n-1]=solve(s1,s2,m-1,n-1,dp);\\n\\t\\t\\t\\n        if(s1[m-1]!=s2[n-1]){ \\n            dp[m-1][n-1]=solve(s1,s2,m-1,n-1,dp);\\n            dp[m][n-1]=solve(s1,s2,m,n-1,dp);\\n            dp[m-1][n]=solve(s1,s2,m-1,n,dp);\\n            return 1+min(dp[m-1][n],min(dp[m-1][n-1],dp[m][n-1]));}\\n\\t\\t\\t\\n        return 0;\\n    }\\npublic:\\n    int minDistance(string word1, string word2) {\\n         vector<vector<int>> vec(word1.size() +1 , vector<int> (word2.size()+1, -1));\\n        return solve(word1,word2,word1.size(),word2.size(),vec);\\n    }\\n};\\n\\n\\nclass Solution1 {//Recursive solution TLE\\npublic:\\n    int solve(string s1,string s2,int m,int n){\\n        if(m==0) return n;\\n        if(n==0) return m;\\n        if(s1[m-1]==s2[n-1]) return solve(s1,s2,m-1,n-1);\\n        if(s1[m-1]!=s2[n-1]) return 1+min(solve(s1,s2,m-1,n),min(solve(s1,s2,m-1,n-1),solve(s1,s2,m,n-1)));\\n        return 0;\\n    }\\npublic:\\n    int minDistance(string word1, string word2) {\\n        return solve(word1,word2,word1.size(),word2.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2721083,
                "title": "o-n-space-dp-100-working-c-striver",
                "content": "These were the mistake done by mean while coding and I was trying to compare it with longest common subsequence \\uD83E\\uDD79. It take my lot of time.\\nEdit Distance\\n\\n*     1. no idea of basic case \\n         recursion code of 0 based indexing\\n*     2. if(i < 0 or j < 0) <- 0 => if(i < 0) <- j+1 , if(j < 0) <- i+1\\n*     3. <- 1 + common(i-1,j-1,s1,s2), min(common(i-1,j,s1,s2),common(i,j-1,s1,s2)) => min({ 1 + common(i-1,j,s1,s2) , 1 + common(i,j-1,s1,s2) , 1 + common(i-1,j-1,s1,s2) })\\n         recursion code of 1 based indexing\\n*     4. base conditon\\n         if(i == 0) <- j+1 , if(j == 0) <- i+1 => if(i == 0) <- j , if(j == 0) <- i\\n*     5. writing base condtion of optimize \\n          curr[0] = 1 => curr[0] = i;\\n\\n**Brute 0 Index : TLE**\\n\\n```\\n    // brute 0 index : TLE\\n        class Solution {\\n        public:\\n            int common(int i,int j,string &s1,string &s2){\\n                if(i < 0) return j+1;  // \\u2B50\\n                if(j < 0) return i+1;  // \\u2B50\\n                \\n                if(s1[i] == s2[j])\\n                    return 0 + common(i-1,j-1,s1,s2);  // \\u2B50\\n                else return min({ 1 + common(i-1,j,s1,s2) , 1 + common(i,j-1,s1,s2) , 1 + common(i-1,j-1,s1,s2) }); // \\u2B50\\n                        //              delete              insert                        replace\\n            }\\n            int minDistance(string s1, string s2) {\\n                int n = s1.size(),m = s2.size();\\n                return common(n-1,m-1,s1,s2);\\n            }\\n        };\\n```\\n    \\n**Brute 1 Index : TLE**\\n\\n```\\n// brute 1 indexing : TLE\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint common(int i,int j,string &s1,string &s2){\\n\\t\\t\\tif(i == 0) return j;  // \\u2B50\\n\\t\\t\\tif(j == 0) return i;  // \\u2B50\\n\\n\\t\\t\\tif(s1[i-1] == s2[j-1])\\n\\t\\t\\t\\treturn 0 + common(i-1,j-1,s1,s2);\\n\\t\\t\\telse return min({ 1 + common(i-1,j,s1,s2) , 1 + common(i,j-1,s1,s2) , 1 + common(i-1,j-1,s1,s2) });\\n\\t\\t\\t\\t\\t//              delete              insert                        replace\\n\\t\\t}\\n\\t\\tint minDistance(string s1, string s2) {\\n\\t\\t\\tint n = s1.size(),m = s2.size();\\n\\t\\t\\treturn common(n,m,s1,s2);\\n\\t\\t}\\n\\t};\\n```\\n\\n**Memorization**\\n\\n```\\n// memo\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint common(int i,int j,string &s1,string &s2,vector<vector<int>> &dp){\\n\\t\\t\\tif(i == 0) return j;\\n\\t\\t\\tif(j == 0) return i;\\n\\n\\t\\t\\tif(dp[i][j] != -1) return dp[i][j];\\n\\t\\t\\tif(s1[i-1] == s2[j-1])\\n\\t\\t\\t\\treturn dp[i][j] = 0 + common(i-1,j-1,s1,s2,dp);\\n\\t\\t\\telse return dp[i][j] = min({ 1 + common(i-1,j,s1,s2,dp) , 1 + common(i,j-1,s1,s2,dp) , 1 + common(i-1,j-1,s1,s2,dp) });\\n\\n\\t\\t}\\n\\t\\tint minDistance(string s1, string s2) {\\n\\t\\t\\tint n = s1.size(),m = s2.size();\\n\\t\\t\\tvector<vector<int>> dp(n+1,vector<int> (m+1,-1));\\n\\t\\t\\treturn common(n,m,s1,s2,dp);\\n\\t\\t}\\n\\t};\\n```\\n\\n**Tabulation**\\n\\n```\\n// tab\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minDistance(string s1, string s2) {\\n\\t\\t\\tint n = s1.size(),m = s2.size();\\n\\t\\t\\tvector<vector<int>> dp(n+1,vector<int> (m+1,0));\\n\\n\\t\\t\\tfor(int i=0;i<=n;i++) dp[i][0] = i;\\n\\t\\t\\tfor(int j=0;j<=m;j++) dp[0][j] = j;\\n\\n\\t\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\t\\tfor(int j=1;j<=m;j++){\\n\\t\\t\\t\\t\\tif(s1[i-1] == s2[j-1])\\n\\t\\t\\t\\t\\t\\tdp[i][j] = dp[i-1][j-1];\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tdp[i][j] = min({1 + dp[i-1][j],1 + dp[i][j-1], 1 + dp[i-1][j-1]});\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\treturn dp[n][m];\\n\\t\\t}\\n\\t};\\n```\\n\\n**Optimize**\\n\\n```\\n// optimize\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minDistance(string s1, string s2) {\\n\\t\\t\\tint n = s1.size(),m = s2.size();\\n\\t\\t\\tvector<int> dp(m+1,0),curr(m+1,0);\\n\\n\\t\\t\\t// curr[0] = 1; \\u2B50\\n\\t\\t\\tfor(int j=0;j<=m;j++) dp[j] = j;\\n\\n\\t\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\t\\tcurr[0] = i; // \\u2B50\\n\\t\\t\\t\\tfor(int j=1;j<=m;j++){\\n\\t\\t\\t\\t\\tif(s1[i-1] == s2[j-1])\\n\\t\\t\\t\\t\\t\\tcurr[j] = dp[j-1];\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tcurr[j] = min({1 + dp[j],1 + curr[j-1], 1 + dp[j-1]});\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdp = curr;\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\treturn dp[m];\\n\\t\\t}\\n\\t};\\n```\\n\\nHappy coding , please do upvote this post.\\n![image](https://assets.leetcode.com/users/images/749bbd83-b0bc-4cc8-8e29-916a9e8b4478_1666164359.9013052.gif)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n    // brute 0 index : TLE\\n        class Solution {\\n        public:\\n            int common(int i,int j,string &s1,string &s2){\\n                if(i < 0) return j+1;  // \\u2B50\\n                if(j < 0) return i+1;  // \\u2B50\\n                \\n                if(s1[i] == s2[j])\\n                    return 0 + common(i-1,j-1,s1,s2);  // \\u2B50\\n                else return min({ 1 + common(i-1,j,s1,s2) , 1 + common(i,j-1,s1,s2) , 1 + common(i-1,j-1,s1,s2) }); // \\u2B50\\n                        //              delete              insert                        replace\\n            }\\n            int minDistance(string s1, string s2) {\\n                int n = s1.size(),m = s2.size();\\n                return common(n-1,m-1,s1,s2);\\n            }\\n        };\\n```\n```\\n// brute 1 indexing : TLE\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint common(int i,int j,string &s1,string &s2){\\n\\t\\t\\tif(i == 0) return j;  // \\u2B50\\n\\t\\t\\tif(j == 0) return i;  // \\u2B50\\n\\n\\t\\t\\tif(s1[i-1] == s2[j-1])\\n\\t\\t\\t\\treturn 0 + common(i-1,j-1,s1,s2);\\n\\t\\t\\telse return min({ 1 + common(i-1,j,s1,s2) , 1 + common(i,j-1,s1,s2) , 1 + common(i-1,j-1,s1,s2) });\\n\\t\\t\\t\\t\\t//              delete              insert                        replace\\n\\t\\t}\\n\\t\\tint minDistance(string s1, string s2) {\\n\\t\\t\\tint n = s1.size(),m = s2.size();\\n\\t\\t\\treturn common(n,m,s1,s2);\\n\\t\\t}\\n\\t};\\n```\n```\\n// memo\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint common(int i,int j,string &s1,string &s2,vector<vector<int>> &dp){\\n\\t\\t\\tif(i == 0) return j;\\n\\t\\t\\tif(j == 0) return i;\\n\\n\\t\\t\\tif(dp[i][j] != -1) return dp[i][j];\\n\\t\\t\\tif(s1[i-1] == s2[j-1])\\n\\t\\t\\t\\treturn dp[i][j] = 0 + common(i-1,j-1,s1,s2,dp);\\n\\t\\t\\telse return dp[i][j] = min({ 1 + common(i-1,j,s1,s2,dp) , 1 + common(i,j-1,s1,s2,dp) , 1 + common(i-1,j-1,s1,s2,dp) });\\n\\n\\t\\t}\\n\\t\\tint minDistance(string s1, string s2) {\\n\\t\\t\\tint n = s1.size(),m = s2.size();\\n\\t\\t\\tvector<vector<int>> dp(n+1,vector<int> (m+1,-1));\\n\\t\\t\\treturn common(n,m,s1,s2,dp);\\n\\t\\t}\\n\\t};\\n```\n```\\n// tab\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minDistance(string s1, string s2) {\\n\\t\\t\\tint n = s1.size(),m = s2.size();\\n\\t\\t\\tvector<vector<int>> dp(n+1,vector<int> (m+1,0));\\n\\n\\t\\t\\tfor(int i=0;i<=n;i++) dp[i][0] = i;\\n\\t\\t\\tfor(int j=0;j<=m;j++) dp[0][j] = j;\\n\\n\\t\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\t\\tfor(int j=1;j<=m;j++){\\n\\t\\t\\t\\t\\tif(s1[i-1] == s2[j-1])\\n\\t\\t\\t\\t\\t\\tdp[i][j] = dp[i-1][j-1];\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tdp[i][j] = min({1 + dp[i-1][j],1 + dp[i][j-1], 1 + dp[i-1][j-1]});\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\treturn dp[n][m];\\n\\t\\t}\\n\\t};\\n```\n```\\n// optimize\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minDistance(string s1, string s2) {\\n\\t\\t\\tint n = s1.size(),m = s2.size();\\n\\t\\t\\tvector<int> dp(m+1,0),curr(m+1,0);\\n\\n\\t\\t\\t// curr[0] = 1; \\u2B50\\n\\t\\t\\tfor(int j=0;j<=m;j++) dp[j] = j;\\n\\n\\t\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\t\\tcurr[0] = i; // \\u2B50\\n\\t\\t\\t\\tfor(int j=1;j<=m;j++){\\n\\t\\t\\t\\t\\tif(s1[i-1] == s2[j-1])\\n\\t\\t\\t\\t\\t\\tcurr[j] = dp[j-1];\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tcurr[j] = min({1 + dp[j],1 + curr[j-1], 1 + dp[j-1]});\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdp = curr;\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\treturn dp[m];\\n\\t\\t}\\n\\t};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2469726,
                "title": "striver-code-python-solution-easy-explained",
                "content": "```\\n# Recursive \\nclass Solution:\\n    def f(self,i,j,s,t):\\n        if i<0:\\n            return j+1\\n        if j<0:\\n            return i+1\\n        if s[i]==t[j]:\\n            return 0 + self.f(i-1,j-1,s,t)\\n        else:\\n            return min((1+self.f(i-1,j,s,t)),(1+self.f(i,j-1,s,t)),(1+self.f(i-1,j-1,s,t)))\\n        \\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m=len(word1)\\n        n=len(word2)\\n        return self.f(m-1,n-1,word1,word2)\\n\\n     \\n#Memoisation \\n\\nclass Solution:\\n    def f(self,i,j,s,t,dp):\\n        if i<0:\\n            return j+1\\n        if j<0:\\n            return i+1\\n        if dp[i][j]!=-1:\\n            return dp[i][j]\\n        if s[i]==t[j]:\\n            dp[i][j]= 0 + self.f(i-1,j-1,s,t,dp)\\n        else:\\n            dp[i][j]= min((1+self.f(i-1,j,s,t,dp)),(1+self.f(i,j-1,s,t,dp)),(1+self.f(i-1,j-1,s,t,dp)))\\n        return dp[i][j]\\n        \\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m=len(word1)\\n        n=len(word2)\\n        dp=[[-1 for i in range(n)]for j in range(m)]\\n        return self.f(m-1,n-1,word1,word2,dp)\\n      \\n                         OR \\nclass Solution:\\n    def f(self,i,j,s,t,dp):\\n        if i==0:\\n            return j\\n        if j==0:\\n            return i\\n        if dp[i][j]!=-1:\\n            return dp[i][j]\\n        if s[i-1]==t[j-1]:\\n            dp[i][j]= 0 + self.f(i-1,j-1,s,t,dp)\\n        else:\\n            dp[i][j]= min((1+self.f(i-1,j,s,t,dp)),(1+self.f(i,j-1,s,t,dp)),(1+self.f(i-1,j-1,s,t,dp)))\\n        return dp[i][j]\\n        \\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m=len(word1)\\n        n=len(word2)\\n        dp=[[-1 for i in range(n+1)]for j in range(m+1)]\\n        return self.f(m,n,word1,word2,dp)\\n      \\n      \\n# Tabulation :\\n\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m=len(word1)\\n        n=len(word2)\\n        dp=[[0 for i in range(n+1)]for j in range(m+1)]\\n        \\n        for j in range(n+1):\\n            dp[0][j]=j\\n        for i in range(m+1):\\n            dp[i][0]=i\\n        \\n            \\n        for i in range(1,m+1):\\n            for j in range(1,n+1):\\n                if word1[i-1]==word2[j-1]:\\n                    dp[i][j]= 0 + dp[i-1][j-1]\\n                else:\\n                    dp[i][j]= 1 + min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])\\n        return dp[m][n]\\n\\n# Space Optimised :\\ndef editDistance(word1, word2) :\\n        m=len(word1)\\n        n=len(word2)\\n        prev=[0]*(n+1)\\n        for j in range(n+1):\\n            prev[j]=j\\n        for i in range(1,m+1):\\n            curr=[0]*(n+1)\\n            curr[0]=i\\n            for j in range(1,n+1):\\n                if word1[i-1]==word2[j-1]:\\n                    curr[j]=prev[j-1]\\n                else:\\n                    curr[j]= 1 + min(prev[j],min(curr[j-1],prev[j-1]))\\n            prev=curr\\n        return curr[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Combinatorics"
                ],
                "code": "```\\n# Recursive \\nclass Solution:\\n    def f(self,i,j,s,t):\\n        if i<0:\\n            return j+1\\n        if j<0:\\n            return i+1\\n        if s[i]==t[j]:\\n            return 0 + self.f(i-1,j-1,s,t)\\n        else:\\n            return min((1+self.f(i-1,j,s,t)),(1+self.f(i,j-1,s,t)),(1+self.f(i-1,j-1,s,t)))\\n        \\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m=len(word1)\\n        n=len(word2)\\n        return self.f(m-1,n-1,word1,word2)\\n\\n     \\n#Memoisation \\n\\nclass Solution:\\n    def f(self,i,j,s,t,dp):\\n        if i<0:\\n            return j+1\\n        if j<0:\\n            return i+1\\n        if dp[i][j]!=-1:\\n            return dp[i][j]\\n        if s[i]==t[j]:\\n            dp[i][j]= 0 + self.f(i-1,j-1,s,t,dp)\\n        else:\\n            dp[i][j]= min((1+self.f(i-1,j,s,t,dp)),(1+self.f(i,j-1,s,t,dp)),(1+self.f(i-1,j-1,s,t,dp)))\\n        return dp[i][j]\\n        \\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m=len(word1)\\n        n=len(word2)\\n        dp=[[-1 for i in range(n)]for j in range(m)]\\n        return self.f(m-1,n-1,word1,word2,dp)\\n      \\n                         OR \\nclass Solution:\\n    def f(self,i,j,s,t,dp):\\n        if i==0:\\n            return j\\n        if j==0:\\n            return i\\n        if dp[i][j]!=-1:\\n            return dp[i][j]\\n        if s[i-1]==t[j-1]:\\n            dp[i][j]= 0 + self.f(i-1,j-1,s,t,dp)\\n        else:\\n            dp[i][j]= min((1+self.f(i-1,j,s,t,dp)),(1+self.f(i,j-1,s,t,dp)),(1+self.f(i-1,j-1,s,t,dp)))\\n        return dp[i][j]\\n        \\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m=len(word1)\\n        n=len(word2)\\n        dp=[[-1 for i in range(n+1)]for j in range(m+1)]\\n        return self.f(m,n,word1,word2,dp)\\n      \\n      \\n# Tabulation :\\n\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m=len(word1)\\n        n=len(word2)\\n        dp=[[0 for i in range(n+1)]for j in range(m+1)]\\n        \\n        for j in range(n+1):\\n            dp[0][j]=j\\n        for i in range(m+1):\\n            dp[i][0]=i\\n        \\n            \\n        for i in range(1,m+1):\\n            for j in range(1,n+1):\\n                if word1[i-1]==word2[j-1]:\\n                    dp[i][j]= 0 + dp[i-1][j-1]\\n                else:\\n                    dp[i][j]= 1 + min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])\\n        return dp[m][n]\\n\\n# Space Optimised :\\ndef editDistance(word1, word2) :\\n        m=len(word1)\\n        n=len(word2)\\n        prev=[0]*(n+1)\\n        for j in range(n+1):\\n            prev[j]=j\\n        for i in range(1,m+1):\\n            curr=[0]*(n+1)\\n            curr[0]=i\\n            for j in range(1,n+1):\\n                if word1[i-1]==word2[j-1]:\\n                    curr[j]=prev[j-1]\\n                else:\\n                    curr[j]= 1 + min(prev[j],min(curr[j-1],prev[j-1]))\\n            prev=curr\\n        return curr[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2448115,
                "title": "easy-c-recursion-memoization-tabulation-space-optimization",
                "content": "Recursion : (gives TLE)\\nTC: Exponential\\nSC : O(n+m) ; where n = length of str1 and m=length of str2\\n\\nMemoization code: \\n```\\nclass Solution {\\npublic:\\n    int func(int i, int j, string s, string t, vector<vector<int>> &dp){\\n        //base cases\\n        if(i<0){\\n            //str1 exhausted\\n            return j+1;\\n        }\\n        if(j<0){\\n            //str2 exhausted\\n            return i+1;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        if(s[i]==t[j]){\\n            //if string chars match, do nothing, just shrink strings and continue checking\\n            return dp[i][j]=0+func(i-1, j-1, s, t, dp);\\n        }\\n        else{\\n            //if there\\'s no string matching\\n            //we can perform 3 operations -> insert, delete, replace\\n            int ins=1+func(i, j-1, s, t, dp);\\n            int del=1+func(i-1, j, s, t, dp);\\n            int repl=1+func(i-1, j-1, s, t, dp);\\n            return dp[i][j]=min(ins, min(del, repl));\\n        }\\n    }\\n    int minDistance(string word1, string word2) {\\n        int n=word1.length();\\n        int m=word2.length();\\n        vector<vector<int>> dp(n, vector<int> (m, -1));\\n        return func(n-1, m-1, word1, word2, dp);\\n    }\\n};\\n```\\nTC : O(n * m)\\nSC : O(n+m) + O(n * m) \\n\\nTo avoid the Auxiliary Stack Space(ASS), we further perform tabulation.\\n\\nTabulation code :\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string &s, string &t) {\\n        int n=s.length();\\n        int m=t.length();\\n        \\n        vector<vector<int>> dp(n+1, vector<int> (m+1, 0));\\n        for(int i=0; i<=n; i++){\\n            dp[i][0]=i;\\n        }\\n        for(int j=0; j<=m; j++){\\n            dp[0][j]=j;\\n        }\\n        \\n        for(int i=1; i<n+1; i++){\\n            for(int j=1; j<m+1; j++){\\n                if(s[i-1]==t[j-1]){\\n                    dp[i][j] = 0+dp[i-1][j-1];\\n                }\\n                else {\\n                    int ins=1+dp[i][j-1];\\n                    int del=1+dp[i-1][j];\\n                    int repl=1+dp[i-1][j-1];\\n                    dp[i][j] = min(ins, min(del, repl));\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```\\nTC : O(n * m)\\nSC : O(n * m) [eliminated extra auxiliary stack space]\\n\\nTo eliminate this extra auxiliary space, we carry out space optimization.\\n\\nSpace Optimization code :\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string &s, string &t) {\\n        int n=s.length();\\n        int m=t.length();\\n        \\n        vector<int> prev(m+1, 0), curr(m+1, 0);\\n        \\n        for(int j=0; j<=m; j++){\\n            prev[j]=j;\\n        }\\n        \\n        for(int i=1; i<n+1; i++){\\n            curr[0]=i;\\n            for(int j=1; j<m+1; j++){\\n                if(s[i-1]==t[j-1]){\\n                    curr[j] = 0+prev[j-1];\\n                }\\n                else {\\n                    int ins=1+curr[j-1];\\n                    int del=1+prev[j];\\n                    int repl=1+prev[j-1];\\n                    curr[j] = min(ins, min(del, repl));\\n                }\\n            }\\n            prev=curr;\\n        }\\n        return prev[m];\\n    }\\n};\\n```\\nTC : O(n * m) [2 nested for loops]\\nSC : O(m)\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int func(int i, int j, string s, string t, vector<vector<int>> &dp){\\n        //base cases\\n        if(i<0){\\n            //str1 exhausted\\n            return j+1;\\n        }\\n        if(j<0){\\n            //str2 exhausted\\n            return i+1;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        if(s[i]==t[j]){\\n            //if string chars match, do nothing, just shrink strings and continue checking\\n            return dp[i][j]=0+func(i-1, j-1, s, t, dp);\\n        }\\n        else{\\n            //if there\\'s no string matching\\n            //we can perform 3 operations -> insert, delete, replace\\n            int ins=1+func(i, j-1, s, t, dp);\\n            int del=1+func(i-1, j, s, t, dp);\\n            int repl=1+func(i-1, j-1, s, t, dp);\\n            return dp[i][j]=min(ins, min(del, repl));\\n        }\\n    }\\n    int minDistance(string word1, string word2) {\\n        int n=word1.length();\\n        int m=word2.length();\\n        vector<vector<int>> dp(n, vector<int> (m, -1));\\n        return func(n-1, m-1, word1, word2, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minDistance(string &s, string &t) {\\n        int n=s.length();\\n        int m=t.length();\\n        \\n        vector<vector<int>> dp(n+1, vector<int> (m+1, 0));\\n        for(int i=0; i<=n; i++){\\n            dp[i][0]=i;\\n        }\\n        for(int j=0; j<=m; j++){\\n            dp[0][j]=j;\\n        }\\n        \\n        for(int i=1; i<n+1; i++){\\n            for(int j=1; j<m+1; j++){\\n                if(s[i-1]==t[j-1]){\\n                    dp[i][j] = 0+dp[i-1][j-1];\\n                }\\n                else {\\n                    int ins=1+dp[i][j-1];\\n                    int del=1+dp[i-1][j];\\n                    int repl=1+dp[i-1][j-1];\\n                    dp[i][j] = min(ins, min(del, repl));\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minDistance(string &s, string &t) {\\n        int n=s.length();\\n        int m=t.length();\\n        \\n        vector<int> prev(m+1, 0), curr(m+1, 0);\\n        \\n        for(int j=0; j<=m; j++){\\n            prev[j]=j;\\n        }\\n        \\n        for(int i=1; i<n+1; i++){\\n            curr[0]=i;\\n            for(int j=1; j<m+1; j++){\\n                if(s[i-1]==t[j-1]){\\n                    curr[j] = 0+prev[j-1];\\n                }\\n                else {\\n                    int ins=1+curr[j-1];\\n                    int del=1+prev[j];\\n                    int repl=1+prev[j-1];\\n                    curr[j] = min(ins, min(del, repl));\\n                }\\n            }\\n            prev=curr;\\n        }\\n        return prev[m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2420042,
                "title": "c-memoization-tabulation",
                "content": "**Memoization**\\n```\\nint memoization(string& s,string& d,int sin,\\n                   int din,vector<vector<int>>& memory)\\n    {\\n        if(din==0)\\n            return sin;\\n        if(sin==0)\\n            return din;\\n        if(memory[sin][din]!=-1)\\n            return memory[sin][din];\\n        if(s[sin-1]==d[din-1])\\n            return memory[sin][din]=\\n            memoization(s,d,sin-1,din-1,memory);\\n        return memory[sin][din]=\\n            1+min(memoization(s,d,sin-1,din,memory),\\n                  min(\\n                 memoization(s,d,sin-1,din-1,memory),\\n                 memoization(s,d,sin,din-1,memory)));\\n    }\\n```\\n**Tabulation**\\n```\\n int tabulation(string& s,string& d,\\n                   vector<vector<int>>& dp)\\n    {\\n        int sin=s.length(),din=d.length();\\n        for(int i=0;i<=sin;i++)\\n            dp[i][0]=i;\\n        for(int j=0;j<=din;j++)\\n            dp[0][j]=j;\\n        for(int i=1;i<=sin;i++)\\n            for(int j=1;j<=din;j++)\\n            {\\n                if(s[i-1]==d[j-1])\\n                    dp[i][j]=dp[i-1][j-1];\\n                else\\n                    dp[i][j]=1+min(dp[i-1][j-1],\\n                                  min(dp[i][j-1],\\n                                     dp[i-1][j]));\\n            }\\n        return dp[sin][din];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint memoization(string& s,string& d,int sin,\\n                   int din,vector<vector<int>>& memory)\\n    {\\n        if(din==0)\\n            return sin;\\n        if(sin==0)\\n            return din;\\n        if(memory[sin][din]!=-1)\\n            return memory[sin][din];\\n        if(s[sin-1]==d[din-1])\\n            return memory[sin][din]=\\n            memoization(s,d,sin-1,din-1,memory);\\n        return memory[sin][din]=\\n            1+min(memoization(s,d,sin-1,din,memory),\\n                  min(\\n                 memoization(s,d,sin-1,din-1,memory),\\n                 memoization(s,d,sin,din-1,memory)));\\n    }\\n```\n```\\n int tabulation(string& s,string& d,\\n                   vector<vector<int>>& dp)\\n    {\\n        int sin=s.length(),din=d.length();\\n        for(int i=0;i<=sin;i++)\\n            dp[i][0]=i;\\n        for(int j=0;j<=din;j++)\\n            dp[0][j]=j;\\n        for(int i=1;i<=sin;i++)\\n            for(int j=1;j<=din;j++)\\n            {\\n                if(s[i-1]==d[j-1])\\n                    dp[i][j]=dp[i-1][j-1];\\n                else\\n                    dp[i][j]=1+min(dp[i-1][j-1],\\n                                  min(dp[i][j-1],\\n                                     dp[i-1][j]));\\n            }\\n        return dp[sin][din];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2350419,
                "title": "cpp-dp-memorization-inline-comments-simple",
                "content": "Please upvote if you understood !\\n\\n\\tint count(string &word1,string &word2,int i,int j,vector<vector<int>> &dp){\\n\\t\\t// if second string exhausted , return length of first string as min number of operatons.\\n        if(j<0) return i+1;\\n\\t\\t// if first string exhausted , return length of second string as min number of operatons.\\n        if(i<0) return j+1;\\n        \\n        if(dp[i][j]!= -1) return dp[i][j];\\n        \\n\\t\\t// if match found of characters just shift to previous index.\\n        if(word1[i]==word2[j]){\\n            return dp[i][j]=count(word1,word2,i-1,j-1,dp);\\n        }\\n        else{\\n\\t\\t\\t// insert operation\\n            int insert=1+count(word1,word2,i,j-1,dp);\\n\\t\\t\\t// delete operation\\n            int del=1+count(word1,word2,i-1,j,dp);\\n\\t\\t\\t// replace operation\\n            int replace=1+count(word1,word2,i-1,j-1,dp);\\n\\t\\t\\t// return minimum of the three operations.\\n            return dp[i][j]=min(insert,min(del,replace));\\n        }\\n    }\\n    \\n    int minDistance(string word1, string word2) {\\n        int n=word1.length();\\n        int m=word2.length();\\n        \\n        vector<vector<int>> dp(n,vector<int>(m,-1));\\n        \\n\\t\\t// start from end of strings\\n        return count(word1,word2,n-1,m-1,dp);\\n    }",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "Please upvote if you understood !\\n\\n\\tint count(string &word1,string &word2,int i,int j,vector<vector<int>> &dp){\\n\\t\\t// if second string exhausted , return length of first string as min number of operatons.\\n        if(j<0) return i+1;\\n\\t\\t// if first string exhausted , return length of second string as min number of operatons.\\n        if(i<0) return j+1;\\n        \\n        if(dp[i][j]!= -1) return dp[i][j];\\n        \\n\\t\\t// if match found of characters just shift to previous index.\\n        if(word1[i]==word2[j]){\\n            return dp[i][j]=count(word1,word2,i-1,j-1,dp);\\n        }\\n        else{\\n\\t\\t\\t// insert operation\\n            int insert=1+count(word1,word2,i,j-1,dp);\\n\\t\\t\\t// delete operation\\n            int del=1+count(word1,word2,i-1,j,dp);\\n\\t\\t\\t// replace operation\\n            int replace=1+count(word1,word2,i-1,j-1,dp);\\n\\t\\t\\t// return minimum of the three operations.\\n            return dp[i][j]=min(insert,min(del,replace));\\n        }\\n    }\\n    \\n    int minDistance(string word1, string word2) {\\n        int n=word1.length();\\n        int m=word2.length();\\n        \\n        vector<vector<int>> dp(n,vector<int>(m,-1));\\n        \\n\\t\\t// start from end of strings\\n        return count(word1,word2,n-1,m-1,dp);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2227245,
                "title": "c-dp-with-memoization-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        /* dp formulation\\n         *\\n         * dp[i][j] shall represent the minimum number of edits\\n         * required to get word1[:i] to match word2[:j].\\n         *\\n         * propagation:\\n         * if word1[i-1] == word2[j-1] then no extra edits are necessary,\\n         *     then dp[i][j] = dp[i-1][j-1]\\n         *\\n         * otherwise,\\n         * dp[i][j] = min(dp[i-1][j-1] + 1 // replacement\\n         *               ,dp[i][j-1] + 1 // insertion\\n         *               ,dp[i-1][j] + 1 // deletion\\n         *               )\\n         */\\n        int m = word1.size(); int n = word2.size();\\n        \\n        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));\\n        \\n        for (int i = 0; i <= m; i++)\\n        {\\n            for (int j = 0; j <= n; j++)\\n            {\\n                if (i == 0)\\n                {\\n                    dp[i][j] = j;\\n                }\\n                else if (j == 0)\\n                {\\n                    dp[i][j] = i;\\n                }\\n                else\\n                {\\n                    if (word1[i-1] == word2[j-1])\\n                    {\\n                        dp[i][j] = dp[i-1][j-1];\\n                    }\\n                    else\\n                    {\\n                        dp[i][j] = min(dp[i-1][j-1] + 1 // replacement\\n                                      ,min(dp[i][j-1] + 1 // insertion\\n                                          ,dp[i-1][j] + 1 // deletion\\n                                          )\\n                                      );\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp.back().back();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        /* dp formulation\\n         *\\n         * dp[i][j] shall represent the minimum number of edits\\n         * required to get word1[:i] to match word2[:j].\\n         *\\n         * propagation:\\n         * if word1[i-1] == word2[j-1] then no extra edits are necessary,\\n         *     then dp[i][j] = dp[i-1][j-1]\\n         *\\n         * otherwise,\\n         * dp[i][j] = min(dp[i-1][j-1] + 1 // replacement\\n         *               ,dp[i][j-1] + 1 // insertion\\n         *               ,dp[i-1][j] + 1 // deletion\\n         *               )\\n         */\\n        int m = word1.size(); int n = word2.size();\\n        \\n        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));\\n        \\n        for (int i = 0; i <= m; i++)\\n        {\\n            for (int j = 0; j <= n; j++)\\n            {\\n                if (i == 0)\\n                {\\n                    dp[i][j] = j;\\n                }\\n                else if (j == 0)\\n                {\\n                    dp[i][j] = i;\\n                }\\n                else\\n                {\\n                    if (word1[i-1] == word2[j-1])\\n                    {\\n                        dp[i][j] = dp[i-1][j-1];\\n                    }\\n                    else\\n                    {\\n                        dp[i][j] = min(dp[i-1][j-1] + 1 // replacement\\n                                      ,min(dp[i][j-1] + 1 // insertion\\n                                          ,dp[i-1][j] + 1 // deletion\\n                                          )\\n                                      );\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp.back().back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2223204,
                "title": "top-down-bottom-up-and-optimized-dynamic-programming",
                "content": "We can either inesrt, delete or replace a character in word1.\\n\\nOur goal is to get to word2 in minimum moves.\\n\\nWe don\\'t have to actually perform this operations, but logically trace the result by manipulating the pointers. Let\\'s have a pointer starting at 0 for word1, and starting at 0 for word2 (for bottom-up, it will be in reverse)\\n\\n* Replace - to replace we move both points and add 1\\n* Delete - to delete we move word1_pointer and don\\'t touch word2_pointer\\n* Insert - we move word2_pointer and don\\'t touch word1_pointer\\n\\nReturn the minimum out of these 3 options to solve each sub-problem.\\n\\n# Top-down memoized\\n```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        return self.find_distance(word1, 0, word2, 0, {})\\n\\n    def find_distance(self, word1, word1_pointer, word2, word2_pointer, memo):\\n        if word1_pointer == len(word1) and word2_pointer == len(word2):\\n            return 0\\n        \\n        if word1_pointer == len(word1) or word2_pointer == len(word2):\\n            return max(len(word1) - word1_pointer, len(word2) - word2_pointer)\\n        \\n        key = (word1_pointer, word2_pointer)\\n        if key in memo: return memo[key]\\n        \\n        word1_len = len(word1) - word1_pointer\\n        word2_len = len(word2) - word2_pointer\\n        \\n        if word1[word1_pointer] == word2[word2_pointer]:\\n            memo[key] = self.find_distance(word1, word1_pointer + 1, word2, word2_pointer + 1, memo)\\n        else:\\n            memo[key] =  1 + self.make_move(word1, word1_pointer, word2, word2_pointer, memo)\\n            \\n        return memo[key]\\n    \\n    \\n    def make_move(self, word1, word1_pointer, word2, word2_pointer, memo):\\n        return min(\\n                self.find_distance(word1, word1_pointer + 1, word2, word2_pointer + 1, memo), # update\\n                self.find_distance(word1, word1_pointer, word2, word2_pointer + 1, memo), # insert\\n                self.find_distance(word1, word1_pointer + 1, word2, word2_pointer, memo) # delete\\n            )\\n        \\n        \\n```\\n\\n\\n# Bottom-up DP\\n```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        word1_len = len(word1)\\n        word2_len = len(word2)\\n        \\n        dp = [[0 for _ in range(word1_len + 1)] for _ in range(word2_len + 1)]\\n        \\n        # Base cases\\n        \\n        # When no words = 0 moves needed\\n        dp[word2_len][word1_len] = 0\\n        \\n        # When one of the strings is missing. the other one\\'s length is required (either delete or insert)\\n        for r in range(word2_len - 1, -1, -1):\\n            dp[r][word1_len] = word2_len - r\\n            \\n        for c in range(word1_len - 1, -1, -1):\\n            dp[word2_len][c] = word1_len - c\\n        \\n        # Transitions\\n        for word2_p in range(word2_len - 1, -1, -1):\\n            for word1_p in range(word1_len -1, -1, -1):\\n                if word1[word1_p] == word2[word2_p]:\\n                    dp[word2_p][word1_p] = dp[word2_p+1][word1_p+1]\\n                else:\\n                    dp[word2_p][word1_p] = 1 + min(\\n                        dp[word2_p][word1_p+1], # delete\\n                        dp[word2_p+1][word1_p], # insert\\n                        dp[word2_p+1][word1_p+1] # replace\\n                    )\\n\\n        return dp[0][0]\\n```\\n\\n\\n# Optimized DP\\nSince we only need the last row in each iteration, we can trim to O(n) space complexity by only saving the last row result.\\n\\n\\n```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        word1_len = len(word1)\\n        word2_len = len(word2)\\n        \\n        \\n        # When one of the strings is missing. the other one\\'s length is required (either delete or insert)\\n        last_row = [0] * (word1_len+1)\\n            \\n        for c in range(word1_len - 1, -1, -1):\\n            last_row[c] = word1_len - c\\n        \\n        # Transitions\\n        for word2_p in range(word2_len - 1, -1, -1):\\n            cur_row = [0] * (word1_len+1)\\n            cur_row[word1_len] = word2_len - word2_p\\n            \\n            for word1_p in range(word1_len -1, -1, -1):\\n                if word1[word1_p] == word2[word2_p]:\\n                    cur_row[word1_p] = last_row[word1_p+1]\\n                else:\\n                    cur_row[word1_p] = 1 + min(\\n                        cur_row[word1_p+1], # delete\\n                        last_row[word1_p], # insert\\n                        last_row[word1_p+1] # replace\\n                    )\\n            \\n            last_row = cur_row\\n\\n        return last_row[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        return self.find_distance(word1, 0, word2, 0, {})\\n\\n    def find_distance(self, word1, word1_pointer, word2, word2_pointer, memo):\\n        if word1_pointer == len(word1) and word2_pointer == len(word2):\\n            return 0\\n        \\n        if word1_pointer == len(word1) or word2_pointer == len(word2):\\n            return max(len(word1) - word1_pointer, len(word2) - word2_pointer)\\n        \\n        key = (word1_pointer, word2_pointer)\\n        if key in memo: return memo[key]\\n        \\n        word1_len = len(word1) - word1_pointer\\n        word2_len = len(word2) - word2_pointer\\n        \\n        if word1[word1_pointer] == word2[word2_pointer]:\\n            memo[key] = self.find_distance(word1, word1_pointer + 1, word2, word2_pointer + 1, memo)\\n        else:\\n            memo[key] =  1 + self.make_move(word1, word1_pointer, word2, word2_pointer, memo)\\n            \\n        return memo[key]\\n    \\n    \\n    def make_move(self, word1, word1_pointer, word2, word2_pointer, memo):\\n        return min(\\n                self.find_distance(word1, word1_pointer + 1, word2, word2_pointer + 1, memo), # update\\n                self.find_distance(word1, word1_pointer, word2, word2_pointer + 1, memo), # insert\\n                self.find_distance(word1, word1_pointer + 1, word2, word2_pointer, memo) # delete\\n            )\\n        \\n        \\n```\n```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        word1_len = len(word1)\\n        word2_len = len(word2)\\n        \\n        dp = [[0 for _ in range(word1_len + 1)] for _ in range(word2_len + 1)]\\n        \\n        # Base cases\\n        \\n        # When no words = 0 moves needed\\n        dp[word2_len][word1_len] = 0\\n        \\n        # When one of the strings is missing. the other one\\'s length is required (either delete or insert)\\n        for r in range(word2_len - 1, -1, -1):\\n            dp[r][word1_len] = word2_len - r\\n            \\n        for c in range(word1_len - 1, -1, -1):\\n            dp[word2_len][c] = word1_len - c\\n        \\n        # Transitions\\n        for word2_p in range(word2_len - 1, -1, -1):\\n            for word1_p in range(word1_len -1, -1, -1):\\n                if word1[word1_p] == word2[word2_p]:\\n                    dp[word2_p][word1_p] = dp[word2_p+1][word1_p+1]\\n                else:\\n                    dp[word2_p][word1_p] = 1 + min(\\n                        dp[word2_p][word1_p+1], # delete\\n                        dp[word2_p+1][word1_p], # insert\\n                        dp[word2_p+1][word1_p+1] # replace\\n                    )\\n\\n        return dp[0][0]\\n```\n```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        word1_len = len(word1)\\n        word2_len = len(word2)\\n        \\n        \\n        # When one of the strings is missing. the other one\\'s length is required (either delete or insert)\\n        last_row = [0] * (word1_len+1)\\n            \\n        for c in range(word1_len - 1, -1, -1):\\n            last_row[c] = word1_len - c\\n        \\n        # Transitions\\n        for word2_p in range(word2_len - 1, -1, -1):\\n            cur_row = [0] * (word1_len+1)\\n            cur_row[word1_len] = word2_len - word2_p\\n            \\n            for word1_p in range(word1_len -1, -1, -1):\\n                if word1[word1_p] == word2[word2_p]:\\n                    cur_row[word1_p] = last_row[word1_p+1]\\n                else:\\n                    cur_row[word1_p] = 1 + min(\\n                        cur_row[word1_p+1], # delete\\n                        last_row[word1_p], # insert\\n                        last_row[word1_p+1] # replace\\n                    )\\n            \\n            last_row = cur_row\\n\\n        return last_row[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2179297,
                "title": "recursive-memoized-easy-to-understand-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = word1.length();\\n        int n = word2.length();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1, -1));\\n        return helper(word1, word2, m, n, dp);\\n    }\\n    int helper(string word1, string word2, int m, int n, vector<vector<int>> &dp) {\\n        if (m == 0) {\\n            return n; // need to remove n characters from word2\\n        }\\n        if (n == 0) {\\n            return m; // need to add m characters to word1\\n        }\\n        if (dp[m][n] != -1) {\\n            return dp[m][n]; // memoization\\n        }\\n        if (word1[m-1] == word2[n-1]) { // same character so do nothing\\n            return dp[m][n] = helper(word1, word2, m-1, n-1, dp);\\n        }\\n        // check min value from all cases\\n        int ans = INT_MAX;\\n        ans = min(ans, helper(word1, word2, m-1, n-1, dp)); // replace\\n        ans = min(ans, helper(word1, word2, m-1, n, dp)); // delete \\n        ans = min(ans, helper(word1, word2, m, n-1, dp)); // addition\\n        return dp[m][n] = 1 + ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = word1.length();\\n        int n = word2.length();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1, -1));\\n        return helper(word1, word2, m, n, dp);\\n    }\\n    int helper(string word1, string word2, int m, int n, vector<vector<int>> &dp) {\\n        if (m == 0) {\\n            return n; // need to remove n characters from word2\\n        }\\n        if (n == 0) {\\n            return m; // need to add m characters to word1\\n        }\\n        if (dp[m][n] != -1) {\\n            return dp[m][n]; // memoization\\n        }\\n        if (word1[m-1] == word2[n-1]) { // same character so do nothing\\n            return dp[m][n] = helper(word1, word2, m-1, n-1, dp);\\n        }\\n        // check min value from all cases\\n        int ans = INT_MAX;\\n        ans = min(ans, helper(word1, word2, m-1, n-1, dp)); // replace\\n        ans = min(ans, helper(word1, word2, m-1, n, dp)); // delete \\n        ans = min(ans, helper(word1, word2, m, n-1, dp)); // addition\\n        return dp[m][n] = 1 + ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2170099,
                "title": "c-easy-tabulation-top-down-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int n = word1.length();\\n        int m = word2.length();\\n        \\n        int dp[n+1][m+1]; \\n        \\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<=m;j++){\\n                if(i==0||j==0){\\n                    dp[i][j] = max(i,j);\\n                }\\n                else if(word1[i-1]==word2[j-1]){\\n                    dp[i][j]= dp[i-1][j-1];\\n                }\\n            else if(word1[i-1]!=word2[j-1]){\\n                dp[i][j]=min(dp[i-1][j],min(dp[i-1][j-1],dp[i][j-1])) +1;\\n              }\\n            }\\n        }\\n     return dp[n][m];  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int n = word1.length();\\n        int m = word2.length();\\n        \\n        int dp[n+1][m+1]; \\n        \\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<=m;j++){\\n                if(i==0||j==0){\\n                    dp[i][j] = max(i,j);\\n                }\\n                else if(word1[i-1]==word2[j-1]){\\n                    dp[i][j]= dp[i-1][j-1];\\n                }\\n            else if(word1[i-1]!=word2[j-1]){\\n                dp[i][j]=min(dp[i-1][j],min(dp[i-1][j-1],dp[i][j-1])) +1;\\n              }\\n            }\\n        }\\n     return dp[n][m];  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2110592,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution\\n{\\npublic:\\n\\tint ans[502][502];\\n\\tint dp(string s1, string s2, int n, int m)\\n\\t{\\n\\t\\tif (ans[n][m] != -1)\\n\\t\\t\\treturn ans[n][m];\\n\\t\\tif (n == 0)\\n\\t\\t\\treturn ans[n][m] = m;\\n\\t\\tif (m == 0)\\n\\t\\t\\treturn ans[n][m] = n;\\n\\t\\tif (s1[n - 1] == s2[m - 1])\\n\\t\\t\\treturn ans[n][m] = dp(s1, s2, n - 1, m - 1);\\n\\t\\telse\\n\\t\\t\\treturn ans[n][m] = 1 + min(dp(s1, s2, n - 1, m), min(dp(s1, s2, n, m - 1), dp(s1, s2, n - 1, m - 1)));\\n\\t}\\n\\tint minDistance(string s1, string s2)\\n\\t{\\n\\t\\tmemset(ans, -1, sizeof(ans));\\n\\t\\treturn dp(s1, s2, s1.length(), s2.length());\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n\\tint ans[502][502];\\n\\tint dp(string s1, string s2, int n, int m)\\n\\t{\\n\\t\\tif (ans[n][m] != -1)\\n\\t\\t\\treturn ans[n][m];\\n\\t\\tif (n == 0)\\n\\t\\t\\treturn ans[n][m] = m;\\n\\t\\tif (m == 0)\\n\\t\\t\\treturn ans[n][m] = n;\\n\\t\\tif (s1[n - 1] == s2[m - 1])\\n\\t\\t\\treturn ans[n][m] = dp(s1, s2, n - 1, m - 1);\\n\\t\\telse\\n\\t\\t\\treturn ans[n][m] = 1 + min(dp(s1, s2, n - 1, m), min(dp(s1, s2, n, m - 1), dp(s1, s2, n - 1, m - 1)));\\n\\t}\\n\\tint minDistance(string s1, string s2)\\n\\t{\\n\\t\\tmemset(ans, -1, sizeof(ans));\\n\\t\\treturn dp(s1, s2, s1.length(), s2.length());\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2025208,
                "title": "c-5-line-super-easy-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    int solve(string &a,string &b,int i,int j,int n,int m)\\n    {\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        if(i==n)return m-j;//if a string is traversed return whats left in b string\\n        if(j==m)return n-i;// and vice verse\\n        if(a[i]==b[j])return dp[i][j]=solve(a,b,i+1,j+1,n,m);//if a and b char are same do i++ and j++\\n        return dp[i][j]=1+min(solve(a,b,i+1,j,n,m),min(solve(a,b,i,j+1,n,m),solve(a,b,i+1,j+1,n,m)));\\n\\t\\t//else check for 3 conditions \\n\\t\\t1.del the character\\n\\t\\t2.insert the character\\n\\t\\t3.replace the character\\n\\t\\t//dry run these 3 conditions and u will get this one\\n    }\\n    int minDistance(string word1, string word2) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(word1,word2,0,0,word1.size(),word2.size());\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    int solve(string &a,string &b,int i,int j,int n,int m)\\n    {\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        if(i==n)return m-j;//if a string is traversed return whats left in b string\\n        if(j==m)return n-i;// and vice verse\\n        if(a[i]==b[j])return dp[i][j]=solve(a,b,i+1,j+1,n,m);//if a and b char are same do i++ and j++\\n        return dp[i][j]=1+min(solve(a,b,i+1,j,n,m),min(solve(a,b,i,j+1,n,m),solve(a,b,i+1,j+1,n,m)));\\n\\t\\t//else check for 3 conditions \\n\\t\\t1.del the character\\n\\t\\t2.insert the character\\n\\t\\t3.replace the character\\n\\t\\t//dry run these 3 conditions and u will get this one\\n    }\\n    int minDistance(string word1, string word2) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(word1,word2,0,0,word1.size(),word2.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2005424,
                "title": "c-dp-o-m-n-easiest-explanation-so-far",
                "content": "\\n\\n \\xA0  int minDistance(string word1, string word2) {\\n        int m= word1.length(), n= word2.length();\\n        vector<vector<int>>tab(m+1, vector<int>(n+1));\\n        \\n        //if word1 is empty, then we have to add all n chars of word2\\n        if(m== 0)\\n            return n;\\n        //if word2 is empty, then we have to delete all m chars of word1\\n        if(n== 0)\\n            return m;\\n        \\n        for(int i =0;i<=m;i++){\\n            for(int j = 0;j<=n;j++){\\n                \\n                /*       g e s e k\\n                     g   0 1 2 3 4\\n                     e   1\\n                     e   2\\n                     k   3\\n                     */\\n                //you can see from dp table, word1 = g(i= 0), (and word2 = g(j ==0))\\n                //so g== g, we need 0 operation, as j== 1 word1 = g & word2 =ge\\n                //g--> ge need 1 operations(addition of e)\\n                //0th row = 0 1 2 3...j\\n                if(i== 0)\\n                    tab[i][j] = j;\\n                else if(j == 0)\\n                    tab[i][j] = i;\\n                //chars are same no operation required\\n                else if(word1[i-1] == word2[j-1])\\n                    tab[i][j] = tab[i-1][j-1];\\n                else{\\n    \\t                tab[i][j] = 1+min(tab[i][j-1], min(tab[i-1][j], tab[i-1][j-1]));\\n                    \\n                        /*insert: word1 = geek, word2 = gesek\\n                        at i = 1 & j= 2, we are ignoring s (by j-1) of word2 and adding\\n                        1 as insret operation, we are not actually adding, we are assuming\\n                        these operations only, remove and replace can be assumed */\\n                }\\n            }\\n            \\n        }\\n        return tab[m][n];\\n    }\\n};",
                "solutionTags": [],
                "code": "\\n\\n \\xA0  int minDistance(string word1, string word2) {\\n        int m= word1.length(), n= word2.length();\\n        vector<vector<int>>tab(m+1, vector<int>(n+1));\\n        \\n        //if word1 is empty, then we have to add all n chars of word2\\n        if(m== 0)\\n            return n;\\n        //if word2 is empty, then we have to delete all m chars of word1\\n        if(n== 0)\\n            return m;\\n        \\n        for(int i =0;i<=m;i++){\\n            for(int j = 0;j<=n;j++){\\n                \\n                /*       g e s e k\\n                     g   0 1 2 3 4\\n                     e   1\\n                     e   2\\n                     k   3\\n                     */\\n                //you can see from dp table, word1 = g(i= 0), (and word2 = g(j ==0))\\n                //so g== g, we need 0 operation, as j== 1 word1 = g & word2 =ge\\n                //g--> ge need 1 operations(addition of e)\\n                //0th row = 0 1 2 3...j\\n                if(i== 0)\\n                    tab[i][j] = j;\\n                else if(j == 0)\\n                    tab[i][j] = i;\\n                //chars are same no operation required\\n                else if(word1[i-1] == word2[j-1])\\n                    tab[i][j] = tab[i-1][j-1];\\n                else{\\n    \\t                tab[i][j] = 1+min(tab[i][j-1], min(tab[i-1][j], tab[i-1][j-1]));\\n                    \\n                        /*insert: word1 = geek, word2 = gesek\\n                        at i = 1 & j= 2, we are ignoring s (by j-1) of word2 and adding\\n                        1 as insret operation, we are not actually adding, we are assuming\\n                        these operations only, remove and replace can be assumed */\\n                }\\n            }\\n            \\n        }\\n        return tab[m][n];\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1945530,
                "title": "c-100-faster-all-approach-included",
                "content": "Suggestion : \\nTrust me if you were able to write the recurrence then the problem is just a cake for you. So now Try yourself and find the recurrence to solve this problem. If you were not able to figure out then no worries please read the full editorial. I will try to make it super easy for you. \\nLets dive deep what the problem is all about ? and note the imp points:\\n1. convert string S1 to string S2 \\n2. operation allowed are:\\n  a. insertion \\n  b. deletion \\n  c. replace \\n3. return min number of operations \\n\\nNow lets observe the worst case : \\nif s1 = \"horse\" and s2= \"ros\" then what my mind says is that delete every character of s1 and then insert every character of s2. so max number of operations are : N(length of s1) + M (length of s2). \\nnow optimized this; \\n**One observation i can deduce is that if only insertion and deletion is allowed then this question will be similar to \"min number of insertion/deletion to convert s1 to s2\"** which is solved using the concept of lcs. \\nbut till now we have not consider the importance of replace operation. \\n\\nNow lets try to form the solution together. \\n\\nif you observe there can be only 2 cases formed (like every sting dp question)\\n**case 1:**\\nif s1[i]==s2[j] then no operation is require hence **F(i,j) = F(i-1,j-1)**\\n**case 2:**\\nif s1[i]!=s2[j] so there are 3 possibilites as given in question now if you were able to write the recurrence for each condition and take the min out of them . Hurrah!! you are done with the solution. Congrats!! . \\n1. replace \\n**F(i,j) = F(i-1,j-1)**\\n2. delete \\n**F(i,j) = F(i-1,j)**\\n3. insert\\n**F(i,j)= F(i,j-1)**\\nans = min (replace , delete, insert)\\n\\nI hope you understand the approach. Lets see code of all approaches\\n**1. Memoization**\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int n= word1.size();\\n        int m= word2.size();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        return solve(n-1,m-1,word1,word2,dp);\\n    }\\n    int solve(int i,int j,string word1,string word2,vector<vector<int>> &dp){\\n        \\n        if(i<0) return j+1;\\n        if(j<0) return i+1;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        if(word1[i]==word2[j]){\\n            return dp[i][j]=solve(i-1,j-1,word1,word2,dp);\\n        }\\n        \\n            char c= word1[i];\\n            word1[i]=word2[j];\\n            int rep= 1 + solve(i-1,j-1,word1,word2,dp);\\n            word1[i]=c;\\n            int del= 1+ solve(i-1,j,word1,word2,dp);\\n            int ins= 1+ solve(i,j-1,word1,word2,dp);\\n        return dp[i][j]=min(rep,min(del,ins));;\\n    }\\n};\\n```\\n**Time Complexity: O(n*m)\\nSpace Complexity: O(stack space) + O(n*m)**\\n\\n**2. Tabulation**\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int n= word1.size();\\n        int m= word2.size();\\n        int dp[n+1][m+1];\\n        for(int i=0;i<=m;i++){\\n            dp[0][i]= i;\\n        }\\n        for(int i=0;i<=n;i++){\\n            dp[i][0]=i;\\n        }\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(word1[i-1]==word2[j-1]) dp[i][j]= dp[i-1][j-1];\\n                else {\\n                    dp[i][j]= 1 + min(dp[i-1][j-1],min(dp[i-1][j],dp[i][j-1]));\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n```\\n**Time Complexity: O(n*m)\\nSpace Complexity: O(n*m)\\nRuntime : 0ms (100% faster)**\\n\\n**3. Space Optimization**\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int n= word1.size();\\n        int m= word2.size();\\n        int prev[m+1],temp[m+1];\\n        for(int i=0;i<=m;i++){\\n            prev[i]= i;\\n        }\\n        for(int i=1;i<=n;i++){\\n            temp[0]=i;\\n            for(int j=1;j<=m;j++){\\n           \\n                if(word1[i-1]==word2[j-1]) temp[j]= prev[j-1];\\n                else {\\n                    temp[j]= 1 + min(prev[j-1],min(prev[j],temp[j-1]));\\n                }\\n            }\\n            for(int i=0;i<=m;i++) prev[i]= temp[i];\\n        }\\n        return prev[m];\\n    }\\n \\n};\\n```\\n**Time Complexity: O(n*m)\\nSpace Complexity: O(m)**\\n\\n**Upvote If you like my approach.**\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int n= word1.size();\\n        int m= word2.size();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        return solve(n-1,m-1,word1,word2,dp);\\n    }\\n    int solve(int i,int j,string word1,string word2,vector<vector<int>> &dp){\\n        \\n        if(i<0) return j+1;\\n        if(j<0) return i+1;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        if(word1[i]==word2[j]){\\n            return dp[i][j]=solve(i-1,j-1,word1,word2,dp);\\n        }\\n        \\n            char c= word1[i];\\n            word1[i]=word2[j];\\n            int rep= 1 + solve(i-1,j-1,word1,word2,dp);\\n            word1[i]=c;\\n            int del= 1+ solve(i-1,j,word1,word2,dp);\\n            int ins= 1+ solve(i,j-1,word1,word2,dp);\\n        return dp[i][j]=min(rep,min(del,ins));;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int n= word1.size();\\n        int m= word2.size();\\n        int dp[n+1][m+1];\\n        for(int i=0;i<=m;i++){\\n            dp[0][i]= i;\\n        }\\n        for(int i=0;i<=n;i++){\\n            dp[i][0]=i;\\n        }\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(word1[i-1]==word2[j-1]) dp[i][j]= dp[i-1][j-1];\\n                else {\\n                    dp[i][j]= 1 + min(dp[i-1][j-1],min(dp[i-1][j],dp[i][j-1]));\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n```\n```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int n= word1.size();\\n        int m= word2.size();\\n        int prev[m+1],temp[m+1];\\n        for(int i=0;i<=m;i++){\\n            prev[i]= i;\\n        }\\n        for(int i=1;i<=n;i++){\\n            temp[0]=i;\\n            for(int j=1;j<=m;j++){\\n           \\n                if(word1[i-1]==word2[j-1]) temp[j]= prev[j-1];\\n                else {\\n                    temp[j]= 1 + min(prev[j-1],min(prev[j],temp[j-1]));\\n                }\\n            }\\n            for(int i=0;i<=m;i++) prev[i]= temp[i];\\n        }\\n        return prev[m];\\n    }\\n \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1929959,
                "title": "c-memoization-recursion-with-explanation",
                "content": "In this question you just have 3 options for non matching character and no need to do any operation for matching character.\\n\\nthe main key point of this question is base case.\\n\\nthere are 3 base case\\'s \\n1. when we have reached the end of both the strings, return 0.\\n2. when we have reached end of any of the string just return the diff of i and j plus one that it.\\n\\nhope understand.\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[505][505];\\n    int rec(string word1,string word2,int i,int j)\\n    {\\n        if(i<0 && j<0)\\n        {\\n            return 0;\\n        }\\n        if(i<0 && j>=0)\\n        {\\n            return j+1;\\n        }\\n        if(i>=0 && j<0)\\n        {\\n            return i+1;\\n        }\\n        if(dp[i][j]!=-1)\\n        {\\n            return dp[i][j];\\n        }\\n        int ans=0;\\n        if(word1[i]!=word2[j])\\n        {\\n            int a=1+rec(word1,word2,i,j-1);\\n            int b=1+rec(word1,word2,i-1,j);\\n            int c=1+rec(word1,word2,i-1,j-1);\\n            ans=min(a,min(b,c));\\n        }else\\n        {\\n            ans=rec(word1,word2,i-1,j-1);\\n        }\\n        return dp[i][j]=ans;\\n    }\\n    int minDistance(string word1, string word2) {\\n        memset(dp,-1,sizeof dp);\\n        int n=word1.size();\\n        int m=word2.size();\\n        if(n==0 || m==0)\\n        {\\n            return abs(m-n);\\n        }\\n        return rec(word1,word2,n,m);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[505][505];\\n    int rec(string word1,string word2,int i,int j)\\n    {\\n        if(i<0 && j<0)\\n        {\\n            return 0;\\n        }\\n        if(i<0 && j>=0)\\n        {\\n            return j+1;\\n        }\\n        if(i>=0 && j<0)\\n        {\\n            return i+1;\\n        }\\n        if(dp[i][j]!=-1)\\n        {\\n            return dp[i][j];\\n        }\\n        int ans=0;\\n        if(word1[i]!=word2[j])\\n        {\\n            int a=1+rec(word1,word2,i,j-1);\\n            int b=1+rec(word1,word2,i-1,j);\\n            int c=1+rec(word1,word2,i-1,j-1);\\n            ans=min(a,min(b,c));\\n        }else\\n        {\\n            ans=rec(word1,word2,i-1,j-1);\\n        }\\n        return dp[i][j]=ans;\\n    }\\n    int minDistance(string word1, string word2) {\\n        memset(dp,-1,sizeof dp);\\n        int n=word1.size();\\n        int m=word2.size();\\n        if(n==0 || m==0)\\n        {\\n            return abs(m-n);\\n        }\\n        return rec(word1,word2,n,m);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888200,
                "title": "explained-step-by-step-description-and-solution-easy-to-understand-answering-the-why",
                "content": "\\nThe post will follow the flow: Choices -> Examples -> Recurrence Relation -> Filling out table -> Solution\\n\\n*Sorry if there are any typos but comment and I\\'ll try to make edits*\\n\\n# Edit Distance\\nTo begin working on really any dynamic programming problem you want to think about those sub problems and about what decisions we can make throughout the process of solving the problem. The decisions we are able to make at any given letter are in this problem explicitly given to us as the following three:\\n\\n1. We can **delete** a letter\\n2. We can **insert** a letter\\n3. We can **replace** a letter\\n\\nLets look at some examples to get a better grasp of what exactly those decisions look like\\n\\n```\\nInput: word1 = \"java\", word2 = \"swift\"\\n```\\nThroughout these decisions our focus will be on the last letters of each string. Our larger goal is to get the two words to be the same but we will focus on letter by letter starting from the end. \\n\\n**Decision 1: We can delete a letter**\\n![image](https://assets.leetcode.com/users/images/fa4261a8-fff4-410a-88f9-7dd78f25b838_1648371955.8076708.png)\\nWe are trying to get \"java\" to become \"swift.\" If we can delete a letter from \"java\" and our goal is to get the last letter to equal the last of \"swift\" then we will remove the letter \\'a\\'. If we delete the last letter in \"java\" it now becomes \"jav\" but \"jav\" still isn\\'t equal to swift. So our subproblem now is to get \"jav\" to become \"swift.\" Notice how we chose to make a decision and now we have a sub problem.\\n\\n\\n**Decision 2: We can insert a letter**\\n![image](https://assets.leetcode.com/users/images/af9d5024-5ef7-4d17-b378-96d727f90816_1648372005.563788.png)\\nWe are trying to get \"java\" to become \"swift.\" If we can insert a letter into \"java\" and our goal is to get the last letter to equal the last letter of \"swift\" then the letter we will insert will be a \\'t\\'. If we insert a \\'t\\' then we get \\'javat\\' and now the last letters are equal but the rest of the word isn\\'t. So our subproblem is now to look at the remaining letters in the words (\\'java\\', \\'swif\\')\\n\\n**Decision 3: We can replace a letter**\\n![image](https://assets.leetcode.com/users/images/1619d600-6085-4c83-ac18-94eacbffc7fc_1648372049.465201.png)\\n\\nAs before we are trying to get \"java\" to become \"swift.\" If we can replace a letter in \"java\" so that the last letter equals the last letter of \"swift\" then we will replace the \\'a\\' to a \\'t\\'. This will result in \"javt\" and \"swift\" and now the last letters are equal but the rest of the word isn\\'t equal. Our new subproblem becomes to get \"jav\" to equal \"swif\"\\n\\n**Important Note**\\nWe talked about the 3 explicitly named decisions for this problem but there is a subtle 4th decision, we can do nothing. This decision would be the decision we choose if the last letter is already the same because there\\'s no need to delete, insert, or replace that last letter. So in this case we will just do nothing to that last letter and continue looking at the rest of the word\\n\\n# Table setup\\n![image](https://assets.leetcode.com/users/images/dfd5f9fe-ffc2-40ab-b76d-6c8b1704e9aa_1648372147.6479256.png)\\nLets explain these cells and the logic being used to fill them so far. The columns represent letters of the word we currently have and the rows represent letters of the word we want. \\n\\nSo table[0][0] can be read as \"Whats the minimum number of steps to turn an empty string into an empty string?\"\\nWell 0 steps are needed to do that. \\n\\nTable[0][4] can be read as \"Whats the minimum number of steps to turn an empty string into java?\" You would need 4 steps to do that, more specifically 4 inserts to do that. You would need to insert \\'j\\' then \\'a\\' then \\'v\\' and then \\'a\\'.\\n\\n**Relating our decisions to a recurrence relation** \\n\\n**1. Decision 1: We can delete a letter**\\n![image](https://assets.leetcode.com/users/images/62eddf11-6b28-4283-8cf6-da3f08a4f8ea_1648372248.910796.png)\\n\\n **2. Decision 2: We can insert a letter**\\n ![image](https://assets.leetcode.com/users/images/31a79fa2-969a-4aca-8b3c-af10336c1029_1648372279.6259208.png)\\n \\n **3. Decision 3: We can replace a letter**\\n ![image](https://assets.leetcode.com/users/images/c6c837d0-ceeb-4d2e-806d-52953582a16e_1648372350.494664.png)\\n\\nThe problem asks for the **minimum** steps to turn our start string to the goal string. So we need to take the minimum of these decisions\\n\\n![image](https://assets.leetcode.com/users/images/d7f858ef-290d-47e8-b4a5-7ac57757d989_1648372386.15309.png)\\n\\nThe +1 is because when we choose which decision to make we then have to execute it and all decisions have a +1 step cost. \\n\\n![image](https://assets.leetcode.com/users/images/71dba42d-84cf-495e-a336-2a0dd14b35b0_1648372415.5852163.png)\\n\\nIf these recurrence relations are a little confusing make sure to go back up to where we explained our decisions\\n\\n# Using our recurrence relations on our visual 2D table\\nBased on our recurrence relation this is a key we can use to quickly find our delete, insert, and replace values.\\n\\n![image](https://assets.leetcode.com/users/images/539cf57d-4dad-4cad-aa91-5edb57d9f053_1648372481.8830466.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a9b606a-1220-4b90-941f-0d09a03491a6_1648372563.230859.png)\\n\\n![image](https://assets.leetcode.com/users/images/5e6b917e-fd16-4493-b627-5bc7c85f821f_1648372584.0092237.png)\\n\\n![image](https://assets.leetcode.com/users/images/02184174-5af2-4da0-a113-017cfacd96e0_1648372593.0742426.png)\\n\\n![image](https://assets.leetcode.com/users/images/2d51b865-5edb-4100-8e0c-1a4b6beba8fe_1648372599.10186.png)\\n\\n![image](https://assets.leetcode.com/users/images/79a88905-8f72-4396-8538-c66996288639_1648372605.4986908.png)\\n\\nIt would take 5 steps to turn \"java\" into \"swift.\" This makes sense because they don\\'t have any of the same letters so we would have to replace all 4 letters in \"java\" and then insert another one because \"swift\" is 5 letters\\n\\nIn case it would be helpful this is the table at the end of filling out the table for the \"horse\" and \"ros\" example\\n\\n![image](https://assets.leetcode.com/users/images/c6820cb4-29db-4bfc-9b26-ff53930a6f64_1648372673.2579377.png)\\n\\n# Solution\\n**Time Complexity: O(nm)**\\n**Space Complexity: O(nm)**\\n\\n```\\nfunc minDistance(_ word1: String, _ word2: String) -> Int {\\n\\tvar table = Array(repeating: Array(repeating: 0, count: word1.count + 1), count: word2.count + 1)\\n\\t\\n\\t// adding the empty string state\\n\\tlet word1Arr = Array(\" \" + word1)\\n\\tlet word2Arr = Array(\" \" + word2)\\n\\t\\n\\t// Table setup for the empty string state\\n\\tfor row in 0..<table.count {\\n\\t\\ttable[row][0] = row\\n\\t}\\n\\tfor col in 0..<table[0].count {\\n\\t\\ttable[0][col] = col\\n\\t}\\n\\t\\n\\t// Begin iterating at index 1 to word2.count - this is the first letter of word2\\n\\tfor i in 1..<table.count {\\n\\t\\n\\t\\tfor j in 1..<table[i].count {\\n\\t\\t\\t\\n\\t\\t\\tlet insert: Int = table[i-1][j]\\n\\t\\t\\tlet remove: Int = table[i][j-1]\\n\\t\\t\\tlet replace: Int = table[i-1][j-1]\\n\\t\\t\\t\\n\\t\\t\\tif word2Arr[i] == word1Arr[j] {\\n\\t\\t\\t\\ttable[i][j] = replace\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ttable[i][j] = min(insert, remove, replace) + 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n\\t// Return the value at the bottom right\\n\\treturn table[word2.count][word1.count]\\n}\\n```\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nInput: word1 = \"java\", word2 = \"swift\"\\n```\n```\\nfunc minDistance(_ word1: String, _ word2: String) -> Int {\\n\\tvar table = Array(repeating: Array(repeating: 0, count: word1.count + 1), count: word2.count + 1)\\n\\t\\n\\t// adding the empty string state\\n\\tlet word1Arr = Array(\" \" + word1)\\n\\tlet word2Arr = Array(\" \" + word2)\\n\\t\\n\\t// Table setup for the empty string state\\n\\tfor row in 0..<table.count {\\n\\t\\ttable[row][0] = row\\n\\t}\\n\\tfor col in 0..<table[0].count {\\n\\t\\ttable[0][col] = col\\n\\t}\\n\\t\\n\\t// Begin iterating at index 1 to word2.count - this is the first letter of word2\\n\\tfor i in 1..<table.count {\\n\\t\\n\\t\\tfor j in 1..<table[i].count {\\n\\t\\t\\t\\n\\t\\t\\tlet insert: Int = table[i-1][j]\\n\\t\\t\\tlet remove: Int = table[i][j-1]\\n\\t\\t\\tlet replace: Int = table[i-1][j-1]\\n\\t\\t\\t\\n\\t\\t\\tif word2Arr[i] == word1Arr[j] {\\n\\t\\t\\t\\ttable[i][j] = replace\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ttable[i][j] = min(insert, remove, replace) + 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n\\t// Return the value at the bottom right\\n\\treturn table[word2.count][word1.count]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1796988,
                "title": "lcs-variation-dp-solution-cpp",
                "content": "DP matrix initialization and Dry run for the sample case\\n![image](https://assets.leetcode.com/users/images/2c43a3fa-d3b3-442b-bf09-fb1332a2a765_1659076991.6366894.jpeg)\\n\\nMechanism\\nIf after comaparing we are finding the same character we will copy the value from the diagonal cell\\notherwise the value will be 1+ the minimum value of updation deletion and insertion\\n![image](https://assets.leetcode.com/users/images/cc3eb444-ea30-414a-8b07-6320539fa79e_1659077075.7195187.jpeg)\\n\\n```\\nclass Solution {\\npublic:\\n     int LCS(string x,string y, int n, int m){\\n        int dp[n+1][m+1];\\n        for(int i =0;i<n+1;i++){\\n            dp[i][0]=i;\\n        }\\n        for(int j=0;j<m+1;j++){\\n            dp[0][j]=j;\\n        }\\n        \\n                \\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<m+1;j++){\\n                if(x[i-1]== y[j-1]){\\n                    dp[i][j]= dp[i-1][j-1];\\n                }\\n                else{\\n                    dp[i][j] = 1+min(dp[i-1][j],min(dp[i][j-1],dp[i-1][j-1]));\\n                }\\n            }\\n        }\\n        \\n        return dp[n][m];   \\n        \\n    }\\n    int minDistance(string word1, string word2) {\\n        int n = word1.size();\\n        int m = word2.size();\\n        \\n        return LCS(word1,word2,n,m);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int LCS(string x,string y, int n, int m){\\n        int dp[n+1][m+1];\\n        for(int i =0;i<n+1;i++){\\n            dp[i][0]=i;\\n        }\\n        for(int j=0;j<m+1;j++){\\n            dp[0][j]=j;\\n        }\\n        \\n                \\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<m+1;j++){\\n                if(x[i-1]== y[j-1]){\\n                    dp[i][j]= dp[i-1][j-1];\\n                }\\n                else{\\n                    dp[i][j] = 1+min(dp[i-1][j],min(dp[i][j-1],dp[i-1][j-1]));\\n                }\\n            }\\n        }\\n        \\n        return dp[n][m];   \\n        \\n    }\\n    int minDistance(string word1, string word2) {\\n        int n = word1.size();\\n        int m = word2.size();\\n        \\n        return LCS(word1,word2,n,m);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1770392,
                "title": "python-simple-recursive-dp-with-memorization-o-mn-84ms-beats-99",
                "content": "Here is a simple recursive python solution:\\n\\nuse two pointers to track which index of word1 and word2 I\\'m evaluating in the function call, at each call:\\n- if one or both the pointers have reached the end return the remaining chars to insert / delete\\n- if the two pointers point to the same value no operation required: p1 + 1, p2 + 1\\n- otherwise keep the minimum distance between insert (p1, p2 + 1), delete (p1 + 1, p2) and replace (p1 + 1, p2 + 1)\\n\\nwith memorization each combination of letters in word1 and word2 is evaluated only once:\\n- time complexity: O(m*n)\\n- space complexity: O(m*n)\\n```\\ndef minDistance(self, word1: str, word2: str) -> int:\\n\\n\\t@lru_cache(None)\\n\\tdef min_dist(p1, p2):\\n\\n\\t\\tif p1 == len(word1) or p2 == len(word2):\\n\\t\\t\\treturn len(word1) - p1 + len(word2) - p2\\n\\n\\t\\t# no change required\\n\\t\\tif word1[p1] == word2[p2]:\\n\\t\\t\\treturn min_dist(p1 + 1, p2 + 1)\\n\\n\\t\\treturn 1 + min(\\n\\t\\t\\tmin_dist(p1, p2 + 1),      # insert character\\n\\t\\t\\tmin_dist(p1 + 1, p2),      # delete character\\n\\t\\t\\tmin_dist(p1 + 1, p2 + 1),  # replace character\\n\\t\\t)\\n\\n\\treturn min_dist(0, 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\ndef minDistance(self, word1: str, word2: str) -> int:\\n\\n\\t@lru_cache(None)\\n\\tdef min_dist(p1, p2):\\n\\n\\t\\tif p1 == len(word1) or p2 == len(word2):\\n\\t\\t\\treturn len(word1) - p1 + len(word2) - p2\\n\\n\\t\\t# no change required\\n\\t\\tif word1[p1] == word2[p2]:\\n\\t\\t\\treturn min_dist(p1 + 1, p2 + 1)\\n\\n\\t\\treturn 1 + min(\\n\\t\\t\\tmin_dist(p1, p2 + 1),      # insert character\\n\\t\\t\\tmin_dist(p1 + 1, p2),      # delete character\\n\\t\\t\\tmin_dist(p1 + 1, p2 + 1),  # replace character\\n\\t\\t)\\n\\n\\treturn min_dist(0, 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1710466,
                "title": "simple-c-top-down-approach",
                "content": "```  int dp[501][501];\\n    int solve(string &s1,string &s2,int m,int n){\\n        if(dp[m][n]!=-1)\\n            return dp[m][n];//if any string become zero then minimum insertion required is  second string length\\n        if(m==0)\\n            return dp[m][n]= n;\\n        if(n==0)\\n            return dp[m][n]= m;\\n        if(s1[m-1]==s2[n-1]){\\n            return dp[m][n]=solve(s1,s2,m-1,n-1);//both  last character match then call by removing last character from both string\\n        }\\n        else\\n        {\\n\\t\\t//we are doing 1 operation so adding 1 to result and taking minimum of insert,delete and replace.\\n            return dp[m][n]= 1+min(solve(s1,s2,m,n-1),min(solve(s1,s2,m-1,n),solve(s1,s2,m-1,n-1)));//when both last character not match then\\n\\t\\t\\t//insert the charcter in string one so 1st string remain same  and string 2 reduces by 1 (after inserting both matches);\\n\\t\\t\\t//delete the last character in string 1 and  second string remain same (after deleting both matches)\\n\\t\\t\\t//replace the  last character in string 1 so both both character match so both string reduces by 1 (after replacing both matches)\\n        }\\n    }\\n    int minDistance(string word1, string word2) {\\n        memset(dp,-1,sizeof(dp));\\n       return solve(word1,word2,word1.length(),word2.length());\\n    }",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```  int dp[501][501];\\n    int solve(string &s1,string &s2,int m,int n){\\n        if(dp[m][n]!=-1)\\n            return dp[m][n];//if any string become zero then minimum insertion required is  second string length\\n        if(m==0)\\n            return dp[m][n]= n;\\n        if(n==0)\\n            return dp[m][n]= m;\\n        if(s1[m-1]==s2[n-1]){\\n            return dp[m][n]=solve(s1,s2,m-1,n-1);//both  last character match then call by removing last character from both string\\n        }\\n        else\\n        {\\n\\t\\t//we are doing 1 operation so adding 1 to result and taking minimum of insert,delete and replace.\\n            return dp[m][n]= 1+min(solve(s1,s2,m,n-1),min(solve(s1,s2,m-1,n),solve(s1,s2,m-1,n-1)));//when both last character not match then\\n\\t\\t\\t//insert the charcter in string one so 1st string remain same  and string 2 reduces by 1 (after inserting both matches);\\n\\t\\t\\t//delete the last character in string 1 and  second string remain same (after deleting both matches)\\n\\t\\t\\t//replace the  last character in string 1 so both both character match so both string reduces by 1 (after replacing both matches)\\n        }\\n    }\\n    int minDistance(string word1, string word2) {\\n        memset(dp,-1,sizeof(dp));\\n       return solve(word1,word2,word1.length(),word2.length());\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1517075,
                "title": "c-solution-with-explanation",
                "content": "```\\n    int minDistance(string word1, string word2) {\\n        int size1 = word1.size();\\n        int size2 = word2.size();\\n        int row = size1 + 1;\\n        int column = size2 + 1;\\n        vector<vector<int>> lm(row, vector<int>(column, 0));\\n        // the distance between \"\" and \"\" is zero\\n        lm[0][0] = 0;\\n        // the operations of converting \"\" to a length i word\\n        for (int i = 1; i < column; i++) {\\n            lm[0][i] = i;\\n        }\\n        // the operations of converting a length i word to \"\"\\n        for (int i = 1; i < row; i++) {\\n            lm[i][0] = i;\\n        }\\n        \\n        for (int r = 1; r < row; r++) {\\n            for (int c = 1; c < column; c++) {\\n                // if the last character of two strings are the same, then the distance is the same as lm[r-1][c-1]\\n                if (word1[r - 1] == word2[c - 1]) {\\n                    lm[r][c] = lm[r - 1][c - 1];\\n                } else {\\n                    // if we have known the min distance between s1[1...r-1] and s2[1...c-1]\\n                    // then we can replace s1[r] with s2[c] first then convert s1[1...r-1] to s2[1...c-1]\\n                    int replace = lm[r - 1][c - 1] + 1;\\n                    // if we have known the min distance bwtween s1[1...r-1] and s2[1...c]\\n\\t\\t\\t\\t\\t// we can  delete s1[r] first then convert s1[1...r-1] to s2[1...c]\\n                    int del = lm[r - 1][c] + 1;\\n                    // if we have known the min distance between s1[1...r] and s2[1...c-1]\\n\\t\\t\\t\\t\\t// we can convert s1[1...r] to s2[1...c-1] then insert s2[c] to the end of s1\\n                    int insert = lm[r][c - 1] + 1;\\n                    // find the min value among the above operation steps\\n                    int result = min(replace, del);\\n                    result = min(result, insert);\\n                    lm[r][c] = result;\\n                }\\n            }\\n        }\\n        return lm[size1][size2];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int minDistance(string word1, string word2) {\\n        int size1 = word1.size();\\n        int size2 = word2.size();\\n        int row = size1 + 1;\\n        int column = size2 + 1;\\n        vector<vector<int>> lm(row, vector<int>(column, 0));\\n        // the distance between \"\" and \"\" is zero\\n        lm[0][0] = 0;\\n        // the operations of converting \"\" to a length i word\\n        for (int i = 1; i < column; i++) {\\n            lm[0][i] = i;\\n        }\\n        // the operations of converting a length i word to \"\"\\n        for (int i = 1; i < row; i++) {\\n            lm[i][0] = i;\\n        }\\n        \\n        for (int r = 1; r < row; r++) {\\n            for (int c = 1; c < column; c++) {\\n                // if the last character of two strings are the same, then the distance is the same as lm[r-1][c-1]\\n                if (word1[r - 1] == word2[c - 1]) {\\n                    lm[r][c] = lm[r - 1][c - 1];\\n                } else {\\n                    // if we have known the min distance between s1[1...r-1] and s2[1...c-1]\\n                    // then we can replace s1[r] with s2[c] first then convert s1[1...r-1] to s2[1...c-1]\\n                    int replace = lm[r - 1][c - 1] + 1;\\n                    // if we have known the min distance bwtween s1[1...r-1] and s2[1...c]\\n\\t\\t\\t\\t\\t// we can  delete s1[r] first then convert s1[1...r-1] to s2[1...c]\\n                    int del = lm[r - 1][c] + 1;\\n                    // if we have known the min distance between s1[1...r] and s2[1...c-1]\\n\\t\\t\\t\\t\\t// we can convert s1[1...r] to s2[1...c-1] then insert s2[c] to the end of s1\\n                    int insert = lm[r][c - 1] + 1;\\n                    // find the min value among the above operation steps\\n                    int result = min(replace, del);\\n                    result = min(result, insert);\\n                    lm[r][c] = result;\\n                }\\n            }\\n        }\\n        return lm[size1][size2];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1475926,
                "title": "c-easy-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int helper(const string& s1, const string& s2, int m, int n,int i, int j,vector<vector<int>>& dp){\\n        if(s1[i] == \\'\\\\0\\'){\\n            return n;\\n        }\\n        if(s2[j] == \\'\\\\0\\'){\\n            return m;\\n        }\\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n        int ans;\\n        if(s1[i] == s2[j]){\\n            ans = helper(s1,s2,m-1,n-1,i+1,j+1,dp);\\n        }\\n        else{\\n            ans = 1 + min(helper(s1,s2,m-1,n,i+1,j,dp),min(helper(s1,s2,m,n-                        1,i,j+1,dp),helper(s1,s2,m-1,n-1,i+1,j+1,dp)));\\n        }\\n        dp[i][j] = ans;\\n        return ans;\\n    }\\n    int minDistance(string s1, string s2) {\\n        int m = s1.size();\\n        int n = s2.size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return helper(s1,s2,m,n,0,0,dp);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    int helper(const string& s1, const string& s2, int m, int n,int i, int j,vector<vector<int>>& dp){\\n        if(s1[i] == \\'\\\\0\\'){\\n            return n;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1458851,
                "title": "java-memorization-3-ms-faster-than-99-35-submission",
                "content": "```\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        \\n        int n = word1.length();\\n        int m = word2.length();\\n        \\n        int[][] memo = new int[n+1][m+1];\\n        for(int[] mem : memo){\\n            Arrays.fill(mem, -1);\\n        }\\n        return Helper(word1, word2, n, m, memo);       \\n        \\n    }\\n    \\n    public static int Helper(String word1, String word2, int n, int m, int[][] memo){\\n        \\n        if(memo[n][m] != -1){\\n            return memo[n][m];\\n        }\\n        \\n        if(n == 0){\\n            return m;\\n        }\\n        if(m == 0){\\n            return n;\\n        }\\n        \\n        if(word1.charAt(n-1) == word2.charAt(m-1)){\\n            return memo[n][m] = Helper(word1, word2, n-1, m-1, memo);\\n        }\\n        else{\\n            int delete = 1 + Helper(word1, word2, n-1, m, memo);  // delete operation\\n            int replace = 1 + Helper(word1, word2, n-1, m-1, memo);  // replace operation\\n            int insert = 1 + Helper(word1, word2, n, m-1, memo); // insert operation\\n            \\n            return memo[n][m] = Math.min(delete, Math.min(replace, insert));\\n        }        \\n        \\n    }\\n    \\n}\\n```\\n\\nPlease help to UPVOTE if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n\\nLOVE CODING :)\\nHAPPY CODING :)\\nHAPPY LEARNING :)",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        \\n        int n = word1.length();\\n        int m = word2.length();\\n        \\n        int[][] memo = new int[n+1][m+1];\\n        for(int[] mem : memo){\\n            Arrays.fill(mem, -1);\\n        }\\n        return Helper(word1, word2, n, m, memo);       \\n        \\n    }\\n    \\n    public static int Helper(String word1, String word2, int n, int m, int[][] memo){\\n        \\n        if(memo[n][m] != -1){\\n            return memo[n][m];\\n        }\\n        \\n        if(n == 0){\\n            return m;\\n        }\\n        if(m == 0){\\n            return n;\\n        }\\n        \\n        if(word1.charAt(n-1) == word2.charAt(m-1)){\\n            return memo[n][m] = Helper(word1, word2, n-1, m-1, memo);\\n        }\\n        else{\\n            int delete = 1 + Helper(word1, word2, n-1, m, memo);  // delete operation\\n            int replace = 1 + Helper(word1, word2, n-1, m-1, memo);  // replace operation\\n            int insert = 1 + Helper(word1, word2, n, m-1, memo); // insert operation\\n            \\n            return memo[n][m] = Math.min(delete, Math.min(replace, insert));\\n        }        \\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1434648,
                "title": "c-dp-solution-by-kushalatolia",
                "content": "![image](https://assets.leetcode.com/users/images/2bf44bc5-6c1d-4369-9e84-3a7ff50a4ba5_1630319139.576023.jpeg)\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int n=word1.size();\\n        int m=word2.size();\\n        int dp[n+1][m+1];\\n        for(int i=0;i<=n;i++)\\n            dp[i][0]=i;\\n        for(int i=0;i<=m;i++)\\n            dp[0][i]=i;\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=m;j++)\\n            {\\n                if(word1[i-1]==word2[j-1])\\n                    dp[i][j]=dp[i-1][j-1];\\n                else \\n                    dp[i][j]=min(dp[i][j-1]+1,min(dp[i-1][j]+1,dp[i-1][j-1]+1));\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int n=word1.size();\\n        int m=word2.size();\\n        int dp[n+1][m+1];\\n        for(int i=0;i<=n;i++)\\n            dp[i][0]=i;\\n        for(int i=0;i<=m;i++)\\n            dp[0][i]=i;\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=m;j++)\\n            {\\n                if(word1[i-1]==word2[j-1])\\n                    dp[i][j]=dp[i-1][j-1];\\n                else \\n                    dp[i][j]=min(dp[i][j-1]+1,min(dp[i-1][j]+1,dp[i-1][j-1]+1));\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1417454,
                "title": "python-dp-memoized-bottom-up-and-recursive-solution",
                "content": "Refer [this](https://en.wikipedia.org/wiki/Levenshtein_distance) article for the algorithm used in this solution.\\n\\n```\\n# DP (top-down) solution\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        n = len(word1)\\n        m = len(word2)\\n        \\n        t = [[0 for p in range(0,m+1)]\\n            for q in range(0,n+1)]\\n        \\n        for a in range(0,n+1):\\n            t[a][0] = a\\n        for b in range(1,m+1):\\n            t[0][b] = b\\n            \\n        for i in range(1,n+1):\\n            for j in range(1,m+1):\\n                \\n                if word1[i-1] == word2[j-1]:\\n                    t[i][j] = t[i-1][j-1]\\n                    \\n                else:\\n                    t[i][j] = 1 + min(t[i][j-1], t[i-1][j], t[i-1][j-1])\\n                    \\n        return t[n][m]\\n\\t\\t\\n\\t\\t\\n# Recursive code\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        return self.edit(word1,word2,len(word1), len(word2))\\n    \\n    def edit(self,x,y,n,m):\\n        if n == 0 or m == 0:\\n            if n == 0:\\n                return m\\n            else:\\n                return n\\n            \\n        if x[n-1] == y[m-1]:\\n            return self.edit(x,y,n-1,m-1)\\n        else:\\n            return 1 + min(self.edit(x,y,n,m-1), self.edit(x,y,n-1,m), self.edit(x,y,n-1,m-1))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n# DP (top-down) solution\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        n = len(word1)\\n        m = len(word2)\\n        \\n        t = [[0 for p in range(0,m+1)]\\n            for q in range(0,n+1)]\\n        \\n        for a in range(0,n+1):\\n            t[a][0] = a\\n        for b in range(1,m+1):\\n            t[0][b] = b\\n            \\n        for i in range(1,n+1):\\n            for j in range(1,m+1):\\n                \\n                if word1[i-1] == word2[j-1]:\\n                    t[i][j] = t[i-1][j-1]\\n                    \\n                else:\\n                    t[i][j] = 1 + min(t[i][j-1], t[i-1][j], t[i-1][j-1])\\n                    \\n        return t[n][m]\\n\\t\\t\\n\\t\\t\\n# Recursive code\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        return self.edit(word1,word2,len(word1), len(word2))\\n    \\n    def edit(self,x,y,n,m):\\n        if n == 0 or m == 0:\\n            if n == 0:\\n                return m\\n            else:\\n                return n\\n            \\n        if x[n-1] == y[m-1]:\\n            return self.edit(x,y,n-1,m-1)\\n        else:\\n            return 1 + min(self.edit(x,y,n,m-1), self.edit(x,y,n-1,m), self.edit(x,y,n-1,m-1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1180587,
                "title": "memoized-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int n= word1.length();\\n        int m = word2.length();\\n        vector<vector<int>> dp(n+1,vector<int> (m+1,-1));\\n        \\n        return solve(n,m,word1,word2,dp);\\n    }\\n    int solve(int n, int m, string word1, string word2, vector<vector<int>> &dp){\\n        if(n==0 || m==0) return max(n,m);\\n        if(dp[n][m]!=-1) return dp[n][m];\\n        if(word1[n-1]==word2[m-1]) return solve(n-1,m-1,word1,word2,dp);\\n        else{\\n            dp[n][m] = min(solve(n-1,m,word1,word2,dp),\\n                           min(solve(n-1,m-1,word1,word2,dp),\\n                               solve(n,m-1,word1,word2,dp))) +1;\\n            return dp[n][m];\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int n= word1.length();\\n        int m = word2.length();\\n        vector<vector<int>> dp(n+1,vector<int> (m+1,-1));\\n        \\n        return solve(n,m,word1,word2,dp);\\n    }\\n    int solve(int n, int m, string word1, string word2, vector<vector<int>> &dp){\\n        if(n==0 || m==0) return max(n,m);\\n        if(dp[n][m]!=-1) return dp[n][m];\\n        if(word1[n-1]==word2[m-1]) return solve(n-1,m-1,word1,word2,dp);\\n        else{\\n            dp[n][m] = min(solve(n-1,m,word1,word2,dp),\\n                           min(solve(n-1,m-1,word1,word2,dp),\\n                               solve(n,m-1,word1,word2,dp))) +1;\\n            return dp[n][m];\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1119169,
                "title": "c-dp-4-ways-to-solve-memory-utilization-99-lesser",
                "content": "\\n**Approach 1**  \\nSo the code for this recursive solution would be  \\nBase Case:  \\n- if **i** reached till the end , in that case we have to see how many characters still left(**word2.size()-j**) in word2 and return that.  \\n- similary we do for j if it reached till the end.  \\n\\nMemoization: Use the index i and j.  \\nTime Complexity: O(M*N)\\nSpace Complexity: O(M*N) plus recursion stack which will also be same.\\n```\\nint dp[505][505];\\nclass Solution {\\n    string s;\\n    string t;\\n    int solve(int i, int j)\\n    {\\n        // If we have exhausted the first string\\n        // We have to take number of chars left in second string\\n        // which will be t.size()-current_index_t\\n        // Same logic goes if we have exhausted second string\\n        if(i==s.size())\\n            return t.size()-j;\\n        if(j==t.size())\\n            return s.size()-i;\\n        // Check if we have already evaluated?\\n        int& ret = dp[i][j];\\n        if(ret !=-1)\\n            return ret;\\n        ret =0;\\n        // Mismatch\\n        if(s[i]!=t[j])\\n        {\\n            // If we replace that means i,j now match lets go to next\\n            int rep = 1 + solve(i+1, j+1);\\n            // if delete that means , we go to next j, i remain same.\\n            int del = 1 + solve(i, j+1);\\n            // if insert same char , that mean i now matches \\n            // but we dont know abt j , so keep j same\\n            int ins = 1 + solve(i+1, j);\\n            // Take minimum of all 3 operation\\n            ret = min({rep, del, ins});\\n        }\\n        else\\n            // i and j match, so lets goto next \\n            ret = solve(i+1, j+1);\\n        return ret;\\n    }\\npublic:\\n    int minDistance(string word1, string word2) {\\n        t = word1;\\n        s = word2;\\n        memset(&dp, -1, sizeof dp);\\n        return solve(0, 0);\\n    }\\n};\\n```\\n**Approach 2**  \\nLets convert this memoization based recursive approach to tabulation based iterative approach.  \\nf(i, j) = 1 + min { f(i+1, j+1) , f(i+1, j), f(i, j+1) }  \\n**Step 1**  \\nTable constrction: create a dp table of size dp[1+m][1+n].  \\nExtra 1 size to handle case of string completely exhaausted.  \\nBase case value to initialized in table, remember in recursive solution whenever i==m we return word2.size()-j and vice versa.  \\nSo here in tabulation approach when i==m-> dp[i][j] = word2.size() -j and when j==n -> dp[i][j] = word1.size()-i  \\n\\n\\n**Step 2**   \\nHow to start the loops:  Notice that our recursive function is dependent on future values, hence we cant start from i=0 or j=0  \\nwe have to start backward, when working backward future value would have been already calculated.  \\n\\n```\\n\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        // Iterative version of recursive approach\\n        // Since recursive approach rely on future value\\n        // we should start backward i.e. i=m j=n\\n        int m = word1.size();\\n        int n = word2.size();\\n        vector<vector<int>> dp(1+m, vector<int>(1+n, 0));\\n        for(int i = m ; i >=0; --i)\\n        {\\n            for(int j = n ; j >=0; --j)\\n            {\\n                if(i==m) // that means word1 is exhausted\\n                    dp[i][j] = n - j;\\n                else if(j==n)\\n                    dp[i][j] = m - i;\\n                else if(word1[i]!=word2[j])\\n                {\\n                    dp[i][j] = 1 + min({dp[i+1][j], dp[i][j+1], dp[i+1][j+1]});\\n                }\\n                else\\n                    dp[i][j] = dp[i+1][j+1];\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```\\n**Approach 3**  \\nGenerally we are more familiar with starting the loop with 0 to n.   \\nThis problem can be solve using this way as well, only the base case change i.e. when i=0 , that mean we are left with entire j length of word2 so dp[i][j]= j;  \\nSimilar when j==0 , dp[i][j]=i  \\n```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = word1.size();\\n        int n = word2.size();\\n        vector<vector<int>> dp(1+m, vector<int>(1+n, 0));\\n        for(int i=0; i <= m; ++i)\\n        {\\n            for(int j=0; j<=n; ++j)\\n            {\\n                if(i==0)\\n                    dp[i][j] = j;\\n                else if(j==0)\\n                    dp[i][j] = i;\\n                else if(word1[i-1]==word2[j-1])\\n                    dp[i][j] = dp[i-1][j-1];\\n                else\\n                {\\n                    dp[i][j] = 1 + min({dp[i-1][j-1], dp[i][j-1], dp[i-1][j]});\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```\\n\\nLet me show you that Approach 2 and 3 are exactly opposite of each other.\\nWe will show with example word1=\"abc\", word2=\"bcd\"\\n\\n![image](https://user-images.githubusercontent.com/20656683/111882251-a63fb180-89da-11eb-88bb-7fbbbd107757.png)\\n\\n\\n\\n**Approach 4 : Space Optimized DP**  \\nAbove tabluation based DP approach consume space of O( M* N ), we can further reduce this to 1-D DP. \\nNotice that as per DP recursive statement we are only dependent on 1-future row or 1-previous  (Approach 2 vs Approach 3) to compute the current row.  \\nOne easy way is to maintain 2 row, one which we will fill in the value of current row and 1 row which has values from previous row operation and then toggle between this row. There is even a smarter way where 2nd row itself is also not required, lets discuss that.  \\nI am going to discuss 1-D verion of Approach 2 but it is also applicable for Approach 3 as well.  \\n\\nStep 1: Always create 1-D DP array for smaller string , for our problem, I will always make word2 as smaller, if its not smaller , call the function by reversing argument.  \\nStep 2: Recall our recusrive function\\n          f(i, j) = 1 + min { f(i+1, j+1) , f(i+1, j), f(i, j+1) }  \\n\\n![image](https://user-images.githubusercontent.com/20656683/111882720-13ecdd00-89dd-11eb-9c38-9f2f25c94621.png)\\n\\nStep 3: Base case value remain same, just that now its 1-D.\\nStep 4: Make sure everywhere dp[i+1][j+1] is replaced by **prev**, dp[i+1][j] is dp[j] itself and dp[i][j+1] is dp[j+1].  \\nprev is a way to store previous value of the cell , so that the same can be reused in next iteration\\n\\nCode for this looks somehing like this.\\n```\\n\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        // Iterative version of recursive approach\\n        // Since recursive approach rely on future value\\n        // we should start backward i.e. i=m j=n\\n        \\n        int m = word1.size();\\n        int n = word2.size();\\n        if(m < n)\\n            return minDistance(word2, word1);\\n        \\n        // Space optimized 1-D DP version\\n        vector<int> dp(1+n, 0);\\n        dp[n] = 0;\\n        int prev;\\n        for(int i = m; i >=0; --i)\\n        {\\n            prev = dp[n];\\n            for(int j = n ; j >=0; --j)\\n            {\\n                int oldDP = dp[j];\\n                if(i==m)\\n                    dp[j] = n-j;\\n                else if(j==n)\\n                    dp[j] = m-i;\\n                else if(word1[i]!=word2[j])\\n                {\\n                    dp[j] = 1 + min({dp[j], dp[j+1], prev});\\n                }\\n                else\\n                    dp[j] = prev;\\n                prev = oldDP;\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```\\n\\nConculsion:\\nApproach 4 when submitted reported 99% lesser memory usage.",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint dp[505][505];\\nclass Solution {\\n    string s;\\n    string t;\\n    int solve(int i, int j)\\n    {\\n        // If we have exhausted the first string\\n        // We have to take number of chars left in second string\\n        // which will be t.size()-current_index_t\\n        // Same logic goes if we have exhausted second string\\n        if(i==s.size())\\n            return t.size()-j;\\n        if(j==t.size())\\n            return s.size()-i;\\n        // Check if we have already evaluated?\\n        int& ret = dp[i][j];\\n        if(ret !=-1)\\n            return ret;\\n        ret =0;\\n        // Mismatch\\n        if(s[i]!=t[j])\\n        {\\n            // If we replace that means i,j now match lets go to next\\n            int rep = 1 + solve(i+1, j+1);\\n            // if delete that means , we go to next j, i remain same.\\n            int del = 1 + solve(i, j+1);\\n            // if insert same char , that mean i now matches \\n            // but we dont know abt j , so keep j same\\n            int ins = 1 + solve(i+1, j);\\n            // Take minimum of all 3 operation\\n            ret = min({rep, del, ins});\\n        }\\n        else\\n            // i and j match, so lets goto next \\n            ret = solve(i+1, j+1);\\n        return ret;\\n    }\\npublic:\\n    int minDistance(string word1, string word2) {\\n        t = word1;\\n        s = word2;\\n        memset(&dp, -1, sizeof dp);\\n        return solve(0, 0);\\n    }\\n};\\n```\n```\\n\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        // Iterative version of recursive approach\\n        // Since recursive approach rely on future value\\n        // we should start backward i.e. i=m j=n\\n        int m = word1.size();\\n        int n = word2.size();\\n        vector<vector<int>> dp(1+m, vector<int>(1+n, 0));\\n        for(int i = m ; i >=0; --i)\\n        {\\n            for(int j = n ; j >=0; --j)\\n            {\\n                if(i==m) // that means word1 is exhausted\\n                    dp[i][j] = n - j;\\n                else if(j==n)\\n                    dp[i][j] = m - i;\\n                else if(word1[i]!=word2[j])\\n                {\\n                    dp[i][j] = 1 + min({dp[i+1][j], dp[i][j+1], dp[i+1][j+1]});\\n                }\\n                else\\n                    dp[i][j] = dp[i+1][j+1];\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = word1.size();\\n        int n = word2.size();\\n        vector<vector<int>> dp(1+m, vector<int>(1+n, 0));\\n        for(int i=0; i <= m; ++i)\\n        {\\n            for(int j=0; j<=n; ++j)\\n            {\\n                if(i==0)\\n                    dp[i][j] = j;\\n                else if(j==0)\\n                    dp[i][j] = i;\\n                else if(word1[i-1]==word2[j-1])\\n                    dp[i][j] = dp[i-1][j-1];\\n                else\\n                {\\n                    dp[i][j] = 1 + min({dp[i-1][j-1], dp[i][j-1], dp[i-1][j]});\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```\n```\\n\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        // Iterative version of recursive approach\\n        // Since recursive approach rely on future value\\n        // we should start backward i.e. i=m j=n\\n        \\n        int m = word1.size();\\n        int n = word2.size();\\n        if(m < n)\\n            return minDistance(word2, word1);\\n        \\n        // Space optimized 1-D DP version\\n        vector<int> dp(1+n, 0);\\n        dp[n] = 0;\\n        int prev;\\n        for(int i = m; i >=0; --i)\\n        {\\n            prev = dp[n];\\n            for(int j = n ; j >=0; --j)\\n            {\\n                int oldDP = dp[j];\\n                if(i==m)\\n                    dp[j] = n-j;\\n                else if(j==n)\\n                    dp[j] = m-i;\\n                else if(word1[i]!=word2[j])\\n                {\\n                    dp[j] = 1 + min({dp[j], dp[j+1], prev});\\n                }\\n                else\\n                    dp[j] = prev;\\n                prev = oldDP;\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1028828,
                "title": "python-easy-understanding-beats-95-in-time",
                "content": "\\tfrom functools import cache\\n\\tclass Solution:\\n\\t\\tdef minDistance(self, word1: str, word2: str) -> int:\\n\\t\\t\\t@cache\\n\\t\\t\\tdef dp(i, j):\\n\\t\\t\\t\\tif i == -1:\\n\\t\\t\\t\\t\\treturn j+1\\n\\t\\t\\t\\tif j == -1:\\n\\t\\t\\t\\t\\treturn i+1\\n\\n\\t\\t\\t\\tif word1[i] == word2[j]:\\n\\t\\t\\t\\t\\treturn dp(i-1,j-1)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn min(\\n\\t\\t\\t\\t\\t\\tdp(i,j-1)+1,\\n\\t\\t\\t\\t\\t\\tdp(i-1,j)+1,\\n\\t\\t\\t\\t\\t\\tdp(i-1,j-1)+1\\n\\t\\t\\t\\t\\t)\\n\\n\\t\\t\\treturn dp(len(word1)-1, len(word2)-1)",
                "solutionTags": [],
                "code": "\\tfrom functools import cache\\n\\tclass Solution:\\n\\t\\tdef minDistance(self, word1: str, word2: str) -> int:\\n\\t\\t\\t@cache\\n\\t\\t\\tdef dp(i, j):\\n\\t\\t\\t\\tif i == -1:\\n\\t\\t\\t\\t\\treturn j+1\\n\\t\\t\\t\\tif j == -1:\\n\\t\\t\\t\\t\\treturn i+1\\n\\n\\t\\t\\t\\tif word1[i] == word2[j]:\\n\\t\\t\\t\\t\\treturn dp(i-1,j-1)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn min(\\n\\t\\t\\t\\t\\t\\tdp(i,j-1)+1,\\n\\t\\t\\t\\t\\t\\tdp(i-1,j)+1,\\n\\t\\t\\t\\t\\t\\tdp(i-1,j-1)+1\\n\\t\\t\\t\\t\\t)\\n\\n\\t\\t\\treturn dp(len(word1)-1, len(word2)-1)",
                "codeTag": "Java"
            },
            {
                "id": 1011449,
                "title": "c-bottom-up-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m=word1.length();\\n        int n=word2.length();\\n        int dp[m+1][n+1];\\n        for(int i=0;i<=m;i++) {\\n            for(int j=0;j<=n;j++)  {\\n                if(i==0) \\n                    dp[i][j]=j;\\n                else if(j==0) \\n                    dp[i][j]=i;\\n                else if(word1[i-1]==word2[j-1])\\n                    dp[i][j] = dp[i-1][j-1];\\n                else \\n                    dp[i][j] = 1+min(dp[i][j-1],min(dp[i-1][j],dp[i-1][j-1]));\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m=word1.length();\\n        int n=word2.length();\\n        int dp[m+1][n+1];\\n        for(int i=0;i<=m;i++) {\\n            for(int j=0;j<=n;j++)  {\\n                if(i==0) \\n                    dp[i][j]=j;\\n                else if(j==0) \\n                    dp[i][j]=i;\\n                else if(word1[i-1]==word2[j-1])\\n                    dp[i][j] = dp[i-1][j-1];\\n                else \\n                    dp[i][j] = 1+min(dp[i][j-1],min(dp[i-1][j],dp[i-1][j-1]));\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 746823,
                "title": "python3-dynamic-programming-solution-faster-than-94-less-than-85",
                "content": "```\\n\\'\\'\\'\\nsolution 1\\n\\'\\'\\'\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        # base case\\n        i = len(word1) - 1\\n        j = len(word2) - 1\\n        \\n        # recording repeating sub-questions\\n        memo = dict()  \\n        \\n        def dp(i, j) -> int:\\n            if i == -1: return j + 1\\n            if j == -1: return i + 1\\n            if (i, j) in memo:\\n                return memo[(i, j)]\\n            \\n            if word1[i] == word2[j]:\\n                memo[(i, j)] = dp(i-1, j-1)\\n            else:\\n                memo[(i, j)] = min(\\n                    dp(i-1, j) + 1,\\n                    dp(i, j-1) + 1,\\n                    dp(i-1, j-1) + 1\\n                )\\n            return memo[(i, j)]\\n        \\n        return dp(i, j)\\n```\\nIf you want to get how it work and understand Chinese, please refer to: [\\u7F16\\u8F91\\u8DDD\\u79BB-\\u52A8\\u6001\\u89C4\\u5212](https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/bian-ji-ju-li).",
                "solutionTags": [],
                "code": "```\\n\\'\\'\\'\\nsolution 1\\n\\'\\'\\'\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        # base case\\n        i = len(word1) - 1\\n        j = len(word2) - 1\\n        \\n        # recording repeating sub-questions\\n        memo = dict()  \\n        \\n        def dp(i, j) -> int:\\n            if i == -1: return j + 1\\n            if j == -1: return i + 1\\n            if (i, j) in memo:\\n                return memo[(i, j)]\\n            \\n            if word1[i] == word2[j]:\\n                memo[(i, j)] = dp(i-1, j-1)\\n            else:\\n                memo[(i, j)] = min(\\n                    dp(i-1, j) + 1,\\n                    dp(i, j-1) + 1,\\n                    dp(i-1, j-1) + 1\\n                )\\n            return memo[(i, j)]\\n        \\n        return dp(i, j)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 717692,
                "title": "c",
                "content": "reference: https://www.youtube.com/watch?v=We3YDTzNXEk&t=0s&list=PLrmLmBdmIlpsHaNTPP_jHHDx_os9ItYXr&index=8\\n\\n```\\npublic class Solution {\\n    public int MinDistance(string word1, string word2) {\\n        if (word1 == string.Empty)\\n            return word2.Length;\\n        else if (word2 == string.Empty)\\n            return word1.Length;\\n        \\n        int [,] res = new int[word1.Length + 1, word2.Length + 1];\\n        \\n        for (int i = 0; i <= word1.Length; i++)\\n            res[i, 0] = i;\\n        \\n        for (int i = 1; i <= word2.Length; i++)\\n            res[0, i] = i;\\n        \\n        for (int i = 1; i <= word1.Length; i++)\\n            for (int j = 1; j <= word2.Length; j++)\\n                if (word1[i - 1] == word2[j - 1])\\n                    res[i, j] = res[i - 1, j - 1];\\n                else\\n                    res[i, j] = Math.Min(res[i - 1, j -1], Math.Min(res[i - 1, j], res[i, j - 1])) + 1;\\n                \\n        return res[word1.Length, word2.Length];\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int MinDistance(string word1, string word2) {\\n        if (word1 == string.Empty)\\n            return word2.Length;\\n        else if (word2 == string.Empty)\\n            return word1.Length;\\n        \\n        int [,] res = new int[word1.Length + 1, word2.Length + 1];\\n        \\n        for (int i = 0; i <= word1.Length; i++)\\n            res[i, 0] = i;\\n        \\n        for (int i = 1; i <= word2.Length; i++)\\n            res[0, i] = i;\\n        \\n        for (int i = 1; i <= word1.Length; i++)\\n            for (int j = 1; j <= word2.Length; j++)\\n                if (word1[i - 1] == word2[j - 1])\\n                    res[i, j] = res[i - 1, j - 1];\\n                else\\n                    res[i, j] = Math.Min(res[i - 1, j -1], Math.Min(res[i - 1, j], res[i, j - 1])) + 1;\\n                \\n        return res[word1.Length, word2.Length];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 662931,
                "title": "edit-distance-cpp-c-pictorial-representation-easy-to-understand",
                "content": "This is the one of the very common dp question:\\n**Basic Intution**: to conver a character how many operations are needed. with this intution we can solve this question\\n_________________________________________________________________________________________________\\n\\n![image](https://assets.leetcode.com/users/bhaviripudi/image_1590934817.png)\\n\\nFigure 1\\n_________________________________________________________________________________________________\\n\\nreference from the above image we will try to consturct the dp matrix for the solution, later we will try to find the recurrence for this solution.\\n_________________________________________________________________________________________________\\n\\n\\n\\n![image](https://assets.leetcode.com/users/bhaviripudi/image_1590935332.png)\\n\\nFigure 2\\n_________________________________________________________________________________________________\\n\\n\\n\\n![image](https://assets.leetcode.com/users/bhaviripudi/image_1590935730.png)\\n\\nFigure 3\\n_________________________________________________________________________________________________\\n\\n![image](https://assets.leetcode.com/users/bhaviripudi/image_1590936072.png)\\n\\nFigure 4\\n_________________________________________________________________________________________________\\n\\n\\nFinally...: The DP Matrix looks like \\n\\n![image](https://assets.leetcode.com/users/bhaviripudi/image_1590943224.png)\\n\\nFigure 5\\n_________________________________________________________________________________________________\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int _firstStrng = word1.size();\\n        int _secondString = word2. size();\\n        \\n        vector<vector<int>> dp(_firstStrng+1,vector<int>(_secondString+1,0));\\n        \\n        for(int row =0; row<= _firstStrng ; row++){\\n            for(int col=0; col<=_secondString; col++){\\n                if(row == 0 ) dp[row][col] = col;\\n                else if( col== 0 ) dp[row][col] = row;\\n                \\n                else if (word1 [row-1] == word2[col-1]) dp[row][col] = dp[row-1][col-1];\\n                else\\n                    dp[row][col] = 1+ min(min(dp[row][col-1], dp[row-1][col]), dp[row-1][col-1]);\\n            }\\n        }\\n        return dp[_firstStrng][_secondString];\\n    }\\n};\\n```\\n\\nNote: Please let me know in the comments.. if you require any other help, or edits in the post.\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int _firstStrng = word1.size();\\n        int _secondString = word2. size();\\n        \\n        vector<vector<int>> dp(_firstStrng+1,vector<int>(_secondString+1,0));\\n        \\n        for(int row =0; row<= _firstStrng ; row++){\\n            for(int col=0; col<=_secondString; col++){\\n                if(row == 0 ) dp[row][col] = col;\\n                else if( col== 0 ) dp[row][col] = row;\\n                \\n                else if (word1 [row-1] == word2[col-1]) dp[row][col] = dp[row-1][col-1];\\n                else\\n                    dp[row][col] = 1+ min(min(dp[row][col-1], dp[row-1][col]), dp[row-1][col-1]);\\n            }\\n        }\\n        return dp[_firstStrng][_secondString];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 662426,
                "title": "c-dp-bottom-up-simple-and-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = word1.size();\\n        int n = word2.size();\\n        int **output = new int*[m+1];\\n        for(int i=0; i<=m; i++)\\n        {\\n            output[i]=new int[n+1];\\n        }\\n        //fill first row\\n        for(int j=0; j<=n; j++)\\n        {\\n            output[0][j]=j;\\n        }\\n        //fill first col\\n        for(int i=0; i<=m; i++)\\n        {\\n            output[i][0]=i;\\n        }\\n\\n        for(int i=1; i<=m; i++)\\n        {\\n            for(int j=1; j<=n; j++)\\n            {\\n                if(word1[m-i]==word2[n-j])\\n                {\\n                    output[i][j]= output[i-1][j-1];\\n                }\\n                else\\n                {\\n                     output[i][j]= min(output[i][j-1],min(output[i-1][j],output[i-1][j-1])) + 1;\\n                }\\n            }\\n        }\\n        return output[m][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = word1.size();\\n        int n = word2.size();\\n        int **output = new int*[m+1];\\n        for(int i=0; i<=m; i++)\\n        {\\n            output[i]=new int[n+1];\\n        }\\n        //fill first row\\n        for(int j=0; j<=n; j++)\\n        {\\n            output[0][j]=j;\\n        }\\n        //fill first col\\n        for(int i=0; i<=m; i++)\\n        {\\n            output[i][0]=i;\\n        }\\n\\n        for(int i=1; i<=m; i++)\\n        {\\n            for(int j=1; j<=n; j++)\\n            {\\n                if(word1[m-i]==word2[n-j])\\n                {\\n                    output[i][j]= output[i-1][j-1];\\n                }\\n                else\\n                {\\n                     output[i][j]= min(output[i][j-1],min(output[i-1][j],output[i-1][j-1])) + 1;\\n                }\\n            }\\n        }\\n        return output[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 655602,
                "title": "python3-memoization-solution-98-95-faster",
                "content": "```\\nclass Solution:\\n    def dp(self,A,B,i,j,aux):\\n        global ans\\n        if aux[i][j]:\\n            return aux[i][j]\\n        if i==0:\\n            return j\\n        if j==0:\\n            return i\\n        if A[i-1] == B[j-1]:\\n            ans = self.dp(A,B,i-1,j-1,aux)\\n        else:\\n            ans = 1 + min(self.dp(A,B,i-1,j-1,aux), self.dp(A,B,i-1,j,aux), self.dp(A,B,i,j-1,aux))\\n        aux[i][j] = ans\\n        return ans\\n    \\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m=len(word1)\\n        n=len(word2)\\n        dp=[[0]*(n+1) for _ in range(m+1)]\\n        b=self.dp(word1,word2,m,n,dp)\\n        return b if m < 1 or n < 1 else dp[m][n]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def dp(self,A,B,i,j,aux):\\n        global ans\\n        if aux[i][j]:\\n            return aux[i][j]\\n        if i==0:\\n            return j\\n        if j==0:\\n            return i\\n        if A[i-1] == B[j-1]:\\n            ans = self.dp(A,B,i-1,j-1,aux)\\n        else:\\n            ans = 1 + min(self.dp(A,B,i-1,j-1,aux), self.dp(A,B,i-1,j,aux), self.dp(A,B,i,j-1,aux))\\n        aux[i][j] = ans\\n        return ans\\n    \\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m=len(word1)\\n        n=len(word2)\\n        dp=[[0]*(n+1) for _ in range(m+1)]\\n        b=self.dp(word1,word2,m,n,dp)\\n        return b if m < 1 or n < 1 else dp[m][n]\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1720630,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 1564737,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 1815300,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 1920807,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 1815477,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 1566473,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 1815034,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 1570128,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 1569955,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 1568243,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 1720630,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 1564737,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 1815300,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 1920807,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 1815477,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 1566473,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 1815034,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 1570128,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 1569955,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 1568243,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 2025451,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "It may be called \\'medium\\', but it\\'s definitely at the top border between medium and hard."
                    },
                    {
                        "username": "wyldbill",
                        "content": "This is actually the [Levenshtein Distance](https://en.wikipedia.org/wiki/Levenshtein_distance)\nIt is one of several different \"[Edit Distance](https://en.wikipedia.org/wiki/Edit_distance)\" problems (Hamming, Jaro, LCS, etc.)\n"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Please help me why LCS is Not Working here \\n\\n![image.png](https://assets.leetcode.com/users/images/6caacef5-7d03-46d7-ba7e-38925334ca7e_1677376352.0691617.png)"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "W1 : HORSE\\nW2: ROS\\nUNION: ROS\\nM-C = 2\\nN-C = 0\\nANS = 2\\n\\nACTUAL RESULT = 3"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I think, because we have replacements"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Because order of characters is important here."
                    },
                    {
                        "username": "Sundow",
                        "content": "Many answers solve the problems but failed to explain why dynamic programming works  and why this problem has optimal structure. I have found a paper that contains a detail proof to the solution. Here is the link: http://www.inrg.csie.ntu.edu.tw/algorithm2013/homework/Wagner-74.pdf"
                    },
                    {
                        "username": "AyonAlfa",
                        "content": "hey are u alive??? then please reply :)"
                    },
                    {
                        "username": "p_next",
                        "content": "The min number of steps converting \"horse\" to \"ros\" I've found is 4:\\n\\n 1. horse -> orse (remove 'h')\\n  \\n 2. orse   -> ors   (remove 'e')\\n\\n 3. ors     -> oros (insert 'o')\\n\\n 4. oros   -> ros   (remove 'o')\\n\\nI can't figure out how to convert them in only 3 steps,pls help me,thx!"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "prompt_07",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "quattrozhou",
                        "content": "My code pass the online judge, but I found my code could not correctly solve this problem:\\n\"abcdxabcde\", \"abcdeabcdx\"\\ngreedy method will likely fail on this test case.\\nThanks! :)"
                    },
                    {
                        "username": "seventhrankpawn",
                        "content": "I ask this question at Microsoft for the AI teams.\\n\\nIt\\'s fundamental to many derivative algorithms for sequence pattern matching, processing, error correction, error rate estimation. \\n\\nHeck most recently I\\'ve seen it applied to the attention outputs of a transformer. \\n\\nIf you\\'re serious about AI, you should know this snazzy DP."
                    },
                    {
                        "username": "ankush920",
                        "content": "ye question karte hue us time ki yaad aa gyi jab me or mera dost apni crush  ka love percentage nikalte the : )"
                    },
                    {
                        "username": "sjames8888",
                        "content": "\nfor anyone wishing to get a good hint without looking at a solution - It may be best to  think of a top down solution where \n\n1. we define a recursive function taking pointers i, j which represent substring of words 1 and 2 - these will be initialised to lengths of two strings.\n\n2. we will probably need to add memoisation later for [i][]j] but not needed for small examples like horse, hor\n\n3. we compute 3 costs - ic, dc, rp for insert, delete, replace\n\n4. for insert we call recursive function where i is reduced by 1 implying we want best cost for smaller substrng on i and cost is plus 1\n\n5. for delete as above but j is reduced by 1\n\n6. for base case if we arrive  into function when i is 0 means cost to get to substring j from empty string i is j we need to add j chars \n\n7. base case arrive where j is 0 we need cost to reduce i to empty string which is i\n\n8. replace is call where both i and j reduce by 1 but we add x where x is 1 when charAt(i-1) != charAt(j-1) else for match x is 0 implying we replace at no cost and cost for larger string i is same as that for both reduced sub strings\n\n9.  we return min of 3 above costs\n\n10. for memoise hand in int[s1.length+1]s2.length+1] before calcs above we check if we have computed - this pivots into the better dp solution which will now be obvious \n\n    if (dp[i][j] != 0) {\n            return dp[i][j];\n        }\n\n return dp[i][j] = min;\n\n11. try it on this case as well but only with above optimisation - and no printing debug!\n\n  @Test\n    void case3() {\n        final var res = new EditDistance().minDistance(\"dinitrophenylhydrazine\", \"acetylphenylhydrazine\");\n        Assertions.assertEquals(6, res);\n    }\n\nand here is trace for above where we print all these values for horse -> ros\n\n\ndepth = 6,  i = 1, j = 1, (ic = 2, dc = 2, rp = 1, x = 1), min = 1, si = h, sj = r \ndepth = 5,  i = 1, j = 2, (ic = 3, dc = 2, rp = 2, x = 1), min = 2, si = h, sj = ro \ndepth = 4,  i = 1, j = 3, (ic = 4, dc = 3, rp = 3, x = 1), min = 3, si = h, sj = ros \ndepth = 5,  i = 2, j = 1, (ic = 2, dc = 3, rp = 2, x = 1), min = 2, si = ho, sj = r \ndepth = 4,  i = 2, j = 2, (ic = 3, dc = 3, rp = 1, x = 0), min = 1, si = ho, sj = ro \ndepth = 3,  i = 2, j = 3, (ic = 4, dc = 2, rp = 3, x = 1), min = 2, si = ho, sj = ros \ndepth = 4,  i = 3, j = 1, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hor, sj = r \ndepth = 3,  i = 3, j = 2, (ic = 2, dc = 3, rp = 3, x = 1), min = 2, si = hor, sj = ro \ndepth = 2,  i = 3, j = 3, (ic = 3, dc = 3, rp = 2, x = 1), min = 2, si = hor, sj = ros \ndepth = 3,  i = 4, j = 1, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = hors, sj = r \ndepth = 2,  i = 4, j = 2, (ic = 3, dc = 4, rp = 3, x = 1), min = 3, si = hors, sj = ro \ndepth = 1,  i = 4, j = 3, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hors, sj = ros \ndepth = 2,  i = 5, j = 1, (ic = 4, dc = 6, rp = 5, x = 1), min = 4, si = horse, sj = r \ndepth = 1,  i = 5, j = 2, (ic = 4, dc = 5, rp = 4, x = 1), min = 4, si = horse, sj = ro \ndepth = 0,  i = 5, j = 3, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = horse, sj = ros \n\n\n\n\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "you provided the solution , not the tip"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "<details>\n<summary>(Click) A hint which might be useful:</summary>\nTime & Space complexity is O(word1.len * word2.len).\n</details>"
                    }
                ]
            },
            {
                "id": 1816568,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "It may be called \\'medium\\', but it\\'s definitely at the top border between medium and hard."
                    },
                    {
                        "username": "wyldbill",
                        "content": "This is actually the [Levenshtein Distance](https://en.wikipedia.org/wiki/Levenshtein_distance)\nIt is one of several different \"[Edit Distance](https://en.wikipedia.org/wiki/Edit_distance)\" problems (Hamming, Jaro, LCS, etc.)\n"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Please help me why LCS is Not Working here \\n\\n![image.png](https://assets.leetcode.com/users/images/6caacef5-7d03-46d7-ba7e-38925334ca7e_1677376352.0691617.png)"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "W1 : HORSE\\nW2: ROS\\nUNION: ROS\\nM-C = 2\\nN-C = 0\\nANS = 2\\n\\nACTUAL RESULT = 3"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I think, because we have replacements"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Because order of characters is important here."
                    },
                    {
                        "username": "Sundow",
                        "content": "Many answers solve the problems but failed to explain why dynamic programming works  and why this problem has optimal structure. I have found a paper that contains a detail proof to the solution. Here is the link: http://www.inrg.csie.ntu.edu.tw/algorithm2013/homework/Wagner-74.pdf"
                    },
                    {
                        "username": "AyonAlfa",
                        "content": "hey are u alive??? then please reply :)"
                    },
                    {
                        "username": "p_next",
                        "content": "The min number of steps converting \"horse\" to \"ros\" I've found is 4:\\n\\n 1. horse -> orse (remove 'h')\\n  \\n 2. orse   -> ors   (remove 'e')\\n\\n 3. ors     -> oros (insert 'o')\\n\\n 4. oros   -> ros   (remove 'o')\\n\\nI can't figure out how to convert them in only 3 steps,pls help me,thx!"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "prompt_07",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "quattrozhou",
                        "content": "My code pass the online judge, but I found my code could not correctly solve this problem:\\n\"abcdxabcde\", \"abcdeabcdx\"\\ngreedy method will likely fail on this test case.\\nThanks! :)"
                    },
                    {
                        "username": "seventhrankpawn",
                        "content": "I ask this question at Microsoft for the AI teams.\\n\\nIt\\'s fundamental to many derivative algorithms for sequence pattern matching, processing, error correction, error rate estimation. \\n\\nHeck most recently I\\'ve seen it applied to the attention outputs of a transformer. \\n\\nIf you\\'re serious about AI, you should know this snazzy DP."
                    },
                    {
                        "username": "ankush920",
                        "content": "ye question karte hue us time ki yaad aa gyi jab me or mera dost apni crush  ka love percentage nikalte the : )"
                    },
                    {
                        "username": "sjames8888",
                        "content": "\nfor anyone wishing to get a good hint without looking at a solution - It may be best to  think of a top down solution where \n\n1. we define a recursive function taking pointers i, j which represent substring of words 1 and 2 - these will be initialised to lengths of two strings.\n\n2. we will probably need to add memoisation later for [i][]j] but not needed for small examples like horse, hor\n\n3. we compute 3 costs - ic, dc, rp for insert, delete, replace\n\n4. for insert we call recursive function where i is reduced by 1 implying we want best cost for smaller substrng on i and cost is plus 1\n\n5. for delete as above but j is reduced by 1\n\n6. for base case if we arrive  into function when i is 0 means cost to get to substring j from empty string i is j we need to add j chars \n\n7. base case arrive where j is 0 we need cost to reduce i to empty string which is i\n\n8. replace is call where both i and j reduce by 1 but we add x where x is 1 when charAt(i-1) != charAt(j-1) else for match x is 0 implying we replace at no cost and cost for larger string i is same as that for both reduced sub strings\n\n9.  we return min of 3 above costs\n\n10. for memoise hand in int[s1.length+1]s2.length+1] before calcs above we check if we have computed - this pivots into the better dp solution which will now be obvious \n\n    if (dp[i][j] != 0) {\n            return dp[i][j];\n        }\n\n return dp[i][j] = min;\n\n11. try it on this case as well but only with above optimisation - and no printing debug!\n\n  @Test\n    void case3() {\n        final var res = new EditDistance().minDistance(\"dinitrophenylhydrazine\", \"acetylphenylhydrazine\");\n        Assertions.assertEquals(6, res);\n    }\n\nand here is trace for above where we print all these values for horse -> ros\n\n\ndepth = 6,  i = 1, j = 1, (ic = 2, dc = 2, rp = 1, x = 1), min = 1, si = h, sj = r \ndepth = 5,  i = 1, j = 2, (ic = 3, dc = 2, rp = 2, x = 1), min = 2, si = h, sj = ro \ndepth = 4,  i = 1, j = 3, (ic = 4, dc = 3, rp = 3, x = 1), min = 3, si = h, sj = ros \ndepth = 5,  i = 2, j = 1, (ic = 2, dc = 3, rp = 2, x = 1), min = 2, si = ho, sj = r \ndepth = 4,  i = 2, j = 2, (ic = 3, dc = 3, rp = 1, x = 0), min = 1, si = ho, sj = ro \ndepth = 3,  i = 2, j = 3, (ic = 4, dc = 2, rp = 3, x = 1), min = 2, si = ho, sj = ros \ndepth = 4,  i = 3, j = 1, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hor, sj = r \ndepth = 3,  i = 3, j = 2, (ic = 2, dc = 3, rp = 3, x = 1), min = 2, si = hor, sj = ro \ndepth = 2,  i = 3, j = 3, (ic = 3, dc = 3, rp = 2, x = 1), min = 2, si = hor, sj = ros \ndepth = 3,  i = 4, j = 1, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = hors, sj = r \ndepth = 2,  i = 4, j = 2, (ic = 3, dc = 4, rp = 3, x = 1), min = 3, si = hors, sj = ro \ndepth = 1,  i = 4, j = 3, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hors, sj = ros \ndepth = 2,  i = 5, j = 1, (ic = 4, dc = 6, rp = 5, x = 1), min = 4, si = horse, sj = r \ndepth = 1,  i = 5, j = 2, (ic = 4, dc = 5, rp = 4, x = 1), min = 4, si = horse, sj = ro \ndepth = 0,  i = 5, j = 3, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = horse, sj = ros \n\n\n\n\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "you provided the solution , not the tip"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "<details>\n<summary>(Click) A hint which might be useful:</summary>\nTime & Space complexity is O(word1.len * word2.len).\n</details>"
                    }
                ]
            },
            {
                "id": 1814605,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "It may be called \\'medium\\', but it\\'s definitely at the top border between medium and hard."
                    },
                    {
                        "username": "wyldbill",
                        "content": "This is actually the [Levenshtein Distance](https://en.wikipedia.org/wiki/Levenshtein_distance)\nIt is one of several different \"[Edit Distance](https://en.wikipedia.org/wiki/Edit_distance)\" problems (Hamming, Jaro, LCS, etc.)\n"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Please help me why LCS is Not Working here \\n\\n![image.png](https://assets.leetcode.com/users/images/6caacef5-7d03-46d7-ba7e-38925334ca7e_1677376352.0691617.png)"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "W1 : HORSE\\nW2: ROS\\nUNION: ROS\\nM-C = 2\\nN-C = 0\\nANS = 2\\n\\nACTUAL RESULT = 3"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I think, because we have replacements"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Because order of characters is important here."
                    },
                    {
                        "username": "Sundow",
                        "content": "Many answers solve the problems but failed to explain why dynamic programming works  and why this problem has optimal structure. I have found a paper that contains a detail proof to the solution. Here is the link: http://www.inrg.csie.ntu.edu.tw/algorithm2013/homework/Wagner-74.pdf"
                    },
                    {
                        "username": "AyonAlfa",
                        "content": "hey are u alive??? then please reply :)"
                    },
                    {
                        "username": "p_next",
                        "content": "The min number of steps converting \"horse\" to \"ros\" I've found is 4:\\n\\n 1. horse -> orse (remove 'h')\\n  \\n 2. orse   -> ors   (remove 'e')\\n\\n 3. ors     -> oros (insert 'o')\\n\\n 4. oros   -> ros   (remove 'o')\\n\\nI can't figure out how to convert them in only 3 steps,pls help me,thx!"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "prompt_07",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "quattrozhou",
                        "content": "My code pass the online judge, but I found my code could not correctly solve this problem:\\n\"abcdxabcde\", \"abcdeabcdx\"\\ngreedy method will likely fail on this test case.\\nThanks! :)"
                    },
                    {
                        "username": "seventhrankpawn",
                        "content": "I ask this question at Microsoft for the AI teams.\\n\\nIt\\'s fundamental to many derivative algorithms for sequence pattern matching, processing, error correction, error rate estimation. \\n\\nHeck most recently I\\'ve seen it applied to the attention outputs of a transformer. \\n\\nIf you\\'re serious about AI, you should know this snazzy DP."
                    },
                    {
                        "username": "ankush920",
                        "content": "ye question karte hue us time ki yaad aa gyi jab me or mera dost apni crush  ka love percentage nikalte the : )"
                    },
                    {
                        "username": "sjames8888",
                        "content": "\nfor anyone wishing to get a good hint without looking at a solution - It may be best to  think of a top down solution where \n\n1. we define a recursive function taking pointers i, j which represent substring of words 1 and 2 - these will be initialised to lengths of two strings.\n\n2. we will probably need to add memoisation later for [i][]j] but not needed for small examples like horse, hor\n\n3. we compute 3 costs - ic, dc, rp for insert, delete, replace\n\n4. for insert we call recursive function where i is reduced by 1 implying we want best cost for smaller substrng on i and cost is plus 1\n\n5. for delete as above but j is reduced by 1\n\n6. for base case if we arrive  into function when i is 0 means cost to get to substring j from empty string i is j we need to add j chars \n\n7. base case arrive where j is 0 we need cost to reduce i to empty string which is i\n\n8. replace is call where both i and j reduce by 1 but we add x where x is 1 when charAt(i-1) != charAt(j-1) else for match x is 0 implying we replace at no cost and cost for larger string i is same as that for both reduced sub strings\n\n9.  we return min of 3 above costs\n\n10. for memoise hand in int[s1.length+1]s2.length+1] before calcs above we check if we have computed - this pivots into the better dp solution which will now be obvious \n\n    if (dp[i][j] != 0) {\n            return dp[i][j];\n        }\n\n return dp[i][j] = min;\n\n11. try it on this case as well but only with above optimisation - and no printing debug!\n\n  @Test\n    void case3() {\n        final var res = new EditDistance().minDistance(\"dinitrophenylhydrazine\", \"acetylphenylhydrazine\");\n        Assertions.assertEquals(6, res);\n    }\n\nand here is trace for above where we print all these values for horse -> ros\n\n\ndepth = 6,  i = 1, j = 1, (ic = 2, dc = 2, rp = 1, x = 1), min = 1, si = h, sj = r \ndepth = 5,  i = 1, j = 2, (ic = 3, dc = 2, rp = 2, x = 1), min = 2, si = h, sj = ro \ndepth = 4,  i = 1, j = 3, (ic = 4, dc = 3, rp = 3, x = 1), min = 3, si = h, sj = ros \ndepth = 5,  i = 2, j = 1, (ic = 2, dc = 3, rp = 2, x = 1), min = 2, si = ho, sj = r \ndepth = 4,  i = 2, j = 2, (ic = 3, dc = 3, rp = 1, x = 0), min = 1, si = ho, sj = ro \ndepth = 3,  i = 2, j = 3, (ic = 4, dc = 2, rp = 3, x = 1), min = 2, si = ho, sj = ros \ndepth = 4,  i = 3, j = 1, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hor, sj = r \ndepth = 3,  i = 3, j = 2, (ic = 2, dc = 3, rp = 3, x = 1), min = 2, si = hor, sj = ro \ndepth = 2,  i = 3, j = 3, (ic = 3, dc = 3, rp = 2, x = 1), min = 2, si = hor, sj = ros \ndepth = 3,  i = 4, j = 1, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = hors, sj = r \ndepth = 2,  i = 4, j = 2, (ic = 3, dc = 4, rp = 3, x = 1), min = 3, si = hors, sj = ro \ndepth = 1,  i = 4, j = 3, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hors, sj = ros \ndepth = 2,  i = 5, j = 1, (ic = 4, dc = 6, rp = 5, x = 1), min = 4, si = horse, sj = r \ndepth = 1,  i = 5, j = 2, (ic = 4, dc = 5, rp = 4, x = 1), min = 4, si = horse, sj = ro \ndepth = 0,  i = 5, j = 3, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = horse, sj = ros \n\n\n\n\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "you provided the solution , not the tip"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "<details>\n<summary>(Click) A hint which might be useful:</summary>\nTime & Space complexity is O(word1.len * word2.len).\n</details>"
                    }
                ]
            },
            {
                "id": 1572780,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "It may be called \\'medium\\', but it\\'s definitely at the top border between medium and hard."
                    },
                    {
                        "username": "wyldbill",
                        "content": "This is actually the [Levenshtein Distance](https://en.wikipedia.org/wiki/Levenshtein_distance)\nIt is one of several different \"[Edit Distance](https://en.wikipedia.org/wiki/Edit_distance)\" problems (Hamming, Jaro, LCS, etc.)\n"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Please help me why LCS is Not Working here \\n\\n![image.png](https://assets.leetcode.com/users/images/6caacef5-7d03-46d7-ba7e-38925334ca7e_1677376352.0691617.png)"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "W1 : HORSE\\nW2: ROS\\nUNION: ROS\\nM-C = 2\\nN-C = 0\\nANS = 2\\n\\nACTUAL RESULT = 3"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I think, because we have replacements"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Because order of characters is important here."
                    },
                    {
                        "username": "Sundow",
                        "content": "Many answers solve the problems but failed to explain why dynamic programming works  and why this problem has optimal structure. I have found a paper that contains a detail proof to the solution. Here is the link: http://www.inrg.csie.ntu.edu.tw/algorithm2013/homework/Wagner-74.pdf"
                    },
                    {
                        "username": "AyonAlfa",
                        "content": "hey are u alive??? then please reply :)"
                    },
                    {
                        "username": "p_next",
                        "content": "The min number of steps converting \"horse\" to \"ros\" I've found is 4:\\n\\n 1. horse -> orse (remove 'h')\\n  \\n 2. orse   -> ors   (remove 'e')\\n\\n 3. ors     -> oros (insert 'o')\\n\\n 4. oros   -> ros   (remove 'o')\\n\\nI can't figure out how to convert them in only 3 steps,pls help me,thx!"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "prompt_07",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "quattrozhou",
                        "content": "My code pass the online judge, but I found my code could not correctly solve this problem:\\n\"abcdxabcde\", \"abcdeabcdx\"\\ngreedy method will likely fail on this test case.\\nThanks! :)"
                    },
                    {
                        "username": "seventhrankpawn",
                        "content": "I ask this question at Microsoft for the AI teams.\\n\\nIt\\'s fundamental to many derivative algorithms for sequence pattern matching, processing, error correction, error rate estimation. \\n\\nHeck most recently I\\'ve seen it applied to the attention outputs of a transformer. \\n\\nIf you\\'re serious about AI, you should know this snazzy DP."
                    },
                    {
                        "username": "ankush920",
                        "content": "ye question karte hue us time ki yaad aa gyi jab me or mera dost apni crush  ka love percentage nikalte the : )"
                    },
                    {
                        "username": "sjames8888",
                        "content": "\nfor anyone wishing to get a good hint without looking at a solution - It may be best to  think of a top down solution where \n\n1. we define a recursive function taking pointers i, j which represent substring of words 1 and 2 - these will be initialised to lengths of two strings.\n\n2. we will probably need to add memoisation later for [i][]j] but not needed for small examples like horse, hor\n\n3. we compute 3 costs - ic, dc, rp for insert, delete, replace\n\n4. for insert we call recursive function where i is reduced by 1 implying we want best cost for smaller substrng on i and cost is plus 1\n\n5. for delete as above but j is reduced by 1\n\n6. for base case if we arrive  into function when i is 0 means cost to get to substring j from empty string i is j we need to add j chars \n\n7. base case arrive where j is 0 we need cost to reduce i to empty string which is i\n\n8. replace is call where both i and j reduce by 1 but we add x where x is 1 when charAt(i-1) != charAt(j-1) else for match x is 0 implying we replace at no cost and cost for larger string i is same as that for both reduced sub strings\n\n9.  we return min of 3 above costs\n\n10. for memoise hand in int[s1.length+1]s2.length+1] before calcs above we check if we have computed - this pivots into the better dp solution which will now be obvious \n\n    if (dp[i][j] != 0) {\n            return dp[i][j];\n        }\n\n return dp[i][j] = min;\n\n11. try it on this case as well but only with above optimisation - and no printing debug!\n\n  @Test\n    void case3() {\n        final var res = new EditDistance().minDistance(\"dinitrophenylhydrazine\", \"acetylphenylhydrazine\");\n        Assertions.assertEquals(6, res);\n    }\n\nand here is trace for above where we print all these values for horse -> ros\n\n\ndepth = 6,  i = 1, j = 1, (ic = 2, dc = 2, rp = 1, x = 1), min = 1, si = h, sj = r \ndepth = 5,  i = 1, j = 2, (ic = 3, dc = 2, rp = 2, x = 1), min = 2, si = h, sj = ro \ndepth = 4,  i = 1, j = 3, (ic = 4, dc = 3, rp = 3, x = 1), min = 3, si = h, sj = ros \ndepth = 5,  i = 2, j = 1, (ic = 2, dc = 3, rp = 2, x = 1), min = 2, si = ho, sj = r \ndepth = 4,  i = 2, j = 2, (ic = 3, dc = 3, rp = 1, x = 0), min = 1, si = ho, sj = ro \ndepth = 3,  i = 2, j = 3, (ic = 4, dc = 2, rp = 3, x = 1), min = 2, si = ho, sj = ros \ndepth = 4,  i = 3, j = 1, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hor, sj = r \ndepth = 3,  i = 3, j = 2, (ic = 2, dc = 3, rp = 3, x = 1), min = 2, si = hor, sj = ro \ndepth = 2,  i = 3, j = 3, (ic = 3, dc = 3, rp = 2, x = 1), min = 2, si = hor, sj = ros \ndepth = 3,  i = 4, j = 1, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = hors, sj = r \ndepth = 2,  i = 4, j = 2, (ic = 3, dc = 4, rp = 3, x = 1), min = 3, si = hors, sj = ro \ndepth = 1,  i = 4, j = 3, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hors, sj = ros \ndepth = 2,  i = 5, j = 1, (ic = 4, dc = 6, rp = 5, x = 1), min = 4, si = horse, sj = r \ndepth = 1,  i = 5, j = 2, (ic = 4, dc = 5, rp = 4, x = 1), min = 4, si = horse, sj = ro \ndepth = 0,  i = 5, j = 3, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = horse, sj = ros \n\n\n\n\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "you provided the solution , not the tip"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "<details>\n<summary>(Click) A hint which might be useful:</summary>\nTime & Space complexity is O(word1.len * word2.len).\n</details>"
                    }
                ]
            },
            {
                "id": 1568893,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "It may be called \\'medium\\', but it\\'s definitely at the top border between medium and hard."
                    },
                    {
                        "username": "wyldbill",
                        "content": "This is actually the [Levenshtein Distance](https://en.wikipedia.org/wiki/Levenshtein_distance)\nIt is one of several different \"[Edit Distance](https://en.wikipedia.org/wiki/Edit_distance)\" problems (Hamming, Jaro, LCS, etc.)\n"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Please help me why LCS is Not Working here \\n\\n![image.png](https://assets.leetcode.com/users/images/6caacef5-7d03-46d7-ba7e-38925334ca7e_1677376352.0691617.png)"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "W1 : HORSE\\nW2: ROS\\nUNION: ROS\\nM-C = 2\\nN-C = 0\\nANS = 2\\n\\nACTUAL RESULT = 3"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I think, because we have replacements"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Because order of characters is important here."
                    },
                    {
                        "username": "Sundow",
                        "content": "Many answers solve the problems but failed to explain why dynamic programming works  and why this problem has optimal structure. I have found a paper that contains a detail proof to the solution. Here is the link: http://www.inrg.csie.ntu.edu.tw/algorithm2013/homework/Wagner-74.pdf"
                    },
                    {
                        "username": "AyonAlfa",
                        "content": "hey are u alive??? then please reply :)"
                    },
                    {
                        "username": "p_next",
                        "content": "The min number of steps converting \"horse\" to \"ros\" I've found is 4:\\n\\n 1. horse -> orse (remove 'h')\\n  \\n 2. orse   -> ors   (remove 'e')\\n\\n 3. ors     -> oros (insert 'o')\\n\\n 4. oros   -> ros   (remove 'o')\\n\\nI can't figure out how to convert them in only 3 steps,pls help me,thx!"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "prompt_07",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "quattrozhou",
                        "content": "My code pass the online judge, but I found my code could not correctly solve this problem:\\n\"abcdxabcde\", \"abcdeabcdx\"\\ngreedy method will likely fail on this test case.\\nThanks! :)"
                    },
                    {
                        "username": "seventhrankpawn",
                        "content": "I ask this question at Microsoft for the AI teams.\\n\\nIt\\'s fundamental to many derivative algorithms for sequence pattern matching, processing, error correction, error rate estimation. \\n\\nHeck most recently I\\'ve seen it applied to the attention outputs of a transformer. \\n\\nIf you\\'re serious about AI, you should know this snazzy DP."
                    },
                    {
                        "username": "ankush920",
                        "content": "ye question karte hue us time ki yaad aa gyi jab me or mera dost apni crush  ka love percentage nikalte the : )"
                    },
                    {
                        "username": "sjames8888",
                        "content": "\nfor anyone wishing to get a good hint without looking at a solution - It may be best to  think of a top down solution where \n\n1. we define a recursive function taking pointers i, j which represent substring of words 1 and 2 - these will be initialised to lengths of two strings.\n\n2. we will probably need to add memoisation later for [i][]j] but not needed for small examples like horse, hor\n\n3. we compute 3 costs - ic, dc, rp for insert, delete, replace\n\n4. for insert we call recursive function where i is reduced by 1 implying we want best cost for smaller substrng on i and cost is plus 1\n\n5. for delete as above but j is reduced by 1\n\n6. for base case if we arrive  into function when i is 0 means cost to get to substring j from empty string i is j we need to add j chars \n\n7. base case arrive where j is 0 we need cost to reduce i to empty string which is i\n\n8. replace is call where both i and j reduce by 1 but we add x where x is 1 when charAt(i-1) != charAt(j-1) else for match x is 0 implying we replace at no cost and cost for larger string i is same as that for both reduced sub strings\n\n9.  we return min of 3 above costs\n\n10. for memoise hand in int[s1.length+1]s2.length+1] before calcs above we check if we have computed - this pivots into the better dp solution which will now be obvious \n\n    if (dp[i][j] != 0) {\n            return dp[i][j];\n        }\n\n return dp[i][j] = min;\n\n11. try it on this case as well but only with above optimisation - and no printing debug!\n\n  @Test\n    void case3() {\n        final var res = new EditDistance().minDistance(\"dinitrophenylhydrazine\", \"acetylphenylhydrazine\");\n        Assertions.assertEquals(6, res);\n    }\n\nand here is trace for above where we print all these values for horse -> ros\n\n\ndepth = 6,  i = 1, j = 1, (ic = 2, dc = 2, rp = 1, x = 1), min = 1, si = h, sj = r \ndepth = 5,  i = 1, j = 2, (ic = 3, dc = 2, rp = 2, x = 1), min = 2, si = h, sj = ro \ndepth = 4,  i = 1, j = 3, (ic = 4, dc = 3, rp = 3, x = 1), min = 3, si = h, sj = ros \ndepth = 5,  i = 2, j = 1, (ic = 2, dc = 3, rp = 2, x = 1), min = 2, si = ho, sj = r \ndepth = 4,  i = 2, j = 2, (ic = 3, dc = 3, rp = 1, x = 0), min = 1, si = ho, sj = ro \ndepth = 3,  i = 2, j = 3, (ic = 4, dc = 2, rp = 3, x = 1), min = 2, si = ho, sj = ros \ndepth = 4,  i = 3, j = 1, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hor, sj = r \ndepth = 3,  i = 3, j = 2, (ic = 2, dc = 3, rp = 3, x = 1), min = 2, si = hor, sj = ro \ndepth = 2,  i = 3, j = 3, (ic = 3, dc = 3, rp = 2, x = 1), min = 2, si = hor, sj = ros \ndepth = 3,  i = 4, j = 1, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = hors, sj = r \ndepth = 2,  i = 4, j = 2, (ic = 3, dc = 4, rp = 3, x = 1), min = 3, si = hors, sj = ro \ndepth = 1,  i = 4, j = 3, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hors, sj = ros \ndepth = 2,  i = 5, j = 1, (ic = 4, dc = 6, rp = 5, x = 1), min = 4, si = horse, sj = r \ndepth = 1,  i = 5, j = 2, (ic = 4, dc = 5, rp = 4, x = 1), min = 4, si = horse, sj = ro \ndepth = 0,  i = 5, j = 3, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = horse, sj = ros \n\n\n\n\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "you provided the solution , not the tip"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "<details>\n<summary>(Click) A hint which might be useful:</summary>\nTime & Space complexity is O(word1.len * word2.len).\n</details>"
                    }
                ]
            },
            {
                "id": 1571170,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "It may be called \\'medium\\', but it\\'s definitely at the top border between medium and hard."
                    },
                    {
                        "username": "wyldbill",
                        "content": "This is actually the [Levenshtein Distance](https://en.wikipedia.org/wiki/Levenshtein_distance)\nIt is one of several different \"[Edit Distance](https://en.wikipedia.org/wiki/Edit_distance)\" problems (Hamming, Jaro, LCS, etc.)\n"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Please help me why LCS is Not Working here \\n\\n![image.png](https://assets.leetcode.com/users/images/6caacef5-7d03-46d7-ba7e-38925334ca7e_1677376352.0691617.png)"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "W1 : HORSE\\nW2: ROS\\nUNION: ROS\\nM-C = 2\\nN-C = 0\\nANS = 2\\n\\nACTUAL RESULT = 3"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I think, because we have replacements"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Because order of characters is important here."
                    },
                    {
                        "username": "Sundow",
                        "content": "Many answers solve the problems but failed to explain why dynamic programming works  and why this problem has optimal structure. I have found a paper that contains a detail proof to the solution. Here is the link: http://www.inrg.csie.ntu.edu.tw/algorithm2013/homework/Wagner-74.pdf"
                    },
                    {
                        "username": "AyonAlfa",
                        "content": "hey are u alive??? then please reply :)"
                    },
                    {
                        "username": "p_next",
                        "content": "The min number of steps converting \"horse\" to \"ros\" I've found is 4:\\n\\n 1. horse -> orse (remove 'h')\\n  \\n 2. orse   -> ors   (remove 'e')\\n\\n 3. ors     -> oros (insert 'o')\\n\\n 4. oros   -> ros   (remove 'o')\\n\\nI can't figure out how to convert them in only 3 steps,pls help me,thx!"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "prompt_07",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "quattrozhou",
                        "content": "My code pass the online judge, but I found my code could not correctly solve this problem:\\n\"abcdxabcde\", \"abcdeabcdx\"\\ngreedy method will likely fail on this test case.\\nThanks! :)"
                    },
                    {
                        "username": "seventhrankpawn",
                        "content": "I ask this question at Microsoft for the AI teams.\\n\\nIt\\'s fundamental to many derivative algorithms for sequence pattern matching, processing, error correction, error rate estimation. \\n\\nHeck most recently I\\'ve seen it applied to the attention outputs of a transformer. \\n\\nIf you\\'re serious about AI, you should know this snazzy DP."
                    },
                    {
                        "username": "ankush920",
                        "content": "ye question karte hue us time ki yaad aa gyi jab me or mera dost apni crush  ka love percentage nikalte the : )"
                    },
                    {
                        "username": "sjames8888",
                        "content": "\nfor anyone wishing to get a good hint without looking at a solution - It may be best to  think of a top down solution where \n\n1. we define a recursive function taking pointers i, j which represent substring of words 1 and 2 - these will be initialised to lengths of two strings.\n\n2. we will probably need to add memoisation later for [i][]j] but not needed for small examples like horse, hor\n\n3. we compute 3 costs - ic, dc, rp for insert, delete, replace\n\n4. for insert we call recursive function where i is reduced by 1 implying we want best cost for smaller substrng on i and cost is plus 1\n\n5. for delete as above but j is reduced by 1\n\n6. for base case if we arrive  into function when i is 0 means cost to get to substring j from empty string i is j we need to add j chars \n\n7. base case arrive where j is 0 we need cost to reduce i to empty string which is i\n\n8. replace is call where both i and j reduce by 1 but we add x where x is 1 when charAt(i-1) != charAt(j-1) else for match x is 0 implying we replace at no cost and cost for larger string i is same as that for both reduced sub strings\n\n9.  we return min of 3 above costs\n\n10. for memoise hand in int[s1.length+1]s2.length+1] before calcs above we check if we have computed - this pivots into the better dp solution which will now be obvious \n\n    if (dp[i][j] != 0) {\n            return dp[i][j];\n        }\n\n return dp[i][j] = min;\n\n11. try it on this case as well but only with above optimisation - and no printing debug!\n\n  @Test\n    void case3() {\n        final var res = new EditDistance().minDistance(\"dinitrophenylhydrazine\", \"acetylphenylhydrazine\");\n        Assertions.assertEquals(6, res);\n    }\n\nand here is trace for above where we print all these values for horse -> ros\n\n\ndepth = 6,  i = 1, j = 1, (ic = 2, dc = 2, rp = 1, x = 1), min = 1, si = h, sj = r \ndepth = 5,  i = 1, j = 2, (ic = 3, dc = 2, rp = 2, x = 1), min = 2, si = h, sj = ro \ndepth = 4,  i = 1, j = 3, (ic = 4, dc = 3, rp = 3, x = 1), min = 3, si = h, sj = ros \ndepth = 5,  i = 2, j = 1, (ic = 2, dc = 3, rp = 2, x = 1), min = 2, si = ho, sj = r \ndepth = 4,  i = 2, j = 2, (ic = 3, dc = 3, rp = 1, x = 0), min = 1, si = ho, sj = ro \ndepth = 3,  i = 2, j = 3, (ic = 4, dc = 2, rp = 3, x = 1), min = 2, si = ho, sj = ros \ndepth = 4,  i = 3, j = 1, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hor, sj = r \ndepth = 3,  i = 3, j = 2, (ic = 2, dc = 3, rp = 3, x = 1), min = 2, si = hor, sj = ro \ndepth = 2,  i = 3, j = 3, (ic = 3, dc = 3, rp = 2, x = 1), min = 2, si = hor, sj = ros \ndepth = 3,  i = 4, j = 1, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = hors, sj = r \ndepth = 2,  i = 4, j = 2, (ic = 3, dc = 4, rp = 3, x = 1), min = 3, si = hors, sj = ro \ndepth = 1,  i = 4, j = 3, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hors, sj = ros \ndepth = 2,  i = 5, j = 1, (ic = 4, dc = 6, rp = 5, x = 1), min = 4, si = horse, sj = r \ndepth = 1,  i = 5, j = 2, (ic = 4, dc = 5, rp = 4, x = 1), min = 4, si = horse, sj = ro \ndepth = 0,  i = 5, j = 3, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = horse, sj = ros \n\n\n\n\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "you provided the solution , not the tip"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "<details>\n<summary>(Click) A hint which might be useful:</summary>\nTime & Space complexity is O(word1.len * word2.len).\n</details>"
                    }
                ]
            },
            {
                "id": 2071330,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "It may be called \\'medium\\', but it\\'s definitely at the top border between medium and hard."
                    },
                    {
                        "username": "wyldbill",
                        "content": "This is actually the [Levenshtein Distance](https://en.wikipedia.org/wiki/Levenshtein_distance)\nIt is one of several different \"[Edit Distance](https://en.wikipedia.org/wiki/Edit_distance)\" problems (Hamming, Jaro, LCS, etc.)\n"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Please help me why LCS is Not Working here \\n\\n![image.png](https://assets.leetcode.com/users/images/6caacef5-7d03-46d7-ba7e-38925334ca7e_1677376352.0691617.png)"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "W1 : HORSE\\nW2: ROS\\nUNION: ROS\\nM-C = 2\\nN-C = 0\\nANS = 2\\n\\nACTUAL RESULT = 3"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I think, because we have replacements"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Because order of characters is important here."
                    },
                    {
                        "username": "Sundow",
                        "content": "Many answers solve the problems but failed to explain why dynamic programming works  and why this problem has optimal structure. I have found a paper that contains a detail proof to the solution. Here is the link: http://www.inrg.csie.ntu.edu.tw/algorithm2013/homework/Wagner-74.pdf"
                    },
                    {
                        "username": "AyonAlfa",
                        "content": "hey are u alive??? then please reply :)"
                    },
                    {
                        "username": "p_next",
                        "content": "The min number of steps converting \"horse\" to \"ros\" I've found is 4:\\n\\n 1. horse -> orse (remove 'h')\\n  \\n 2. orse   -> ors   (remove 'e')\\n\\n 3. ors     -> oros (insert 'o')\\n\\n 4. oros   -> ros   (remove 'o')\\n\\nI can't figure out how to convert them in only 3 steps,pls help me,thx!"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "prompt_07",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "quattrozhou",
                        "content": "My code pass the online judge, but I found my code could not correctly solve this problem:\\n\"abcdxabcde\", \"abcdeabcdx\"\\ngreedy method will likely fail on this test case.\\nThanks! :)"
                    },
                    {
                        "username": "seventhrankpawn",
                        "content": "I ask this question at Microsoft for the AI teams.\\n\\nIt\\'s fundamental to many derivative algorithms for sequence pattern matching, processing, error correction, error rate estimation. \\n\\nHeck most recently I\\'ve seen it applied to the attention outputs of a transformer. \\n\\nIf you\\'re serious about AI, you should know this snazzy DP."
                    },
                    {
                        "username": "ankush920",
                        "content": "ye question karte hue us time ki yaad aa gyi jab me or mera dost apni crush  ka love percentage nikalte the : )"
                    },
                    {
                        "username": "sjames8888",
                        "content": "\nfor anyone wishing to get a good hint without looking at a solution - It may be best to  think of a top down solution where \n\n1. we define a recursive function taking pointers i, j which represent substring of words 1 and 2 - these will be initialised to lengths of two strings.\n\n2. we will probably need to add memoisation later for [i][]j] but not needed for small examples like horse, hor\n\n3. we compute 3 costs - ic, dc, rp for insert, delete, replace\n\n4. for insert we call recursive function where i is reduced by 1 implying we want best cost for smaller substrng on i and cost is plus 1\n\n5. for delete as above but j is reduced by 1\n\n6. for base case if we arrive  into function when i is 0 means cost to get to substring j from empty string i is j we need to add j chars \n\n7. base case arrive where j is 0 we need cost to reduce i to empty string which is i\n\n8. replace is call where both i and j reduce by 1 but we add x where x is 1 when charAt(i-1) != charAt(j-1) else for match x is 0 implying we replace at no cost and cost for larger string i is same as that for both reduced sub strings\n\n9.  we return min of 3 above costs\n\n10. for memoise hand in int[s1.length+1]s2.length+1] before calcs above we check if we have computed - this pivots into the better dp solution which will now be obvious \n\n    if (dp[i][j] != 0) {\n            return dp[i][j];\n        }\n\n return dp[i][j] = min;\n\n11. try it on this case as well but only with above optimisation - and no printing debug!\n\n  @Test\n    void case3() {\n        final var res = new EditDistance().minDistance(\"dinitrophenylhydrazine\", \"acetylphenylhydrazine\");\n        Assertions.assertEquals(6, res);\n    }\n\nand here is trace for above where we print all these values for horse -> ros\n\n\ndepth = 6,  i = 1, j = 1, (ic = 2, dc = 2, rp = 1, x = 1), min = 1, si = h, sj = r \ndepth = 5,  i = 1, j = 2, (ic = 3, dc = 2, rp = 2, x = 1), min = 2, si = h, sj = ro \ndepth = 4,  i = 1, j = 3, (ic = 4, dc = 3, rp = 3, x = 1), min = 3, si = h, sj = ros \ndepth = 5,  i = 2, j = 1, (ic = 2, dc = 3, rp = 2, x = 1), min = 2, si = ho, sj = r \ndepth = 4,  i = 2, j = 2, (ic = 3, dc = 3, rp = 1, x = 0), min = 1, si = ho, sj = ro \ndepth = 3,  i = 2, j = 3, (ic = 4, dc = 2, rp = 3, x = 1), min = 2, si = ho, sj = ros \ndepth = 4,  i = 3, j = 1, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hor, sj = r \ndepth = 3,  i = 3, j = 2, (ic = 2, dc = 3, rp = 3, x = 1), min = 2, si = hor, sj = ro \ndepth = 2,  i = 3, j = 3, (ic = 3, dc = 3, rp = 2, x = 1), min = 2, si = hor, sj = ros \ndepth = 3,  i = 4, j = 1, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = hors, sj = r \ndepth = 2,  i = 4, j = 2, (ic = 3, dc = 4, rp = 3, x = 1), min = 3, si = hors, sj = ro \ndepth = 1,  i = 4, j = 3, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hors, sj = ros \ndepth = 2,  i = 5, j = 1, (ic = 4, dc = 6, rp = 5, x = 1), min = 4, si = horse, sj = r \ndepth = 1,  i = 5, j = 2, (ic = 4, dc = 5, rp = 4, x = 1), min = 4, si = horse, sj = ro \ndepth = 0,  i = 5, j = 3, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = horse, sj = ros \n\n\n\n\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "you provided the solution , not the tip"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "<details>\n<summary>(Click) A hint which might be useful:</summary>\nTime & Space complexity is O(word1.len * word2.len).\n</details>"
                    }
                ]
            },
            {
                "id": 1986248,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "It may be called \\'medium\\', but it\\'s definitely at the top border between medium and hard."
                    },
                    {
                        "username": "wyldbill",
                        "content": "This is actually the [Levenshtein Distance](https://en.wikipedia.org/wiki/Levenshtein_distance)\nIt is one of several different \"[Edit Distance](https://en.wikipedia.org/wiki/Edit_distance)\" problems (Hamming, Jaro, LCS, etc.)\n"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Please help me why LCS is Not Working here \\n\\n![image.png](https://assets.leetcode.com/users/images/6caacef5-7d03-46d7-ba7e-38925334ca7e_1677376352.0691617.png)"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "W1 : HORSE\\nW2: ROS\\nUNION: ROS\\nM-C = 2\\nN-C = 0\\nANS = 2\\n\\nACTUAL RESULT = 3"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I think, because we have replacements"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Because order of characters is important here."
                    },
                    {
                        "username": "Sundow",
                        "content": "Many answers solve the problems but failed to explain why dynamic programming works  and why this problem has optimal structure. I have found a paper that contains a detail proof to the solution. Here is the link: http://www.inrg.csie.ntu.edu.tw/algorithm2013/homework/Wagner-74.pdf"
                    },
                    {
                        "username": "AyonAlfa",
                        "content": "hey are u alive??? then please reply :)"
                    },
                    {
                        "username": "p_next",
                        "content": "The min number of steps converting \"horse\" to \"ros\" I've found is 4:\\n\\n 1. horse -> orse (remove 'h')\\n  \\n 2. orse   -> ors   (remove 'e')\\n\\n 3. ors     -> oros (insert 'o')\\n\\n 4. oros   -> ros   (remove 'o')\\n\\nI can't figure out how to convert them in only 3 steps,pls help me,thx!"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "prompt_07",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "quattrozhou",
                        "content": "My code pass the online judge, but I found my code could not correctly solve this problem:\\n\"abcdxabcde\", \"abcdeabcdx\"\\ngreedy method will likely fail on this test case.\\nThanks! :)"
                    },
                    {
                        "username": "seventhrankpawn",
                        "content": "I ask this question at Microsoft for the AI teams.\\n\\nIt\\'s fundamental to many derivative algorithms for sequence pattern matching, processing, error correction, error rate estimation. \\n\\nHeck most recently I\\'ve seen it applied to the attention outputs of a transformer. \\n\\nIf you\\'re serious about AI, you should know this snazzy DP."
                    },
                    {
                        "username": "ankush920",
                        "content": "ye question karte hue us time ki yaad aa gyi jab me or mera dost apni crush  ka love percentage nikalte the : )"
                    },
                    {
                        "username": "sjames8888",
                        "content": "\nfor anyone wishing to get a good hint without looking at a solution - It may be best to  think of a top down solution where \n\n1. we define a recursive function taking pointers i, j which represent substring of words 1 and 2 - these will be initialised to lengths of two strings.\n\n2. we will probably need to add memoisation later for [i][]j] but not needed for small examples like horse, hor\n\n3. we compute 3 costs - ic, dc, rp for insert, delete, replace\n\n4. for insert we call recursive function where i is reduced by 1 implying we want best cost for smaller substrng on i and cost is plus 1\n\n5. for delete as above but j is reduced by 1\n\n6. for base case if we arrive  into function when i is 0 means cost to get to substring j from empty string i is j we need to add j chars \n\n7. base case arrive where j is 0 we need cost to reduce i to empty string which is i\n\n8. replace is call where both i and j reduce by 1 but we add x where x is 1 when charAt(i-1) != charAt(j-1) else for match x is 0 implying we replace at no cost and cost for larger string i is same as that for both reduced sub strings\n\n9.  we return min of 3 above costs\n\n10. for memoise hand in int[s1.length+1]s2.length+1] before calcs above we check if we have computed - this pivots into the better dp solution which will now be obvious \n\n    if (dp[i][j] != 0) {\n            return dp[i][j];\n        }\n\n return dp[i][j] = min;\n\n11. try it on this case as well but only with above optimisation - and no printing debug!\n\n  @Test\n    void case3() {\n        final var res = new EditDistance().minDistance(\"dinitrophenylhydrazine\", \"acetylphenylhydrazine\");\n        Assertions.assertEquals(6, res);\n    }\n\nand here is trace for above where we print all these values for horse -> ros\n\n\ndepth = 6,  i = 1, j = 1, (ic = 2, dc = 2, rp = 1, x = 1), min = 1, si = h, sj = r \ndepth = 5,  i = 1, j = 2, (ic = 3, dc = 2, rp = 2, x = 1), min = 2, si = h, sj = ro \ndepth = 4,  i = 1, j = 3, (ic = 4, dc = 3, rp = 3, x = 1), min = 3, si = h, sj = ros \ndepth = 5,  i = 2, j = 1, (ic = 2, dc = 3, rp = 2, x = 1), min = 2, si = ho, sj = r \ndepth = 4,  i = 2, j = 2, (ic = 3, dc = 3, rp = 1, x = 0), min = 1, si = ho, sj = ro \ndepth = 3,  i = 2, j = 3, (ic = 4, dc = 2, rp = 3, x = 1), min = 2, si = ho, sj = ros \ndepth = 4,  i = 3, j = 1, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hor, sj = r \ndepth = 3,  i = 3, j = 2, (ic = 2, dc = 3, rp = 3, x = 1), min = 2, si = hor, sj = ro \ndepth = 2,  i = 3, j = 3, (ic = 3, dc = 3, rp = 2, x = 1), min = 2, si = hor, sj = ros \ndepth = 3,  i = 4, j = 1, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = hors, sj = r \ndepth = 2,  i = 4, j = 2, (ic = 3, dc = 4, rp = 3, x = 1), min = 3, si = hors, sj = ro \ndepth = 1,  i = 4, j = 3, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hors, sj = ros \ndepth = 2,  i = 5, j = 1, (ic = 4, dc = 6, rp = 5, x = 1), min = 4, si = horse, sj = r \ndepth = 1,  i = 5, j = 2, (ic = 4, dc = 5, rp = 4, x = 1), min = 4, si = horse, sj = ro \ndepth = 0,  i = 5, j = 3, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = horse, sj = ros \n\n\n\n\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "you provided the solution , not the tip"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "<details>\n<summary>(Click) A hint which might be useful:</summary>\nTime & Space complexity is O(word1.len * word2.len).\n</details>"
                    }
                ]
            },
            {
                "id": 1933173,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "It may be called \\'medium\\', but it\\'s definitely at the top border between medium and hard."
                    },
                    {
                        "username": "wyldbill",
                        "content": "This is actually the [Levenshtein Distance](https://en.wikipedia.org/wiki/Levenshtein_distance)\nIt is one of several different \"[Edit Distance](https://en.wikipedia.org/wiki/Edit_distance)\" problems (Hamming, Jaro, LCS, etc.)\n"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Please help me why LCS is Not Working here \\n\\n![image.png](https://assets.leetcode.com/users/images/6caacef5-7d03-46d7-ba7e-38925334ca7e_1677376352.0691617.png)"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "W1 : HORSE\\nW2: ROS\\nUNION: ROS\\nM-C = 2\\nN-C = 0\\nANS = 2\\n\\nACTUAL RESULT = 3"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I think, because we have replacements"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Because order of characters is important here."
                    },
                    {
                        "username": "Sundow",
                        "content": "Many answers solve the problems but failed to explain why dynamic programming works  and why this problem has optimal structure. I have found a paper that contains a detail proof to the solution. Here is the link: http://www.inrg.csie.ntu.edu.tw/algorithm2013/homework/Wagner-74.pdf"
                    },
                    {
                        "username": "AyonAlfa",
                        "content": "hey are u alive??? then please reply :)"
                    },
                    {
                        "username": "p_next",
                        "content": "The min number of steps converting \"horse\" to \"ros\" I've found is 4:\\n\\n 1. horse -> orse (remove 'h')\\n  \\n 2. orse   -> ors   (remove 'e')\\n\\n 3. ors     -> oros (insert 'o')\\n\\n 4. oros   -> ros   (remove 'o')\\n\\nI can't figure out how to convert them in only 3 steps,pls help me,thx!"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "prompt_07",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "quattrozhou",
                        "content": "My code pass the online judge, but I found my code could not correctly solve this problem:\\n\"abcdxabcde\", \"abcdeabcdx\"\\ngreedy method will likely fail on this test case.\\nThanks! :)"
                    },
                    {
                        "username": "seventhrankpawn",
                        "content": "I ask this question at Microsoft for the AI teams.\\n\\nIt\\'s fundamental to many derivative algorithms for sequence pattern matching, processing, error correction, error rate estimation. \\n\\nHeck most recently I\\'ve seen it applied to the attention outputs of a transformer. \\n\\nIf you\\'re serious about AI, you should know this snazzy DP."
                    },
                    {
                        "username": "ankush920",
                        "content": "ye question karte hue us time ki yaad aa gyi jab me or mera dost apni crush  ka love percentage nikalte the : )"
                    },
                    {
                        "username": "sjames8888",
                        "content": "\nfor anyone wishing to get a good hint without looking at a solution - It may be best to  think of a top down solution where \n\n1. we define a recursive function taking pointers i, j which represent substring of words 1 and 2 - these will be initialised to lengths of two strings.\n\n2. we will probably need to add memoisation later for [i][]j] but not needed for small examples like horse, hor\n\n3. we compute 3 costs - ic, dc, rp for insert, delete, replace\n\n4. for insert we call recursive function where i is reduced by 1 implying we want best cost for smaller substrng on i and cost is plus 1\n\n5. for delete as above but j is reduced by 1\n\n6. for base case if we arrive  into function when i is 0 means cost to get to substring j from empty string i is j we need to add j chars \n\n7. base case arrive where j is 0 we need cost to reduce i to empty string which is i\n\n8. replace is call where both i and j reduce by 1 but we add x where x is 1 when charAt(i-1) != charAt(j-1) else for match x is 0 implying we replace at no cost and cost for larger string i is same as that for both reduced sub strings\n\n9.  we return min of 3 above costs\n\n10. for memoise hand in int[s1.length+1]s2.length+1] before calcs above we check if we have computed - this pivots into the better dp solution which will now be obvious \n\n    if (dp[i][j] != 0) {\n            return dp[i][j];\n        }\n\n return dp[i][j] = min;\n\n11. try it on this case as well but only with above optimisation - and no printing debug!\n\n  @Test\n    void case3() {\n        final var res = new EditDistance().minDistance(\"dinitrophenylhydrazine\", \"acetylphenylhydrazine\");\n        Assertions.assertEquals(6, res);\n    }\n\nand here is trace for above where we print all these values for horse -> ros\n\n\ndepth = 6,  i = 1, j = 1, (ic = 2, dc = 2, rp = 1, x = 1), min = 1, si = h, sj = r \ndepth = 5,  i = 1, j = 2, (ic = 3, dc = 2, rp = 2, x = 1), min = 2, si = h, sj = ro \ndepth = 4,  i = 1, j = 3, (ic = 4, dc = 3, rp = 3, x = 1), min = 3, si = h, sj = ros \ndepth = 5,  i = 2, j = 1, (ic = 2, dc = 3, rp = 2, x = 1), min = 2, si = ho, sj = r \ndepth = 4,  i = 2, j = 2, (ic = 3, dc = 3, rp = 1, x = 0), min = 1, si = ho, sj = ro \ndepth = 3,  i = 2, j = 3, (ic = 4, dc = 2, rp = 3, x = 1), min = 2, si = ho, sj = ros \ndepth = 4,  i = 3, j = 1, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hor, sj = r \ndepth = 3,  i = 3, j = 2, (ic = 2, dc = 3, rp = 3, x = 1), min = 2, si = hor, sj = ro \ndepth = 2,  i = 3, j = 3, (ic = 3, dc = 3, rp = 2, x = 1), min = 2, si = hor, sj = ros \ndepth = 3,  i = 4, j = 1, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = hors, sj = r \ndepth = 2,  i = 4, j = 2, (ic = 3, dc = 4, rp = 3, x = 1), min = 3, si = hors, sj = ro \ndepth = 1,  i = 4, j = 3, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hors, sj = ros \ndepth = 2,  i = 5, j = 1, (ic = 4, dc = 6, rp = 5, x = 1), min = 4, si = horse, sj = r \ndepth = 1,  i = 5, j = 2, (ic = 4, dc = 5, rp = 4, x = 1), min = 4, si = horse, sj = ro \ndepth = 0,  i = 5, j = 3, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = horse, sj = ros \n\n\n\n\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "you provided the solution , not the tip"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "<details>\n<summary>(Click) A hint which might be useful:</summary>\nTime & Space complexity is O(word1.len * word2.len).\n</details>"
                    }
                ]
            },
            {
                "id": 1815135,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "It may be called \\'medium\\', but it\\'s definitely at the top border between medium and hard."
                    },
                    {
                        "username": "wyldbill",
                        "content": "This is actually the [Levenshtein Distance](https://en.wikipedia.org/wiki/Levenshtein_distance)\nIt is one of several different \"[Edit Distance](https://en.wikipedia.org/wiki/Edit_distance)\" problems (Hamming, Jaro, LCS, etc.)\n"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Please help me why LCS is Not Working here \\n\\n![image.png](https://assets.leetcode.com/users/images/6caacef5-7d03-46d7-ba7e-38925334ca7e_1677376352.0691617.png)"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "W1 : HORSE\\nW2: ROS\\nUNION: ROS\\nM-C = 2\\nN-C = 0\\nANS = 2\\n\\nACTUAL RESULT = 3"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I think, because we have replacements"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Because order of characters is important here."
                    },
                    {
                        "username": "Sundow",
                        "content": "Many answers solve the problems but failed to explain why dynamic programming works  and why this problem has optimal structure. I have found a paper that contains a detail proof to the solution. Here is the link: http://www.inrg.csie.ntu.edu.tw/algorithm2013/homework/Wagner-74.pdf"
                    },
                    {
                        "username": "AyonAlfa",
                        "content": "hey are u alive??? then please reply :)"
                    },
                    {
                        "username": "p_next",
                        "content": "The min number of steps converting \"horse\" to \"ros\" I've found is 4:\\n\\n 1. horse -> orse (remove 'h')\\n  \\n 2. orse   -> ors   (remove 'e')\\n\\n 3. ors     -> oros (insert 'o')\\n\\n 4. oros   -> ros   (remove 'o')\\n\\nI can't figure out how to convert them in only 3 steps,pls help me,thx!"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "prompt_07",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "quattrozhou",
                        "content": "My code pass the online judge, but I found my code could not correctly solve this problem:\\n\"abcdxabcde\", \"abcdeabcdx\"\\ngreedy method will likely fail on this test case.\\nThanks! :)"
                    },
                    {
                        "username": "seventhrankpawn",
                        "content": "I ask this question at Microsoft for the AI teams.\\n\\nIt\\'s fundamental to many derivative algorithms for sequence pattern matching, processing, error correction, error rate estimation. \\n\\nHeck most recently I\\'ve seen it applied to the attention outputs of a transformer. \\n\\nIf you\\'re serious about AI, you should know this snazzy DP."
                    },
                    {
                        "username": "ankush920",
                        "content": "ye question karte hue us time ki yaad aa gyi jab me or mera dost apni crush  ka love percentage nikalte the : )"
                    },
                    {
                        "username": "sjames8888",
                        "content": "\nfor anyone wishing to get a good hint without looking at a solution - It may be best to  think of a top down solution where \n\n1. we define a recursive function taking pointers i, j which represent substring of words 1 and 2 - these will be initialised to lengths of two strings.\n\n2. we will probably need to add memoisation later for [i][]j] but not needed for small examples like horse, hor\n\n3. we compute 3 costs - ic, dc, rp for insert, delete, replace\n\n4. for insert we call recursive function where i is reduced by 1 implying we want best cost for smaller substrng on i and cost is plus 1\n\n5. for delete as above but j is reduced by 1\n\n6. for base case if we arrive  into function when i is 0 means cost to get to substring j from empty string i is j we need to add j chars \n\n7. base case arrive where j is 0 we need cost to reduce i to empty string which is i\n\n8. replace is call where both i and j reduce by 1 but we add x where x is 1 when charAt(i-1) != charAt(j-1) else for match x is 0 implying we replace at no cost and cost for larger string i is same as that for both reduced sub strings\n\n9.  we return min of 3 above costs\n\n10. for memoise hand in int[s1.length+1]s2.length+1] before calcs above we check if we have computed - this pivots into the better dp solution which will now be obvious \n\n    if (dp[i][j] != 0) {\n            return dp[i][j];\n        }\n\n return dp[i][j] = min;\n\n11. try it on this case as well but only with above optimisation - and no printing debug!\n\n  @Test\n    void case3() {\n        final var res = new EditDistance().minDistance(\"dinitrophenylhydrazine\", \"acetylphenylhydrazine\");\n        Assertions.assertEquals(6, res);\n    }\n\nand here is trace for above where we print all these values for horse -> ros\n\n\ndepth = 6,  i = 1, j = 1, (ic = 2, dc = 2, rp = 1, x = 1), min = 1, si = h, sj = r \ndepth = 5,  i = 1, j = 2, (ic = 3, dc = 2, rp = 2, x = 1), min = 2, si = h, sj = ro \ndepth = 4,  i = 1, j = 3, (ic = 4, dc = 3, rp = 3, x = 1), min = 3, si = h, sj = ros \ndepth = 5,  i = 2, j = 1, (ic = 2, dc = 3, rp = 2, x = 1), min = 2, si = ho, sj = r \ndepth = 4,  i = 2, j = 2, (ic = 3, dc = 3, rp = 1, x = 0), min = 1, si = ho, sj = ro \ndepth = 3,  i = 2, j = 3, (ic = 4, dc = 2, rp = 3, x = 1), min = 2, si = ho, sj = ros \ndepth = 4,  i = 3, j = 1, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hor, sj = r \ndepth = 3,  i = 3, j = 2, (ic = 2, dc = 3, rp = 3, x = 1), min = 2, si = hor, sj = ro \ndepth = 2,  i = 3, j = 3, (ic = 3, dc = 3, rp = 2, x = 1), min = 2, si = hor, sj = ros \ndepth = 3,  i = 4, j = 1, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = hors, sj = r \ndepth = 2,  i = 4, j = 2, (ic = 3, dc = 4, rp = 3, x = 1), min = 3, si = hors, sj = ro \ndepth = 1,  i = 4, j = 3, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hors, sj = ros \ndepth = 2,  i = 5, j = 1, (ic = 4, dc = 6, rp = 5, x = 1), min = 4, si = horse, sj = r \ndepth = 1,  i = 5, j = 2, (ic = 4, dc = 5, rp = 4, x = 1), min = 4, si = horse, sj = ro \ndepth = 0,  i = 5, j = 3, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = horse, sj = ros \n\n\n\n\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "you provided the solution , not the tip"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "<details>\n<summary>(Click) A hint which might be useful:</summary>\nTime & Space complexity is O(word1.len * word2.len).\n</details>"
                    }
                ]
            },
            {
                "id": 1814571,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "It was a good run..."
                    },
                    {
                        "username": "pandey_nikhil",
                        "content": "what is the name \"EDIT DISTANCE \" suggest with respect to this question , I mean why the question name is EDIT DISTANCE ? I\\'m curious \\uD83E\\uDD14about it."
                    },
                    {
                        "username": "preetisushma",
                        "content": "https://codemummy.blogspot.com/2020/08/edit-distance-dynamic-programming.html\\n\\nvery easy"
                    },
                    {
                        "username": "greensabath",
                        "content": "This link doesn\\'t explain anything that the code is doing. It also does not use the minDistance function with 2 parms. It uses 2 additional parms which it does not explain what they are."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "eric0831",
                        "content": "By now I believe most of you understand dp[i - 1][j - 1] for `replace`, but how about `insert` and `delete`?\\n\\nFor instance, if we want to match `abbc` to `acc`, we need to take a look of the sub problem, what is the minimum steps we need to make `abb` to match `ac`.\\nHere we have our first case when 2 charactre are the same, we move both pointer to the left  `if(s1.charAt(j - 1) == s2.charAt(j - 1) ` -> `f[i][j] = f[i - 1][j - 1]`\\nWe continue our discussion here, now our goal is to make `abb` to match `ac`, three things we can do here, which is  `replace` , `insert`, and `delete`,\\nFor  `replace`, we replace the last character `b` to `c` and we will have `abc` to match `ac`, and our sub problem will be the min steps to match `ab` to `a`, which gives us `f[i][j] = f[i - 1][j - 1]`\\nFor `delete`, which means we delete the last character, now we need to match `ab` to `ac` which gives us `f[i][j] = f[i - 1][j - 1]`\\n\\nThe hardest part for this problem is to understand insert, so for our `abb` to match `ac` , we can add a `c` to our first string, and we will have `abbc` to match `ac`, now our sub problem become to mach `abb` to `a`, at this point we need to move our second string to the left, which gives us `f[i][j] = f[i][j - 1]`\\n\\nI\\'m sure from here you are smart enough to firgure out the rest."
                    },
                    {
                        "username": "mrigankkhandelwal300",
                        "content": "Hey all,\\n\\nI solved this problem using DP with TC O(mn). However it beats only 12~15% solutions. How do I improve time complexity beyond my algorithm i.e. what tricks can I use to give my code an edge with respect to time complexity."
                    },
                    {
                        "username": "zenfred",
                        "content": "1. Try waiting a while and resubmitting. LC servers are not stable in terms of runtime.\\n2. If your solution still runs slow, post the code so that we can diagnose it for you."
                    },
                    {
                        "username": "abhipatwari",
                        "content": "what\\'s different with use case \"distance\" and \"springbok\"?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "WTF !!! I some how solved this shit !!"
                    },
                    {
                        "username": "lipsapatel25",
                        "content": "This video explains the problem very well\\nhttps://youtu.be/CELw4LKLSeE"
                    },
                    {
                        "username": "bogdanctx",
                        "content": "This is easily done if Levenshtein distance algorithm is applied."
                    },
                    {
                        "username": "sad_python",
                        "content": "THIS IS HARD!!\\n"
                    }
                ]
            },
            {
                "id": 1798109,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "It was a good run..."
                    },
                    {
                        "username": "pandey_nikhil",
                        "content": "what is the name \"EDIT DISTANCE \" suggest with respect to this question , I mean why the question name is EDIT DISTANCE ? I\\'m curious \\uD83E\\uDD14about it."
                    },
                    {
                        "username": "preetisushma",
                        "content": "https://codemummy.blogspot.com/2020/08/edit-distance-dynamic-programming.html\\n\\nvery easy"
                    },
                    {
                        "username": "greensabath",
                        "content": "This link doesn\\'t explain anything that the code is doing. It also does not use the minDistance function with 2 parms. It uses 2 additional parms which it does not explain what they are."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "eric0831",
                        "content": "By now I believe most of you understand dp[i - 1][j - 1] for `replace`, but how about `insert` and `delete`?\\n\\nFor instance, if we want to match `abbc` to `acc`, we need to take a look of the sub problem, what is the minimum steps we need to make `abb` to match `ac`.\\nHere we have our first case when 2 charactre are the same, we move both pointer to the left  `if(s1.charAt(j - 1) == s2.charAt(j - 1) ` -> `f[i][j] = f[i - 1][j - 1]`\\nWe continue our discussion here, now our goal is to make `abb` to match `ac`, three things we can do here, which is  `replace` , `insert`, and `delete`,\\nFor  `replace`, we replace the last character `b` to `c` and we will have `abc` to match `ac`, and our sub problem will be the min steps to match `ab` to `a`, which gives us `f[i][j] = f[i - 1][j - 1]`\\nFor `delete`, which means we delete the last character, now we need to match `ab` to `ac` which gives us `f[i][j] = f[i - 1][j - 1]`\\n\\nThe hardest part for this problem is to understand insert, so for our `abb` to match `ac` , we can add a `c` to our first string, and we will have `abbc` to match `ac`, now our sub problem become to mach `abb` to `a`, at this point we need to move our second string to the left, which gives us `f[i][j] = f[i][j - 1]`\\n\\nI\\'m sure from here you are smart enough to firgure out the rest."
                    },
                    {
                        "username": "mrigankkhandelwal300",
                        "content": "Hey all,\\n\\nI solved this problem using DP with TC O(mn). However it beats only 12~15% solutions. How do I improve time complexity beyond my algorithm i.e. what tricks can I use to give my code an edge with respect to time complexity."
                    },
                    {
                        "username": "zenfred",
                        "content": "1. Try waiting a while and resubmitting. LC servers are not stable in terms of runtime.\\n2. If your solution still runs slow, post the code so that we can diagnose it for you."
                    },
                    {
                        "username": "abhipatwari",
                        "content": "what\\'s different with use case \"distance\" and \"springbok\"?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "WTF !!! I some how solved this shit !!"
                    },
                    {
                        "username": "lipsapatel25",
                        "content": "This video explains the problem very well\\nhttps://youtu.be/CELw4LKLSeE"
                    },
                    {
                        "username": "bogdanctx",
                        "content": "This is easily done if Levenshtein distance algorithm is applied."
                    },
                    {
                        "username": "sad_python",
                        "content": "THIS IS HARD!!\\n"
                    }
                ]
            },
            {
                "id": 1574248,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "It was a good run..."
                    },
                    {
                        "username": "pandey_nikhil",
                        "content": "what is the name \"EDIT DISTANCE \" suggest with respect to this question , I mean why the question name is EDIT DISTANCE ? I\\'m curious \\uD83E\\uDD14about it."
                    },
                    {
                        "username": "preetisushma",
                        "content": "https://codemummy.blogspot.com/2020/08/edit-distance-dynamic-programming.html\\n\\nvery easy"
                    },
                    {
                        "username": "greensabath",
                        "content": "This link doesn\\'t explain anything that the code is doing. It also does not use the minDistance function with 2 parms. It uses 2 additional parms which it does not explain what they are."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "eric0831",
                        "content": "By now I believe most of you understand dp[i - 1][j - 1] for `replace`, but how about `insert` and `delete`?\\n\\nFor instance, if we want to match `abbc` to `acc`, we need to take a look of the sub problem, what is the minimum steps we need to make `abb` to match `ac`.\\nHere we have our first case when 2 charactre are the same, we move both pointer to the left  `if(s1.charAt(j - 1) == s2.charAt(j - 1) ` -> `f[i][j] = f[i - 1][j - 1]`\\nWe continue our discussion here, now our goal is to make `abb` to match `ac`, three things we can do here, which is  `replace` , `insert`, and `delete`,\\nFor  `replace`, we replace the last character `b` to `c` and we will have `abc` to match `ac`, and our sub problem will be the min steps to match `ab` to `a`, which gives us `f[i][j] = f[i - 1][j - 1]`\\nFor `delete`, which means we delete the last character, now we need to match `ab` to `ac` which gives us `f[i][j] = f[i - 1][j - 1]`\\n\\nThe hardest part for this problem is to understand insert, so for our `abb` to match `ac` , we can add a `c` to our first string, and we will have `abbc` to match `ac`, now our sub problem become to mach `abb` to `a`, at this point we need to move our second string to the left, which gives us `f[i][j] = f[i][j - 1]`\\n\\nI\\'m sure from here you are smart enough to firgure out the rest."
                    },
                    {
                        "username": "mrigankkhandelwal300",
                        "content": "Hey all,\\n\\nI solved this problem using DP with TC O(mn). However it beats only 12~15% solutions. How do I improve time complexity beyond my algorithm i.e. what tricks can I use to give my code an edge with respect to time complexity."
                    },
                    {
                        "username": "zenfred",
                        "content": "1. Try waiting a while and resubmitting. LC servers are not stable in terms of runtime.\\n2. If your solution still runs slow, post the code so that we can diagnose it for you."
                    },
                    {
                        "username": "abhipatwari",
                        "content": "what\\'s different with use case \"distance\" and \"springbok\"?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "WTF !!! I some how solved this shit !!"
                    },
                    {
                        "username": "lipsapatel25",
                        "content": "This video explains the problem very well\\nhttps://youtu.be/CELw4LKLSeE"
                    },
                    {
                        "username": "bogdanctx",
                        "content": "This is easily done if Levenshtein distance algorithm is applied."
                    },
                    {
                        "username": "sad_python",
                        "content": "THIS IS HARD!!\\n"
                    }
                ]
            },
            {
                "id": 1573850,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "It was a good run..."
                    },
                    {
                        "username": "pandey_nikhil",
                        "content": "what is the name \"EDIT DISTANCE \" suggest with respect to this question , I mean why the question name is EDIT DISTANCE ? I\\'m curious \\uD83E\\uDD14about it."
                    },
                    {
                        "username": "preetisushma",
                        "content": "https://codemummy.blogspot.com/2020/08/edit-distance-dynamic-programming.html\\n\\nvery easy"
                    },
                    {
                        "username": "greensabath",
                        "content": "This link doesn\\'t explain anything that the code is doing. It also does not use the minDistance function with 2 parms. It uses 2 additional parms which it does not explain what they are."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "eric0831",
                        "content": "By now I believe most of you understand dp[i - 1][j - 1] for `replace`, but how about `insert` and `delete`?\\n\\nFor instance, if we want to match `abbc` to `acc`, we need to take a look of the sub problem, what is the minimum steps we need to make `abb` to match `ac`.\\nHere we have our first case when 2 charactre are the same, we move both pointer to the left  `if(s1.charAt(j - 1) == s2.charAt(j - 1) ` -> `f[i][j] = f[i - 1][j - 1]`\\nWe continue our discussion here, now our goal is to make `abb` to match `ac`, three things we can do here, which is  `replace` , `insert`, and `delete`,\\nFor  `replace`, we replace the last character `b` to `c` and we will have `abc` to match `ac`, and our sub problem will be the min steps to match `ab` to `a`, which gives us `f[i][j] = f[i - 1][j - 1]`\\nFor `delete`, which means we delete the last character, now we need to match `ab` to `ac` which gives us `f[i][j] = f[i - 1][j - 1]`\\n\\nThe hardest part for this problem is to understand insert, so for our `abb` to match `ac` , we can add a `c` to our first string, and we will have `abbc` to match `ac`, now our sub problem become to mach `abb` to `a`, at this point we need to move our second string to the left, which gives us `f[i][j] = f[i][j - 1]`\\n\\nI\\'m sure from here you are smart enough to firgure out the rest."
                    },
                    {
                        "username": "mrigankkhandelwal300",
                        "content": "Hey all,\\n\\nI solved this problem using DP with TC O(mn). However it beats only 12~15% solutions. How do I improve time complexity beyond my algorithm i.e. what tricks can I use to give my code an edge with respect to time complexity."
                    },
                    {
                        "username": "zenfred",
                        "content": "1. Try waiting a while and resubmitting. LC servers are not stable in terms of runtime.\\n2. If your solution still runs slow, post the code so that we can diagnose it for you."
                    },
                    {
                        "username": "abhipatwari",
                        "content": "what\\'s different with use case \"distance\" and \"springbok\"?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "WTF !!! I some how solved this shit !!"
                    },
                    {
                        "username": "lipsapatel25",
                        "content": "This video explains the problem very well\\nhttps://youtu.be/CELw4LKLSeE"
                    },
                    {
                        "username": "bogdanctx",
                        "content": "This is easily done if Levenshtein distance algorithm is applied."
                    },
                    {
                        "username": "sad_python",
                        "content": "THIS IS HARD!!\\n"
                    }
                ]
            },
            {
                "id": 2068551,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "It was a good run..."
                    },
                    {
                        "username": "pandey_nikhil",
                        "content": "what is the name \"EDIT DISTANCE \" suggest with respect to this question , I mean why the question name is EDIT DISTANCE ? I\\'m curious \\uD83E\\uDD14about it."
                    },
                    {
                        "username": "preetisushma",
                        "content": "https://codemummy.blogspot.com/2020/08/edit-distance-dynamic-programming.html\\n\\nvery easy"
                    },
                    {
                        "username": "greensabath",
                        "content": "This link doesn\\'t explain anything that the code is doing. It also does not use the minDistance function with 2 parms. It uses 2 additional parms which it does not explain what they are."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "eric0831",
                        "content": "By now I believe most of you understand dp[i - 1][j - 1] for `replace`, but how about `insert` and `delete`?\\n\\nFor instance, if we want to match `abbc` to `acc`, we need to take a look of the sub problem, what is the minimum steps we need to make `abb` to match `ac`.\\nHere we have our first case when 2 charactre are the same, we move both pointer to the left  `if(s1.charAt(j - 1) == s2.charAt(j - 1) ` -> `f[i][j] = f[i - 1][j - 1]`\\nWe continue our discussion here, now our goal is to make `abb` to match `ac`, three things we can do here, which is  `replace` , `insert`, and `delete`,\\nFor  `replace`, we replace the last character `b` to `c` and we will have `abc` to match `ac`, and our sub problem will be the min steps to match `ab` to `a`, which gives us `f[i][j] = f[i - 1][j - 1]`\\nFor `delete`, which means we delete the last character, now we need to match `ab` to `ac` which gives us `f[i][j] = f[i - 1][j - 1]`\\n\\nThe hardest part for this problem is to understand insert, so for our `abb` to match `ac` , we can add a `c` to our first string, and we will have `abbc` to match `ac`, now our sub problem become to mach `abb` to `a`, at this point we need to move our second string to the left, which gives us `f[i][j] = f[i][j - 1]`\\n\\nI\\'m sure from here you are smart enough to firgure out the rest."
                    },
                    {
                        "username": "mrigankkhandelwal300",
                        "content": "Hey all,\\n\\nI solved this problem using DP with TC O(mn). However it beats only 12~15% solutions. How do I improve time complexity beyond my algorithm i.e. what tricks can I use to give my code an edge with respect to time complexity."
                    },
                    {
                        "username": "zenfred",
                        "content": "1. Try waiting a while and resubmitting. LC servers are not stable in terms of runtime.\\n2. If your solution still runs slow, post the code so that we can diagnose it for you."
                    },
                    {
                        "username": "abhipatwari",
                        "content": "what\\'s different with use case \"distance\" and \"springbok\"?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "WTF !!! I some how solved this shit !!"
                    },
                    {
                        "username": "lipsapatel25",
                        "content": "This video explains the problem very well\\nhttps://youtu.be/CELw4LKLSeE"
                    },
                    {
                        "username": "bogdanctx",
                        "content": "This is easily done if Levenshtein distance algorithm is applied."
                    },
                    {
                        "username": "sad_python",
                        "content": "THIS IS HARD!!\\n"
                    }
                ]
            },
            {
                "id": 2053497,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "It was a good run..."
                    },
                    {
                        "username": "pandey_nikhil",
                        "content": "what is the name \"EDIT DISTANCE \" suggest with respect to this question , I mean why the question name is EDIT DISTANCE ? I\\'m curious \\uD83E\\uDD14about it."
                    },
                    {
                        "username": "preetisushma",
                        "content": "https://codemummy.blogspot.com/2020/08/edit-distance-dynamic-programming.html\\n\\nvery easy"
                    },
                    {
                        "username": "greensabath",
                        "content": "This link doesn\\'t explain anything that the code is doing. It also does not use the minDistance function with 2 parms. It uses 2 additional parms which it does not explain what they are."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "eric0831",
                        "content": "By now I believe most of you understand dp[i - 1][j - 1] for `replace`, but how about `insert` and `delete`?\\n\\nFor instance, if we want to match `abbc` to `acc`, we need to take a look of the sub problem, what is the minimum steps we need to make `abb` to match `ac`.\\nHere we have our first case when 2 charactre are the same, we move both pointer to the left  `if(s1.charAt(j - 1) == s2.charAt(j - 1) ` -> `f[i][j] = f[i - 1][j - 1]`\\nWe continue our discussion here, now our goal is to make `abb` to match `ac`, three things we can do here, which is  `replace` , `insert`, and `delete`,\\nFor  `replace`, we replace the last character `b` to `c` and we will have `abc` to match `ac`, and our sub problem will be the min steps to match `ab` to `a`, which gives us `f[i][j] = f[i - 1][j - 1]`\\nFor `delete`, which means we delete the last character, now we need to match `ab` to `ac` which gives us `f[i][j] = f[i - 1][j - 1]`\\n\\nThe hardest part for this problem is to understand insert, so for our `abb` to match `ac` , we can add a `c` to our first string, and we will have `abbc` to match `ac`, now our sub problem become to mach `abb` to `a`, at this point we need to move our second string to the left, which gives us `f[i][j] = f[i][j - 1]`\\n\\nI\\'m sure from here you are smart enough to firgure out the rest."
                    },
                    {
                        "username": "mrigankkhandelwal300",
                        "content": "Hey all,\\n\\nI solved this problem using DP with TC O(mn). However it beats only 12~15% solutions. How do I improve time complexity beyond my algorithm i.e. what tricks can I use to give my code an edge with respect to time complexity."
                    },
                    {
                        "username": "zenfred",
                        "content": "1. Try waiting a while and resubmitting. LC servers are not stable in terms of runtime.\\n2. If your solution still runs slow, post the code so that we can diagnose it for you."
                    },
                    {
                        "username": "abhipatwari",
                        "content": "what\\'s different with use case \"distance\" and \"springbok\"?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "WTF !!! I some how solved this shit !!"
                    },
                    {
                        "username": "lipsapatel25",
                        "content": "This video explains the problem very well\\nhttps://youtu.be/CELw4LKLSeE"
                    },
                    {
                        "username": "bogdanctx",
                        "content": "This is easily done if Levenshtein distance algorithm is applied."
                    },
                    {
                        "username": "sad_python",
                        "content": "THIS IS HARD!!\\n"
                    }
                ]
            },
            {
                "id": 2052528,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "It was a good run..."
                    },
                    {
                        "username": "pandey_nikhil",
                        "content": "what is the name \"EDIT DISTANCE \" suggest with respect to this question , I mean why the question name is EDIT DISTANCE ? I\\'m curious \\uD83E\\uDD14about it."
                    },
                    {
                        "username": "preetisushma",
                        "content": "https://codemummy.blogspot.com/2020/08/edit-distance-dynamic-programming.html\\n\\nvery easy"
                    },
                    {
                        "username": "greensabath",
                        "content": "This link doesn\\'t explain anything that the code is doing. It also does not use the minDistance function with 2 parms. It uses 2 additional parms which it does not explain what they are."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "eric0831",
                        "content": "By now I believe most of you understand dp[i - 1][j - 1] for `replace`, but how about `insert` and `delete`?\\n\\nFor instance, if we want to match `abbc` to `acc`, we need to take a look of the sub problem, what is the minimum steps we need to make `abb` to match `ac`.\\nHere we have our first case when 2 charactre are the same, we move both pointer to the left  `if(s1.charAt(j - 1) == s2.charAt(j - 1) ` -> `f[i][j] = f[i - 1][j - 1]`\\nWe continue our discussion here, now our goal is to make `abb` to match `ac`, three things we can do here, which is  `replace` , `insert`, and `delete`,\\nFor  `replace`, we replace the last character `b` to `c` and we will have `abc` to match `ac`, and our sub problem will be the min steps to match `ab` to `a`, which gives us `f[i][j] = f[i - 1][j - 1]`\\nFor `delete`, which means we delete the last character, now we need to match `ab` to `ac` which gives us `f[i][j] = f[i - 1][j - 1]`\\n\\nThe hardest part for this problem is to understand insert, so for our `abb` to match `ac` , we can add a `c` to our first string, and we will have `abbc` to match `ac`, now our sub problem become to mach `abb` to `a`, at this point we need to move our second string to the left, which gives us `f[i][j] = f[i][j - 1]`\\n\\nI\\'m sure from here you are smart enough to firgure out the rest."
                    },
                    {
                        "username": "mrigankkhandelwal300",
                        "content": "Hey all,\\n\\nI solved this problem using DP with TC O(mn). However it beats only 12~15% solutions. How do I improve time complexity beyond my algorithm i.e. what tricks can I use to give my code an edge with respect to time complexity."
                    },
                    {
                        "username": "zenfred",
                        "content": "1. Try waiting a while and resubmitting. LC servers are not stable in terms of runtime.\\n2. If your solution still runs slow, post the code so that we can diagnose it for you."
                    },
                    {
                        "username": "abhipatwari",
                        "content": "what\\'s different with use case \"distance\" and \"springbok\"?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "WTF !!! I some how solved this shit !!"
                    },
                    {
                        "username": "lipsapatel25",
                        "content": "This video explains the problem very well\\nhttps://youtu.be/CELw4LKLSeE"
                    },
                    {
                        "username": "bogdanctx",
                        "content": "This is easily done if Levenshtein distance algorithm is applied."
                    },
                    {
                        "username": "sad_python",
                        "content": "THIS IS HARD!!\\n"
                    }
                ]
            },
            {
                "id": 2046986,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "It was a good run..."
                    },
                    {
                        "username": "pandey_nikhil",
                        "content": "what is the name \"EDIT DISTANCE \" suggest with respect to this question , I mean why the question name is EDIT DISTANCE ? I\\'m curious \\uD83E\\uDD14about it."
                    },
                    {
                        "username": "preetisushma",
                        "content": "https://codemummy.blogspot.com/2020/08/edit-distance-dynamic-programming.html\\n\\nvery easy"
                    },
                    {
                        "username": "greensabath",
                        "content": "This link doesn\\'t explain anything that the code is doing. It also does not use the minDistance function with 2 parms. It uses 2 additional parms which it does not explain what they are."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "eric0831",
                        "content": "By now I believe most of you understand dp[i - 1][j - 1] for `replace`, but how about `insert` and `delete`?\\n\\nFor instance, if we want to match `abbc` to `acc`, we need to take a look of the sub problem, what is the minimum steps we need to make `abb` to match `ac`.\\nHere we have our first case when 2 charactre are the same, we move both pointer to the left  `if(s1.charAt(j - 1) == s2.charAt(j - 1) ` -> `f[i][j] = f[i - 1][j - 1]`\\nWe continue our discussion here, now our goal is to make `abb` to match `ac`, three things we can do here, which is  `replace` , `insert`, and `delete`,\\nFor  `replace`, we replace the last character `b` to `c` and we will have `abc` to match `ac`, and our sub problem will be the min steps to match `ab` to `a`, which gives us `f[i][j] = f[i - 1][j - 1]`\\nFor `delete`, which means we delete the last character, now we need to match `ab` to `ac` which gives us `f[i][j] = f[i - 1][j - 1]`\\n\\nThe hardest part for this problem is to understand insert, so for our `abb` to match `ac` , we can add a `c` to our first string, and we will have `abbc` to match `ac`, now our sub problem become to mach `abb` to `a`, at this point we need to move our second string to the left, which gives us `f[i][j] = f[i][j - 1]`\\n\\nI\\'m sure from here you are smart enough to firgure out the rest."
                    },
                    {
                        "username": "mrigankkhandelwal300",
                        "content": "Hey all,\\n\\nI solved this problem using DP with TC O(mn). However it beats only 12~15% solutions. How do I improve time complexity beyond my algorithm i.e. what tricks can I use to give my code an edge with respect to time complexity."
                    },
                    {
                        "username": "zenfred",
                        "content": "1. Try waiting a while and resubmitting. LC servers are not stable in terms of runtime.\\n2. If your solution still runs slow, post the code so that we can diagnose it for you."
                    },
                    {
                        "username": "abhipatwari",
                        "content": "what\\'s different with use case \"distance\" and \"springbok\"?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "WTF !!! I some how solved this shit !!"
                    },
                    {
                        "username": "lipsapatel25",
                        "content": "This video explains the problem very well\\nhttps://youtu.be/CELw4LKLSeE"
                    },
                    {
                        "username": "bogdanctx",
                        "content": "This is easily done if Levenshtein distance algorithm is applied."
                    },
                    {
                        "username": "sad_python",
                        "content": "THIS IS HARD!!\\n"
                    }
                ]
            },
            {
                "id": 2034681,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "It was a good run..."
                    },
                    {
                        "username": "pandey_nikhil",
                        "content": "what is the name \"EDIT DISTANCE \" suggest with respect to this question , I mean why the question name is EDIT DISTANCE ? I\\'m curious \\uD83E\\uDD14about it."
                    },
                    {
                        "username": "preetisushma",
                        "content": "https://codemummy.blogspot.com/2020/08/edit-distance-dynamic-programming.html\\n\\nvery easy"
                    },
                    {
                        "username": "greensabath",
                        "content": "This link doesn\\'t explain anything that the code is doing. It also does not use the minDistance function with 2 parms. It uses 2 additional parms which it does not explain what they are."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "eric0831",
                        "content": "By now I believe most of you understand dp[i - 1][j - 1] for `replace`, but how about `insert` and `delete`?\\n\\nFor instance, if we want to match `abbc` to `acc`, we need to take a look of the sub problem, what is the minimum steps we need to make `abb` to match `ac`.\\nHere we have our first case when 2 charactre are the same, we move both pointer to the left  `if(s1.charAt(j - 1) == s2.charAt(j - 1) ` -> `f[i][j] = f[i - 1][j - 1]`\\nWe continue our discussion here, now our goal is to make `abb` to match `ac`, three things we can do here, which is  `replace` , `insert`, and `delete`,\\nFor  `replace`, we replace the last character `b` to `c` and we will have `abc` to match `ac`, and our sub problem will be the min steps to match `ab` to `a`, which gives us `f[i][j] = f[i - 1][j - 1]`\\nFor `delete`, which means we delete the last character, now we need to match `ab` to `ac` which gives us `f[i][j] = f[i - 1][j - 1]`\\n\\nThe hardest part for this problem is to understand insert, so for our `abb` to match `ac` , we can add a `c` to our first string, and we will have `abbc` to match `ac`, now our sub problem become to mach `abb` to `a`, at this point we need to move our second string to the left, which gives us `f[i][j] = f[i][j - 1]`\\n\\nI\\'m sure from here you are smart enough to firgure out the rest."
                    },
                    {
                        "username": "mrigankkhandelwal300",
                        "content": "Hey all,\\n\\nI solved this problem using DP with TC O(mn). However it beats only 12~15% solutions. How do I improve time complexity beyond my algorithm i.e. what tricks can I use to give my code an edge with respect to time complexity."
                    },
                    {
                        "username": "zenfred",
                        "content": "1. Try waiting a while and resubmitting. LC servers are not stable in terms of runtime.\\n2. If your solution still runs slow, post the code so that we can diagnose it for you."
                    },
                    {
                        "username": "abhipatwari",
                        "content": "what\\'s different with use case \"distance\" and \"springbok\"?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "WTF !!! I some how solved this shit !!"
                    },
                    {
                        "username": "lipsapatel25",
                        "content": "This video explains the problem very well\\nhttps://youtu.be/CELw4LKLSeE"
                    },
                    {
                        "username": "bogdanctx",
                        "content": "This is easily done if Levenshtein distance algorithm is applied."
                    },
                    {
                        "username": "sad_python",
                        "content": "THIS IS HARD!!\\n"
                    }
                ]
            },
            {
                "id": 2028500,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "It was a good run..."
                    },
                    {
                        "username": "pandey_nikhil",
                        "content": "what is the name \"EDIT DISTANCE \" suggest with respect to this question , I mean why the question name is EDIT DISTANCE ? I\\'m curious \\uD83E\\uDD14about it."
                    },
                    {
                        "username": "preetisushma",
                        "content": "https://codemummy.blogspot.com/2020/08/edit-distance-dynamic-programming.html\\n\\nvery easy"
                    },
                    {
                        "username": "greensabath",
                        "content": "This link doesn\\'t explain anything that the code is doing. It also does not use the minDistance function with 2 parms. It uses 2 additional parms which it does not explain what they are."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "eric0831",
                        "content": "By now I believe most of you understand dp[i - 1][j - 1] for `replace`, but how about `insert` and `delete`?\\n\\nFor instance, if we want to match `abbc` to `acc`, we need to take a look of the sub problem, what is the minimum steps we need to make `abb` to match `ac`.\\nHere we have our first case when 2 charactre are the same, we move both pointer to the left  `if(s1.charAt(j - 1) == s2.charAt(j - 1) ` -> `f[i][j] = f[i - 1][j - 1]`\\nWe continue our discussion here, now our goal is to make `abb` to match `ac`, three things we can do here, which is  `replace` , `insert`, and `delete`,\\nFor  `replace`, we replace the last character `b` to `c` and we will have `abc` to match `ac`, and our sub problem will be the min steps to match `ab` to `a`, which gives us `f[i][j] = f[i - 1][j - 1]`\\nFor `delete`, which means we delete the last character, now we need to match `ab` to `ac` which gives us `f[i][j] = f[i - 1][j - 1]`\\n\\nThe hardest part for this problem is to understand insert, so for our `abb` to match `ac` , we can add a `c` to our first string, and we will have `abbc` to match `ac`, now our sub problem become to mach `abb` to `a`, at this point we need to move our second string to the left, which gives us `f[i][j] = f[i][j - 1]`\\n\\nI\\'m sure from here you are smart enough to firgure out the rest."
                    },
                    {
                        "username": "mrigankkhandelwal300",
                        "content": "Hey all,\\n\\nI solved this problem using DP with TC O(mn). However it beats only 12~15% solutions. How do I improve time complexity beyond my algorithm i.e. what tricks can I use to give my code an edge with respect to time complexity."
                    },
                    {
                        "username": "zenfred",
                        "content": "1. Try waiting a while and resubmitting. LC servers are not stable in terms of runtime.\\n2. If your solution still runs slow, post the code so that we can diagnose it for you."
                    },
                    {
                        "username": "abhipatwari",
                        "content": "what\\'s different with use case \"distance\" and \"springbok\"?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "WTF !!! I some how solved this shit !!"
                    },
                    {
                        "username": "lipsapatel25",
                        "content": "This video explains the problem very well\\nhttps://youtu.be/CELw4LKLSeE"
                    },
                    {
                        "username": "bogdanctx",
                        "content": "This is easily done if Levenshtein distance algorithm is applied."
                    },
                    {
                        "username": "sad_python",
                        "content": "THIS IS HARD!!\\n"
                    }
                ]
            },
            {
                "id": 2018671,
                "content": [
                    {
                        "username": "lin25_",
                        "content": "not them changing this to a medium"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "What I thought was to do actual operations on strings \n\n\n    // Insert\n    word1.insert(i, 1, word2[j]);\n\n    // Delete\n    word1.erase(i, 1);\n\n    // Replace\n    word1.replace(i, 1, 1, word2[j]);\n\nBut it is not the way this problem solve. If you are thinking same like me you have to change your approach little bit. instead of doing this heavy operation on each charactor maintain helper row & column on 0th index with some value and do the operation using that helper row & column.\n\nHappy coding :)\n"
                    },
                    {
                        "username": "yash_4980",
                        "content": "The time when TLE on recursive approach don\\'t hurt you more, but your are happy of finding a brute force to the problem and enjoy the fact that now, you have good skills at creating recursive solutions than before."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "I solved it on my own!!! Never been so much happy :-)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Just can\\'t believe I have solved it without the solution!"
                    },
                    {
                        "username": "MukulDev007",
                        "content": "Draw the recursion tree for this problem, and then find the relation between indexes of both word.\\nWhat to do when the words match? If they dont match, try performing the 3 operations, see the index.\\nAfter recursive solution is established, try DP."
                    },
                    {
                        "username": "Arnius",
                        "content": "this seems challenging. nice lets see!"
                    },
                    {
                        "username": "Finesse",
                        "content": "A very similar problem: [1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)"
                    },
                    {
                        "username": "Zein4",
                        "content": "does it help if I solve an easier related problem? if so what is the name of the question"
                    },
                    {
                        "username": "aitachii",
                        "content": "wat\\nive read the paper but i still dont understand why those formulas were used"
                    }
                ]
            },
            {
                "id": 2007725,
                "content": [
                    {
                        "username": "lin25_",
                        "content": "not them changing this to a medium"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "What I thought was to do actual operations on strings \n\n\n    // Insert\n    word1.insert(i, 1, word2[j]);\n\n    // Delete\n    word1.erase(i, 1);\n\n    // Replace\n    word1.replace(i, 1, 1, word2[j]);\n\nBut it is not the way this problem solve. If you are thinking same like me you have to change your approach little bit. instead of doing this heavy operation on each charactor maintain helper row & column on 0th index with some value and do the operation using that helper row & column.\n\nHappy coding :)\n"
                    },
                    {
                        "username": "yash_4980",
                        "content": "The time when TLE on recursive approach don\\'t hurt you more, but your are happy of finding a brute force to the problem and enjoy the fact that now, you have good skills at creating recursive solutions than before."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "I solved it on my own!!! Never been so much happy :-)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Just can\\'t believe I have solved it without the solution!"
                    },
                    {
                        "username": "MukulDev007",
                        "content": "Draw the recursion tree for this problem, and then find the relation between indexes of both word.\\nWhat to do when the words match? If they dont match, try performing the 3 operations, see the index.\\nAfter recursive solution is established, try DP."
                    },
                    {
                        "username": "Arnius",
                        "content": "this seems challenging. nice lets see!"
                    },
                    {
                        "username": "Finesse",
                        "content": "A very similar problem: [1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)"
                    },
                    {
                        "username": "Zein4",
                        "content": "does it help if I solve an easier related problem? if so what is the name of the question"
                    },
                    {
                        "username": "aitachii",
                        "content": "wat\\nive read the paper but i still dont understand why those formulas were used"
                    }
                ]
            },
            {
                "id": 2001869,
                "content": [
                    {
                        "username": "lin25_",
                        "content": "not them changing this to a medium"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "What I thought was to do actual operations on strings \n\n\n    // Insert\n    word1.insert(i, 1, word2[j]);\n\n    // Delete\n    word1.erase(i, 1);\n\n    // Replace\n    word1.replace(i, 1, 1, word2[j]);\n\nBut it is not the way this problem solve. If you are thinking same like me you have to change your approach little bit. instead of doing this heavy operation on each charactor maintain helper row & column on 0th index with some value and do the operation using that helper row & column.\n\nHappy coding :)\n"
                    },
                    {
                        "username": "yash_4980",
                        "content": "The time when TLE on recursive approach don\\'t hurt you more, but your are happy of finding a brute force to the problem and enjoy the fact that now, you have good skills at creating recursive solutions than before."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "I solved it on my own!!! Never been so much happy :-)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Just can\\'t believe I have solved it without the solution!"
                    },
                    {
                        "username": "MukulDev007",
                        "content": "Draw the recursion tree for this problem, and then find the relation between indexes of both word.\\nWhat to do when the words match? If they dont match, try performing the 3 operations, see the index.\\nAfter recursive solution is established, try DP."
                    },
                    {
                        "username": "Arnius",
                        "content": "this seems challenging. nice lets see!"
                    },
                    {
                        "username": "Finesse",
                        "content": "A very similar problem: [1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)"
                    },
                    {
                        "username": "Zein4",
                        "content": "does it help if I solve an easier related problem? if so what is the name of the question"
                    },
                    {
                        "username": "aitachii",
                        "content": "wat\\nive read the paper but i still dont understand why those formulas were used"
                    }
                ]
            },
            {
                "id": 1921440,
                "content": [
                    {
                        "username": "lin25_",
                        "content": "not them changing this to a medium"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "What I thought was to do actual operations on strings \n\n\n    // Insert\n    word1.insert(i, 1, word2[j]);\n\n    // Delete\n    word1.erase(i, 1);\n\n    // Replace\n    word1.replace(i, 1, 1, word2[j]);\n\nBut it is not the way this problem solve. If you are thinking same like me you have to change your approach little bit. instead of doing this heavy operation on each charactor maintain helper row & column on 0th index with some value and do the operation using that helper row & column.\n\nHappy coding :)\n"
                    },
                    {
                        "username": "yash_4980",
                        "content": "The time when TLE on recursive approach don\\'t hurt you more, but your are happy of finding a brute force to the problem and enjoy the fact that now, you have good skills at creating recursive solutions than before."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "I solved it on my own!!! Never been so much happy :-)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Just can\\'t believe I have solved it without the solution!"
                    },
                    {
                        "username": "MukulDev007",
                        "content": "Draw the recursion tree for this problem, and then find the relation between indexes of both word.\\nWhat to do when the words match? If they dont match, try performing the 3 operations, see the index.\\nAfter recursive solution is established, try DP."
                    },
                    {
                        "username": "Arnius",
                        "content": "this seems challenging. nice lets see!"
                    },
                    {
                        "username": "Finesse",
                        "content": "A very similar problem: [1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)"
                    },
                    {
                        "username": "Zein4",
                        "content": "does it help if I solve an easier related problem? if so what is the name of the question"
                    },
                    {
                        "username": "aitachii",
                        "content": "wat\\nive read the paper but i still dont understand why those formulas were used"
                    }
                ]
            },
            {
                "id": 1919830,
                "content": [
                    {
                        "username": "lin25_",
                        "content": "not them changing this to a medium"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "What I thought was to do actual operations on strings \n\n\n    // Insert\n    word1.insert(i, 1, word2[j]);\n\n    // Delete\n    word1.erase(i, 1);\n\n    // Replace\n    word1.replace(i, 1, 1, word2[j]);\n\nBut it is not the way this problem solve. If you are thinking same like me you have to change your approach little bit. instead of doing this heavy operation on each charactor maintain helper row & column on 0th index with some value and do the operation using that helper row & column.\n\nHappy coding :)\n"
                    },
                    {
                        "username": "yash_4980",
                        "content": "The time when TLE on recursive approach don\\'t hurt you more, but your are happy of finding a brute force to the problem and enjoy the fact that now, you have good skills at creating recursive solutions than before."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "I solved it on my own!!! Never been so much happy :-)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Just can\\'t believe I have solved it without the solution!"
                    },
                    {
                        "username": "MukulDev007",
                        "content": "Draw the recursion tree for this problem, and then find the relation between indexes of both word.\\nWhat to do when the words match? If they dont match, try performing the 3 operations, see the index.\\nAfter recursive solution is established, try DP."
                    },
                    {
                        "username": "Arnius",
                        "content": "this seems challenging. nice lets see!"
                    },
                    {
                        "username": "Finesse",
                        "content": "A very similar problem: [1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)"
                    },
                    {
                        "username": "Zein4",
                        "content": "does it help if I solve an easier related problem? if so what is the name of the question"
                    },
                    {
                        "username": "aitachii",
                        "content": "wat\\nive read the paper but i still dont understand why those formulas were used"
                    }
                ]
            },
            {
                "id": 1816391,
                "content": [
                    {
                        "username": "lin25_",
                        "content": "not them changing this to a medium"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "What I thought was to do actual operations on strings \n\n\n    // Insert\n    word1.insert(i, 1, word2[j]);\n\n    // Delete\n    word1.erase(i, 1);\n\n    // Replace\n    word1.replace(i, 1, 1, word2[j]);\n\nBut it is not the way this problem solve. If you are thinking same like me you have to change your approach little bit. instead of doing this heavy operation on each charactor maintain helper row & column on 0th index with some value and do the operation using that helper row & column.\n\nHappy coding :)\n"
                    },
                    {
                        "username": "yash_4980",
                        "content": "The time when TLE on recursive approach don\\'t hurt you more, but your are happy of finding a brute force to the problem and enjoy the fact that now, you have good skills at creating recursive solutions than before."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "I solved it on my own!!! Never been so much happy :-)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Just can\\'t believe I have solved it without the solution!"
                    },
                    {
                        "username": "MukulDev007",
                        "content": "Draw the recursion tree for this problem, and then find the relation between indexes of both word.\\nWhat to do when the words match? If they dont match, try performing the 3 operations, see the index.\\nAfter recursive solution is established, try DP."
                    },
                    {
                        "username": "Arnius",
                        "content": "this seems challenging. nice lets see!"
                    },
                    {
                        "username": "Finesse",
                        "content": "A very similar problem: [1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)"
                    },
                    {
                        "username": "Zein4",
                        "content": "does it help if I solve an easier related problem? if so what is the name of the question"
                    },
                    {
                        "username": "aitachii",
                        "content": "wat\\nive read the paper but i still dont understand why those formulas were used"
                    }
                ]
            },
            {
                "id": 1815338,
                "content": [
                    {
                        "username": "lin25_",
                        "content": "not them changing this to a medium"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "What I thought was to do actual operations on strings \n\n\n    // Insert\n    word1.insert(i, 1, word2[j]);\n\n    // Delete\n    word1.erase(i, 1);\n\n    // Replace\n    word1.replace(i, 1, 1, word2[j]);\n\nBut it is not the way this problem solve. If you are thinking same like me you have to change your approach little bit. instead of doing this heavy operation on each charactor maintain helper row & column on 0th index with some value and do the operation using that helper row & column.\n\nHappy coding :)\n"
                    },
                    {
                        "username": "yash_4980",
                        "content": "The time when TLE on recursive approach don\\'t hurt you more, but your are happy of finding a brute force to the problem and enjoy the fact that now, you have good skills at creating recursive solutions than before."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "I solved it on my own!!! Never been so much happy :-)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Just can\\'t believe I have solved it without the solution!"
                    },
                    {
                        "username": "MukulDev007",
                        "content": "Draw the recursion tree for this problem, and then find the relation between indexes of both word.\\nWhat to do when the words match? If they dont match, try performing the 3 operations, see the index.\\nAfter recursive solution is established, try DP."
                    },
                    {
                        "username": "Arnius",
                        "content": "this seems challenging. nice lets see!"
                    },
                    {
                        "username": "Finesse",
                        "content": "A very similar problem: [1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)"
                    },
                    {
                        "username": "Zein4",
                        "content": "does it help if I solve an easier related problem? if so what is the name of the question"
                    },
                    {
                        "username": "aitachii",
                        "content": "wat\\nive read the paper but i still dont understand why those formulas were used"
                    }
                ]
            },
            {
                "id": 1815308,
                "content": [
                    {
                        "username": "lin25_",
                        "content": "not them changing this to a medium"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "What I thought was to do actual operations on strings \n\n\n    // Insert\n    word1.insert(i, 1, word2[j]);\n\n    // Delete\n    word1.erase(i, 1);\n\n    // Replace\n    word1.replace(i, 1, 1, word2[j]);\n\nBut it is not the way this problem solve. If you are thinking same like me you have to change your approach little bit. instead of doing this heavy operation on each charactor maintain helper row & column on 0th index with some value and do the operation using that helper row & column.\n\nHappy coding :)\n"
                    },
                    {
                        "username": "yash_4980",
                        "content": "The time when TLE on recursive approach don\\'t hurt you more, but your are happy of finding a brute force to the problem and enjoy the fact that now, you have good skills at creating recursive solutions than before."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "I solved it on my own!!! Never been so much happy :-)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Just can\\'t believe I have solved it without the solution!"
                    },
                    {
                        "username": "MukulDev007",
                        "content": "Draw the recursion tree for this problem, and then find the relation between indexes of both word.\\nWhat to do when the words match? If they dont match, try performing the 3 operations, see the index.\\nAfter recursive solution is established, try DP."
                    },
                    {
                        "username": "Arnius",
                        "content": "this seems challenging. nice lets see!"
                    },
                    {
                        "username": "Finesse",
                        "content": "A very similar problem: [1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)"
                    },
                    {
                        "username": "Zein4",
                        "content": "does it help if I solve an easier related problem? if so what is the name of the question"
                    },
                    {
                        "username": "aitachii",
                        "content": "wat\\nive read the paper but i still dont understand why those formulas were used"
                    }
                ]
            },
            {
                "id": 1815230,
                "content": [
                    {
                        "username": "lin25_",
                        "content": "not them changing this to a medium"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "What I thought was to do actual operations on strings \n\n\n    // Insert\n    word1.insert(i, 1, word2[j]);\n\n    // Delete\n    word1.erase(i, 1);\n\n    // Replace\n    word1.replace(i, 1, 1, word2[j]);\n\nBut it is not the way this problem solve. If you are thinking same like me you have to change your approach little bit. instead of doing this heavy operation on each charactor maintain helper row & column on 0th index with some value and do the operation using that helper row & column.\n\nHappy coding :)\n"
                    },
                    {
                        "username": "yash_4980",
                        "content": "The time when TLE on recursive approach don\\'t hurt you more, but your are happy of finding a brute force to the problem and enjoy the fact that now, you have good skills at creating recursive solutions than before."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "I solved it on my own!!! Never been so much happy :-)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Just can\\'t believe I have solved it without the solution!"
                    },
                    {
                        "username": "MukulDev007",
                        "content": "Draw the recursion tree for this problem, and then find the relation between indexes of both word.\\nWhat to do when the words match? If they dont match, try performing the 3 operations, see the index.\\nAfter recursive solution is established, try DP."
                    },
                    {
                        "username": "Arnius",
                        "content": "this seems challenging. nice lets see!"
                    },
                    {
                        "username": "Finesse",
                        "content": "A very similar problem: [1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)"
                    },
                    {
                        "username": "Zein4",
                        "content": "does it help if I solve an easier related problem? if so what is the name of the question"
                    },
                    {
                        "username": "aitachii",
                        "content": "wat\\nive read the paper but i still dont understand why those formulas were used"
                    }
                ]
            },
            {
                "id": 1815225,
                "content": [
                    {
                        "username": "lin25_",
                        "content": "not them changing this to a medium"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "What I thought was to do actual operations on strings \n\n\n    // Insert\n    word1.insert(i, 1, word2[j]);\n\n    // Delete\n    word1.erase(i, 1);\n\n    // Replace\n    word1.replace(i, 1, 1, word2[j]);\n\nBut it is not the way this problem solve. If you are thinking same like me you have to change your approach little bit. instead of doing this heavy operation on each charactor maintain helper row & column on 0th index with some value and do the operation using that helper row & column.\n\nHappy coding :)\n"
                    },
                    {
                        "username": "yash_4980",
                        "content": "The time when TLE on recursive approach don\\'t hurt you more, but your are happy of finding a brute force to the problem and enjoy the fact that now, you have good skills at creating recursive solutions than before."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "I solved it on my own!!! Never been so much happy :-)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Just can\\'t believe I have solved it without the solution!"
                    },
                    {
                        "username": "MukulDev007",
                        "content": "Draw the recursion tree for this problem, and then find the relation between indexes of both word.\\nWhat to do when the words match? If they dont match, try performing the 3 operations, see the index.\\nAfter recursive solution is established, try DP."
                    },
                    {
                        "username": "Arnius",
                        "content": "this seems challenging. nice lets see!"
                    },
                    {
                        "username": "Finesse",
                        "content": "A very similar problem: [1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)"
                    },
                    {
                        "username": "Zein4",
                        "content": "does it help if I solve an easier related problem? if so what is the name of the question"
                    },
                    {
                        "username": "aitachii",
                        "content": "wat\\nive read the paper but i still dont understand why those formulas were used"
                    }
                ]
            }
        ]
    },
    {
        "title": "Factorial Trailing Zeroes",
        "question_content": "<p>Given an integer <code>n</code>, return <em>the number of trailing zeroes in </em><code>n!</code>.</p>\n\n<p>Note that <code>n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 3\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> 3! = 6, no trailing zero.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 5\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> 5! = 120, one trailing zero.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 0\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you write a solution that works in logarithmic time complexity?</p>\n",
        "solutions": [
            {
                "id": 52371,
                "title": "my-one-line-solutions-in-3-languages",
                "content": "This question is pretty straightforward.\\n\\nBecause all trailing 0 is from factors 5 * 2. \\n\\nBut sometimes one number may have several 5 factors, for example, 25 have two 5 factors, 125 have three 5 factors. In the n! operation, factors 2 is always ample.  So we just count how many 5 factors in all number from 1 to n. \\n\\nOne line code:\\n\\nJava:\\n\\n        return n == 0 ? 0 : n / 5 + trailingZeroes(n / 5);\\n\\nC++:\\n\\n        return n == 0 ? 0 : n / 5 + trailingZeroes(n / 5);\\n\\nPython:\\n\\n        return 0 if n == 0 else n / 5 + self.trailingZeroes(n / 5)",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "This question is pretty straightforward.\\n\\nBecause all trailing 0 is from factors 5 * 2. \\n\\nBut sometimes one number may have several 5 factors, for example, 25 have two 5 factors, 125 have three 5 factors. In the n! operation, factors 2 is always ample.  So we just count how many 5 factors in all number from 1 to n. \\n\\nOne line code:\\n\\nJava:\\n\\n        return n == 0 ? 0 : n / 5 + trailingZeroes(n / 5);\\n\\nC++:\\n\\n        return n == 0 ? 0 : n / 5 + trailingZeroes(n / 5);\\n\\nPython:\\n\\n        return 0 if n == 0 else n / 5 + self.trailingZeroes(n / 5)",
                "codeTag": "Unknown"
            },
            {
                "id": 52373,
                "title": "simple-c-c-solution-with-detailed-explaination",
                "content": "The idea is: \\n\\n 1. The ZERO comes from 10.  \\n 2. The 10 comes from 2 x 5 \\n 3. And we need to account for all the products of 5 and 2. likes 4\\xd75 = 20 ...\\n 4. So, if we take all the numbers with 5 as a factor, we'll have way  more than enough even numbers to pair with them to get factors of 10\\n\\n**Example One**\\n\\nHow many multiples of 5 are between 1 and 23? There is 5, 10, 15, and 20, for four multiples of 5. Paired with 2's from the even factors, this makes for four factors of 10, so: **23! has 4 zeros**.\\n\\n\\n**Example Two**\\n\\nHow many multiples of 5 are there in the numbers from 1 to 100? \\n\\nbecause   100 \\xf7 5 = 20, so, there are twenty multiples of 5 between 1 and 100.\\n\\nbut wait, actually 25 is 5\\xd75, so each multiple of 25 has an extra factor of 5, e.g. 25 \\xd7 4 = 100\\uff0cwhich introduces extra of zero.\\n\\nSo, we need know how many multiples of 25 are between 1 and 100? Since 100 \\xf7 25 = 4, there are four multiples of 25 between 1 and 100.\\n\\nFinally, we get 20 + 4 = 24 trailing zeroes in 100!\\n\\n\\nThe above example tell us, we need care about 5, 5\\xd75, 5\\xd75\\xd75, 5\\xd75\\xd75\\xd75 ....\\n\\n**Example Three**\\n\\nBy given number 4617.\\n\\n5^1 :  4617 \\xf7 5 = 923.4, so we get 923 factors of 5\\n\\n5^2 :  4617 \\xf7 25 = 184.68, so we get 184 additional factors of 5\\n\\n5^3 :  4617 \\xf7 125 = 36.936, so we get 36 additional factors of 5\\n\\n5^4 :  4617 \\xf7 625 = 7.3872, so we get 7 additional factors of 5\\n\\n5^5 :  4617 \\xf7 3125 = 1.47744, so we get 1 more factor of 5\\n\\n5^6 :  4617 \\xf7 15625 = 0.295488, which is less than 1, so stop here.\\n\\nThen 4617! has 923 + 184 + 36 + 7 + 1 = 1151 trailing zeroes.\\n\\nC/C++ code \\n\\n    int trailingZeroes(int n) {\\n        int result = 0;\\n        for(long long i=5; n/i>0; i*=5){\\n            result += (n/i);\\n        }\\n        return result;\\n    }\\n\\n\\n---------update-----------\\n\\nTo avoid the integer overflow as **@localvar** mentioned below(in case of 'n >=1808548329' ), the expression \" i <= INT_MAX/5\" is not a good way to prevent overflow, because 5^13 is > INT_MAX/5 and it's valid. \\n\\nSo, if you want to use \"multiply\", consider define the 'i' as 'long long' type.\\n\\nOr, take the solution **@codingryan** mentioned in below answer!",
                "solutionTags": [],
                "code": "The idea is: \\n\\n 1. The ZERO comes from 10.  \\n 2. The 10 comes from 2 x 5 \\n 3. And we need to account for all the products of 5 and 2. likes 4\\xd75 = 20 ...\\n 4. So, if we take all the numbers with 5 as a factor, we'll have way  more than enough even numbers to pair with them to get factors of 10\\n\\n**Example One**\\n\\nHow many multiples of 5 are between 1 and 23? There is 5, 10, 15, and 20, for four multiples of 5. Paired with 2's from the even factors, this makes for four factors of 10, so: **23! has 4 zeros**.\\n\\n\\n**Example Two**\\n\\nHow many multiples of 5 are there in the numbers from 1 to 100? \\n\\nbecause   100 \\xf7 5 = 20, so, there are twenty multiples of 5 between 1 and 100.\\n\\nbut wait, actually 25 is 5\\xd75, so each multiple of 25 has an extra factor of 5, e.g. 25 \\xd7 4 = 100\\uff0cwhich introduces extra of zero.\\n\\nSo, we need know how many multiples of 25 are between 1 and 100? Since 100 \\xf7 25 = 4, there are four multiples of 25 between 1 and 100.\\n\\nFinally, we get 20 + 4 = 24 trailing zeroes in 100!\\n\\n\\nThe above example tell us, we need care about 5, 5\\xd75, 5\\xd75\\xd75, 5\\xd75\\xd75\\xd75 ....\\n\\n**Example Three**\\n\\nBy given number 4617.\\n\\n5^1 :  4617 \\xf7 5 = 923.4, so we get 923 factors of 5\\n\\n5^2 :  4617 \\xf7 25 = 184.68, so we get 184 additional factors of 5\\n\\n5^3 :  4617 \\xf7 125 = 36.936, so we get 36 additional factors of 5\\n\\n5^4 :  4617 \\xf7 625 = 7.3872, so we get 7 additional factors of 5\\n\\n5^5 :  4617 \\xf7 3125 = 1.47744, so we get 1 more factor of 5\\n\\n5^6 :  4617 \\xf7 15625 = 0.295488, which is less than 1, so stop here.\\n\\nThen 4617! has 923 + 184 + 36 + 7 + 1 = 1151 trailing zeroes.\\n\\nC/C++ code \\n\\n    int trailingZeroes(int n) {\\n        int result = 0;\\n        for(long long i=5; n/i>0; i*=5){\\n            result += (n/i);\\n        }\\n        return result;\\n    }\\n\\n\\n---------update-----------\\n\\nTo avoid the integer overflow as **@localvar** mentioned below(in case of 'n >=1808548329' ), the expression \" i <= INT_MAX/5\" is not a good way to prevent overflow, because 5^13 is > INT_MAX/5 and it's valid. \\n\\nSo, if you want to use \"multiply\", consider define the 'i' as 'long long' type.\\n\\nOr, take the solution **@codingryan** mentioned in below answer!",
                "codeTag": "Unknown"
            },
            {
                "id": 52367,
                "title": "my-explanation-of-the-log-n-solution",
                "content": "10 is the product of 2 and 5. In n!, we need to know how many 2 and 5, and the number of zeros is the minimum of the number of 2 and the number of 5.\\n\\nSince multiple of 2 is more than multiple of 5, the number of zeros is dominant by the number of 5.\\n\\nHere we expand  \\n\\n      2147483647!\\n    =2 * 3 * ...* 5 ... *10 ... 15* ... * 25 ... * 50 ... * 125 ... * 250...\\n    =2 * 3 * ...* 5 ... * (5^1*2)...(5^1*3)...*(5^2*1)...*(5^2*2)...*(5^3*1)...*(5^3*2)... (Equation 1)\\n\\nWe just count the number of 5 in Equation 1.\\n\\nMultiple of 5 provides one 5, multiple of 25 provides two 5 and so on.\\n\\nNote the duplication: multiple of 25 is also multiple of 5, so multiple of 25 only provides one extra 5.\\n\\nHere is the basic solution:\\n\\n    return n/5 + n/25 + n/125 + n/625 + n/3125+...;\\n\\nYou can easily rewrite it to a loop.",
                "solutionTags": [],
                "code": "10 is the product of 2 and 5. In n!, we need to know how many 2 and 5, and the number of zeros is the minimum of the number of 2 and the number of 5.\\n\\nSince multiple of 2 is more than multiple of 5, the number of zeros is dominant by the number of 5.\\n\\nHere we expand  \\n\\n      2147483647!\\n    =2 * 3 * ...* 5 ... *10 ... 15* ... * 25 ... * 50 ... * 125 ... * 250...\\n    =2 * 3 * ...* 5 ... * (5^1*2)...(5^1*3)...*(5^2*1)...*(5^2*2)...*(5^3*1)...*(5^3*2)... (Equation 1)\\n\\nWe just count the number of 5 in Equation 1.\\n\\nMultiple of 5 provides one 5, multiple of 25 provides two 5 and so on.\\n\\nNote the duplication: multiple of 25 is also multiple of 5, so multiple of 25 only provides one extra 5.\\n\\nHere is the basic solution:\\n\\n    return n/5 + n/25 + n/125 + n/625 + n/3125+...;\\n\\nYou can easily rewrite it to a loop.",
                "codeTag": "Unknown"
            },
            {
                "id": 52470,
                "title": "4-lines-4ms-c-solution-with-explanations",
                "content": "Well, to compute the number of trailing zeros, we need to first think clear about what will generate a trailing `0`? Obviously, a number multiplied by `10` will have a trailing `0` added to it. So we only need to find out how many `10`'s will appear in the expression of the factorial. Since `10 = 2 * 5` and there are a bunch more `2`'s (each even number will contribute at least one `2`), we only need to count the number of `5`'s.\\n\\nNow let's see what numbers will contribute a `5`. Well, simply the multiples of `5`, like `5, 10, 15, 20, 25, 35, ...`. So is the result simply `n / 5`? Well, not that easy. Notice that some numbers may contribute more than one `5`, like `25 = 5 * 5`. Well, what numbers will contribute more than one `5`? Ok, you may notice that only multiples of the power of `5` will contribute more than one `5`. For example, multiples of `25` will contribute at least two `5`'s.\\n\\nWell, how to count them all? If you try some examples, you may finally get the result, which is `n / 5 + n / 25 + n / 125 + ...`. The idea behind this expression is: all the multiples of `5` will contribute one `5`, the multiples of `25` will contribute one more `5` and the multiples of `125` will contribute another one more `5`... and so on. Now, we can write down the following code, which is pretty short.\\n\\n    class Solution {\\n    public:\\n        int trailingZeroes(int n) { \\n            int count = 0;\\n            for (long long i = 5; n / i; i *= 5)\\n                count += n / i;\\n            return count;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "class Solution {\\n    public:\\n        int trailingZeroes(int n) { \\n            int count = 0;\\n            for (long long i = 5; n / i; i *= 5)\\n                count += n / i;\\n            return count;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 52506,
                "title": "o-log-5-n-solution-java",
                "content": "O(log_5(N)) (base 5!) is faster than any polynomial. You need no more than 14 iterations to get the result. You just need to count how many times 5 appears in n! during multiplication in different forms: 5, 25, 125, 625, ... . when any 5 is multiplied by 2 (we have many of them) then we get 0 at the end. That's it.\\n\\n    public class Solution {\\n        public int trailingZeroes(int n) {\\n            int r = 0;\\n            while (n > 0) {\\n                n /= 5;\\n                r += n;\\n            }\\n            return r;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int trailingZeroes(int n) {\\n            int r = 0;\\n            while (n > 0) {\\n                n /= 5;\\n                r += n;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 355808,
                "title": "javascript-solution-with-explanation",
                "content": "First, let\\'s think about in what situation will we get a trailing zero. We get a trailing zero whenever we multiply a non zero number by 10.\\n\\nExample: 1 * 10 = 10\\n\\nSince 10 is made up of multiplying 2 by 5, another way to get a trailing zero is to multiply a non zero number by 2 and 5.\\n\\nExample: 1 * 2 * 5 = 10\\n\\nSo, to count the number of trailing zeroes we just need to figure out how many times we multiply 2 by 5.\\n\\nExample: \\n1 * (2 * 5) = 10 // one trailing zero\\n1 * (2 * 5) * (2 * 5) = 100 // two trailing zeroes\\n\\nNow let\\'s look at factorial.\\n\\nThe factorial of 5 is:\\n1 * **2** * 3 * 4 * **5** = 120\\nSince we have multiplied 2 and 5 once, there is one trailing zero.\\n\\nThe factorial of 10 is:\\n1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 = 3628800\\nAnother way to write this is:\\n1 * **2** * 3 * 4 * **5** * 6 * 7 * 8 * 9 * **2** * **5** = 3628800\\nAs you can see, we have multiplied 2 and 5 twice, so there are two trailing zeroes.\\n\\nInstead of keeping track of the number of 2s and 5s, we really just need to keep track of the number of 5s. This is because in any factorial calculation there are always going to be more multiples of 2 than 5. \\n\\nExample: From the numbers 1 to 10, there are five multiples of 2 but only two multiples of 5. \\n\\nQuestion: How many 5s are there in the factorial of 25?\\nYou may guess the answer is 25 / 5 = 5, however there are actually 6.\\n\\nHere are all the multiples of 5 in the factorial of 25: \\n5, 10, 15, 20, 25\\nAnother way to write this is:\\n(5 * 1), (5 * 2), (5 * 3), (5 * 4), (5 * 5)\\nAs you can see, 5 is actually multiplied 6 times.\\n\\nWe can simplify the answer to the Factorial Trailing Zeroes question to the following:\\n(n / 5) + (n / 5^2) + (n / 5^3)... (n / 5^x)\\nWe continue until 5^x is greater than n.\\n\\n```\\nvar trailingZeroes = function(n) {\\n    let numZeroes = 0;\\n    for (let i = 5; i <= n; i *= 5) {\\n        numZeroes += Math.floor(n / i);\\n    }\\n    return numZeroes;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar trailingZeroes = function(n) {\\n    let numZeroes = 0;\\n    for (let i = 5; i <= n; i *= 5) {\\n        numZeroes += Math.floor(n / i);\\n    }\\n    return numZeroes;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 52510,
                "title": "o-log5-n-solution-python",
                "content": "1. meet the number that can be dived by 5, the Trailing will have 1 more zero.\\n\\n2 .meet the number that can be dived by 5*5, the Trailing will have 2 more zero.\\n..\\n\\n..\\n\\n..\\n\\nand so on.\\n\\n\\nso we just find how many number can be dived by 5, can be dived by 5*5 ...  and sum up.\\n\\n\\n        def trailingZeroes(self, n):\\n            r = 0\\n            while n > 0:\\n                n /= 5\\n                r += n\\n            return r",
                "solutionTags": [
                    "Python"
                ],
                "code": "1. meet the number that can be dived by 5, the Trailing will have 1 more zero.\\n\\n2 .meet the number that can be dived by 5*5, the Trailing will have 2 more zero.\\n..\\n\\n..\\n\\n..\\n\\nand so on.\\n\\n\\nso we just find how many number can be dived by 5, can be dived by 5*5 ...  and sum up.\\n\\n\\n        def trailingZeroes(self, n):\\n            r = 0\\n            while n > 0:\\n                n /= 5\\n                r += n\\n            return r",
                "codeTag": "Python3"
            },
            {
                "id": 52424,
                "title": "iterative-python-solution-with-explanation",
                "content": "We add a trailing zero every time we multiply by 10 (5 * 2). Since we will have always more 2s than 5s, the problem is to find the number of 5s in the numbers from 1 to n.\\nLet's consider 10! as example:\\n\\n10! = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1\\n\\nIn this case, we have two 5s (in 10 and 5), so the result is 2. How can we efficiently compute this number for a given n? Well, we could compute the multiple of 5 contained in n, but this is not enough: for example, 25 accounts for 2 5s, 50 accounts also for 2 5s, and so on.\\n\\nSo, we do the following: we start from 5, and we see how many multiples of 5 we have in n. Then, we multiply 5 by 5 (25) and we add how many multiples of 25 we have in n. In this case we will not have duplicates, as at in each step we will add only one 5 to the result.\\n\\n    class Solution(object):\\n        def trailingZeroes(self, n):\\n            k, tot = 5, 0\\n            while k <= n:\\n                tot += n // k\\n                k = k * 5\\n            return tot",
                "solutionTags": [
                    "Python"
                ],
                "code": "We add a trailing zero every time we multiply by 10 (5 * 2). Since we will have always more 2s than 5s, the problem is to find the number of 5s in the numbers from 1 to n.\\nLet's consider 10! as example:\\n\\n10! = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1\\n\\nIn this case, we have two 5s (in 10 and 5), so the result is 2. How can we efficiently compute this number for a given n? Well, we could compute the multiple of 5 contained in n, but this is not enough: for example, 25 accounts for 2 5s, 50 accounts also for 2 5s, and so on.\\n\\nSo, we do the following: we start from 5, and we see how many multiples of 5 we have in n. Then, we multiply 5 by 5 (25) and we add how many multiples of 25 we have in n. In this case we will not have duplicates, as at in each step we will add only one 5 to the result.\\n\\n    class Solution(object):\\n        def trailingZeroes(self, n):\\n            k, tot = 5, 0\\n            while k <= n:\\n                tot += n // k\\n                k = k * 5\\n            return tot",
                "codeTag": "Java"
            },
            {
                "id": 755572,
                "title": "python-log-n-loop-100-speed",
                "content": "**Python Log(n) Loop | 100% Speed**\\n\\nThe code below presents an Easy Python solution with clear syntax. The algorithm works as follows:\\n\\n1. The numbers of \"zeros\" in \"n!\" can be traced by decomposing the multiplication \"n * (n-1) * ...\" into a prime factorization with the format:\\n * n! = 2^a * 3^b * 5^c, ...\\n\\n2. In this factorization, the number of \"zeros\" in \"n!\" would correspond to the highest number of \"10\\'s\" that we can form. Since  \"10 = 5 * 2\", the number of zeros would be \"10\\'s = min(a,c) \". \\n\\n3. While we should consider tracking 2^a and 5^c separately, we can note that 50% of integer numbers are even (multiples of 2), whereas only 20% are multiples of 5.\\n\\n4. As a result, we can conclude that we add a zero to our factorial every time we multiply by 5...\\n\\n5. Some numbers can multiply by 5 more than once, such as 5^2 = 25 or 5^3 = 125. We can consider these cases by adding a loop to account for all multiples of 5^x. Since 5^x grows exponentially, we achieve an algorithm with Log(n) time complexity.\\n\\nI hope the explanation was helpful. This is a very interesting problem.\\n\\nCheers,\\n\\n```\\nclass Solution:\\n    def trailingZeroes(self, n):\\n        x   = 5\\n        res = 0\\n        while x <= n:\\n            res += n//x\\n            x   *= 5\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def trailingZeroes(self, n):\\n        x   = 5\\n        res = 0\\n        while x <= n:\\n            res += n//x\\n            x   *= 5\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52493,
                "title": "simple-c-solution",
                "content": "Because from 1 to n, the number of 2 factors is always bigger than the number of 5 factors. So we only need to find the number of 5 factors among 1...n.\\n\\n1st loop: 5, 10, 15, 20, 25, 30, ....\\n\\n2nd loop:                      25              50         ......\\n.....\\n\\ncode:\\n\\n    class Solution {\\n    public:\\n        int trailingZeroes(int n) {\\n            int res=0;\\n            while(n){\\n                n/=5;\\n                res+=n;\\n            }\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int trailingZeroes(int n) {\\n            int res=0;\\n            while(n){\\n                n/=5;\\n                res+=n;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 522315,
                "title": "clear-explanation-of-the-solution-since-i-didn-t-find-an-adequate-one",
                "content": "This problem is difficult mainly because you must reach the insight that __it is a multiple of 5 and an even number that leads to a trailing zero__ and since there are on average 4 times as many even numbers as 5s (from 1-9 for example 2,4,6,8), the limiting factor for the number of trailing zeros are the number of 5s that will be multiplied. Hence, you count them and you\\'re good.\\n\\nTake for example 5! (5 factorial). It is `5 x 4 x 3 x 2 x 1`. It can be written either as `20 x 6` or `10 x 12` in both cases the mutiplication of 5 either with 4 or 2 being the factor that causes the single trailing zero in the final answer 120.\\n\\nSo for n = 25, the factorial:\\n`25 x 24 x 23 x 22 x 21 x 20 x 19 x 18 x 17 x 16 x 15 x 14 x 13 x 12 x 11 x 10 x 9 x 8 x 7 x 6 x 5 x 4 x 3 x 2 x 1`\\n\\nSo the number of 5s here are 5, 10 (5 x 2), 15 (5 x 3), 20 (5 x 4), and two 5s in 25 (5 x 5). So in total 6 fives. So we should expect 6 trailing zeros.\\n\\nAnd indeed it is the case: 15511210043330985984**000000**\\n\\nHow to get them? Do integer division!\\n\\nFirst `25 // 5 -> 5`. Then `5 // 5 -> 1` (stopping here since `1 // 5 -> 0` so ignoring that). So we would expect 5 + 1 trailing zeros.\\n\\nThe code below is from another post. Purpose of the post was to give the intuition of what\\'s happening below.\\n```python\\ndef trailingZeroes(n: int) -> int:\\n    cnt = 0\\n    while n != 0:\\n        n = n // 5\\n        cnt = cnt + n  # NOT incremented by 1. Incremented by n.\\n    return cnt\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\ndef trailingZeroes(n: int) -> int:\\n    cnt = 0\\n    while n != 0:\\n        n = n // 5\\n        cnt = cnt + n  # NOT incremented by 1. Incremented by n.\\n    return cnt\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 52399,
                "title": "my-python-solution-in-o-1-space-o-logn-time",
                "content": "**Concept:**\\n\\nSince 0 only company with 5*2\\nSo only need to count the volume of 5 factor. (because 2 always enough)\\n\\nSo..\\n100! \\'s  zero has => floor(100/5) + floor(100/25) =  floor(100/5) + floor((100/5)/5) \\n\\n**Code:**\\n\\n    class Solution(object):\\n        def trailingZeroes(self, n):\\n            zeroCnt = 0\\n            while n > 0:\\n                n = n//5; zeroCnt += n\\n            \\n            return zeroCnt",
                "solutionTags": [
                    "Python"
                ],
                "code": "**Concept:**\\n\\nSince 0 only company with 5*2\\nSo only need to count the volume of 5 factor. (because 2 always enough)\\n\\nSo..\\n100! \\'s  zero has => floor(100/5) + floor(100/25) =  floor(100/5) + floor((100/5)/5) \\n\\n**Code:**\\n\\n    class Solution(object):\\n        def trailingZeroes(self, n):\\n            zeroCnt = 0\\n            while n > 0:\\n                n = n//5; zeroCnt += n\\n            \\n            return zeroCnt",
                "codeTag": "Java"
            },
            {
                "id": 817709,
                "title": "solution-using-prime-factorization-with-easy-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int ans=0;\\n        long int i=0;\\n        for(i=5; n/i >=1 ;i*=5){\\n            ans+= n/i;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nA number has trailing zeroes if it is divisible by 10 which has prime factors 2 and 5.\\nLet a number be 95000. \\nHow many trailing zeroes are in this number?   Ans: 3\\nWhat is the highest power of 10 the number is divisible by? Ans: 10^3. So, 3 is the ans.\\nHence, we can say, if an integer is divisible by 10^k, then it has k trailing zeroes.\\n\\nNow let a number be 2^5 * 5^4. Here  2^4 * 5^4 is the highest power of 10 which is 10^4. So, The number has 4 trailing powers.\\nAnother example, 2^3 * 3^1 * 5^4 * 7^2 gives us 2^3 * 5^3 to make the max power of 10 hence 3 trailing zeroes.\\nSo, we can see that the number of trailing zeroes comes from the power of 2 and power of 5, whichever is smaller. Then we also see that total power of 2 is always less than or equal to total power of 5. So, it is absolutely fine if we calculate only power of 5.\\n\\nSo, from the explanation above, let\\'s calculate 30! 30! has 30/5 = 6 multiples of 5 that are less or equal than 30.\\n\\t\\t\\t30! = 30* 25* 20 * 15 * 10 * 5 * k\\nEach term here contributes 5^1 factor except 25 which contributes 5^2 factor (which gives extra 1 trailing zero). So, the number of trailing zeroes in 30! is 7.\\n\\nThus each multiple of 25 will contribute an additional 1 trailing zero.\\nLet\\'s find the number of trailing zeroes in 500!\\n500/5 + 500/25 + 500/125 = 100+20+4 = 124 trailing zeroes (Ans). Here 25 gives extra 4, 125 gives extra 4 trailing zeroes.\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int ans=0;\\n        long int i=0;\\n        for(i=5; n/i >=1 ;i*=5){\\n            ans+= n/i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52428,
                "title": "sharing-my-java-solution-in-1ms-runtime",
                "content": "    public int trailingZeroes(int n) {\\n        int count = 0;\\n \\n        while(n > 0) {\\n            n /= 5;\\n            count += n;\\n        }\\n \\n        return count;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int trailingZeroes(int n) {\\n        int count = 0;\\n \\n        while(n > 0) {\\n            n /= 5;\\n            count += n;\\n        }\\n \\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 52432,
                "title": "3-lines-of-java-o-logn-time-o-1-space",
                "content": "    public class Solution {\\n        public int trailingZeroes(int n) {\\n            int s = 0;\\n            while (n>4) s += (n/=5);\\n            return s;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int trailingZeroes(int n) {\\n            int s = 0;\\n            while (n>4) s += (n/=5);\\n            return s;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 52480,
                "title": "share-my-3ms-solution-in-c",
                "content": "int trailingZeroes(int n) {\\n    int res = 0;\\n\\n    do\\n    {\\n        res += n/5;\\n    }while(n /= 5);\\n    \\n    return res;\\n}",
                "solutionTags": [],
                "code": "int trailingZeroes(int n) {\\n    int res = 0;\\n\\n    do\\n    {\\n        res += n/5;\\n    }while(n /= 5);\\n    \\n    return res;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2835993,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int res=0;\\n        while(n){\\n            n/=5;\\n            res+=n;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int res=0;\\n        while(n){\\n            n/=5;\\n            res+=n;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52472,
                "title": "one-liners-in-c-java-python-ruby-c-c",
                "content": "All of these got accepted, but some **might** be unsafe in general because of evaluation order. I didn't check the specifications.\\n\\n    Ruby          (1..13).map{|e| n/5**e}.reduce(:+)\\n                  z=0; (1..13).each{|e| z+=n/5**e}; z\\n                  n > 0 ? trailing_zeroes(n/=5) + n : 0              Maybe unsafe\\n                  n > 0 ? n/5 + trailing_zeroes(n/5) : 0\\n                  (n/=5) > 0 ? n + trailing_zeroes(n) : 0\\n                  n > 0 ? (n/=5) + trailing_zeroes(n) : 0            Maybe unsafe\\n\\n    Python        return sum(n/5**e for e in range(1,14))\\n                  return n and n/5 + self.trailingZeroes(n/5)\\n\\n    C++ and C     int z=0; while(n) z+=n/=5; return z;\\n                  return n ? n + trailingZeroes(n/=5) : 0;           Maybe unsafe\\n                  return n ? n/5 + trailingZeroes(n/5) : 0;\\n                  return (n/=5) ? n + trailingZeroes(n) : 0;\\n                  return n ? (n/=5) + trailingZeroes(n) : 0;         Maybe unsafe\\n\\n    Java and C\\u266f   int z=0; while(n>0) z+=n/=5; return z;\\n                  return n > 0 ? trailingZeroes(n/=5) + n : 0;       Maybe unsafe\\n                  return n > 0 ? n/5 + trailingZeroes(n/5) : 0;\\n                  return (n/=5) > 0 ? n + trailingZeroes(n) : 0;\\n                  return n > 0 ? (n/=5) + trailingZeroes(n) : 0;     Maybe unsafe\\n\\nI didn't write JavaScript solutions because of the absence of integer division and because I don't know it well. And they'd probably look like ugly versions of the Java or C++ solutions anyway.",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Ruby"
                ],
                "code": "All of these got accepted, but some **might** be unsafe in general because of evaluation order. I didn't check the specifications.\\n\\n    Ruby          (1..13).map{|e| n/5**e}.reduce(:+)\\n                  z=0; (1..13).each{|e| z+=n/5**e}; z\\n                  n > 0 ? trailing_zeroes(n/=5) + n : 0              Maybe unsafe\\n                  n > 0 ? n/5 + trailing_zeroes(n/5) : 0\\n                  (n/=5) > 0 ? n + trailing_zeroes(n) : 0\\n                  n > 0 ? (n/=5) + trailing_zeroes(n) : 0            Maybe unsafe\\n\\n    Python        return sum(n/5**e for e in range(1,14))\\n                  return n and n/5 + self.trailingZeroes(n/5)\\n\\n    C++ and C     int z=0; while(n) z+=n/=5; return z;\\n                  return n ? n + trailingZeroes(n/=5) : 0;           Maybe unsafe\\n                  return n ? n/5 + trailingZeroes(n/5) : 0;\\n                  return (n/=5) ? n + trailingZeroes(n) : 0;\\n                  return n ? (n/=5) + trailingZeroes(n) : 0;         Maybe unsafe\\n\\n    Java and C\\u266f   int z=0; while(n>0) z+=n/=5; return z;\\n                  return n > 0 ? trailingZeroes(n/=5) + n : 0;       Maybe unsafe\\n                  return n > 0 ? n/5 + trailingZeroes(n/5) : 0;\\n                  return (n/=5) > 0 ? n + trailingZeroes(n) : 0;\\n                  return n > 0 ? (n/=5) + trailingZeroes(n) : 0;     Maybe unsafe\\n\\nI didn't write JavaScript solutions because of the absence of integer division and because I don't know it well. And they'd probably look like ugly versions of the Java or C++ solutions anyway.",
                "codeTag": "Unknown"
            },
            {
                "id": 52490,
                "title": "c-3-lines-implementation",
                "content": "class Solution {\\n\\npublic:\\n\\n    int trailingZeroes(int n) {\\n\\n        int sum=0;\\n\\n        for (int i = n/5; i>0; i/=5) sum += i;\\n\\n        return sum;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n\\npublic:\\n\\n    int trailingZeroes(int n) {\\n\\n        int sum=0;\\n\\n        for (int i = n/5; i>0; i/=5) sum += i;\\n\\n        return sum;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 52497,
                "title": "python-one-liner",
                "content": "    def trailingZeroes(self, n):\\n        return 0 if n < 5 else n/5 + self.trailingZeroes(n/5)",
                "solutionTags": [],
                "code": "    def trailingZeroes(self, n):\\n        return 0 if n < 5 else n/5 + self.trailingZeroes(n/5)",
                "codeTag": "Python3"
            },
            {
                "id": 1152167,
                "title": "python3-o-log-n-time-o-1-space-explanation",
                "content": "To help this intution stick let\\'s work with an example, say 60! I can tell you that 60! has 14 trailing zeros.\\n\\nLet\\'s begin by understanding how a trailing zero is created. The simplest way to create a trailing zero is to multiply a given number by 10. Now, every number has at least two factors, namely itself and 1, however these are the trivial factors that every number has. Excluding these trivial factors 10 can be factored as 2 x 5. We can therefore deduce that the number of trailing zeros will be dictated by the smaller of the count of factor 2 and the count of factor 5 in 60!\\n\\n60! can be divided by 2, 52 times and divided by 5, 14 times. As multiples of 2 occur more frequently than multiples of 5 in the natural numbers, the number of trailing zeros will be dictated by the number of times 60! can be divided by 5.\\n\\nWhich of the natural numbers up to 60 have at least one factor of 5?\\nThere are 12, (5, 10, 15, 20, 35, 30, 35, 40, 45, 50, 55, 60), which can be found by 60 / 5\\n\\nSo we\\'ve found the number of natural numbers up to 60 that have at least a factor of 5 but you may notice that 25 and 50 can be factored as 5x5 and 5x5x2 and so we\\'ll have to account for the fact that there are some numbers that will have more than one factor of 5.\\n\\n60 // 5 + 60 // 25 = 12 + 2 which gives us our answer.\\n\\nTo find the general solution to this problem we can factor our previous equation as follows:\\nquotient = 60 // 5\\nans = quotient + quotient // 5\\n\\nThis can be applied in a recursive way to account for increasingly many numbers with increasing factors of 5.\\n\\n```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        quotient = n // 5\\n        return quotient + self.trailingZeroes(quotient) if quotient >= 5 else quotient\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        quotient = n // 5\\n        return quotient + self.trailingZeroes(quotient) if quotient >= 5 else quotient\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52440,
                "title": "1ms-1-line-java-solution",
                "content": "Another way to deal \\n    \\n    public int trailingZeroes(int n) {\\n        return n>=5 ? n/5 + trailingZeroes(n/5): 0;\\n    }",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Recursion"
                ],
                "code": "Another way to deal \\n    \\n    public int trailingZeroes(int n) {\\n        return n>=5 ? n/5 + trailingZeroes(n/5): 0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1151659,
                "title": "c-from-worst-to-best-all-solutions-with-expalanation-comments",
                "content": "**First Approach**\\nMany of us probably though in order to find trailing zeros in factorial number first we need to generate 10\\'s to get some zeros. To generate 10\\'s we need to find 5\\'s and 2\\'s because\\n`10 = 2 x 5` meaning that we only need to find all 2 and 5 pairs together, other numbers because don\\'t help generating 10\\'s. Besides, we will have enough (at least as many as 5\\'s) 2\\'s because of even numbers so we don\\'t need to worry about number of 2\\'s. That\\'s why we will focus on the number of 5\\'s which will lead us towards the result.\\n\\nSee this example;\\n5! = **5**.4.3.**2**.1 -> **(5.2)**.4.3.1 ->**(10)**.4.3.1\\nHere the numbers that gives us 10 are only 2 and 5.\\n\\nSecondly, in some numbers like 25, 125, we may have many 5\\'s we should also take care this.\\n\\n**O(N) Solution**\\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int count = 0;\\n        // Since we have enought 2\\'s because of even numbers\\n        // It is enough to count only 5\\'s\\n        for (int i = 1; i <= n; i++) {\\n            if (i % 5 == 0) {\\n                // Check for power of 5\\n                int pow5 = i;\\n                while ((pow5 % 5) == 0) {\\n                    pow5 /= 5;\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n\\n**Optimization**\\nNow, since we proved that we just need to count 5\\'s only in the above section, Why would not we just count how many 5\\'s we have directly right? So we just got rid of the for loop where we incremented i one by one in linear time. Instead, we will use `/` operator which will give us logarithmic time.\\n\\n**O(logn) Solution**\\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int count = 0;\\n        while (n > 0) {\\n            count += n / 5;\\n            n /= 5;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int count = 0;\\n        // Since we have enought 2\\'s because of even numbers\\n        // It is enough to count only 5\\'s\\n        for (int i = 1; i <= n; i++) {\\n            if (i % 5 == 0) {\\n                // Check for power of 5\\n                int pow5 = i;\\n                while ((pow5 % 5) == 0) {\\n                    pow5 /= 5;\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int count = 0;\\n        while (n > 0) {\\n            count += n / 5;\\n            n /= 5;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 223702,
                "title": "java-solutions",
                "content": "- The **brute-force algorithm** is to count trailing zeros is first find factorial of number and then count the zeros in the factorial one by one. It is fine for smaller number like `10`. Since `10! = 3628800` and so, trailing zeros = `2`. But what about big numbers like `100`. The factorial of `100` has `24` zeros in the end and almost `160` digits. Its really hard to store that big number and then count the zeros one by one.\\n- The **better idea** is to count the number of `5` factors in all numbers from `1` to `n`. Since all trailing `0` is from factors `2 * 5`. In `n!` operation, factors `2` will always be more than factors `5`. So we just count the number of 5 factors in all numbers from `1` to `n`.\\n\\n**Example 1:**\\n- There are four multiples of `5` between `1` and `23`. i.e. `5, 10, 15, and 20`,  So `23!` has `4` zeros.\\n\\n**Example 2:**\\n- There are `20` multiples of `5` from `1` to `100`, since `100 / 5 = 20`. But actually `25` is `5 * 5`, so each multiple of `25` has an extra factor of `5` which should also be counted. Since `100 / 25 = 4`, there are four multiples of `25` between `1` and `100`. Finally, we get `20 + 4 = 24` trailing zeros in `100!`. Therefore, we need care about `5` powers as well, to consider additional `5` factors.\\n\\n- So it can be computed as:\\n`count = (n / 5) + (n / 25) + (n / 125) + ... + 0`. Iteration will be terminated when `5^k` becomes greater than `n`.\\n\\n**Solution 1: Iterative**\\n\\nTime complexity: `O(log n)`\\nSpace complexity: `O(1)`\\n\\n```\\nclass Solution \\n{\\n    public int trailingZeroes(int n) \\n    {\\n        int count = 0;\\n        \\n        while(n >= 5)\\n            count += (n /= 5);\\n        \\n        return count;\\n    }\\n}\\n```\\n\\n**OR**\\n\\n```\\nclass Solution \\n{\\n    public int trailingZeroes(int n) \\n    {\\n        int count = 0;\\n        \\n        for(long i = 5; n / i > 0; i *= 5)\\n            count += (n / i);\\n        \\n        return count;\\n    }\\n}\\n```\\n\\n**Solution 2: Recursive**\\n\\nTime complexity: `O(log n)`\\nSpace complexity: `O(log n)` - space required for the recursive function call stack.\\n\\n```\\nclass Solution \\n{\\n    public int trailingZeroes(int n) \\n    {\\n        if(n < 5)\\n\\t\\t\\treturn 0;\\n\\t\\telse\\n\\t\\t\\treturn (n / 5) + trailingZeroes(n / 5);\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public int trailingZeroes(int n) \\n    {\\n        int count = 0;\\n        \\n        while(n >= 5)\\n            count += (n /= 5);\\n        \\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution \\n{\\n    public int trailingZeroes(int n) \\n    {\\n        int count = 0;\\n        \\n        for(long i = 5; n / i > 0; i *= 5)\\n            count += (n / i);\\n        \\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution \\n{\\n    public int trailingZeroes(int n) \\n    {\\n        if(n < 5)\\n\\t\\t\\treturn 0;\\n\\t\\telse\\n\\t\\t\\treturn (n / 5) + trailingZeroes(n / 5);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52474,
                "title": "4ms-c-solution-and-short-explanation",
                "content": "There are lots of explanations of this online. Briefly, pairs of factors of 2 and 5 in the prime factorization of n! generate trailing zeros. So for every 5 in the prime factorization, we can pair it with a 2 to generate a trailing zero. There are more than enough 2s to go around, the limiting \"factor\" is the 5s. Clearly there are at least n / 5 factors of 5 in n!. But in addition to being divisible by 5, n! may be divisible by 5^2, 5^3 and so on, which introduce more factors of 5 that pair up with factors of 2 to get more trailing zeros. So at each step of the algorithm we just divide by 5 and add the quotient to our total zero count, until the number isn't divisible by a power of 5. \\n\\n    class Solution {\\n    public:\\n        int trailingZeroes(int n) {\\n            int zeros = 0;\\n            while (n) {\\n                zeros += n / 5;\\n                n /= 5;\\n            }\\n            return zeros;   \\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int trailingZeroes(int n) {\\n            int zeros = 0;\\n            while (n) {\\n                zeros += n / 5;\\n                n /= 5;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 52460,
                "title": "a-4ms-c-solution-using-method-in-wikipedia",
                "content": "    class Solution {\\n    public:\\n        int trailingZeroes(int n) {\\n            int count = 0;\\n            while(n /= 5) count += n;\\n            return count;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int trailingZeroes(int n) {\\n            int count = 0;\\n            while(n /= 5) count += n;\\n            return count;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3579829,
                "title": "100-faster-c-solution-o-log-n-time-complexity-with-easy-explanation",
                "content": "# Observation\\nIf you read the question carefully, you will find a follow-up section below sample testcases which gives a hint on how to approach this problem.\\nIf you analyse the problem properly and check the expected output for the input number, you will observe a pattern that the answer increases by 1 at an interval of 5. Also for larger inputs their actual answer is slightly above the quotient of number divided by 5.\\nThis is where the follow up helps. \\n```\\nInput/Output\\n100 -> 24 (100/5 = 20, then 20/5 = 4; 20+4)\\n10 -> 2 (10/2 = 2, then 2/5 = 0; 2+0)\\n24 -> 4 (24/5 = 4, then 4/5 = 0; 4+0)\\n25 -> 6 (25/5 = 5, then 5/5 = 1; 5+1)\\n200 -> 49 (200/5 = 40, 40/5 = 8, 8/5 = 1; 40+8+1)\\n```\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInitialize the variable ans with 0.\\nIterate over input n until n>0.\\nInside the loop, increase ans with the value of \"n/5\". And the, modify n such that now n is equal to n/5.\\nReturn the answer (ans).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(log n) ; base = 5\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int ans = 0;\\n        while (n>0){\\n            ans += n/5;\\n            n = n/5;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nInput/Output\\n100 -> 24 (100/5 = 20, then 20/5 = 4; 20+4)\\n10 -> 2 (10/2 = 2, then 2/5 = 0; 2+0)\\n24 -> 4 (24/5 = 4, then 4/5 = 0; 4+0)\\n25 -> 6 (25/5 = 5, then 5/5 = 1; 5+1)\\n200 -> 49 (200/5 = 40, 40/5 = 8, 8/5 = 1; 40+8+1)\\n```\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int ans = 0;\\n        while (n>0){\\n            ans += n/5;\\n            n = n/5;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3136108,
                "title": "easy-one-line-solution-and-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDetermine how 0 will be formed\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nzero can be formed by combination of (5,2) count the number of 5 in given n! basically do n/5 will give the number of 5 but there is a catch 25 has (5,5) that means we have to calculate it one more time\\nfor that just divide the n in multiple of 5(5,25,125,625,3125) for 2,3,4 digits number\\n# Complexity\\n- Time complexity: o(1) 0ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        return n/5+n/25+n/125+n/625+n/3125;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        return n/5+n/25+n/125+n/625+n/3125;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 971559,
                "title": "java-o-log-n-solution-with-detailed-explanation-0ms",
                "content": "Explanation:\\n\\nTo get a 0 at trail, there should be a pair of 2 and 5 in factors below n. We can observe that number of 2s as a factor is always greater than or equal to number of 5s as a factor.  This means, number of pair of 2 and 5 really depends on number of 5s as a factor and thus all computation depends on 5 and not 2.\\n\\nWe basically have to count how many 5s as a factor, are there below the given number. For numbers < 25, We can find out how many 5s are there by simple doing n/5. For 25 (5^2)  number of 0s are: 25/ 5 = 5 + 1. This one is added because 25 has 2 fives and not just one. Thus, an extra pair of 5 and 2 leading to an extra 0. This explanation continues for all the exponentiation of 5 lesser than the number itself. \\n\\nCode:\\n\\n```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n    \\n        int sol = 0;\\n        int expOfFive = 5;\\n        while(n >= expOfFive){\\n            sol += n / expOfFive;\\n            expOfFive = 5 * expOfFive;\\n        }\\n        return sol;\\n        \\n    }\\n}\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int trailingZeroes(int n) {\\n    \\n        int sol = 0;\\n        int expOfFive = 5;\\n        while(n >= expOfFive){\\n            sol += n / expOfFive;\\n            expOfFive = 5 * expOfFive;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 778503,
                "title": "python-3-3-levels-of-implementation-with-explanation-for-each",
                "content": "Someone\\'s first attempt might look something like this:\\n```\\n        fact = math.factorial(n) #use the math class to calculate the factorial\\n\\n        string = [i for i in str(fact)] #Turn the into a string list\\n        \\n        string.reverse() #reverse it so all 0\\'s are in front\\n        count = 0\\n        \\n        #continue counting up until you hit a number that is not 0, then return the counter\\n        for number in string:\\n            if number != \\'0\\':\\n                return count\\n            count += 1\\n```\\n\\nHowever, you will notice that this method only works for values of \\'n\\' that are relatively small. In order to  account for any value of \\'n\\' we need to look into how trailing 0\\'s occur within factorials.\\n\\nLet\\'s take a look at a few factorial results:\\n\\n4! = 1 * 2 * 3 * 4 = 24\\n5! = 24 * 5 = 120\\n6! = 120 * 6 = 720\\n7! = 720 * 7 = 4320\\n8! = 4320 * 8 = 34,560\\n9! = 34560 * 9 = 311,040\\n10! = 311,040 * 10 = 3,110,400\\n\\nAs you can see, the number of trailing 0\\'s is equal to the number of times the given n can be divided by 5, or to put it more bluntly:\\n\\n4/5 = 0 -> 0 trailing 0\\'s\\n5/5 = 1 -> 1 trailing 0\\n9/5 = 1 -> 1 trailing 0\\n10/5 = 2 -> 2 trailing 0\\'s.\\n\\nWith this in mind, we can count the number of trailing 0\\'s by counting how many times 5 can go into n\\n\\nHowever, we also need to consider the case in which \\'n\\' is very large. For example, if n = 200, our logic would look like this: 200/5 = 40. So 40 trailing 0\\'s right? Well, we also have to consider that 40 is *also* a multiple of 5, so we need to continue dividing by 5 until we reach a number below 5. So the full logic should be:\\n\\n200/5 = 40 -> 40 trailing 0\\'s\\n40/5 = 8 -> 48 trailing 0\\'s\\n8/5 = 1 -> 49 trailing 0\\'s\\n\\nWith this logic in hand, we can create a while loop that implements our method\\n```\\n\\t\\tcount = 0\\n\\t\\t\\n        if n < 5:\\n            return 0\\n        \\n        while n >= 5 :\\n            count += int(n/5) \\n            n = int(n/5) \\n\\n        return count\\n```\\n\\nFinally, you will notice that we have all the elements we need to implement this solution recursively:\\n```\\n        if n < 5: #base case\\n            return 0\\n        else: #add the current factor of 5 to the next smallest factor of n/5\\n            return int(n/5) + self.trailingZeroes(int(n/5))\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\n        fact = math.factorial(n) #use the math class to calculate the factorial\\n\\n        string = [i for i in str(fact)] #Turn the into a string list\\n        \\n        string.reverse() #reverse it so all 0\\'s are in front\\n        count = 0\\n        \\n        #continue counting up until you hit a number that is not 0, then return the counter\\n        for number in string:\\n            if number != \\'0\\':\\n                return count\\n            count += 1\\n```\n```\\n\\t\\tcount = 0\\n\\t\\t\\n        if n < 5:\\n            return 0\\n        \\n        while n >= 5 :\\n            count += int(n/5) \\n            n = int(n/5) \\n\\n        return count\\n```\n```\\n        if n < 5: #base case\\n            return 0\\n        else: #add the current factor of 5 to the next smallest factor of n/5\\n            return int(n/5) + self.trailingZeroes(int(n/5))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52485,
                "title": "2-lines-java-solution-any-better-code",
                "content": "    public int trailingZeroes(int n) {\\n        if(n < 5) return 0;\\n        else return n/5 + trailingZeroes(n/5);\\n    }",
                "solutionTags": [],
                "code": "    public int trailingZeroes(int n) {\\n        if(n < 5) return 0;\\n        else return n/5 + trailingZeroes(n/5);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1377295,
                "title": "c-100-faster-easy-to-understand-2-methods",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n\\n**Method 1**\\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) \\n    {\\n        int count5=0,num;\\n        for(int i=5;i<=n;i+=5)\\n        {\\n           num=i;\\n           while(num%5==0)\\n           {\\n               count5++;\\n               num/=5;\\n           } \\n        }   \\n        return count5;\\n    } \\n};\\n```\\n**Method 2(100% faster):**\\nlogic: https://www.purplemath.com/modules/factzero.htm\\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) \\n    {\\n        int count=0;\\n        while(n/5>=1)\\n        {\\n          count+=(n/5);\\n          n=n/5;  \\n        }    \\n        return count;\\n    } \\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) \\n    {\\n        int count5=0,num;\\n        for(int i=5;i<=n;i+=5)\\n        {\\n           num=i;\\n           while(num%5==0)\\n           {\\n               count5++;\\n               num/=5;\\n           } \\n        }   \\n        return count5;\\n    } \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) \\n    {\\n        int count=0;\\n        while(n/5>=1)\\n        {\\n          count+=(n/5);\\n          n=n/5;  \\n        }    \\n        return count;\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855400,
                "title": "java-solution-explanation-thought-process",
                "content": "**TL;DR**\\nThis took me a while to figure out, I suggest watching this [K5 video](https://www.youtube.com/watch?v=GokjSyb-Z_c) explaining the theory behind this approach.\\n\\n**Base Case** - `21! = 51,090,942,171,709,440,000`\\n\\n**Explanation**\\nIf a number has trailing zeros it is divisible by `10` without a remainder (i.e. `n % 10 == 0`) - therefore if `n` has trailing zeros then `10` will be a factor of `n`. \\n\\nThe theoretical brute-force solution is to divide the factorial by `10` until no zeros remain while maintaining a count. Consider the base case above - notice that the factorial of `21` is greater than both `Integer.MAX_VALUE` and `Long.MAX_VALUE`, therefore you will need to use a `BigInteger` to get around this issue.\\n\\n```\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n\\t\\n        BigInteger factorial = BigInteger.ONE; // factors start with 1\\n        for (int i = 2; i <= n; i++) // start computing from 2 onwards\\n            factorial = factorial.multiply(BigInteger.valueOf(i));\\n        \\n        int count = 0;\\n\\t\\t// remember, you can\\'t use normal arithmetic operators with BigInteger\\n        while (factorial.mod(BigInteger.TEN) == BigInteger.ZERO) {\\n            factorial = factorial.divide(BigInteger.TEN);\\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```\\n\\nHowever, when I tried to submit the above code as my solution the execution time limit exceeded when trying to compute the factorials of large numbers like `9000`. Back to the drawing board - we need an approach which can be executed within the given time limit - and preferably with a single loop.\\n\\nLet\\'s consider the base case again - instead of computing the factorial and dividing it by `10`, we can consider it\\'s building blocks i.e. the preceding numbers themselves.\\n\\n`21! = 1 x 2 x 3 x 4 x 5 x 6 x 7 x 8 x 9 x 10 x 11 x 12 x 13 x 14 x 15 x 16 x 17 x 18 x 19 x 20 x 21`\\n\\nThe only elements divisible by `10` without a remainder are `10` and `20` - however we know for a fact that `21!` has `4` trailing zeros, so we need to dig deeper, so let\\'s consider the factors of `10` and `20`.\\n\\n`10 = 2 x 5`\\n`20 = 2 x 10 = 2 x 2 x 5` \\n\\nBoth `10` and `20` are in turn divisible by `2` and `5` without a remainder (i.e. `10 % 2 = 0`, `10 % 5 = 0`, `20 % 2 = 0`, `20 % 5 = 0`) since both `2` and `5` are factors of `10` which is in turn a factor of `20`. Let\\'s consider the occurrence of the common factors of both `10` and `20` (i.e. `2` and `5`) in our base case.\\n\\nBase Case - `21! = 1 x 2 x 3 x 4 x 5 x 6 x 7 x 8 x 9 x 10 x 11 x 12 x 13 x 14 x 15 x 16 x 17 x 18 x 19 x 20 x 21`\\nCommon Factors - `21! = 1 x 2 x 3 x (2 x 2) x 5 x (2 x 3) x 7 x (2 x 2 x 2) x 9 x (5 x 2) x 11 x (3 x 2 x 2) x 13 x (7 x 2) x (5 x 3) x (2 x 2 x 2 x 2) x 17 x (2 x 9) x 19 x (5 x 2 x 2) x (7 x 3)`\\n\\nAfter we break down the elements themselves with the common factors of `10` we can see that `2` occurs `17` times while `5` occurs only  `4` times. The reason why `2` occurs more than `5` is because it is the smallest common factor of every even number, causing it to repeat one or more times in every even number of the base cases\\'s sequence - however `5` is the only odd prime factor of `10` guaranteeing it to occur only in multiples of `5` in any sequence.\\n\\nAn efficient way to identify the occurences of `5` as a multiplier in the preceding numbers of the sequence is by dividing `n` by `5` and then dividing it\\'s result by `5` again until you get a result smaller than `5`  (watch video linked above). The addition of these results will be the occurence of zeros in the factorial of `n`.\\n\\n![image](https://assets.leetcode.com/users/images/88b8f91b-1d88-4e64-bd26-085aa5096eeb_1600581164.411297.png)\\n\\nIn the above examples `21!`, `75!` and `100!` will have `4`, `18` and `31` trailing zeros respectively. The coded solution would look like the following.\\n\\n```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        int result = 0;\\n        while (n >= 5) { // stop dividing when you get a result less than 5\\n            result += n/5; // add the result of n/5 to the counter - since we\\'re using integers we don\\'t need to worry about decimals\\n            n = n/5; // replace n with n/5 so that we can divide it by 5 in the next iteration\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\nCheers!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n\\t\\n        BigInteger factorial = BigInteger.ONE; // factors start with 1\\n        for (int i = 2; i <= n; i++) // start computing from 2 onwards\\n            factorial = factorial.multiply(BigInteger.valueOf(i));\\n        \\n        int count = 0;\\n\\t\\t// remember, you can\\'t use normal arithmetic operators with BigInteger\\n        while (factorial.mod(BigInteger.TEN) == BigInteger.ZERO) {\\n            factorial = factorial.divide(BigInteger.TEN);\\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        int result = 0;\\n        while (n >= 5) { // stop dividing when you get a result less than 5\\n            result += n/5; // add the result of n/5 to the counter - since we\\'re using integers we don\\'t need to worry about decimals\\n            n = n/5; // replace n with n/5 so that we can divide it by 5 in the next iteration\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52452,
                "title": "my-java-solution-2m",
                "content": "    public class Solution {\\n    public int trailingZeroes(int n) {\\n        if(n < 5) return 0;\\n        return n / 5 + trailingZeroes(n / 5);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int trailingZeroes(int n) {\\n        if(n < 5) return 0;\\n        return n / 5 + trailingZeroes(n / 5);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 52461,
                "title": "my-0ms-c-solution",
                "content": "` \\n int trailingZeroes(int n) {\\n\\n    if (n == 0)\\n        return 0;\\n    return n/5 + trailingZeroes(n/5);\\n}\\n`",
                "solutionTags": [],
                "code": "` \\n int trailingZeroes(int n) {\\n\\n    if (n == 0)\\n        return 0;\\n    return n/5 + trailingZeroes(n/5);\\n}\\n`",
                "codeTag": "Unknown"
            },
            {
                "id": 3583732,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor getting no. of zeros we must se how many times the number is multiplied by 10. In order to check that. I checked how many faactors of 5 are present in n!.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs to check for multiple of 10 the number must be multiple of 2 and 5. Here multiples of 2 will be more than multiples of 5 so I checked for multiple of 5.\\n\\n# Complexity\\n- Time complexity: O(log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        if(n==0 || n==1){\\n            return 0;\\n        }\\n        int n5=0;\\n        while(n>=5){\\n            n/=5;\\n            n5+=n;\\n        }\\n        return n5;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        if(n==0 || n==1){\\n            return 0;\\n        }\\n        int n5=0;\\n        while(n>=5){\\n            n/=5;\\n            n5+=n;\\n        }\\n        return n5;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3212798,
                "title": "172-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTo compute the number of trailing zeroes in n!, we need to count the number of factors of 10 in n!. Notice that 10 can only be formed by multiplying 2 and 5, and we can always find more factors of 2 than factors of 5 in n!. Therefore, it suffices to count the number of factors of 5 in n! to determine the number of trailing zeroes.\\n\\nLet count = 0 be the variable that keeps track of the number of factors of 5. We can count the factors of 5 in n! by computing n/5 + n/25 + n/125 + ... until the quotient becomes 0. Each term in the sum corresponds to the number of multiples of 5, 25, 125, ..., that are less than or equal to n.\\n\\nThe final value of count will be the number of trailing zeroes in n!.\\n# Complexity\\n- Time complexity:\\nO(log n) - we keep dividing n by 5 in each iteration until n becomes 0.\\n\\n- Space complexity:\\nO(1) - we only use a constant amount of extra space to store the variable count.\\n\\n# Code\\n```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        count = 0\\n        while n > 0:\\n            count += n // 5\\n            n //= 5\\n        return count\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        count = 0\\n        while n > 0:\\n            count += n // 5\\n            n //= 5\\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1516201,
                "title": "factorial-trailing-zeroes-mathematical-o-logn-o-1-time",
                "content": "**Idea**: A trailing 0 will be formed only if a number has both 2 and 5 as prime factors. \\nIf there are x number of 2 and y number of 5 then number of trailing zeros is `min(x,y)`\\n\\n**Observation**: Practically `count of 2 >= count of 5` always. So we just need to find count of 5.\\n\\n**How to count 5**: Since we are finding factorial of n, so we need to count the number of 5 in `1, 2 ,3 ,...,n`. We can observe that after every five numbers a 5 occurs:\\n1, 2, 3, 4, **5 (5x1)**\\n6, 7, 8, 9, **10 (5x2)**\\n11, 12, 13, 14, **15 (5x3)**\\n16, 17, 18, 19, **20 (5x2x2)**\\nBut numbers like 25, 125 (i.e 5^k) there will be extra 5s\\n25 (5x5)\\n125 (5x5x5)\\n...\\n\\nSo we need to count amount of numbers divisible by- \\n5 -> Containing one 5,\\n25 -> Containing two 5,\\n125 -> Containing three 5 ...\\n```python\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        count = 0\\n        i = 1\\n        while True:\\n            cur_div = n//(5**i)\\n            if cur_div == 0:\\n                break\\n            count += cur_div\\n            i += 1\\n        return count\\n```\\n\\nBut we can further improve the solution!\\nInstead of counting amount of numbers divisible by 5, 25, 125, 625...\\nWe can just reduce our `n` to `n//5` after each iteration and just count amount of numbers divisible by 5 at each iteration\\n```python\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        count = 0\\n        while n >= 5:\\n            n //= 5\\n            count += n\\n        return count\\n```\\n\\nTime Complexity: O(log5(n))\\nSpace complexity: O(1)\\n\\n# **BUT....**\\nOur constraints say that `0 <= n <= 10000`\\n So we can do it in **O(1) time** \\uD83D\\uDE43\\n Because we know that only power of 5 that lies in [0, 10000] are: 5, 25, 125, 625, 3125:\\n ```python\\n class Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        return n//5 + n//25 + n//125 + n//625 + n//3125\\n ```\\n \\n Bonus: One liner using [Walrus operator](https://docs.python.org/3/whatsnew/3.8.html#assignment-expressions)\\n```python\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        return sum([n:=n//5 for i in range(5)])\\n```\\n\\nHope it helps :)",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```python\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        count = 0\\n        i = 1\\n        while True:\\n            cur_div = n//(5**i)\\n            if cur_div == 0:\\n                break\\n            count += cur_div\\n            i += 1\\n        return count\\n```\n```python\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        count = 0\\n        while n >= 5:\\n            n //= 5\\n            count += n\\n        return count\\n```\n```python\\n class Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        return n//5 + n//25 + n//125 + n//625 + n//3125\\n ```\n```python\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        return sum([n:=n//5 for i in range(5)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1324416,
                "title": "c-3-sols-beginner-friendly-well-explained",
                "content": "**Approah 1 :**\\nJust count the total power of 2 and 5 from n to 1  and return the minimum of it as 10 is made only by 2 and 5.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void count(int n, int &c2, int &c5){\\n        for(int i=n; i>0 && i%2==0; i/=2) c2++;\\n        for(int i=n; i>0 && i%5==0; i/=5) c5++;\\n    }\\n    \\n    int trailingZeroes(int n) {\\n        int m, c2=0, c5=0;\\n        for(int i=2; i<=n;i++){\\n            count(i,c2,c5);\\n        }\\n        return min(c2,c5);\\n    }\\n};\\n```\\n**Appraoch 2:**\\nWe don\\'t need to calculate power of 2 as we are returning min(c2,c5) and in every case 2\\'s power would be less than or equal to 5\\'s power\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void count(int n, int &c5){\\n        for(int i=n; i>0 && i%5==0; i/=5) c5++;\\n    }\\n    \\n    int trailingZeroes(int n) {\\n        int c5=0;\\n        for(int i=2; i<=n;i++){\\n            count(i, c5);\\n        }\\n        return c5;\\n    }\\n};\\n```\\n**Approach 3:**\\nBoth above approach are of type O(NlogN)... so here is the O(logN) sol. Just an another way of calculating total power of 5\\n\\nBasic Maths: Total power of a number(say a) in the range [n , n/a) is = n/a;\\nex:-\\nfor n=10;\\nthen from 10 to 2 (10/5) total power of 5 is 2 (10/5).\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int trailingZeroes(int n) {\\n        int c5=0;\\n        for(n=n/5; n>0;n/=5) c5 +=n;\\n        return c5;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void count(int n, int &c2, int &c5){\\n        for(int i=n; i>0 && i%2==0; i/=2) c2++;\\n        for(int i=n; i>0 && i%5==0; i/=5) c5++;\\n    }\\n    \\n    int trailingZeroes(int n) {\\n        int m, c2=0, c5=0;\\n        for(int i=2; i<=n;i++){\\n            count(i,c2,c5);\\n        }\\n        return min(c2,c5);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    void count(int n, int &c5){\\n        for(int i=n; i>0 && i%5==0; i/=5) c5++;\\n    }\\n    \\n    int trailingZeroes(int n) {\\n        int c5=0;\\n        for(int i=2; i<=n;i++){\\n            count(i, c5);\\n        }\\n        return c5;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 517279,
                "title": "one-line-solution",
                "content": "TrailingZeroes is basically counting the number of factor 10.\\n10 = 2 times 5\\nBecause n is factorial, there are definitely much more 2 than 5. So we only need to count the number of 5 in given factorial n.\\nn = 5 -> 5 * 4 * 3 * 2 * 1 count = 5/5 + 0 = 1\\nn = 10 -> 10 * 9 * 8 * 7 * 6 * 5* 4 * 3 * 2 * 1. count = 10/5 + 0 = 2\\nn = 50 count = 50/5 + trailingZeroes(10) = 10 + 2 = 12\\n50(two fives) 45 40 35 30 25(two fives) 20 15 10 5 -> 12 fives\\nn = 100 count = 100/5 + trailingZeroes(20) = 20 + 4 = 24\\n```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        return n == 0 ? 0 : n/5 + trailingZeroes(n/5);        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        return n == 0 ? 0 : n/5 + trailingZeroes(n/5);        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2452895,
                "title": "very-easy-100-fully-explained-java-c-python-js-c-python3",
                "content": "# **Java Solution:**\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Factorial Trailing Zeroes.\\n\\n```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        // Negative Number Edge Case...\\n        if (n < 0)\\n\\t\\t    return -1;\\n        // Initialize the output result i.e., the number of trailing zeroes...\\n\\t    int output = 0;\\n        // Count number of 5s in prime factors of n!\\n\\t    for (long idx = 5; n/idx >= 1; idx *= 5) {\\n\\t\\t    output += n/idx;\\n\\t    }\\n        // Return the number of trailing zeroes...\\n        return output;\\n    }\\n}\\n/**\\n**The following example helps you to understand the code...**\\nLet, n = 25\\nInitialize the output as 0...\\n\\nAfter first pass,\\n\\t\\t\\t\\tloop for idx = 5; n / idx >= 1\\n\\t\\t\\t\\t25 / 5 >= 1 or, 5 >= 1... It\\'s true...\\n\\t\\t\\t\\toutput = output + n / idx  =  0 + 25/5  =  0 + 5  =  5\\n\\t\\t\\t\\tand, idx *= 5  i.e.,  idx = 5 * 5  =  25\\n\\nAfter second pass,\\n\\t\\t\\t\\tn / idx >= 1  or,  25 / 25 >= 1  or,  1 >= 1... It\\'s true...\\n\\t\\t\\t\\toutput = output + n / idx  =  5 + 25/25  =  5 + 1  =  6\\n\\t\\t\\t\\tnow, idx *= 5  i.e.,  idx = 25 * 5  =  125\\n\\t\\t\\t\\t\\nAgain,\\n\\t\\t\\t\\tn / idx >= 1\\n\\t\\t\\t\\t28 / 125 >= 1  or,  0 >= 1... It\\'s false\\n\\t\\t\\t\\t\\n**So we return the output as 6...**\\n**/\\n```\\n\\n\\n# **C++ / C Solution:**\\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int output = 0;\\n        for(int idx = 5; idx <= n; idx += 5) {\\n            int x = idx;\\n            while(x > 0 && x % 5 == 0) {\\n                ++output;\\n                x /= 5;\\n            }\\n        }\\n        return output;\\n    }\\n};\\n/**\\nTotal number of trailing zeroes will be equal to count of how many times 10 is factor of that number.\\nAnd every 10 is formed of the product of two prime numbers 2 and 5.\\nSo if we find out how many factors of 2\\u2019s are there in the number. Similarly how many factors of 5\\u2019s are there. Then we can say that each of these will combine to make product equal to 10.\\nTherefore total number of trailing zeroes will be equal to minimum( count of 2\\u2019s , count of 5\\u2019s).\\n**/\\n```\\n\\n# **Python/Python3 Solution:**\\n```\\nclass Solution(object):\\n    def trailingZeroes(self, n):\\n        # Negative Number Edge Case\\n        if(n < 0):\\n            return -1\\n        # Initialize output...\\n        output = 0\\n        # Keep dividing n by 5 & update output...\\n        while(n >= 5):\\n            n //= 5\\n            output += n\\n        return output    # Return the output...\\n```\\n                \\n# **JavaScript Solution:**\\n```\\nvar trailingZeroes = function(n) {\\n    // Negative Number Edge Case...\\n    if (n < 0) return -1;\\n    // Initialize the output result i.e., the number of trailing zeroes...\\n\\tlet output = 0;\\n    // Count number of 5s in prime factors of n!\\n\\tfor (let idx = 5; n/idx >= 1; idx *= 5) {\\n\\t\\toutput += Math.floor(n/idx);\\n\\t}\\n    // Return the number of trailing zeroes...\\n    return output;\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        // Negative Number Edge Case...\\n        if (n < 0)\\n\\t\\t    return -1;\\n        // Initialize the output result i.e., the number of trailing zeroes...\\n\\t    int output = 0;\\n        // Count number of 5s in prime factors of n!\\n\\t    for (long idx = 5; n/idx >= 1; idx *= 5) {\\n\\t\\t    output += n/idx;\\n\\t    }\\n        // Return the number of trailing zeroes...\\n        return output;\\n    }\\n}\\n/**\\n**The following example helps you to understand the code...**\\nLet, n = 25\\nInitialize the output as 0...\\n\\nAfter first pass,\\n\\t\\t\\t\\tloop for idx = 5; n / idx >= 1\\n\\t\\t\\t\\t25 / 5 >= 1 or, 5 >= 1... It\\'s true...\\n\\t\\t\\t\\toutput = output + n / idx  =  0 + 25/5  =  0 + 5  =  5\\n\\t\\t\\t\\tand, idx *= 5  i.e.,  idx = 5 * 5  =  25\\n\\nAfter second pass,\\n\\t\\t\\t\\tn / idx >= 1  or,  25 / 25 >= 1  or,  1 >= 1... It\\'s true...\\n\\t\\t\\t\\toutput = output + n / idx  =  5 + 25/25  =  5 + 1  =  6\\n\\t\\t\\t\\tnow, idx *= 5  i.e.,  idx = 25 * 5  =  125\\n\\t\\t\\t\\t\\nAgain,\\n\\t\\t\\t\\tn / idx >= 1\\n\\t\\t\\t\\t28 / 125 >= 1  or,  0 >= 1... It\\'s false\\n\\t\\t\\t\\t\\n**So we return the output as 6...**\\n**/\\n```\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int output = 0;\\n        for(int idx = 5; idx <= n; idx += 5) {\\n            int x = idx;\\n            while(x > 0 && x % 5 == 0) {\\n                ++output;\\n                x /= 5;\\n            }\\n        }\\n        return output;\\n    }\\n};\\n/**\\nTotal number of trailing zeroes will be equal to count of how many times 10 is factor of that number.\\nAnd every 10 is formed of the product of two prime numbers 2 and 5.\\nSo if we find out how many factors of 2\\u2019s are there in the number. Similarly how many factors of 5\\u2019s are there. Then we can say that each of these will combine to make product equal to 10.\\nTherefore total number of trailing zeroes will be equal to minimum( count of 2\\u2019s , count of 5\\u2019s).\\n**/\\n```\n```\\nclass Solution(object):\\n    def trailingZeroes(self, n):\\n        # Negative Number Edge Case\\n        if(n < 0):\\n            return -1\\n        # Initialize output...\\n        output = 0\\n        # Keep dividing n by 5 & update output...\\n        while(n >= 5):\\n            n //= 5\\n            output += n\\n        return output    # Return the output...\\n```\n```\\nvar trailingZeroes = function(n) {\\n    // Negative Number Edge Case...\\n    if (n < 0) return -1;\\n    // Initialize the output result i.e., the number of trailing zeroes...\\n\\tlet output = 0;\\n    // Count number of 5s in prime factors of n!\\n\\tfor (let idx = 5; n/idx >= 1; idx *= 5) {\\n\\t\\toutput += Math.floor(n/idx);\\n\\t}\\n    // Return the number of trailing zeroes...\\n    return output;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1746127,
                "title": "c-single-line-solution",
                "content": "If a number has zero as trailing then it means it means there is atleast one 5* 2 or generally its primefactorisation contains 2^n* 3^m* 5^p * 7^q.....\\n\\nFor a number to contain trailing zeros it has to be 2^n * 5^m where the deciding power will be of 5 (for a given range number multiples of 2 (i.e, even) is greater than 5 multiples) so we need to find the number of 5 multiples less than given number.\\n\\nA simple observation is that no of 5 in prime factorisation of the n! would give no of zero in it.\\n\\nA simple observation would give us :\\nIf a number **x** less than or equal to **n** is a power of 5 then we need to account for their extra **5** it brings.\\n\\n(Here i have taken till 3125 since given **n** range is 1 <= **n** <= 10^4\\n\\n\\n```\\nint trailingZeroes(int n) {\\n        if(n<=4)return 0;\\n        \\n        int temp=n/5+ n/25 + n/125 +n/625 +n/3125;\\n        return temp;\\n\\n    }\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nint trailingZeroes(int n) {\\n        if(n<=4)return 0;\\n        \\n        int temp=n/5+ n/25 + n/125 +n/625 +n/3125;\\n        return temp;\\n\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 913696,
                "title": "python-divide-by-powers-of-5-98-faster",
                "content": "```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        \\n        count = 0\\n        i = 5\\n        while n//i >= 1:\\n            count += n//i\\n            i *=5\\n        return int(count)  \\n```\\n**LOGIC**\\nTrailing 0s in n! = Count of 5s in prime factors of n!\\n                  = floor(n/5) + floor(n/25) + floor(n/125) + ....\\n\\t\\t\\t\\t  \\n**If it helped please upvote**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        \\n        count = 0\\n        i = 5\\n        while n//i >= 1:\\n            count += n//i\\n            i *=5\\n        return int(count)  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 852183,
                "title": "simple-java-solution",
                "content": "class Solution {\\n    public int trailingZeroes(int n) {\\n        return n>=5 ? n/5 + trailingZeroes(n/5): 0;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int trailingZeroes(int n) {\\n        return n>=5 ? n/5 + trailingZeroes(n/5): 0;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 534764,
                "title": "python-3-iterative-solution-beats-97-31-with-explanation",
                "content": "```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n\\t# iteration -- since all zeros come from 2*5, so we count how many 2 and 5 in given n. since we have enough 2, so we only need to count how many 5 we have in n.\\n        res = 0\\n        while n > 0:\\n            n //= 5\\n            res += n\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n\\t# iteration -- since all zeros come from 2*5, so we count how many 2 and 5 in given n. since we have enough 2, so we only need to count how many 5 we have in n.\\n        res = 0\\n        while n > 0:\\n            n //= 5\\n            res += n\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 187696,
                "title": "60ms-beats-96-of-javascript-submissions",
                "content": "Find the number of trailing zeros in 500!.\n\nThe number of multiples of 5 that are less than or equal to 500 is  500/5=100\nThen, the number of multiples of 25 is  500/25=20\nThen, the number of multiples of 125 is  500/125=4\nThe next power of 5 is 625, which is greater than 500\nTherefore, the number of trailing zeros of  is  = 100+20+4=124\n refer this link https://brilliant.org/wiki/trailing-number-of-zeros/ for more\n\n```\nvar trailingZeroes = function(n) {\n    let count=0,x=5\n    while(x<=n){\n        count += Math.floor(n/x)\n        x*=5\n    }\n    return count\n\n};\n```",
                "solutionTags": [],
                "code": "```\nvar trailingZeroes = function(n) {\n    let count=0,x=5\n    while(x<=n){\n        count += Math.floor(n/x)\n        x*=5\n    }\n    return count\n\n};\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 52443,
                "title": "c-concise-solution",
                "content": "    int trailingZeroes(int n) {\\n        // 5 is always less than 2, so, one 5, one trailing 0\\n        int sum = 0;\\n        while (n > 0) {\\n            n /= 5;\\n            sum += n;\\n        }\\n        return sum;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    int trailingZeroes(int n) {\\n        // 5 is always less than 2, so, one 5, one trailing 0\\n        int sum = 0;\\n        while (n > 0) {\\n            n /= 5;\\n            sum += n;\\n        }\\n        return sum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 52498,
                "title": "my-simplest-method-by-python-only-5-lines",
                "content": "def trailingZeroes(self,n):\\n\\t\\tret = 0\\n\\t\\twhile n/5:\\n\\t\\t\\tret+=n/5\\n\\t\\t\\tn/=5\\n\\t\\treturn ret",
                "solutionTags": [],
                "code": "def trailingZeroes(self,n):\\n\\t\\tret = 0\\n\\t\\twhile n/5:\\n\\t\\t\\tret+=n/5\\n\\t\\t\\tn/=5\\n\\t\\treturn ret",
                "codeTag": "Python3"
            },
            {
                "id": 52512,
                "title": "two-solutions-c-code-with-explanation-and-extension",
                "content": "We know that one pair of 2*5 makes one zero. \\n\\nThus the problem can be converted to \"In decomposition of prime factors of n! (n! = 2^x * 3^y * 5^z * ...), figure out the min(x, z).\" \\n\\nObviously that x > z. Then the problem is to find z (power time of 5). \\n\\nSolution 1: Accumulate multiplier 5 one-by-one from 1 to n\\n\\n    class Solution {\\n    public:\\n        int trailingZeroes(int n) {\\n            int ret = 0;\\n            for(int i = 1; i <= n; i ++)\\n            {\\n                int tmp = i;\\n                while(tmp%5 == 0)\\n                {\\n                    ret ++;\\n                    tmp /= 5;\\n                }\\n            }\\n            return ret;\\n        }\\n    };\\n\\nIn previous analysis, we can see the numbers contributes to 5 are those dividible by 5. (mod 5 == 0)\\n\\nThere is a mathematical law that [n/k] equals to how many numbers from 1~n that are divisible by k.\\nIn this case, z = [n/5] + [n/5^2] + ... \\n\\nSolution 2: \\n\\n    class Solution {\\n    public:\\n        int trailingZeroes(int n) {\\n            int ret = 0;\\n            while(n)\\n            {\\n                ret += n/5;\\n                n /= 5;\\n            }\\n            return ret;\\n        }\\n    };\\n\\n\\nThe problem can be further extended to \"In binary representation of n!, locate the rightmost 1\". \\n\\nIn this case, since each 2 contributes one zero in the binary representation, the problem is to find x (power time of 2). \\n\\nx = [n/2] + [n/2^2] + ...",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int trailingZeroes(int n) {\\n            int ret = 0;\\n            for(int i = 1; i <= n; i ++)\\n            {\\n                int tmp = i;\\n                while(tmp%5 == 0)\\n                {\\n                    ret ++;\\n                    tmp /= 5;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3765226,
                "title": "python-simplest-solution",
                "content": "\\n\\n\\n\\n# Time complexity:\\nThe time complexity of this approach is O(log n) because the while loop runs until \\'5^a\\' is less than or equal to \\'n\\'. As we multiply \\'b\\' by 5 in each iteration, the loop will run approximately log base 5 of \\'n\\' times.\\n\\n# Space complexity:\\nThe space complexity of this approach is O(1) because we are using only a constant amount of space to store the variables \\'a\\', \\'b\\', and \\'c\\'.\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        a=1\\n        b=5\\n        c=0\\n        while (5**a)<=n:\\n            c+=n//b\\n            a+=1\\n            b=b*5\\n        return c\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        a=1\\n        b=5\\n        c=0\\n        while (5**a)<=n:\\n            c+=n//b\\n            a+=1\\n            b=b*5\\n        return c\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483592,
                "title": "beats-100-java-easy-solution-beginner-friendly-easy-to-understand-formula-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the program is based on the observation that trailing zeros in a factorial come from the product of the factors 2 and 5. Since the number of factors of 2 is always greater than the number of factors of 5 in any given number, counting the number of factors of 5 is enough to calculate the number of trailing zeros in a factorial. Therefore, the program counts the number of factors of 5 in n and its powers to calculate the number of trailing zeros in n!.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe program uses a while loop to iterate over n and its powers of 5. In each iteration, the program adds the number of factors of 5 in the current value of n to a counter c. The program then divides n by 5 to get the next smaller value to check. This process continues until n is less than 5.\\n\\n# Complexity\\nThe time complexity of this program is O(log n), as the loop iterates log_5(n) times, with each iteration taking constant time. The space complexity of the program is O(1), as it only requires a constant amount of extra space to store the counter c.\\n- Time complexity:O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n       int c=0;\\n       while(n>4){\\n           c+=(n/5);\\n           n/=5;\\n       }\\n       return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n       int c=0;\\n       while(n>4){\\n           c+=(n/5);\\n           n/=5;\\n       }\\n       return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1618225,
                "title": "python-java-c-c-one-liner-o-logn-explained-in-detail",
                "content": "* The problem is how many 10 in the factorial factors. Because  the number of 2 is more than the number of 5, so the key is how many 5 in the factorial factors.\\n* n // 5 is how many numbers contain a factor of 5, but note 25 = 5 * 5 can provide two 5 and 125 =  5 * 5 * 5 can probide three 5 and so on. We need to count the total number of 5 in the factorial factors.\\n* for n <= 10000, the result is n // 5 + n // 25 + n // 125 + n // 625 + n // 3125\\n* we need to add log(n, 5) times, so the time complexity is O(logN)\\n```\\nclass Solution(object):\\n    def trailingZeroes(self, n):\\n        return n // 5 + n // 25 + n // 125 + n // 625 + n // 3125\\n```\\nan alternative codeing style\\n```\\nclass Solution(object):\\n    def trailingZeroes(self, n):\\n        return sum([n // 5 ** i for i in range(1, 6)])\\n```\\n**Java solution**\\n```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        return n / 5 + n / 25 + n / 125 + n / 625 + n / 3125;\\n    }\\n}\\n```\\n**C solution**\\n```\\nint trailingZeroes(int n){\\n    return n / 5 + n / 25 + n / 125 + n / 625 + n / 3125;\\n}\\n```\\n**C++ solution**\\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        return n / 5 + n / 25 + n / 125 + n / 625 + n / 3125;\\n    }\\n};\\n```\\n\\n**Please UPVOTE!**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def trailingZeroes(self, n):\\n        return n // 5 + n // 25 + n // 125 + n // 625 + n // 3125\\n```\n```\\nclass Solution(object):\\n    def trailingZeroes(self, n):\\n        return sum([n // 5 ** i for i in range(1, 6)])\\n```\n```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        return n / 5 + n / 25 + n / 125 + n / 625 + n / 3125;\\n    }\\n}\\n```\n```\\nint trailingZeroes(int n){\\n    return n / 5 + n / 25 + n / 125 + n / 625 + n / 3125;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        return n / 5 + n / 25 + n / 125 + n / 625 + n / 3125;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1203100,
                "title": "java-in-depth-explanation-with-complete-thought-process-two-solutions",
                "content": "```\\n/*\\n    Q : It looks horrible that how we can store n! (if 0 <= n <= 10000).\\n        there is no such data that can store such a big big number.\\n        \\n    Q: Is that we need to calculate actual value of n!.\\n    A: Well, absolutely not. If anyhow we can store/calculate n! that \\n       would be too costly. It takes much more computation time.\\n       \\n    To solve this problem the sequence of following questions should\\n    come to our mind.\\n    \\n    Q:1 If we want trailing zeroes in n! then what are the digits/numbers\\n        are responsible to produce zeroes?\\n        \\n    A:1 If you observe carefully by writing few testcases you will find\\n        that only digit 2 & 5 are appropriate candidates to produce\\n        zeroes in n!.\\n        \\n    Q:2 How do we find how many 2\\'s and 5\\'s are there in n!. If calculating\\n        n! is too costly{assuming not possible to calculate}?\\n    A:2 Well, don\\'t need to calculate n! to counts of 2 and 5.\\n        We can can represent all the numbers(1x2x3x4...n) to its prime\\n        factorization, from there we can find how many 2\\'s and 5\\'s\\n        are exists in n!.\\n        \\n        For example:\\n        -----------\\n            n -> 10\\n            then how many 2\\'s and 5\\'s are there in 10!\\n            \\n            1x2x3x4x5x6x7x8x9x10\\n            \\n            Writing individual numbers in n! to its prime factorization\\n            \\n            1x2x3x(2x2)x5x(2x3)x7x(2x2x2)x(3x3)x(2x5)\\n            \\n            1x2^8x3^4x5^2x7\\n            \\n            so, we\\'ve 8(2\\'s) and 2(5\\'s).\\n            \\n            Number of trailing zeroes in n! is equal to:\\n            \\n            min(maximum_power_of_2, maximum_power_of_5)\\n            \\n            min(8, 2) -> 2\\n            \\n            There are two trailing zeroes at the end of 10!(3628800).\\n            \\n    Observation#1 If we observe carefully, maximum power of 2 in n! is always\\n                  greater than maximum power of 5.\\n                  \\n                  So therefore, number of trailing zeroes is always equal\\n                  to maximum power of 5 in prime factorization of n!.\\n                  \\n                  \\n    Observation#2 Maximum power of 5 in n! is always equal to\\n                  number of total multiples of 5 in [1x2x3x4x5x6x7x8x9x10]\\n                  \\n                  total multiples of 5 in [1-10] : equivalent to maximum power of 5 in n!\\n                  \\n                  for 10! -> we can see that there is only 2 multiples(5 & 10)\\n                  of 5 in between [1-10]\\n                  \\n                  But in case if numbers are power of 5 like, 25, 125, 625.. etc.\\n                  \\n                  we\\'ve to consider like\\n                               : 25/5 + 5/5 -> 6\\n                               : 125/5 + 25/5 + 5/5 -> 31 \\n                               : 625/5 + 125/5 + 25/5 + 5/5 -> 156\\n                               \\n                  Because when we divide n with 5 -> we missed some power of 5\\'s in n!.\\n                  \\n    Q:3 How do we know that how many multiples 5(any number) is there in [1-n]?\\n    A:3 n/5\\n*/\\n\\nclass Solution {\\n    public int trailingZeroes_(int n) {\\n        int cnt = 0;\\n        while(n / 5 > 0) {\\n            cnt += n / 5;\\n            n /= 5;\\n        }\\n        return cnt;\\n    }\\n    \\n    public int trailingZeroes(int n) {\\n        return n == 0 ? 0 : n / 5 + trailingZeroes(n / 5);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n    Q : It looks horrible that how we can store n! (if 0 <= n <= 10000).\\n        there is no such data that can store such a big big number.\\n        \\n    Q: Is that we need to calculate actual value of n!.\\n    A: Well, absolutely not. If anyhow we can store/calculate n! that \\n       would be too costly. It takes much more computation time.\\n       \\n    To solve this problem the sequence of following questions should\\n    come to our mind.\\n    \\n    Q:1 If we want trailing zeroes in n! then what are the digits/numbers\\n        are responsible to produce zeroes?\\n        \\n    A:1 If you observe carefully by writing few testcases you will find\\n        that only digit 2 & 5 are appropriate candidates to produce\\n        zeroes in n!.\\n        \\n    Q:2 How do we find how many 2\\'s and 5\\'s are there in n!. If calculating\\n        n! is too costly{assuming not possible to calculate}?\\n    A:2 Well, don\\'t need to calculate n! to counts of 2 and 5.\\n        We can can represent all the numbers(1x2x3x4...n) to its prime\\n        factorization, from there we can find how many 2\\'s and 5\\'s\\n        are exists in n!.\\n        \\n        For example:\\n        -----------\\n            n -> 10\\n            then how many 2\\'s and 5\\'s are there in 10!\\n            \\n            1x2x3x4x5x6x7x8x9x10\\n            \\n            Writing individual numbers in n! to its prime factorization\\n            \\n            1x2x3x(2x2)x5x(2x3)x7x(2x2x2)x(3x3)x(2x5)\\n            \\n            1x2^8x3^4x5^2x7\\n            \\n            so, we\\'ve 8(2\\'s) and 2(5\\'s).\\n            \\n            Number of trailing zeroes in n! is equal to:\\n            \\n            min(maximum_power_of_2, maximum_power_of_5)\\n            \\n            min(8, 2) -> 2\\n            \\n            There are two trailing zeroes at the end of 10!(3628800).\\n            \\n    Observation#1 If we observe carefully, maximum power of 2 in n! is always\\n                  greater than maximum power of 5.\\n                  \\n                  So therefore, number of trailing zeroes is always equal\\n                  to maximum power of 5 in prime factorization of n!.\\n                  \\n                  \\n    Observation#2 Maximum power of 5 in n! is always equal to\\n                  number of total multiples of 5 in [1x2x3x4x5x6x7x8x9x10]\\n                  \\n                  total multiples of 5 in [1-10] : equivalent to maximum power of 5 in n!\\n                  \\n                  for 10! -> we can see that there is only 2 multiples(5 & 10)\\n                  of 5 in between [1-10]\\n                  \\n                  But in case if numbers are power of 5 like, 25, 125, 625.. etc.\\n                  \\n                  we\\'ve to consider like\\n                               : 25/5 + 5/5 -> 6\\n                               : 125/5 + 25/5 + 5/5 -> 31 \\n                               : 625/5 + 125/5 + 25/5 + 5/5 -> 156\\n                               \\n                  Because when we divide n with 5 -> we missed some power of 5\\'s in n!.\\n                  \\n    Q:3 How do we know that how many multiples 5(any number) is there in [1-n]?\\n    A:3 n/5\\n*/\\n\\nclass Solution {\\n    public int trailingZeroes_(int n) {\\n        int cnt = 0;\\n        while(n / 5 > 0) {\\n            cnt += n / 5;\\n            n /= 5;\\n        }\\n        return cnt;\\n    }\\n    \\n    public int trailingZeroes(int n) {\\n        return n == 0 ? 0 : n / 5 + trailingZeroes(n / 5);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 863663,
                "title": "0-ms-java-solution",
                "content": "**Approach:\\nfor counting the number of trailing zeroes\\n1.example if there is a number 1200 -this will be made of product of 12,10,10\\n **   so it consist of 2s 10 as these ten are contributing  and making two zeroes in the answer**\\n**2. so our main aim is to count number of times 10 occur in the system\\n3.for 10 to occcur -we need to count the factor of 10 which are 2 and 5\\n4.as in any number Occurences of 2 >Occurences of 5\\n5.so it is better to count   occurences of 5\\n6. for counting the occurence  of 5:**\\n  \\n**\\n**** eg Trailing 0s in n! = Count of 5s in prime factors of n!\\n                  **= floor(n/5) + floor(n/25) + floor(n/125) + ....**\\n```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n    int ans=0;\\n       int p=5;  //5^1=5\\n        while((n/p)>0)\\n        {\\n            ans+=n/p; \\n            p=p*5; //increasing the power by 5\\n            \\n        }\\n        return ans;\\n        \\n    }\\n}\\n```\\n**please upvote the solution if you like it**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n    int ans=0;\\n       int p=5;  //5^1=5\\n        while((n/p)>0)\\n        {\\n            ans+=n/p; \\n            p=p*5; //increasing the power by 5\\n            \\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 448166,
                "title": "python-js-go-c-solution-with-o-log-n-w-hint",
                "content": "Hint:\\n\\n----\\n\\nn! = n x n-1 x n-2 ... x 1\\nThat means trailing zero is contributed by the number of (5, 2) pair in prime factor decomposition of n!\\n\\nWith the value growing on n, n can be re-written as n = **5**^**k** x **2**^**q** x  (other prime factors ...).\\n\\nThe **key-point** is the **k**, the exponent of 5, because k \\u2266 q always for every possible n! with trailing zero.\\n\\nObservation:\\n\\n5! = 5 x 4 x 3 x 2 x 1 = 5^1 x 2^1 x ( 4 x 3 ) = 5^**1** x 2^3 x other prime factors= 12**0**\\n\\n10! = 10 x 9 x ... 5 x ...x 2 x 1 = 5^**2** x 2^8 x other prime factors = 36288**00**\\n\\n15! = 15 x 14 x ... x 2 x1 = 5^**3** x 2^11 x other prime factors = 1307674368**000**\\n\\n---\\n\\nMethod_#1: Iterative implementation\\n\\nPython:\\n\\n```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        \\n        exponent_of_5 = 0\\n        \\n        while n > 4 :\\n            \\n            quotient = n // 5\\n            \\n            exponent_of_5, n =  exponent_of_5+quotient, quotient\\n        \\n        return exponent_of_5\\n```\\n\\n---\\n\\nJavascript:\\n\\n```\\nvar trailingZeroes = function(n) {\\n    \\n    let exp_of_5 = 0;\\n    \\n    while( n > 4 ){\\n        \\n        let quotient = Math.floor(n / 5);\\n        \\n        exp_of_5 = exp_of_5 + quotient;\\n        n = quotient;\\n    }\\n    \\n    return exp_of_5;\\n};\\n```\\n\\n---\\n\\nGo\\n\\n```\\nfunc trailingZeroes(n int) int {\\n    \\n    exp_of_5 := 0\\n    \\n    for n > 4 {\\n        \\n        quotient := n / 5\\n        \\n        exp_of_5 = exp_of_5 + quotient\\n        n = quotient\\n        \\n    }\\n    \\n    return exp_of_5\\n}\\n```\\n\\n---\\n\\nC++\\n\\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        \\n        int exp_of_5 = 0;\\n        \\n        while( n > 4 ){\\n            \\n            int quotient = n / 5;\\n            exp_of_5 = exp_of_5 + quotient;\\n            n = quotient;\\n        }\\n        \\n        return exp_of_5;\\n    }\\n};\\n```\\n\\n---\\n\\nMethod_#2: Recursive implementation\\n\\nPython:\\n\\n```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        \\n        if n == 0:\\n            # Base case\\n            return 0\\n        \\n        else:\\n            # Inductive step\\n            return ( n//5 + self.trailingZeroes(n//5) )\\n```\\n\\n---\\n\\nJavascript:\\n\\n```\\nvar trailingZeroes = function(n) {\\n    \\n    if( n == 0 ){\\n        // base case\\n        return 0;\\n    }\\n    \\n    // General cases\\n    let quotient = Math.floor( n / 5 );\\n    return ( quotient + trailingZeroes(quotient) );\\n    \\n}\\n```\\n\\n---\\n\\nGo\\n\\n```\\nfunc trailingZeroes(n int) int {\\n    \\n    // Base case\\n    if( n == 0 ){\\n        \\n        return 0\\n    }\\n    \\n    \\n    // General cases\\n    \\n    quotient := n / 5\\n    \\n    return quotient + trailingZeroes( quotient )\\n}\\n```\\n\\n---\\n\\nC++\\n\\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        \\n        // Base case:\\n        if( n == 0){\\n            return 0;\\n        }\\n        \\n        // General case\\n        int quotient = n / 5;\\n        return quotient + trailingZeroes( quotient );\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C",
                    "JavaScript",
                    "Go",
                    "Math",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        \\n        exponent_of_5 = 0\\n        \\n        while n > 4 :\\n            \\n            quotient = n // 5\\n            \\n            exponent_of_5, n =  exponent_of_5+quotient, quotient\\n        \\n        return exponent_of_5\\n```\n```\\nvar trailingZeroes = function(n) {\\n    \\n    let exp_of_5 = 0;\\n    \\n    while( n > 4 ){\\n        \\n        let quotient = Math.floor(n / 5);\\n        \\n        exp_of_5 = exp_of_5 + quotient;\\n        n = quotient;\\n    }\\n    \\n    return exp_of_5;\\n};\\n```\n```\\nfunc trailingZeroes(n int) int {\\n    \\n    exp_of_5 := 0\\n    \\n    for n > 4 {\\n        \\n        quotient := n / 5\\n        \\n        exp_of_5 = exp_of_5 + quotient\\n        n = quotient\\n        \\n    }\\n    \\n    return exp_of_5\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        \\n        int exp_of_5 = 0;\\n        \\n        while( n > 4 ){\\n            \\n            int quotient = n / 5;\\n            exp_of_5 = exp_of_5 + quotient;\\n            n = quotient;\\n        }\\n        \\n        return exp_of_5;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        \\n        if n == 0:\\n            # Base case\\n            return 0\\n        \\n        else:\\n            # Inductive step\\n            return ( n//5 + self.trailingZeroes(n//5) )\\n```\n```\\nvar trailingZeroes = function(n) {\\n    \\n    if( n == 0 ){\\n        // base case\\n        return 0;\\n    }\\n    \\n    // General cases\\n    let quotient = Math.floor( n / 5 );\\n    return ( quotient + trailingZeroes(quotient) );\\n    \\n}\\n```\n```\\nfunc trailingZeroes(n int) int {\\n    \\n    // Base case\\n    if( n == 0 ){\\n        \\n        return 0\\n    }\\n    \\n    \\n    // General cases\\n    \\n    quotient := n / 5\\n    \\n    return quotient + trailingZeroes( quotient )\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        \\n        // Base case:\\n        if( n == 0){\\n            return 0;\\n        }\\n        \\n        // General case\\n        int quotient = n / 5;\\n        return quotient + trailingZeroes( quotient );\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 428776,
                "title": "javascript-solution",
                "content": "### The Idea\\n1. The # of trailing 0 eqauls to how many 5s we see if we break up the factorial\\n2. For example 5! = 1* 2 * 3 * (2 * 2) * 5 , we found one 5, so there is 1 zero.\\n3. Why 5? because only a pair of 2 * 5 can create 0, and since there are way more 2s than 5s, it\\'s more efficient to count 5s\\n4. Why recursion? To break up big numbers that were created by different 5s, such as 25 = 5 * 5.\\n```\\nvar trailingZeroes = function(n) {\\n    if (n<5) return 0;\\n    return Math.floor(n/5) + trailingZeroes(n/5);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar trailingZeroes = function(n) {\\n    if (n<5) return 0;\\n    return Math.floor(n/5) + trailingZeroes(n/5);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 375272,
                "title": "intuitive-java-solution-with-explanation",
                "content": "**Idea**  \\nTrailing zero is formed by multiplying 2\\'s multiple and 5\\'s multiple. By nature, # of 2\\'s multiple (2, 4, 6, ... `2-steps-jump`) are lot more than # of 5\\'s (5, 10, 15..`5-steps-jump`). So # of 5\\'s multiple should decide the trailing zeros which is `n/5`. But note that numbers like `25, 125..` are special as they have more than one 5\\'s in them and each 5 can contribute to one trailing zero with some 2\\'s multiple. Again, do not worry about running out of 2\\'s multiples for `25 or 125 etc` as they are far more abundantly available.\\n\\n```\\npublic int trailingZeroes(int n) {\\n        int count = 0;\\n        while(n > 0){\\n            count += n/5;\\n            n /= 5;\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int trailingZeroes(int n) {\\n        int count = 0;\\n        while(n > 0){\\n            count += n/5;\\n            n /= 5;\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 368620,
                "title": "c-0ms-elegant-solution-explained-using-no-extra-variable-beats-100-100",
                "content": "Thinking process:\\n1. tailling zeors means factor of 10 in the factorial\\n2. any occurance of the factor 5 must has another 2 as a factor in any factorial\\n3. thus, finding tailling zeros means `finding the number of factor of 5` for `the factorial of n`\\n4. we can do so by dividing `n` to get the additional number of factor of 5s\\n\\nThe last step is a little hard to explain even with an example, but I\\'ll try:\\n\\nFor instance, `25!` have factors of 5, 10, 15, 20, and 25 that we are interested in. 5, 10, 15, 20 all have only `1` factor of 5 in each of them while 25 have `2` of factor 5. We have 4 trailling zeros from `20!` to `24!`, and `25` brought 2 of 5s into`25!` making it has 6 of 5s. Thus, `25!` has 6 trailling zeros. \\n\\nWe can see that for every `n` seperated by 5, we have one more factor of 5 involved, so we should divide `n` to get the number of additional factors of 5.\\n\\nTrying out a few more examples might help you understand the transition from step 3 to step 4.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int res(0);\\n        while (n) {\\n            res += n /= 5;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int res(0);\\n        while (n) {\\n            res += n /= 5;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52455,
                "title": "0ms-6-line-solution-in-c-java",
                "content": "    int count = 0; \\n    while (n > 1) {\\n      count += n / 5;\\n      n = n / 5; \\n    }\\n    return count;",
                "solutionTags": [
                    "Java"
                ],
                "code": "    int count = 0; \\n    while (n > 1) {\\n      count += n / 5;\\n      n = n / 5; \\n    }\\n    return count;",
                "codeTag": "Unknown"
            },
            {
                "id": 52466,
                "title": "java-simple-solution-5-line",
                "content": "Because the trailing zeros is only related to the number of 5 in n!, we can calculate this by the code below:\\n\\n    \\tpublic int trailingZeroes(int n) {\\n\\t\\tint rs = 0;\\n\\t\\twhile (n != 0) {\\n\\t\\t\\trs += (n / 5);\\n\\t\\t\\tn /= 5;\\n\\t\\t}\\n\\t\\treturn rs;\\n\\t}",
                "solutionTags": [],
                "code": "Because the trailing zeros is only related to the number of 5 in n!, we can calculate this by the code below:\\n\\n    \\tpublic int trailingZeroes(int n) {\\n\\t\\tint rs = 0;\\n\\t\\twhile (n != 0) {\\n\\t\\t\\trs += (n / 5);\\n\\t\\t\\tn /= 5;\\n\\t\\t}\\n\\t\\treturn rs;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 52501,
                "title": "accepted-python-submission-with-log5-n-time-complexity",
                "content": "5 multiply an even number will contribute one tailing zero. The factorial list never short of even number. Basically, how many '5' within the list determines the number of tailing zero. The code bellow count how many 5 in the list from 1 to n.\\n\\n       class Solution:\\n        # @return an integer\\n        def trailingZeroes(self, n):\\n            res=0\\n            while n>0:\\n                n=int(n/5) \\n                res+=n \\n            return res",
                "solutionTags": [],
                "code": "5 multiply an even number will contribute one tailing zero. The factorial list never short of even number. Basically, how many '5' within the list determines the number of tailing zero. The code bellow count how many 5 in the list from 1 to n.\\n\\n       class Solution:\\n        # @return an integer\\n        def trailingZeroes(self, n):\\n            res=0\\n            while n>0:\\n                n=int(n/5) \\n                res+=n \\n            return res",
                "codeTag": "Java"
            },
            {
                "id": 3796013,
                "title": "java-2-easy-solutions-explained",
                "content": "**This question is pretty straightforward.\\nBecause all trailing 0 is from factors `5 * 2`.**\\n\\n# Complexity\\n- Time complexity: O(logn) to the base 5\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n      int count = 0;\\n      while(n > 0) {\\n          n /= 5;\\n          count += n;\\n      }  \\n      return count;\\n    }\\n}\\n```\\n**THE ONE LINER SOLUTION USING RECURSION**\\n```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n return n == 0 ? 0 : n / 5 + trailingZeroes(n / 5);\\n    }\\n}\\n```\\n*Time complexity is same but recurion takes an extra `O(n)` space in the memory which is why the iterative approach is better*\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n      int count = 0;\\n      while(n > 0) {\\n          n /= 5;\\n          count += n;\\n      }  \\n      return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n return n == 0 ? 0 : n / 5 + trailingZeroes(n / 5);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631514,
                "title": "java-easiest-solution-beginners-understandable-100-beats-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe trailingZeroes function takes an integer n as input and calculates the number of trailing zeros(ie zeros at the end of the factorial answer) in the factorial of n.\\n\\n# Approach\\nLet\\'s consider an example: n = 25.\\n\\nInitially, count = 0 and n = 25.\\n\\n1st iteration:\\n\\nDivide n by 5: n = 25 / 5 = 5\\nAdd n (5) to count: count = 0 + 5 = 5\\n\\n2nd iteration:\\n\\nDivide n by 5: n = 5 / 5 = 1\\nAdd n (1) to count: count = 5 + 1 = 6\\nThe loop ends because n becomes less than 5.\\n\\nThe final result is count = 6, indicating that the factorial of 25 has 6 trailing zeros.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        int count=0;\\n        while(n>0){\\n            n/=5;\\n            count+=n;\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n# **Guys please upvote my solution if you feel it worthy!!**",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        int count=0;\\n        while(n>0){\\n            n/=5;\\n            count+=n;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341834,
                "title": "easy-java-solution-t-c-logn",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        int count=0;\\n        for(int i=5;i<=n;i*=5){\\n             count+=(n/i);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        int count=0;\\n        for(int i=5;i<=n;i*=5){\\n             count+=(n/i);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3308083,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n)\\n     {\\n        int res=0;\\n        while(n)\\n        {\\n            n/=5;\\n            res+=n;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n)\\n     {\\n        int res=0;\\n        while(n)\\n        {\\n            n/=5;\\n            res+=n;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224095,
                "title": "beats-100-c-soluton-with-explanation",
                "content": "# Intuitio\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1.Approach/method\\n![no_of_zero.jpeg](https://assets.leetcode.com/users/images/10a29712-6e37-459c-8e89-b169652d79ca_1677217055.8167605.jpeg)\\n\\n2.Approach/method\\n1.In second approach we simply divide the n! number by 5\\n2.After that For every 5*5.....(or 5^m,m=2,3,4....)(less n) multiple we get extra zero of n!/5^m..\\n3.Add the both zero(step1+step2)\\n\\nexample \\n1.25!\\nnumber of zero=25/5 + 25/25\\n               5+1=6\\n2.50!\\nnumber of zero=50/5 + 50/25\\n               10 + 2= 12\\n4.150!\\nnumber of zero=  150/5 + 150/25 + 150/125 (125 is less then 150  and 5^3=125(5^m))  \\n           30+6+1=37\\n\\n5.1000!\\n1000/5 + 1000/25(5^2) + 1000/125(5^3) +1000/625(5^4)\\n200+40+8+1=249\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//1st method\\n\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int count_zero = 0;\\n        while(n>=5)\\n        {\\n         int quotient=n/5;\\n         n=quotient;\\n         count_zero=count_zero + quotient;\\n        }\\n     return count_zero;\\n    }\\n};\\n\\n//2nd methods\\n//1.In second approach we simply divide the n! number by 5\\n//2.For every 5^m... multiple we get extra zero of n!/5^m..(m=2,3,4...)\\n//3.Add the both zero(step1+step2)\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int count_zero = 0;\\n        int i = 5;\\n        while(i <= n) {\\n            count_zero += n / i;\\n            i =i*5;\\n        }\\n    return count_zero;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//1st method\\n\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int count_zero = 0;\\n        while(n>=5)\\n        {\\n         int quotient=n/5;\\n         n=quotient;\\n         count_zero=count_zero + quotient;\\n        }\\n     return count_zero;\\n    }\\n};\\n\\n//2nd methods\\n//1.In second approach we simply divide the n! number by 5\\n//2.For every 5^m... multiple we get extra zero of n!/5^m..(m=2,3,4...)\\n//3.Add the both zero(step1+step2)\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int count_zero = 0;\\n        int i = 5;\\n        while(i <= n) {\\n            count_zero += n / i;\\n            i =i*5;\\n        }\\n    return count_zero;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130161,
                "title": "explained-simple-code-in-java-mathematics",
                "content": "# Approach\\nThe logic is used to calculate the number of trailing zeros in the factorial of a number. In mathematics, a factorial is the product of all positive integers less than or equal to n. For example, the factorial of 5 is 5! = 5 x 4 x 3 x 2 x 1 = 120, and it contains one trailing zero, since 10 is a product of 2 and 5. By dividing n by 5, you are counting the number of multiples of 5 in the range from 1 to n. However, you need to also consider the multiples of 25 (which are also multiples of 5), so you divide n by 25 to count the number of multiples of 25. Finally, you add the results of both divisions to get the total number of trailing zeros in n!.\\n\\n# Time and Space Complexity\\n\\nThe time complexity of this code is O(log n), as the for loop performs logarithmic operations with respect to the value of n. Each iteration multiplies i by 5, reducing the number of operations performed in each subsequent iteration.\\n\\nThe space complexity of this code is O(1), as it only uses a few variables, regardless of the input size. The memory usage remains constant, regardless of the value of n.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        int res = 0;\\n        for(int i=5;i<=n;i=5*i){\\n            res = res + (n/i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        int res = 0;\\n        for(int i=5;i<=n;i=5*i){\\n            res = res + (n/i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3019048,
                "title": "easiest-soln-goldman-sachs-well-explained",
                "content": "## If you found my answer helpful, please consider giving it an upvote\\uD83D\\uDE0A\\n**ReviseWithArsh #6Companies30Days Challenge 2023\\nChallenge Company 2 : Goldman Sachs\\nQ3. Factorial with Trailing Zeroes.**\\n\\n![3.trailing-zero1.jpg](https://assets.leetcode.com/users/images/45e4aa6b-379f-452c-bd1e-569340c75541_1673178151.6843765.jpeg)\\n![3.trialing-zeros2.jpg](https://assets.leetcode.com/users/images/72b66ceb-9feb-424e-b04a-e4aedcdc7333_1673178163.6625884.jpeg)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // Function to find the number of trailing zeros in the factorial of a given number n\\n    int trailingZeroes(int n) {\\n        // Initialize a variable to store the number of trailing zeros\\n        int num_zeros = 0;\\n\\n        // Iterate over the multiples of 5 from 5 to n\\n        for (int i = 5; i <= n; i += 5) {\\n            // Initialize a variable to store the current multiple of 5\\n            int num = i;\\n\\n            // Divide num by 5 and add the quotient to num_zeros until num is no longer divisible by 5\\n            while (num % 5 == 0) {\\n                num /= 5;\\n                num_zeros++;\\n            }\\n        }\\n\\n        // Return the number of trailing zeros\\n        return num_zeros;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Function to find the number of trailing zeros in the factorial of a given number n\\n    int trailingZeroes(int n) {\\n        // Initialize a variable to store the number of trailing zeros\\n        int num_zeros = 0;\\n\\n        // Iterate over the multiples of 5 from 5 to n\\n        for (int i = 5; i <= n; i += 5) {\\n            // Initialize a variable to store the current multiple of 5\\n            int num = i;\\n\\n            // Divide num by 5 and add the quotient to num_zeros until num is no longer divisible by 5\\n            while (num % 5 == 0) {\\n                num /= 5;\\n                num_zeros++;\\n            }\\n        }\\n\\n        // Return the number of trailing zeros\\n        return num_zeros;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846894,
                "title": "c-sol-with-100-faster",
                "content": "class Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int sum = 0, q = 0;\\n        while(n!=0){\\n        q= n/5;\\n        sum += q;\\n        n = n/5;\\n    }\\n        return sum;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int sum = 0, q = 0;\\n        while(n!=0){\\n        q= n/5;\\n        sum += q;\\n        n = n/5;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1547673,
                "title": "easy-java-solution-with-full-explaination-formula-too-with-diagram",
                "content": "Here let just change the Question instead and find out the no divisible by 15,\\nSo 15 is Comprising 2 prime factors 3 and 5.\\nLet supoose we have 10 here and try to find its Trying to ** Find How many times 15 is repeated**\\nso 10!=10* 9* 8* 7* 6* 5* 4* 3* 2* 1\\n    so here we\\'ll find 15 prime factors which are 3 and 5.\\n\\tHere we are only looking for prime factor because suppose we are looking for 3 first so in 6 we will get a factor of 3 and in 9 too.\\n\\tSince 3 is comprising in other values too we will look out for other prime factor of 15 i.e 5.\\n\\tSo the appearance of 15 we be decided on how many times 5 is repeated in 10!\\n\\tso we check on how many times 3 and 5 are repeated using a formula which is :-\\n\\t![image](https://assets.leetcode.com/users/images/fdd61997-4e6d-4a16-8230-1aab2fd7a056_1635573545.707294.png)\\n\\n\\nHere C is the  Count ,n is number whose factorial we are going to do and p is the prime no,and **these brackets are Greatest Integer Function**\\nso appyling this formula for 3 we will get 4 times (3=**3**x1,6=2x**3**,9=**3**x**3**) and \\nfor 5 it will be 2 (5=**5**x1,10=**5**x2)\\nso 3 -4 times and 5-2 times **we will consider the value which is least among prime factor** here it is 2 so final answer is 2.\\n\\n\\nSo similarly for 10 we will do the same we are going to use this concept and will take the least value of 5 because 2 is more repeated than 5 so we will choose 5 .\\n\\nHere is the code:-\\n\\n\\npublic class Solution {\\n\\n\\n    public int trailingZeroes(int n) {\\n        int count=0;\\n        while(n>0){\\n            n=n/5;\\n            count+=n;\\n        }\\n        return count;\\n}\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n\\n    public int trailingZeroes(int n) {\\n        int count=0;\\n        while(n>0){\\n            n=n/5;\\n            count+=n;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1275893,
                "title": "java-100-time-iterative-and-recursive-solutions-explanation",
                "content": "**Intuition:**\\n\\nMultiplying 5 and 2 results in 10, which has one trailing zero. So any number that has the factor of 5 and 2 (i.e. 10) will definitely have a zero at the end. If there are more than one multiple of 10 *(i.e. multiple of 5 and 2)* in the number (eg - 100=10x10, 1000=10x10x10, etc), then there are more than one zero in the number.\\n\\nSo if we are able to count the number of 10s (5x2) in the number we should be able to find our result.\\n\\nNow if factorial of a number has 5, then it will definitely have a 2 (as 2 < 5). So if we are able to find the number of factors of 5 in a number we should be able to find the number of 10s as well.\\n\\nDividing the given number by 5 will give the factor of 5. If current factor is greater than equal to 5, then that also has additional factor of 5 which needs to be counted to get the final count. Hence that number also needs to be divided by 5 and added to the count. We would want to do this until the factor is less than 5, in which case the factor will be 0.\\n\\n\\n**Iterative:**\\n\\n```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        int count = 0;\\n        while (n >= 5) { \\n\\t\\t\\tn /= 5;\\n            count += n;\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n**Recursive:**\\n```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        return n < 5 ? 0 : n / 5 + trailingZeroes(n/5);\\n\\t}\\n}\\t\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        int count = 0;\\n        while (n >= 5) { \\n\\t\\t\\tn /= 5;\\n            count += n;\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        return n < 5 ? 0 : n / 5 + trailingZeroes(n/5);\\n\\t}\\n}\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 889734,
                "title": "javascript-solution-with-short-hard-to-read-code",
                "content": "## Code\\n```javascript\\nvar trailingZeroes = function (n) {\\n  let c = 0\\n  while (n >= 5) {\\n    c += (n = (n / 5) | 0)\\n  }\\n  return c\\n}\\n```\\n\\n## Explain\\n\\nAs we know, `0` only apear when multiply has `5` and `5`\\'s multiple, and below every `5`\\'s multiple, there will always has an even which can multiply `5`\\'s multiple be a `0` end number.\\n\\nso I just need find out how many `5`\\'s multiple exsist in given number `N`\\n\\nLast! Also as all we know, `25` is double `5`, which can make a `two 0` end number, and so on\\n\\nSo, just count how many `5` in `N` and plus how many `5*5` in `N` and `5*5*5` in `N`\\u2026.\\n\\n*Note: `number | 0` is a shot way to get trunc `Int` number but it requires `number` less than `(2^31)-1`*",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar trailingZeroes = function (n) {\\n  let c = 0\\n  while (n >= 5) {\\n    c += (n = (n / 5) | 0)\\n  }\\n  return c\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 764647,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        int numberOfFives = 0;\\n        \\n        while(n >= 5){\\n            int temp = (int)Math.floor(n / 5);\\n            numberOfFives += temp;\\n            n = temp;\\n        }\\n        \\n        return numberOfFives;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        int numberOfFives = 0;\\n        \\n        while(n >= 5){\\n            int temp = (int)Math.floor(n / 5);\\n            numberOfFives += temp;\\n            n = temp;\\n        }\\n        \\n        return numberOfFives;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 683183,
                "title": "100-percent-faster-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int count = 0;\\n        while(n){\\n            count += n/5;\\n            n= n/5;\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int count = 0;\\n        while(n){\\n            count += n/5;\\n            n= n/5;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 412134,
                "title": "python-3-solution",
                "content": "```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        \\n        z = 0\\n        \\n        while n > 0:\\n            n= n // 5 \\n            z+= n\\n        return z\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        \\n        z = 0\\n        \\n        while n > 0:\\n            n= n // 5 \\n            z+= n\\n        return z\\n```",
                "codeTag": "Java"
            },
            {
                "id": 356210,
                "title": "simple-python-solution",
                "content": "0 can only be generated by 2*5 bassicly\\nSince there are more 2 than 5, we can just count how many 5 factor.\\nCount 5, 5**2, 5**3, ... add them all.\\n```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        ans = 0\\n        while n > 0:\\n            ans += n // 5\\n            n //= 5\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        ans = 0\\n        while n > 0:\\n            ans += n // 5\\n            n //= 5\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 279485,
                "title": "python3-beats-100-36ms",
                "content": "```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        if n<5:\\n            return 0\\n        x=0\\n        while n != 0:\\n            x += n // 5\\n            n //= 5\\n            \\n        return x\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        if n<5:\\n            return 0\\n        x=0\\n        while n != 0:\\n            x += n // 5\\n            n //= 5\\n            \\n        return x\\n",
                "codeTag": "Java"
            },
            {
                "id": 244234,
                "title": "recursive-java-soltions-beats-100",
                "content": "This solution involves a little bit of math. We get a 0 at the end of multiplication, when we multiplying multiple of 2 & 5.\\neg: 2 * 5 = 10\\n4 * 5 =20\\n2 * 15 =30\\n4 * 10 =40\\nThis means we hae to figure out how many multiples  5\\'s and 2\\'s are there in the multiplication.\\nSuppose the number of multiples of 5\\'s is x and \\nthe number of multiples of 2\\'s is y.\\nSo the number of trailing 0\\'s would be min(x,y)\\nBut in case of a factorials the multiples of 5 will always be less than multiples of 2.\\neg n =12\\nmultiples of 2 (y) = [2,4,6,8,10,12] = 6\\nmultiples of 5 (y) = [5,10] = 2\\nSo we only need to find y.\\n\\nBelow is the recursive solution for that.\\n```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        if (n/5 >= 5) {\\n            return n/5 + trailingZeroes(n/5);\\n        } else {\\n            return n/5;\\n        }  \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        if (n/5 >= 5) {\\n            return n/5 + trailingZeroes(n/5);\\n        } else {\\n            return n/5;\\n        }  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 202026,
                "title": "python-solution",
                "content": "\\u53C2\\u8003Wiki\\u4E0A\\u6587\\u7AE0https://en.wikipedia.org/wiki/Trailing_zero#Factorial\\ntips: \\u4E94\\u7684\\u500D\\u6570\\u7684\\u9644\\u8FD1\\u4E00\\u5B9A\\u5B58\\u5728\\u4E0E\\u4E4B\\u76F8\\u5339\\u914D\\u7684\\u5076\\u6570\\uFF0C\\u6240\\u4EE5\\u4E0D\\u5FC5\\u53EF\\u4EE5\\u641C\\u7D22\\uFF0C\\u53EA\\u8981\\u8003\\u8651\\u4E94\\u7684\\u6574\\u500D\\u6570\\u5373\\u53EF\\u3002\\n```\\nclass Solution(object):\\n    \\n    def trailingZeroes(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        cnt = 0\\n        while n >= 5:\\n            n //= 5\\n            cnt += n\\n        return cnt\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    \\n    def trailingZeroes(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        cnt = 0\\n        while n >= 5:\\n            n //= 5\\n            cnt += n\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 200330,
                "title": "python-5-lines-iterative-solution-with-explanations",
                "content": "```python\\nclass Solution(object):\\n    def trailingZeroes(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        c = 0\\n        while n > 0:\\n            n //= 5\\n            c += n\\n        return c\\n```\\nWe have one trailing zero for each pair of prime factors (2,5) in the prime factorization of n!.\\nThere are plenty of factors 2 in n! so let\\'s just count the factors 5 in all numbers lower than n (included).\\nTotal number of factors 5 is equal to the sum of those numbers :\\n- number of multiples of 5 below n (added in 1st iteration, after having divided n by 5 once) \\n- number of multiples of 5^2 below n (added in 2nd iteration, after having divided n by 5 twice) \\n- number of multiples of 5^3 below n (added in 3rd iteration, after having divided n by 5 three times) \\n...\\n- number of multiples of 5^k below n (added in last iteration, after having divided n by 5 k times)\\nk goes until log5(n) so the time complexity is O(log(n)).",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def trailingZeroes(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        c = 0\\n        while n > 0:\\n            n //= 5\\n            c += n\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 185386,
                "title": "java-solution",
                "content": "Now let us think about how a trailing zero is added during factorial calculation.\n1) You decompose the multiplication chain in terms of each element's prime factors\n ex. 10! = 10x9x8x7x6x5x4x3x2x1 =(5x2)*(3x3)*(2x2x2)*7*(2x3)*5*(2x2)*3*2*1\n2) A trailing zero is added only if whenever there is a pair of one 5 and one 2 in the multiplication chain.\n3) This (5,2) pair production is fundamentally limited by the number of 5's in the multiplcation chain because there will be always more 2's than 5's.\n4) So the trick is to count how many factor 5's are in the multiplication chain.\n\nSo how do we count this ?\nFor n! \n!n = (5^(number of 5's))*(other prime factor multiplications)\n1) So simple way of counting the 5s is to keep dividing n by 5 and summing up number of times it divided evenly.. but this is slow\n\nIs there a better way ? \nEx. How many multiples of 5s are in 100! or 1 to 100?\n100 / 5 = 20.\nBut there are also mutiples of 5x5, 100/(5x5) = 4. (One extra 5's from 25, 50, 75 and 100)\nAre there multiples of 5x5x5 ? Nope because 100/(5x5x5) < 1; So this is our termination condition.\nSo the total number of trailing zeros are 20 + 4 = 24\nSo factors we care about are 5, 5x5, 5x5x5, 5x5x5x... and so on.\n\n2) Add up the quotients by dividing the number by 5, 5x5, 5x5x5, and so on (Works but, later this leads to overflow because divisor is exponentially increasing)\n3) Another way of approaching 2) is simply divide n by 5, to count multiples of 5.\nThen update n = n/5 to and divide it by 5 to count the multiples of 5x5's. \nThen update n = n/5 to and divide it by 5 count multiples of 5x5x5's and so on till n/5 < 1.\n```\nclass Solution {\n    public int trailingZeroes(int n) {\n        int numOfFives = 0;\n        while(true){\n            if(n/5<1){\n                break;\n            } else {\n                numOfFives += n/5;\n                n=n/5;\n            }\n        }\n        return numOfFives;\n    }\n}\n```\n\n",
                "solutionTags": [],
                "code": "```\nclass Solution {\n    public int trailingZeroes(int n) {\n        int numOfFives = 0;\n        while(true){\n            if(n/5<1){\n                break;\n            } else {\n                numOfFives += n/5;\n                n=n/5;\n            }\n        }\n        return numOfFives;\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 52444,
                "title": "3-lines-java-solution-1ms",
                "content": "\\n    public int trailingZeroes(int n) {\\n    \\tint num;\\n    \\tfor (num = 0; n != 0; n /= 5, num += n);\\n    \\treturn num;\\n    }",
                "solutionTags": [],
                "code": "\\n    public int trailingZeroes(int n) {\\n    \\tint num;\\n    \\tfor (num = 0; n != 0; n /= 5, num += n);\\n    \\treturn num;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 52442,
                "title": "1ms-java-solution",
                "content": "    public class Solution {\\n    public int trailingZeroes(int n) {\\n        int sum=0;\\n        while(n>=5){\\n            sum+=n/5;\\n            n=n/5;\\n        }\\n        return sum;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int trailingZeroes(int n) {\\n        int sum=0;\\n        while(n>=5){\\n            sum+=n/5;\\n            n=n/5;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 52458,
                "title": "c-4ms-simple-solution-by-counting-5-s",
                "content": "    class Solution {\\n    public:\\n    int trailingZeroes(int n) {\\n        int r = 0;\\n        while(n >= 5){\\n            n /= 5;\\n            r += n;\\n        }\\n        return r;\\n    }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n    int trailingZeroes(int n) {\\n        int r = 0;\\n        while(n >= 5){\\n            n /= 5;\\n            r += n;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 52429,
                "title": "why-my-code-didn-t-pass-the-test",
                "content": "The code is quite simple and straight forward:\\n\\nint trailingZeroes(int n) {\\n        int num = 0;\\n\\n\\tfor(int test=5; test<=n; test*=5)\\n\\t{\\n\\t\\tnum += n/test;\\n\\t}\\n\\n\\treturn num;\\n}\\n\\n\\nHowever, system test returns:\\n\\nStatus: Time Limit Exceeded\\nLast executed input:\\t2147483647\\n\\n\\nMy questions are:\\n\\n1. This \"last input\" is obviously a long int, rather than int. Why does the system care about a long int type since the pre-set class uses an int function?\\n\\n2. Why did the recursive function passed system test? What's the difference with my function?\\n\\nint trailingZeroes(int n) {\\n        return n==0 ? 0 : n/5+trailingZeroes(n/5);\\n}\\n\\nThanks!",
                "solutionTags": [],
                "code": "The code is quite simple and straight forward:\\n\\nint trailingZeroes(int n) {\\n        int num = 0;\\n\\n\\tfor(int test=5; test<=n; test*=5)\\n\\t{\\n\\t\\tnum += n/test;\\n\\t}\\n\\n\\treturn num;\\n}\\n\\n\\nHowever, system test returns:\\n\\nStatus: Time Limit Exceeded\\nLast executed input:\\t2147483647\\n\\n\\nMy questions are:\\n\\n1. This \"last input\" is obviously a long int, rather than int. Why does the system care about a long int type since the pre-set class uses an int function?\\n\\n2. Why did the recursive function passed system test? What's the difference with my function?\\n\\nint trailingZeroes(int n) {\\n        return n==0 ? 0 : n/5+trailingZeroes(n/5);\\n}\\n\\nThanks!",
                "codeTag": "Java"
            },
            {
                "id": 3737418,
                "title": "simple-c-code-easiest-approach",
                "content": "\\n\\n# Complexity\\n- Time complexity: Log N\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:Constant Space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int ans=0;\\n        while(n>0){\\n            ans+=n/5;\\n            n/=5;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int ans=0;\\n        while(n>0){\\n            ans+=n/5;\\n            n/=5;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717257,
                "title": "java-100-beats-easy-solution",
                "content": "# Intuition\\nWe have to find exponent of 5 in factorial of n.\\nThe exponent of 5 will be equal to the number of trailing zeros. \\n\\n# Approach\\nWe continuously divide n by 5 and add it to variable(initialised from zero) and n will become n/5,until n becomes zero.\\n\\n# Complexity\\n- Time complexity:\\nO(logn)\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n       int c=0;\\n       while(n!=0){\\n           c+=n/5;\\n           n/=5;\\n       }\\n       return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n       int c=0;\\n       while(n!=0){\\n           c+=n/5;\\n           n/=5;\\n       }\\n       return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631503,
                "title": "5-lines-solution-java-log-n-100-beats",
                "content": "# Intuition\\nThe trailingZeroes function takes an integer n as input and calculates the number of trailing zeros(ie zeros at the end of the factorial answer) in the factorial of n.\\n\\n# Approach\\nLet\\'s consider an example: n = 25.\\n\\nInitially, count = 0 and n = 25.\\n\\n1st iteration:\\n\\nDivide n by 5: n = 25 / 5 = 5\\nAdd n (5) to count: count = 0 + 5 = 5\\n\\n2nd iteration:\\n\\nDivide n by 5: n = 5 / 5 = 1\\nAdd n (1) to count: count = 5 + 1 = 6\\nThe loop ends because n becomes less than 5.\\n\\nThe final result is count = 6, indicating that the factorial of 25 has 6 trailing zeros.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Please upvote guys if u like my solution!!\\n# Code\\n```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        int count=0;\\n        while(n>0){\\n            n/=5;\\n            count+=n;\\n        }     \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        int count=0;\\n        while(n>0){\\n            n/=5;\\n            count+=n;\\n        }     \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3616779,
                "title": "easy-c-solution-beats-100-4lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int count = 0 ;\\n        for (int i = 5; n / i >= 1; i *= 5){\\n            count += n / i;\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int count = 0 ;\\n        for (int i = 5; n / i >= 1; i *= 5){\\n            count += n / i;\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546309,
                "title": "easiest-python-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        co = 0\\n        while n > 0:\\n            co+= n // 5\\n            n //= 5\\n        return co\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        co = 0\\n        while n > 0:\\n            co+= n // 5\\n            n //= 5\\n        return co\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658530,
                "title": "python-easy-solution-in-5-lines",
                "content": "```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        i,c = 5,0\\n        while i<=n:\\n            c+=n//i\\n            i*=5\\n        return c\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        i,c = 5,0\\n        while i<=n:\\n            c+=n//i\\n            i*=5\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2583050,
                "title": "java-fastest-solution",
                "content": "```\\nclass Solution {\\n    \\n    \\n    public int trailingZeroes(int n) {\\n        \\n        int ans=0;\\n       while(n>=5)\\n       {\\n           n/=5;\\n           ans+=n;\\n       }\\n        \\n        return ans;\\n    }\\n}\\n```\\n\\nStay Hungry! Stay f00lish : )",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    \\n    public int trailingZeroes(int n) {\\n        \\n        int ans=0;\\n       while(n>=5)\\n       {\\n           n/=5;\\n           ans+=n;\\n       }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2406341,
                "title": "c-0ms-faster-than-100-fastest-explained-with-comments-simple-easy-method",
                "content": "\\n```\\n\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {  \\n\\t\\n\\t//we just have to count number of 5\\'s as  (5*2) contributes to 1 zero, \\n\\t//as number of 2\\'s are always greater than number of 5\\'s, \\n\\t//count of 5\\'s are the limiting case for  trailing 0\\'s\\n\\n\\n      if(n <= 4){                   //if n is less than 4 then leading zeroes are 0\\n        return 0;\\n      }\\n                                         //considering powers of  5 as 25 contributes to 2 --> 5\\'s, \\n\\t                                     //125 contrinutes to 3 --> 5\\'s similarly 625 contributes 4  --> 5\\'s and so on ,\\n\\t                                     //and dividing then gives the count of 5\\'s for the value of n\\n\\t   int countof5 = 0;   \\n\\t   \\n      for(int i = 1; i<=5 ;++i){                   \\n        int temp_count=n/(pow(5,i));  \\n        \\n        if(temp_count==0){\\n          break;\\n        }\\n        \\n        else{\\n          countof5+=temp_count;\\n        }\\n        \\n      }\\n      \\n      return  countof5;\\n    }\\n};\\n\\n\\n```\\n\\n",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {  \\n\\t\\n\\t//we just have to count number of 5\\'s as  (5*2) contributes to 1 zero, \\n\\t//as number of 2\\'s are always greater than number of 5\\'s, \\n\\t//count of 5\\'s are the limiting case for  trailing 0\\'s\\n\\n\\n      if(n <= 4){                   //if n is less than 4 then leading zeroes are 0\\n        return 0;\\n      }\\n                                         //considering powers of  5 as 25 contributes to 2 --> 5\\'s, \\n\\t                                     //125 contrinutes to 3 --> 5\\'s similarly 625 contributes 4  --> 5\\'s and so on ,\\n\\t                                     //and dividing then gives the count of 5\\'s for the value of n\\n\\t   int countof5 = 0;   \\n\\t   \\n      for(int i = 1; i<=5 ;++i){                   \\n        int temp_count=n/(pow(5,i));  \\n        \\n        if(temp_count==0){\\n          break;\\n        }\\n        \\n        else{\\n          countof5+=temp_count;\\n        }\\n        \\n      }\\n      \\n      return  countof5;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2395507,
                "title": "java-easy-4-lines-code",
                "content": "don\\'t forget to upvpte if you like the sol\\n\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        int res =0;\\n        for(int i=5;i<=n;i*=5)\\n        {res = res + n/i;}\\n        return res;}  }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int trailingZeroes(int n) {\\n        int res =0;\\n        for(int i=5;i<=n;i*=5)\\n        {res = res + n/i;}",
                "codeTag": "Java"
            },
            {
                "id": 2076166,
                "title": "c-3-lines-solution-with-detailed-explanation-100-faster",
                "content": "**Explanation** :  We have to find power of 10 in n!.\\nWhich boils down to finding maximum power of 5 present in factorization of n! because maximum power of 2 will always be greater than maximum power of 5. \\n\\nApproach : \\nLet\\'s take 10! as an example.\\n`10! = 1*2*3*4*5*6*7*8*9*10`\\n\\nThere are 5 multiples of 2 present in 10! each containing atleast one power of 2. \\n`2 4 6 8 10  ` Count can be obtained by integral value of `10/2`   \\nAdd 5 to the answer. We have counted 5 powers of 2. \\n\\nThen there are 2 multiples of `2^2` present in 10! each containing atleast 2 power of 2. \\n`4 8`  can be obtained by integral value of ` 10/2^2.`\\nAdd 2 to the answer. \\n\\nNow one might think there are 2 factors of `2^2` so we should add 4 but first power of 2 in each no. is already added in previous iterations.\\nWhen we counted all the multiples of 2. \\n\\nSo in general there are `n/p^a ` ( where p is a prime no. Take floor of the value ) multiples of ` p^a `present in n! . Each containing atleast \\'a\\' power of 2. \\nAdd `[n/p^a] `to the answer.  \\nThis will count one power of 2 in each multiple of `p^a`. Rest of the powers are already counted in previous iterations. \\n\\nNow our answer is the sum of all such no. of multiples.\\n\\n`ans = [n/p] + [n/p^2] + [n/p^3] +.... [n/p^a] where p^a < = n`\\n\\n\\n```\\n   int trailingZeroes(int n) {\\n        int pow_of_5=0;\\n        \\n        while(n){\\n            n=n/5; \\n            pow_of_5+=n;\\n        }\\n        return pow_of_5;\\n    }\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n   int trailingZeroes(int n) {\\n        int pow_of_5=0;\\n        \\n        while(n){\\n            n=n/5; \\n            pow_of_5+=n;\\n        }\\n        return pow_of_5;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1460040,
                "title": "js-o-nlogn-and-o-logn-solution-explained",
                "content": "The main idea - you need to figure out, how many 5\\'s you have on n! multipliers. For example: 10 is 5 * 2, so there is one 5. 250 is 5 * 5 * 5 * 2, so there is three 5\\'s. For every 5 you can find 2\\'s in n! multipliers, and 5*2 will give you 10 and one zero in final result. So you don\\'t need to find 2\\'s, only 5\\'s.\\n\\nSo, O(NlogN) solution solution first, it\\'s easier to understand\\n```\\nvar trailingZeroes = function(n) {\\n    let count = 0;\\n\\t// find 5\\'s in k\\n\\t// return 1 for 10 and 3 for 250 from example;\\n    function getMaxPov5(k) {\\n        let max = 0;\\n        while ((k / 5) % 1 === 0) {\\n            max++;\\n            k /= 5;\\n        }\\n        return max;\\n    }\\n\\t// check only multipliers we can divide by 5\\n    for (let i = 5; i <= n; i += 5) {\\n        count += getMaxPov5(i);\\n    }\\n    return count;\\n};\\n```\\nO(logN) solution\\n```\\nvar trailingZeroes = function(n) {\\n    let count = 0;\\n    \\n\\t// first iteration: find quantity of numbers divisible by 5\\n\\t// second iteration: find quantity of numbers divisible by 25. It is numbers from first iteration / 5. 25 = 5*5,\\n\\t// but we counted first 5 in first iteration, so we add only one 5 for every number divisible by 25.\\n\\t// etc for 125, 625 and so on\\n    while (n) {\\n        n = Math.floor(n / 5);\\n        count += n;\\n    }\\n    return count;\\n};\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar trailingZeroes = function(n) {\\n    let count = 0;\\n\\t// find 5\\'s in k\\n\\t// return 1 for 10 and 3 for 250 from example;\\n    function getMaxPov5(k) {\\n        let max = 0;\\n        while ((k / 5) % 1 === 0) {\\n            max++;\\n            k /= 5;\\n        }\\n        return max;\\n    }\\n\\t// check only multipliers we can divide by 5\\n    for (let i = 5; i <= n; i += 5) {\\n        count += getMaxPov5(i);\\n    }\\n    return count;\\n};\\n```\n```\\nvar trailingZeroes = function(n) {\\n    let count = 0;\\n    \\n\\t// first iteration: find quantity of numbers divisible by 5\\n\\t// second iteration: find quantity of numbers divisible by 25. It is numbers from first iteration / 5. 25 = 5*5,\\n\\t// but we counted first 5 in first iteration, so we add only one 5 for every number divisible by 25.\\n\\t// etc for 125, 625 and so on\\n    while (n) {\\n        n = Math.floor(n / 5);\\n        count += n;\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1423005,
                "title": "super-easy-4-line-of-code-100-faster",
                "content": "**Please Upvote**\\n\\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int ans=0;\\n        while(n/5>=1){\\n            ans+=(n/5);\\n            n/=5;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int ans=0;\\n        while(n/5>=1){\\n            ans+=(n/5);\\n            n/=5;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1290809,
                "title": "very-easy-python-solution",
                "content": "The solution is based on the following idea:\\nevery number 5k: 5k<=n give a zero. \\nHere we count all numbers less or equal n which are multiples of 5, then multiples of 25 (they give 00) etc.\\n```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        #n < 10000\\n        res = 0\\n        while n > 0:\\n            res += n//5\\n            n = n//5\\n        return(res)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        #n < 10000\\n        res = 0\\n        while n > 0:\\n            res += n//5\\n            n = n//5\\n        return(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1266799,
                "title": "one-line-c-solution-o-1-time-and-space-complexity",
                "content": "In this method we add ***[n/(powers of 5 less than given range of nos)].***\\nTherefore, here the range of n was 10000, thus as (5^6 > 10000) & (5^5 < 10000) thus we will divide n by powers of 5 until 5th power and add them to get the answer. \\n*This method clicked to me when I wrote different values of factorial together and saw the pattern in their trailing zeros.*\\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        return n/5 + n/25 + n/125 + n/625 + n/3125; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        return n/5 + n/25 + n/125 + n/625 + n/3125; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1258493,
                "title": "weeb-explains-python-math",
                "content": "\\tclass Solution:\\n\\t\\tdef trailingZeroes(self, n: int) -> int:\\n\\t\\t\\tcount = 0\\n\\n\\t\\t\\twhile(n >= 5):\\n\\t\\t\\t\\tn //= 5 # integer division, we don\\'t need decimal numbers\\n\\t\\t\\t\\tcount += n\\n\\n\\t\\t\\treturn count\\nA trailing zero is always produced by prime factors 2 and 5 because 2 * 5 = 10 and 10 has one trailing zero\\n**Example:**\\nn = 5: There is one 5 and 3 2s in prime factors of 5! (2 * 2 * 2 * 3 * 5). So a count of trailing 0s is 1.\\nn = 11: There are two 5s and eight 2s in prime factors of 11! (2^8 * 3^4 * 5^2 * 7). So the count of trailing 0s is 2.\\n\\nif u noticed, the number of 5s is always lower than the number of 2s. Thus, we just need to find the number of 5s by dividing the number with 5\\n\\nAnyways, its time for some anime recommendations\\nTry watching **Dagashi Kashi**\\n\\n# Episodes: 24 (2 seasons)\\n# Genres: Comedy, Shounen\\n\\nFun anime, if ur feeling down, just try out this anime.\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef trailingZeroes(self, n: int) -> int:\\n\\t\\t\\tcount = 0\\n\\n\\t\\t\\twhile(n >= 5):\\n\\t\\t\\t\\tn //= 5 # integer division, we don\\'t need decimal numbers\\n\\t\\t\\t\\tcount += n\\n\\n\\t\\t\\treturn count\\nA trailing zero is always produced by prime factors 2 and 5 because 2 * 5 = 10 and 10 has one trailing zero\\n**Example:**\\nn = 5: There is one 5 and 3 2s in prime factors of 5! (2 * 2 * 2 * 3 * 5). So a count of trailing 0s is 1.\\nn = 11: There are two 5s and eight 2s in prime factors of 11! (2^8 * 3^4 * 5^2 * 7). So the count of trailing 0s is 2.\\n\\nif u noticed, the number of 5s is always lower than the number of 2s. Thus, we just need to find the number of 5s by dividing the number with 5\\n\\nAnyways, its time for some anime recommendations\\nTry watching **Dagashi Kashi**\\n\\n# Episodes: 24 (2 seasons)\\n# Genres: Comedy, Shounen\\n\\nFun anime, if ur feeling down, just try out this anime.\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1249892,
                "title": "java-math-based-approach-with-proper-explanation",
                "content": "*Attached the code below in case you just want that, and none of the BS written down*\\n\\nYou must know that every number can be broken down in a multiplication of prime numbers, called it\\'s prime factors.\\nSo, just assume we have this number 25 * 22. How many trailing zeros would it have?\\n\\nThe answer lies in it\\'s prime factors. \\n25 = 5 * 5\\n22 = 2 * 11\\n\\nA number will have a trailing zero, if and only if it has 10 as a factor, and for it to have 10 as a factor, it must have a pair of 2 and 5.\\nIn our above example, we see just one pair of 2 and 5, and hence 25 * 22 will have just one ttailing zero!\\n\\nHow does it apply to a factorial? Well, 5! = 5 * 4 * 3 * 2 * 1 = 5 * (2 * 2) * 3 * 2 * 1 => just one pair of 2 and 5 again, and so one trailing zero.\\n\\nNoticed something? The number of 5 will always be less than the number of 2. So if we can find our the number of 5 amongst the prime factors of a number, that would give us the amount of trailing zeros.\\n\\nThe big question though is how the hell do we find out all the prime factors of 1234! . I mean we can\\'t do that, right?\\nSo we have this formula. To find the highest power of a prime factor in a factorial.\\n\\nHighest power of X(a prime number) in N! = [N/X] + [N/(X.X)] + [N / (X.X.X)] + . . . . + 0\\n\\nHighest power of 5 in 1234! ? \\n\\n1234/5 = 246\\n246/5   = 49\\n49/5     = 9\\n9/5       = 1\\n1/5       = 0\\n\\n246 + 49 + 9 + 1 = 305. Thus 1234! have 305 trailing zeros!\\n\\nHope that helped you, and hope you learned something.  \\n\\nclass Solution {\\n\\n    public int trailingZeroes(int n) \\n    {\\n        int ans = 0;\\n        \\n        while (n/5 > 0) \\n        {\\n            ans += n/5;            \\n            n /= 5;\\n        }\\n        \\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int trailingZeroes(int n) \\n    {\\n        int ans = 0;\\n        \\n        while (n/5 > 0) \\n        {\\n            ans += n/5;            \\n            n /= 5;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 995003,
                "title": "fast-23ms-python3-in-o-log-n-time",
                "content": "For the reasoning behind this see: https://www.purplemath.com/modules/factzero.htm\\n```\\n        powers_of_five = 5\\n    \\n        trailing_zeros = 0\\n        while powers_of_five <= n:\\n            trailing_zeros += n // powers_of_five\\n            powers_of_five *= 5\\n\\n        return trailing_zeros \\n```",
                "solutionTags": [],
                "code": "```\\n        powers_of_five = 5\\n    \\n        trailing_zeros = 0\\n        while powers_of_five <= n:\\n            trailing_zeros += n // powers_of_five\\n            powers_of_five *= 5\\n\\n        return trailing_zeros \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 863845,
                "title": "20ms-o-log-5-n-python-solution-beats-99-1",
                "content": "trailing zeroes will occur when 5 multiply by 2. So after every 5 we get 1 more zero. \\n```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        if n == 0:\\n            return 0\\n        count = 0\\n        while n:\\n            n //= 5\\n            count += n\\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        if n == 0:\\n            return 0\\n        count = 0\\n        while n:\\n            n //= 5\\n            count += n\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 499428,
                "title": "faster-than-97-100-better-memory",
                "content": "```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        if n<5:\\n            return 0\\n        \\n        ans=0\\n        while n!=0: \\n            n=n//5\\n            ans+= n\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        if n<5:\\n            return 0\\n        \\n        ans=0\\n        while n!=0: \\n            n=n//5\\n            ans+= n\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 374912,
                "title": "python",
                "content": "Keep dividing the number by multiples of 5 and add that to the count\\n```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        count, i = 0, 5\\n        while (n/i) >= 1: \\n            count += int(n/i) \\n            i *= 5\\n        return count\\n```\\n\\nIt comes down to primes factors of a number. The number of 2s and 5s you can combine will give the number of trailing zeros. So for example, if you have 10000 as a number the prime factors will be 5^4 x 2^4 will give you 4. For 68750, the prime factors will be 2^1 x 5^5 x 11^1 will give you 1 since you can only combine 2^1 and 5^1.\\n\\nSources Below:\\nhttps://brilliant.org/wiki/trailing-number-of-zeros/\\nhttps://www.geeksforgeeks.org/count-trailing-zeroes-factorial-number/",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        count, i = 0, 5\\n        while (n/i) >= 1: \\n            count += int(n/i) \\n            i *= 5\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 304343,
                "title": "python-16ms-with-explaination-super-easy-to-understand",
                "content": "Zeros come from 10 which is 2*5, and 5>2, so we just need to count how many 5 this factorial has\\n```\\nclass Solution(object):\\n    def trailingZeroes(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        i = 1\\n        out = 0\\n        while n>=5**i:\\n            out+=n//5**i\\n            i+=1\\n        return out\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def trailingZeroes(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        i = 1\\n        out = 0\\n        while n>=5**i:\\n            out+=n//5**i\\n            i+=1\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 303095,
                "title": "java-solution-with-detailed-explanation",
                "content": "```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        //You found yourself how many factors 5 the number n! has: The number of factors 5 is n/5 + n/25 + n/125...  The number of factors 2 is n/2 + n/4 + n/8 ..., then number of factors 103 is n/103 + n/103^2 + n/103^3 ... and so on. (Applied to all prime dividers)\\n        //And because the number of factors 2 is always >= # of factors 5, there are enough factor 2 to pair with the factor 5 in n!, and each factor 5 can thus form a trailing zero(\"10\"). Note that k \"10\"s multiplied together will have k trailing zeros.\\n        //Therefore the problem now becomes counting how many factors 5 are there in n!.(Which can be calculated by our formula above.)\\n        int cnt = 0;\\n        while(n > 0){\\n            n /= 5;\\n            cnt += n;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        //You found yourself how many factors 5 the number n! has: The number of factors 5 is n/5 + n/25 + n/125...  The number of factors 2 is n/2 + n/4 + n/8 ..., then number of factors 103 is n/103 + n/103^2 + n/103^3 ... and so on. (Applied to all prime dividers)\\n        //And because the number of factors 2 is always >= # of factors 5, there are enough factor 2 to pair with the factor 5 in n!, and each factor 5 can thus form a trailing zero(\"10\"). Note that k \"10\"s multiplied together will have k trailing zeros.\\n        //Therefore the problem now becomes counting how many factors 5 are there in n!.(Which can be calculated by our formula above.)\\n        int cnt = 0;\\n        while(n > 0){\\n            n /= 5;\\n            cnt += n;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 206577,
                "title": "java-faster-than-99-82-minimalistic-solution",
                "content": "```\\npublic int trailingZeroes(int n) {\\n\\tint solution = 0;\\n\\twhile(n>0) {\\n\\t\\tsolution += n/5;\\n\\t\\tn/=5;\\n\\t}\\n\\treturn solution; }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int trailingZeroes(int n) {\\n\\tint solution = 0;\\n\\twhile(n>0) {\\n\\t\\tsolution += n/5;\\n\\t\\tn/=5;\\n\\t}\\n\\treturn solution; }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 153554,
                "title": "simplest-c-solution-100",
                "content": "```\\nint trailingZeroes(int n) \\n{\\n    int res = 0;\\n    while (n >= 5)\\n    {\\n        res += n / 5;\\n        n = n / 5;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint trailingZeroes(int n) \\n{\\n    int res = 0;\\n    while (n >= 5)\\n    {\\n        res += n / 5;\\n        n = n / 5;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 152499,
                "title": "python3-100-24-ms",
                "content": "```\\n\\tdef trailingZeroes(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n\\n        Brute force exceeded allowed run time.  To calculate \\n        number of trailing zeros w/o the need to first calculate \\n        the factorial, use this understanding: the number of \\n        trailing zeros can be derived by \"summing how many \\n        fives and powers of five are in the input \\'n\\'.  Ex.\\n        num_of_zeros = n//5 + n//5^2 + n//5^3 + n//5^N ... break when 5^N < n (the input)\\n        4! => 0 \\n        5! => 1 \\n        10! => 2\\n        24! => 4\\n        25! => 5 + 1\\n        50! => 10 + 2\\n        125! => 25 + 5 + 1\\n         ...\\n        \"\"\"\\n        if n < 1:\\n            return 0\\n\\t\\t\\t\\t\\t\\t\\n        num_zeros = 0\\n        pow_of_5 = 5\\n\\t\\t\\t\\t\\n        while pow_of_5 <= n:\\n            num_zeros += n // pow_of_5\\n            pow_of_5 *= 5 \\n\\t\\t\\t\\t\\t\\t\\n        return num_zeros\\n```",
                "solutionTags": [],
                "code": "```\\n\\tdef trailingZeroes(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n\\n        Brute force exceeded allowed run time.  To calculate \\n        number of trailing zeros w/o the need to first calculate \\n        the factorial, use this understanding: the number of \\n        trailing zeros can be derived by \"summing how many \\n        fives and powers of five are in the input \\'n\\'.  Ex.\\n        num_of_zeros = n//5 + n//5^2 + n//5^3 + n//5^N ... break when 5^N < n (the input)\\n        4! => 0 \\n        5! => 1 \\n        10! => 2\\n        24! => 4\\n        25! => 5 + 1\\n        50! => 10 + 2\\n        125! => 25 + 5 + 1\\n         ...\\n        \"\"\"\\n        if n < 1:\\n            return 0\\n\\t\\t\\t\\t\\t\\t\\n        num_zeros = 0\\n        pow_of_5 = 5\\n\\t\\t\\t\\t\\n        while pow_of_5 <= n:\\n            num_zeros += n // pow_of_5\\n            pow_of_5 *= 5 \\n\\t\\t\\t\\t\\t\\t\\n        return num_zeros\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 52451,
                "title": "single-line-c-solution",
                "content": "    int trailingZeroes(int n) {\\n        return n==0? 0:n/5+trailingZeroes(n/5);\\n    }",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "    int trailingZeroes(int n) {\\n        return n==0? 0:n/5+trailingZeroes(n/5);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 52473,
                "title": "accepted-4ms-c-solution",
                "content": "    class Solution {  \\n    public:  \\n        int trailingZeroes(int n) {\\n            int zeros = 0;\\n            while (n) zeros += n /= 5;\\n            return zeros;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {  \\n    public:  \\n        int trailingZeroes(int n) {\\n            int zeros = 0;\\n            while (n) zeros += n /= 5;\\n            return zeros;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 52505,
                "title": "this-is-an-accepted-java-solution-but-can-it-run-in-log-n-time",
                "content": "    public class Solution {\\n    public int trailingZeroes(int n) {\\n        int result = 0;\\n        while(n > 1)\\n        {\\n            n/=5;\\n            result += n;\\n            \\n        }\\n        return result;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int trailingZeroes(int n) {\\n        int result = 0;\\n        while(n > 1)\\n        {\\n            n/=5;\\n            result += n;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 52507,
                "title": "more-test-cases-needed",
                "content": "when 'n >=1808548329' solutions using multiply like below will get overflow and output wrong answer.\\n(5^13 = 1220703125 < 2^31, but 5^14 = 6103515625 > 2^32 and 6103515625 % 2^32 = 1808548329 < 2 ^31)\\n\\n    for( int i = 5; n >= i; i *= 5 ) .....",
                "solutionTags": [],
                "code": "when 'n >=1808548329' solutions using multiply like below will get overflow and output wrong answer.\\n(5^13 = 1220703125 < 2^31, but 5^14 = 6103515625 > 2^32 and 6103515625 % 2^32 = 1808548329 < 2 ^31)\\n\\n    for( int i = 5; n >= i; i *= 5 ) .....",
                "codeTag": "Unknown"
            },
            {
                "id": 3976872,
                "title": "one-line-code-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is basic mathematical approach in which we count the number of 5\\'s in the given number as it contribute to zeros in the number.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        return n/5+n/25+n/125+n/3125+n/625+n/15625;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        return n/5+n/25+n/125+n/3125+n/625+n/15625;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3769853,
                "title": "easy-java-solution-beats-100-notebook-explanation",
                "content": "# Intuition\\n![20230715_225642 (1).jpg](https://assets.leetcode.com/users/images/c791ea20-6c2a-42f1-8ea1-e5348786814a_1689442153.2552214.jpeg)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        int count=0;\\n        while(n%5!=n){\\n            count+=(n/5);\\n            n=n/5;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        int count=0;\\n        while(n%5!=n){\\n            count+=(n/5);\\n            n=n/5;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737415,
                "title": "log-n-solution-beats-100-0ms-runtime",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(logn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n       int ans=0;\\n       while(n/5){\\n           ans+=n/5;\\n           n/=5;\\n       }\\n       return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n       int ans=0;\\n       while(n/5){\\n           ans+=n/5;\\n           n/=5;\\n       }\\n       return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3641732,
                "title": "c-easy-two-line-code-recursion-100-faster",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        if(n==0)return 0;\\n        return (n/5) + trailingZeroes(n/5);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        if(n==0)return 0;\\n        return (n/5) + trailingZeroes(n/5);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3635415,
                "title": "100-beats-and-easy-to-understand",
                "content": "# Intuition\\nto find the no of trailing zeros only need to find the no of 5\\'s in the given number and add their frequency that yous answeer.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int ans=0;\\n        while(n){\\n            ans+=n/5;\\n            n=n/5;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int ans=0;\\n        while(n){\\n            ans+=n/5;\\n            n=n/5;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618594,
                "title": "easy-5-lines-beats-100-python-explained",
                "content": "# Intuition\\nIn the multiplication process, trailing zeroes are generated by the product of 5 or its multiples, such as 10, 15, 20, and so on. Initially, it seems like we can simply return num/5 to count the number of trailing zeroes.\\n\\nHowever, this approach fails when we encounter numbers like 25. For example, if we divide 25 by 5, we only consider one factor of 5, but the actual number of trailing zeroes is 6 (25 = 5 * 5). To account for this, we need to divide by 5 and then by 25.\\n\\nThis problem occurs with numbers like 125, 625, and so on. To handle this, we need to loop and divide the number by increasing powers of 5 until the division result is less than 5.\\n\\nThe updated solution can be summarized as follows:\\n\\nInitialize a variable, count, to 0.\\nIterate while num is greater than or equal to 5.\\nWithin the loop, divide num by 5 and add the quotient to count.\\nUpdate num to be the quotient.\\nFinally, return the value of count as the number of trailing zeroes.\\nI hope this clarifies the solution. Let me know if you have any further questions!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def trailingZeroes(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        c,i=0,5\\n        while i<=n:\\n            c+=n/i\\n            i*=5\\n        return c\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def trailingZeroes(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        c,i=0,5\\n        while i<=n:\\n            c+=n/i\\n            i*=5\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608509,
                "title": "2-methods-o-n-o-log5n",
                "content": "```\\n// method 1 : o(n)\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int dp[10010][4];\\n        memset(dp, 0, sizeof(dp));\\n        \\n        for(int i=1; i<= n; i++){\\n            // dp[i][0]= i%2==0 ? dp[i/2][0]+1 : 0;  //num of 2 in i\\n            // dp[i][1]= dp[i-1][1] + dp[i][0];      // sum of 2 till i\\n            \\n            dp[i][2]= i%5==0 ? dp[i/5][2]+1 : 0;  //num of 5 in i\\n            dp[i][3]= dp[i-1][3] + dp[i][2];      // sum of 5 till i\\n        }\\n        \\n        // for(int i=0; i<1010; i++) printf(\"%d : %d, %d, %d, %d \\\\n\", i, dp[i][0],dp[i][1], dp[i][2], dp[i][3]);\\n        \\n        // return min(dp[n][1], dp[n][3]);\\n\\t\\t// we don\\'t need to count 2 coz 2 will always be bigger in count\\n        return dp[n][3];\\n\\n    }\\n};\\n```\\n\\n\\n```\\n// mothod 2: log5n , https://youtu.be/wkvVdggCSeo \\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int ans=0;\\n        \\n        while(n){\\n            ans+= n/5;\\n            n/=5;  //or  5 = 5^2, then 5^3 tthen 5^4 ........... we devided n by 5 to remove overflow\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nNOTE this formula for future reference ( here n/x means float value of n/x )\\n![image](https://assets.leetcode.com/users/images/7c90499e-5692-4273-b408-aef8dd3fb063_1686129284.9588723.png)\\n",
                "solutionTags": [],
                "code": "```\\n// method 1 : o(n)\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int dp[10010][4];\\n        memset(dp, 0, sizeof(dp));\\n        \\n        for(int i=1; i<= n; i++){\\n            // dp[i][0]= i%2==0 ? dp[i/2][0]+1 : 0;  //num of 2 in i\\n            // dp[i][1]= dp[i-1][1] + dp[i][0];      // sum of 2 till i\\n            \\n            dp[i][2]= i%5==0 ? dp[i/5][2]+1 : 0;  //num of 5 in i\\n            dp[i][3]= dp[i-1][3] + dp[i][2];      // sum of 5 till i\\n        }\\n        \\n        // for(int i=0; i<1010; i++) printf(\"%d : %d, %d, %d, %d \\\\n\", i, dp[i][0],dp[i][1], dp[i][2], dp[i][3]);\\n        \\n        // return min(dp[n][1], dp[n][3]);\\n\\t\\t// we don\\'t need to count 2 coz 2 will always be bigger in count\\n        return dp[n][3];\\n\\n    }\\n};\\n```\n```\\n// mothod 2: log5n , https://youtu.be/wkvVdggCSeo \\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int ans=0;\\n        \\n        while(n){\\n            ans+= n/5;\\n            n/=5;  //or  5 = 5^2, then 5^3 tthen 5^4 ........... we devided n by 5 to remove overflow\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565150,
                "title": "0ms-beats-100-short-and-easy-c-solution",
                "content": "# Intuition\\n\\n- To get trailing zeroes we need to know how many times can the number be divided by 10.\\n- But doing it directly would lead to TLE. So what do we do now.\\n- We can simply count how many 5\\'s can be extracted from the given number.\\n\\n# Approach\\n- First divide the number by 5 and add it to $$sum$$.\\n- Now divide the number by 5.\\n- Repeat this process until the number is less than 5.\\n\\n# Complexity\\n- Time complexity: \\n$$O($$log$$5$$n$$)$$\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int sum=0;\\n        while(n >= 5){\\n            sum += (n/5);\\n            n /= 5;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int sum=0;\\n        while(n >= 5){\\n            sum += (n/5);\\n            n /= 5;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3353340,
                "title": "python-beats-99-43",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(log(n))$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        count = 0\\n        log = 5\\n        while n >= log:\\n            count += n//log\\n            log *= 5\\n        return count\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        count = 0\\n        log = 5\\n        while n >= log:\\n            count += n//log\\n            log *= 5\\n        return count\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332578,
                "title": "0-ms-4-line-solution-very-simple-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        int result = 0;\\n        //count all the 5\\'s and store that \\n        for(int i = 5 ; i<=n; i*=5)\\n            result += n / i;\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        int result = 0;\\n        //count all the 5\\'s and store that \\n        for(int i = 5 ; i<=n; i*=5)\\n            result += n / i;\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268671,
                "title": "easy-python-solution-using-dp-it-takes-o-n-space-because-of-dp",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def trailingZeroes(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        dp=[1]*(n+1)\\n        for i in range(2,n+1):\\n            dp[i]=dp[i-1]*i\\n        st=str(dp[-1])\\n        val=st.rstrip(\"0\")\\n        return len(st)-len(val)\\n```",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution(object):\\n    def trailingZeroes(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        dp=[1]*(n+1)\\n        for i in range(2,n+1):\\n            dp[i]=dp[i-1]*i\\n        st=str(dp[-1])\\n        val=st.rstrip(\"0\")\\n        return len(st)-len(val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254786,
                "title": "simplest-and-easiest-approach-c",
                "content": "# Simplest Solution\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int trailingZeroes(int n) {\\n        int a=0;\\n        while(n){\\n            n/=5;\\n            a+=n;\\n        }\\n        return a;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int trailingZeroes(int n) {\\n        int a=0;\\n        while(n){\\n            n/=5;\\n            a+=n;\\n        }\\n        return a;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3236149,
                "title": "beats-100-0ms-detailed-easy-explanation-java-python3-c-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe contributing factors to zero are two and five. For any number `n` the number of two appearing in `n!` will always be greater than the number of fives. Hence we need to count the number of fives.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n![download (1).png](https://assets.leetcode.com/users/images/19c67836-61d4-4d10-b0fd-8f9d28ec2875_1677498523.377247.png)\\n\\n![download.png](https://assets.leetcode.com/users/images/5f8ad369-51de-46dc-8d45-8bbdca1ed1be_1677498463.9279845.png)\\n\\n# Explanation\\nHere is an explanation of how the function works:\\n\\n1. Initialize a variable called `zeros` to 0. This variable will be used to keep track of the number of trailing zeros in the factorial of `n`.\\n\\n1. Enter a while loop that will continue as long as `n` is greater than 0.\\n\\n1. In each iteration of the loop, calculate the number of factors of 5 in `n` by dividing `n` by 5 and adding the result to `zeros`. This is because each factor of 5 contributes to a trailing zero in the factorial of n.\\n\\n1. Divide n by 5 to remove all factors of 5 from n. This is because we have already counted them in step 3, and we only need to count each factor of 5 once.\\n\\n1. Repeat steps 3-4 until `n` is no longer greater than 0.\\n\\n1. Return the final value of `zeros`.\\n# Complexity\\n- Time complexity:  O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this function is O(log n), because we divide `n` by 5 in each iteration of the while loop, reducing its value by a factor of 5 each time. This means that the number of iterations required is proportional to the logarithm of `n`.\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this function is O(1), because we only use a constant amount of extra space to store the `zeros` variable. Regardless of the input value of `n`, the amount of extra space used by the function remains the same. Therefore, the space complexity is constant, or O(1).\\n# Java\\n```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        int zeros = 0;\\n        while (n > 0) {\\n        zeros += n / 5;\\n        n /= 5;\\n        }\\n        return zeros;\\n    }\\n}\\n```\\n# C\\n```\\nint trailingZeroes(int n) {\\n    int zeros = 0;\\n    while (n > 0) {\\n        zeros += n / 5;\\n        n /= 5;\\n    }\\n    return zeros;\\n}\\n\\n```\\n# C++\\n```\\nint trailingZeroes(int n) {\\n    int zeros = 0;\\n    while (n > 0) {\\n        zeros += n / 5;\\n        n /= 5;\\n    }\\n    return zeros;\\n}\\n\\n```\\n# Python3\\n```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        zeros = 0\\n        while n > 0:\\n            zeros += n // 5\\n            n //= 5\\n        return zeros\\n\\n```\\n---\\n# Connect\\nLinkedIn : www.linkedin.com/in/akashjana\\n---\\n#### Please consider upvoting if you find this helpful. Thank You :)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        int zeros = 0;\\n        while (n > 0) {\\n        zeros += n / 5;\\n        n /= 5;\\n        }\\n        return zeros;\\n    }\\n}\\n```\n```\\nint trailingZeroes(int n) {\\n    int zeros = 0;\\n    while (n > 0) {\\n        zeros += n / 5;\\n        n /= 5;\\n    }\\n    return zeros;\\n}\\n\\n```\n```\\nint trailingZeroes(int n) {\\n    int zeros = 0;\\n    while (n > 0) {\\n        zeros += n / 5;\\n        n /= 5;\\n    }\\n    return zeros;\\n}\\n\\n```\n```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        zeros = 0\\n        while n > 0:\\n            zeros += n // 5\\n            n //= 5\\n        return zeros\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224151,
                "title": "beats-100-c-soluton-with-explanation",
                "content": "# Approach\\n1.Approach/method\\n![no_of_zero2.jpeg](https://assets.leetcode.com/users/images/4df19918-3e68-4f76-895d-e3100c83223b_1677219863.0379024.jpeg)\\n\\n\\n2.Approach/method\\n1.In second approach we simply divide the n! number by 5\\n2.After that For every 5*5.....(or 5^m,m=2,3,4....)(less n) multiple we get extra zero of n!/5^m..\\n3.Add the both zero(step1+step2)\\n\\nexample \\n1.25!\\nnumber of zero=25/5 + 25/25\\n               5+1=6\\n2.50!\\nnumber of zero=50/5 + 50/25\\n               10 + 2= 12\\n4.150!\\nnumber of zero=  150/5 + 150/25 + 150/125 (125 is less then 150  and 5^3=125(5^m))  \\n           30+6+1=37\\n\\n5.1000!\\n1000/5 + 1000/25(5^2) + 1000/125(5^3) +1000/625(5^4)\\n200+40+8+1=249\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(logn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//1st method\\n\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int count_zero = 0;\\n        while(n>=5)\\n        {\\n         int quotient=n/5;\\n         n=quotient;\\n         count_zero=count_zero + quotient;\\n        }\\n     return count_zero;\\n    }\\n};\\n\\n//2nd methods\\n//1.In second approach we simply divide the n! number by 5\\n//2.For every 5^m... multiple we get extra zero of n!/5^m..(m=2,3,4...)\\n//3.Add the both zero(step1+step2)\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int count_zero = 0;\\n        int i = 5;\\n        while(i <= n) {\\n            count_zero += n / i;\\n            i =i*5;\\n        }\\n    return count_zero;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//1st method\\n\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int count_zero = 0;\\n        while(n>=5)\\n        {\\n         int quotient=n/5;\\n         n=quotient;\\n         count_zero=count_zero + quotient;\\n        }\\n     return count_zero;\\n    }\\n};\\n\\n//2nd methods\\n//1.In second approach we simply divide the n! number by 5\\n//2.For every 5^m... multiple we get extra zero of n!/5^m..(m=2,3,4...)\\n//3.Add the both zero(step1+step2)\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int count_zero = 0;\\n        int i = 5;\\n        while(i <= n) {\\n            count_zero += n / i;\\n            i =i*5;\\n        }\\n    return count_zero;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3128401,
                "title": "simple-intuition-python-3-solution-23ms-faster-than-98-99",
                "content": "# Intuition\\nThe ZERO comes from 10.\\nThe 10 comes from 2 x 5\\nAnd we need to account for all the products of 5 and 2, like 4\\xD75 = 20 \\u2026\\nSo, if we take all the numbers with 5 as a factor, we will have plenty of even numbers to pair with them to get factors of 10.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(logN)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        count=0\\n        while n>=5:\\n            n//=5\\n            count+=n\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        count=0\\n        while n>=5:\\n            n//=5\\n            count+=n\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049596,
                "title": "c-easy-solution-0ms-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:log(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        if(n<5) return 0;\\n\\n        int value=5, count=1;\\n        while(value*5<=n){\\n            value=value*5;\\n            count++;\\n        }\\n\\n        int ans=0;\\n        int covered=0;\\n        while(count!=0){\\n            int multiples=n/value;\\n            int add=(multiples-covered)*count;\\n            covered=multiples;\\n            ans+=add;\\n            value/=5;\\n            count--;           \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        if(n<5) return 0;\\n\\n        int value=5, count=1;\\n        while(value*5<=n){\\n            value=value*5;\\n            count++;\\n        }\\n\\n        int ans=0;\\n        int covered=0;\\n        while(count!=0){\\n            int multiples=n/value;\\n            int add=(multiples-covered)*count;\\n            covered=multiples;\\n            ans+=add;\\n            value/=5;\\n            count--;           \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3007098,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:Depends on the number of factors of 5 in n.\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int cnt=0;\\n        while(n){\\n            n/=5;\\n            cnt+=n;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int cnt=0;\\n        while(n){\\n            n/=5;\\n            cnt+=n;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3006281,
                "title": "python-solution-o-2-n-for-beginner-understanding",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* Disclaimer : This solution is not in Logarithmic Time. This is a beginners solution. I would highly suggest to do it in Logarithmic Time Complexity because it has a completely different approach.\\n* First, simply call the factorial function which calculates the factorial of an number.\\n* Arr is an array of integers of factorial.\\n* Then simply count the number of consecutive zeroes from last and return it.\\n\\n# Complexity\\n- Time complexity: O(2*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    \\n    def fact(self, n:int):\\n        if n == 1 or n == 0: \\n            return 1\\n        return n * self.fact(n-1)\\n\\n    def trailingZeroes(self, n: int) -> int:\\n        factorial = self.fact(n)\\n        arr = [int(x) for x in str(factorial)]\\n        count = 0\\n        for i in reversed(arr):\\n            if i==0:\\n                count += 1\\n            else:\\n                break\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def fact(self, n:int):\\n        if n == 1 or n == 0: \\n            return 1\\n        return n * self.fact(n-1)\\n\\n    def trailingZeroes(self, n: int) -> int:\\n        factorial = self.fact(n)\\n        arr = [int(x) for x in str(factorial)]\\n        count = 0\\n        for i in reversed(arr):\\n            if i==0:\\n                count += 1\\n            else:\\n                break\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2921012,
                "title": "factorial-trailing-zeroes-beats-100-runtime-0-ms-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        // if(n==0)\\n        //  return 0;\\n        // int sum=0;\\n        // while(n/5>0)\\n        // {\\n        //     sum=sum+(n/5);\\n        //     n=n/5;\\n        // }\\n        // return sum;\\n        int sum=0;\\n        while(n>0)\\n        {\\n            n=n/5;\\n            sum = sum + n;\\n         \\n        }\\n        return sum;\\n          \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        // if(n==0)\\n        //  return 0;\\n        // int sum=0;\\n        // while(n/5>0)\\n        // {\\n        //     sum=sum+(n/5);\\n        //     n=n/5;\\n        // }\\n        // return sum;\\n        int sum=0;\\n        while(n>0)\\n        {\\n            n=n/5;\\n            sum = sum + n;\\n         \\n        }\\n        return sum;\\n          \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2872358,
                "title": "simple-c-solution-o-log-n-must-check",
                "content": "\\n\\n**Solution:**\\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int count = 0;\\n\\n        for(int i = 5; i<=n;i=i*5)\\n        {\\n            count = count + n/i;\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n----\\n\\n**Analysis:**\\n\\n**Time Complexity:** ```O(log n)```\\n\\nwe have the 5^k <=n\\n           \\u2234 5^k = n\\n               k = log n base 5\\n\\n**Space Complexity:** ```O(1)```\\n\\n---\\n\\nIf this solution help you then please ```UPVOTE```.\\nTill then **Keep Learning, Keep Exploring, Keep Growing!!**\\n\\n**Thank You !!**\\n\\n\\n----",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int count = 0;\\n\\n        for(int i = 5; i<=n;i=i*5)\\n        {\\n            count = count + n/i;\\n        }\\n        return count;\\n    }\\n};\\n```\n```O(log n)```\n```O(1)```\n```UPVOTE```",
                "codeTag": "Java"
            },
            {
                "id": 2789564,
                "title": "c-simple-math-method-to-find-number-of-trailing-zeroes",
                "content": "```\\nint trailingZeroes(int n) {\\n        \\n        int ans = 0, i = 1;\\n        //store [n/5^i] in sum till it becomes zeros\\n        while(pow(5,i) <= n) {\\n            ans += n/pow(5,i);\\n            i++;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nint trailingZeroes(int n) {\\n        \\n        int ans = 0, i = 1;\\n        //store [n/5^i] in sum till it becomes zeros\\n        while(pow(5,i) <= n) {\\n            ans += n/pow(5,i);\\n            i++;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2788540,
                "title": "1-line-code-0ms-solution-simple-approach",
                "content": "# Intuition\\nIt\\'s just to notice that on multiplying with which number we will get a trailing zero\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nEvery time we multiply with 5 or powers of 5(25,125,etc) we\\'ll get a trailing zero.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        return (n/5)+(n/25)+(n/125)+(n/625)+(n/3125);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        return (n/5)+(n/25)+(n/125)+(n/625)+(n/3125);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784206,
                "title": "c-solution-iterative-approach-faster-than-100-of-c-submissions",
                "content": "```\\nint trailingZeroes(int n){\\n    int div = 5, zeros = 0;\\n    while(n/div != 0){\\n        zeros += n/div;\\n        div *= 5;\\n    }\\n    return zeros;\\n}\\n```",
                "solutionTags": [
                    "Math",
                    "Recursion"
                ],
                "code": "```\\nint trailingZeroes(int n){\\n    int div = 5, zeros = 0;\\n    while(n/div != 0){\\n        zeros += n/div;\\n        div *= 5;\\n    }\\n    return zeros;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2783986,
                "title": "c-solution-1-line-recursive-approach-faster-than-100-of-c-submissions",
                "content": "```\\nint trailingZeroes(int n){\\n    return (n != 0) ? n/5 + trailingZeroes(n/5) : 0;\\n}\\n```",
                "solutionTags": [
                    "Math",
                    "Recursion"
                ],
                "code": "```\\nint trailingZeroes(int n){\\n    return (n != 0) ? n/5 + trailingZeroes(n/5) : 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2751198,
                "title": "python3-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        f=1\\n        if n==0 and n==1:\\n            return 0\\n        for i in range(1,n+1):\\n            f*=i\\n        s=str(f)[::-1]\\n        count=0\\n        for i in s:\\n            if i==\"0\":\\n                count+=1\\n            else:\\n                break\\n        return count\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        f=1\\n        if n==0 and n==1:\\n            return 0\\n        for i in range(1,n+1):\\n            f*=i\\n        s=str(f)[::-1]\\n        count=0\\n        for i in s:\\n            if i==\"0\":\\n                count+=1\\n            else:\\n                break\\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2525213,
                "title": "o-1-time-complexity-one-liner-faster-than-100-easiest-solution-ace-solution",
                "content": "```\\n int trailingZeroes(int n) { \\n      return n/5+n/25+n/125+n/625+n/3125;\\n        }",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n int trailingZeroes(int n) { \\n      return n/5+n/25+n/125+n/625+n/3125;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 2477605,
                "title": "fast-and-easy-solution-in-java-c",
                "content": "```\\npublic int trailingZeroes(int n) {\\n        int ans=0;\\n     \\n        ans+=n/5;\\n        ans+=n/25;\\n        ans+=n/125;\\n        ans+=n/625;\\n        ans+=n/3125;\\n        ans+=n/15625;\\n\\t\\t\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int trailingZeroes(int n) {\\n        int ans=0;\\n     \\n        ans+=n/5;\\n        ans+=n/25;\\n        ans+=n/125;\\n        ans+=n/625;\\n        ans+=n/3125;\\n        ans+=n/15625;\\n\\t\\t\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2453749,
                "title": "runtime-0-ms-faster-than-100-easy-c-solution",
                "content": "![image](https://assets.leetcode.com/users/images/88ba6a0e-25fc-4500-9615-a38e5fdab180_1661003156.9793484.png)\\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int ans = 0, i = 5;\\n        while(n >= i){\\n            ans += (n/i);\\n            i *= 5;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int ans = 0, i = 5;\\n        while(n >= i){\\n            ans += (n/i);\\n            i *= 5;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2342451,
                "title": "c-power-of-5",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int x=5;\\n        int ans=0;\\n        while(x<=n){\\n            ans+=n/x;\\n            x*=5;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int x=5;\\n        int ans=0;\\n        while(x<=n){\\n            ans+=n/x;\\n            x*=5;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2317387,
                "title": "easy-3-line-sol-100-fast-o-logn",
                "content": "**if u find it useful and good for understanding plz upvote**\\u2B06\\n\\n# Logic :\\n\\n**trailing 0s** in n!= count of` 5s in prime factors of n!`\\n\\n**Ex.** 10!=3628800 it\\'s prime factors are 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 5, 5, 7 here **5 are 2 times means 2 trailing zero.**\\n\\n# Code:\\n\\n```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        \\n    int count=0;\\n    for(int i=5; n/i>=1;i*=5){\\n       count+=n/i;\\n    }\\n        return count;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        \\n    int count=0;\\n    for(int i=5; n/i>=1;i*=5){\\n       count+=n/i;\\n    }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2312037,
                "title": "0-ms-solution-faster-than-100",
                "content": "int trailingZeroes(int num) {\\n        int denom = 5,  zeroes = 0;\\n        while(num>=denom)\\n        {  \\n            zeroes+=(num/denom);\\n            denom*=5; \\n        }\\n        return zeroes;\\n    }\\n\\t\\n\\t// Every time you divide the given number with denom by updating denom by denom*5 and store the num/denom in zeroes count and return that\\'s it :)\\n\\t\\n\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "int trailingZeroes(int num) {\\n        int denom = 5,  zeroes = 0;\\n        while(num>=denom)\\n        {  \\n            zeroes+=(num/denom);\\n            denom*=5; \\n        }\\n        return zeroes;\\n    }\\n\\t\\n\\t// Every time you divide the given number with denom by updating denom by denom*5 and store the num/denom in zeroes count and return that\\'s it :)\\n\\t\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2195172,
                "title": "java-100-faster-and-92-less-memory",
                "content": "0 will only come in factorial result if there is any pair of 2 * 5 in the products of factorial.\\nFor example : 1 * 2 * 3 * 4 * 5 \\n\\nHere we have single pair of 2 and 5. Number of 2 * 5 pairs means the number times its getting multiplied by 10. Since we get lots of 2 in factorial of higher numbers thus we dont have to worry about 2 and we need to check only number of 5.\\n\\nTherefore number of 5 determines number of trailing zeroes.\\n\\n```\\n public int trailingZeroes(int n) {\\n        int count = 0;\\n        \\n        if(n < 5) {\\n            return 0;\\n        }\\n        \\n        while(n > 1) {\\n            n /= 5;\\n            count += n;\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public int trailingZeroes(int n) {\\n        int count = 0;\\n        \\n        if(n < 5) {\\n            return 0;\\n        }\\n        \\n        while(n > 1) {\\n            n /= 5;\\n            count += n;\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2188758,
                "title": "c-faster-than-100-runtime-0-ms-most-efficient-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int res=0;\\n        for(int i=5;i<=n;i=i*5)\\n            res=res+n/i;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int res=0;\\n        for(int i=5;i<=n;i=i*5)\\n            res=res+n/i;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2186940,
                "title": "c-python-easy-solution",
                "content": "**Python**\\n```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        x=5\\n        zero=0\\n        while ((n//x)>0):\\n            zero+=(n//x)\\n            x*=5\\n        return(zero) \\n```\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int x=5,zero=0;\\n        while((n/x)>0){\\n            zero+=(n/x);\\n            x*=5;\\n        }\\n        return(zero);\\n    }\\n};\\n```\\n**Space Complexity : O(1)\\nTime Complexity : O(logN)**",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        x=5\\n        zero=0\\n        while ((n//x)>0):\\n            zero+=(n//x)\\n            x*=5\\n        return(zero) \\n```\n```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int x=5,zero=0;\\n        while((n/x)>0){\\n            zero+=(n/x);\\n            x*=5;\\n        }\\n        return(zero);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2166652,
                "title": "cpp-easy-code-log-n-solution-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int cnt = 0;\\n        for ( int i = 1 ; i <= n ; i ++){\\n            if ( n / pow ( 5 , i ) <= 0 ) return cnt ;\\n            cnt += ( n / pow( 5 , i ));           \\n        } \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int cnt = 0;\\n        for ( int i = 1 ; i <= n ; i ++){\\n            if ( n / pow ( 5 , i ) <= 0 ) return cnt ;\\n            cnt += ( n / pow( 5 , i ));           \\n        } \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2154528,
                "title": "count-the-number-of-trailing-zeros",
                "content": "Factorial of an integer (n) is obtained simply by multiplying of the numbers from 1 upto n (including n).\\n\\nIts obvious that trailing zeros in any number are because of multiplication by 10. \\n\\nSimilarly, While calculating a factorial, If the number gets multiplied by 10 or prime factors whose products is 10, then it will add a trailing zero at the end. \\n\\nEg: factorial of 6 is 720. (1 trailing zeros).\\n\\n*6! = 1 * 2 * 3 * 4 * 5 * 6\\n\\t= 1 * 2 * 3 * (2 * 2) * 5 * (2 * 3)*\\n\\nIn the above prime factors of numbers multiplied in the factorial, we can observe that there are 2s and 5s. Its clear that 2* 5 = 10.  So the combination of 2s and 5s are bringing in all the trailing zeros. \\n\\nHence, \\n    *number of trailing zeros \\n\\t\\t\\t= min (number of 2s in prime factors, number of 5s in prime factors)*\\n\\nNow, it is clear that all even numbers have a factor 2 but only multiples of 5 like 5, 10, 15, etc.. have a factor 5. So it is clear  that there are more number of 2 than 5 in any set of prime factors of factorial.\\n\\nSo the number of 5s will be the obvious minimum which is rather easy to count and may not require complete factorization as such.\\n\\nFor that, simply count the numbers divisible by 5 from 1 to n. There are some numbers which are multiples of higher powers of 5 and hence have more than one 5s in the prime factors. For that, we can count the numbers that are divisible by each higher powers of 5 upto  n. \\nIn summary,\\n\\n*Number of 5s in the prime factors \\n= Count of numbers divisible by 5 + Count of numbers divisible by 25 + Count of numbers divisible by 125 + ...\\n= floor(n/5) + floor(n/25) + floor(n/125) + floor(n/625) + ... until the number inside paranthesis gets to zero.*\\n\\n\\nIts simple Java Solution would be as follows: \\n\\n```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        \\n        int countZeros=0;\\n        \\n        while(n>0)\\n        {\\n            countZeros += n/5;\\n            n/=5; \\n        }\\n\\n        return countZeros;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        \\n        int countZeros=0;\\n        \\n        while(n>0)\\n        {\\n            countZeros += n/5;\\n            n/=5; \\n        }\\n\\n        return countZeros;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1568387,
                "content": [
                    {
                        "username": "nextsde",
                        "content": "How can we tell from a number, how many trailing zeroes are at the end?\\n\\n10 = 10\\n1200 = 12 x 10 x 10\\n145000 = 145 x 10 x 10 x10\\n\\nFrom above example, we can clearly see number of 10\\'s in a number gives us number of trailing zeros in that number.\\n\\nSo, in our first brute force solution we can calcualte the n! and check how many 10\\'s are in there. That will give us the solution.\\n\\nBut, since n! will become very very large to calculate as n becomes bigger. So, this is not a feasible solution.\\n\\nWhat can we do?\\n\\nLet\\'s build some more intuition to see if we can find out the final hint we need.\\n\\nWhat is the property of 10?\\n\\nWe can get 10 from 2 & 5 (2x5). Can you get 10 in any other way? No.\\n\\nSo, let\\'s break it down further.\\n\\n10 = 2 x 5 [1(2),1(5)]\\n100 = 2 x 2 x 5 x 5 [2(2),2(5)]\\n120 = 2 x 2 x 2 x 3 x 5 [3(2),1(3),1(5)]\\n1200 = 2 x 2 x 2 x 2 x 3 x 5 x 5 [4(2),1(3),2(5)] //2 appears 4 times, 3 appears 1 time, 5 appears 2 times}\\n50 = 2 x 5 x 5 [1(2),2(5)]\\n\\nFrom above you will see, among 5 and 2 whichever appears lowest amount is the count of our trailing zeros.\\nBut for n!, we know we will have more 2\\'s than 5.\\nLet\\'s see an example:\\n5! = 1 x 2 x 3  x 4(2x2) x 5 = [3(2),1(5)]\\n\\nTry writing down couple more example and you will understand. So, in 25! how many 5 will be there?\\n\\n....x5....x10....x15....x20....x25 = x5...x2x5....x3x5....x4x5....x5x5 = 6 , Because 25 itself has 2 5\\'s in it.\\n\\nOk, up till this point we were still analyzing n!.\\n\\nBut we know if n>=5 it will have 5 as a factor.\\n\\nSo, based on our intuition so far.\\n\\nIf n=5 ... there will be 1(5)\\nIf n=10 ... there will be 2(5)\\nIf n=15 ... there will be 3(5)\\nIf n=25 ... there will be 5(5) + 1 (5)\\n\\nNow all we need to do is keep dividing n by 5 and add the result to our existing result until n get to 0.\\n\\nIf you are still having trouble getting the code, see this post https://nextswe.com/leetcode-172-factorial-trailing-zeroes/ . Code is provided at the end of explanation.\\nThanks"
                    },
                    {
                        "username": "naveen12124139",
                        "content": "//just return this\\nreturn n/3125+n/625+n/125+n/25+n/5;"
                    },
                    {
                        "username": "sergei99",
                        "content": "It only gets you to the top in languages with smart enough compilers. I\\'ve got C++ and Java executing at 0ms, but stuck with stupid Python... I guess if there is no library function \"count trailing zeroes in factorial\" written in C, then it\\'s just crawling."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "Hacker !!!!\\n"
                    },
                    {
                        "username": "amit2020cs",
                        "content": "You checked the constraints to count the largest power of 5. Nice intuition"
                    },
                    {
                        "username": "heisenbergknocks",
                        "content": "\\t\\n\\tThis seems long but just read on.\\n\\n\\tThe number of 0s in n! is the number of 10s that can be generated by numbers\\n\\tfrom 1 to n!. 10 is a product of 2 and 5, so we just need to check\\n\\thow many 2x5 are present in n!\\n\\n\\tIf n = 5, then n! = 1x2x3x4x5. There is one 2 and 5 pair present\\n\\tin 5! which can make one 10. So numbers of 0s in 5! is one.\\n\\n\\tIf n = 10, then n! = 1x2x3x4x5x6x7x8x9x10 => this would have two zeros one from the\\n\\t2x5 and one from another 2x5 in 10.\\n\\n\\tIf n = 15, then n! = 1x2x3x4x5x6x7x8x9x10x11x12x13x14x15 => this would have three\\n\\tzeros one from the 2x5 and one from another 2x5 in 10 and one from a 5 in 15 which\\n\\twould give us a 0 by multiplying with any 2 from any even num from 1 to 15.\\n\\n\\tSince there are a lot more 2s than 5s in any n!, we just need to find the\\n\\tnumber of 5s in n! and that will be the answer. Eg.\\n\\n\\t5! -> one 0 as there is only one 5 from 1 to 5.\\n\\t10! -> two 0s as there are two 5s from 1 to 10.\\n\\t15! -> three 0s as there are three 5s from 1 to 10.\\n\\t20! -> four 0s as there are four 5s from 1 to 10.\\n\\n\\tHow to quickly count number of 5s in n!? Use n/5.\\n\\tAssume n = 15, using n / 5 we get 3, this tells us that there are at least\\n\\tthree multiples of 5 present in numbers from 1 to 15 namely\\n\\t5x1 = 5, 5x2 = 10 and 5x3 = 15.\\n\\tSo, we can get the number of 5s in n! and hence the number of 0s in n! using n / 5.\\n\\n\\tBut there is still one issue for numbers like 25, 125,\\n\\t625, which contain more than one 5 as their factor.\\n\\n\\tEg. for 25!, the number of 0s is = number of 0s in 20! + number of 0s which can be generated from 21 to 25\\n\\t= number of 0s in 20! + two 0s as there are two 5s present in 25 which would\\n\\tmultiple with any two 2s and make a 100 and give us 2 zeros.\\n\\t= so 25! has six 0s.\\n\\n\\tBut, going by the original formula we will calculate number of 0s in 25! as\\n\\t25/5 which is 5. So five 0s.\\n\\tNow, what we need to do is just divide this result of 5 again by 5\\n\\twhich gives us a 1 and add it to previous five 0s\\n\\n\\tIntuition: Keep dividing by 5 and adding the result to number of 0s."
                    },
                    {
                        "username": "johngroves",
                        "content": "` return n//5 + self.trailingZeroes(n//5) if n else 0`\\nHelpful background here:\\nhttp://www.purplemath.com/modules/factzero.htm"
                    },
                    {
                        "username": "nangao",
                        "content": "I Can't understand this problem"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "This should be easy, not medium  :)"
                    },
                    {
                        "username": "harsha335",
                        "content": "If you cannot get the intuition, it will be hard."
                    },
                    {
                        "username": "megaman14",
                        "content": "You want to find the number of times 10 goes into n, which means the number of times both 5 and 2 appear. Since we always have more 2\\'s than 5\\'s, to get the answer, we try to find the number of times 5 appears as a factor. This is equivalent to n/5. However, we have to account for the powers of 5: 25, 125, 625... Thus, if we multiply the iterator by 5 each time, ex: n/25, n/125, n/625...we can increment the count and get the answer. Now, all you need to do is to be careful about int overflow"
                    },
                    {
                        "username": "alex86",
                        "content": "Factorial of 0 is 1. "
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "Legitimately once I had example numbers to work with, this was much easier to tell what the pattern was. So here\\'s something in Haskell to print out all the factorials:\\n\\n```hs\\nmodule Main where\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nmain = withFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```\\n\\nor for ghci:\\n\\n```hs\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nwithFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```"
                    },
                    {
                        "username": "jzummo",
                        "content": "https://en.wikipedia.org/wiki/Legendre%27s_formula"
                    }
                ]
            },
            {
                "id": 1574696,
                "content": [
                    {
                        "username": "nextsde",
                        "content": "How can we tell from a number, how many trailing zeroes are at the end?\\n\\n10 = 10\\n1200 = 12 x 10 x 10\\n145000 = 145 x 10 x 10 x10\\n\\nFrom above example, we can clearly see number of 10\\'s in a number gives us number of trailing zeros in that number.\\n\\nSo, in our first brute force solution we can calcualte the n! and check how many 10\\'s are in there. That will give us the solution.\\n\\nBut, since n! will become very very large to calculate as n becomes bigger. So, this is not a feasible solution.\\n\\nWhat can we do?\\n\\nLet\\'s build some more intuition to see if we can find out the final hint we need.\\n\\nWhat is the property of 10?\\n\\nWe can get 10 from 2 & 5 (2x5). Can you get 10 in any other way? No.\\n\\nSo, let\\'s break it down further.\\n\\n10 = 2 x 5 [1(2),1(5)]\\n100 = 2 x 2 x 5 x 5 [2(2),2(5)]\\n120 = 2 x 2 x 2 x 3 x 5 [3(2),1(3),1(5)]\\n1200 = 2 x 2 x 2 x 2 x 3 x 5 x 5 [4(2),1(3),2(5)] //2 appears 4 times, 3 appears 1 time, 5 appears 2 times}\\n50 = 2 x 5 x 5 [1(2),2(5)]\\n\\nFrom above you will see, among 5 and 2 whichever appears lowest amount is the count of our trailing zeros.\\nBut for n!, we know we will have more 2\\'s than 5.\\nLet\\'s see an example:\\n5! = 1 x 2 x 3  x 4(2x2) x 5 = [3(2),1(5)]\\n\\nTry writing down couple more example and you will understand. So, in 25! how many 5 will be there?\\n\\n....x5....x10....x15....x20....x25 = x5...x2x5....x3x5....x4x5....x5x5 = 6 , Because 25 itself has 2 5\\'s in it.\\n\\nOk, up till this point we were still analyzing n!.\\n\\nBut we know if n>=5 it will have 5 as a factor.\\n\\nSo, based on our intuition so far.\\n\\nIf n=5 ... there will be 1(5)\\nIf n=10 ... there will be 2(5)\\nIf n=15 ... there will be 3(5)\\nIf n=25 ... there will be 5(5) + 1 (5)\\n\\nNow all we need to do is keep dividing n by 5 and add the result to our existing result until n get to 0.\\n\\nIf you are still having trouble getting the code, see this post https://nextswe.com/leetcode-172-factorial-trailing-zeroes/ . Code is provided at the end of explanation.\\nThanks"
                    },
                    {
                        "username": "naveen12124139",
                        "content": "//just return this\\nreturn n/3125+n/625+n/125+n/25+n/5;"
                    },
                    {
                        "username": "sergei99",
                        "content": "It only gets you to the top in languages with smart enough compilers. I\\'ve got C++ and Java executing at 0ms, but stuck with stupid Python... I guess if there is no library function \"count trailing zeroes in factorial\" written in C, then it\\'s just crawling."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "Hacker !!!!\\n"
                    },
                    {
                        "username": "amit2020cs",
                        "content": "You checked the constraints to count the largest power of 5. Nice intuition"
                    },
                    {
                        "username": "heisenbergknocks",
                        "content": "\\t\\n\\tThis seems long but just read on.\\n\\n\\tThe number of 0s in n! is the number of 10s that can be generated by numbers\\n\\tfrom 1 to n!. 10 is a product of 2 and 5, so we just need to check\\n\\thow many 2x5 are present in n!\\n\\n\\tIf n = 5, then n! = 1x2x3x4x5. There is one 2 and 5 pair present\\n\\tin 5! which can make one 10. So numbers of 0s in 5! is one.\\n\\n\\tIf n = 10, then n! = 1x2x3x4x5x6x7x8x9x10 => this would have two zeros one from the\\n\\t2x5 and one from another 2x5 in 10.\\n\\n\\tIf n = 15, then n! = 1x2x3x4x5x6x7x8x9x10x11x12x13x14x15 => this would have three\\n\\tzeros one from the 2x5 and one from another 2x5 in 10 and one from a 5 in 15 which\\n\\twould give us a 0 by multiplying with any 2 from any even num from 1 to 15.\\n\\n\\tSince there are a lot more 2s than 5s in any n!, we just need to find the\\n\\tnumber of 5s in n! and that will be the answer. Eg.\\n\\n\\t5! -> one 0 as there is only one 5 from 1 to 5.\\n\\t10! -> two 0s as there are two 5s from 1 to 10.\\n\\t15! -> three 0s as there are three 5s from 1 to 10.\\n\\t20! -> four 0s as there are four 5s from 1 to 10.\\n\\n\\tHow to quickly count number of 5s in n!? Use n/5.\\n\\tAssume n = 15, using n / 5 we get 3, this tells us that there are at least\\n\\tthree multiples of 5 present in numbers from 1 to 15 namely\\n\\t5x1 = 5, 5x2 = 10 and 5x3 = 15.\\n\\tSo, we can get the number of 5s in n! and hence the number of 0s in n! using n / 5.\\n\\n\\tBut there is still one issue for numbers like 25, 125,\\n\\t625, which contain more than one 5 as their factor.\\n\\n\\tEg. for 25!, the number of 0s is = number of 0s in 20! + number of 0s which can be generated from 21 to 25\\n\\t= number of 0s in 20! + two 0s as there are two 5s present in 25 which would\\n\\tmultiple with any two 2s and make a 100 and give us 2 zeros.\\n\\t= so 25! has six 0s.\\n\\n\\tBut, going by the original formula we will calculate number of 0s in 25! as\\n\\t25/5 which is 5. So five 0s.\\n\\tNow, what we need to do is just divide this result of 5 again by 5\\n\\twhich gives us a 1 and add it to previous five 0s\\n\\n\\tIntuition: Keep dividing by 5 and adding the result to number of 0s."
                    },
                    {
                        "username": "johngroves",
                        "content": "` return n//5 + self.trailingZeroes(n//5) if n else 0`\\nHelpful background here:\\nhttp://www.purplemath.com/modules/factzero.htm"
                    },
                    {
                        "username": "nangao",
                        "content": "I Can't understand this problem"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "This should be easy, not medium  :)"
                    },
                    {
                        "username": "harsha335",
                        "content": "If you cannot get the intuition, it will be hard."
                    },
                    {
                        "username": "megaman14",
                        "content": "You want to find the number of times 10 goes into n, which means the number of times both 5 and 2 appear. Since we always have more 2\\'s than 5\\'s, to get the answer, we try to find the number of times 5 appears as a factor. This is equivalent to n/5. However, we have to account for the powers of 5: 25, 125, 625... Thus, if we multiply the iterator by 5 each time, ex: n/25, n/125, n/625...we can increment the count and get the answer. Now, all you need to do is to be careful about int overflow"
                    },
                    {
                        "username": "alex86",
                        "content": "Factorial of 0 is 1. "
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "Legitimately once I had example numbers to work with, this was much easier to tell what the pattern was. So here\\'s something in Haskell to print out all the factorials:\\n\\n```hs\\nmodule Main where\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nmain = withFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```\\n\\nor for ghci:\\n\\n```hs\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nwithFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```"
                    },
                    {
                        "username": "jzummo",
                        "content": "https://en.wikipedia.org/wiki/Legendre%27s_formula"
                    }
                ]
            },
            {
                "id": 1570434,
                "content": [
                    {
                        "username": "nextsde",
                        "content": "How can we tell from a number, how many trailing zeroes are at the end?\\n\\n10 = 10\\n1200 = 12 x 10 x 10\\n145000 = 145 x 10 x 10 x10\\n\\nFrom above example, we can clearly see number of 10\\'s in a number gives us number of trailing zeros in that number.\\n\\nSo, in our first brute force solution we can calcualte the n! and check how many 10\\'s are in there. That will give us the solution.\\n\\nBut, since n! will become very very large to calculate as n becomes bigger. So, this is not a feasible solution.\\n\\nWhat can we do?\\n\\nLet\\'s build some more intuition to see if we can find out the final hint we need.\\n\\nWhat is the property of 10?\\n\\nWe can get 10 from 2 & 5 (2x5). Can you get 10 in any other way? No.\\n\\nSo, let\\'s break it down further.\\n\\n10 = 2 x 5 [1(2),1(5)]\\n100 = 2 x 2 x 5 x 5 [2(2),2(5)]\\n120 = 2 x 2 x 2 x 3 x 5 [3(2),1(3),1(5)]\\n1200 = 2 x 2 x 2 x 2 x 3 x 5 x 5 [4(2),1(3),2(5)] //2 appears 4 times, 3 appears 1 time, 5 appears 2 times}\\n50 = 2 x 5 x 5 [1(2),2(5)]\\n\\nFrom above you will see, among 5 and 2 whichever appears lowest amount is the count of our trailing zeros.\\nBut for n!, we know we will have more 2\\'s than 5.\\nLet\\'s see an example:\\n5! = 1 x 2 x 3  x 4(2x2) x 5 = [3(2),1(5)]\\n\\nTry writing down couple more example and you will understand. So, in 25! how many 5 will be there?\\n\\n....x5....x10....x15....x20....x25 = x5...x2x5....x3x5....x4x5....x5x5 = 6 , Because 25 itself has 2 5\\'s in it.\\n\\nOk, up till this point we were still analyzing n!.\\n\\nBut we know if n>=5 it will have 5 as a factor.\\n\\nSo, based on our intuition so far.\\n\\nIf n=5 ... there will be 1(5)\\nIf n=10 ... there will be 2(5)\\nIf n=15 ... there will be 3(5)\\nIf n=25 ... there will be 5(5) + 1 (5)\\n\\nNow all we need to do is keep dividing n by 5 and add the result to our existing result until n get to 0.\\n\\nIf you are still having trouble getting the code, see this post https://nextswe.com/leetcode-172-factorial-trailing-zeroes/ . Code is provided at the end of explanation.\\nThanks"
                    },
                    {
                        "username": "naveen12124139",
                        "content": "//just return this\\nreturn n/3125+n/625+n/125+n/25+n/5;"
                    },
                    {
                        "username": "sergei99",
                        "content": "It only gets you to the top in languages with smart enough compilers. I\\'ve got C++ and Java executing at 0ms, but stuck with stupid Python... I guess if there is no library function \"count trailing zeroes in factorial\" written in C, then it\\'s just crawling."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "Hacker !!!!\\n"
                    },
                    {
                        "username": "amit2020cs",
                        "content": "You checked the constraints to count the largest power of 5. Nice intuition"
                    },
                    {
                        "username": "heisenbergknocks",
                        "content": "\\t\\n\\tThis seems long but just read on.\\n\\n\\tThe number of 0s in n! is the number of 10s that can be generated by numbers\\n\\tfrom 1 to n!. 10 is a product of 2 and 5, so we just need to check\\n\\thow many 2x5 are present in n!\\n\\n\\tIf n = 5, then n! = 1x2x3x4x5. There is one 2 and 5 pair present\\n\\tin 5! which can make one 10. So numbers of 0s in 5! is one.\\n\\n\\tIf n = 10, then n! = 1x2x3x4x5x6x7x8x9x10 => this would have two zeros one from the\\n\\t2x5 and one from another 2x5 in 10.\\n\\n\\tIf n = 15, then n! = 1x2x3x4x5x6x7x8x9x10x11x12x13x14x15 => this would have three\\n\\tzeros one from the 2x5 and one from another 2x5 in 10 and one from a 5 in 15 which\\n\\twould give us a 0 by multiplying with any 2 from any even num from 1 to 15.\\n\\n\\tSince there are a lot more 2s than 5s in any n!, we just need to find the\\n\\tnumber of 5s in n! and that will be the answer. Eg.\\n\\n\\t5! -> one 0 as there is only one 5 from 1 to 5.\\n\\t10! -> two 0s as there are two 5s from 1 to 10.\\n\\t15! -> three 0s as there are three 5s from 1 to 10.\\n\\t20! -> four 0s as there are four 5s from 1 to 10.\\n\\n\\tHow to quickly count number of 5s in n!? Use n/5.\\n\\tAssume n = 15, using n / 5 we get 3, this tells us that there are at least\\n\\tthree multiples of 5 present in numbers from 1 to 15 namely\\n\\t5x1 = 5, 5x2 = 10 and 5x3 = 15.\\n\\tSo, we can get the number of 5s in n! and hence the number of 0s in n! using n / 5.\\n\\n\\tBut there is still one issue for numbers like 25, 125,\\n\\t625, which contain more than one 5 as their factor.\\n\\n\\tEg. for 25!, the number of 0s is = number of 0s in 20! + number of 0s which can be generated from 21 to 25\\n\\t= number of 0s in 20! + two 0s as there are two 5s present in 25 which would\\n\\tmultiple with any two 2s and make a 100 and give us 2 zeros.\\n\\t= so 25! has six 0s.\\n\\n\\tBut, going by the original formula we will calculate number of 0s in 25! as\\n\\t25/5 which is 5. So five 0s.\\n\\tNow, what we need to do is just divide this result of 5 again by 5\\n\\twhich gives us a 1 and add it to previous five 0s\\n\\n\\tIntuition: Keep dividing by 5 and adding the result to number of 0s."
                    },
                    {
                        "username": "johngroves",
                        "content": "` return n//5 + self.trailingZeroes(n//5) if n else 0`\\nHelpful background here:\\nhttp://www.purplemath.com/modules/factzero.htm"
                    },
                    {
                        "username": "nangao",
                        "content": "I Can't understand this problem"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "This should be easy, not medium  :)"
                    },
                    {
                        "username": "harsha335",
                        "content": "If you cannot get the intuition, it will be hard."
                    },
                    {
                        "username": "megaman14",
                        "content": "You want to find the number of times 10 goes into n, which means the number of times both 5 and 2 appear. Since we always have more 2\\'s than 5\\'s, to get the answer, we try to find the number of times 5 appears as a factor. This is equivalent to n/5. However, we have to account for the powers of 5: 25, 125, 625... Thus, if we multiply the iterator by 5 each time, ex: n/25, n/125, n/625...we can increment the count and get the answer. Now, all you need to do is to be careful about int overflow"
                    },
                    {
                        "username": "alex86",
                        "content": "Factorial of 0 is 1. "
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "Legitimately once I had example numbers to work with, this was much easier to tell what the pattern was. So here\\'s something in Haskell to print out all the factorials:\\n\\n```hs\\nmodule Main where\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nmain = withFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```\\n\\nor for ghci:\\n\\n```hs\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nwithFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```"
                    },
                    {
                        "username": "jzummo",
                        "content": "https://en.wikipedia.org/wiki/Legendre%27s_formula"
                    }
                ]
            },
            {
                "id": 1571376,
                "content": [
                    {
                        "username": "nextsde",
                        "content": "How can we tell from a number, how many trailing zeroes are at the end?\\n\\n10 = 10\\n1200 = 12 x 10 x 10\\n145000 = 145 x 10 x 10 x10\\n\\nFrom above example, we can clearly see number of 10\\'s in a number gives us number of trailing zeros in that number.\\n\\nSo, in our first brute force solution we can calcualte the n! and check how many 10\\'s are in there. That will give us the solution.\\n\\nBut, since n! will become very very large to calculate as n becomes bigger. So, this is not a feasible solution.\\n\\nWhat can we do?\\n\\nLet\\'s build some more intuition to see if we can find out the final hint we need.\\n\\nWhat is the property of 10?\\n\\nWe can get 10 from 2 & 5 (2x5). Can you get 10 in any other way? No.\\n\\nSo, let\\'s break it down further.\\n\\n10 = 2 x 5 [1(2),1(5)]\\n100 = 2 x 2 x 5 x 5 [2(2),2(5)]\\n120 = 2 x 2 x 2 x 3 x 5 [3(2),1(3),1(5)]\\n1200 = 2 x 2 x 2 x 2 x 3 x 5 x 5 [4(2),1(3),2(5)] //2 appears 4 times, 3 appears 1 time, 5 appears 2 times}\\n50 = 2 x 5 x 5 [1(2),2(5)]\\n\\nFrom above you will see, among 5 and 2 whichever appears lowest amount is the count of our trailing zeros.\\nBut for n!, we know we will have more 2\\'s than 5.\\nLet\\'s see an example:\\n5! = 1 x 2 x 3  x 4(2x2) x 5 = [3(2),1(5)]\\n\\nTry writing down couple more example and you will understand. So, in 25! how many 5 will be there?\\n\\n....x5....x10....x15....x20....x25 = x5...x2x5....x3x5....x4x5....x5x5 = 6 , Because 25 itself has 2 5\\'s in it.\\n\\nOk, up till this point we were still analyzing n!.\\n\\nBut we know if n>=5 it will have 5 as a factor.\\n\\nSo, based on our intuition so far.\\n\\nIf n=5 ... there will be 1(5)\\nIf n=10 ... there will be 2(5)\\nIf n=15 ... there will be 3(5)\\nIf n=25 ... there will be 5(5) + 1 (5)\\n\\nNow all we need to do is keep dividing n by 5 and add the result to our existing result until n get to 0.\\n\\nIf you are still having trouble getting the code, see this post https://nextswe.com/leetcode-172-factorial-trailing-zeroes/ . Code is provided at the end of explanation.\\nThanks"
                    },
                    {
                        "username": "naveen12124139",
                        "content": "//just return this\\nreturn n/3125+n/625+n/125+n/25+n/5;"
                    },
                    {
                        "username": "sergei99",
                        "content": "It only gets you to the top in languages with smart enough compilers. I\\'ve got C++ and Java executing at 0ms, but stuck with stupid Python... I guess if there is no library function \"count trailing zeroes in factorial\" written in C, then it\\'s just crawling."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "Hacker !!!!\\n"
                    },
                    {
                        "username": "amit2020cs",
                        "content": "You checked the constraints to count the largest power of 5. Nice intuition"
                    },
                    {
                        "username": "heisenbergknocks",
                        "content": "\\t\\n\\tThis seems long but just read on.\\n\\n\\tThe number of 0s in n! is the number of 10s that can be generated by numbers\\n\\tfrom 1 to n!. 10 is a product of 2 and 5, so we just need to check\\n\\thow many 2x5 are present in n!\\n\\n\\tIf n = 5, then n! = 1x2x3x4x5. There is one 2 and 5 pair present\\n\\tin 5! which can make one 10. So numbers of 0s in 5! is one.\\n\\n\\tIf n = 10, then n! = 1x2x3x4x5x6x7x8x9x10 => this would have two zeros one from the\\n\\t2x5 and one from another 2x5 in 10.\\n\\n\\tIf n = 15, then n! = 1x2x3x4x5x6x7x8x9x10x11x12x13x14x15 => this would have three\\n\\tzeros one from the 2x5 and one from another 2x5 in 10 and one from a 5 in 15 which\\n\\twould give us a 0 by multiplying with any 2 from any even num from 1 to 15.\\n\\n\\tSince there are a lot more 2s than 5s in any n!, we just need to find the\\n\\tnumber of 5s in n! and that will be the answer. Eg.\\n\\n\\t5! -> one 0 as there is only one 5 from 1 to 5.\\n\\t10! -> two 0s as there are two 5s from 1 to 10.\\n\\t15! -> three 0s as there are three 5s from 1 to 10.\\n\\t20! -> four 0s as there are four 5s from 1 to 10.\\n\\n\\tHow to quickly count number of 5s in n!? Use n/5.\\n\\tAssume n = 15, using n / 5 we get 3, this tells us that there are at least\\n\\tthree multiples of 5 present in numbers from 1 to 15 namely\\n\\t5x1 = 5, 5x2 = 10 and 5x3 = 15.\\n\\tSo, we can get the number of 5s in n! and hence the number of 0s in n! using n / 5.\\n\\n\\tBut there is still one issue for numbers like 25, 125,\\n\\t625, which contain more than one 5 as their factor.\\n\\n\\tEg. for 25!, the number of 0s is = number of 0s in 20! + number of 0s which can be generated from 21 to 25\\n\\t= number of 0s in 20! + two 0s as there are two 5s present in 25 which would\\n\\tmultiple with any two 2s and make a 100 and give us 2 zeros.\\n\\t= so 25! has six 0s.\\n\\n\\tBut, going by the original formula we will calculate number of 0s in 25! as\\n\\t25/5 which is 5. So five 0s.\\n\\tNow, what we need to do is just divide this result of 5 again by 5\\n\\twhich gives us a 1 and add it to previous five 0s\\n\\n\\tIntuition: Keep dividing by 5 and adding the result to number of 0s."
                    },
                    {
                        "username": "johngroves",
                        "content": "` return n//5 + self.trailingZeroes(n//5) if n else 0`\\nHelpful background here:\\nhttp://www.purplemath.com/modules/factzero.htm"
                    },
                    {
                        "username": "nangao",
                        "content": "I Can't understand this problem"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "This should be easy, not medium  :)"
                    },
                    {
                        "username": "harsha335",
                        "content": "If you cannot get the intuition, it will be hard."
                    },
                    {
                        "username": "megaman14",
                        "content": "You want to find the number of times 10 goes into n, which means the number of times both 5 and 2 appear. Since we always have more 2\\'s than 5\\'s, to get the answer, we try to find the number of times 5 appears as a factor. This is equivalent to n/5. However, we have to account for the powers of 5: 25, 125, 625... Thus, if we multiply the iterator by 5 each time, ex: n/25, n/125, n/625...we can increment the count and get the answer. Now, all you need to do is to be careful about int overflow"
                    },
                    {
                        "username": "alex86",
                        "content": "Factorial of 0 is 1. "
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "Legitimately once I had example numbers to work with, this was much easier to tell what the pattern was. So here\\'s something in Haskell to print out all the factorials:\\n\\n```hs\\nmodule Main where\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nmain = withFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```\\n\\nor for ghci:\\n\\n```hs\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nwithFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```"
                    },
                    {
                        "username": "jzummo",
                        "content": "https://en.wikipedia.org/wiki/Legendre%27s_formula"
                    }
                ]
            },
            {
                "id": 1571377,
                "content": [
                    {
                        "username": "nextsde",
                        "content": "How can we tell from a number, how many trailing zeroes are at the end?\\n\\n10 = 10\\n1200 = 12 x 10 x 10\\n145000 = 145 x 10 x 10 x10\\n\\nFrom above example, we can clearly see number of 10\\'s in a number gives us number of trailing zeros in that number.\\n\\nSo, in our first brute force solution we can calcualte the n! and check how many 10\\'s are in there. That will give us the solution.\\n\\nBut, since n! will become very very large to calculate as n becomes bigger. So, this is not a feasible solution.\\n\\nWhat can we do?\\n\\nLet\\'s build some more intuition to see if we can find out the final hint we need.\\n\\nWhat is the property of 10?\\n\\nWe can get 10 from 2 & 5 (2x5). Can you get 10 in any other way? No.\\n\\nSo, let\\'s break it down further.\\n\\n10 = 2 x 5 [1(2),1(5)]\\n100 = 2 x 2 x 5 x 5 [2(2),2(5)]\\n120 = 2 x 2 x 2 x 3 x 5 [3(2),1(3),1(5)]\\n1200 = 2 x 2 x 2 x 2 x 3 x 5 x 5 [4(2),1(3),2(5)] //2 appears 4 times, 3 appears 1 time, 5 appears 2 times}\\n50 = 2 x 5 x 5 [1(2),2(5)]\\n\\nFrom above you will see, among 5 and 2 whichever appears lowest amount is the count of our trailing zeros.\\nBut for n!, we know we will have more 2\\'s than 5.\\nLet\\'s see an example:\\n5! = 1 x 2 x 3  x 4(2x2) x 5 = [3(2),1(5)]\\n\\nTry writing down couple more example and you will understand. So, in 25! how many 5 will be there?\\n\\n....x5....x10....x15....x20....x25 = x5...x2x5....x3x5....x4x5....x5x5 = 6 , Because 25 itself has 2 5\\'s in it.\\n\\nOk, up till this point we were still analyzing n!.\\n\\nBut we know if n>=5 it will have 5 as a factor.\\n\\nSo, based on our intuition so far.\\n\\nIf n=5 ... there will be 1(5)\\nIf n=10 ... there will be 2(5)\\nIf n=15 ... there will be 3(5)\\nIf n=25 ... there will be 5(5) + 1 (5)\\n\\nNow all we need to do is keep dividing n by 5 and add the result to our existing result until n get to 0.\\n\\nIf you are still having trouble getting the code, see this post https://nextswe.com/leetcode-172-factorial-trailing-zeroes/ . Code is provided at the end of explanation.\\nThanks"
                    },
                    {
                        "username": "naveen12124139",
                        "content": "//just return this\\nreturn n/3125+n/625+n/125+n/25+n/5;"
                    },
                    {
                        "username": "sergei99",
                        "content": "It only gets you to the top in languages with smart enough compilers. I\\'ve got C++ and Java executing at 0ms, but stuck with stupid Python... I guess if there is no library function \"count trailing zeroes in factorial\" written in C, then it\\'s just crawling."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "Hacker !!!!\\n"
                    },
                    {
                        "username": "amit2020cs",
                        "content": "You checked the constraints to count the largest power of 5. Nice intuition"
                    },
                    {
                        "username": "heisenbergknocks",
                        "content": "\\t\\n\\tThis seems long but just read on.\\n\\n\\tThe number of 0s in n! is the number of 10s that can be generated by numbers\\n\\tfrom 1 to n!. 10 is a product of 2 and 5, so we just need to check\\n\\thow many 2x5 are present in n!\\n\\n\\tIf n = 5, then n! = 1x2x3x4x5. There is one 2 and 5 pair present\\n\\tin 5! which can make one 10. So numbers of 0s in 5! is one.\\n\\n\\tIf n = 10, then n! = 1x2x3x4x5x6x7x8x9x10 => this would have two zeros one from the\\n\\t2x5 and one from another 2x5 in 10.\\n\\n\\tIf n = 15, then n! = 1x2x3x4x5x6x7x8x9x10x11x12x13x14x15 => this would have three\\n\\tzeros one from the 2x5 and one from another 2x5 in 10 and one from a 5 in 15 which\\n\\twould give us a 0 by multiplying with any 2 from any even num from 1 to 15.\\n\\n\\tSince there are a lot more 2s than 5s in any n!, we just need to find the\\n\\tnumber of 5s in n! and that will be the answer. Eg.\\n\\n\\t5! -> one 0 as there is only one 5 from 1 to 5.\\n\\t10! -> two 0s as there are two 5s from 1 to 10.\\n\\t15! -> three 0s as there are three 5s from 1 to 10.\\n\\t20! -> four 0s as there are four 5s from 1 to 10.\\n\\n\\tHow to quickly count number of 5s in n!? Use n/5.\\n\\tAssume n = 15, using n / 5 we get 3, this tells us that there are at least\\n\\tthree multiples of 5 present in numbers from 1 to 15 namely\\n\\t5x1 = 5, 5x2 = 10 and 5x3 = 15.\\n\\tSo, we can get the number of 5s in n! and hence the number of 0s in n! using n / 5.\\n\\n\\tBut there is still one issue for numbers like 25, 125,\\n\\t625, which contain more than one 5 as their factor.\\n\\n\\tEg. for 25!, the number of 0s is = number of 0s in 20! + number of 0s which can be generated from 21 to 25\\n\\t= number of 0s in 20! + two 0s as there are two 5s present in 25 which would\\n\\tmultiple with any two 2s and make a 100 and give us 2 zeros.\\n\\t= so 25! has six 0s.\\n\\n\\tBut, going by the original formula we will calculate number of 0s in 25! as\\n\\t25/5 which is 5. So five 0s.\\n\\tNow, what we need to do is just divide this result of 5 again by 5\\n\\twhich gives us a 1 and add it to previous five 0s\\n\\n\\tIntuition: Keep dividing by 5 and adding the result to number of 0s."
                    },
                    {
                        "username": "johngroves",
                        "content": "` return n//5 + self.trailingZeroes(n//5) if n else 0`\\nHelpful background here:\\nhttp://www.purplemath.com/modules/factzero.htm"
                    },
                    {
                        "username": "nangao",
                        "content": "I Can't understand this problem"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "This should be easy, not medium  :)"
                    },
                    {
                        "username": "harsha335",
                        "content": "If you cannot get the intuition, it will be hard."
                    },
                    {
                        "username": "megaman14",
                        "content": "You want to find the number of times 10 goes into n, which means the number of times both 5 and 2 appear. Since we always have more 2\\'s than 5\\'s, to get the answer, we try to find the number of times 5 appears as a factor. This is equivalent to n/5. However, we have to account for the powers of 5: 25, 125, 625... Thus, if we multiply the iterator by 5 each time, ex: n/25, n/125, n/625...we can increment the count and get the answer. Now, all you need to do is to be careful about int overflow"
                    },
                    {
                        "username": "alex86",
                        "content": "Factorial of 0 is 1. "
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "Legitimately once I had example numbers to work with, this was much easier to tell what the pattern was. So here\\'s something in Haskell to print out all the factorials:\\n\\n```hs\\nmodule Main where\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nmain = withFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```\\n\\nor for ghci:\\n\\n```hs\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nwithFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```"
                    },
                    {
                        "username": "jzummo",
                        "content": "https://en.wikipedia.org/wiki/Legendre%27s_formula"
                    }
                ]
            },
            {
                "id": 2007404,
                "content": [
                    {
                        "username": "nextsde",
                        "content": "How can we tell from a number, how many trailing zeroes are at the end?\\n\\n10 = 10\\n1200 = 12 x 10 x 10\\n145000 = 145 x 10 x 10 x10\\n\\nFrom above example, we can clearly see number of 10\\'s in a number gives us number of trailing zeros in that number.\\n\\nSo, in our first brute force solution we can calcualte the n! and check how many 10\\'s are in there. That will give us the solution.\\n\\nBut, since n! will become very very large to calculate as n becomes bigger. So, this is not a feasible solution.\\n\\nWhat can we do?\\n\\nLet\\'s build some more intuition to see if we can find out the final hint we need.\\n\\nWhat is the property of 10?\\n\\nWe can get 10 from 2 & 5 (2x5). Can you get 10 in any other way? No.\\n\\nSo, let\\'s break it down further.\\n\\n10 = 2 x 5 [1(2),1(5)]\\n100 = 2 x 2 x 5 x 5 [2(2),2(5)]\\n120 = 2 x 2 x 2 x 3 x 5 [3(2),1(3),1(5)]\\n1200 = 2 x 2 x 2 x 2 x 3 x 5 x 5 [4(2),1(3),2(5)] //2 appears 4 times, 3 appears 1 time, 5 appears 2 times}\\n50 = 2 x 5 x 5 [1(2),2(5)]\\n\\nFrom above you will see, among 5 and 2 whichever appears lowest amount is the count of our trailing zeros.\\nBut for n!, we know we will have more 2\\'s than 5.\\nLet\\'s see an example:\\n5! = 1 x 2 x 3  x 4(2x2) x 5 = [3(2),1(5)]\\n\\nTry writing down couple more example and you will understand. So, in 25! how many 5 will be there?\\n\\n....x5....x10....x15....x20....x25 = x5...x2x5....x3x5....x4x5....x5x5 = 6 , Because 25 itself has 2 5\\'s in it.\\n\\nOk, up till this point we were still analyzing n!.\\n\\nBut we know if n>=5 it will have 5 as a factor.\\n\\nSo, based on our intuition so far.\\n\\nIf n=5 ... there will be 1(5)\\nIf n=10 ... there will be 2(5)\\nIf n=15 ... there will be 3(5)\\nIf n=25 ... there will be 5(5) + 1 (5)\\n\\nNow all we need to do is keep dividing n by 5 and add the result to our existing result until n get to 0.\\n\\nIf you are still having trouble getting the code, see this post https://nextswe.com/leetcode-172-factorial-trailing-zeroes/ . Code is provided at the end of explanation.\\nThanks"
                    },
                    {
                        "username": "naveen12124139",
                        "content": "//just return this\\nreturn n/3125+n/625+n/125+n/25+n/5;"
                    },
                    {
                        "username": "sergei99",
                        "content": "It only gets you to the top in languages with smart enough compilers. I\\'ve got C++ and Java executing at 0ms, but stuck with stupid Python... I guess if there is no library function \"count trailing zeroes in factorial\" written in C, then it\\'s just crawling."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "Hacker !!!!\\n"
                    },
                    {
                        "username": "amit2020cs",
                        "content": "You checked the constraints to count the largest power of 5. Nice intuition"
                    },
                    {
                        "username": "heisenbergknocks",
                        "content": "\\t\\n\\tThis seems long but just read on.\\n\\n\\tThe number of 0s in n! is the number of 10s that can be generated by numbers\\n\\tfrom 1 to n!. 10 is a product of 2 and 5, so we just need to check\\n\\thow many 2x5 are present in n!\\n\\n\\tIf n = 5, then n! = 1x2x3x4x5. There is one 2 and 5 pair present\\n\\tin 5! which can make one 10. So numbers of 0s in 5! is one.\\n\\n\\tIf n = 10, then n! = 1x2x3x4x5x6x7x8x9x10 => this would have two zeros one from the\\n\\t2x5 and one from another 2x5 in 10.\\n\\n\\tIf n = 15, then n! = 1x2x3x4x5x6x7x8x9x10x11x12x13x14x15 => this would have three\\n\\tzeros one from the 2x5 and one from another 2x5 in 10 and one from a 5 in 15 which\\n\\twould give us a 0 by multiplying with any 2 from any even num from 1 to 15.\\n\\n\\tSince there are a lot more 2s than 5s in any n!, we just need to find the\\n\\tnumber of 5s in n! and that will be the answer. Eg.\\n\\n\\t5! -> one 0 as there is only one 5 from 1 to 5.\\n\\t10! -> two 0s as there are two 5s from 1 to 10.\\n\\t15! -> three 0s as there are three 5s from 1 to 10.\\n\\t20! -> four 0s as there are four 5s from 1 to 10.\\n\\n\\tHow to quickly count number of 5s in n!? Use n/5.\\n\\tAssume n = 15, using n / 5 we get 3, this tells us that there are at least\\n\\tthree multiples of 5 present in numbers from 1 to 15 namely\\n\\t5x1 = 5, 5x2 = 10 and 5x3 = 15.\\n\\tSo, we can get the number of 5s in n! and hence the number of 0s in n! using n / 5.\\n\\n\\tBut there is still one issue for numbers like 25, 125,\\n\\t625, which contain more than one 5 as their factor.\\n\\n\\tEg. for 25!, the number of 0s is = number of 0s in 20! + number of 0s which can be generated from 21 to 25\\n\\t= number of 0s in 20! + two 0s as there are two 5s present in 25 which would\\n\\tmultiple with any two 2s and make a 100 and give us 2 zeros.\\n\\t= so 25! has six 0s.\\n\\n\\tBut, going by the original formula we will calculate number of 0s in 25! as\\n\\t25/5 which is 5. So five 0s.\\n\\tNow, what we need to do is just divide this result of 5 again by 5\\n\\twhich gives us a 1 and add it to previous five 0s\\n\\n\\tIntuition: Keep dividing by 5 and adding the result to number of 0s."
                    },
                    {
                        "username": "johngroves",
                        "content": "` return n//5 + self.trailingZeroes(n//5) if n else 0`\\nHelpful background here:\\nhttp://www.purplemath.com/modules/factzero.htm"
                    },
                    {
                        "username": "nangao",
                        "content": "I Can't understand this problem"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "This should be easy, not medium  :)"
                    },
                    {
                        "username": "harsha335",
                        "content": "If you cannot get the intuition, it will be hard."
                    },
                    {
                        "username": "megaman14",
                        "content": "You want to find the number of times 10 goes into n, which means the number of times both 5 and 2 appear. Since we always have more 2\\'s than 5\\'s, to get the answer, we try to find the number of times 5 appears as a factor. This is equivalent to n/5. However, we have to account for the powers of 5: 25, 125, 625... Thus, if we multiply the iterator by 5 each time, ex: n/25, n/125, n/625...we can increment the count and get the answer. Now, all you need to do is to be careful about int overflow"
                    },
                    {
                        "username": "alex86",
                        "content": "Factorial of 0 is 1. "
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "Legitimately once I had example numbers to work with, this was much easier to tell what the pattern was. So here\\'s something in Haskell to print out all the factorials:\\n\\n```hs\\nmodule Main where\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nmain = withFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```\\n\\nor for ghci:\\n\\n```hs\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nwithFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```"
                    },
                    {
                        "username": "jzummo",
                        "content": "https://en.wikipedia.org/wiki/Legendre%27s_formula"
                    }
                ]
            },
            {
                "id": 1569593,
                "content": [
                    {
                        "username": "nextsde",
                        "content": "How can we tell from a number, how many trailing zeroes are at the end?\\n\\n10 = 10\\n1200 = 12 x 10 x 10\\n145000 = 145 x 10 x 10 x10\\n\\nFrom above example, we can clearly see number of 10\\'s in a number gives us number of trailing zeros in that number.\\n\\nSo, in our first brute force solution we can calcualte the n! and check how many 10\\'s are in there. That will give us the solution.\\n\\nBut, since n! will become very very large to calculate as n becomes bigger. So, this is not a feasible solution.\\n\\nWhat can we do?\\n\\nLet\\'s build some more intuition to see if we can find out the final hint we need.\\n\\nWhat is the property of 10?\\n\\nWe can get 10 from 2 & 5 (2x5). Can you get 10 in any other way? No.\\n\\nSo, let\\'s break it down further.\\n\\n10 = 2 x 5 [1(2),1(5)]\\n100 = 2 x 2 x 5 x 5 [2(2),2(5)]\\n120 = 2 x 2 x 2 x 3 x 5 [3(2),1(3),1(5)]\\n1200 = 2 x 2 x 2 x 2 x 3 x 5 x 5 [4(2),1(3),2(5)] //2 appears 4 times, 3 appears 1 time, 5 appears 2 times}\\n50 = 2 x 5 x 5 [1(2),2(5)]\\n\\nFrom above you will see, among 5 and 2 whichever appears lowest amount is the count of our trailing zeros.\\nBut for n!, we know we will have more 2\\'s than 5.\\nLet\\'s see an example:\\n5! = 1 x 2 x 3  x 4(2x2) x 5 = [3(2),1(5)]\\n\\nTry writing down couple more example and you will understand. So, in 25! how many 5 will be there?\\n\\n....x5....x10....x15....x20....x25 = x5...x2x5....x3x5....x4x5....x5x5 = 6 , Because 25 itself has 2 5\\'s in it.\\n\\nOk, up till this point we were still analyzing n!.\\n\\nBut we know if n>=5 it will have 5 as a factor.\\n\\nSo, based on our intuition so far.\\n\\nIf n=5 ... there will be 1(5)\\nIf n=10 ... there will be 2(5)\\nIf n=15 ... there will be 3(5)\\nIf n=25 ... there will be 5(5) + 1 (5)\\n\\nNow all we need to do is keep dividing n by 5 and add the result to our existing result until n get to 0.\\n\\nIf you are still having trouble getting the code, see this post https://nextswe.com/leetcode-172-factorial-trailing-zeroes/ . Code is provided at the end of explanation.\\nThanks"
                    },
                    {
                        "username": "naveen12124139",
                        "content": "//just return this\\nreturn n/3125+n/625+n/125+n/25+n/5;"
                    },
                    {
                        "username": "sergei99",
                        "content": "It only gets you to the top in languages with smart enough compilers. I\\'ve got C++ and Java executing at 0ms, but stuck with stupid Python... I guess if there is no library function \"count trailing zeroes in factorial\" written in C, then it\\'s just crawling."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "Hacker !!!!\\n"
                    },
                    {
                        "username": "amit2020cs",
                        "content": "You checked the constraints to count the largest power of 5. Nice intuition"
                    },
                    {
                        "username": "heisenbergknocks",
                        "content": "\\t\\n\\tThis seems long but just read on.\\n\\n\\tThe number of 0s in n! is the number of 10s that can be generated by numbers\\n\\tfrom 1 to n!. 10 is a product of 2 and 5, so we just need to check\\n\\thow many 2x5 are present in n!\\n\\n\\tIf n = 5, then n! = 1x2x3x4x5. There is one 2 and 5 pair present\\n\\tin 5! which can make one 10. So numbers of 0s in 5! is one.\\n\\n\\tIf n = 10, then n! = 1x2x3x4x5x6x7x8x9x10 => this would have two zeros one from the\\n\\t2x5 and one from another 2x5 in 10.\\n\\n\\tIf n = 15, then n! = 1x2x3x4x5x6x7x8x9x10x11x12x13x14x15 => this would have three\\n\\tzeros one from the 2x5 and one from another 2x5 in 10 and one from a 5 in 15 which\\n\\twould give us a 0 by multiplying with any 2 from any even num from 1 to 15.\\n\\n\\tSince there are a lot more 2s than 5s in any n!, we just need to find the\\n\\tnumber of 5s in n! and that will be the answer. Eg.\\n\\n\\t5! -> one 0 as there is only one 5 from 1 to 5.\\n\\t10! -> two 0s as there are two 5s from 1 to 10.\\n\\t15! -> three 0s as there are three 5s from 1 to 10.\\n\\t20! -> four 0s as there are four 5s from 1 to 10.\\n\\n\\tHow to quickly count number of 5s in n!? Use n/5.\\n\\tAssume n = 15, using n / 5 we get 3, this tells us that there are at least\\n\\tthree multiples of 5 present in numbers from 1 to 15 namely\\n\\t5x1 = 5, 5x2 = 10 and 5x3 = 15.\\n\\tSo, we can get the number of 5s in n! and hence the number of 0s in n! using n / 5.\\n\\n\\tBut there is still one issue for numbers like 25, 125,\\n\\t625, which contain more than one 5 as their factor.\\n\\n\\tEg. for 25!, the number of 0s is = number of 0s in 20! + number of 0s which can be generated from 21 to 25\\n\\t= number of 0s in 20! + two 0s as there are two 5s present in 25 which would\\n\\tmultiple with any two 2s and make a 100 and give us 2 zeros.\\n\\t= so 25! has six 0s.\\n\\n\\tBut, going by the original formula we will calculate number of 0s in 25! as\\n\\t25/5 which is 5. So five 0s.\\n\\tNow, what we need to do is just divide this result of 5 again by 5\\n\\twhich gives us a 1 and add it to previous five 0s\\n\\n\\tIntuition: Keep dividing by 5 and adding the result to number of 0s."
                    },
                    {
                        "username": "johngroves",
                        "content": "` return n//5 + self.trailingZeroes(n//5) if n else 0`\\nHelpful background here:\\nhttp://www.purplemath.com/modules/factzero.htm"
                    },
                    {
                        "username": "nangao",
                        "content": "I Can't understand this problem"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "This should be easy, not medium  :)"
                    },
                    {
                        "username": "harsha335",
                        "content": "If you cannot get the intuition, it will be hard."
                    },
                    {
                        "username": "megaman14",
                        "content": "You want to find the number of times 10 goes into n, which means the number of times both 5 and 2 appear. Since we always have more 2\\'s than 5\\'s, to get the answer, we try to find the number of times 5 appears as a factor. This is equivalent to n/5. However, we have to account for the powers of 5: 25, 125, 625... Thus, if we multiply the iterator by 5 each time, ex: n/25, n/125, n/625...we can increment the count and get the answer. Now, all you need to do is to be careful about int overflow"
                    },
                    {
                        "username": "alex86",
                        "content": "Factorial of 0 is 1. "
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "Legitimately once I had example numbers to work with, this was much easier to tell what the pattern was. So here\\'s something in Haskell to print out all the factorials:\\n\\n```hs\\nmodule Main where\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nmain = withFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```\\n\\nor for ghci:\\n\\n```hs\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nwithFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```"
                    },
                    {
                        "username": "jzummo",
                        "content": "https://en.wikipedia.org/wiki/Legendre%27s_formula"
                    }
                ]
            },
            {
                "id": 1975879,
                "content": [
                    {
                        "username": "nextsde",
                        "content": "How can we tell from a number, how many trailing zeroes are at the end?\\n\\n10 = 10\\n1200 = 12 x 10 x 10\\n145000 = 145 x 10 x 10 x10\\n\\nFrom above example, we can clearly see number of 10\\'s in a number gives us number of trailing zeros in that number.\\n\\nSo, in our first brute force solution we can calcualte the n! and check how many 10\\'s are in there. That will give us the solution.\\n\\nBut, since n! will become very very large to calculate as n becomes bigger. So, this is not a feasible solution.\\n\\nWhat can we do?\\n\\nLet\\'s build some more intuition to see if we can find out the final hint we need.\\n\\nWhat is the property of 10?\\n\\nWe can get 10 from 2 & 5 (2x5). Can you get 10 in any other way? No.\\n\\nSo, let\\'s break it down further.\\n\\n10 = 2 x 5 [1(2),1(5)]\\n100 = 2 x 2 x 5 x 5 [2(2),2(5)]\\n120 = 2 x 2 x 2 x 3 x 5 [3(2),1(3),1(5)]\\n1200 = 2 x 2 x 2 x 2 x 3 x 5 x 5 [4(2),1(3),2(5)] //2 appears 4 times, 3 appears 1 time, 5 appears 2 times}\\n50 = 2 x 5 x 5 [1(2),2(5)]\\n\\nFrom above you will see, among 5 and 2 whichever appears lowest amount is the count of our trailing zeros.\\nBut for n!, we know we will have more 2\\'s than 5.\\nLet\\'s see an example:\\n5! = 1 x 2 x 3  x 4(2x2) x 5 = [3(2),1(5)]\\n\\nTry writing down couple more example and you will understand. So, in 25! how many 5 will be there?\\n\\n....x5....x10....x15....x20....x25 = x5...x2x5....x3x5....x4x5....x5x5 = 6 , Because 25 itself has 2 5\\'s in it.\\n\\nOk, up till this point we were still analyzing n!.\\n\\nBut we know if n>=5 it will have 5 as a factor.\\n\\nSo, based on our intuition so far.\\n\\nIf n=5 ... there will be 1(5)\\nIf n=10 ... there will be 2(5)\\nIf n=15 ... there will be 3(5)\\nIf n=25 ... there will be 5(5) + 1 (5)\\n\\nNow all we need to do is keep dividing n by 5 and add the result to our existing result until n get to 0.\\n\\nIf you are still having trouble getting the code, see this post https://nextswe.com/leetcode-172-factorial-trailing-zeroes/ . Code is provided at the end of explanation.\\nThanks"
                    },
                    {
                        "username": "naveen12124139",
                        "content": "//just return this\\nreturn n/3125+n/625+n/125+n/25+n/5;"
                    },
                    {
                        "username": "sergei99",
                        "content": "It only gets you to the top in languages with smart enough compilers. I\\'ve got C++ and Java executing at 0ms, but stuck with stupid Python... I guess if there is no library function \"count trailing zeroes in factorial\" written in C, then it\\'s just crawling."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "Hacker !!!!\\n"
                    },
                    {
                        "username": "amit2020cs",
                        "content": "You checked the constraints to count the largest power of 5. Nice intuition"
                    },
                    {
                        "username": "heisenbergknocks",
                        "content": "\\t\\n\\tThis seems long but just read on.\\n\\n\\tThe number of 0s in n! is the number of 10s that can be generated by numbers\\n\\tfrom 1 to n!. 10 is a product of 2 and 5, so we just need to check\\n\\thow many 2x5 are present in n!\\n\\n\\tIf n = 5, then n! = 1x2x3x4x5. There is one 2 and 5 pair present\\n\\tin 5! which can make one 10. So numbers of 0s in 5! is one.\\n\\n\\tIf n = 10, then n! = 1x2x3x4x5x6x7x8x9x10 => this would have two zeros one from the\\n\\t2x5 and one from another 2x5 in 10.\\n\\n\\tIf n = 15, then n! = 1x2x3x4x5x6x7x8x9x10x11x12x13x14x15 => this would have three\\n\\tzeros one from the 2x5 and one from another 2x5 in 10 and one from a 5 in 15 which\\n\\twould give us a 0 by multiplying with any 2 from any even num from 1 to 15.\\n\\n\\tSince there are a lot more 2s than 5s in any n!, we just need to find the\\n\\tnumber of 5s in n! and that will be the answer. Eg.\\n\\n\\t5! -> one 0 as there is only one 5 from 1 to 5.\\n\\t10! -> two 0s as there are two 5s from 1 to 10.\\n\\t15! -> three 0s as there are three 5s from 1 to 10.\\n\\t20! -> four 0s as there are four 5s from 1 to 10.\\n\\n\\tHow to quickly count number of 5s in n!? Use n/5.\\n\\tAssume n = 15, using n / 5 we get 3, this tells us that there are at least\\n\\tthree multiples of 5 present in numbers from 1 to 15 namely\\n\\t5x1 = 5, 5x2 = 10 and 5x3 = 15.\\n\\tSo, we can get the number of 5s in n! and hence the number of 0s in n! using n / 5.\\n\\n\\tBut there is still one issue for numbers like 25, 125,\\n\\t625, which contain more than one 5 as their factor.\\n\\n\\tEg. for 25!, the number of 0s is = number of 0s in 20! + number of 0s which can be generated from 21 to 25\\n\\t= number of 0s in 20! + two 0s as there are two 5s present in 25 which would\\n\\tmultiple with any two 2s and make a 100 and give us 2 zeros.\\n\\t= so 25! has six 0s.\\n\\n\\tBut, going by the original formula we will calculate number of 0s in 25! as\\n\\t25/5 which is 5. So five 0s.\\n\\tNow, what we need to do is just divide this result of 5 again by 5\\n\\twhich gives us a 1 and add it to previous five 0s\\n\\n\\tIntuition: Keep dividing by 5 and adding the result to number of 0s."
                    },
                    {
                        "username": "johngroves",
                        "content": "` return n//5 + self.trailingZeroes(n//5) if n else 0`\\nHelpful background here:\\nhttp://www.purplemath.com/modules/factzero.htm"
                    },
                    {
                        "username": "nangao",
                        "content": "I Can't understand this problem"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "This should be easy, not medium  :)"
                    },
                    {
                        "username": "harsha335",
                        "content": "If you cannot get the intuition, it will be hard."
                    },
                    {
                        "username": "megaman14",
                        "content": "You want to find the number of times 10 goes into n, which means the number of times both 5 and 2 appear. Since we always have more 2\\'s than 5\\'s, to get the answer, we try to find the number of times 5 appears as a factor. This is equivalent to n/5. However, we have to account for the powers of 5: 25, 125, 625... Thus, if we multiply the iterator by 5 each time, ex: n/25, n/125, n/625...we can increment the count and get the answer. Now, all you need to do is to be careful about int overflow"
                    },
                    {
                        "username": "alex86",
                        "content": "Factorial of 0 is 1. "
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "Legitimately once I had example numbers to work with, this was much easier to tell what the pattern was. So here\\'s something in Haskell to print out all the factorials:\\n\\n```hs\\nmodule Main where\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nmain = withFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```\\n\\nor for ghci:\\n\\n```hs\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nwithFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```"
                    },
                    {
                        "username": "jzummo",
                        "content": "https://en.wikipedia.org/wiki/Legendre%27s_formula"
                    }
                ]
            },
            {
                "id": 1909361,
                "content": [
                    {
                        "username": "nextsde",
                        "content": "How can we tell from a number, how many trailing zeroes are at the end?\\n\\n10 = 10\\n1200 = 12 x 10 x 10\\n145000 = 145 x 10 x 10 x10\\n\\nFrom above example, we can clearly see number of 10\\'s in a number gives us number of trailing zeros in that number.\\n\\nSo, in our first brute force solution we can calcualte the n! and check how many 10\\'s are in there. That will give us the solution.\\n\\nBut, since n! will become very very large to calculate as n becomes bigger. So, this is not a feasible solution.\\n\\nWhat can we do?\\n\\nLet\\'s build some more intuition to see if we can find out the final hint we need.\\n\\nWhat is the property of 10?\\n\\nWe can get 10 from 2 & 5 (2x5). Can you get 10 in any other way? No.\\n\\nSo, let\\'s break it down further.\\n\\n10 = 2 x 5 [1(2),1(5)]\\n100 = 2 x 2 x 5 x 5 [2(2),2(5)]\\n120 = 2 x 2 x 2 x 3 x 5 [3(2),1(3),1(5)]\\n1200 = 2 x 2 x 2 x 2 x 3 x 5 x 5 [4(2),1(3),2(5)] //2 appears 4 times, 3 appears 1 time, 5 appears 2 times}\\n50 = 2 x 5 x 5 [1(2),2(5)]\\n\\nFrom above you will see, among 5 and 2 whichever appears lowest amount is the count of our trailing zeros.\\nBut for n!, we know we will have more 2\\'s than 5.\\nLet\\'s see an example:\\n5! = 1 x 2 x 3  x 4(2x2) x 5 = [3(2),1(5)]\\n\\nTry writing down couple more example and you will understand. So, in 25! how many 5 will be there?\\n\\n....x5....x10....x15....x20....x25 = x5...x2x5....x3x5....x4x5....x5x5 = 6 , Because 25 itself has 2 5\\'s in it.\\n\\nOk, up till this point we were still analyzing n!.\\n\\nBut we know if n>=5 it will have 5 as a factor.\\n\\nSo, based on our intuition so far.\\n\\nIf n=5 ... there will be 1(5)\\nIf n=10 ... there will be 2(5)\\nIf n=15 ... there will be 3(5)\\nIf n=25 ... there will be 5(5) + 1 (5)\\n\\nNow all we need to do is keep dividing n by 5 and add the result to our existing result until n get to 0.\\n\\nIf you are still having trouble getting the code, see this post https://nextswe.com/leetcode-172-factorial-trailing-zeroes/ . Code is provided at the end of explanation.\\nThanks"
                    },
                    {
                        "username": "naveen12124139",
                        "content": "//just return this\\nreturn n/3125+n/625+n/125+n/25+n/5;"
                    },
                    {
                        "username": "sergei99",
                        "content": "It only gets you to the top in languages with smart enough compilers. I\\'ve got C++ and Java executing at 0ms, but stuck with stupid Python... I guess if there is no library function \"count trailing zeroes in factorial\" written in C, then it\\'s just crawling."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "Hacker !!!!\\n"
                    },
                    {
                        "username": "amit2020cs",
                        "content": "You checked the constraints to count the largest power of 5. Nice intuition"
                    },
                    {
                        "username": "heisenbergknocks",
                        "content": "\\t\\n\\tThis seems long but just read on.\\n\\n\\tThe number of 0s in n! is the number of 10s that can be generated by numbers\\n\\tfrom 1 to n!. 10 is a product of 2 and 5, so we just need to check\\n\\thow many 2x5 are present in n!\\n\\n\\tIf n = 5, then n! = 1x2x3x4x5. There is one 2 and 5 pair present\\n\\tin 5! which can make one 10. So numbers of 0s in 5! is one.\\n\\n\\tIf n = 10, then n! = 1x2x3x4x5x6x7x8x9x10 => this would have two zeros one from the\\n\\t2x5 and one from another 2x5 in 10.\\n\\n\\tIf n = 15, then n! = 1x2x3x4x5x6x7x8x9x10x11x12x13x14x15 => this would have three\\n\\tzeros one from the 2x5 and one from another 2x5 in 10 and one from a 5 in 15 which\\n\\twould give us a 0 by multiplying with any 2 from any even num from 1 to 15.\\n\\n\\tSince there are a lot more 2s than 5s in any n!, we just need to find the\\n\\tnumber of 5s in n! and that will be the answer. Eg.\\n\\n\\t5! -> one 0 as there is only one 5 from 1 to 5.\\n\\t10! -> two 0s as there are two 5s from 1 to 10.\\n\\t15! -> three 0s as there are three 5s from 1 to 10.\\n\\t20! -> four 0s as there are four 5s from 1 to 10.\\n\\n\\tHow to quickly count number of 5s in n!? Use n/5.\\n\\tAssume n = 15, using n / 5 we get 3, this tells us that there are at least\\n\\tthree multiples of 5 present in numbers from 1 to 15 namely\\n\\t5x1 = 5, 5x2 = 10 and 5x3 = 15.\\n\\tSo, we can get the number of 5s in n! and hence the number of 0s in n! using n / 5.\\n\\n\\tBut there is still one issue for numbers like 25, 125,\\n\\t625, which contain more than one 5 as their factor.\\n\\n\\tEg. for 25!, the number of 0s is = number of 0s in 20! + number of 0s which can be generated from 21 to 25\\n\\t= number of 0s in 20! + two 0s as there are two 5s present in 25 which would\\n\\tmultiple with any two 2s and make a 100 and give us 2 zeros.\\n\\t= so 25! has six 0s.\\n\\n\\tBut, going by the original formula we will calculate number of 0s in 25! as\\n\\t25/5 which is 5. So five 0s.\\n\\tNow, what we need to do is just divide this result of 5 again by 5\\n\\twhich gives us a 1 and add it to previous five 0s\\n\\n\\tIntuition: Keep dividing by 5 and adding the result to number of 0s."
                    },
                    {
                        "username": "johngroves",
                        "content": "` return n//5 + self.trailingZeroes(n//5) if n else 0`\\nHelpful background here:\\nhttp://www.purplemath.com/modules/factzero.htm"
                    },
                    {
                        "username": "nangao",
                        "content": "I Can't understand this problem"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "This should be easy, not medium  :)"
                    },
                    {
                        "username": "harsha335",
                        "content": "If you cannot get the intuition, it will be hard."
                    },
                    {
                        "username": "megaman14",
                        "content": "You want to find the number of times 10 goes into n, which means the number of times both 5 and 2 appear. Since we always have more 2\\'s than 5\\'s, to get the answer, we try to find the number of times 5 appears as a factor. This is equivalent to n/5. However, we have to account for the powers of 5: 25, 125, 625... Thus, if we multiply the iterator by 5 each time, ex: n/25, n/125, n/625...we can increment the count and get the answer. Now, all you need to do is to be careful about int overflow"
                    },
                    {
                        "username": "alex86",
                        "content": "Factorial of 0 is 1. "
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "Legitimately once I had example numbers to work with, this was much easier to tell what the pattern was. So here\\'s something in Haskell to print out all the factorials:\\n\\n```hs\\nmodule Main where\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nmain = withFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```\\n\\nor for ghci:\\n\\n```hs\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nwithFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```"
                    },
                    {
                        "username": "jzummo",
                        "content": "https://en.wikipedia.org/wiki/Legendre%27s_formula"
                    }
                ]
            },
            {
                "id": 2063628,
                "content": [
                    {
                        "username": "nextsde",
                        "content": "How can we tell from a number, how many trailing zeroes are at the end?\\n\\n10 = 10\\n1200 = 12 x 10 x 10\\n145000 = 145 x 10 x 10 x10\\n\\nFrom above example, we can clearly see number of 10\\'s in a number gives us number of trailing zeros in that number.\\n\\nSo, in our first brute force solution we can calcualte the n! and check how many 10\\'s are in there. That will give us the solution.\\n\\nBut, since n! will become very very large to calculate as n becomes bigger. So, this is not a feasible solution.\\n\\nWhat can we do?\\n\\nLet\\'s build some more intuition to see if we can find out the final hint we need.\\n\\nWhat is the property of 10?\\n\\nWe can get 10 from 2 & 5 (2x5). Can you get 10 in any other way? No.\\n\\nSo, let\\'s break it down further.\\n\\n10 = 2 x 5 [1(2),1(5)]\\n100 = 2 x 2 x 5 x 5 [2(2),2(5)]\\n120 = 2 x 2 x 2 x 3 x 5 [3(2),1(3),1(5)]\\n1200 = 2 x 2 x 2 x 2 x 3 x 5 x 5 [4(2),1(3),2(5)] //2 appears 4 times, 3 appears 1 time, 5 appears 2 times}\\n50 = 2 x 5 x 5 [1(2),2(5)]\\n\\nFrom above you will see, among 5 and 2 whichever appears lowest amount is the count of our trailing zeros.\\nBut for n!, we know we will have more 2\\'s than 5.\\nLet\\'s see an example:\\n5! = 1 x 2 x 3  x 4(2x2) x 5 = [3(2),1(5)]\\n\\nTry writing down couple more example and you will understand. So, in 25! how many 5 will be there?\\n\\n....x5....x10....x15....x20....x25 = x5...x2x5....x3x5....x4x5....x5x5 = 6 , Because 25 itself has 2 5\\'s in it.\\n\\nOk, up till this point we were still analyzing n!.\\n\\nBut we know if n>=5 it will have 5 as a factor.\\n\\nSo, based on our intuition so far.\\n\\nIf n=5 ... there will be 1(5)\\nIf n=10 ... there will be 2(5)\\nIf n=15 ... there will be 3(5)\\nIf n=25 ... there will be 5(5) + 1 (5)\\n\\nNow all we need to do is keep dividing n by 5 and add the result to our existing result until n get to 0.\\n\\nIf you are still having trouble getting the code, see this post https://nextswe.com/leetcode-172-factorial-trailing-zeroes/ . Code is provided at the end of explanation.\\nThanks"
                    },
                    {
                        "username": "naveen12124139",
                        "content": "//just return this\\nreturn n/3125+n/625+n/125+n/25+n/5;"
                    },
                    {
                        "username": "sergei99",
                        "content": "It only gets you to the top in languages with smart enough compilers. I\\'ve got C++ and Java executing at 0ms, but stuck with stupid Python... I guess if there is no library function \"count trailing zeroes in factorial\" written in C, then it\\'s just crawling."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "Hacker !!!!\\n"
                    },
                    {
                        "username": "amit2020cs",
                        "content": "You checked the constraints to count the largest power of 5. Nice intuition"
                    },
                    {
                        "username": "heisenbergknocks",
                        "content": "\\t\\n\\tThis seems long but just read on.\\n\\n\\tThe number of 0s in n! is the number of 10s that can be generated by numbers\\n\\tfrom 1 to n!. 10 is a product of 2 and 5, so we just need to check\\n\\thow many 2x5 are present in n!\\n\\n\\tIf n = 5, then n! = 1x2x3x4x5. There is one 2 and 5 pair present\\n\\tin 5! which can make one 10. So numbers of 0s in 5! is one.\\n\\n\\tIf n = 10, then n! = 1x2x3x4x5x6x7x8x9x10 => this would have two zeros one from the\\n\\t2x5 and one from another 2x5 in 10.\\n\\n\\tIf n = 15, then n! = 1x2x3x4x5x6x7x8x9x10x11x12x13x14x15 => this would have three\\n\\tzeros one from the 2x5 and one from another 2x5 in 10 and one from a 5 in 15 which\\n\\twould give us a 0 by multiplying with any 2 from any even num from 1 to 15.\\n\\n\\tSince there are a lot more 2s than 5s in any n!, we just need to find the\\n\\tnumber of 5s in n! and that will be the answer. Eg.\\n\\n\\t5! -> one 0 as there is only one 5 from 1 to 5.\\n\\t10! -> two 0s as there are two 5s from 1 to 10.\\n\\t15! -> three 0s as there are three 5s from 1 to 10.\\n\\t20! -> four 0s as there are four 5s from 1 to 10.\\n\\n\\tHow to quickly count number of 5s in n!? Use n/5.\\n\\tAssume n = 15, using n / 5 we get 3, this tells us that there are at least\\n\\tthree multiples of 5 present in numbers from 1 to 15 namely\\n\\t5x1 = 5, 5x2 = 10 and 5x3 = 15.\\n\\tSo, we can get the number of 5s in n! and hence the number of 0s in n! using n / 5.\\n\\n\\tBut there is still one issue for numbers like 25, 125,\\n\\t625, which contain more than one 5 as their factor.\\n\\n\\tEg. for 25!, the number of 0s is = number of 0s in 20! + number of 0s which can be generated from 21 to 25\\n\\t= number of 0s in 20! + two 0s as there are two 5s present in 25 which would\\n\\tmultiple with any two 2s and make a 100 and give us 2 zeros.\\n\\t= so 25! has six 0s.\\n\\n\\tBut, going by the original formula we will calculate number of 0s in 25! as\\n\\t25/5 which is 5. So five 0s.\\n\\tNow, what we need to do is just divide this result of 5 again by 5\\n\\twhich gives us a 1 and add it to previous five 0s\\n\\n\\tIntuition: Keep dividing by 5 and adding the result to number of 0s."
                    },
                    {
                        "username": "johngroves",
                        "content": "` return n//5 + self.trailingZeroes(n//5) if n else 0`\\nHelpful background here:\\nhttp://www.purplemath.com/modules/factzero.htm"
                    },
                    {
                        "username": "nangao",
                        "content": "I Can't understand this problem"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "This should be easy, not medium  :)"
                    },
                    {
                        "username": "harsha335",
                        "content": "If you cannot get the intuition, it will be hard."
                    },
                    {
                        "username": "megaman14",
                        "content": "You want to find the number of times 10 goes into n, which means the number of times both 5 and 2 appear. Since we always have more 2\\'s than 5\\'s, to get the answer, we try to find the number of times 5 appears as a factor. This is equivalent to n/5. However, we have to account for the powers of 5: 25, 125, 625... Thus, if we multiply the iterator by 5 each time, ex: n/25, n/125, n/625...we can increment the count and get the answer. Now, all you need to do is to be careful about int overflow"
                    },
                    {
                        "username": "alex86",
                        "content": "Factorial of 0 is 1. "
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "Legitimately once I had example numbers to work with, this was much easier to tell what the pattern was. So here\\'s something in Haskell to print out all the factorials:\\n\\n```hs\\nmodule Main where\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nmain = withFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```\\n\\nor for ghci:\\n\\n```hs\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nwithFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```"
                    },
                    {
                        "username": "jzummo",
                        "content": "https://en.wikipedia.org/wiki/Legendre%27s_formula"
                    }
                ]
            },
            {
                "id": 1568387,
                "content": [
                    {
                        "username": "nextsde",
                        "content": "How can we tell from a number, how many trailing zeroes are at the end?\\n\\n10 = 10\\n1200 = 12 x 10 x 10\\n145000 = 145 x 10 x 10 x10\\n\\nFrom above example, we can clearly see number of 10\\'s in a number gives us number of trailing zeros in that number.\\n\\nSo, in our first brute force solution we can calcualte the n! and check how many 10\\'s are in there. That will give us the solution.\\n\\nBut, since n! will become very very large to calculate as n becomes bigger. So, this is not a feasible solution.\\n\\nWhat can we do?\\n\\nLet\\'s build some more intuition to see if we can find out the final hint we need.\\n\\nWhat is the property of 10?\\n\\nWe can get 10 from 2 & 5 (2x5). Can you get 10 in any other way? No.\\n\\nSo, let\\'s break it down further.\\n\\n10 = 2 x 5 [1(2),1(5)]\\n100 = 2 x 2 x 5 x 5 [2(2),2(5)]\\n120 = 2 x 2 x 2 x 3 x 5 [3(2),1(3),1(5)]\\n1200 = 2 x 2 x 2 x 2 x 3 x 5 x 5 [4(2),1(3),2(5)] //2 appears 4 times, 3 appears 1 time, 5 appears 2 times}\\n50 = 2 x 5 x 5 [1(2),2(5)]\\n\\nFrom above you will see, among 5 and 2 whichever appears lowest amount is the count of our trailing zeros.\\nBut for n!, we know we will have more 2\\'s than 5.\\nLet\\'s see an example:\\n5! = 1 x 2 x 3  x 4(2x2) x 5 = [3(2),1(5)]\\n\\nTry writing down couple more example and you will understand. So, in 25! how many 5 will be there?\\n\\n....x5....x10....x15....x20....x25 = x5...x2x5....x3x5....x4x5....x5x5 = 6 , Because 25 itself has 2 5\\'s in it.\\n\\nOk, up till this point we were still analyzing n!.\\n\\nBut we know if n>=5 it will have 5 as a factor.\\n\\nSo, based on our intuition so far.\\n\\nIf n=5 ... there will be 1(5)\\nIf n=10 ... there will be 2(5)\\nIf n=15 ... there will be 3(5)\\nIf n=25 ... there will be 5(5) + 1 (5)\\n\\nNow all we need to do is keep dividing n by 5 and add the result to our existing result until n get to 0.\\n\\nIf you are still having trouble getting the code, see this post https://nextswe.com/leetcode-172-factorial-trailing-zeroes/ . Code is provided at the end of explanation.\\nThanks"
                    },
                    {
                        "username": "naveen12124139",
                        "content": "//just return this\\nreturn n/3125+n/625+n/125+n/25+n/5;"
                    },
                    {
                        "username": "sergei99",
                        "content": "It only gets you to the top in languages with smart enough compilers. I\\'ve got C++ and Java executing at 0ms, but stuck with stupid Python... I guess if there is no library function \"count trailing zeroes in factorial\" written in C, then it\\'s just crawling."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "Hacker !!!!\\n"
                    },
                    {
                        "username": "amit2020cs",
                        "content": "You checked the constraints to count the largest power of 5. Nice intuition"
                    },
                    {
                        "username": "heisenbergknocks",
                        "content": "\\t\\n\\tThis seems long but just read on.\\n\\n\\tThe number of 0s in n! is the number of 10s that can be generated by numbers\\n\\tfrom 1 to n!. 10 is a product of 2 and 5, so we just need to check\\n\\thow many 2x5 are present in n!\\n\\n\\tIf n = 5, then n! = 1x2x3x4x5. There is one 2 and 5 pair present\\n\\tin 5! which can make one 10. So numbers of 0s in 5! is one.\\n\\n\\tIf n = 10, then n! = 1x2x3x4x5x6x7x8x9x10 => this would have two zeros one from the\\n\\t2x5 and one from another 2x5 in 10.\\n\\n\\tIf n = 15, then n! = 1x2x3x4x5x6x7x8x9x10x11x12x13x14x15 => this would have three\\n\\tzeros one from the 2x5 and one from another 2x5 in 10 and one from a 5 in 15 which\\n\\twould give us a 0 by multiplying with any 2 from any even num from 1 to 15.\\n\\n\\tSince there are a lot more 2s than 5s in any n!, we just need to find the\\n\\tnumber of 5s in n! and that will be the answer. Eg.\\n\\n\\t5! -> one 0 as there is only one 5 from 1 to 5.\\n\\t10! -> two 0s as there are two 5s from 1 to 10.\\n\\t15! -> three 0s as there are three 5s from 1 to 10.\\n\\t20! -> four 0s as there are four 5s from 1 to 10.\\n\\n\\tHow to quickly count number of 5s in n!? Use n/5.\\n\\tAssume n = 15, using n / 5 we get 3, this tells us that there are at least\\n\\tthree multiples of 5 present in numbers from 1 to 15 namely\\n\\t5x1 = 5, 5x2 = 10 and 5x3 = 15.\\n\\tSo, we can get the number of 5s in n! and hence the number of 0s in n! using n / 5.\\n\\n\\tBut there is still one issue for numbers like 25, 125,\\n\\t625, which contain more than one 5 as their factor.\\n\\n\\tEg. for 25!, the number of 0s is = number of 0s in 20! + number of 0s which can be generated from 21 to 25\\n\\t= number of 0s in 20! + two 0s as there are two 5s present in 25 which would\\n\\tmultiple with any two 2s and make a 100 and give us 2 zeros.\\n\\t= so 25! has six 0s.\\n\\n\\tBut, going by the original formula we will calculate number of 0s in 25! as\\n\\t25/5 which is 5. So five 0s.\\n\\tNow, what we need to do is just divide this result of 5 again by 5\\n\\twhich gives us a 1 and add it to previous five 0s\\n\\n\\tIntuition: Keep dividing by 5 and adding the result to number of 0s."
                    },
                    {
                        "username": "johngroves",
                        "content": "` return n//5 + self.trailingZeroes(n//5) if n else 0`\\nHelpful background here:\\nhttp://www.purplemath.com/modules/factzero.htm"
                    },
                    {
                        "username": "nangao",
                        "content": "I Can't understand this problem"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "This should be easy, not medium  :)"
                    },
                    {
                        "username": "harsha335",
                        "content": "If you cannot get the intuition, it will be hard."
                    },
                    {
                        "username": "megaman14",
                        "content": "You want to find the number of times 10 goes into n, which means the number of times both 5 and 2 appear. Since we always have more 2\\'s than 5\\'s, to get the answer, we try to find the number of times 5 appears as a factor. This is equivalent to n/5. However, we have to account for the powers of 5: 25, 125, 625... Thus, if we multiply the iterator by 5 each time, ex: n/25, n/125, n/625...we can increment the count and get the answer. Now, all you need to do is to be careful about int overflow"
                    },
                    {
                        "username": "alex86",
                        "content": "Factorial of 0 is 1. "
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "Legitimately once I had example numbers to work with, this was much easier to tell what the pattern was. So here\\'s something in Haskell to print out all the factorials:\\n\\n```hs\\nmodule Main where\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nmain = withFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```\\n\\nor for ghci:\\n\\n```hs\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nwithFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```"
                    },
                    {
                        "username": "jzummo",
                        "content": "https://en.wikipedia.org/wiki/Legendre%27s_formula"
                    }
                ]
            },
            {
                "id": 1574696,
                "content": [
                    {
                        "username": "nextsde",
                        "content": "How can we tell from a number, how many trailing zeroes are at the end?\\n\\n10 = 10\\n1200 = 12 x 10 x 10\\n145000 = 145 x 10 x 10 x10\\n\\nFrom above example, we can clearly see number of 10\\'s in a number gives us number of trailing zeros in that number.\\n\\nSo, in our first brute force solution we can calcualte the n! and check how many 10\\'s are in there. That will give us the solution.\\n\\nBut, since n! will become very very large to calculate as n becomes bigger. So, this is not a feasible solution.\\n\\nWhat can we do?\\n\\nLet\\'s build some more intuition to see if we can find out the final hint we need.\\n\\nWhat is the property of 10?\\n\\nWe can get 10 from 2 & 5 (2x5). Can you get 10 in any other way? No.\\n\\nSo, let\\'s break it down further.\\n\\n10 = 2 x 5 [1(2),1(5)]\\n100 = 2 x 2 x 5 x 5 [2(2),2(5)]\\n120 = 2 x 2 x 2 x 3 x 5 [3(2),1(3),1(5)]\\n1200 = 2 x 2 x 2 x 2 x 3 x 5 x 5 [4(2),1(3),2(5)] //2 appears 4 times, 3 appears 1 time, 5 appears 2 times}\\n50 = 2 x 5 x 5 [1(2),2(5)]\\n\\nFrom above you will see, among 5 and 2 whichever appears lowest amount is the count of our trailing zeros.\\nBut for n!, we know we will have more 2\\'s than 5.\\nLet\\'s see an example:\\n5! = 1 x 2 x 3  x 4(2x2) x 5 = [3(2),1(5)]\\n\\nTry writing down couple more example and you will understand. So, in 25! how many 5 will be there?\\n\\n....x5....x10....x15....x20....x25 = x5...x2x5....x3x5....x4x5....x5x5 = 6 , Because 25 itself has 2 5\\'s in it.\\n\\nOk, up till this point we were still analyzing n!.\\n\\nBut we know if n>=5 it will have 5 as a factor.\\n\\nSo, based on our intuition so far.\\n\\nIf n=5 ... there will be 1(5)\\nIf n=10 ... there will be 2(5)\\nIf n=15 ... there will be 3(5)\\nIf n=25 ... there will be 5(5) + 1 (5)\\n\\nNow all we need to do is keep dividing n by 5 and add the result to our existing result until n get to 0.\\n\\nIf you are still having trouble getting the code, see this post https://nextswe.com/leetcode-172-factorial-trailing-zeroes/ . Code is provided at the end of explanation.\\nThanks"
                    },
                    {
                        "username": "naveen12124139",
                        "content": "//just return this\\nreturn n/3125+n/625+n/125+n/25+n/5;"
                    },
                    {
                        "username": "sergei99",
                        "content": "It only gets you to the top in languages with smart enough compilers. I\\'ve got C++ and Java executing at 0ms, but stuck with stupid Python... I guess if there is no library function \"count trailing zeroes in factorial\" written in C, then it\\'s just crawling."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "Hacker !!!!\\n"
                    },
                    {
                        "username": "amit2020cs",
                        "content": "You checked the constraints to count the largest power of 5. Nice intuition"
                    },
                    {
                        "username": "heisenbergknocks",
                        "content": "\\t\\n\\tThis seems long but just read on.\\n\\n\\tThe number of 0s in n! is the number of 10s that can be generated by numbers\\n\\tfrom 1 to n!. 10 is a product of 2 and 5, so we just need to check\\n\\thow many 2x5 are present in n!\\n\\n\\tIf n = 5, then n! = 1x2x3x4x5. There is one 2 and 5 pair present\\n\\tin 5! which can make one 10. So numbers of 0s in 5! is one.\\n\\n\\tIf n = 10, then n! = 1x2x3x4x5x6x7x8x9x10 => this would have two zeros one from the\\n\\t2x5 and one from another 2x5 in 10.\\n\\n\\tIf n = 15, then n! = 1x2x3x4x5x6x7x8x9x10x11x12x13x14x15 => this would have three\\n\\tzeros one from the 2x5 and one from another 2x5 in 10 and one from a 5 in 15 which\\n\\twould give us a 0 by multiplying with any 2 from any even num from 1 to 15.\\n\\n\\tSince there are a lot more 2s than 5s in any n!, we just need to find the\\n\\tnumber of 5s in n! and that will be the answer. Eg.\\n\\n\\t5! -> one 0 as there is only one 5 from 1 to 5.\\n\\t10! -> two 0s as there are two 5s from 1 to 10.\\n\\t15! -> three 0s as there are three 5s from 1 to 10.\\n\\t20! -> four 0s as there are four 5s from 1 to 10.\\n\\n\\tHow to quickly count number of 5s in n!? Use n/5.\\n\\tAssume n = 15, using n / 5 we get 3, this tells us that there are at least\\n\\tthree multiples of 5 present in numbers from 1 to 15 namely\\n\\t5x1 = 5, 5x2 = 10 and 5x3 = 15.\\n\\tSo, we can get the number of 5s in n! and hence the number of 0s in n! using n / 5.\\n\\n\\tBut there is still one issue for numbers like 25, 125,\\n\\t625, which contain more than one 5 as their factor.\\n\\n\\tEg. for 25!, the number of 0s is = number of 0s in 20! + number of 0s which can be generated from 21 to 25\\n\\t= number of 0s in 20! + two 0s as there are two 5s present in 25 which would\\n\\tmultiple with any two 2s and make a 100 and give us 2 zeros.\\n\\t= so 25! has six 0s.\\n\\n\\tBut, going by the original formula we will calculate number of 0s in 25! as\\n\\t25/5 which is 5. So five 0s.\\n\\tNow, what we need to do is just divide this result of 5 again by 5\\n\\twhich gives us a 1 and add it to previous five 0s\\n\\n\\tIntuition: Keep dividing by 5 and adding the result to number of 0s."
                    },
                    {
                        "username": "johngroves",
                        "content": "` return n//5 + self.trailingZeroes(n//5) if n else 0`\\nHelpful background here:\\nhttp://www.purplemath.com/modules/factzero.htm"
                    },
                    {
                        "username": "nangao",
                        "content": "I Can't understand this problem"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "This should be easy, not medium  :)"
                    },
                    {
                        "username": "harsha335",
                        "content": "If you cannot get the intuition, it will be hard."
                    },
                    {
                        "username": "megaman14",
                        "content": "You want to find the number of times 10 goes into n, which means the number of times both 5 and 2 appear. Since we always have more 2\\'s than 5\\'s, to get the answer, we try to find the number of times 5 appears as a factor. This is equivalent to n/5. However, we have to account for the powers of 5: 25, 125, 625... Thus, if we multiply the iterator by 5 each time, ex: n/25, n/125, n/625...we can increment the count and get the answer. Now, all you need to do is to be careful about int overflow"
                    },
                    {
                        "username": "alex86",
                        "content": "Factorial of 0 is 1. "
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "Legitimately once I had example numbers to work with, this was much easier to tell what the pattern was. So here\\'s something in Haskell to print out all the factorials:\\n\\n```hs\\nmodule Main where\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nmain = withFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```\\n\\nor for ghci:\\n\\n```hs\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nwithFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```"
                    },
                    {
                        "username": "jzummo",
                        "content": "https://en.wikipedia.org/wiki/Legendre%27s_formula"
                    }
                ]
            },
            {
                "id": 1570434,
                "content": [
                    {
                        "username": "nextsde",
                        "content": "How can we tell from a number, how many trailing zeroes are at the end?\\n\\n10 = 10\\n1200 = 12 x 10 x 10\\n145000 = 145 x 10 x 10 x10\\n\\nFrom above example, we can clearly see number of 10\\'s in a number gives us number of trailing zeros in that number.\\n\\nSo, in our first brute force solution we can calcualte the n! and check how many 10\\'s are in there. That will give us the solution.\\n\\nBut, since n! will become very very large to calculate as n becomes bigger. So, this is not a feasible solution.\\n\\nWhat can we do?\\n\\nLet\\'s build some more intuition to see if we can find out the final hint we need.\\n\\nWhat is the property of 10?\\n\\nWe can get 10 from 2 & 5 (2x5). Can you get 10 in any other way? No.\\n\\nSo, let\\'s break it down further.\\n\\n10 = 2 x 5 [1(2),1(5)]\\n100 = 2 x 2 x 5 x 5 [2(2),2(5)]\\n120 = 2 x 2 x 2 x 3 x 5 [3(2),1(3),1(5)]\\n1200 = 2 x 2 x 2 x 2 x 3 x 5 x 5 [4(2),1(3),2(5)] //2 appears 4 times, 3 appears 1 time, 5 appears 2 times}\\n50 = 2 x 5 x 5 [1(2),2(5)]\\n\\nFrom above you will see, among 5 and 2 whichever appears lowest amount is the count of our trailing zeros.\\nBut for n!, we know we will have more 2\\'s than 5.\\nLet\\'s see an example:\\n5! = 1 x 2 x 3  x 4(2x2) x 5 = [3(2),1(5)]\\n\\nTry writing down couple more example and you will understand. So, in 25! how many 5 will be there?\\n\\n....x5....x10....x15....x20....x25 = x5...x2x5....x3x5....x4x5....x5x5 = 6 , Because 25 itself has 2 5\\'s in it.\\n\\nOk, up till this point we were still analyzing n!.\\n\\nBut we know if n>=5 it will have 5 as a factor.\\n\\nSo, based on our intuition so far.\\n\\nIf n=5 ... there will be 1(5)\\nIf n=10 ... there will be 2(5)\\nIf n=15 ... there will be 3(5)\\nIf n=25 ... there will be 5(5) + 1 (5)\\n\\nNow all we need to do is keep dividing n by 5 and add the result to our existing result until n get to 0.\\n\\nIf you are still having trouble getting the code, see this post https://nextswe.com/leetcode-172-factorial-trailing-zeroes/ . Code is provided at the end of explanation.\\nThanks"
                    },
                    {
                        "username": "naveen12124139",
                        "content": "//just return this\\nreturn n/3125+n/625+n/125+n/25+n/5;"
                    },
                    {
                        "username": "sergei99",
                        "content": "It only gets you to the top in languages with smart enough compilers. I\\'ve got C++ and Java executing at 0ms, but stuck with stupid Python... I guess if there is no library function \"count trailing zeroes in factorial\" written in C, then it\\'s just crawling."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "Hacker !!!!\\n"
                    },
                    {
                        "username": "amit2020cs",
                        "content": "You checked the constraints to count the largest power of 5. Nice intuition"
                    },
                    {
                        "username": "heisenbergknocks",
                        "content": "\\t\\n\\tThis seems long but just read on.\\n\\n\\tThe number of 0s in n! is the number of 10s that can be generated by numbers\\n\\tfrom 1 to n!. 10 is a product of 2 and 5, so we just need to check\\n\\thow many 2x5 are present in n!\\n\\n\\tIf n = 5, then n! = 1x2x3x4x5. There is one 2 and 5 pair present\\n\\tin 5! which can make one 10. So numbers of 0s in 5! is one.\\n\\n\\tIf n = 10, then n! = 1x2x3x4x5x6x7x8x9x10 => this would have two zeros one from the\\n\\t2x5 and one from another 2x5 in 10.\\n\\n\\tIf n = 15, then n! = 1x2x3x4x5x6x7x8x9x10x11x12x13x14x15 => this would have three\\n\\tzeros one from the 2x5 and one from another 2x5 in 10 and one from a 5 in 15 which\\n\\twould give us a 0 by multiplying with any 2 from any even num from 1 to 15.\\n\\n\\tSince there are a lot more 2s than 5s in any n!, we just need to find the\\n\\tnumber of 5s in n! and that will be the answer. Eg.\\n\\n\\t5! -> one 0 as there is only one 5 from 1 to 5.\\n\\t10! -> two 0s as there are two 5s from 1 to 10.\\n\\t15! -> three 0s as there are three 5s from 1 to 10.\\n\\t20! -> four 0s as there are four 5s from 1 to 10.\\n\\n\\tHow to quickly count number of 5s in n!? Use n/5.\\n\\tAssume n = 15, using n / 5 we get 3, this tells us that there are at least\\n\\tthree multiples of 5 present in numbers from 1 to 15 namely\\n\\t5x1 = 5, 5x2 = 10 and 5x3 = 15.\\n\\tSo, we can get the number of 5s in n! and hence the number of 0s in n! using n / 5.\\n\\n\\tBut there is still one issue for numbers like 25, 125,\\n\\t625, which contain more than one 5 as their factor.\\n\\n\\tEg. for 25!, the number of 0s is = number of 0s in 20! + number of 0s which can be generated from 21 to 25\\n\\t= number of 0s in 20! + two 0s as there are two 5s present in 25 which would\\n\\tmultiple with any two 2s and make a 100 and give us 2 zeros.\\n\\t= so 25! has six 0s.\\n\\n\\tBut, going by the original formula we will calculate number of 0s in 25! as\\n\\t25/5 which is 5. So five 0s.\\n\\tNow, what we need to do is just divide this result of 5 again by 5\\n\\twhich gives us a 1 and add it to previous five 0s\\n\\n\\tIntuition: Keep dividing by 5 and adding the result to number of 0s."
                    },
                    {
                        "username": "johngroves",
                        "content": "` return n//5 + self.trailingZeroes(n//5) if n else 0`\\nHelpful background here:\\nhttp://www.purplemath.com/modules/factzero.htm"
                    },
                    {
                        "username": "nangao",
                        "content": "I Can't understand this problem"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "This should be easy, not medium  :)"
                    },
                    {
                        "username": "harsha335",
                        "content": "If you cannot get the intuition, it will be hard."
                    },
                    {
                        "username": "megaman14",
                        "content": "You want to find the number of times 10 goes into n, which means the number of times both 5 and 2 appear. Since we always have more 2\\'s than 5\\'s, to get the answer, we try to find the number of times 5 appears as a factor. This is equivalent to n/5. However, we have to account for the powers of 5: 25, 125, 625... Thus, if we multiply the iterator by 5 each time, ex: n/25, n/125, n/625...we can increment the count and get the answer. Now, all you need to do is to be careful about int overflow"
                    },
                    {
                        "username": "alex86",
                        "content": "Factorial of 0 is 1. "
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "Legitimately once I had example numbers to work with, this was much easier to tell what the pattern was. So here\\'s something in Haskell to print out all the factorials:\\n\\n```hs\\nmodule Main where\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nmain = withFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```\\n\\nor for ghci:\\n\\n```hs\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nwithFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```"
                    },
                    {
                        "username": "jzummo",
                        "content": "https://en.wikipedia.org/wiki/Legendre%27s_formula"
                    }
                ]
            },
            {
                "id": 1571376,
                "content": [
                    {
                        "username": "nextsde",
                        "content": "How can we tell from a number, how many trailing zeroes are at the end?\\n\\n10 = 10\\n1200 = 12 x 10 x 10\\n145000 = 145 x 10 x 10 x10\\n\\nFrom above example, we can clearly see number of 10\\'s in a number gives us number of trailing zeros in that number.\\n\\nSo, in our first brute force solution we can calcualte the n! and check how many 10\\'s are in there. That will give us the solution.\\n\\nBut, since n! will become very very large to calculate as n becomes bigger. So, this is not a feasible solution.\\n\\nWhat can we do?\\n\\nLet\\'s build some more intuition to see if we can find out the final hint we need.\\n\\nWhat is the property of 10?\\n\\nWe can get 10 from 2 & 5 (2x5). Can you get 10 in any other way? No.\\n\\nSo, let\\'s break it down further.\\n\\n10 = 2 x 5 [1(2),1(5)]\\n100 = 2 x 2 x 5 x 5 [2(2),2(5)]\\n120 = 2 x 2 x 2 x 3 x 5 [3(2),1(3),1(5)]\\n1200 = 2 x 2 x 2 x 2 x 3 x 5 x 5 [4(2),1(3),2(5)] //2 appears 4 times, 3 appears 1 time, 5 appears 2 times}\\n50 = 2 x 5 x 5 [1(2),2(5)]\\n\\nFrom above you will see, among 5 and 2 whichever appears lowest amount is the count of our trailing zeros.\\nBut for n!, we know we will have more 2\\'s than 5.\\nLet\\'s see an example:\\n5! = 1 x 2 x 3  x 4(2x2) x 5 = [3(2),1(5)]\\n\\nTry writing down couple more example and you will understand. So, in 25! how many 5 will be there?\\n\\n....x5....x10....x15....x20....x25 = x5...x2x5....x3x5....x4x5....x5x5 = 6 , Because 25 itself has 2 5\\'s in it.\\n\\nOk, up till this point we were still analyzing n!.\\n\\nBut we know if n>=5 it will have 5 as a factor.\\n\\nSo, based on our intuition so far.\\n\\nIf n=5 ... there will be 1(5)\\nIf n=10 ... there will be 2(5)\\nIf n=15 ... there will be 3(5)\\nIf n=25 ... there will be 5(5) + 1 (5)\\n\\nNow all we need to do is keep dividing n by 5 and add the result to our existing result until n get to 0.\\n\\nIf you are still having trouble getting the code, see this post https://nextswe.com/leetcode-172-factorial-trailing-zeroes/ . Code is provided at the end of explanation.\\nThanks"
                    },
                    {
                        "username": "naveen12124139",
                        "content": "//just return this\\nreturn n/3125+n/625+n/125+n/25+n/5;"
                    },
                    {
                        "username": "sergei99",
                        "content": "It only gets you to the top in languages with smart enough compilers. I\\'ve got C++ and Java executing at 0ms, but stuck with stupid Python... I guess if there is no library function \"count trailing zeroes in factorial\" written in C, then it\\'s just crawling."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "Hacker !!!!\\n"
                    },
                    {
                        "username": "amit2020cs",
                        "content": "You checked the constraints to count the largest power of 5. Nice intuition"
                    },
                    {
                        "username": "heisenbergknocks",
                        "content": "\\t\\n\\tThis seems long but just read on.\\n\\n\\tThe number of 0s in n! is the number of 10s that can be generated by numbers\\n\\tfrom 1 to n!. 10 is a product of 2 and 5, so we just need to check\\n\\thow many 2x5 are present in n!\\n\\n\\tIf n = 5, then n! = 1x2x3x4x5. There is one 2 and 5 pair present\\n\\tin 5! which can make one 10. So numbers of 0s in 5! is one.\\n\\n\\tIf n = 10, then n! = 1x2x3x4x5x6x7x8x9x10 => this would have two zeros one from the\\n\\t2x5 and one from another 2x5 in 10.\\n\\n\\tIf n = 15, then n! = 1x2x3x4x5x6x7x8x9x10x11x12x13x14x15 => this would have three\\n\\tzeros one from the 2x5 and one from another 2x5 in 10 and one from a 5 in 15 which\\n\\twould give us a 0 by multiplying with any 2 from any even num from 1 to 15.\\n\\n\\tSince there are a lot more 2s than 5s in any n!, we just need to find the\\n\\tnumber of 5s in n! and that will be the answer. Eg.\\n\\n\\t5! -> one 0 as there is only one 5 from 1 to 5.\\n\\t10! -> two 0s as there are two 5s from 1 to 10.\\n\\t15! -> three 0s as there are three 5s from 1 to 10.\\n\\t20! -> four 0s as there are four 5s from 1 to 10.\\n\\n\\tHow to quickly count number of 5s in n!? Use n/5.\\n\\tAssume n = 15, using n / 5 we get 3, this tells us that there are at least\\n\\tthree multiples of 5 present in numbers from 1 to 15 namely\\n\\t5x1 = 5, 5x2 = 10 and 5x3 = 15.\\n\\tSo, we can get the number of 5s in n! and hence the number of 0s in n! using n / 5.\\n\\n\\tBut there is still one issue for numbers like 25, 125,\\n\\t625, which contain more than one 5 as their factor.\\n\\n\\tEg. for 25!, the number of 0s is = number of 0s in 20! + number of 0s which can be generated from 21 to 25\\n\\t= number of 0s in 20! + two 0s as there are two 5s present in 25 which would\\n\\tmultiple with any two 2s and make a 100 and give us 2 zeros.\\n\\t= so 25! has six 0s.\\n\\n\\tBut, going by the original formula we will calculate number of 0s in 25! as\\n\\t25/5 which is 5. So five 0s.\\n\\tNow, what we need to do is just divide this result of 5 again by 5\\n\\twhich gives us a 1 and add it to previous five 0s\\n\\n\\tIntuition: Keep dividing by 5 and adding the result to number of 0s."
                    },
                    {
                        "username": "johngroves",
                        "content": "` return n//5 + self.trailingZeroes(n//5) if n else 0`\\nHelpful background here:\\nhttp://www.purplemath.com/modules/factzero.htm"
                    },
                    {
                        "username": "nangao",
                        "content": "I Can't understand this problem"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "This should be easy, not medium  :)"
                    },
                    {
                        "username": "harsha335",
                        "content": "If you cannot get the intuition, it will be hard."
                    },
                    {
                        "username": "megaman14",
                        "content": "You want to find the number of times 10 goes into n, which means the number of times both 5 and 2 appear. Since we always have more 2\\'s than 5\\'s, to get the answer, we try to find the number of times 5 appears as a factor. This is equivalent to n/5. However, we have to account for the powers of 5: 25, 125, 625... Thus, if we multiply the iterator by 5 each time, ex: n/25, n/125, n/625...we can increment the count and get the answer. Now, all you need to do is to be careful about int overflow"
                    },
                    {
                        "username": "alex86",
                        "content": "Factorial of 0 is 1. "
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "Legitimately once I had example numbers to work with, this was much easier to tell what the pattern was. So here\\'s something in Haskell to print out all the factorials:\\n\\n```hs\\nmodule Main where\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nmain = withFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```\\n\\nor for ghci:\\n\\n```hs\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nwithFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```"
                    },
                    {
                        "username": "jzummo",
                        "content": "https://en.wikipedia.org/wiki/Legendre%27s_formula"
                    }
                ]
            },
            {
                "id": 1571377,
                "content": [
                    {
                        "username": "nextsde",
                        "content": "How can we tell from a number, how many trailing zeroes are at the end?\\n\\n10 = 10\\n1200 = 12 x 10 x 10\\n145000 = 145 x 10 x 10 x10\\n\\nFrom above example, we can clearly see number of 10\\'s in a number gives us number of trailing zeros in that number.\\n\\nSo, in our first brute force solution we can calcualte the n! and check how many 10\\'s are in there. That will give us the solution.\\n\\nBut, since n! will become very very large to calculate as n becomes bigger. So, this is not a feasible solution.\\n\\nWhat can we do?\\n\\nLet\\'s build some more intuition to see if we can find out the final hint we need.\\n\\nWhat is the property of 10?\\n\\nWe can get 10 from 2 & 5 (2x5). Can you get 10 in any other way? No.\\n\\nSo, let\\'s break it down further.\\n\\n10 = 2 x 5 [1(2),1(5)]\\n100 = 2 x 2 x 5 x 5 [2(2),2(5)]\\n120 = 2 x 2 x 2 x 3 x 5 [3(2),1(3),1(5)]\\n1200 = 2 x 2 x 2 x 2 x 3 x 5 x 5 [4(2),1(3),2(5)] //2 appears 4 times, 3 appears 1 time, 5 appears 2 times}\\n50 = 2 x 5 x 5 [1(2),2(5)]\\n\\nFrom above you will see, among 5 and 2 whichever appears lowest amount is the count of our trailing zeros.\\nBut for n!, we know we will have more 2\\'s than 5.\\nLet\\'s see an example:\\n5! = 1 x 2 x 3  x 4(2x2) x 5 = [3(2),1(5)]\\n\\nTry writing down couple more example and you will understand. So, in 25! how many 5 will be there?\\n\\n....x5....x10....x15....x20....x25 = x5...x2x5....x3x5....x4x5....x5x5 = 6 , Because 25 itself has 2 5\\'s in it.\\n\\nOk, up till this point we were still analyzing n!.\\n\\nBut we know if n>=5 it will have 5 as a factor.\\n\\nSo, based on our intuition so far.\\n\\nIf n=5 ... there will be 1(5)\\nIf n=10 ... there will be 2(5)\\nIf n=15 ... there will be 3(5)\\nIf n=25 ... there will be 5(5) + 1 (5)\\n\\nNow all we need to do is keep dividing n by 5 and add the result to our existing result until n get to 0.\\n\\nIf you are still having trouble getting the code, see this post https://nextswe.com/leetcode-172-factorial-trailing-zeroes/ . Code is provided at the end of explanation.\\nThanks"
                    },
                    {
                        "username": "naveen12124139",
                        "content": "//just return this\\nreturn n/3125+n/625+n/125+n/25+n/5;"
                    },
                    {
                        "username": "sergei99",
                        "content": "It only gets you to the top in languages with smart enough compilers. I\\'ve got C++ and Java executing at 0ms, but stuck with stupid Python... I guess if there is no library function \"count trailing zeroes in factorial\" written in C, then it\\'s just crawling."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "Hacker !!!!\\n"
                    },
                    {
                        "username": "amit2020cs",
                        "content": "You checked the constraints to count the largest power of 5. Nice intuition"
                    },
                    {
                        "username": "heisenbergknocks",
                        "content": "\\t\\n\\tThis seems long but just read on.\\n\\n\\tThe number of 0s in n! is the number of 10s that can be generated by numbers\\n\\tfrom 1 to n!. 10 is a product of 2 and 5, so we just need to check\\n\\thow many 2x5 are present in n!\\n\\n\\tIf n = 5, then n! = 1x2x3x4x5. There is one 2 and 5 pair present\\n\\tin 5! which can make one 10. So numbers of 0s in 5! is one.\\n\\n\\tIf n = 10, then n! = 1x2x3x4x5x6x7x8x9x10 => this would have two zeros one from the\\n\\t2x5 and one from another 2x5 in 10.\\n\\n\\tIf n = 15, then n! = 1x2x3x4x5x6x7x8x9x10x11x12x13x14x15 => this would have three\\n\\tzeros one from the 2x5 and one from another 2x5 in 10 and one from a 5 in 15 which\\n\\twould give us a 0 by multiplying with any 2 from any even num from 1 to 15.\\n\\n\\tSince there are a lot more 2s than 5s in any n!, we just need to find the\\n\\tnumber of 5s in n! and that will be the answer. Eg.\\n\\n\\t5! -> one 0 as there is only one 5 from 1 to 5.\\n\\t10! -> two 0s as there are two 5s from 1 to 10.\\n\\t15! -> three 0s as there are three 5s from 1 to 10.\\n\\t20! -> four 0s as there are four 5s from 1 to 10.\\n\\n\\tHow to quickly count number of 5s in n!? Use n/5.\\n\\tAssume n = 15, using n / 5 we get 3, this tells us that there are at least\\n\\tthree multiples of 5 present in numbers from 1 to 15 namely\\n\\t5x1 = 5, 5x2 = 10 and 5x3 = 15.\\n\\tSo, we can get the number of 5s in n! and hence the number of 0s in n! using n / 5.\\n\\n\\tBut there is still one issue for numbers like 25, 125,\\n\\t625, which contain more than one 5 as their factor.\\n\\n\\tEg. for 25!, the number of 0s is = number of 0s in 20! + number of 0s which can be generated from 21 to 25\\n\\t= number of 0s in 20! + two 0s as there are two 5s present in 25 which would\\n\\tmultiple with any two 2s and make a 100 and give us 2 zeros.\\n\\t= so 25! has six 0s.\\n\\n\\tBut, going by the original formula we will calculate number of 0s in 25! as\\n\\t25/5 which is 5. So five 0s.\\n\\tNow, what we need to do is just divide this result of 5 again by 5\\n\\twhich gives us a 1 and add it to previous five 0s\\n\\n\\tIntuition: Keep dividing by 5 and adding the result to number of 0s."
                    },
                    {
                        "username": "johngroves",
                        "content": "` return n//5 + self.trailingZeroes(n//5) if n else 0`\\nHelpful background here:\\nhttp://www.purplemath.com/modules/factzero.htm"
                    },
                    {
                        "username": "nangao",
                        "content": "I Can't understand this problem"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "This should be easy, not medium  :)"
                    },
                    {
                        "username": "harsha335",
                        "content": "If you cannot get the intuition, it will be hard."
                    },
                    {
                        "username": "megaman14",
                        "content": "You want to find the number of times 10 goes into n, which means the number of times both 5 and 2 appear. Since we always have more 2\\'s than 5\\'s, to get the answer, we try to find the number of times 5 appears as a factor. This is equivalent to n/5. However, we have to account for the powers of 5: 25, 125, 625... Thus, if we multiply the iterator by 5 each time, ex: n/25, n/125, n/625...we can increment the count and get the answer. Now, all you need to do is to be careful about int overflow"
                    },
                    {
                        "username": "alex86",
                        "content": "Factorial of 0 is 1. "
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "Legitimately once I had example numbers to work with, this was much easier to tell what the pattern was. So here\\'s something in Haskell to print out all the factorials:\\n\\n```hs\\nmodule Main where\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nmain = withFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```\\n\\nor for ghci:\\n\\n```hs\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nwithFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```"
                    },
                    {
                        "username": "jzummo",
                        "content": "https://en.wikipedia.org/wiki/Legendre%27s_formula"
                    }
                ]
            },
            {
                "id": 2007404,
                "content": [
                    {
                        "username": "nextsde",
                        "content": "How can we tell from a number, how many trailing zeroes are at the end?\\n\\n10 = 10\\n1200 = 12 x 10 x 10\\n145000 = 145 x 10 x 10 x10\\n\\nFrom above example, we can clearly see number of 10\\'s in a number gives us number of trailing zeros in that number.\\n\\nSo, in our first brute force solution we can calcualte the n! and check how many 10\\'s are in there. That will give us the solution.\\n\\nBut, since n! will become very very large to calculate as n becomes bigger. So, this is not a feasible solution.\\n\\nWhat can we do?\\n\\nLet\\'s build some more intuition to see if we can find out the final hint we need.\\n\\nWhat is the property of 10?\\n\\nWe can get 10 from 2 & 5 (2x5). Can you get 10 in any other way? No.\\n\\nSo, let\\'s break it down further.\\n\\n10 = 2 x 5 [1(2),1(5)]\\n100 = 2 x 2 x 5 x 5 [2(2),2(5)]\\n120 = 2 x 2 x 2 x 3 x 5 [3(2),1(3),1(5)]\\n1200 = 2 x 2 x 2 x 2 x 3 x 5 x 5 [4(2),1(3),2(5)] //2 appears 4 times, 3 appears 1 time, 5 appears 2 times}\\n50 = 2 x 5 x 5 [1(2),2(5)]\\n\\nFrom above you will see, among 5 and 2 whichever appears lowest amount is the count of our trailing zeros.\\nBut for n!, we know we will have more 2\\'s than 5.\\nLet\\'s see an example:\\n5! = 1 x 2 x 3  x 4(2x2) x 5 = [3(2),1(5)]\\n\\nTry writing down couple more example and you will understand. So, in 25! how many 5 will be there?\\n\\n....x5....x10....x15....x20....x25 = x5...x2x5....x3x5....x4x5....x5x5 = 6 , Because 25 itself has 2 5\\'s in it.\\n\\nOk, up till this point we were still analyzing n!.\\n\\nBut we know if n>=5 it will have 5 as a factor.\\n\\nSo, based on our intuition so far.\\n\\nIf n=5 ... there will be 1(5)\\nIf n=10 ... there will be 2(5)\\nIf n=15 ... there will be 3(5)\\nIf n=25 ... there will be 5(5) + 1 (5)\\n\\nNow all we need to do is keep dividing n by 5 and add the result to our existing result until n get to 0.\\n\\nIf you are still having trouble getting the code, see this post https://nextswe.com/leetcode-172-factorial-trailing-zeroes/ . Code is provided at the end of explanation.\\nThanks"
                    },
                    {
                        "username": "naveen12124139",
                        "content": "//just return this\\nreturn n/3125+n/625+n/125+n/25+n/5;"
                    },
                    {
                        "username": "sergei99",
                        "content": "It only gets you to the top in languages with smart enough compilers. I\\'ve got C++ and Java executing at 0ms, but stuck with stupid Python... I guess if there is no library function \"count trailing zeroes in factorial\" written in C, then it\\'s just crawling."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "Hacker !!!!\\n"
                    },
                    {
                        "username": "amit2020cs",
                        "content": "You checked the constraints to count the largest power of 5. Nice intuition"
                    },
                    {
                        "username": "heisenbergknocks",
                        "content": "\\t\\n\\tThis seems long but just read on.\\n\\n\\tThe number of 0s in n! is the number of 10s that can be generated by numbers\\n\\tfrom 1 to n!. 10 is a product of 2 and 5, so we just need to check\\n\\thow many 2x5 are present in n!\\n\\n\\tIf n = 5, then n! = 1x2x3x4x5. There is one 2 and 5 pair present\\n\\tin 5! which can make one 10. So numbers of 0s in 5! is one.\\n\\n\\tIf n = 10, then n! = 1x2x3x4x5x6x7x8x9x10 => this would have two zeros one from the\\n\\t2x5 and one from another 2x5 in 10.\\n\\n\\tIf n = 15, then n! = 1x2x3x4x5x6x7x8x9x10x11x12x13x14x15 => this would have three\\n\\tzeros one from the 2x5 and one from another 2x5 in 10 and one from a 5 in 15 which\\n\\twould give us a 0 by multiplying with any 2 from any even num from 1 to 15.\\n\\n\\tSince there are a lot more 2s than 5s in any n!, we just need to find the\\n\\tnumber of 5s in n! and that will be the answer. Eg.\\n\\n\\t5! -> one 0 as there is only one 5 from 1 to 5.\\n\\t10! -> two 0s as there are two 5s from 1 to 10.\\n\\t15! -> three 0s as there are three 5s from 1 to 10.\\n\\t20! -> four 0s as there are four 5s from 1 to 10.\\n\\n\\tHow to quickly count number of 5s in n!? Use n/5.\\n\\tAssume n = 15, using n / 5 we get 3, this tells us that there are at least\\n\\tthree multiples of 5 present in numbers from 1 to 15 namely\\n\\t5x1 = 5, 5x2 = 10 and 5x3 = 15.\\n\\tSo, we can get the number of 5s in n! and hence the number of 0s in n! using n / 5.\\n\\n\\tBut there is still one issue for numbers like 25, 125,\\n\\t625, which contain more than one 5 as their factor.\\n\\n\\tEg. for 25!, the number of 0s is = number of 0s in 20! + number of 0s which can be generated from 21 to 25\\n\\t= number of 0s in 20! + two 0s as there are two 5s present in 25 which would\\n\\tmultiple with any two 2s and make a 100 and give us 2 zeros.\\n\\t= so 25! has six 0s.\\n\\n\\tBut, going by the original formula we will calculate number of 0s in 25! as\\n\\t25/5 which is 5. So five 0s.\\n\\tNow, what we need to do is just divide this result of 5 again by 5\\n\\twhich gives us a 1 and add it to previous five 0s\\n\\n\\tIntuition: Keep dividing by 5 and adding the result to number of 0s."
                    },
                    {
                        "username": "johngroves",
                        "content": "` return n//5 + self.trailingZeroes(n//5) if n else 0`\\nHelpful background here:\\nhttp://www.purplemath.com/modules/factzero.htm"
                    },
                    {
                        "username": "nangao",
                        "content": "I Can't understand this problem"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "This should be easy, not medium  :)"
                    },
                    {
                        "username": "harsha335",
                        "content": "If you cannot get the intuition, it will be hard."
                    },
                    {
                        "username": "megaman14",
                        "content": "You want to find the number of times 10 goes into n, which means the number of times both 5 and 2 appear. Since we always have more 2\\'s than 5\\'s, to get the answer, we try to find the number of times 5 appears as a factor. This is equivalent to n/5. However, we have to account for the powers of 5: 25, 125, 625... Thus, if we multiply the iterator by 5 each time, ex: n/25, n/125, n/625...we can increment the count and get the answer. Now, all you need to do is to be careful about int overflow"
                    },
                    {
                        "username": "alex86",
                        "content": "Factorial of 0 is 1. "
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "Legitimately once I had example numbers to work with, this was much easier to tell what the pattern was. So here\\'s something in Haskell to print out all the factorials:\\n\\n```hs\\nmodule Main where\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nmain = withFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```\\n\\nor for ghci:\\n\\n```hs\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nwithFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```"
                    },
                    {
                        "username": "jzummo",
                        "content": "https://en.wikipedia.org/wiki/Legendre%27s_formula"
                    }
                ]
            },
            {
                "id": 1569593,
                "content": [
                    {
                        "username": "nextsde",
                        "content": "How can we tell from a number, how many trailing zeroes are at the end?\\n\\n10 = 10\\n1200 = 12 x 10 x 10\\n145000 = 145 x 10 x 10 x10\\n\\nFrom above example, we can clearly see number of 10\\'s in a number gives us number of trailing zeros in that number.\\n\\nSo, in our first brute force solution we can calcualte the n! and check how many 10\\'s are in there. That will give us the solution.\\n\\nBut, since n! will become very very large to calculate as n becomes bigger. So, this is not a feasible solution.\\n\\nWhat can we do?\\n\\nLet\\'s build some more intuition to see if we can find out the final hint we need.\\n\\nWhat is the property of 10?\\n\\nWe can get 10 from 2 & 5 (2x5). Can you get 10 in any other way? No.\\n\\nSo, let\\'s break it down further.\\n\\n10 = 2 x 5 [1(2),1(5)]\\n100 = 2 x 2 x 5 x 5 [2(2),2(5)]\\n120 = 2 x 2 x 2 x 3 x 5 [3(2),1(3),1(5)]\\n1200 = 2 x 2 x 2 x 2 x 3 x 5 x 5 [4(2),1(3),2(5)] //2 appears 4 times, 3 appears 1 time, 5 appears 2 times}\\n50 = 2 x 5 x 5 [1(2),2(5)]\\n\\nFrom above you will see, among 5 and 2 whichever appears lowest amount is the count of our trailing zeros.\\nBut for n!, we know we will have more 2\\'s than 5.\\nLet\\'s see an example:\\n5! = 1 x 2 x 3  x 4(2x2) x 5 = [3(2),1(5)]\\n\\nTry writing down couple more example and you will understand. So, in 25! how many 5 will be there?\\n\\n....x5....x10....x15....x20....x25 = x5...x2x5....x3x5....x4x5....x5x5 = 6 , Because 25 itself has 2 5\\'s in it.\\n\\nOk, up till this point we were still analyzing n!.\\n\\nBut we know if n>=5 it will have 5 as a factor.\\n\\nSo, based on our intuition so far.\\n\\nIf n=5 ... there will be 1(5)\\nIf n=10 ... there will be 2(5)\\nIf n=15 ... there will be 3(5)\\nIf n=25 ... there will be 5(5) + 1 (5)\\n\\nNow all we need to do is keep dividing n by 5 and add the result to our existing result until n get to 0.\\n\\nIf you are still having trouble getting the code, see this post https://nextswe.com/leetcode-172-factorial-trailing-zeroes/ . Code is provided at the end of explanation.\\nThanks"
                    },
                    {
                        "username": "naveen12124139",
                        "content": "//just return this\\nreturn n/3125+n/625+n/125+n/25+n/5;"
                    },
                    {
                        "username": "sergei99",
                        "content": "It only gets you to the top in languages with smart enough compilers. I\\'ve got C++ and Java executing at 0ms, but stuck with stupid Python... I guess if there is no library function \"count trailing zeroes in factorial\" written in C, then it\\'s just crawling."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "Hacker !!!!\\n"
                    },
                    {
                        "username": "amit2020cs",
                        "content": "You checked the constraints to count the largest power of 5. Nice intuition"
                    },
                    {
                        "username": "heisenbergknocks",
                        "content": "\\t\\n\\tThis seems long but just read on.\\n\\n\\tThe number of 0s in n! is the number of 10s that can be generated by numbers\\n\\tfrom 1 to n!. 10 is a product of 2 and 5, so we just need to check\\n\\thow many 2x5 are present in n!\\n\\n\\tIf n = 5, then n! = 1x2x3x4x5. There is one 2 and 5 pair present\\n\\tin 5! which can make one 10. So numbers of 0s in 5! is one.\\n\\n\\tIf n = 10, then n! = 1x2x3x4x5x6x7x8x9x10 => this would have two zeros one from the\\n\\t2x5 and one from another 2x5 in 10.\\n\\n\\tIf n = 15, then n! = 1x2x3x4x5x6x7x8x9x10x11x12x13x14x15 => this would have three\\n\\tzeros one from the 2x5 and one from another 2x5 in 10 and one from a 5 in 15 which\\n\\twould give us a 0 by multiplying with any 2 from any even num from 1 to 15.\\n\\n\\tSince there are a lot more 2s than 5s in any n!, we just need to find the\\n\\tnumber of 5s in n! and that will be the answer. Eg.\\n\\n\\t5! -> one 0 as there is only one 5 from 1 to 5.\\n\\t10! -> two 0s as there are two 5s from 1 to 10.\\n\\t15! -> three 0s as there are three 5s from 1 to 10.\\n\\t20! -> four 0s as there are four 5s from 1 to 10.\\n\\n\\tHow to quickly count number of 5s in n!? Use n/5.\\n\\tAssume n = 15, using n / 5 we get 3, this tells us that there are at least\\n\\tthree multiples of 5 present in numbers from 1 to 15 namely\\n\\t5x1 = 5, 5x2 = 10 and 5x3 = 15.\\n\\tSo, we can get the number of 5s in n! and hence the number of 0s in n! using n / 5.\\n\\n\\tBut there is still one issue for numbers like 25, 125,\\n\\t625, which contain more than one 5 as their factor.\\n\\n\\tEg. for 25!, the number of 0s is = number of 0s in 20! + number of 0s which can be generated from 21 to 25\\n\\t= number of 0s in 20! + two 0s as there are two 5s present in 25 which would\\n\\tmultiple with any two 2s and make a 100 and give us 2 zeros.\\n\\t= so 25! has six 0s.\\n\\n\\tBut, going by the original formula we will calculate number of 0s in 25! as\\n\\t25/5 which is 5. So five 0s.\\n\\tNow, what we need to do is just divide this result of 5 again by 5\\n\\twhich gives us a 1 and add it to previous five 0s\\n\\n\\tIntuition: Keep dividing by 5 and adding the result to number of 0s."
                    },
                    {
                        "username": "johngroves",
                        "content": "` return n//5 + self.trailingZeroes(n//5) if n else 0`\\nHelpful background here:\\nhttp://www.purplemath.com/modules/factzero.htm"
                    },
                    {
                        "username": "nangao",
                        "content": "I Can't understand this problem"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "This should be easy, not medium  :)"
                    },
                    {
                        "username": "harsha335",
                        "content": "If you cannot get the intuition, it will be hard."
                    },
                    {
                        "username": "megaman14",
                        "content": "You want to find the number of times 10 goes into n, which means the number of times both 5 and 2 appear. Since we always have more 2\\'s than 5\\'s, to get the answer, we try to find the number of times 5 appears as a factor. This is equivalent to n/5. However, we have to account for the powers of 5: 25, 125, 625... Thus, if we multiply the iterator by 5 each time, ex: n/25, n/125, n/625...we can increment the count and get the answer. Now, all you need to do is to be careful about int overflow"
                    },
                    {
                        "username": "alex86",
                        "content": "Factorial of 0 is 1. "
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "Legitimately once I had example numbers to work with, this was much easier to tell what the pattern was. So here\\'s something in Haskell to print out all the factorials:\\n\\n```hs\\nmodule Main where\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nmain = withFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```\\n\\nor for ghci:\\n\\n```hs\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nwithFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```"
                    },
                    {
                        "username": "jzummo",
                        "content": "https://en.wikipedia.org/wiki/Legendre%27s_formula"
                    }
                ]
            },
            {
                "id": 1975879,
                "content": [
                    {
                        "username": "nextsde",
                        "content": "How can we tell from a number, how many trailing zeroes are at the end?\\n\\n10 = 10\\n1200 = 12 x 10 x 10\\n145000 = 145 x 10 x 10 x10\\n\\nFrom above example, we can clearly see number of 10\\'s in a number gives us number of trailing zeros in that number.\\n\\nSo, in our first brute force solution we can calcualte the n! and check how many 10\\'s are in there. That will give us the solution.\\n\\nBut, since n! will become very very large to calculate as n becomes bigger. So, this is not a feasible solution.\\n\\nWhat can we do?\\n\\nLet\\'s build some more intuition to see if we can find out the final hint we need.\\n\\nWhat is the property of 10?\\n\\nWe can get 10 from 2 & 5 (2x5). Can you get 10 in any other way? No.\\n\\nSo, let\\'s break it down further.\\n\\n10 = 2 x 5 [1(2),1(5)]\\n100 = 2 x 2 x 5 x 5 [2(2),2(5)]\\n120 = 2 x 2 x 2 x 3 x 5 [3(2),1(3),1(5)]\\n1200 = 2 x 2 x 2 x 2 x 3 x 5 x 5 [4(2),1(3),2(5)] //2 appears 4 times, 3 appears 1 time, 5 appears 2 times}\\n50 = 2 x 5 x 5 [1(2),2(5)]\\n\\nFrom above you will see, among 5 and 2 whichever appears lowest amount is the count of our trailing zeros.\\nBut for n!, we know we will have more 2\\'s than 5.\\nLet\\'s see an example:\\n5! = 1 x 2 x 3  x 4(2x2) x 5 = [3(2),1(5)]\\n\\nTry writing down couple more example and you will understand. So, in 25! how many 5 will be there?\\n\\n....x5....x10....x15....x20....x25 = x5...x2x5....x3x5....x4x5....x5x5 = 6 , Because 25 itself has 2 5\\'s in it.\\n\\nOk, up till this point we were still analyzing n!.\\n\\nBut we know if n>=5 it will have 5 as a factor.\\n\\nSo, based on our intuition so far.\\n\\nIf n=5 ... there will be 1(5)\\nIf n=10 ... there will be 2(5)\\nIf n=15 ... there will be 3(5)\\nIf n=25 ... there will be 5(5) + 1 (5)\\n\\nNow all we need to do is keep dividing n by 5 and add the result to our existing result until n get to 0.\\n\\nIf you are still having trouble getting the code, see this post https://nextswe.com/leetcode-172-factorial-trailing-zeroes/ . Code is provided at the end of explanation.\\nThanks"
                    },
                    {
                        "username": "naveen12124139",
                        "content": "//just return this\\nreturn n/3125+n/625+n/125+n/25+n/5;"
                    },
                    {
                        "username": "sergei99",
                        "content": "It only gets you to the top in languages with smart enough compilers. I\\'ve got C++ and Java executing at 0ms, but stuck with stupid Python... I guess if there is no library function \"count trailing zeroes in factorial\" written in C, then it\\'s just crawling."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "Hacker !!!!\\n"
                    },
                    {
                        "username": "amit2020cs",
                        "content": "You checked the constraints to count the largest power of 5. Nice intuition"
                    },
                    {
                        "username": "heisenbergknocks",
                        "content": "\\t\\n\\tThis seems long but just read on.\\n\\n\\tThe number of 0s in n! is the number of 10s that can be generated by numbers\\n\\tfrom 1 to n!. 10 is a product of 2 and 5, so we just need to check\\n\\thow many 2x5 are present in n!\\n\\n\\tIf n = 5, then n! = 1x2x3x4x5. There is one 2 and 5 pair present\\n\\tin 5! which can make one 10. So numbers of 0s in 5! is one.\\n\\n\\tIf n = 10, then n! = 1x2x3x4x5x6x7x8x9x10 => this would have two zeros one from the\\n\\t2x5 and one from another 2x5 in 10.\\n\\n\\tIf n = 15, then n! = 1x2x3x4x5x6x7x8x9x10x11x12x13x14x15 => this would have three\\n\\tzeros one from the 2x5 and one from another 2x5 in 10 and one from a 5 in 15 which\\n\\twould give us a 0 by multiplying with any 2 from any even num from 1 to 15.\\n\\n\\tSince there are a lot more 2s than 5s in any n!, we just need to find the\\n\\tnumber of 5s in n! and that will be the answer. Eg.\\n\\n\\t5! -> one 0 as there is only one 5 from 1 to 5.\\n\\t10! -> two 0s as there are two 5s from 1 to 10.\\n\\t15! -> three 0s as there are three 5s from 1 to 10.\\n\\t20! -> four 0s as there are four 5s from 1 to 10.\\n\\n\\tHow to quickly count number of 5s in n!? Use n/5.\\n\\tAssume n = 15, using n / 5 we get 3, this tells us that there are at least\\n\\tthree multiples of 5 present in numbers from 1 to 15 namely\\n\\t5x1 = 5, 5x2 = 10 and 5x3 = 15.\\n\\tSo, we can get the number of 5s in n! and hence the number of 0s in n! using n / 5.\\n\\n\\tBut there is still one issue for numbers like 25, 125,\\n\\t625, which contain more than one 5 as their factor.\\n\\n\\tEg. for 25!, the number of 0s is = number of 0s in 20! + number of 0s which can be generated from 21 to 25\\n\\t= number of 0s in 20! + two 0s as there are two 5s present in 25 which would\\n\\tmultiple with any two 2s and make a 100 and give us 2 zeros.\\n\\t= so 25! has six 0s.\\n\\n\\tBut, going by the original formula we will calculate number of 0s in 25! as\\n\\t25/5 which is 5. So five 0s.\\n\\tNow, what we need to do is just divide this result of 5 again by 5\\n\\twhich gives us a 1 and add it to previous five 0s\\n\\n\\tIntuition: Keep dividing by 5 and adding the result to number of 0s."
                    },
                    {
                        "username": "johngroves",
                        "content": "` return n//5 + self.trailingZeroes(n//5) if n else 0`\\nHelpful background here:\\nhttp://www.purplemath.com/modules/factzero.htm"
                    },
                    {
                        "username": "nangao",
                        "content": "I Can't understand this problem"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "This should be easy, not medium  :)"
                    },
                    {
                        "username": "harsha335",
                        "content": "If you cannot get the intuition, it will be hard."
                    },
                    {
                        "username": "megaman14",
                        "content": "You want to find the number of times 10 goes into n, which means the number of times both 5 and 2 appear. Since we always have more 2\\'s than 5\\'s, to get the answer, we try to find the number of times 5 appears as a factor. This is equivalent to n/5. However, we have to account for the powers of 5: 25, 125, 625... Thus, if we multiply the iterator by 5 each time, ex: n/25, n/125, n/625...we can increment the count and get the answer. Now, all you need to do is to be careful about int overflow"
                    },
                    {
                        "username": "alex86",
                        "content": "Factorial of 0 is 1. "
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "Legitimately once I had example numbers to work with, this was much easier to tell what the pattern was. So here\\'s something in Haskell to print out all the factorials:\\n\\n```hs\\nmodule Main where\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nmain = withFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```\\n\\nor for ghci:\\n\\n```hs\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nwithFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```"
                    },
                    {
                        "username": "jzummo",
                        "content": "https://en.wikipedia.org/wiki/Legendre%27s_formula"
                    }
                ]
            },
            {
                "id": 1909361,
                "content": [
                    {
                        "username": "nextsde",
                        "content": "How can we tell from a number, how many trailing zeroes are at the end?\\n\\n10 = 10\\n1200 = 12 x 10 x 10\\n145000 = 145 x 10 x 10 x10\\n\\nFrom above example, we can clearly see number of 10\\'s in a number gives us number of trailing zeros in that number.\\n\\nSo, in our first brute force solution we can calcualte the n! and check how many 10\\'s are in there. That will give us the solution.\\n\\nBut, since n! will become very very large to calculate as n becomes bigger. So, this is not a feasible solution.\\n\\nWhat can we do?\\n\\nLet\\'s build some more intuition to see if we can find out the final hint we need.\\n\\nWhat is the property of 10?\\n\\nWe can get 10 from 2 & 5 (2x5). Can you get 10 in any other way? No.\\n\\nSo, let\\'s break it down further.\\n\\n10 = 2 x 5 [1(2),1(5)]\\n100 = 2 x 2 x 5 x 5 [2(2),2(5)]\\n120 = 2 x 2 x 2 x 3 x 5 [3(2),1(3),1(5)]\\n1200 = 2 x 2 x 2 x 2 x 3 x 5 x 5 [4(2),1(3),2(5)] //2 appears 4 times, 3 appears 1 time, 5 appears 2 times}\\n50 = 2 x 5 x 5 [1(2),2(5)]\\n\\nFrom above you will see, among 5 and 2 whichever appears lowest amount is the count of our trailing zeros.\\nBut for n!, we know we will have more 2\\'s than 5.\\nLet\\'s see an example:\\n5! = 1 x 2 x 3  x 4(2x2) x 5 = [3(2),1(5)]\\n\\nTry writing down couple more example and you will understand. So, in 25! how many 5 will be there?\\n\\n....x5....x10....x15....x20....x25 = x5...x2x5....x3x5....x4x5....x5x5 = 6 , Because 25 itself has 2 5\\'s in it.\\n\\nOk, up till this point we were still analyzing n!.\\n\\nBut we know if n>=5 it will have 5 as a factor.\\n\\nSo, based on our intuition so far.\\n\\nIf n=5 ... there will be 1(5)\\nIf n=10 ... there will be 2(5)\\nIf n=15 ... there will be 3(5)\\nIf n=25 ... there will be 5(5) + 1 (5)\\n\\nNow all we need to do is keep dividing n by 5 and add the result to our existing result until n get to 0.\\n\\nIf you are still having trouble getting the code, see this post https://nextswe.com/leetcode-172-factorial-trailing-zeroes/ . Code is provided at the end of explanation.\\nThanks"
                    },
                    {
                        "username": "naveen12124139",
                        "content": "//just return this\\nreturn n/3125+n/625+n/125+n/25+n/5;"
                    },
                    {
                        "username": "sergei99",
                        "content": "It only gets you to the top in languages with smart enough compilers. I\\'ve got C++ and Java executing at 0ms, but stuck with stupid Python... I guess if there is no library function \"count trailing zeroes in factorial\" written in C, then it\\'s just crawling."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "Hacker !!!!\\n"
                    },
                    {
                        "username": "amit2020cs",
                        "content": "You checked the constraints to count the largest power of 5. Nice intuition"
                    },
                    {
                        "username": "heisenbergknocks",
                        "content": "\\t\\n\\tThis seems long but just read on.\\n\\n\\tThe number of 0s in n! is the number of 10s that can be generated by numbers\\n\\tfrom 1 to n!. 10 is a product of 2 and 5, so we just need to check\\n\\thow many 2x5 are present in n!\\n\\n\\tIf n = 5, then n! = 1x2x3x4x5. There is one 2 and 5 pair present\\n\\tin 5! which can make one 10. So numbers of 0s in 5! is one.\\n\\n\\tIf n = 10, then n! = 1x2x3x4x5x6x7x8x9x10 => this would have two zeros one from the\\n\\t2x5 and one from another 2x5 in 10.\\n\\n\\tIf n = 15, then n! = 1x2x3x4x5x6x7x8x9x10x11x12x13x14x15 => this would have three\\n\\tzeros one from the 2x5 and one from another 2x5 in 10 and one from a 5 in 15 which\\n\\twould give us a 0 by multiplying with any 2 from any even num from 1 to 15.\\n\\n\\tSince there are a lot more 2s than 5s in any n!, we just need to find the\\n\\tnumber of 5s in n! and that will be the answer. Eg.\\n\\n\\t5! -> one 0 as there is only one 5 from 1 to 5.\\n\\t10! -> two 0s as there are two 5s from 1 to 10.\\n\\t15! -> three 0s as there are three 5s from 1 to 10.\\n\\t20! -> four 0s as there are four 5s from 1 to 10.\\n\\n\\tHow to quickly count number of 5s in n!? Use n/5.\\n\\tAssume n = 15, using n / 5 we get 3, this tells us that there are at least\\n\\tthree multiples of 5 present in numbers from 1 to 15 namely\\n\\t5x1 = 5, 5x2 = 10 and 5x3 = 15.\\n\\tSo, we can get the number of 5s in n! and hence the number of 0s in n! using n / 5.\\n\\n\\tBut there is still one issue for numbers like 25, 125,\\n\\t625, which contain more than one 5 as their factor.\\n\\n\\tEg. for 25!, the number of 0s is = number of 0s in 20! + number of 0s which can be generated from 21 to 25\\n\\t= number of 0s in 20! + two 0s as there are two 5s present in 25 which would\\n\\tmultiple with any two 2s and make a 100 and give us 2 zeros.\\n\\t= so 25! has six 0s.\\n\\n\\tBut, going by the original formula we will calculate number of 0s in 25! as\\n\\t25/5 which is 5. So five 0s.\\n\\tNow, what we need to do is just divide this result of 5 again by 5\\n\\twhich gives us a 1 and add it to previous five 0s\\n\\n\\tIntuition: Keep dividing by 5 and adding the result to number of 0s."
                    },
                    {
                        "username": "johngroves",
                        "content": "` return n//5 + self.trailingZeroes(n//5) if n else 0`\\nHelpful background here:\\nhttp://www.purplemath.com/modules/factzero.htm"
                    },
                    {
                        "username": "nangao",
                        "content": "I Can't understand this problem"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "This should be easy, not medium  :)"
                    },
                    {
                        "username": "harsha335",
                        "content": "If you cannot get the intuition, it will be hard."
                    },
                    {
                        "username": "megaman14",
                        "content": "You want to find the number of times 10 goes into n, which means the number of times both 5 and 2 appear. Since we always have more 2\\'s than 5\\'s, to get the answer, we try to find the number of times 5 appears as a factor. This is equivalent to n/5. However, we have to account for the powers of 5: 25, 125, 625... Thus, if we multiply the iterator by 5 each time, ex: n/25, n/125, n/625...we can increment the count and get the answer. Now, all you need to do is to be careful about int overflow"
                    },
                    {
                        "username": "alex86",
                        "content": "Factorial of 0 is 1. "
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "Legitimately once I had example numbers to work with, this was much easier to tell what the pattern was. So here\\'s something in Haskell to print out all the factorials:\\n\\n```hs\\nmodule Main where\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nmain = withFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```\\n\\nor for ghci:\\n\\n```hs\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nwithFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```"
                    },
                    {
                        "username": "jzummo",
                        "content": "https://en.wikipedia.org/wiki/Legendre%27s_formula"
                    }
                ]
            },
            {
                "id": 2063628,
                "content": [
                    {
                        "username": "nextsde",
                        "content": "How can we tell from a number, how many trailing zeroes are at the end?\\n\\n10 = 10\\n1200 = 12 x 10 x 10\\n145000 = 145 x 10 x 10 x10\\n\\nFrom above example, we can clearly see number of 10\\'s in a number gives us number of trailing zeros in that number.\\n\\nSo, in our first brute force solution we can calcualte the n! and check how many 10\\'s are in there. That will give us the solution.\\n\\nBut, since n! will become very very large to calculate as n becomes bigger. So, this is not a feasible solution.\\n\\nWhat can we do?\\n\\nLet\\'s build some more intuition to see if we can find out the final hint we need.\\n\\nWhat is the property of 10?\\n\\nWe can get 10 from 2 & 5 (2x5). Can you get 10 in any other way? No.\\n\\nSo, let\\'s break it down further.\\n\\n10 = 2 x 5 [1(2),1(5)]\\n100 = 2 x 2 x 5 x 5 [2(2),2(5)]\\n120 = 2 x 2 x 2 x 3 x 5 [3(2),1(3),1(5)]\\n1200 = 2 x 2 x 2 x 2 x 3 x 5 x 5 [4(2),1(3),2(5)] //2 appears 4 times, 3 appears 1 time, 5 appears 2 times}\\n50 = 2 x 5 x 5 [1(2),2(5)]\\n\\nFrom above you will see, among 5 and 2 whichever appears lowest amount is the count of our trailing zeros.\\nBut for n!, we know we will have more 2\\'s than 5.\\nLet\\'s see an example:\\n5! = 1 x 2 x 3  x 4(2x2) x 5 = [3(2),1(5)]\\n\\nTry writing down couple more example and you will understand. So, in 25! how many 5 will be there?\\n\\n....x5....x10....x15....x20....x25 = x5...x2x5....x3x5....x4x5....x5x5 = 6 , Because 25 itself has 2 5\\'s in it.\\n\\nOk, up till this point we were still analyzing n!.\\n\\nBut we know if n>=5 it will have 5 as a factor.\\n\\nSo, based on our intuition so far.\\n\\nIf n=5 ... there will be 1(5)\\nIf n=10 ... there will be 2(5)\\nIf n=15 ... there will be 3(5)\\nIf n=25 ... there will be 5(5) + 1 (5)\\n\\nNow all we need to do is keep dividing n by 5 and add the result to our existing result until n get to 0.\\n\\nIf you are still having trouble getting the code, see this post https://nextswe.com/leetcode-172-factorial-trailing-zeroes/ . Code is provided at the end of explanation.\\nThanks"
                    },
                    {
                        "username": "naveen12124139",
                        "content": "//just return this\\nreturn n/3125+n/625+n/125+n/25+n/5;"
                    },
                    {
                        "username": "sergei99",
                        "content": "It only gets you to the top in languages with smart enough compilers. I\\'ve got C++ and Java executing at 0ms, but stuck with stupid Python... I guess if there is no library function \"count trailing zeroes in factorial\" written in C, then it\\'s just crawling."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "Hacker !!!!\\n"
                    },
                    {
                        "username": "amit2020cs",
                        "content": "You checked the constraints to count the largest power of 5. Nice intuition"
                    },
                    {
                        "username": "heisenbergknocks",
                        "content": "\\t\\n\\tThis seems long but just read on.\\n\\n\\tThe number of 0s in n! is the number of 10s that can be generated by numbers\\n\\tfrom 1 to n!. 10 is a product of 2 and 5, so we just need to check\\n\\thow many 2x5 are present in n!\\n\\n\\tIf n = 5, then n! = 1x2x3x4x5. There is one 2 and 5 pair present\\n\\tin 5! which can make one 10. So numbers of 0s in 5! is one.\\n\\n\\tIf n = 10, then n! = 1x2x3x4x5x6x7x8x9x10 => this would have two zeros one from the\\n\\t2x5 and one from another 2x5 in 10.\\n\\n\\tIf n = 15, then n! = 1x2x3x4x5x6x7x8x9x10x11x12x13x14x15 => this would have three\\n\\tzeros one from the 2x5 and one from another 2x5 in 10 and one from a 5 in 15 which\\n\\twould give us a 0 by multiplying with any 2 from any even num from 1 to 15.\\n\\n\\tSince there are a lot more 2s than 5s in any n!, we just need to find the\\n\\tnumber of 5s in n! and that will be the answer. Eg.\\n\\n\\t5! -> one 0 as there is only one 5 from 1 to 5.\\n\\t10! -> two 0s as there are two 5s from 1 to 10.\\n\\t15! -> three 0s as there are three 5s from 1 to 10.\\n\\t20! -> four 0s as there are four 5s from 1 to 10.\\n\\n\\tHow to quickly count number of 5s in n!? Use n/5.\\n\\tAssume n = 15, using n / 5 we get 3, this tells us that there are at least\\n\\tthree multiples of 5 present in numbers from 1 to 15 namely\\n\\t5x1 = 5, 5x2 = 10 and 5x3 = 15.\\n\\tSo, we can get the number of 5s in n! and hence the number of 0s in n! using n / 5.\\n\\n\\tBut there is still one issue for numbers like 25, 125,\\n\\t625, which contain more than one 5 as their factor.\\n\\n\\tEg. for 25!, the number of 0s is = number of 0s in 20! + number of 0s which can be generated from 21 to 25\\n\\t= number of 0s in 20! + two 0s as there are two 5s present in 25 which would\\n\\tmultiple with any two 2s and make a 100 and give us 2 zeros.\\n\\t= so 25! has six 0s.\\n\\n\\tBut, going by the original formula we will calculate number of 0s in 25! as\\n\\t25/5 which is 5. So five 0s.\\n\\tNow, what we need to do is just divide this result of 5 again by 5\\n\\twhich gives us a 1 and add it to previous five 0s\\n\\n\\tIntuition: Keep dividing by 5 and adding the result to number of 0s."
                    },
                    {
                        "username": "johngroves",
                        "content": "` return n//5 + self.trailingZeroes(n//5) if n else 0`\\nHelpful background here:\\nhttp://www.purplemath.com/modules/factzero.htm"
                    },
                    {
                        "username": "nangao",
                        "content": "I Can't understand this problem"
                    },
                    {
                        "username": "Aishwarya_Omar",
                        "content": "This should be easy, not medium  :)"
                    },
                    {
                        "username": "harsha335",
                        "content": "If you cannot get the intuition, it will be hard."
                    },
                    {
                        "username": "megaman14",
                        "content": "You want to find the number of times 10 goes into n, which means the number of times both 5 and 2 appear. Since we always have more 2\\'s than 5\\'s, to get the answer, we try to find the number of times 5 appears as a factor. This is equivalent to n/5. However, we have to account for the powers of 5: 25, 125, 625... Thus, if we multiply the iterator by 5 each time, ex: n/25, n/125, n/625...we can increment the count and get the answer. Now, all you need to do is to be careful about int overflow"
                    },
                    {
                        "username": "alex86",
                        "content": "Factorial of 0 is 1. "
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "Legitimately once I had example numbers to work with, this was much easier to tell what the pattern was. So here\\'s something in Haskell to print out all the factorials:\\n\\n```hs\\nmodule Main where\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nmain = withFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```\\n\\nor for ghci:\\n\\n```hs\\nimport System.IO\\nfactorials :: [Integer]\\nfactorials = 0 : scanl1 (*) [1..]\\nwithFile \"factorials.csv\" WriteMode f where\\n  f h = mapM_ (\\\\(i, f) -> hPutStrLn h $ show i ++ \",\" ++ show f) $ zip [0..10000] factorials\\n```"
                    },
                    {
                        "username": "jzummo",
                        "content": "https://en.wikipedia.org/wiki/Legendre%27s_formula"
                    }
                ]
            },
            {
                "id": 2057187,
                "content": [
                    {
                        "username": "sergei99",
                        "content": "This is fairly simple. Just 5 multiplications, 5 shifts and 4 additions, which in languages like C, C++, Java, Scala, Python looks like this:\\n`(n * 0x6667 >> 17) + (n * 0x51EC >> 19) + (n * 0x418A >> 21) + (n * 0x68DC >> 24) + (n * 0x53E3 >> 26)`\\nThis would calculate the number of trailing zeroes in factorial of `n` for any `n` not exceeding `10000` (and for some of `n` above `10000`) without using costly divisions or loops. Moreover, all intermediate results would fit 29 bits, which means not only does it fit `int` in Java, C++, etc., but it also can be computed within the minimal size of Python\\'s `int` on 32-bit platforms without expansion. I doubt anyone could compute it faster than this."
                    },
                    {
                        "username": "thiruthuvarajan",
                        "content": "I have my naïve approach but why this doesn't work. ? can any one help ?\n\n `int fact = 1;`\n`for(int i=2;i<=n;i++) {`\n`     fact *= i;`\n`   }`\n`   int cnt = 0;`\n`   while(fact%10==0) {`\n`        cnt++;`\n`        fact = fact/10;`\n`   }`"
                    },
                    {
                        "username": "GriffinWJ",
                        "content": "The error seems to be integer overflow, ints only hold up to the value of +2147483647 and (10^4)! is way bigger than that (10^4 being the max n value). I would look at a list of factorials and try and find a pattern or think about what times what would make a number end in 0. \\n\\nHint: Maybe look into the number 5?"
                    },
                    {
                        "username": "BatMe",
                        "content": "For anyone wondering about this question, this is just matth, simple math that you\\'ve to code. \\nCheck this out: \\nhttps://www.toppr.com/ask/question/zeroes-at-the-end-of-125/"
                    },
                    {
                        "username": "BatMe",
                        "content": "Solve this aptitude question, It will help you in solving this problem: \\nhttps://www.toppr.com/ask/question/zeroes-at-the-end-of-125/\\n\\nThank me later. "
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "this is kind of simple maths concept, though somehow the acceptance rate is low"
                    },
                    {
                        "username": "GriffinWJ",
                        "content": "I figured out that I can do the whole problem in one line with addition and division and creating no new variables. Can someone please explain how that very simple solution took the same memory (6.1) as other solutions that seem incredibly complicated with tons of loops and variables? What actually determines memory use and how can I reduce it?   "
                    },
                    {
                        "username": "sergei99",
                        "content": "The answer is simple: LC\\'s measurement system is screwed up. Measurements depend on plenty of random factors unrelated to solution itself."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Anyone can tell me why\n\n1. This JS code doesn't pass the case `30` and I need to use `5` for some reason.\n```\nvar trailingZeroes = function(n) {\n  let num = 1;\n  for (let i = 1; i <= n; i++) {\n    num *= i;\n  }\n  n = 0;\n  while (num % 10 === 0) {\n    num = Math.floor(num / 10);\n    n++;\n  }\n  return n;\n};\n```\n\n2. Whereas this Python code passes with no probs:\n\n\n```\nclass Solution:\n    def trailingZeroes(self, n: int) -> int:\n\n        num = 1\n        for i in range(1, n + 1):\n            num *= i\n        n = 0\n        while num % 10 == 0:\n            num = num // 10\n            n += 1\n        return n\n```\n"
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "JS uses float for all numbers. Python uses a bigint for its `int` class. For information about the limits of double-precision floating-point numbers, I\\'d say read the Wikipedia article: https://en.wikipedia.org/wiki/Double-precision_floating-point_format#Precision_limitations_on_integer_values"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I could do this immediately in logarithmic time (in < 2 mins) because this question takes me back to the memories of JEE (college entrance exam) days. This was a popular question back then. And that was years ago!! From that struggle to this one at Leetcode \\u2764"
                    },
                    {
                        "username": "LUKITA",
                        "content": "Hi, just wanna ask, when i input n =30, the result of 30! calculating is with 18 zeros consecutively from the end, why does the output of the testing case only 7, can anyone explain"
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "You probably are using float and losing precision."
                    },
                    {
                        "username": "gokulkrishna98",
                        "content": "There are 7 zeroes as trailing zeros in 30!, the problem can be broken down to number of 10\\'s in the factorization of n!. As there are more 2\\'s than 5s. you can change the problem to number of 5\\'s in the prime factorization of n!"
                    },
                    {
                        "username": "NavneetChadhokar1",
                        "content": "public int trailingZeroes(int n) {\\n        int count =0;\\n        while(n>0){\\n            n=n/5;\\n            count=count+n;\\n        }\\n        return count;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 2027477,
                "content": [
                    {
                        "username": "sergei99",
                        "content": "This is fairly simple. Just 5 multiplications, 5 shifts and 4 additions, which in languages like C, C++, Java, Scala, Python looks like this:\\n`(n * 0x6667 >> 17) + (n * 0x51EC >> 19) + (n * 0x418A >> 21) + (n * 0x68DC >> 24) + (n * 0x53E3 >> 26)`\\nThis would calculate the number of trailing zeroes in factorial of `n` for any `n` not exceeding `10000` (and for some of `n` above `10000`) without using costly divisions or loops. Moreover, all intermediate results would fit 29 bits, which means not only does it fit `int` in Java, C++, etc., but it also can be computed within the minimal size of Python\\'s `int` on 32-bit platforms without expansion. I doubt anyone could compute it faster than this."
                    },
                    {
                        "username": "thiruthuvarajan",
                        "content": "I have my naïve approach but why this doesn't work. ? can any one help ?\n\n `int fact = 1;`\n`for(int i=2;i<=n;i++) {`\n`     fact *= i;`\n`   }`\n`   int cnt = 0;`\n`   while(fact%10==0) {`\n`        cnt++;`\n`        fact = fact/10;`\n`   }`"
                    },
                    {
                        "username": "GriffinWJ",
                        "content": "The error seems to be integer overflow, ints only hold up to the value of +2147483647 and (10^4)! is way bigger than that (10^4 being the max n value). I would look at a list of factorials and try and find a pattern or think about what times what would make a number end in 0. \\n\\nHint: Maybe look into the number 5?"
                    },
                    {
                        "username": "BatMe",
                        "content": "For anyone wondering about this question, this is just matth, simple math that you\\'ve to code. \\nCheck this out: \\nhttps://www.toppr.com/ask/question/zeroes-at-the-end-of-125/"
                    },
                    {
                        "username": "BatMe",
                        "content": "Solve this aptitude question, It will help you in solving this problem: \\nhttps://www.toppr.com/ask/question/zeroes-at-the-end-of-125/\\n\\nThank me later. "
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "this is kind of simple maths concept, though somehow the acceptance rate is low"
                    },
                    {
                        "username": "GriffinWJ",
                        "content": "I figured out that I can do the whole problem in one line with addition and division and creating no new variables. Can someone please explain how that very simple solution took the same memory (6.1) as other solutions that seem incredibly complicated with tons of loops and variables? What actually determines memory use and how can I reduce it?   "
                    },
                    {
                        "username": "sergei99",
                        "content": "The answer is simple: LC\\'s measurement system is screwed up. Measurements depend on plenty of random factors unrelated to solution itself."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Anyone can tell me why\n\n1. This JS code doesn't pass the case `30` and I need to use `5` for some reason.\n```\nvar trailingZeroes = function(n) {\n  let num = 1;\n  for (let i = 1; i <= n; i++) {\n    num *= i;\n  }\n  n = 0;\n  while (num % 10 === 0) {\n    num = Math.floor(num / 10);\n    n++;\n  }\n  return n;\n};\n```\n\n2. Whereas this Python code passes with no probs:\n\n\n```\nclass Solution:\n    def trailingZeroes(self, n: int) -> int:\n\n        num = 1\n        for i in range(1, n + 1):\n            num *= i\n        n = 0\n        while num % 10 == 0:\n            num = num // 10\n            n += 1\n        return n\n```\n"
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "JS uses float for all numbers. Python uses a bigint for its `int` class. For information about the limits of double-precision floating-point numbers, I\\'d say read the Wikipedia article: https://en.wikipedia.org/wiki/Double-precision_floating-point_format#Precision_limitations_on_integer_values"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I could do this immediately in logarithmic time (in < 2 mins) because this question takes me back to the memories of JEE (college entrance exam) days. This was a popular question back then. And that was years ago!! From that struggle to this one at Leetcode \\u2764"
                    },
                    {
                        "username": "LUKITA",
                        "content": "Hi, just wanna ask, when i input n =30, the result of 30! calculating is with 18 zeros consecutively from the end, why does the output of the testing case only 7, can anyone explain"
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "You probably are using float and losing precision."
                    },
                    {
                        "username": "gokulkrishna98",
                        "content": "There are 7 zeroes as trailing zeros in 30!, the problem can be broken down to number of 10\\'s in the factorization of n!. As there are more 2\\'s than 5s. you can change the problem to number of 5\\'s in the prime factorization of n!"
                    },
                    {
                        "username": "NavneetChadhokar1",
                        "content": "public int trailingZeroes(int n) {\\n        int count =0;\\n        while(n>0){\\n            n=n/5;\\n            count=count+n;\\n        }\\n        return count;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 2026105,
                "content": [
                    {
                        "username": "sergei99",
                        "content": "This is fairly simple. Just 5 multiplications, 5 shifts and 4 additions, which in languages like C, C++, Java, Scala, Python looks like this:\\n`(n * 0x6667 >> 17) + (n * 0x51EC >> 19) + (n * 0x418A >> 21) + (n * 0x68DC >> 24) + (n * 0x53E3 >> 26)`\\nThis would calculate the number of trailing zeroes in factorial of `n` for any `n` not exceeding `10000` (and for some of `n` above `10000`) without using costly divisions or loops. Moreover, all intermediate results would fit 29 bits, which means not only does it fit `int` in Java, C++, etc., but it also can be computed within the minimal size of Python\\'s `int` on 32-bit platforms without expansion. I doubt anyone could compute it faster than this."
                    },
                    {
                        "username": "thiruthuvarajan",
                        "content": "I have my naïve approach but why this doesn't work. ? can any one help ?\n\n `int fact = 1;`\n`for(int i=2;i<=n;i++) {`\n`     fact *= i;`\n`   }`\n`   int cnt = 0;`\n`   while(fact%10==0) {`\n`        cnt++;`\n`        fact = fact/10;`\n`   }`"
                    },
                    {
                        "username": "GriffinWJ",
                        "content": "The error seems to be integer overflow, ints only hold up to the value of +2147483647 and (10^4)! is way bigger than that (10^4 being the max n value). I would look at a list of factorials and try and find a pattern or think about what times what would make a number end in 0. \\n\\nHint: Maybe look into the number 5?"
                    },
                    {
                        "username": "BatMe",
                        "content": "For anyone wondering about this question, this is just matth, simple math that you\\'ve to code. \\nCheck this out: \\nhttps://www.toppr.com/ask/question/zeroes-at-the-end-of-125/"
                    },
                    {
                        "username": "BatMe",
                        "content": "Solve this aptitude question, It will help you in solving this problem: \\nhttps://www.toppr.com/ask/question/zeroes-at-the-end-of-125/\\n\\nThank me later. "
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "this is kind of simple maths concept, though somehow the acceptance rate is low"
                    },
                    {
                        "username": "GriffinWJ",
                        "content": "I figured out that I can do the whole problem in one line with addition and division and creating no new variables. Can someone please explain how that very simple solution took the same memory (6.1) as other solutions that seem incredibly complicated with tons of loops and variables? What actually determines memory use and how can I reduce it?   "
                    },
                    {
                        "username": "sergei99",
                        "content": "The answer is simple: LC\\'s measurement system is screwed up. Measurements depend on plenty of random factors unrelated to solution itself."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Anyone can tell me why\n\n1. This JS code doesn't pass the case `30` and I need to use `5` for some reason.\n```\nvar trailingZeroes = function(n) {\n  let num = 1;\n  for (let i = 1; i <= n; i++) {\n    num *= i;\n  }\n  n = 0;\n  while (num % 10 === 0) {\n    num = Math.floor(num / 10);\n    n++;\n  }\n  return n;\n};\n```\n\n2. Whereas this Python code passes with no probs:\n\n\n```\nclass Solution:\n    def trailingZeroes(self, n: int) -> int:\n\n        num = 1\n        for i in range(1, n + 1):\n            num *= i\n        n = 0\n        while num % 10 == 0:\n            num = num // 10\n            n += 1\n        return n\n```\n"
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "JS uses float for all numbers. Python uses a bigint for its `int` class. For information about the limits of double-precision floating-point numbers, I\\'d say read the Wikipedia article: https://en.wikipedia.org/wiki/Double-precision_floating-point_format#Precision_limitations_on_integer_values"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I could do this immediately in logarithmic time (in < 2 mins) because this question takes me back to the memories of JEE (college entrance exam) days. This was a popular question back then. And that was years ago!! From that struggle to this one at Leetcode \\u2764"
                    },
                    {
                        "username": "LUKITA",
                        "content": "Hi, just wanna ask, when i input n =30, the result of 30! calculating is with 18 zeros consecutively from the end, why does the output of the testing case only 7, can anyone explain"
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "You probably are using float and losing precision."
                    },
                    {
                        "username": "gokulkrishna98",
                        "content": "There are 7 zeroes as trailing zeros in 30!, the problem can be broken down to number of 10\\'s in the factorization of n!. As there are more 2\\'s than 5s. you can change the problem to number of 5\\'s in the prime factorization of n!"
                    },
                    {
                        "username": "NavneetChadhokar1",
                        "content": "public int trailingZeroes(int n) {\\n        int count =0;\\n        while(n>0){\\n            n=n/5;\\n            count=count+n;\\n        }\\n        return count;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 2026102,
                "content": [
                    {
                        "username": "sergei99",
                        "content": "This is fairly simple. Just 5 multiplications, 5 shifts and 4 additions, which in languages like C, C++, Java, Scala, Python looks like this:\\n`(n * 0x6667 >> 17) + (n * 0x51EC >> 19) + (n * 0x418A >> 21) + (n * 0x68DC >> 24) + (n * 0x53E3 >> 26)`\\nThis would calculate the number of trailing zeroes in factorial of `n` for any `n` not exceeding `10000` (and for some of `n` above `10000`) without using costly divisions or loops. Moreover, all intermediate results would fit 29 bits, which means not only does it fit `int` in Java, C++, etc., but it also can be computed within the minimal size of Python\\'s `int` on 32-bit platforms without expansion. I doubt anyone could compute it faster than this."
                    },
                    {
                        "username": "thiruthuvarajan",
                        "content": "I have my naïve approach but why this doesn't work. ? can any one help ?\n\n `int fact = 1;`\n`for(int i=2;i<=n;i++) {`\n`     fact *= i;`\n`   }`\n`   int cnt = 0;`\n`   while(fact%10==0) {`\n`        cnt++;`\n`        fact = fact/10;`\n`   }`"
                    },
                    {
                        "username": "GriffinWJ",
                        "content": "The error seems to be integer overflow, ints only hold up to the value of +2147483647 and (10^4)! is way bigger than that (10^4 being the max n value). I would look at a list of factorials and try and find a pattern or think about what times what would make a number end in 0. \\n\\nHint: Maybe look into the number 5?"
                    },
                    {
                        "username": "BatMe",
                        "content": "For anyone wondering about this question, this is just matth, simple math that you\\'ve to code. \\nCheck this out: \\nhttps://www.toppr.com/ask/question/zeroes-at-the-end-of-125/"
                    },
                    {
                        "username": "BatMe",
                        "content": "Solve this aptitude question, It will help you in solving this problem: \\nhttps://www.toppr.com/ask/question/zeroes-at-the-end-of-125/\\n\\nThank me later. "
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "this is kind of simple maths concept, though somehow the acceptance rate is low"
                    },
                    {
                        "username": "GriffinWJ",
                        "content": "I figured out that I can do the whole problem in one line with addition and division and creating no new variables. Can someone please explain how that very simple solution took the same memory (6.1) as other solutions that seem incredibly complicated with tons of loops and variables? What actually determines memory use and how can I reduce it?   "
                    },
                    {
                        "username": "sergei99",
                        "content": "The answer is simple: LC\\'s measurement system is screwed up. Measurements depend on plenty of random factors unrelated to solution itself."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Anyone can tell me why\n\n1. This JS code doesn't pass the case `30` and I need to use `5` for some reason.\n```\nvar trailingZeroes = function(n) {\n  let num = 1;\n  for (let i = 1; i <= n; i++) {\n    num *= i;\n  }\n  n = 0;\n  while (num % 10 === 0) {\n    num = Math.floor(num / 10);\n    n++;\n  }\n  return n;\n};\n```\n\n2. Whereas this Python code passes with no probs:\n\n\n```\nclass Solution:\n    def trailingZeroes(self, n: int) -> int:\n\n        num = 1\n        for i in range(1, n + 1):\n            num *= i\n        n = 0\n        while num % 10 == 0:\n            num = num // 10\n            n += 1\n        return n\n```\n"
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "JS uses float for all numbers. Python uses a bigint for its `int` class. For information about the limits of double-precision floating-point numbers, I\\'d say read the Wikipedia article: https://en.wikipedia.org/wiki/Double-precision_floating-point_format#Precision_limitations_on_integer_values"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I could do this immediately in logarithmic time (in < 2 mins) because this question takes me back to the memories of JEE (college entrance exam) days. This was a popular question back then. And that was years ago!! From that struggle to this one at Leetcode \\u2764"
                    },
                    {
                        "username": "LUKITA",
                        "content": "Hi, just wanna ask, when i input n =30, the result of 30! calculating is with 18 zeros consecutively from the end, why does the output of the testing case only 7, can anyone explain"
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "You probably are using float and losing precision."
                    },
                    {
                        "username": "gokulkrishna98",
                        "content": "There are 7 zeroes as trailing zeros in 30!, the problem can be broken down to number of 10\\'s in the factorization of n!. As there are more 2\\'s than 5s. you can change the problem to number of 5\\'s in the prime factorization of n!"
                    },
                    {
                        "username": "NavneetChadhokar1",
                        "content": "public int trailingZeroes(int n) {\\n        int count =0;\\n        while(n>0){\\n            n=n/5;\\n            count=count+n;\\n        }\\n        return count;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 2020202,
                "content": [
                    {
                        "username": "sergei99",
                        "content": "This is fairly simple. Just 5 multiplications, 5 shifts and 4 additions, which in languages like C, C++, Java, Scala, Python looks like this:\\n`(n * 0x6667 >> 17) + (n * 0x51EC >> 19) + (n * 0x418A >> 21) + (n * 0x68DC >> 24) + (n * 0x53E3 >> 26)`\\nThis would calculate the number of trailing zeroes in factorial of `n` for any `n` not exceeding `10000` (and for some of `n` above `10000`) without using costly divisions or loops. Moreover, all intermediate results would fit 29 bits, which means not only does it fit `int` in Java, C++, etc., but it also can be computed within the minimal size of Python\\'s `int` on 32-bit platforms without expansion. I doubt anyone could compute it faster than this."
                    },
                    {
                        "username": "thiruthuvarajan",
                        "content": "I have my naïve approach but why this doesn't work. ? can any one help ?\n\n `int fact = 1;`\n`for(int i=2;i<=n;i++) {`\n`     fact *= i;`\n`   }`\n`   int cnt = 0;`\n`   while(fact%10==0) {`\n`        cnt++;`\n`        fact = fact/10;`\n`   }`"
                    },
                    {
                        "username": "GriffinWJ",
                        "content": "The error seems to be integer overflow, ints only hold up to the value of +2147483647 and (10^4)! is way bigger than that (10^4 being the max n value). I would look at a list of factorials and try and find a pattern or think about what times what would make a number end in 0. \\n\\nHint: Maybe look into the number 5?"
                    },
                    {
                        "username": "BatMe",
                        "content": "For anyone wondering about this question, this is just matth, simple math that you\\'ve to code. \\nCheck this out: \\nhttps://www.toppr.com/ask/question/zeroes-at-the-end-of-125/"
                    },
                    {
                        "username": "BatMe",
                        "content": "Solve this aptitude question, It will help you in solving this problem: \\nhttps://www.toppr.com/ask/question/zeroes-at-the-end-of-125/\\n\\nThank me later. "
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "this is kind of simple maths concept, though somehow the acceptance rate is low"
                    },
                    {
                        "username": "GriffinWJ",
                        "content": "I figured out that I can do the whole problem in one line with addition and division and creating no new variables. Can someone please explain how that very simple solution took the same memory (6.1) as other solutions that seem incredibly complicated with tons of loops and variables? What actually determines memory use and how can I reduce it?   "
                    },
                    {
                        "username": "sergei99",
                        "content": "The answer is simple: LC\\'s measurement system is screwed up. Measurements depend on plenty of random factors unrelated to solution itself."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Anyone can tell me why\n\n1. This JS code doesn't pass the case `30` and I need to use `5` for some reason.\n```\nvar trailingZeroes = function(n) {\n  let num = 1;\n  for (let i = 1; i <= n; i++) {\n    num *= i;\n  }\n  n = 0;\n  while (num % 10 === 0) {\n    num = Math.floor(num / 10);\n    n++;\n  }\n  return n;\n};\n```\n\n2. Whereas this Python code passes with no probs:\n\n\n```\nclass Solution:\n    def trailingZeroes(self, n: int) -> int:\n\n        num = 1\n        for i in range(1, n + 1):\n            num *= i\n        n = 0\n        while num % 10 == 0:\n            num = num // 10\n            n += 1\n        return n\n```\n"
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "JS uses float for all numbers. Python uses a bigint for its `int` class. For information about the limits of double-precision floating-point numbers, I\\'d say read the Wikipedia article: https://en.wikipedia.org/wiki/Double-precision_floating-point_format#Precision_limitations_on_integer_values"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I could do this immediately in logarithmic time (in < 2 mins) because this question takes me back to the memories of JEE (college entrance exam) days. This was a popular question back then. And that was years ago!! From that struggle to this one at Leetcode \\u2764"
                    },
                    {
                        "username": "LUKITA",
                        "content": "Hi, just wanna ask, when i input n =30, the result of 30! calculating is with 18 zeros consecutively from the end, why does the output of the testing case only 7, can anyone explain"
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "You probably are using float and losing precision."
                    },
                    {
                        "username": "gokulkrishna98",
                        "content": "There are 7 zeroes as trailing zeros in 30!, the problem can be broken down to number of 10\\'s in the factorization of n!. As there are more 2\\'s than 5s. you can change the problem to number of 5\\'s in the prime factorization of n!"
                    },
                    {
                        "username": "NavneetChadhokar1",
                        "content": "public int trailingZeroes(int n) {\\n        int count =0;\\n        while(n>0){\\n            n=n/5;\\n            count=count+n;\\n        }\\n        return count;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1999987,
                "content": [
                    {
                        "username": "sergei99",
                        "content": "This is fairly simple. Just 5 multiplications, 5 shifts and 4 additions, which in languages like C, C++, Java, Scala, Python looks like this:\\n`(n * 0x6667 >> 17) + (n * 0x51EC >> 19) + (n * 0x418A >> 21) + (n * 0x68DC >> 24) + (n * 0x53E3 >> 26)`\\nThis would calculate the number of trailing zeroes in factorial of `n` for any `n` not exceeding `10000` (and for some of `n` above `10000`) without using costly divisions or loops. Moreover, all intermediate results would fit 29 bits, which means not only does it fit `int` in Java, C++, etc., but it also can be computed within the minimal size of Python\\'s `int` on 32-bit platforms without expansion. I doubt anyone could compute it faster than this."
                    },
                    {
                        "username": "thiruthuvarajan",
                        "content": "I have my naïve approach but why this doesn't work. ? can any one help ?\n\n `int fact = 1;`\n`for(int i=2;i<=n;i++) {`\n`     fact *= i;`\n`   }`\n`   int cnt = 0;`\n`   while(fact%10==0) {`\n`        cnt++;`\n`        fact = fact/10;`\n`   }`"
                    },
                    {
                        "username": "GriffinWJ",
                        "content": "The error seems to be integer overflow, ints only hold up to the value of +2147483647 and (10^4)! is way bigger than that (10^4 being the max n value). I would look at a list of factorials and try and find a pattern or think about what times what would make a number end in 0. \\n\\nHint: Maybe look into the number 5?"
                    },
                    {
                        "username": "BatMe",
                        "content": "For anyone wondering about this question, this is just matth, simple math that you\\'ve to code. \\nCheck this out: \\nhttps://www.toppr.com/ask/question/zeroes-at-the-end-of-125/"
                    },
                    {
                        "username": "BatMe",
                        "content": "Solve this aptitude question, It will help you in solving this problem: \\nhttps://www.toppr.com/ask/question/zeroes-at-the-end-of-125/\\n\\nThank me later. "
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "this is kind of simple maths concept, though somehow the acceptance rate is low"
                    },
                    {
                        "username": "GriffinWJ",
                        "content": "I figured out that I can do the whole problem in one line with addition and division and creating no new variables. Can someone please explain how that very simple solution took the same memory (6.1) as other solutions that seem incredibly complicated with tons of loops and variables? What actually determines memory use and how can I reduce it?   "
                    },
                    {
                        "username": "sergei99",
                        "content": "The answer is simple: LC\\'s measurement system is screwed up. Measurements depend on plenty of random factors unrelated to solution itself."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Anyone can tell me why\n\n1. This JS code doesn't pass the case `30` and I need to use `5` for some reason.\n```\nvar trailingZeroes = function(n) {\n  let num = 1;\n  for (let i = 1; i <= n; i++) {\n    num *= i;\n  }\n  n = 0;\n  while (num % 10 === 0) {\n    num = Math.floor(num / 10);\n    n++;\n  }\n  return n;\n};\n```\n\n2. Whereas this Python code passes with no probs:\n\n\n```\nclass Solution:\n    def trailingZeroes(self, n: int) -> int:\n\n        num = 1\n        for i in range(1, n + 1):\n            num *= i\n        n = 0\n        while num % 10 == 0:\n            num = num // 10\n            n += 1\n        return n\n```\n"
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "JS uses float for all numbers. Python uses a bigint for its `int` class. For information about the limits of double-precision floating-point numbers, I\\'d say read the Wikipedia article: https://en.wikipedia.org/wiki/Double-precision_floating-point_format#Precision_limitations_on_integer_values"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I could do this immediately in logarithmic time (in < 2 mins) because this question takes me back to the memories of JEE (college entrance exam) days. This was a popular question back then. And that was years ago!! From that struggle to this one at Leetcode \\u2764"
                    },
                    {
                        "username": "LUKITA",
                        "content": "Hi, just wanna ask, when i input n =30, the result of 30! calculating is with 18 zeros consecutively from the end, why does the output of the testing case only 7, can anyone explain"
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "You probably are using float and losing precision."
                    },
                    {
                        "username": "gokulkrishna98",
                        "content": "There are 7 zeroes as trailing zeros in 30!, the problem can be broken down to number of 10\\'s in the factorization of n!. As there are more 2\\'s than 5s. you can change the problem to number of 5\\'s in the prime factorization of n!"
                    },
                    {
                        "username": "NavneetChadhokar1",
                        "content": "public int trailingZeroes(int n) {\\n        int count =0;\\n        while(n>0){\\n            n=n/5;\\n            count=count+n;\\n        }\\n        return count;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1972625,
                "content": [
                    {
                        "username": "sergei99",
                        "content": "This is fairly simple. Just 5 multiplications, 5 shifts and 4 additions, which in languages like C, C++, Java, Scala, Python looks like this:\\n`(n * 0x6667 >> 17) + (n * 0x51EC >> 19) + (n * 0x418A >> 21) + (n * 0x68DC >> 24) + (n * 0x53E3 >> 26)`\\nThis would calculate the number of trailing zeroes in factorial of `n` for any `n` not exceeding `10000` (and for some of `n` above `10000`) without using costly divisions or loops. Moreover, all intermediate results would fit 29 bits, which means not only does it fit `int` in Java, C++, etc., but it also can be computed within the minimal size of Python\\'s `int` on 32-bit platforms without expansion. I doubt anyone could compute it faster than this."
                    },
                    {
                        "username": "thiruthuvarajan",
                        "content": "I have my naïve approach but why this doesn't work. ? can any one help ?\n\n `int fact = 1;`\n`for(int i=2;i<=n;i++) {`\n`     fact *= i;`\n`   }`\n`   int cnt = 0;`\n`   while(fact%10==0) {`\n`        cnt++;`\n`        fact = fact/10;`\n`   }`"
                    },
                    {
                        "username": "GriffinWJ",
                        "content": "The error seems to be integer overflow, ints only hold up to the value of +2147483647 and (10^4)! is way bigger than that (10^4 being the max n value). I would look at a list of factorials and try and find a pattern or think about what times what would make a number end in 0. \\n\\nHint: Maybe look into the number 5?"
                    },
                    {
                        "username": "BatMe",
                        "content": "For anyone wondering about this question, this is just matth, simple math that you\\'ve to code. \\nCheck this out: \\nhttps://www.toppr.com/ask/question/zeroes-at-the-end-of-125/"
                    },
                    {
                        "username": "BatMe",
                        "content": "Solve this aptitude question, It will help you in solving this problem: \\nhttps://www.toppr.com/ask/question/zeroes-at-the-end-of-125/\\n\\nThank me later. "
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "this is kind of simple maths concept, though somehow the acceptance rate is low"
                    },
                    {
                        "username": "GriffinWJ",
                        "content": "I figured out that I can do the whole problem in one line with addition and division and creating no new variables. Can someone please explain how that very simple solution took the same memory (6.1) as other solutions that seem incredibly complicated with tons of loops and variables? What actually determines memory use and how can I reduce it?   "
                    },
                    {
                        "username": "sergei99",
                        "content": "The answer is simple: LC\\'s measurement system is screwed up. Measurements depend on plenty of random factors unrelated to solution itself."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Anyone can tell me why\n\n1. This JS code doesn't pass the case `30` and I need to use `5` for some reason.\n```\nvar trailingZeroes = function(n) {\n  let num = 1;\n  for (let i = 1; i <= n; i++) {\n    num *= i;\n  }\n  n = 0;\n  while (num % 10 === 0) {\n    num = Math.floor(num / 10);\n    n++;\n  }\n  return n;\n};\n```\n\n2. Whereas this Python code passes with no probs:\n\n\n```\nclass Solution:\n    def trailingZeroes(self, n: int) -> int:\n\n        num = 1\n        for i in range(1, n + 1):\n            num *= i\n        n = 0\n        while num % 10 == 0:\n            num = num // 10\n            n += 1\n        return n\n```\n"
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "JS uses float for all numbers. Python uses a bigint for its `int` class. For information about the limits of double-precision floating-point numbers, I\\'d say read the Wikipedia article: https://en.wikipedia.org/wiki/Double-precision_floating-point_format#Precision_limitations_on_integer_values"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I could do this immediately in logarithmic time (in < 2 mins) because this question takes me back to the memories of JEE (college entrance exam) days. This was a popular question back then. And that was years ago!! From that struggle to this one at Leetcode \\u2764"
                    },
                    {
                        "username": "LUKITA",
                        "content": "Hi, just wanna ask, when i input n =30, the result of 30! calculating is with 18 zeros consecutively from the end, why does the output of the testing case only 7, can anyone explain"
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "You probably are using float and losing precision."
                    },
                    {
                        "username": "gokulkrishna98",
                        "content": "There are 7 zeroes as trailing zeros in 30!, the problem can be broken down to number of 10\\'s in the factorization of n!. As there are more 2\\'s than 5s. you can change the problem to number of 5\\'s in the prime factorization of n!"
                    },
                    {
                        "username": "NavneetChadhokar1",
                        "content": "public int trailingZeroes(int n) {\\n        int count =0;\\n        while(n>0){\\n            n=n/5;\\n            count=count+n;\\n        }\\n        return count;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1970226,
                "content": [
                    {
                        "username": "sergei99",
                        "content": "This is fairly simple. Just 5 multiplications, 5 shifts and 4 additions, which in languages like C, C++, Java, Scala, Python looks like this:\\n`(n * 0x6667 >> 17) + (n * 0x51EC >> 19) + (n * 0x418A >> 21) + (n * 0x68DC >> 24) + (n * 0x53E3 >> 26)`\\nThis would calculate the number of trailing zeroes in factorial of `n` for any `n` not exceeding `10000` (and for some of `n` above `10000`) without using costly divisions or loops. Moreover, all intermediate results would fit 29 bits, which means not only does it fit `int` in Java, C++, etc., but it also can be computed within the minimal size of Python\\'s `int` on 32-bit platforms without expansion. I doubt anyone could compute it faster than this."
                    },
                    {
                        "username": "thiruthuvarajan",
                        "content": "I have my naïve approach but why this doesn't work. ? can any one help ?\n\n `int fact = 1;`\n`for(int i=2;i<=n;i++) {`\n`     fact *= i;`\n`   }`\n`   int cnt = 0;`\n`   while(fact%10==0) {`\n`        cnt++;`\n`        fact = fact/10;`\n`   }`"
                    },
                    {
                        "username": "GriffinWJ",
                        "content": "The error seems to be integer overflow, ints only hold up to the value of +2147483647 and (10^4)! is way bigger than that (10^4 being the max n value). I would look at a list of factorials and try and find a pattern or think about what times what would make a number end in 0. \\n\\nHint: Maybe look into the number 5?"
                    },
                    {
                        "username": "BatMe",
                        "content": "For anyone wondering about this question, this is just matth, simple math that you\\'ve to code. \\nCheck this out: \\nhttps://www.toppr.com/ask/question/zeroes-at-the-end-of-125/"
                    },
                    {
                        "username": "BatMe",
                        "content": "Solve this aptitude question, It will help you in solving this problem: \\nhttps://www.toppr.com/ask/question/zeroes-at-the-end-of-125/\\n\\nThank me later. "
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "this is kind of simple maths concept, though somehow the acceptance rate is low"
                    },
                    {
                        "username": "GriffinWJ",
                        "content": "I figured out that I can do the whole problem in one line with addition and division and creating no new variables. Can someone please explain how that very simple solution took the same memory (6.1) as other solutions that seem incredibly complicated with tons of loops and variables? What actually determines memory use and how can I reduce it?   "
                    },
                    {
                        "username": "sergei99",
                        "content": "The answer is simple: LC\\'s measurement system is screwed up. Measurements depend on plenty of random factors unrelated to solution itself."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Anyone can tell me why\n\n1. This JS code doesn't pass the case `30` and I need to use `5` for some reason.\n```\nvar trailingZeroes = function(n) {\n  let num = 1;\n  for (let i = 1; i <= n; i++) {\n    num *= i;\n  }\n  n = 0;\n  while (num % 10 === 0) {\n    num = Math.floor(num / 10);\n    n++;\n  }\n  return n;\n};\n```\n\n2. Whereas this Python code passes with no probs:\n\n\n```\nclass Solution:\n    def trailingZeroes(self, n: int) -> int:\n\n        num = 1\n        for i in range(1, n + 1):\n            num *= i\n        n = 0\n        while num % 10 == 0:\n            num = num // 10\n            n += 1\n        return n\n```\n"
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "JS uses float for all numbers. Python uses a bigint for its `int` class. For information about the limits of double-precision floating-point numbers, I\\'d say read the Wikipedia article: https://en.wikipedia.org/wiki/Double-precision_floating-point_format#Precision_limitations_on_integer_values"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I could do this immediately in logarithmic time (in < 2 mins) because this question takes me back to the memories of JEE (college entrance exam) days. This was a popular question back then. And that was years ago!! From that struggle to this one at Leetcode \\u2764"
                    },
                    {
                        "username": "LUKITA",
                        "content": "Hi, just wanna ask, when i input n =30, the result of 30! calculating is with 18 zeros consecutively from the end, why does the output of the testing case only 7, can anyone explain"
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "You probably are using float and losing precision."
                    },
                    {
                        "username": "gokulkrishna98",
                        "content": "There are 7 zeroes as trailing zeros in 30!, the problem can be broken down to number of 10\\'s in the factorization of n!. As there are more 2\\'s than 5s. you can change the problem to number of 5\\'s in the prime factorization of n!"
                    },
                    {
                        "username": "NavneetChadhokar1",
                        "content": "public int trailingZeroes(int n) {\\n        int count =0;\\n        while(n>0){\\n            n=n/5;\\n            count=count+n;\\n        }\\n        return count;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1906271,
                "content": [
                    {
                        "username": "sergei99",
                        "content": "This is fairly simple. Just 5 multiplications, 5 shifts and 4 additions, which in languages like C, C++, Java, Scala, Python looks like this:\\n`(n * 0x6667 >> 17) + (n * 0x51EC >> 19) + (n * 0x418A >> 21) + (n * 0x68DC >> 24) + (n * 0x53E3 >> 26)`\\nThis would calculate the number of trailing zeroes in factorial of `n` for any `n` not exceeding `10000` (and for some of `n` above `10000`) without using costly divisions or loops. Moreover, all intermediate results would fit 29 bits, which means not only does it fit `int` in Java, C++, etc., but it also can be computed within the minimal size of Python\\'s `int` on 32-bit platforms without expansion. I doubt anyone could compute it faster than this."
                    },
                    {
                        "username": "thiruthuvarajan",
                        "content": "I have my naïve approach but why this doesn't work. ? can any one help ?\n\n `int fact = 1;`\n`for(int i=2;i<=n;i++) {`\n`     fact *= i;`\n`   }`\n`   int cnt = 0;`\n`   while(fact%10==0) {`\n`        cnt++;`\n`        fact = fact/10;`\n`   }`"
                    },
                    {
                        "username": "GriffinWJ",
                        "content": "The error seems to be integer overflow, ints only hold up to the value of +2147483647 and (10^4)! is way bigger than that (10^4 being the max n value). I would look at a list of factorials and try and find a pattern or think about what times what would make a number end in 0. \\n\\nHint: Maybe look into the number 5?"
                    },
                    {
                        "username": "BatMe",
                        "content": "For anyone wondering about this question, this is just matth, simple math that you\\'ve to code. \\nCheck this out: \\nhttps://www.toppr.com/ask/question/zeroes-at-the-end-of-125/"
                    },
                    {
                        "username": "BatMe",
                        "content": "Solve this aptitude question, It will help you in solving this problem: \\nhttps://www.toppr.com/ask/question/zeroes-at-the-end-of-125/\\n\\nThank me later. "
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "this is kind of simple maths concept, though somehow the acceptance rate is low"
                    },
                    {
                        "username": "GriffinWJ",
                        "content": "I figured out that I can do the whole problem in one line with addition and division and creating no new variables. Can someone please explain how that very simple solution took the same memory (6.1) as other solutions that seem incredibly complicated with tons of loops and variables? What actually determines memory use and how can I reduce it?   "
                    },
                    {
                        "username": "sergei99",
                        "content": "The answer is simple: LC\\'s measurement system is screwed up. Measurements depend on plenty of random factors unrelated to solution itself."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Anyone can tell me why\n\n1. This JS code doesn't pass the case `30` and I need to use `5` for some reason.\n```\nvar trailingZeroes = function(n) {\n  let num = 1;\n  for (let i = 1; i <= n; i++) {\n    num *= i;\n  }\n  n = 0;\n  while (num % 10 === 0) {\n    num = Math.floor(num / 10);\n    n++;\n  }\n  return n;\n};\n```\n\n2. Whereas this Python code passes with no probs:\n\n\n```\nclass Solution:\n    def trailingZeroes(self, n: int) -> int:\n\n        num = 1\n        for i in range(1, n + 1):\n            num *= i\n        n = 0\n        while num % 10 == 0:\n            num = num // 10\n            n += 1\n        return n\n```\n"
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "JS uses float for all numbers. Python uses a bigint for its `int` class. For information about the limits of double-precision floating-point numbers, I\\'d say read the Wikipedia article: https://en.wikipedia.org/wiki/Double-precision_floating-point_format#Precision_limitations_on_integer_values"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I could do this immediately in logarithmic time (in < 2 mins) because this question takes me back to the memories of JEE (college entrance exam) days. This was a popular question back then. And that was years ago!! From that struggle to this one at Leetcode \\u2764"
                    },
                    {
                        "username": "LUKITA",
                        "content": "Hi, just wanna ask, when i input n =30, the result of 30! calculating is with 18 zeros consecutively from the end, why does the output of the testing case only 7, can anyone explain"
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "You probably are using float and losing precision."
                    },
                    {
                        "username": "gokulkrishna98",
                        "content": "There are 7 zeroes as trailing zeros in 30!, the problem can be broken down to number of 10\\'s in the factorization of n!. As there are more 2\\'s than 5s. you can change the problem to number of 5\\'s in the prime factorization of n!"
                    },
                    {
                        "username": "NavneetChadhokar1",
                        "content": "public int trailingZeroes(int n) {\\n        int count =0;\\n        while(n>0){\\n            n=n/5;\\n            count=count+n;\\n        }\\n        return count;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1879508,
                "content": [
                    {
                        "username": "sergei99",
                        "content": "This is fairly simple. Just 5 multiplications, 5 shifts and 4 additions, which in languages like C, C++, Java, Scala, Python looks like this:\\n`(n * 0x6667 >> 17) + (n * 0x51EC >> 19) + (n * 0x418A >> 21) + (n * 0x68DC >> 24) + (n * 0x53E3 >> 26)`\\nThis would calculate the number of trailing zeroes in factorial of `n` for any `n` not exceeding `10000` (and for some of `n` above `10000`) without using costly divisions or loops. Moreover, all intermediate results would fit 29 bits, which means not only does it fit `int` in Java, C++, etc., but it also can be computed within the minimal size of Python\\'s `int` on 32-bit platforms without expansion. I doubt anyone could compute it faster than this."
                    },
                    {
                        "username": "thiruthuvarajan",
                        "content": "I have my naïve approach but why this doesn't work. ? can any one help ?\n\n `int fact = 1;`\n`for(int i=2;i<=n;i++) {`\n`     fact *= i;`\n`   }`\n`   int cnt = 0;`\n`   while(fact%10==0) {`\n`        cnt++;`\n`        fact = fact/10;`\n`   }`"
                    },
                    {
                        "username": "GriffinWJ",
                        "content": "The error seems to be integer overflow, ints only hold up to the value of +2147483647 and (10^4)! is way bigger than that (10^4 being the max n value). I would look at a list of factorials and try and find a pattern or think about what times what would make a number end in 0. \\n\\nHint: Maybe look into the number 5?"
                    },
                    {
                        "username": "BatMe",
                        "content": "For anyone wondering about this question, this is just matth, simple math that you\\'ve to code. \\nCheck this out: \\nhttps://www.toppr.com/ask/question/zeroes-at-the-end-of-125/"
                    },
                    {
                        "username": "BatMe",
                        "content": "Solve this aptitude question, It will help you in solving this problem: \\nhttps://www.toppr.com/ask/question/zeroes-at-the-end-of-125/\\n\\nThank me later. "
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "this is kind of simple maths concept, though somehow the acceptance rate is low"
                    },
                    {
                        "username": "GriffinWJ",
                        "content": "I figured out that I can do the whole problem in one line with addition and division and creating no new variables. Can someone please explain how that very simple solution took the same memory (6.1) as other solutions that seem incredibly complicated with tons of loops and variables? What actually determines memory use and how can I reduce it?   "
                    },
                    {
                        "username": "sergei99",
                        "content": "The answer is simple: LC\\'s measurement system is screwed up. Measurements depend on plenty of random factors unrelated to solution itself."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Anyone can tell me why\n\n1. This JS code doesn't pass the case `30` and I need to use `5` for some reason.\n```\nvar trailingZeroes = function(n) {\n  let num = 1;\n  for (let i = 1; i <= n; i++) {\n    num *= i;\n  }\n  n = 0;\n  while (num % 10 === 0) {\n    num = Math.floor(num / 10);\n    n++;\n  }\n  return n;\n};\n```\n\n2. Whereas this Python code passes with no probs:\n\n\n```\nclass Solution:\n    def trailingZeroes(self, n: int) -> int:\n\n        num = 1\n        for i in range(1, n + 1):\n            num *= i\n        n = 0\n        while num % 10 == 0:\n            num = num // 10\n            n += 1\n        return n\n```\n"
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "JS uses float for all numbers. Python uses a bigint for its `int` class. For information about the limits of double-precision floating-point numbers, I\\'d say read the Wikipedia article: https://en.wikipedia.org/wiki/Double-precision_floating-point_format#Precision_limitations_on_integer_values"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I could do this immediately in logarithmic time (in < 2 mins) because this question takes me back to the memories of JEE (college entrance exam) days. This was a popular question back then. And that was years ago!! From that struggle to this one at Leetcode \\u2764"
                    },
                    {
                        "username": "LUKITA",
                        "content": "Hi, just wanna ask, when i input n =30, the result of 30! calculating is with 18 zeros consecutively from the end, why does the output of the testing case only 7, can anyone explain"
                    },
                    {
                        "username": "HexTheDragon",
                        "content": "You probably are using float and losing precision."
                    },
                    {
                        "username": "gokulkrishna98",
                        "content": "There are 7 zeroes as trailing zeros in 30!, the problem can be broken down to number of 10\\'s in the factorization of n!. As there are more 2\\'s than 5s. you can change the problem to number of 5\\'s in the prime factorization of n!"
                    },
                    {
                        "username": "NavneetChadhokar1",
                        "content": "public int trailingZeroes(int n) {\\n        int count =0;\\n        while(n>0){\\n            n=n/5;\\n            count=count+n;\\n        }\\n        return count;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            }
        ]
    }
]