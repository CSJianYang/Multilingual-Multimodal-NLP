[
    {
        "title": "Walking Robot Simulation II",
        "question_content": "A width x height grid is on an XY-plane with the bottom-left cell at (0, 0) and the top-right cell at (width - 1, height - 1). The grid is aligned with the four cardinal directions (\"North\", \"East\", \"South\", and \"West\"). A robot is initially at cell (0, 0) facing direction \"East\".\nThe robot can be instructed to move for a specific number of steps. For each step, it does the following.\n\n\tAttempts to move forward one cell in the direction it is facing.\n\tIf the cell the robot is moving to is out of bounds, the robot instead turns 90 degrees counterclockwise and retries the step.\n\nAfter the robot finishes moving the number of steps required, it stops and awaits the next instruction.\nImplement the Robot class:\n\n\tRobot(int width, int height) Initializes the width x height grid with the robot at (0, 0) facing \"East\".\n\tvoid step(int num) Instructs the robot to move forward num steps.\n\tint[] getPos() Returns the current cell the robot is at, as an array of length 2, [x, y].\n\tString getDir() Returns the current direction of the robot, \"North\", \"East\", \"South\", or \"West\".\n\n&nbsp;\nExample 1:\n\nInput\n[\"Robot\", \"step\", \"step\", \"getPos\", \"getDir\", \"step\", \"step\", \"step\", \"getPos\", \"getDir\"]\n[[6, 3], [2], [2], [], [], [2], [1], [4], [], []]\nOutput\n[null, null, null, [4, 0], \"East\", null, null, null, [1, 2], \"West\"]\nExplanation\nRobot robot = new Robot(6, 3); // Initialize the grid and the robot at (0, 0) facing East.\nrobot.step(2);  // It moves two steps East to (2, 0), and faces East.\nrobot.step(2);  // It moves two steps East to (4, 0), and faces East.\nrobot.getPos(); // return [4, 0]\nrobot.getDir(); // return \"East\"\nrobot.step(2);  // It moves one step East to (5, 0), and faces East.\n                // Moving the next step East would be out of bounds, so it turns and faces North.\n                // Then, it moves one step North to (5, 1), and faces North.\nrobot.step(1);  // It moves one step North to (5, 2), and faces North (not West).\nrobot.step(4);  // Moving the next step North would be out of bounds, so it turns and faces West.\n                // Then, it moves four steps West to (1, 2), and faces West.\nrobot.getPos(); // return [1, 2]\nrobot.getDir(); // return \"West\"\n\n&nbsp;\nConstraints:\n\n\t2 <= width, height <= 100\n\t1 <= num <= 105\n\tAt most 104 calls in total will be made to step, getPos, and getDir.",
        "solutions": [
            {
                "id": 1576036,
                "title": "python-easy-and-concise-solution",
                "content": "# **Explanation**\\nGenerate all results for every position first.\\n\\nNote that,\\nif robot moves, its direction for `[0, 0]` will be `South`.\\nWhile it starts at `[0, 0]` with `East`\\n<br>\\n\\n# **Complexity**\\nTime `O(m+n)`\\nSpace `O(m+n)`\\n<br>\\n\\n\\n**Python**\\n```py\\nclass Solution(object):\\n\\n    def __init__(self, w, h):\\n        self.i = 0\\n        self.pos = [[0, 0, \\'South\\']] + [[i, 0, \\'East\\'] for i in range(1, w)] + \\\\\\n            [[w - 1, i, \\'North\\'] for i in range(1, h)] + \\\\\\n            [[i, h - 1, \\'West\\'] for i in range(w - 2, -1, -1)] +\\\\\\n            [[0, i, \\'South\\'] for i in range(h - 2, 0, -1)]\\n\\n    def move(self, x):\\n        self.i += x\\n\\n    def getPos(self):\\n        return self.pos[self.i % len(self.pos)][:2]\\n\\n    def getDir(self):\\n        return self.pos[self.i % len(self.pos)][2] if self.i else \\'East\\'\\n```",
                "solutionTags": [],
                "code": "```py\\nclass Solution(object):\\n\\n    def __init__(self, w, h):\\n        self.i = 0\\n        self.pos = [[0, 0, \\'South\\']] + [[i, 0, \\'East\\'] for i in range(1, w)] + \\\\\\n            [[w - 1, i, \\'North\\'] for i in range(1, h)] + \\\\\\n            [[i, h - 1, \\'West\\'] for i in range(w - 2, -1, -1)] +\\\\\\n            [[0, i, \\'South\\'] for i in range(h - 2, 0, -1)]\\n\\n    def move(self, x):\\n        self.i += x\\n\\n    def getPos(self):\\n        return self.pos[self.i % len(self.pos)][:2]\\n\\n    def getDir(self):\\n        return self.pos[self.i % len(self.pos)][2] if self.i else \\'East\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1575926,
                "title": "worst-question-ever-java-solution-with-explanation",
                "content": "I tried this for more the 1 hour . And finally now i find the solution\\nCredit to  [pigorski](https://leetcode.com/pigorski/)  for the solution\\n\\nHere are some points to notice\\n1. To get Rid of TLE  we do % of num with   w * 2 + h * 2 - 4 because we have to travel through perimeter of the given grid and after travel  w * 2 + h * 2 - 4 we will reach at the same position.\\n1. if you wondered why we subtract 4 from  w * 2 + h * 2  if we simply do n*m we will  travel all the corner edges 2 times so to manage this we have to subtract 4 from  w * 2 + h * 2 - 4.\\n1. In case your solution passes 140 test case  and you didn\\'t find the reason why your code fails .\\nDry Run This test case\\n[\"Robot\",\"getPos\",\"getDir\",\"move\",\"getDir\",\"getPos\"]\\n[[2,3],[],[],[24],[],[]]\\n\\n* in the beginning robot faces \"East\" at (0, 0),\\n* but next time, when it comes to (0, 0) it should face \"South\"\\n\\n\\nclass Robot {\\n    \\n    private int w;\\n    private int h;\\n    private int x;\\n    private int y;\\n    private String dir;\\n    \\n\\n    public Robot(int width, int height) {\\n        w = width;\\n        h = height;\\n        x = 0;\\n        y = 0;\\n        dir = \"East\";\\n    }\\n    \\n    public void move(int num) {\\n        num %= w * 2 + h * 2 - 4;\\n        if (num == 0) num = w * 2 + h * 2 - 4;\\n        \\n        for (int i = 0; i < num; i++) {\\n            switch (dir) {\\n                case \"East\":\\n                    if (x == w - 1) {\\n                        dir = \"North\";\\n                        y++;\\n                    }\\n                    else {\\n                        x++;\\n                    }\\n                    break;\\n                case \"North\":\\n                    if (y == h - 1) {\\n                        dir = \"West\";\\n                        x--;\\n                    }\\n                    else {\\n                        y++;\\n                    }\\n                    break;\\n                case \"West\":\\n                    if (x == 0) {\\n                        dir = \"South\";\\n                        y--;\\n                    }\\n                    else {\\n                        x--;\\n                    }\\n                    break;\\n                case \"South\":\\n                    if (y == 0) {\\n                        dir = \"East\";\\n                        x++;\\n                    }\\n                    else {\\n                        y--;\\n                    }\\n            }\\n        }\\n    }\\n    \\n    public int[] getPos() {\\n        return new int[] {x, y};\\n    }\\n    \\n    public String getDir() {\\n        return dir;\\n    }\\n}\\n \\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "I tried this for more the 1 hour . And finally now i find the solution\\nCredit to  [pigorski](https://leetcode.com/pigorski/)  for the solution\\n\\nHere are some points to notice\\n1. To get Rid of TLE  we do % of num with   w * 2 + h * 2 - 4 because we have to travel through perimeter of the given grid and after travel  w * 2 + h * 2 - 4 we will reach at the same position.\\n1. if you wondered why we subtract 4 from  w * 2 + h * 2  if we simply do n*m we will  travel all the corner edges 2 times so to manage this we have to subtract 4 from  w * 2 + h * 2 - 4.\\n1. In case your solution passes 140 test case  and you didn\\'t find the reason why your code fails .\\nDry Run This test case\\n[\"Robot\",\"getPos\",\"getDir\",\"move\",\"getDir\",\"getPos\"]\\n[[2,3],[],[],[24],[],[]]\\n\\n* in the beginning robot faces \"East\" at (0, 0),\\n* but next time, when it comes to (0, 0) it should face \"South\"\\n\\n\\nclass Robot {\\n    \\n    private int w;\\n    private int h;\\n    private int x;\\n    private int y;\\n    private String dir;\\n    \\n\\n    public Robot(int width, int height) {\\n        w = width;\\n        h = height;\\n        x = 0;\\n        y = 0;\\n        dir = \"East\";\\n    }\\n    \\n    public void move(int num) {\\n        num %= w * 2 + h * 2 - 4;\\n        if (num == 0) num = w * 2 + h * 2 - 4;\\n        \\n        for (int i = 0; i < num; i++) {\\n            switch (dir) {\\n                case \"East\":\\n                    if (x == w - 1) {\\n                        dir = \"North\";\\n                        y++;\\n                    }\\n                    else {\\n                        x++;\\n                    }\\n                    break;\\n                case \"North\":\\n                    if (y == h - 1) {\\n                        dir = \"West\";\\n                        x--;\\n                    }\\n                    else {\\n                        y++;\\n                    }\\n                    break;\\n                case \"West\":\\n                    if (x == 0) {\\n                        dir = \"South\";\\n                        y--;\\n                    }\\n                    else {\\n                        x--;\\n                    }\\n                    break;\\n                case \"South\":\\n                    if (y == 0) {\\n                        dir = \"East\";\\n                        x++;\\n                    }\\n                    else {\\n                        y--;\\n                    }\\n            }\\n        }\\n    }\\n    \\n    public int[] getPos() {\\n        return new int[] {x, y};\\n    }\\n    \\n    public String getDir() {\\n        return dir;\\n    }\\n}\\n \\n",
                "codeTag": "Java"
            },
            {
                "id": 1575990,
                "title": "c-handle-round-trip-o-1-for-all",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n## Solution 1.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/walking-robot-simulation-ii/\\n// Author: github.com/lzl124631x\\n// Time: \\n//      move: O(W + H)\\n//      Robot, getPos, getDir: O(1)\\n// Space: O(1)\\nclass Robot {\\n    int dir = 0, dirs[4][2] = {{1,0},{0,1},{-1,0},{0,-1}}, w, h, perimeter, x = 0, y = 0;\\n    string text[4] = {\"East\",\"North\",\"West\",\"South\"};\\npublic:\\n    Robot(int width, int height) : w(width), h(height), perimeter(2*(w + h - 2)) {}\\n    void move(int k) {\\n        if (k >= perimeter) {\\n            k %= perimeter;\\n            if (x == 0 && y == 0 && dir == 0) dir = 3; // Special case: if we are at the beginning (x = 0, y = 0 and facing east), after the round trip, the direction becomes south.\\n        }\\n        while (k > 0) {\\n            auto &[dx, dy] = dirs[dir];\\n            int nx = x + dx, ny = y + dy;\\n            if (nx < 0 || ny < 0 || nx >= w || ny >= h) {\\n                dir = (dir + 1) % 4;\\n            } else {\\n                x = nx, y = ny;\\n                --k;\\n            }\\n        }\\n    }\\n    vector<int> getPos() {\\n        return {x,y};\\n    }\\n    string getDir() {\\n        return text[dir];\\n    }\\n};\\n```\\n\\n\\n## Solution 2.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/walking-robot-simulation-ii/\\n// Author: github.com/lzl124631x\\n// Time: O(1) for all\\n// Space: O(1)\\nclass Robot {\\n    int dir = 0, dirs[4][2] = {{1,0},{0,1},{-1,0},{0,-1}}, w, h, perimeter, x = 0, y = 0;\\n    string text[4] = {\"East\",\"North\",\"West\",\"South\"};\\n    int maxStep() {\\n        if (dir == 0) return w - 1 - x;\\n        if (dir == 1) return h - 1 - y;\\n        if (dir == 2) return x;\\n        return y;\\n    }\\npublic:\\n    Robot(int width, int height) : w(width), h(height), perimeter(2*(w + h - 2)) {}\\n    void move(int k) {\\n        if (k >= perimeter) {\\n            k %= perimeter;\\n            if (x == 0 && y == 0 && dir == 0) dir = 3; // Special case: if we are at the beginning (x = 0, y = 0 and facing east), after the round trip, the direction becomes south.\\n        }\\n        while (k > 0) {\\n            int step = min(k, maxStep());\\n            k -= step;\\n            auto &[dx, dy] = dirs[dir];\\n            x += dx * step;\\n            y += dy * step;\\n            if (k) dir = (dir + 1) % 4;\\n        }\\n    }\\n    vector<int> getPos() {\\n        return {x,y};\\n    }\\n    string getDir() {\\n        return text[dir];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/walking-robot-simulation-ii/\\n// Author: github.com/lzl124631x\\n// Time: \\n//      move: O(W + H)\\n//      Robot, getPos, getDir: O(1)\\n// Space: O(1)\\nclass Robot {\\n    int dir = 0, dirs[4][2] = {{1,0},{0,1},{-1,0},{0,-1}}, w, h, perimeter, x = 0, y = 0;\\n    string text[4] = {\"East\",\"North\",\"West\",\"South\"};\\npublic:\\n    Robot(int width, int height) : w(width), h(height), perimeter(2*(w + h - 2)) {}\\n    void move(int k) {\\n        if (k >= perimeter) {\\n            k %= perimeter;\\n            if (x == 0 && y == 0 && dir == 0) dir = 3; // Special case: if we are at the beginning (x = 0, y = 0 and facing east), after the round trip, the direction becomes south.\\n        }\\n        while (k > 0) {\\n            auto &[dx, dy] = dirs[dir];\\n            int nx = x + dx, ny = y + dy;\\n            if (nx < 0 || ny < 0 || nx >= w || ny >= h) {\\n                dir = (dir + 1) % 4;\\n            } else {\\n                x = nx, y = ny;\\n                --k;\\n            }\\n        }\\n    }\\n    vector<int> getPos() {\\n        return {x,y};\\n    }\\n    string getDir() {\\n        return text[dir];\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/walking-robot-simulation-ii/\\n// Author: github.com/lzl124631x\\n// Time: O(1) for all\\n// Space: O(1)\\nclass Robot {\\n    int dir = 0, dirs[4][2] = {{1,0},{0,1},{-1,0},{0,-1}}, w, h, perimeter, x = 0, y = 0;\\n    string text[4] = {\"East\",\"North\",\"West\",\"South\"};\\n    int maxStep() {\\n        if (dir == 0) return w - 1 - x;\\n        if (dir == 1) return h - 1 - y;\\n        if (dir == 2) return x;\\n        return y;\\n    }\\npublic:\\n    Robot(int width, int height) : w(width), h(height), perimeter(2*(w + h - 2)) {}\\n    void move(int k) {\\n        if (k >= perimeter) {\\n            k %= perimeter;\\n            if (x == 0 && y == 0 && dir == 0) dir = 3; // Special case: if we are at the beginning (x = 0, y = 0 and facing east), after the round trip, the direction becomes south.\\n        }\\n        while (k > 0) {\\n            int step = min(k, maxStep());\\n            k -= step;\\n            auto &[dx, dy] = dirs[dir];\\n            x += dx * step;\\n            y += dy * step;\\n            if (k) dir = (dir + 1) % 4;\\n        }\\n    }\\n    vector<int> getPos() {\\n        return {x,y};\\n    }\\n    string getDir() {\\n        return text[dir];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478796,
                "title": "javascript-2069-walking-robot-simulation-ii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\nI struggled intial tries\\n\\nOn paper, we can easily derive below:\\n- Robot always walks on the outer rim of the grid ( circle/ cycle )\\n- 0,0 position changes from East to South once we cricle back to it\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n1\\n```\\nvar Robot = function (W, H) {\\n    const dirs = [\"East\", \"North\", \"West\", \"South\"];\\n\\n    const a = []; // single dimension array of [x, y, direction] of grid\\'s outer rim\\n    for (let x = 0; x < W; x++)      a.push([x, 0, 0]);     // go East\\n    for (let y = 1; y < H; y++)      a.push([W - 1, y, 1]); // go North\\n    for (let x = W - 2; x >= 0; x--) a.push([x, H - 1, 2]); // go West\\n    for (let y = H - 2; y > 0; y--)  a.push([0, y, 3]);     // go South\\n\\n    let i = 0;\\n    Robot.prototype.step = function (num) {\\n        i = (i + num) % a.length;   // mod to simulate cycle/ circle\\n        a[0][2] = 3;                // once moved, direction becomes South for 0,0\\n    };\\n    Robot.prototype.getPos = function () {\\n        return a[i].slice(0, 2);    // 1st two - x & y\\n    };\\n    Robot.prototype.getDir = function () {\\n        return dirs[ a[i][2] ];       // last one - direction - as string\\n    };\\n};\\n```\\n\\n---\\n\\n![image.png](https://assets.leetcode.com/users/images/2725d4a1-432f-4582-be47-074198bf11a2_1683050427.9897425.png)\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar Robot = function (W, H) {\\n    const dirs = [\"East\", \"North\", \"West\", \"South\"];\\n\\n    const a = []; // single dimension array of [x, y, direction] of grid\\'s outer rim\\n    for (let x = 0; x < W; x++)      a.push([x, 0, 0]);     // go East\\n    for (let y = 1; y < H; y++)      a.push([W - 1, y, 1]); // go North\\n    for (let x = W - 2; x >= 0; x--) a.push([x, H - 1, 2]); // go West\\n    for (let y = H - 2; y > 0; y--)  a.push([0, y, 3]);     // go South\\n\\n    let i = 0;\\n    Robot.prototype.step = function (num) {\\n        i = (i + num) % a.length;   // mod to simulate cycle/ circle\\n        a[0][2] = 3;                // once moved, direction becomes South for 0,0\\n    };\\n    Robot.prototype.getPos = function () {\\n        return a[i].slice(0, 2);    // 1st two - x & y\\n    };\\n    Robot.prototype.getDir = function () {\\n        return dirs[ a[i][2] ];       // last one - direction - as string\\n    };\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1576194,
                "title": "java-brute-force-easy-to-understand",
                "content": "Robot only moves on edges of matrix.\\n`(currPos + moves) % perimeter` to get curr position.\\n`[0, perimeter]` contains all posible value after move.\\n`currPos  <--> (x, y)  <-->  direction` has a 1-1-1 mapping. Use hashMap to keep (value, (point[], direction)).\\n\\nBoundary case: Before move `(0, 0) <-> East`;  after move `(0, 0) <-> South`\\n\\n\\n```\\nclass Robot {\\n    Map<Integer, Pair<int[], String>> map;\\n    int currPos;\\n    int perimeter;\\n    boolean moved;\\n    \\n    public Robot(int width, int height) {\\n        map = new HashMap<>();\\n        currPos = 0;\\n        perimeter = 0;\\n        moved = false;\\n        \\n        map.put(0, new Pair(new int[]{0, 0}, \"South\"));\\n        \\n        for(int e = 1; e < width; ++e)\\n            map.put(++perimeter, new Pair(new int[]{e, 0}, \"East\"));\\n        \\n        for(int n = 1; n < height; ++n)\\n            map.put(++perimeter, new Pair(new int[]{width - 1, n}, \"North\"));\\n        \\n        for(int w = width - 2; w >= 0; --w)\\n            map.put(++perimeter, new Pair(new int[]{w, height - 1}, \"West\"));\\n        \\n        for(int s = height - 2; s >= 0; --s)\\n            map.put(++perimeter, new Pair(new int[]{0, s}, \"South\"));\\n        \\n    }\\n    \\n    public void move(int num) {\\n        moved = true;\\n        currPos = (currPos + num) % perimeter;\\n    }\\n    \\n    public int[] getPos() {\\n        return map.get(currPos).getKey();\\n    }\\n    \\n    public String getDir() {\\n        return moved ? map.get(currPos).getValue() : \"East\";\\n    }\\n}",
                "solutionTags": [],
                "code": "Robot only moves on edges of matrix.\\n`(currPos + moves) % perimeter` to get curr position.\\n`[0, perimeter]` contains all posible value after move.\\n`currPos  <--> (x, y)  <-->  direction` has a 1-1-1 mapping. Use hashMap to keep (value, (point[], direction)).\\n\\nBoundary case: Before move `(0, 0) <-> East`;  after move `(0, 0) <-> South`\\n\\n\\n```\\nclass Robot {\\n    Map<Integer, Pair<int[], String>> map;\\n    int currPos;\\n    int perimeter;\\n    boolean moved;\\n    \\n    public Robot(int width, int height) {\\n        map = new HashMap<>();\\n        currPos = 0;\\n        perimeter = 0;\\n        moved = false;\\n        \\n        map.put(0, new Pair(new int[]{0, 0}, \"South\"));\\n        \\n        for(int e = 1; e < width; ++e)\\n            map.put(++perimeter, new Pair(new int[]{e, 0}, \"East\"));\\n        \\n        for(int n = 1; n < height; ++n)\\n            map.put(++perimeter, new Pair(new int[]{width - 1, n}, \"North\"));\\n        \\n        for(int w = width - 2; w >= 0; --w)\\n            map.put(++perimeter, new Pair(new int[]{w, height - 1}, \"West\"));\\n        \\n        for(int s = height - 2; s >= 0; --s)\\n            map.put(++perimeter, new Pair(new int[]{0, s}, \"South\"));\\n        \\n    }\\n    \\n    public void move(int num) {\\n        moved = true;\\n        currPos = (currPos + num) % perimeter;\\n    }\\n    \\n    public int[] getPos() {\\n        return map.get(currPos).getKey();\\n    }\\n    \\n    public String getDir() {\\n        return moved ? map.get(currPos).getValue() : \"East\";\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1575896,
                "title": "tricky-test-case-explained",
                "content": "Consider the SIMPLE case:\\n[\"Robot\",\"move\", \"getDir\"]\\n[[3, 3], [8], []]\\n\\nCorrect answer is [null,null,\"South\"]\\n\\nBut you will be returning [null,null,\"East\"]\\n\\nReason:\\nYou would have done num = num % circumference;\\nwhich is 0 after 8 moves in this case but the direction facing by robot will be \"SOUTH\" not \"EAST\". You should update this!\\n\\n![image](https://assets.leetcode.com/users/images/426f8daf-96ea-4b60-914c-93f8b59bb6e6_1636819860.6443744.png)\\n\\n\\nCorrect Code:\\n\\n```\\nclass Robot {\\npublic:\\n    int w, h, i, j, round, dir = 0,flag = 1;\\n    Robot(int width, int height) {\\n        w = width;\\n        h = height;\\n        i = 0;\\n        j = 0;\\n        round = w + w + h + h - 4;\\n    \\n    }\\n    \\n    void move(int num) {\\n        num = num % round;\\n        if(flag and num == 0){\\n            if(i == 0 and j == 0)   dir = 3;\\n            flag = 0;\\n            return ;\\n        }\\n        \\n        while(num--){\\n            if(dir == 0){\\n                j++;\\n                if(j == w){\\n                    dir = 1;\\n                    i++;\\n                    j--;\\n                }\\n            }\\n            else if(dir == 1){\\n                i++;\\n                if(i == h){\\n                    dir = 2;\\n                    i--;\\n                    j--;\\n                }\\n            }\\n            else if(dir == 2){\\n                j--;\\n                if(j == -1){\\n                    dir = 3;\\n                    j++;\\n                    i--;\\n                }\\n            }\\n            else{\\n                i--;\\n                if(i == -1){\\n                    dir = 0;\\n                    i++;\\n                    j++;\\n                }\\n            }\\n        }\\n\\n    }\\n    \\n    vector<int> getPos() {\\n        return {j, i};\\n    }\\n    \\n    string getDir() {\\n        if(dir == 0)    return \"East\";\\n        if(dir == 1)    return \"North\";\\n        if(dir == 2)    return \"West\";\\n        if(dir == 3)    return \"South\";\\n        return \"\";\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Robot {\\npublic:\\n    int w, h, i, j, round, dir = 0,flag = 1;\\n    Robot(int width, int height) {\\n        w = width;\\n        h = height;\\n        i = 0;\\n        j = 0;\\n        round = w + w + h + h - 4;\\n    \\n    }\\n    \\n    void move(int num) {\\n        num = num % round;\\n        if(flag and num == 0){\\n            if(i == 0 and j == 0)   dir = 3;\\n            flag = 0;\\n            return ;\\n        }\\n        \\n        while(num--){\\n            if(dir == 0){\\n                j++;\\n                if(j == w){\\n                    dir = 1;\\n                    i++;\\n                    j--;\\n                }\\n            }\\n            else if(dir == 1){\\n                i++;\\n                if(i == h){\\n                    dir = 2;\\n                    i--;\\n                    j--;\\n                }\\n            }\\n            else if(dir == 2){\\n                j--;\\n                if(j == -1){\\n                    dir = 3;\\n                    j++;\\n                    i--;\\n                }\\n            }\\n            else{\\n                i--;\\n                if(i == -1){\\n                    dir = 0;\\n                    i++;\\n                    j++;\\n                }\\n            }\\n        }\\n\\n    }\\n    \\n    vector<int> getPos() {\\n        return {j, i};\\n    }\\n    \\n    string getDir() {\\n        if(dir == 0)    return \"East\";\\n        if(dir == 1)    return \"North\";\\n        if(dir == 2)    return \"West\";\\n        if(dir == 3)    return \"South\";\\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576766,
                "title": "formula",
                "content": "Very hairy problem. The realization is that position always determines the direction (except if we haven\\'t `moved` yet).\\n \\nAnd position can be determined by the number of steps we traveled from the left-bottom corner (so we use modulo to discard loops).\\n\\n**C++**\\n```cpp\\nint st = 0, w = 0, h = 0, moved = false;\\nRobot(int width, int height): w(width - 1), h(height - 1) {}\\nvoid move(int num) {\\n    moved = true;\\n    st = (st + num) % (2 * h + 2 * w);\\n}\\nvector<int> getPos() {\\n    return { st < w ? st : st < w + h ? w : st < 2 * w + h ? 2 * w + h - st : 0,\\n           st < w ? 0 : st < w + h ? st - w : st < 2 * w + h ? h : 2 * w + 2 * h - st };\\n}\\nstring getDir() {\\n    return (moved && (st > 2 * w + h || st == 0)) ? \"South\" : st <= w ? \"East\" : st <= w + h ? \"North\" : \"West\";\\n}\\n```\\n**Switch Case Version**\\n```cpp\\nint steps = 0, w = 0, h = 0, per = 0;\\nRobot(int width, int height): w(width - 1), h(height - 1), per(2 * h + 2 * w) {}\\nvoid move(int num) { steps += num; }\\nint getSide(int steps) {\\n    return steps <= w ? 0 // bottom\\n        : steps <= w + h ? 1 // right\\n            : steps <= 2 * w + h ? 2 // top\\n                : 3; // left\\n}\\nvector<int> getPos() {\\n    switch (getSide(steps % per)) {\\n        case 0:\\n            return {steps % per, 0};\\n        case 1:\\n            return {w, steps % per - w};\\n        case 2:\\n            return {2 * w + h - steps % per, h};\\n        default:\\n            return {0, per - steps % per};\\n    }\\n}\\nstring getDir() {\\n    if (steps && steps % per == 0)\\n        return \"South\";\\n    switch (getSide(steps % per)) {\\n        case 0:\\n            return \"East\";\\n        case 1:\\n            return \"North\";\\n        case 2:\\n            return \"West\";\\n        default:\\n            return \"South\";\\n    }    \\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint st = 0, w = 0, h = 0, moved = false;\\nRobot(int width, int height): w(width - 1), h(height - 1) {}\\nvoid move(int num) {\\n    moved = true;\\n    st = (st + num) % (2 * h + 2 * w);\\n}\\nvector<int> getPos() {\\n    return { st < w ? st : st < w + h ? w : st < 2 * w + h ? 2 * w + h - st : 0,\\n           st < w ? 0 : st < w + h ? st - w : st < 2 * w + h ? h : 2 * w + 2 * h - st };\\n}\\nstring getDir() {\\n    return (moved && (st > 2 * w + h || st == 0)) ? \"South\" : st <= w ? \"East\" : st <= w + h ? \"North\" : \"West\";\\n}\\n```\n```cpp\\nint steps = 0, w = 0, h = 0, per = 0;\\nRobot(int width, int height): w(width - 1), h(height - 1), per(2 * h + 2 * w) {}\\nvoid move(int num) { steps += num; }\\nint getSide(int steps) {\\n    return steps <= w ? 0 // bottom\\n        : steps <= w + h ? 1 // right\\n            : steps <= 2 * w + h ? 2 // top\\n                : 3; // left\\n}\\nvector<int> getPos() {\\n    switch (getSide(steps % per)) {\\n        case 0:\\n            return {steps % per, 0};\\n        case 1:\\n            return {w, steps % per - w};\\n        case 2:\\n            return {2 * w + h - steps % per, h};\\n        default:\\n            return {0, per - steps % per};\\n    }\\n}\\nstring getDir() {\\n    if (steps && steps % per == 0)\\n        return \"South\";\\n    switch (getSide(steps % per)) {\\n        case 0:\\n            return \"East\";\\n        case 1:\\n            return \"North\";\\n        case 2:\\n            return \"West\";\\n        default:\\n            return \"South\";\\n    }    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1575992,
                "title": "use-mod-to-move-and-only-calculate-position-direction-when-asked-o-1-space-o-1-time",
                "content": "```\\nclass Robot:\\n\\n    def __init__(self, width: int, height: int):\\n        self.width = width - 1\\n        self.height = height - 1\\n        self.mod = 2 * (self.width + self.height)\\n        self.position = 0\\n        self.moved = False\\n\\n    def move(self, num: int) -> None:\\n        self.moved = True\\n        self.position = (self.position + num) % self.mod\\n        \\n    def getPos(self) -> List[int]:\\n        pos = self.position\\n        if pos <= self.width:\\n            return [pos, 0]\\n        pos -= self.width\\n        if pos <= self.height:\\n            return [self.width, pos]\\n        pos -= self.height\\n        if pos <= self.width:\\n            return [self.width - pos, self.height]\\n        pos -= self.width\\n        return [0, self.height - pos]\\n            \\n    def getDir(self) -> str:\\n        pos = self.position\\n        if pos == 0:\\n            return \\'South\\' if self.moved else \\'East\\'\\n        if pos <= self.width:\\n            return \\'East\\'\\n        pos -= self.width\\n        if pos <= self.height:\\n            return \\'North\\'\\n        pos -= self.height\\n        if pos <= self.width:\\n            return \\'West\\'\\n        return \\'South\\'\\n```",
                "solutionTags": [],
                "code": "```\\nclass Robot:\\n\\n    def __init__(self, width: int, height: int):\\n        self.width = width - 1\\n        self.height = height - 1\\n        self.mod = 2 * (self.width + self.height)\\n        self.position = 0\\n        self.moved = False\\n\\n    def move(self, num: int) -> None:\\n        self.moved = True\\n        self.position = (self.position + num) % self.mod\\n        \\n    def getPos(self) -> List[int]:\\n        pos = self.position\\n        if pos <= self.width:\\n            return [pos, 0]\\n        pos -= self.width\\n        if pos <= self.height:\\n            return [self.width, pos]\\n        pos -= self.height\\n        if pos <= self.width:\\n            return [self.width - pos, self.height]\\n        pos -= self.width\\n        return [0, self.height - pos]\\n            \\n    def getDir(self) -> str:\\n        pos = self.position\\n        if pos == 0:\\n            return \\'South\\' if self.moved else \\'East\\'\\n        if pos <= self.width:\\n            return \\'East\\'\\n        pos -= self.width\\n        if pos <= self.height:\\n            return \\'North\\'\\n        pos -= self.height\\n        if pos <= self.width:\\n            return \\'West\\'\\n        return \\'South\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1575907,
                "title": "c-176ms-91-o1time-commented",
                "content": "\\n![image](https://assets.leetcode.com/users/images/73493060-fea0-4d86-a09f-ffec33e1ea8e_1636822636.8582125.png)\\n\\n**General idea:**\\n1. calculate **total path** as : (width + hight) * 2  - 4 \\n2. whan we calculate move : **new pos** = ( **old pos** + **num** ) % **total path**\\n3. when we calculate coordinates : check where our pos \\n   first interval **[0; l1)** or second interval **[ l1 ; l2)** or third interval **[ l2 ; l3)** or last interval\\n4. when we calculate direction - we do like step 3 (exption is start position for this case I use **flag**)\\n\\n\\nRuntime: 176 ms, faster than 90.91% of C++ online submissions for Walking Robot Simulation II.\\nMemory Usage: 120.5 MB, less than 27.27% of C++ online submissions for Walking Robot Simulation II.\\n```\\nclass Robot {\\npublic:\\n  int pos, tot, l1, l2, l3, max_y, max_x;\\n  bool flag = true;\\n  \\n  Robot(int w, int h) {\\n    pos = 0;\\n    max_y = h - 1, max_x = w - 1; \\n    l1  = w;\\n    l2  = l1 + h - 1;\\n    l3  = l2 + w - 1;\\n    tot = l3 + h - 2;\\n  }\\n    \\n  void move(int num){\\n    flag = false;\\n    pos = (pos + num)%tot;\\n  }\\n    \\n  vector<int> getPos() {\\n    if(pos < l1) return {pos, 0};\\n    if(pos < l2) return {max_x, pos - l1 + 1};\\n    if(pos < l3) return {l3 - pos - 1, max_y};\\n    \\n    return {0 , tot - pos};      \\n  }\\n    \\n  string getDir() {\\n    if(flag) return \"East\";\\n    \\n    if(pos == 0) return \"South\";\\n    if(pos < l1) return \"East\";\\n    if(pos < l2) return \"North\";\\n    if(pos < l3) return \"West\";\\n    \\n    return \"South\"; \\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Robot {\\npublic:\\n  int pos, tot, l1, l2, l3, max_y, max_x;\\n  bool flag = true;\\n  \\n  Robot(int w, int h) {\\n    pos = 0;\\n    max_y = h - 1, max_x = w - 1; \\n    l1  = w;\\n    l2  = l1 + h - 1;\\n    l3  = l2 + w - 1;\\n    tot = l3 + h - 2;\\n  }\\n    \\n  void move(int num){\\n    flag = false;\\n    pos = (pos + num)%tot;\\n  }\\n    \\n  vector<int> getPos() {\\n    if(pos < l1) return {pos, 0};\\n    if(pos < l2) return {max_x, pos - l1 + 1};\\n    if(pos < l3) return {l3 - pos - 1, max_y};\\n    \\n    return {0 , tot - pos};      \\n  }\\n    \\n  string getDir() {\\n    if(flag) return \"East\";\\n    \\n    if(pos == 0) return \"South\";\\n    if(pos < l1) return \"East\";\\n    if(pos < l2) return \"North\";\\n    if(pos < l3) return \"West\";\\n    \\n    return \"South\"; \\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576086,
                "title": "simple-c-solution",
                "content": "```\\nclass Robot {\\n    string dir[4] = {\"East\", \"North\", \"West\", \"South\"};\\n    int     dx[4] = { +1   ,   +0   ,   -1  ,    -0  };\\n    int     dy[4] = { +0   ,   +1   ,   -0  ,    -1  };\\n    int currDir;\\n    int width, height;\\n    int y , x;\\npublic:\\n    Robot(int width, int height) {\\n        this->width = width;\\n        this->height = height;\\n        currDir = 0;\\n        x = 0;\\n        y = 0;\\n    }\\n    \\n    void move(int num) {\\n        if (num < 1) return;\\n        \\n        if (y == 0 and x == 0 and currDir == 0 and num >= (height+width-2)*2) // move steps multiple of perimeter-4\\n        {\\n            currDir = 3;\\n            move(num%((height+width-2)*2));\\n        }\\n        else // attempt to move one step\\n        {\\n            int nx = x+dx[currDir];\\n            int ny = y+dy[currDir];\\n\\n            if (nx < 0 or nx >= width or ny < 0 or ny >= height) // if out of bounds\\n            {\\n                currDir = (currDir+1)%4;\\n                move(num);\\n            }\\n            else  // move one step\\n            {\\n                x = nx; y = ny;\\n                move(num-1);\\n            }\\n        }\\n    }\\n    \\n    vector<int> getPos() {\\n        return {x, y};\\n    }\\n    \\n    string getDir() {\\n        return dir[currDir];\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Robot {\\n    string dir[4] = {\"East\", \"North\", \"West\", \"South\"};\\n    int     dx[4] = { +1   ,   +0   ,   -1  ,    -0  };\\n    int     dy[4] = { +0   ,   +1   ,   -0  ,    -1  };\\n    int currDir;\\n    int width, height;\\n    int y , x;\\npublic:\\n    Robot(int width, int height) {\\n        this->width = width;\\n        this->height = height;\\n        currDir = 0;\\n        x = 0;\\n        y = 0;\\n    }\\n    \\n    void move(int num) {\\n        if (num < 1) return;\\n        \\n        if (y == 0 and x == 0 and currDir == 0 and num >= (height+width-2)*2) // move steps multiple of perimeter-4\\n        {\\n            currDir = 3;\\n            move(num%((height+width-2)*2));\\n        }\\n        else // attempt to move one step\\n        {\\n            int nx = x+dx[currDir];\\n            int ny = y+dy[currDir];\\n\\n            if (nx < 0 or nx >= width or ny < 0 or ny >= height) // if out of bounds\\n            {\\n                currDir = (currDir+1)%4;\\n                move(num);\\n            }\\n            else  // move one step\\n            {\\n                x = nx; y = ny;\\n                move(num-1);\\n            }\\n        }\\n    }\\n    \\n    vector<int> getPos() {\\n        return {x, y};\\n    }\\n    \\n    string getDir() {\\n        return dir[currDir];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576005,
                "title": "move-is-a-keyword-in-rust-judge-has-a-compile-error",
                "content": "Here\\'s my attempt with rust but I got a compile error:\\n\\n```\\nLine 79, Char 22: expected identifier, found keyword `move` (solution.rs)\\n   |\\n79 |     let result = obj.move(Deserializer::to_int(args[0].as_str()).unwrap());\\n   |                      ^^^^ expected identifier, found keyword\\n   |\\nhelp: you can escape reserved keywords to use them as identifiers\\n   |\\n79 |     let result = obj.r#move(Deserializer::to_int(args[0].as_str()).unwrap());\\n   |                      ^^^^^^\\nerror: aborting due to previous error\\n```\\n\\ndoes anyone know how to fix the compile error? it seems it\\'s a problem with the judge code trying to use a keyword. \\n\\n```\\nstruct Robot {\\n    dir: Vec<String>,\\n    pos: Vec<Vec<i32>>,\\n    i: usize,\\n}\\n\\nimpl Robot {\\n    fn new(width: i32, height: i32) -> Self {\\n        let mut dir = vec![];\\n        let mut pos = vec![];\\n        let mut x = 0;\\n        let mut y = 0;\\n        for _ in 0..width {\\n            dir.push(\"East\".to_string());\\n            pos.push(vec![x, y]);\\n            x += 1;\\n        }\\n        x -= 1;\\n        for _ in 0..height {\\n            dir.push(\"North\".to_string());\\n            pos.push(vec![x, y]);\\n            y += 1;\\n        }\\n        y -= 1;\\n        for _ in 0..width {\\n            dir.push(\"West\".to_string());\\n            pos.push(vec![x, y]);\\n            x -= 1;\\n        }\\n        x += 1;\\n        for _ in 0..height {\\n            dir.push(\"South\".to_string());\\n            pos.push(vec![x, y]);\\n            y -= 1;\\n        }\\n        Robot {\\n            dir,\\n            pos,\\n            i: 0,\\n        }\\n    }\\n\\n    fn r#move(&mut self, num: i32) {\\n        let num = num as usize;\\n        self.i += num;\\n        self.i %= self.dir.len();\\n    }\\n\\n    fn get_pos(&self) -> Vec<i32> {\\n        self.pos[self.i].clone()\\n    }\\n\\n    fn get_dir(&self) -> String {\\n        self.dir[self.i].clone()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nLine 79, Char 22: expected identifier, found keyword `move` (solution.rs)\\n   |\\n79 |     let result = obj.move(Deserializer::to_int(args[0].as_str()).unwrap());\\n   |                      ^^^^ expected identifier, found keyword\\n   |\\nhelp: you can escape reserved keywords to use them as identifiers\\n   |\\n79 |     let result = obj.r#move(Deserializer::to_int(args[0].as_str()).unwrap());\\n   |                      ^^^^^^\\nerror: aborting due to previous error\\n```\n```\\nstruct Robot {\\n    dir: Vec<String>,\\n    pos: Vec<Vec<i32>>,\\n    i: usize,\\n}\\n\\nimpl Robot {\\n    fn new(width: i32, height: i32) -> Self {\\n        let mut dir = vec![];\\n        let mut pos = vec![];\\n        let mut x = 0;\\n        let mut y = 0;\\n        for _ in 0..width {\\n            dir.push(\"East\".to_string());\\n            pos.push(vec![x, y]);\\n            x += 1;\\n        }\\n        x -= 1;\\n        for _ in 0..height {\\n            dir.push(\"North\".to_string());\\n            pos.push(vec![x, y]);\\n            y += 1;\\n        }\\n        y -= 1;\\n        for _ in 0..width {\\n            dir.push(\"West\".to_string());\\n            pos.push(vec![x, y]);\\n            x -= 1;\\n        }\\n        x += 1;\\n        for _ in 0..height {\\n            dir.push(\"South\".to_string());\\n            pos.push(vec![x, y]);\\n            y -= 1;\\n        }\\n        Robot {\\n            dir,\\n            pos,\\n            i: 0,\\n        }\\n    }\\n\\n    fn r#move(&mut self, num: i32) {\\n        let num = num as usize;\\n        self.i += num;\\n        self.i %= self.dir.len();\\n    }\\n\\n    fn get_pos(&self) -> Vec<i32> {\\n        self.pos[self.i].clone()\\n    }\\n\\n    fn get_dir(&self) -> String {\\n        self.dir[self.i].clone()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1575981,
                "title": "python-solution-save-all-the-possible-positions-and-mod",
                "content": "``` python\\nclass Robot:\\n\\n    def __init__(self, width: int, height: int):\\n        self.w = width\\n        self.h = height\\n        self.pos = [0, 0]\\n        \\n        # save all the possible positions\\n        self.arr = []\\n        for i in range(width):\\n            self.arr.append([i, 0])\\n        for i in range(1, height):\\n            self.arr.append([width - 1, i])\\n        for i in range(1, width):\\n            self.arr.append([width - 1 - i, height - 1])\\n        for i in range(1, height - 1):\\n            self.arr.append([0, height - 1 - i])\\n        \\n        # robot has moved or not\\n        self.flag = 1\\n\\n    def move(self, num: int) -> None:\\n\\t\\n\\t\\t# find where pos in arr\\n        i = self.arr.index(self.pos)\\n\\t\\t\\n\\t\\t# calculate the new position\\n        self.pos = self.arr[(i + num) % (self.w * 2 + self.h * 2 - 4)]\\n\\t\\t\\n        self.flag = 0\\n\\n    def getPos(self) -> List[int]:\\n        return self.pos\\n\\n    def getDir(self) -> str:\\n\\t\\n\\t\\t# robot has not moved yet\\n        if self.flag:\\n            return \"East\"\\n\\t\\t\\t\\n\\t\\t# x == 0\\n        if self.pos[0] == 0:\\n            if self.pos[1] == self.h - 1:\\n                return \"West\"\\n            else:\\n                return \"South\"\\n\\t\\t\\t\\t\\n\\t\\t# x == self.w - 1\\n        if self.pos[0] == self.w - 1:\\n            if self.pos[1] == 0:\\n                return \"East\"\\n            else:\\n                return \"North\"\\n\\t\\t\\t\\t\\n\\t\\t# y == 0\\n        if self.pos[1] == 0:\\n            return \"East\"\\n\\t\\t\\t\\n\\t\\t# y == 1\\n        return \"West\"\\n```",
                "solutionTags": [],
                "code": "``` python\\nclass Robot:\\n\\n    def __init__(self, width: int, height: int):\\n        self.w = width\\n        self.h = height\\n        self.pos = [0, 0]\\n        \\n        # save all the possible positions\\n        self.arr = []\\n        for i in range(width):\\n            self.arr.append([i, 0])\\n        for i in range(1, height):\\n            self.arr.append([width - 1, i])\\n        for i in range(1, width):\\n            self.arr.append([width - 1 - i, height - 1])\\n        for i in range(1, height - 1):\\n            self.arr.append([0, height - 1 - i])\\n        \\n        # robot has moved or not\\n        self.flag = 1\\n\\n    def move(self, num: int) -> None:\\n\\t\\n\\t\\t# find where pos in arr\\n        i = self.arr.index(self.pos)\\n\\t\\t\\n\\t\\t# calculate the new position\\n        self.pos = self.arr[(i + num) % (self.w * 2 + self.h * 2 - 4)]\\n\\t\\t\\n        self.flag = 0\\n\\n    def getPos(self) -> List[int]:\\n        return self.pos\\n\\n    def getDir(self) -> str:\\n\\t\\n\\t\\t# robot has not moved yet\\n        if self.flag:\\n            return \"East\"\\n\\t\\t\\t\\n\\t\\t# x == 0\\n        if self.pos[0] == 0:\\n            if self.pos[1] == self.h - 1:\\n                return \"West\"\\n            else:\\n                return \"South\"\\n\\t\\t\\t\\t\\n\\t\\t# x == self.w - 1\\n        if self.pos[0] == self.w - 1:\\n            if self.pos[1] == 0:\\n                return \"East\"\\n            else:\\n                return \"North\"\\n\\t\\t\\t\\t\\n\\t\\t# y == 0\\n        if self.pos[1] == 0:\\n            return \"East\"\\n\\t\\t\\t\\n\\t\\t# y == 1\\n        return \"West\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576222,
                "title": "clear-and-concise-c-solution",
                "content": "```\\nclass Robot {\\npublic:\\n    \\n    int x, y, w, h, flag=1, perim;\\n    string dir;\\n    \\n    Robot(int width, int height) {\\n        dir = \"East\";\\n        x = 0, y = 0;\\n        perim = width + width + height + height - 4;\\n        w = width;\\n        h = height;\\n    }\\n    \\n    void east()\\n    {\\n        y++;\\n        if(y == w)\\n        {\\n            dir = \"North\";\\n            x++, y--;\\n        }\\n    }\\n    \\n    void west()\\n    {\\n        y--;\\n        if(y == -1)\\n        {\\n            dir = \"South\";\\n            x--, y++;\\n        }\\n    }\\n    \\n    void north()\\n    {\\n        x++;\\n        if(x == h)\\n        {\\n            dir = \"West\";\\n            x--, y--;\\n        }\\n    }\\n    \\n    void south()\\n    {\\n        x--;\\n        if(x == -1)\\n        {\\n            dir = \"East\";\\n            x++, y++;\\n        }\\n    }\\n    \\n    void move(int num) {\\n        \\n        num = num % perim;\\n        \\n        if(flag && num == 0)\\n        {\\n            if(x==0 && y==0)\\n                dir = \"South\";\\n            flag = 0;\\n            return;\\n        }\\n        \\n        for(int i=0; i<num; i++)\\n        {\\n            if(dir == \"East\")\\n                east();\\n            else if(dir == \"West\")\\n                west();\\n            else if(dir == \"North\")\\n                north();\\n            else if(dir == \"South\")\\n                south();\\n        }\\n    }\\n    \\n    vector<int> getPos() {\\n        return {y, x};\\n    }\\n    \\n    string getDir() {\\n        return dir;\\n    }\\n};\\n```\\n\\n***Put east() west() north() south() code inside if else statements to increase run time significantly. Seeing such code all at one place may be confusing for beginners.***",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Robot {\\npublic:\\n    \\n    int x, y, w, h, flag=1, perim;\\n    string dir;\\n    \\n    Robot(int width, int height) {\\n        dir = \"East\";\\n        x = 0, y = 0;\\n        perim = width + width + height + height - 4;\\n        w = width;\\n        h = height;\\n    }\\n    \\n    void east()\\n    {\\n        y++;\\n        if(y == w)\\n        {\\n            dir = \"North\";\\n            x++, y--;\\n        }\\n    }\\n    \\n    void west()\\n    {\\n        y--;\\n        if(y == -1)\\n        {\\n            dir = \"South\";\\n            x--, y++;\\n        }\\n    }\\n    \\n    void north()\\n    {\\n        x++;\\n        if(x == h)\\n        {\\n            dir = \"West\";\\n            x--, y--;\\n        }\\n    }\\n    \\n    void south()\\n    {\\n        x--;\\n        if(x == -1)\\n        {\\n            dir = \"East\";\\n            x++, y++;\\n        }\\n    }\\n    \\n    void move(int num) {\\n        \\n        num = num % perim;\\n        \\n        if(flag && num == 0)\\n        {\\n            if(x==0 && y==0)\\n                dir = \"South\";\\n            flag = 0;\\n            return;\\n        }\\n        \\n        for(int i=0; i<num; i++)\\n        {\\n            if(dir == \"East\")\\n                east();\\n            else if(dir == \"West\")\\n                west();\\n            else if(dir == \"North\")\\n                north();\\n            else if(dir == \"South\")\\n                south();\\n        }\\n    }\\n    \\n    vector<int> getPos() {\\n        return {y, x};\\n    }\\n    \\n    string getDir() {\\n        return dir;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576529,
                "title": "elegant-o-1-c-solution-based-on-four-if-logic-no-loops",
                "content": "Below is a neat and concise `O(1)` solution based on four `if` conditions.\\nWe, basically, check on which side the `cur` position falls using the `updatePos` method on each `move` invocation.\\n\\nIntuitively, `cur` is the number of steps from beginning to reach the current position.\\nEast, North is increasing, so we subtract the previous corner number (aka `side[i-1]`) from `cur`.\\nWest, South is decreasing, so we subtract `cur` from the current corner number(aka `side[i]`).\\n\\n```\\nclass Robot {\\n    int w, h, cur = 0;\\n    vector<int> pos = {0, 0}, side;\\n    string dir = \"East\";\\n    \\n    void updatePos() {\\n        if (cur <= side[0]) {\\n            pos = {cur, 0};\\n            dir = cur ? \"East\" : \"South\";\\n        } else if (cur <= side[1]) {\\n            pos = {w - 1, cur - side[0]};\\n            dir = \"North\";\\n        } else if (cur <= side[2]) {\\n            pos = {side[2] - cur, h - 1};\\n            dir = \"West\";\\n        } else {\\n            pos = {0, side[3] - cur};\\n            dir = \"South\";\\n        }\\n    }\\npublic:\\n    Robot(int width, int height) : w(width), h(height) {\\n        side = {w - 1, w + h - 2, 2 * w + h - 3, 2 * w + 2 * h - 4};\\n    }\\n    \\n    void move(int num) {\\n        cur = (cur + num)  % (side[3]);\\n        updatePos();\\n    }\\n    \\n    vector<int> getPos() { return pos; }\\n    string getDir() { return dir; }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Robot {\\n    int w, h, cur = 0;\\n    vector<int> pos = {0, 0}, side;\\n    string dir = \"East\";\\n    \\n    void updatePos() {\\n        if (cur <= side[0]) {\\n            pos = {cur, 0};\\n            dir = cur ? \"East\" : \"South\";\\n        } else if (cur <= side[1]) {\\n            pos = {w - 1, cur - side[0]};\\n            dir = \"North\";\\n        } else if (cur <= side[2]) {\\n            pos = {side[2] - cur, h - 1};\\n            dir = \"West\";\\n        } else {\\n            pos = {0, side[3] - cur};\\n            dir = \"South\";\\n        }\\n    }\\npublic:\\n    Robot(int width, int height) : w(width), h(height) {\\n        side = {w - 1, w + h - 2, 2 * w + h - 3, 2 * w + 2 * h - 4};\\n    }\\n    \\n    void move(int num) {\\n        cur = (cur + num)  % (side[3]);\\n        updatePos();\\n    }\\n    \\n    vector<int> getPos() { return pos; }\\n    string getDir() { return dir; }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3132098,
                "title": "c-o-1-time-and-space",
                "content": "**Approach:**\\n* Calculating perimeter with given height and width.\\n* Using modulos operator to quickly compute which position and direction it stops.\\n\\n**Note:** if robot moves, its direction for [0, 0] will be South, While it starts at [0, 0] with East\\n\\n*Time complexity - O(1)\\nSpace Complexity - O(1)*\\n\\n```\\n\\tvector<vector<int>> dir = {{1,0},{0,1},{-1,0},{0,-1}};\\n    vector<string> dir_str = {\"East\",\"North\",\"West\",\"South\"};\\n    vector<int> pos = {0,0};\\n    int w, h, idx=0, count=0;\\n    \\n    Robot(int width, int height) {\\n        w=width;\\n        h=height;\\n    }\\n    \\n    void step(int num) {\\n        count = (count + num) % (2*(w + h - 2));\\n        \\n        if(count >=0 && count < w){\\n            pos={count, 0};\\n            idx = count==0 ? 3 : 0;\\n        }else if(count >= w && count < w + h - 1){\\n            pos={w-1, count - w + 1};\\n            idx=1;\\n        }else if(count >= w + h - 1 && count < 2*w + h - 2){\\n            pos={2*w + h - count - 3, h - 1};\\n            idx=2;\\n        }else{\\n            pos={0, 2*h + 2*w - count - 4};\\n            idx=3;\\n        }\\n    }\\n    \\n    vector<int> getPos() {\\n        return pos;\\n    }\\n    \\n    string getDir() {\\n        return dir_str[idx];\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\tvector<vector<int>> dir = {{1,0},{0,1},{-1,0},{0,-1}};\\n    vector<string> dir_str = {\"East\",\"North\",\"West\",\"South\"};\\n    vector<int> pos = {0,0};\\n    int w, h, idx=0, count=0;\\n    \\n    Robot(int width, int height) {\\n        w=width;\\n        h=height;\\n    }\\n    \\n    void step(int num) {\\n        count = (count + num) % (2*(w + h - 2));\\n        \\n        if(count >=0 && count < w){\\n            pos={count, 0};\\n            idx = count==0 ? 3 : 0;\\n        }else if(count >= w && count < w + h - 1){\\n            pos={w-1, count - w + 1};\\n            idx=1;\\n        }else if(count >= w + h - 1 && count < 2*w + h - 2){\\n            pos={2*w + h - count - 3, h - 1};\\n            idx=2;\\n        }else{\\n            pos={0, 2*h + 2*w - count - 4};\\n            idx=3;\\n        }\\n    }\\n    \\n    vector<int> getPos() {\\n        return pos;\\n    }\\n    \\n    string getDir() {\\n        return dir_str[idx];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1995662,
                "title": "java-simple-o-1-for-all-no-for-while-loop",
                "content": "It is actually very symmetrical if we adjust width and height to 0 index (i.e. substract 1 from them) at the very start.\\nWe can then mod the number of cells in a lap = `2 * (width + height)` and just do\\n```\\n{remainder, 0}\\n{w, reminder}\\n{w - reminder, h}\\n{0, h - reminder}\\n```\\nfor each position.\\nThere is one edge case: When the robot hasn\\'t removed, it is facing \"East\", not \"South\".\\n\\nThere is no for-loop or while loop at all, so it is O(1) for all methods including constructor. \\n```Java\\nclass Robot {\\n\\n    int p;\\n    int w;\\n    int h;\\n    public Robot(int width, int height) {\\n        w = width - 1;\\n        h = height - 1;\\n        p = 0;\\n    }\\n\\n    public void step(int num) {\\n        p += num;\\n    }\\n\\n    public int[] getPos() {\\n        int remain = p % (2 * (w + h));\\n        if (remain <= w)\\n            return new int[]{remain, 0};\\n        remain -= w;\\n        if (remain <= h)\\n            return new int[]{w, remain};\\n        remain -= h;\\n        if (remain <= w)\\n            return new int[]{w - remain, h};\\n        remain -= w;\\n        return new int[]{0, h - remain};\\n    }\\n\\n    public String getDir() {\\n        int[] pos = getPos();\\n        if (p == 0 || pos[1] == 0 && pos[0] > 0)\\n            return \"East\";\\n        else if (pos[0] == w && pos[1] > 0)\\n            return \"North\";\\n        else if (pos[1] == h && pos[0] < w)\\n            return \"West\";\\n        else\\n            return \"South\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n{remainder, 0}\\n{w, reminder}\\n{w - reminder, h}\\n{0, h - reminder}\\n```\n```Java\\nclass Robot {\\n\\n    int p;\\n    int w;\\n    int h;\\n    public Robot(int width, int height) {\\n        w = width - 1;\\n        h = height - 1;\\n        p = 0;\\n    }\\n\\n    public void step(int num) {\\n        p += num;\\n    }\\n\\n    public int[] getPos() {\\n        int remain = p % (2 * (w + h));\\n        if (remain <= w)\\n            return new int[]{remain, 0};\\n        remain -= w;\\n        if (remain <= h)\\n            return new int[]{w, remain};\\n        remain -= h;\\n        if (remain <= w)\\n            return new int[]{w - remain, h};\\n        remain -= w;\\n        return new int[]{0, h - remain};\\n    }\\n\\n    public String getDir() {\\n        int[] pos = getPos();\\n        if (p == 0 || pos[1] == 0 && pos[0] > 0)\\n            return \"East\";\\n        else if (pos[0] == w && pos[1] > 0)\\n            return \"North\";\\n        else if (pos[1] == h && pos[0] < w)\\n            return \"West\";\\n        else\\n            return \"South\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1633717,
                "title": "js-circular-array-preprocessing-commented-code",
                "content": "**tl;dr**\\n\\n1. robot walks around the map once\\n2. store entire path and corresponding directions into arrays\\n3. keep a counter of all the steps taken\\n4. use mod operation to look up coordinates and direction in constant time\\n\\n**example implementation**\\n\\n```\\nconst EAST = \"East\";\\nconst NORTH = \"North\";\\nconst WEST = \"West\";\\nconst SOUTH = \"South\";\\n\\nconst DIRECTIONS = [EAST, NORTH, WEST, SOUTH];\\nconst ORIGIN = [0,0];\\n\\n/**\\n * @param {number} width\\n * @param {number} height\\n */\\nvar Robot = function(width, height) {\\n    this.width = width;\\n    this.height = height;\\n    \\n    this.path = []; // circular buffer of entire path of robot\\n    this.dirAtSquare = [];  // dir robot is facing at each square\\n    this.currentPos = -1;\\n\\n    this.preprocess();\\n};\\n\\n/**\\n * Loop around the map once and store the path into a circular buffer.\\n *\\n * (0,0) is set to face SOUTH. The only time it is EAST is at the beginning\\n * if the robot didn\\'t move at all.\\n *\\n * @return {void}\\n */\\nRobot.prototype.preprocess = function() {\\n    // go right\\n    for (let i = 1; i < this.width; i++) {\\n        this.path.push([i, 0]);\\n        this.dirAtSquare.push(0);\\n    }\\n    \\n    // go up\\n    const xMax = this.width - 1;\\n    for (let i = 1; i < this.height; i++) {\\n        this.path.push([xMax, i]);\\n        this.dirAtSquare.push(1);\\n    }\\n    \\n    // go left\\n    const yMax = this.height - 1;\\n    for (let i = xMax - 1; i >= 0; i--) {\\n        this.path.push([i, yMax]);\\n        this.dirAtSquare.push(2);\\n    }\\n    \\n    // go down\\n    const xMin = 0;\\n    for (let i = yMax - 1; i >= 0; i--) {\\n        this.path.push([xMin, i]);\\n        this.dirAtSquare.push(3);\\n    }\\n}\\n\\n/** \\n * @param {number} num\\n * @return {void}\\n */\\nRobot.prototype.step = function(num) {\\n    this.currentPos += num;\\n};\\n\\n/**\\n * @return {number[]}\\n */\\nRobot.prototype.getPos = function() {\\n    return this.currentPos === -1\\n        ? ORIGIN    // we haven\\'t moved\\n        : this.path[this.currentPos % this.path.length];\\n};\\n\\n/**\\n * @return {string}\\n */\\nRobot.prototype.getDir = function() {\\n    return this.currentPos === -1\\n        ? DIRECTIONS[0] // we haven\\'t moved\\n        : DIRECTIONS[this.dirAtSquare[this.currentPos % this.dirAtSquare.length]];\\n};\\n\\n/** \\n * Your Robot object will be instantiated and called as such:\\n * var obj = new Robot(width, height)\\n * obj.step(num)\\n * var param_2 = obj.getPos()\\n * var param_3 = obj.getDir()\\n */\\n ```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\nconst EAST = \"East\";\\nconst NORTH = \"North\";\\nconst WEST = \"West\";\\nconst SOUTH = \"South\";\\n\\nconst DIRECTIONS = [EAST, NORTH, WEST, SOUTH];\\nconst ORIGIN = [0,0];\\n\\n/**\\n * @param {number} width\\n * @param {number} height\\n */\\nvar Robot = function(width, height) {\\n    this.width = width;\\n    this.height = height;\\n    \\n    this.path = []; // circular buffer of entire path of robot\\n    this.dirAtSquare = [];  // dir robot is facing at each square\\n    this.currentPos = -1;\\n\\n    this.preprocess();\\n};\\n\\n/**\\n * Loop around the map once and store the path into a circular buffer.\\n *\\n * (0,0) is set to face SOUTH. The only time it is EAST is at the beginning\\n * if the robot didn\\'t move at all.\\n *\\n * @return {void}\\n */\\nRobot.prototype.preprocess = function() {\\n    // go right\\n    for (let i = 1; i < this.width; i++) {\\n        this.path.push([i, 0]);\\n        this.dirAtSquare.push(0);\\n    }\\n    \\n    // go up\\n    const xMax = this.width - 1;\\n    for (let i = 1; i < this.height; i++) {\\n        this.path.push([xMax, i]);\\n        this.dirAtSquare.push(1);\\n    }\\n    \\n    // go left\\n    const yMax = this.height - 1;\\n    for (let i = xMax - 1; i >= 0; i--) {\\n        this.path.push([i, yMax]);\\n        this.dirAtSquare.push(2);\\n    }\\n    \\n    // go down\\n    const xMin = 0;\\n    for (let i = yMax - 1; i >= 0; i--) {\\n        this.path.push([xMin, i]);\\n        this.dirAtSquare.push(3);\\n    }\\n}\\n\\n/** \\n * @param {number} num\\n * @return {void}\\n */\\nRobot.prototype.step = function(num) {\\n    this.currentPos += num;\\n};\\n\\n/**\\n * @return {number[]}\\n */\\nRobot.prototype.getPos = function() {\\n    return this.currentPos === -1\\n        ? ORIGIN    // we haven\\'t moved\\n        : this.path[this.currentPos % this.path.length];\\n};\\n\\n/**\\n * @return {string}\\n */\\nRobot.prototype.getDir = function() {\\n    return this.currentPos === -1\\n        ? DIRECTIONS[0] // we haven\\'t moved\\n        : DIRECTIONS[this.dirAtSquare[this.currentPos % this.dirAtSquare.length]];\\n};\\n\\n/** \\n * Your Robot object will be instantiated and called as such:\\n * var obj = new Robot(width, height)\\n * obj.step(num)\\n * var param_2 = obj.getPos()\\n * var param_3 = obj.getDir()\\n */\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1576363,
                "title": "java-easy-to-understand-solution-solve-hidden-test-case-error",
                "content": "## Thought process : \\n1. nothing much to notice just keep the variables and arrays public.\\n2. implement the logic i.e. change the direction after every last bound reached. \\n3. Look for the pattern in the repetition : 2*w + 2*h - 4 . Now apply num % roundtrip\\n4. Umm.. thats it ( I went wrong here for the first time ).\\n5. Okay what if it reaches back to the place it started  . Hmm so lets keep num = roundtrip when we reach at 0 again.\\n\\n## Code : \\n```\\nclass Robot {\\n            public int[][] arr;\\n            public int[] pos;\\n            public String dir = \"\"; \\npublic int round = 0;\\n    public Robot(int width, int height) {\\n        arr = new int[width][height];\\n       pos = new int[]{0,0};\\n          dir = \"East\";\\n        round = width + width + height + height - 4;\\n    }\\n    \\n    public void move(int num) {\\n       num %= round;\\n\\t\\tif (num == 0)\\n\\t\\t\\tnum = round;\\n        \\n        int temp = num;\\n       while(temp>0)\\n       {\\n           if(dir == \"East\")\\n           {\\n               if(pos[0]<arr.length-1)\\n               {\\n               pos[0]++;\\n                   temp--;\\n               }\\n               else\\n               {\\n                   dir = \"North\";\\n                   pos[1]++;\\n                   temp--;\\n               }\\n           }\\n            else if(dir == \"North\")\\n           {\\n               if(pos[1]<arr[0].length-1)\\n               {\\n               pos[1]++;\\n                   temp--;\\n               }\\n               else\\n               {\\n                   dir = \"West\";\\n                   pos[0]--;\\n                   temp--;\\n               }\\n           }\\n            else if(dir == \"West\")\\n           {\\n               if(pos[0]>0)\\n               {\\n               pos[0]--;\\n                   temp--;\\n               }\\n               else\\n               {\\n                   dir = \"South\";\\n                   pos[1]--;\\n                   temp--;\\n               }\\n           }\\n            else if(dir == \"South\")\\n           {\\n               if(pos[1]>0)\\n               {\\n               pos[1]--;\\n                   temp--;\\n               }\\n               else\\n               {\\n                   dir = \"East\";\\n                   pos[0]++;\\n                   temp--;\\n               }\\n           }  \\n       }\\n    }\\n    \\n    public int[] getPos() {\\n        return pos;\\n    }\\n    \\n    public String getDir() {\\n        return dir;\\n    }\\n}\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot obj = new Robot(width, height);\\n * obj.move(num);\\n * int[] param_2 = obj.getPos();\\n * String param_3 = obj.getDir();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Robot {\\n            public int[][] arr;\\n            public int[] pos;\\n            public String dir = \"\"; \\npublic int round = 0;\\n    public Robot(int width, int height) {\\n        arr = new int[width][height];\\n       pos = new int[]{0,0};\\n          dir = \"East\";\\n        round = width + width + height + height - 4;\\n    }\\n    \\n    public void move(int num) {\\n       num %= round;\\n\\t\\tif (num == 0)\\n\\t\\t\\tnum = round;\\n        \\n        int temp = num;\\n       while(temp>0)\\n       {\\n           if(dir == \"East\")\\n           {\\n               if(pos[0]<arr.length-1)\\n               {\\n               pos[0]++;\\n                   temp--;\\n               }\\n               else\\n               {\\n                   dir = \"North\";\\n                   pos[1]++;\\n                   temp--;\\n               }\\n           }\\n            else if(dir == \"North\")\\n           {\\n               if(pos[1]<arr[0].length-1)\\n               {\\n               pos[1]++;\\n                   temp--;\\n               }\\n               else\\n               {\\n                   dir = \"West\";\\n                   pos[0]--;\\n                   temp--;\\n               }\\n           }\\n            else if(dir == \"West\")\\n           {\\n               if(pos[0]>0)\\n               {\\n               pos[0]--;\\n                   temp--;\\n               }\\n               else\\n               {\\n                   dir = \"South\";\\n                   pos[1]--;\\n                   temp--;\\n               }\\n           }\\n            else if(dir == \"South\")\\n           {\\n               if(pos[1]>0)\\n               {\\n               pos[1]--;\\n                   temp--;\\n               }\\n               else\\n               {\\n                   dir = \"East\";\\n                   pos[0]++;\\n                   temp--;\\n               }\\n           }  \\n       }\\n    }\\n    \\n    public int[] getPos() {\\n        return pos;\\n    }\\n    \\n    public String getDir() {\\n        return dir;\\n    }\\n}\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot obj = new Robot(width, height);\\n * obj.move(num);\\n * int[] param_2 = obj.getPos();\\n * String param_3 = obj.getDir();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1575929,
                "title": "python-don-t-need-to-move-until-getting-pos-dir-with-some-explanation",
                "content": "The only tricky part is how to deal with the facing direction after a full round of trip. Need to find a more elegant way to handle it.\\n\\n```Python\\nclass Robot:\\n\\n    def __init__(self, width: int, height: int):\\n        self.deltas = [(1, 0), (0, 1), (-1, 0), (0, -1)]\\n        self.dirs = [\"East\", \"North\", \"West\", \"South\"]\\n        self.boundary = [[width - 1, 0], [width - 1, height - 1], [0, height - 1], [0, 0]]\\n        self.pos = [0, 0]\\n        self.dir = 0\\n        self.width = width\\n        self.height = height\\n        self.steps_so_far = 0\\n\\n    def isOut(self, w, h):\\n        if w < 0 or w >= self.width or h < 0 or h >= self.height:\\n            return True\\n        return False\\n        \\n    def move(self, num: int) -> None:\\n        self.steps_so_far += num\\n        \\n    def _move(self, num):\\n\\t    # perimeter\\n        num %= (self.width + self.height) * 2 - 4\\n\\t\\t# if the robot starts and end at the same corner, set its facing to the single possible direction (entering this corner)\\n        if num == 0:\\n            if self.pos == self.boundary[0]:\\n                self.dir = 0\\n            elif self.pos == self.boundary[1]:\\n                self.dir = 1\\n            elif self.pos == self.boundary[2]:\\n                self.dir = 2\\n            elif self.pos == self.boundary[3]:\\n                self.dir = 3\\n            return\\n\\t\\t\\t\\n\\t\\t# if the move in the current direction gets out of bound, change direction\\n        while self.isOut(self.pos[0] + num * self.deltas[self.dir][0], self.pos[1] + num * self.deltas[self.dir][1]):\\n            num -= max(abs(self.boundary[self.dir][0] - self.pos[0]), abs(self.boundary[self.dir][1] - self.pos[1]))\\n            self.pos[0] = self.boundary[self.dir][0]\\n            self.pos[1] = self.boundary[self.dir][1]\\n            self.dir = (self.dir + 1) % 4\\n\\n        self.pos[0] += num * self.deltas[self.dir][0]\\n        self.pos[1] += num * self.deltas[self.dir][1]\\n\\n    def getPos(self) -> List[int]:\\n        if self.steps_so_far > 0:\\n            self._move(self.steps_so_far)\\n            self.steps_so_far = 0\\n        return self.pos\\n\\n    def getDir(self) -> str:\\n        if self.steps_so_far > 0:\\n            self._move(self.steps_so_far)\\n            self.steps_so_far = 0\\n        return self.dirs[self.dir]\\n\\n\\n# Your Robot object will be instantiated and called as such:\\n# obj = Robot(width, height)\\n# obj.move(num)\\n# param_2 = obj.getPos()\\n# param_3 = obj.getDir()\\n```\\n\\nUpdate:\\nActually, we don\\'t need to handle the all four cases as shown in the code. There is only one case, i.e., (0, 0), that we need to deal with. When the robot starts from (0, 0), its facing direction is East. If the robot ends its move at (0, 0), then its facing is \"South\". For other 3 corners, the entering facing direction will always be the same.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```Python\\nclass Robot:\\n\\n    def __init__(self, width: int, height: int):\\n        self.deltas = [(1, 0), (0, 1), (-1, 0), (0, -1)]\\n        self.dirs = [\"East\", \"North\", \"West\", \"South\"]\\n        self.boundary = [[width - 1, 0], [width - 1, height - 1], [0, height - 1], [0, 0]]\\n        self.pos = [0, 0]\\n        self.dir = 0\\n        self.width = width\\n        self.height = height\\n        self.steps_so_far = 0\\n\\n    def isOut(self, w, h):\\n        if w < 0 or w >= self.width or h < 0 or h >= self.height:\\n            return True\\n        return False\\n        \\n    def move(self, num: int) -> None:\\n        self.steps_so_far += num\\n        \\n    def _move(self, num):\\n\\t    # perimeter\\n        num %= (self.width + self.height) * 2 - 4\\n\\t\\t# if the robot starts and end at the same corner, set its facing to the single possible direction (entering this corner)\\n        if num == 0:\\n            if self.pos == self.boundary[0]:\\n                self.dir = 0\\n            elif self.pos == self.boundary[1]:\\n                self.dir = 1\\n            elif self.pos == self.boundary[2]:\\n                self.dir = 2\\n            elif self.pos == self.boundary[3]:\\n                self.dir = 3\\n            return\\n\\t\\t\\t\\n\\t\\t# if the move in the current direction gets out of bound, change direction\\n        while self.isOut(self.pos[0] + num * self.deltas[self.dir][0], self.pos[1] + num * self.deltas[self.dir][1]):\\n            num -= max(abs(self.boundary[self.dir][0] - self.pos[0]), abs(self.boundary[self.dir][1] - self.pos[1]))\\n            self.pos[0] = self.boundary[self.dir][0]\\n            self.pos[1] = self.boundary[self.dir][1]\\n            self.dir = (self.dir + 1) % 4\\n\\n        self.pos[0] += num * self.deltas[self.dir][0]\\n        self.pos[1] += num * self.deltas[self.dir][1]\\n\\n    def getPos(self) -> List[int]:\\n        if self.steps_so_far > 0:\\n            self._move(self.steps_so_far)\\n            self.steps_so_far = 0\\n        return self.pos\\n\\n    def getDir(self) -> str:\\n        if self.steps_so_far > 0:\\n            self._move(self.steps_so_far)\\n            self.steps_so_far = 0\\n        return self.dirs[self.dir]\\n\\n\\n# Your Robot object will be instantiated and called as such:\\n# obj = Robot(width, height)\\n# obj.move(num)\\n# param_2 = obj.getPos()\\n# param_3 = obj.getDir()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904453,
                "title": "c-super-rare-clean-code-easy-to-grasp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Robot {\\nprivate:\\n    pair<string,pair<int,int>> arr[500];\\n    int peri;\\n    bool move;\\n    int steps;\\npublic:\\n    Robot(int width, int height) {\\n        \\n        steps = move = peri = 0;\\n        arr[peri] = {\"South\",{0,0}};\\n\\n        for(int i=1; i<width; i++){\\n            arr[++peri] = {\"East\",{i,0}};\\n        }\\n\\n        for(int i=1; i<height; i++){\\n            arr[++peri] = {\"North\",{width-1,i}};\\n        }\\n\\n        for(int i=width-2; i>=0; i--){\\n            arr[++peri] = {\"West\",{i,height-1}};\\n        }\\n\\n        for(int i=height-2; i>=0; i--){\\n            arr[++peri] = {\"South\",{0,i}};\\n\\n        }\\n\\n    }\\n    \\n    void step(int num) {\\n        move = true;\\n        steps += num;\\n        steps %= peri;\\n    }\\n    \\n    vector<int> getPos() {\\n        return {arr[steps].second.first,arr[steps].second.second};\\n    }\\n    \\n    string getDir() {\\n        if(!move) return \"East\";\\n        return arr[steps].first;\\n    }\\n};\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot* obj = new Robot(width, height);\\n * obj->step(num);\\n * vector<int> param_2 = obj->getPos();\\n * string param_3 = obj->getDir();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Robot {\\nprivate:\\n    pair<string,pair<int,int>> arr[500];\\n    int peri;\\n    bool move;\\n    int steps;\\npublic:\\n    Robot(int width, int height) {\\n        \\n        steps = move = peri = 0;\\n        arr[peri] = {\"South\",{0,0}};\\n\\n        for(int i=1; i<width; i++){\\n            arr[++peri] = {\"East\",{i,0}};\\n        }\\n\\n        for(int i=1; i<height; i++){\\n            arr[++peri] = {\"North\",{width-1,i}};\\n        }\\n\\n        for(int i=width-2; i>=0; i--){\\n            arr[++peri] = {\"West\",{i,height-1}};\\n        }\\n\\n        for(int i=height-2; i>=0; i--){\\n            arr[++peri] = {\"South\",{0,i}};\\n\\n        }\\n\\n    }\\n    \\n    void step(int num) {\\n        move = true;\\n        steps += num;\\n        steps %= peri;\\n    }\\n    \\n    vector<int> getPos() {\\n        return {arr[steps].second.first,arr[steps].second.second};\\n    }\\n    \\n    string getDir() {\\n        if(!move) return \"East\";\\n        return arr[steps].first;\\n    }\\n};\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot* obj = new Robot(width, height);\\n * obj->step(num);\\n * vector<int> param_2 = obj->getPos();\\n * string param_3 = obj->getDir();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477342,
                "title": "not-bad",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Robot:\\n\\n    def __init__(self, width: int, height: int):\\n        self.dir=\"East\"\\n        self.cor=[0,0]\\n        self.arr=[width-1,height-1]\\n        self.width=width\\n        self.height=height\\n\\n    def step(self, num: int) -> None:\\n        total=((self.height+self.width-2)*2)\\n        num=num%total\\n        if num!=0:\\n           i=0\\n           while i<num:\\n                if self.dir==\"East\":\\n                    if self.cor[0]==self.width-1:\\n                        num+=1\\n                        self.dir=\"North\"\\n                    else:self.cor[0]+=1\\n\\n                elif self.dir==\"West\":\\n                    if self.cor[0]==0:\\n                        num+=1\\n                        self.dir=\"South\"\\n                    else:self.cor[0]-=1\\n                elif self.dir==\"North\":\\n                    if self.cor[1]==self.height-1:\\n                        num+=1\\n                        self.dir=\"West\"\\n                    else:self.cor[1]+=1\\n                elif self.dir==\"South\":\\n                    if self.cor[1]==0:\\n                        num+=1\\n                        self.dir=\"East\"\\n                    else:self.cor[1]-=1\\n                i+=1      \\n        elif self.cor==[0,0]  and self.dir==\"East\":self.dir=\"South\"\\n      \\n    def getPos(self) -> List[int]:\\n        return self.cor\\n\\n    def getDir(self) -> str:\\n        return self.dir\\n\\n\\n# Your Robot object will be instantiated and called as such:\\n# obj = Robot(width, height)\\n# obj.step(num)\\n# param_2 = obj.getPos()\\n# param_3 = obj.getDir()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Design",
                    "Simulation"
                ],
                "code": "```\\nclass Robot:\\n\\n    def __init__(self, width: int, height: int):\\n        self.dir=\"East\"\\n        self.cor=[0,0]\\n        self.arr=[width-1,height-1]\\n        self.width=width\\n        self.height=height\\n\\n    def step(self, num: int) -> None:\\n        total=((self.height+self.width-2)*2)\\n        num=num%total\\n        if num!=0:\\n           i=0\\n           while i<num:\\n                if self.dir==\"East\":\\n                    if self.cor[0]==self.width-1:\\n                        num+=1\\n                        self.dir=\"North\"\\n                    else:self.cor[0]+=1\\n\\n                elif self.dir==\"West\":\\n                    if self.cor[0]==0:\\n                        num+=1\\n                        self.dir=\"South\"\\n                    else:self.cor[0]-=1\\n                elif self.dir==\"North\":\\n                    if self.cor[1]==self.height-1:\\n                        num+=1\\n                        self.dir=\"West\"\\n                    else:self.cor[1]+=1\\n                elif self.dir==\"South\":\\n                    if self.cor[1]==0:\\n                        num+=1\\n                        self.dir=\"East\"\\n                    else:self.cor[1]-=1\\n                i+=1      \\n        elif self.cor==[0,0]  and self.dir==\"East\":self.dir=\"South\"\\n      \\n    def getPos(self) -> List[int]:\\n        return self.cor\\n\\n    def getDir(self) -> str:\\n        return self.dir\\n\\n\\n# Your Robot object will be instantiated and called as such:\\n# obj = Robot(width, height)\\n# obj.step(num)\\n# param_2 = obj.getPos()\\n# param_3 = obj.getDir()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445342,
                "title": "c-simulation",
                "content": "# Code\\n```\\nclass Robot {\\n    int total, width, height, cycleLen;\\n    vector<string> directions;\\npublic:\\n    Robot(int width, int height) {\\n        total = 0;\\n        this -> width = width;\\n        this -> height = height;\\n        cycleLen = (width + height - 2) * 2;\\n        directions = {\"East\", \"North\", \"West\", \"South\"};\\n    }\\n    \\n    void step(int num) {\\n        total += num;\\n    }\\n\\n    vector<int> solve() {\\n        if(!total) return {0, 0, 0};\\n        int x = 0, y = 0, dir = 3;\\n        int steps = total % cycleLen;\\n        if(steps) {\\n            dir = (dir + 1) % 4;\\n            int m = min(steps, width - 1);\\n            steps -= m;\\n            x = m, y = 0;\\n        }\\n        if(steps) {\\n            dir = (dir + 1) % 4;\\n            int m = min(steps, height - 1);\\n            steps -= m;\\n            x = width - 1, y = m;\\n        }\\n        if(steps) {\\n            dir = (dir + 1) % 4;\\n            int m = min(steps, width - 1);\\n            steps -= m;\\n            x = width - 1 - m, y = height - 1;\\n        }\\n        if(steps) {\\n            dir = (dir + 1) % 4;\\n            int m = min(steps, height - 1);\\n            steps -= m;\\n            x = 0, y = height - 1 - m;\\n        }\\n        return {x, y, dir};\\n    }\\n    \\n    vector<int> getPos() {\\n        vector<int> vals = solve();\\n        return {vals[0], vals[1]};\\n    }\\n    \\n    string getDir() {\\n        vector<int> vals = solve();\\n        return directions[vals[2]];\\n    }\\n};\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot* obj = new Robot(width, height);\\n * obj->step(num);\\n * vector<int> param_2 = obj->getPos();\\n * string param_3 = obj->getDir();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Design",
                    "Simulation"
                ],
                "code": "```\\nclass Robot {\\n    int total, width, height, cycleLen;\\n    vector<string> directions;\\npublic:\\n    Robot(int width, int height) {\\n        total = 0;\\n        this -> width = width;\\n        this -> height = height;\\n        cycleLen = (width + height - 2) * 2;\\n        directions = {\"East\", \"North\", \"West\", \"South\"};\\n    }\\n    \\n    void step(int num) {\\n        total += num;\\n    }\\n\\n    vector<int> solve() {\\n        if(!total) return {0, 0, 0};\\n        int x = 0, y = 0, dir = 3;\\n        int steps = total % cycleLen;\\n        if(steps) {\\n            dir = (dir + 1) % 4;\\n            int m = min(steps, width - 1);\\n            steps -= m;\\n            x = m, y = 0;\\n        }\\n        if(steps) {\\n            dir = (dir + 1) % 4;\\n            int m = min(steps, height - 1);\\n            steps -= m;\\n            x = width - 1, y = m;\\n        }\\n        if(steps) {\\n            dir = (dir + 1) % 4;\\n            int m = min(steps, width - 1);\\n            steps -= m;\\n            x = width - 1 - m, y = height - 1;\\n        }\\n        if(steps) {\\n            dir = (dir + 1) % 4;\\n            int m = min(steps, height - 1);\\n            steps -= m;\\n            x = 0, y = height - 1 - m;\\n        }\\n        return {x, y, dir};\\n    }\\n    \\n    vector<int> getPos() {\\n        vector<int> vals = solve();\\n        return {vals[0], vals[1]};\\n    }\\n    \\n    string getDir() {\\n        vector<int> vals = solve();\\n        return directions[vals[2]];\\n    }\\n};\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot* obj = new Robot(width, height);\\n * obj->step(num);\\n * vector<int> param_2 = obj->getPos();\\n * string param_3 = obj->getDir();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2936774,
                "title": "java-solution-walking-robot-simulation-ii",
                "content": "# Intuition\\nTaking mod to reduce time complexity\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWill increase the step in direction d and check if the newX and newY are valid or not. If not then change the direction i.e. d = (d+1) % 4;\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- step : O(2*(width+height)) + getPos : O(1) + getDir : O(1) = O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Robot {\\n    private int[][] dir = {{1,0},{0,1},{-1,0},{0,-1}};\\n    private String[] direction = {\"East\",\"North\",\"West\",\"South\"};\\n    private int width;\\n    private int height;\\n    private int x,y,d,mod;\\n\\n    public Robot(int width, int height) {\\n        this.width = width;\\n        this.height = height;\\n        mod = width*2 + height*2 -4;\\n    }\\n\\n    private boolean isValid(int x, int y){\\n        return x>=0 && x<width && y>=0 && y<height;\\n    }\\n\\n    public void step(int num) {\\n        num = num % mod;\\n        if(num == 0) num=mod;\\n\\n        while(num-->0){\\n            if(!isValid(x+dir[d][0], y+dir[d][1]))\\n                d = (d+1)%4;\\n            x+=dir[d][0];\\n            y+=dir[d][1];\\n        }\\n    }\\n    \\n    public int[] getPos() {\\n        return new int[]{x,y};\\n    }\\n    \\n    public String getDir() {\\n        return direction[d];\\n    }\\n}\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot obj = new Robot(width, height);\\n * obj.step(num);\\n * int[] param_2 = obj.getPos();\\n * String param_3 = obj.getDir();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Robot {\\n    private int[][] dir = {{1,0},{0,1},{-1,0},{0,-1}};\\n    private String[] direction = {\"East\",\"North\",\"West\",\"South\"};\\n    private int width;\\n    private int height;\\n    private int x,y,d,mod;\\n\\n    public Robot(int width, int height) {\\n        this.width = width;\\n        this.height = height;\\n        mod = width*2 + height*2 -4;\\n    }\\n\\n    private boolean isValid(int x, int y){\\n        return x>=0 && x<width && y>=0 && y<height;\\n    }\\n\\n    public void step(int num) {\\n        num = num % mod;\\n        if(num == 0) num=mod;\\n\\n        while(num-->0){\\n            if(!isValid(x+dir[d][0], y+dir[d][1]))\\n                d = (d+1)%4;\\n            x+=dir[d][0];\\n            y+=dir[d][1];\\n        }\\n    }\\n    \\n    public int[] getPos() {\\n        return new int[]{x,y};\\n    }\\n    \\n    public String getDir() {\\n        return direction[d];\\n    }\\n}\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot obj = new Robot(width, height);\\n * obj.step(num);\\n * int[] param_2 = obj.getPos();\\n * String param_3 = obj.getDir();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2249830,
                "title": "easiest-solution-very-intutive-beginner-friendly",
                "content": "Intution : As the Robot walks only on circumference so there will be total 2 * width + 2 * height - 4 = perimeter, no. of positions on circumference where robot can stop .Now if we store every position and its direction at that position in our map then we can return the position and direction in just O(1) time.\\n\\nBase Case: When the robot is at its starting positon(0, 0) its direction is \"East\" but once if the robot left his starting position and it reaches again on starting position(0, 0) then its direction will be \"South\".\\n\\n```\\nclass Robot {\\n\\tvector<string> direction = {\"East\", \"North\", \"West\", \"South\"}; \\n    unordered_map<int, vector<int>>m;\\n    int totalSteps = 0;\\n    int perimeter;\\npublic:\\n    Robot(int width, int height) {\\n        perimeter = 2 *( width - 2) + 2 * height;\\n        \\n        int pos = 0;\\n        \\n        for(int w = 0;w < width;w++){\\n            m[pos++] = {w, 0, 0};\\n        }\\n        for(int h = 1;h < height;h++){\\n            m[pos++] = {width - 1, h, 1};\\n        }\\n        for(int w = width - 2;w >= 0;w--){\\n            m[pos++] = {w, height - 1, 2};\\n        }\\n        for(int h = height - 2;h > 0;h--){\\n            m[pos++] = {0, h, 3};\\n        }\\n\\n    }\\n    \\n    void step(int num) {\\n        totalSteps += num;\\n    }\\n    \\n    vector<int> getPos() {\\n        int position = totalSteps % perimeter;\\n        auto v = m[position];\\n        return {v[0], v[1]};\\n    }\\n    \\n    string getDir() {\\n        int position = totalSteps % perimeter;\\n        \\n        auto v = m[position];\\n        if(position == 0){\\n            if(totalSteps == 0)\\n                return direction[0];\\n            else\\n                return direction[3];\\n        }\\n        \\n        return direction[v[2]];\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Robot {\\n\\tvector<string> direction = {\"East\", \"North\", \"West\", \"South\"}; \\n    unordered_map<int, vector<int>>m;\\n    int totalSteps = 0;\\n    int perimeter;\\npublic:\\n    Robot(int width, int height) {\\n        perimeter = 2 *( width - 2) + 2 * height;\\n        \\n        int pos = 0;\\n        \\n        for(int w = 0;w < width;w++){\\n            m[pos++] = {w, 0, 0};\\n        }\\n        for(int h = 1;h < height;h++){\\n            m[pos++] = {width - 1, h, 1};\\n        }\\n        for(int w = width - 2;w >= 0;w--){\\n            m[pos++] = {w, height - 1, 2};\\n        }\\n        for(int h = height - 2;h > 0;h--){\\n            m[pos++] = {0, h, 3};\\n        }\\n\\n    }\\n    \\n    void step(int num) {\\n        totalSteps += num;\\n    }\\n    \\n    vector<int> getPos() {\\n        int position = totalSteps % perimeter;\\n        auto v = m[position];\\n        return {v[0], v[1]};\\n    }\\n    \\n    string getDir() {\\n        int position = totalSteps % perimeter;\\n        \\n        auto v = m[position];\\n        if(position == 0){\\n            if(totalSteps == 0)\\n                return direction[0];\\n            else\\n                return direction[3];\\n        }\\n        \\n        return direction[v[2]];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976295,
                "title": "java-beats-100-00-memory-speed-0ms-april-2022",
                "content": "```\\nclass Robot {\\n    private final int width, height, perimeter, rightTop, leftTop, rightBottom;\\n    private int steps = 0;\\n    private boolean started = false; //\\n    public Robot(int width, int height) {\\n        this.width = width;\\n        this.height = height;\\n        this.perimeter = (width + height - 2) * 2; // Number of steps to go around a circle.\\n        this.rightBottom = width - 1; // Number of steps to reach bottom right corner.\\n        this.rightTop = width + height - 2; // Number of steps to reach top right corner.\\n        this.leftTop = width * 2 + height - 3; // Number of steps to reach top left corner.\\n    }\\n    public void step(int num) {\\n        if(num == 0) return;\\n        steps = (steps + num) % perimeter;\\n        started = true; // Since the initial direction is different from later direction at 0/0, a boolean is needed.\\n    }\\n    public int[] getPos() {\\n        if(steps == 0) return new int[]{0, 0};\\n        if(steps > 0 && steps <= rightBottom) return new int[]{steps, 0};\\n        if(steps > rightBottom && steps <= rightTop) return new int[]{width -1, steps - rightBottom};\\n        if(steps > rightTop && steps <= leftTop) return new int[]{leftTop - steps , height - 1};\\n        return new int[]{0, perimeter - steps};\\n    }\\n    public String getDir() {\\n        if(steps > 0 && steps < width) return \"East\";\\n        if(steps >= width && steps <= rightTop) return \"North\";\\n        if(steps > rightTop && steps <= leftTop) return \"West\";\\n        if(steps == 0 && !started) return \"East\"; // If it\\'s the initial state.\\n        return \"South\";\\n    }\\n}\\n```\\n\\n***Consider upvote if usefull!***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Robot {\\n    private final int width, height, perimeter, rightTop, leftTop, rightBottom;\\n    private int steps = 0;\\n    private boolean started = false; //\\n    public Robot(int width, int height) {\\n        this.width = width;\\n        this.height = height;\\n        this.perimeter = (width + height - 2) * 2; // Number of steps to go around a circle.\\n        this.rightBottom = width - 1; // Number of steps to reach bottom right corner.\\n        this.rightTop = width + height - 2; // Number of steps to reach top right corner.\\n        this.leftTop = width * 2 + height - 3; // Number of steps to reach top left corner.\\n    }\\n    public void step(int num) {\\n        if(num == 0) return;\\n        steps = (steps + num) % perimeter;\\n        started = true; // Since the initial direction is different from later direction at 0/0, a boolean is needed.\\n    }\\n    public int[] getPos() {\\n        if(steps == 0) return new int[]{0, 0};\\n        if(steps > 0 && steps <= rightBottom) return new int[]{steps, 0};\\n        if(steps > rightBottom && steps <= rightTop) return new int[]{width -1, steps - rightBottom};\\n        if(steps > rightTop && steps <= leftTop) return new int[]{leftTop - steps , height - 1};\\n        return new int[]{0, perimeter - steps};\\n    }\\n    public String getDir() {\\n        if(steps > 0 && steps < width) return \"East\";\\n        if(steps >= width && steps <= rightTop) return \"North\";\\n        if(steps > rightTop && steps <= leftTop) return \"West\";\\n        if(steps == 0 && !started) return \"East\"; // If it\\'s the initial state.\\n        return \"South\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1625076,
                "title": "c-easy-to-understand-fast",
                "content": "```\\nclass Robot {\\npublic:\\n    int width,height;\\n    int dir=0;\\n   int x=0,y=0;\\n    Robot(int width, int height) {\\n        this->width=width;\\n        this->height=height;\\n    }\\n    void step(int num)\\n    {\\n         int peri=2*(height+width)-4;\\n         if(num%peri!=0)\\n         num%=peri;\\n          if(dir==0)\\n        {       \\n            if(x+num<=width-1)\\n            {\\n                x=x+num;\\n                num=0;\\n            }\\n            else\\n            {\\n                num-=(width-1-x);\\n                x=width-1;\\n                dir=(dir+1)%4;\\n                move(num);\\n            }\\n        }\\n        else if(dir==1)\\n        {\\n            if(y+num<=height-1)\\n            {\\n                y=y+num;\\n                num=0;\\n            }\\n            else\\n            {\\n                num-=(height-1-y);\\n                y=height-1;\\n                dir=(dir+1)%4;\\n                move(num);\\n            }  \\n        }\\n        else if(dir==2)\\n        {   \\n           if(x-num>=0)\\n            {\\n                x=x-num;\\n                num=0;\\n            }\\n            else\\n            {\\n                num-=x;\\n                x=0;\\n                dir=(dir+1)%4;\\n                move(num);\\n            }\\n        }\\n        else if(dir==3)\\n        {       \\n            if(y-num>=0)\\n            {\\n                y=y-num;\\n                num=0;\\n            }\\n            else\\n            {\\n                num-=(y);\\n                y=0;\\n                dir=(dir+1)%4;\\n                move(num);\\n            }\\n        }\\n    }\\n    void move(int num) {\\n     int peri=2*(height+width)-4;\\n        if(num%peri!=0)\\n         num%=peri;\\n        step(num);\\n    }\\n    vector<int> getPos() {\\n        vector<int> pos(2);\\n        pos[0]=x;\\n        pos[1]=y;\\n        return pos;\\n    }\\n    string getDir() {\\n        if(dir==0)\\n        return \"East\";\\n        else if(dir==1)\\n        return \"North\";\\n        else if(dir==2)\\n        return \"West\";\\n        else if(dir==3)\\n        return \"South\";\\n        return \"\";\\n    }\\n};\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot* obj = new Robot(width, height);\\n * obj->step(num);\\n * vector<int> param_2 = obj->getPos();\\n * string param_3 = obj->getDir();\\n */\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Robot {\\npublic:\\n    int width,height;\\n    int dir=0;\\n   int x=0,y=0;\\n    Robot(int width, int height) {\\n        this->width=width;\\n        this->height=height;\\n    }\\n    void step(int num)\\n    {\\n         int peri=2*(height+width)-4;\\n         if(num%peri!=0)\\n         num%=peri;\\n          if(dir==0)\\n        {       \\n            if(x+num<=width-1)\\n            {\\n                x=x+num;\\n                num=0;\\n            }\\n            else\\n            {\\n                num-=(width-1-x);\\n                x=width-1;\\n                dir=(dir+1)%4;\\n                move(num);\\n            }\\n        }\\n        else if(dir==1)\\n        {\\n            if(y+num<=height-1)\\n            {\\n                y=y+num;\\n                num=0;\\n            }\\n            else\\n            {\\n                num-=(height-1-y);\\n                y=height-1;\\n                dir=(dir+1)%4;\\n                move(num);\\n            }  \\n        }\\n        else if(dir==2)\\n        {   \\n           if(x-num>=0)\\n            {\\n                x=x-num;\\n                num=0;\\n            }\\n            else\\n            {\\n                num-=x;\\n                x=0;\\n                dir=(dir+1)%4;\\n                move(num);\\n            }\\n        }\\n        else if(dir==3)\\n        {       \\n            if(y-num>=0)\\n            {\\n                y=y-num;\\n                num=0;\\n            }\\n            else\\n            {\\n                num-=(y);\\n                y=0;\\n                dir=(dir+1)%4;\\n                move(num);\\n            }\\n        }\\n    }\\n    void move(int num) {\\n     int peri=2*(height+width)-4;\\n        if(num%peri!=0)\\n         num%=peri;\\n        step(num);\\n    }\\n    vector<int> getPos() {\\n        vector<int> pos(2);\\n        pos[0]=x;\\n        pos[1]=y;\\n        return pos;\\n    }\\n    string getDir() {\\n        if(dir==0)\\n        return \"East\";\\n        else if(dir==1)\\n        return \"North\";\\n        else if(dir==2)\\n        return \"West\";\\n        else if(dir==3)\\n        return \"South\";\\n        return \"\";\\n    }\\n};\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot* obj = new Robot(width, height);\\n * obj->step(num);\\n * vector<int> param_2 = obj->getPos();\\n * string param_3 = obj->getDir();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1610826,
                "title": "c-simple-solution-o-1-tc-99-35-speed",
                "content": "Logic :\\nTotal number of blocks on boundry, rd = height*2 + (width-2)*2\\nThey can be seen as straight line starting from 0,1, ... , rd-1.\\nEvery block on the boundry of rectangle will have only specific coordinates and direction. We can preprocess them into map/vector.\\nTime Complextity : O(1)\\nSpace Complexity : O(width+height)\\n\\nCode : \\n```\\nclass Robot {\\npublic:\\n    int rd;\\n    bool start;\\n    int cur;\\n    vector<pair<string, pair<int,int>>> map;\\n    \\n    Robot(int x, int y) {\\n        cur = 0; \\n        start = false;\\n        rd = 2*x + (y-2)*2;\\n        \\n        map.clear();\\n        map.assign(rd, {\"\",{0,0}});\\n        int cnt = 1;\\n        for(int i=1;i<x;i++) \\n            map[cnt++] = {\"East\", {i,0}};\\n        for(int j=1;j<y;j++)\\n            map[cnt++] = {\"North\", {x-1, j}};\\n        for(int i=x-2;i>=0;i--) \\n            map[cnt++] = {\"West\", {i,y-1}};\\n        for(int j=y-2;j>0;j--)\\n            map[cnt++] = {\"South\", {0, j}};\\n        map[0] = {\"South\", {0,0}};\\n    }\\n    \\n    void step(int num) {\\n        start = true;\\n        cur += num;\\n        cur %= rd;\\n    }\\n    \\n    vector<int> getPos() {\\n        return {map[cur].second.first, map[cur].second.second};\\n    }\\n    \\n    string getDir() {\\n        if(start)\\n            return map[cur].first;\\n        return \"East\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Robot {\\npublic:\\n    int rd;\\n    bool start;\\n    int cur;\\n    vector<pair<string, pair<int,int>>> map;\\n    \\n    Robot(int x, int y) {\\n        cur = 0; \\n        start = false;\\n        rd = 2*x + (y-2)*2;\\n        \\n        map.clear();\\n        map.assign(rd, {\"\",{0,0}});\\n        int cnt = 1;\\n        for(int i=1;i<x;i++) \\n            map[cnt++] = {\"East\", {i,0}};\\n        for(int j=1;j<y;j++)\\n            map[cnt++] = {\"North\", {x-1, j}};\\n        for(int i=x-2;i>=0;i--) \\n            map[cnt++] = {\"West\", {i,y-1}};\\n        for(int j=y-2;j>0;j--)\\n            map[cnt++] = {\"South\", {0, j}};\\n        map[0] = {\"South\", {0,0}};\\n    }\\n    \\n    void step(int num) {\\n        start = true;\\n        cur += num;\\n        cur %= rd;\\n    }\\n    \\n    vector<int> getPos() {\\n        return {map[cur].second.first, map[cur].second.second};\\n    }\\n    \\n    string getDir() {\\n        if(start)\\n            return map[cur].first;\\n        return \"East\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1602318,
                "title": "c-hashmap-simple-easy-to-understand-code",
                "content": "```\\nclass Robot {\\nprivate:\\n    int width, height, perimeter;\\n    int dir = 0;\\n    int x = 0, y = 0;\\n    map<int, string> mp = {{0, \"East\"}, {1, \"North\"}, {2, \"West\"}, {3, \"South\"}};\\n\\npublic:\\n    Robot(int width, int height) {\\n        this->width = width;\\n        this->height = height;\\n        this->perimeter = 2 * (height + width) - 4;\\n    }\\n    \\n    void step(int num) {\\n\\t\\tif(!num) return;\\n        num = num % perimeter;\\n        if(x == 0 && y == 0 && num == 0) dir = 3;\\n        while(num--){\\n            if(x == 0 && y == 0) dir = 0;\\n            else if(x == width-1 && y == 0) dir = 1;\\n            else if(x == width-1 && y == height-1) dir = 2;\\n            else if(x == 0 && y == height-1) dir = 3;\\n            \\n            if(dir == 0) x += 1; \\n            if(dir == 1) y += 1;\\n            if(dir == 2) x -= 1;\\n            if(dir == 3) y -= 1;\\n        }\\n        \\n    }\\n    \\n    vector<int> getPos() {\\n        return {x, y};\\n    }\\n    \\n    string getDir() {\\n        return mp[dir];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Robot {\\nprivate:\\n    int width, height, perimeter;\\n    int dir = 0;\\n    int x = 0, y = 0;\\n    map<int, string> mp = {{0, \"East\"}, {1, \"North\"}, {2, \"West\"}, {3, \"South\"}};\\n\\npublic:\\n    Robot(int width, int height) {\\n        this->width = width;\\n        this->height = height;\\n        this->perimeter = 2 * (height + width) - 4;\\n    }\\n    \\n    void step(int num) {\\n\\t\\tif(!num) return;\\n        num = num % perimeter;\\n        if(x == 0 && y == 0 && num == 0) dir = 3;\\n        while(num--){\\n            if(x == 0 && y == 0) dir = 0;\\n            else if(x == width-1 && y == 0) dir = 1;\\n            else if(x == width-1 && y == height-1) dir = 2;\\n            else if(x == 0 && y == height-1) dir = 3;\\n            \\n            if(dir == 0) x += 1; \\n            if(dir == 1) y += 1;\\n            if(dir == 2) x -= 1;\\n            if(dir == 3) y -= 1;\\n        }\\n        \\n    }\\n    \\n    vector<int> getPos() {\\n        return {x, y};\\n    }\\n    \\n    string getDir() {\\n        return mp[dir];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1596540,
                "title": "java-in-30-lines-beats-98-on-speed-and-92-on-ram",
                "content": "```\\nclass Robot {\\n    private final int width, height, perimeter, rightTop, leftTop, rightBottom;\\n    private int steps = 0;\\n    private boolean started = false; //\\n    public Robot(int width, int height) {\\n        this.width = width;\\n        this.height = height;\\n        this.perimeter = (width + height - 2) * 2; // Number of steps to go around a circle.\\n        this.rightBottom = width - 1; // Number of steps to reach bottom right corner.\\n        this.rightTop = width + height - 2; // Number of steps to reach top right corner.\\n        this.leftTop = width * 2 + height - 3; // Number of steps to reach top left corner.\\n    }\\n    public void step(int num) {\\n        if(num == 0) return;\\n        steps = (steps + num) % perimeter;\\n        started = true; // Since the initial direction is different from later direction at 0/0, a boolean is needed.\\n    }\\n    public int[] getPos() {\\n        if(steps == 0) return new int[]{0, 0};\\n        if(steps > 0 && steps <= rightBottom) return new int[]{steps, 0};\\n        if(steps > rightBottom && steps <= rightTop) return new int[]{width -1, steps - rightBottom};\\n        if(steps > rightTop && steps <= leftTop) return new int[]{leftTop - steps , height - 1};\\n        return new int[]{0, perimeter - steps};\\n    }\\n    public String getDir() {\\n        if(steps > 0 && steps < width) return \"East\";\\n        if(steps >= width && steps <= rightTop) return \"North\";\\n        if(steps > rightTop && steps <= leftTop) return \"West\";\\n        if(steps == 0 && !started) return \"East\"; // If it\\'s the initial state.\\n        return \"South\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Robot {\\n    private final int width, height, perimeter, rightTop, leftTop, rightBottom;\\n    private int steps = 0;\\n    private boolean started = false; //\\n    public Robot(int width, int height) {\\n        this.width = width;\\n        this.height = height;\\n        this.perimeter = (width + height - 2) * 2; // Number of steps to go around a circle.\\n        this.rightBottom = width - 1; // Number of steps to reach bottom right corner.\\n        this.rightTop = width + height - 2; // Number of steps to reach top right corner.\\n        this.leftTop = width * 2 + height - 3; // Number of steps to reach top left corner.\\n    }\\n    public void step(int num) {\\n        if(num == 0) return;\\n        steps = (steps + num) % perimeter;\\n        started = true; // Since the initial direction is different from later direction at 0/0, a boolean is needed.\\n    }\\n    public int[] getPos() {\\n        if(steps == 0) return new int[]{0, 0};\\n        if(steps > 0 && steps <= rightBottom) return new int[]{steps, 0};\\n        if(steps > rightBottom && steps <= rightTop) return new int[]{width -1, steps - rightBottom};\\n        if(steps > rightTop && steps <= leftTop) return new int[]{leftTop - steps , height - 1};\\n        return new int[]{0, perimeter - steps};\\n    }\\n    public String getDir() {\\n        if(steps > 0 && steps < width) return \"East\";\\n        if(steps >= width && steps <= rightTop) return \"North\";\\n        if(steps > rightTop && steps <= leftTop) return \"West\";\\n        if(steps == 0 && !started) return \"East\"; // If it\\'s the initial state.\\n        return \"South\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577522,
                "title": "javascript-brut-force-without-direction-hidden-testcase-problem",
                "content": "```\\n/**\\n * @param {number} width\\n * @param {number} height\\n */\\nvar Robot = function(width, height) {\\n    this.x = width - 1;\\n    this.y = height - 1;\\n    this.pos = [0, 0];\\n    this.dir = \\'East\\';\\n};\\n\\n/** \\n * @param {number} num\\n * @return {void}\\n */\\nRobot.prototype.move = function(num) {\\n    while (num > 0) {\\n        if (this.dir === \\'East\\') {\\n            if (num - (this.x - this.pos[0]) > 0) {\\n                this.dir = \\'North\\';\\n                num -= this.x - this.pos[0];\\n                this.pos[0] = this.x;\\n            } else {\\n                this.pos[0] += num;\\n                num = 0;\\n            }\\n            continue;\\n        }\\n        if (this.dir === \\'North\\') {\\n            if (num - (this.y - this.pos[1]) > 0) {\\n                this.dir = \\'West\\';\\n                num -= this.y - this.pos[1];\\n                this.pos[1] = this.y;\\n            } else {\\n                this.pos[1] += num;\\n                num = 0;\\n            }\\n            continue;\\n        }\\n        if (this.dir === \\'West\\') {\\n            if (num - this.pos[0] > 0) {\\n                this.dir = \\'South\\';\\n                num -= this.pos[0];\\n                this.pos[0] = 0;\\n            } else {\\n                this.pos[0] = this.pos[0] - num;\\n                num = 0;\\n            }\\n            continue;\\n        }\\n        if (this.dir === \\'South\\') {\\n            if (num - this.pos[1] > 0) {\\n                this.dir = \\'East\\';\\n                num -= this.pos[1];\\n                this.pos[1] = 0;\\n            } else {\\n                this.pos[1] = this.pos[1] - num;\\n                num = 0;\\n            }\\n            continue;\\n        }\\n        \\n    }\\n    \\n};\\n\\n/**\\n * @return {number[]}\\n */\\nRobot.prototype.getPos = function() {\\n    return this.pos;\\n};\\n\\n/**\\n * @return {string}\\n */\\nRobot.prototype.getDir = function() {\\n    return this.dir;\\n};\\n\\n/** \\n * Your Robot object will be instantiated and called as such:\\n * var obj = new Robot(width, height)\\n * obj.move(num)\\n * var param_2 = obj.getPos()\\n * var param_3 = obj.getDir()\\n */ \\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} width\\n * @param {number} height\\n */\\nvar Robot = function(width, height) {\\n    this.x = width - 1;\\n    this.y = height - 1;\\n    this.pos = [0, 0];\\n    this.dir = \\'East\\';\\n};\\n\\n/** \\n * @param {number} num\\n * @return {void}\\n */\\nRobot.prototype.move = function(num) {\\n    while (num > 0) {\\n        if (this.dir === \\'East\\') {\\n            if (num - (this.x - this.pos[0]) > 0) {\\n                this.dir = \\'North\\';\\n                num -= this.x - this.pos[0];\\n                this.pos[0] = this.x;\\n            } else {\\n                this.pos[0] += num;\\n                num = 0;\\n            }\\n            continue;\\n        }\\n        if (this.dir === \\'North\\') {\\n            if (num - (this.y - this.pos[1]) > 0) {\\n                this.dir = \\'West\\';\\n                num -= this.y - this.pos[1];\\n                this.pos[1] = this.y;\\n            } else {\\n                this.pos[1] += num;\\n                num = 0;\\n            }\\n            continue;\\n        }\\n        if (this.dir === \\'West\\') {\\n            if (num - this.pos[0] > 0) {\\n                this.dir = \\'South\\';\\n                num -= this.pos[0];\\n                this.pos[0] = 0;\\n            } else {\\n                this.pos[0] = this.pos[0] - num;\\n                num = 0;\\n            }\\n            continue;\\n        }\\n        if (this.dir === \\'South\\') {\\n            if (num - this.pos[1] > 0) {\\n                this.dir = \\'East\\';\\n                num -= this.pos[1];\\n                this.pos[1] = 0;\\n            } else {\\n                this.pos[1] = this.pos[1] - num;\\n                num = 0;\\n            }\\n            continue;\\n        }\\n        \\n    }\\n    \\n};\\n\\n/**\\n * @return {number[]}\\n */\\nRobot.prototype.getPos = function() {\\n    return this.pos;\\n};\\n\\n/**\\n * @return {string}\\n */\\nRobot.prototype.getDir = function() {\\n    return this.dir;\\n};\\n\\n/** \\n * Your Robot object will be instantiated and called as such:\\n * var obj = new Robot(width, height)\\n * obj.move(num)\\n * var param_2 = obj.getPos()\\n * var param_3 = obj.getDir()\\n */ \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1576584,
                "title": "python3-simulation",
                "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/e61879b77928a08bb15cc182a69259d6e2bce59a) for solutions of biweekly 65. \\n```\\nclass Robot:\\n\\n    def __init__(self, width: int, height: int):\\n        self.width = width\\n        self.height = height\\n        self.perimeter = 2*(width+height)-4\\n        self.pos = [0, 0]\\n        self.dir = [1, 0]\\n        \\n    def move(self, num: int) -> None:\\n        num %= self.perimeter\\n        if num == 0 and self.pos == [0, 0] and self.dir == [1, 0]: self.dir = [0, -1]\\n        while num: \\n            if self.dir == [1, 0]: most = self.width - self.pos[0] - 1\\n            elif self.dir == [0, 1]: most = self.height - self.pos[1] - 1\\n            elif self.dir == [-1, 0]: most = self.pos[0]\\n            else: most = self.pos[1]\\n            step = min(num, most)\\n            self.pos = [self.pos[0] + self.dir[0]*step, self.pos[1] + self.dir[1]*step]\\n            if num > most: self.dir = [-self.dir[1], self.dir[0]]\\n            num -= step \\n            \\n    def getPos(self) -> List[int]:\\n        return self.pos\\n\\n    def getDir(self) -> str:\\n        if self.dir == [1, 0]: return \"East\"\\n        elif self.dir == [0, 1]: return \"North\"\\n        elif self.dir == [-1, 0]: return \"West\"\\n        return \"South\"\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Robot:\\n\\n    def __init__(self, width: int, height: int):\\n        self.width = width\\n        self.height = height\\n        self.perimeter = 2*(width+height)-4\\n        self.pos = [0, 0]\\n        self.dir = [1, 0]\\n        \\n    def move(self, num: int) -> None:\\n        num %= self.perimeter\\n        if num == 0 and self.pos == [0, 0] and self.dir == [1, 0]: self.dir = [0, -1]\\n        while num: \\n            if self.dir == [1, 0]: most = self.width - self.pos[0] - 1\\n            elif self.dir == [0, 1]: most = self.height - self.pos[1] - 1\\n            elif self.dir == [-1, 0]: most = self.pos[0]\\n            else: most = self.pos[1]\\n            step = min(num, most)\\n            self.pos = [self.pos[0] + self.dir[0]*step, self.pos[1] + self.dir[1]*step]\\n            if num > most: self.dir = [-self.dir[1], self.dir[0]]\\n            num -= step \\n            \\n    def getPos(self) -> List[int]:\\n        return self.pos\\n\\n    def getDir(self) -> str:\\n        if self.dir == [1, 0]: return \"East\"\\n        elif self.dir == [0, 1]: return \"North\"\\n        elif self.dir == [-1, 0]: return \"West\"\\n        return \"South\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576283,
                "title": "c-simple-implementation-hidden-testcase-solved",
                "content": "Consider the SIMPLE case:\\n[\"Robot\",\"move\", \"getDir\"]\\n[[3, 3], [8], []]\\n\\nCorrect answer is [null,null,\"South\"]\\n\\nBut you will be returning [null,null,\"East\"]\\n\\nReason:\\nYou would have done num = num % circumference; where, circumference = 2*width + 2*height -4\\nwhich is 0 after 8 moves in this case but the direction faced by robot will be \"SOUTH\" not \"EAST\". You should update this!\\n\\n\\n```\\nclass Robot {\\n    int x;\\n    int y;\\n    string dir;\\n    int width;\\n    int height;\\npublic:\\n    Robot(int w, int h) {\\n        x = 0;\\n        y = 0;\\n        dir = \"East\";\\n        width = w;\\n        height = h;\\n    }\\n    \\n    void move(int num) {\\n        num = num%(2*width + 2*height - 4);\\n        int x1 = x;\\n        int y1 = y;\\n        string dir1 = dir;\\n        while(num > 0){\\n            if(dir1 == \"East\"){\\n                int new_x1 = min(x1+num,width-1);\\n                if((x1+num) >= width){\\n                    dir1 = \"North\";\\n                }\\n                num -= (new_x1 - x1);\\n                x1 = new_x1;\\n            }\\n            else if(dir1 == \"North\"){\\n                int new_y1 = min(y1+num, height-1);\\n                if((y1+num) >= height){\\n                    dir1 = \"West\";\\n                }\\n                num -= (new_y1 - y1);\\n                y1 = new_y1;\\n                \\n            }\\n            else if(dir1 == \"West\"){\\n                int new_x1 = max(x1-num, 0);\\n                if((x1-num) < 0){\\n                    dir1 = \"South\";\\n                }\\n                num -= abs(x1 - new_x1);\\n                x1 = new_x1;\\n            }\\n            else if(dir1 == \"South\"){\\n                int new_y1 = max(y1-num, 0);\\n                if((y1-num) < 0){\\n                    dir1 = \"East\";\\n                }\\n                num -= abs(y1 - new_y1);\\n                y1 = new_y1;\\n            }\\n            \\n        }\\n        \\n        x = x1;\\n        y = y1;\\n        \\n        if (x == 0 && y == 0) {\\n            dir1 = \"South\";\\n        }\\n        \\n        dir = dir1;\\n    }\\n    \\n    vector<int> getPos() {\\n        return vector<int>({x,y});\\n    }\\n    \\n    string getDir() {\\n        return dir;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Robot {\\n    int x;\\n    int y;\\n    string dir;\\n    int width;\\n    int height;\\npublic:\\n    Robot(int w, int h) {\\n        x = 0;\\n        y = 0;\\n        dir = \"East\";\\n        width = w;\\n        height = h;\\n    }\\n    \\n    void move(int num) {\\n        num = num%(2*width + 2*height - 4);\\n        int x1 = x;\\n        int y1 = y;\\n        string dir1 = dir;\\n        while(num > 0){\\n            if(dir1 == \"East\"){\\n                int new_x1 = min(x1+num,width-1);\\n                if((x1+num) >= width){\\n                    dir1 = \"North\";\\n                }\\n                num -= (new_x1 - x1);\\n                x1 = new_x1;\\n            }\\n            else if(dir1 == \"North\"){\\n                int new_y1 = min(y1+num, height-1);\\n                if((y1+num) >= height){\\n                    dir1 = \"West\";\\n                }\\n                num -= (new_y1 - y1);\\n                y1 = new_y1;\\n                \\n            }\\n            else if(dir1 == \"West\"){\\n                int new_x1 = max(x1-num, 0);\\n                if((x1-num) < 0){\\n                    dir1 = \"South\";\\n                }\\n                num -= abs(x1 - new_x1);\\n                x1 = new_x1;\\n            }\\n            else if(dir1 == \"South\"){\\n                int new_y1 = max(y1-num, 0);\\n                if((y1-num) < 0){\\n                    dir1 = \"East\";\\n                }\\n                num -= abs(y1 - new_y1);\\n                y1 = new_y1;\\n            }\\n            \\n        }\\n        \\n        x = x1;\\n        y = y1;\\n        \\n        if (x == 0 && y == 0) {\\n            dir1 = \"South\";\\n        }\\n        \\n        dir = dir1;\\n    }\\n    \\n    vector<int> getPos() {\\n        return vector<int>({x,y});\\n    }\\n    \\n    string getDir() {\\n        return dir;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576140,
                "title": "javascript-direct-way-300ms",
                "content": "```\\nfunction Robot(row, col) {\\n    let round = 2 * (row + col) - 4;\\n    let d = \\'E\\', x = 0, y = 0, first = true;\\n    return { move, getPos, getDir }\\n    function move(step) {\\n        step %= round;\\n\\t\\t// solve this issue from here https://leetcode.com/problems/walking-robot-simulation-ii/discuss/1575896/Hidden-Test-Case-REVEALED!\\n        if(first && step == 0){ // get stuck in hidden case 140, start (0, 0) face East, round >= 1 to (0, 0) face \"South\"\\n            if(x == 0 && y == 0) d = \\'S\\';\\n            first = false;\\n            return;\\n        }\\n        while (step--) {\\n            if (d == \\'E\\') {\\n                if (x + 1 < row) {\\n                    x++;\\n                } else {\\n                    y++;\\n                    turn();\\n                }\\n            } else if (d == \\'N\\') {\\n                if (y + 1 < col) {\\n                    y++;\\n                } else {\\n                    x--;\\n                    turn();\\n                }\\n            } else if (d == \\'W\\') {\\n                if (x - 1 >= 0) {\\n                    x--;\\n                } else {\\n                    y--;\\n                    turn();\\n                }\\n            } else if (d == \\'S\\') {\\n                if (y - 1 >= 0) {\\n                    y--\\n                } else {\\n                    x++;\\n                    turn();\\n                }\\n            }\\n        }\\n    }\\n    function getPos() {\\n        return [x, y];\\n    }\\n    function getDir() {\\n        if (d == \\'E\\') {\\n            return \\'East\\';\\n        } else if (d == \\'N\\') {\\n            return \\'North\\';\\n        } else if (d == \\'W\\') {\\n            return \\'West\\';\\n        } else if (d == \\'S\\') {\\n            return \\'South\\';\\n        }\\n    }\\n    function turn() {\\n        if (d == \\'E\\') {\\n            d = \\'N\\';\\n        } else if (d == \\'N\\') {\\n            d = \\'W\\';\\n        } else if (d == \\'W\\') {\\n            d = \\'S\\';\\n        } else if (d == \\'S\\') {\\n            d = \\'E\\';\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction Robot(row, col) {\\n    let round = 2 * (row + col) - 4;\\n    let d = \\'E\\', x = 0, y = 0, first = true;\\n    return { move, getPos, getDir }\\n    function move(step) {\\n        step %= round;\\n\\t\\t// solve this issue from here https://leetcode.com/problems/walking-robot-simulation-ii/discuss/1575896/Hidden-Test-Case-REVEALED!\\n        if(first && step == 0){ // get stuck in hidden case 140, start (0, 0) face East, round >= 1 to (0, 0) face \"South\"\\n            if(x == 0 && y == 0) d = \\'S\\';\\n            first = false;\\n            return;\\n        }\\n        while (step--) {\\n            if (d == \\'E\\') {\\n                if (x + 1 < row) {\\n                    x++;\\n                } else {\\n                    y++;\\n                    turn();\\n                }\\n            } else if (d == \\'N\\') {\\n                if (y + 1 < col) {\\n                    y++;\\n                } else {\\n                    x--;\\n                    turn();\\n                }\\n            } else if (d == \\'W\\') {\\n                if (x - 1 >= 0) {\\n                    x--;\\n                } else {\\n                    y--;\\n                    turn();\\n                }\\n            } else if (d == \\'S\\') {\\n                if (y - 1 >= 0) {\\n                    y--\\n                } else {\\n                    x++;\\n                    turn();\\n                }\\n            }\\n        }\\n    }\\n    function getPos() {\\n        return [x, y];\\n    }\\n    function getDir() {\\n        if (d == \\'E\\') {\\n            return \\'East\\';\\n        } else if (d == \\'N\\') {\\n            return \\'North\\';\\n        } else if (d == \\'W\\') {\\n            return \\'West\\';\\n        } else if (d == \\'S\\') {\\n            return \\'South\\';\\n        }\\n    }\\n    function turn() {\\n        if (d == \\'E\\') {\\n            d = \\'N\\';\\n        } else if (d == \\'N\\') {\\n            d = \\'W\\';\\n        } else if (d == \\'W\\') {\\n            d = \\'S\\';\\n        } else if (d == \\'S\\') {\\n            d = \\'E\\';\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1576098,
                "title": "c-build-linear-array",
                "content": "Build an array with the perimeter.\\nCorner case - Whenever cur=0, for first time, we will face east, from next iteration, we point south (for this reason flag is used)\\n```\\nclass Robot {\\npublic:\\n    int h,w,cur;\\n    vector<pair<int,int>> v;\\n    int flag=0;\\n    Robot(int width, int height) {\\n        h=height;\\n        w=width;\\n        cur=0;\\n        v.clear();\\n        for(int i=0;i<w;i++) v.push_back({i,0});\\n        for(int j=1;j<h;j++) v.push_back({w-1,j});\\n        for(int i=w-2;i>=0;i--) v.push_back({i,h-1});\\n        for(int j=h-2;j>0;j--) v.push_back({0,j});\\n    }\\n    \\n    void move(int num) {\\n        flag=1;\\n        cur=(cur+num)%v.size();\\n    }\\n    \\n    vector<int> getPos() {\\n        return vector<int>{v[cur].first,v[cur].second};\\n    }\\n    \\n    string getDir() {\\n        int n1=h+w-2, n2=n1+w-1;\\n        if(cur>=flag && cur<=w-1) return \"East\";\\n        if(cur>=w && cur<=n1) return \"North\";\\n        if(cur>n1 && cur<=n2) return \"West\";\\n        return \"South\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Robot {\\npublic:\\n    int h,w,cur;\\n    vector<pair<int,int>> v;\\n    int flag=0;\\n    Robot(int width, int height) {\\n        h=height;\\n        w=width;\\n        cur=0;\\n        v.clear();\\n        for(int i=0;i<w;i++) v.push_back({i,0});\\n        for(int j=1;j<h;j++) v.push_back({w-1,j});\\n        for(int i=w-2;i>=0;i--) v.push_back({i,h-1});\\n        for(int j=h-2;j>0;j--) v.push_back({0,j});\\n    }\\n    \\n    void move(int num) {\\n        flag=1;\\n        cur=(cur+num)%v.size();\\n    }\\n    \\n    vector<int> getPos() {\\n        return vector<int>{v[cur].first,v[cur].second};\\n    }\\n    \\n    string getDir() {\\n        int n1=h+w-2, n2=n1+w-1;\\n        if(cur>=flag && cur<=w-1) return \"East\";\\n        if(cur>=w && cur<=n1) return \"North\";\\n        if(cur>n1 && cur<=n2) return \"West\";\\n        return \"South\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576046,
                "title": "c-math-based-short-solution",
                "content": "Just need to handle the case where getDir is called when position is back to (0, 0). \\n```\\nclass Robot {\\npublic:\\n    int H, W, pos, moves;\\n    bool started;\\n    Robot(int width, int height) {\\n        H = height;\\n        W = width;\\n        pos = 0;\\n        started = 0;\\n        moves = (W + H - 2) << 1;\\n    }\\n    \\n    // total number of moves can be 2 * (width + height - 2)\\n    void move(int num) {\\n        pos = (pos + num) % moves;\\n        started = 1;\\n    }\\n    \\n    vector<int> getPos() {\\n        if (pos < W)\\n            return {pos, 0};\\n        else if (pos < W + H - 1)\\n            return {W-1, pos - W + 1};\\n        else if (pos < (W<<1) + H - 2)\\n            return {(W<<1) + H - pos - 3, H-1};    // {W - (moves - (W + H)), H-1}\\n        else\\n            return {0, moves - pos};\\n    }\\n    \\n    string getDir() {\\n        if (pos < W)\\n            return (started && !pos ? \"South\" : \"East\");\\n        else if (pos < W + H - 1)\\n            return \"North\";\\n        else if (pos < (W<<1) + H - 2)\\n            return \"West\";    // {W - (moves - (W + H)), H-1}\\n        else\\n            return \"South\";\\n    }\\n};\\n``",
                "solutionTags": [],
                "code": "Just need to handle the case where getDir is called when position is back to (0, 0). \\n```\\nclass Robot {\\npublic:\\n    int H, W, pos, moves;\\n    bool started;\\n    Robot(int width, int height) {\\n        H = height;\\n        W = width;\\n        pos = 0;\\n        started = 0;\\n        moves = (W + H - 2) << 1;\\n    }\\n    \\n    // total number of moves can be 2 * (width + height - 2)\\n    void move(int num) {\\n        pos = (pos + num) % moves;\\n        started = 1;\\n    }\\n    \\n    vector<int> getPos() {\\n        if (pos < W)\\n            return {pos, 0};\\n        else if (pos < W + H - 1)\\n            return {W-1, pos - W + 1};\\n        else if (pos < (W<<1) + H - 2)\\n            return {(W<<1) + H - pos - 3, H-1};    // {W - (moves - (W + H)), H-1}\\n        else\\n            return {0, moves - pos};\\n    }\\n    \\n    string getDir() {\\n        if (pos < W)\\n            return (started && !pos ? \"South\" : \"East\");\\n        else if (pos < W + H - 1)\\n            return \"North\";\\n        else if (pos < (W<<1) + H - 2)\\n            return \"West\";    // {W - (moves - (W + H)), H-1}\\n        else\\n            return \"South\";\\n    }\\n};\\n``",
                "codeTag": "Java"
            },
            {
                "id": 1575962,
                "title": "c-very-easy-solution",
                "content": "```\\nlass Robot {\\npublic:\\n    int grid[101][101];\\n    int height,width;\\n    bool check = 1;\\n    int dir;\\n    int x,y;\\n    vector<int> vect;\\n    Robot(int width1, int height1) \\n    {\\n        height = height1-1;\\n        width = width1-1;\\n        x = 0, y = 0;\\n        dir = 0;\\n    }\\n    void move(int num) \\n    {\\n        int round = (height)*2 + (width*2);\\n        int temp = num/round;\\n        num-=(temp*round);\\n        if(temp>0)\\n        {\\n            if(check) dir = 3;\\n        }\\n        check = 0;\\n        while(num>0)\\n        {\\n            int x1 = x,y1 = y;\\n            if(dir==0) x1 = width;\\n            if(dir==1) y1 = height;\\n            if(dir==2) x1 = 0;\\n            if(dir==3) y1 = 0;\\n            int possible = abs(x-x1) + abs(y-y1);\\n            if(possible==0)\\n            {\\n                dir++;\\n                dir = dir%4;\\n                continue;\\n            }\\n            int a1 = min(possible, num);\\n            num-=a1;\\n            possible-=a1;\\n            if(dir==0) x+=a1;\\n            if(dir==1) y+=a1;\\n            if(dir==2) x-=a1;\\n            if(dir==3) y-=a1;\\n        }\\n    }\\n    vector<int> getPos() \\n    {\\n        vect.clear();\\n        vect.push_back(x);\\n        vect.push_back(y);\\n        return vect;\\n    }\\n    string getDir() \\n    {\\n        if(dir==1) return \"North\";\\n        if(dir==3) return \"South\";\\n        if(dir==0) return \"East\";\\n        return \"West\";\\n    }\\n};\\n```\\n**Suggestions are welcomed.**\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nlass Robot {\\npublic:\\n    int grid[101][101];\\n    int height,width;\\n    bool check = 1;\\n    int dir;\\n    int x,y;\\n    vector<int> vect;\\n    Robot(int width1, int height1) \\n    {\\n        height = height1-1;\\n        width = width1-1;\\n        x = 0, y = 0;\\n        dir = 0;\\n    }\\n    void move(int num) \\n    {\\n        int round = (height)*2 + (width*2);\\n        int temp = num/round;\\n        num-=(temp*round);\\n        if(temp>0)\\n        {\\n            if(check) dir = 3;\\n        }\\n        check = 0;\\n        while(num>0)\\n        {\\n            int x1 = x,y1 = y;\\n            if(dir==0) x1 = width;\\n            if(dir==1) y1 = height;\\n            if(dir==2) x1 = 0;\\n            if(dir==3) y1 = 0;\\n            int possible = abs(x-x1) + abs(y-y1);\\n            if(possible==0)\\n            {\\n                dir++;\\n                dir = dir%4;\\n                continue;\\n            }\\n            int a1 = min(possible, num);\\n            num-=a1;\\n            possible-=a1;\\n            if(dir==0) x+=a1;\\n            if(dir==1) y+=a1;\\n            if(dir==2) x-=a1;\\n            if(dir==3) y-=a1;\\n        }\\n    }\\n    vector<int> getPos() \\n    {\\n        vect.clear();\\n        vect.push_back(x);\\n        vect.push_back(y);\\n        return vect;\\n    }\\n    string getDir() \\n    {\\n        if(dir==1) return \"North\";\\n        if(dir==3) return \"South\";\\n        if(dir==0) return \"East\";\\n        return \"West\";\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1575941,
                "title": "c-clear-and-easy-to-understand-solution",
                "content": "```cpp\\nclass Robot {\\npublic:\\n    int grid[101][101];\\n    int height,width;\\n    bool check = 1;\\n    int dir;\\n    int x,y;\\n    vector<int> vect;\\n    Robot(int width1, int height1) \\n    {\\n        height = height1-1;\\n        width = width1-1;\\n        x = 0, y = 0;\\n        dir = 0;\\n    }\\n    void move(int num) \\n    {\\n        int round = (height)*2 + (width*2);\\n        int temp = num/round;\\n        num-=(temp*round);\\n        if(temp>0)\\n        {\\n            if(check) dir = 3;\\n        }\\n        check = 0;\\n        while(num>0)\\n        {\\n            int x1 = x,y1 = y;\\n            if(dir==0) x1 = width;\\n            if(dir==1) y1 = height;\\n            if(dir==2) x1 = 0;\\n            if(dir==3) y1 = 0;\\n            int possible = abs(x-x1) + abs(y-y1);\\n            if(possible==0)\\n            {\\n                dir++;\\n                dir = dir%4;\\n                continue;\\n            }\\n            int a1 = min(possible, num);\\n            num-=a1;\\n            possible-=a1;\\n            if(dir==0) x+=a1;\\n            if(dir==1) y+=a1;\\n            if(dir==2) x-=a1;\\n            if(dir==3) y-=a1;\\n        }\\n    }\\n    vector<int> getPos() \\n    {\\n        vect.clear();\\n        vect.push_back(x);\\n        vect.push_back(y);\\n        return vect;\\n    }\\n    string getDir() \\n    {\\n        if(dir==1) return \"North\";\\n        if(dir==3) return \"South\";\\n        if(dir==0) return \"East\";\\n        return \"West\";\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Robot {\\npublic:\\n    int grid[101][101];\\n    int height,width;\\n    bool check = 1;\\n    int dir;\\n    int x,y;\\n    vector<int> vect;\\n    Robot(int width1, int height1) \\n    {\\n        height = height1-1;\\n        width = width1-1;\\n        x = 0, y = 0;\\n        dir = 0;\\n    }\\n    void move(int num) \\n    {\\n        int round = (height)*2 + (width*2);\\n        int temp = num/round;\\n        num-=(temp*round);\\n        if(temp>0)\\n        {\\n            if(check) dir = 3;\\n        }\\n        check = 0;\\n        while(num>0)\\n        {\\n            int x1 = x,y1 = y;\\n            if(dir==0) x1 = width;\\n            if(dir==1) y1 = height;\\n            if(dir==2) x1 = 0;\\n            if(dir==3) y1 = 0;\\n            int possible = abs(x-x1) + abs(y-y1);\\n            if(possible==0)\\n            {\\n                dir++;\\n                dir = dir%4;\\n                continue;\\n            }\\n            int a1 = min(possible, num);\\n            num-=a1;\\n            possible-=a1;\\n            if(dir==0) x+=a1;\\n            if(dir==1) y+=a1;\\n            if(dir==2) x-=a1;\\n            if(dir==3) y-=a1;\\n        }\\n    }\\n    vector<int> getPos() \\n    {\\n        vect.clear();\\n        vect.push_back(x);\\n        vect.push_back(y);\\n        return vect;\\n    }\\n    string getDir() \\n    {\\n        if(dir==1) return \"North\";\\n        if(dir==3) return \"South\";\\n        if(dir==0) return \"East\";\\n        return \"West\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1575938,
                "title": "what-is-wrong-with-this",
                "content": "class Robot {\\n\\n    int i=0,j=1;\\n    int x=0,y=0;\\n    int n,m;\\n    public Robot(int width, int height) {\\n        n=width;\\n        m=height;\\n    }\\n    \\n    public void move(int num) {\\n        long temp=(n-1)*2 + (m-1)*2;\\n        if(temp<num){\\n            num=num%((int)temp);\\n        }\\n        // num=num%temp;\\n        while(num-->0){\\n            \\n           if(x+j==n){\\n                i=1;\\n               j=0;\\n            }\\n            if(x+j==-1){\\n                i=-1;\\n                j=0;\\n            }\\n            if(y+i==m){\\n                i=0;\\n                j=-1;\\n            }\\n            if(y+i==-1){\\n                i=0;\\n                j=1;\\n            }\\n        \\n            x=x+j;\\n            y=y+i;\\n            \\n        }\\n        // System.out.println(x+\" \"+y);\\n    }\\n    \\n    public int[] getPos() {\\n        return new int[]{x,y};\\n    }\\n    \\n    public String getDir() {\\n        if(i==0 && j==1){\\n            return \"East\";\\n        }\\n        else if(i==0 && j==-1){\\n            return \"West\";\\n        }\\n        else if(i==1 && j==0){\\n            return \"North\";\\n        }\\n        else{\\n            return \"South\";\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Robot {\\n\\n    int i=0,j=1;\\n    int x=0,y=0;\\n    int n,m;\\n    public Robot(int width, int height) {\\n        n=width;\\n        m=height;\\n    }\\n    \\n    public void move(int num) {\\n        long temp=(n-1)*2 + (m-1)*2;\\n        if(temp<num){\\n            num=num%((int)temp);\\n        }\\n        // num=num%temp;\\n        while(num-->0){\\n            \\n           if(x+j==n){\\n                i=1;\\n               j=0;\\n            }\\n            if(x+j==-1){\\n                i=-1;\\n                j=0;\\n            }\\n            if(y+i==m){\\n                i=0;\\n                j=-1;\\n            }\\n            if(y+i==-1){\\n                i=0;\\n                j=1;\\n            }\\n        \\n            x=x+j;\\n            y=y+i;\\n            \\n        }\\n        // System.out.println(x+\" \"+y);\\n    }\\n    \\n    public int[] getPos() {\\n        return new int[]{x,y};\\n    }\\n    \\n    public String getDir() {\\n        if(i==0 && j==1){\\n            return \"East\";\\n        }\\n        else if(i==0 && j==-1){\\n            return \"West\";\\n        }\\n        else if(i==1 && j==0){\\n            return \"North\";\\n        }\\n        else{\\n            return \"South\";\\n        }\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 4049544,
                "title": "o-1-javascript-typescript-solution",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Robot {\\n  private moved = false;\\n  private position = 0;\\n\\n  constructor(private width: number, private height: number) {}\\n\\n  step(num: number): void {\\n    this.moved = true;\\n    this.position += num;\\n    this.position %= this.width * 2 + this.height * 2 - 4;\\n  }\\n\\n  getPos(): number[] {\\n    const { position, width, height } = this;\\n    if (position < width) return [position, 0];\\n    if (position < width + height - 1) return [width - 1, position - width + 1];\\n    if (position < width * 2 + height - 2)\\n      return [width * 2 + height - 3 - position, height - 1];\\n    return [0, width * 2 + height * 2 - 4 - position];\\n  }\\n\\n  getDir(): string {\\n    const { moved, position, width, height } = this;\\n    if (!moved) return \"East\";\\n    if (position === 0) return \"South\";\\n    if (position < width) return \"East\";\\n    if (position < width + height - 1) return \"North\";\\n    if (position < width * 2 + height - 2) return \"West\";\\n    return \"South\";\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nclass Robot {\\n  private moved = false;\\n  private position = 0;\\n\\n  constructor(private width: number, private height: number) {}\\n\\n  step(num: number): void {\\n    this.moved = true;\\n    this.position += num;\\n    this.position %= this.width * 2 + this.height * 2 - 4;\\n  }\\n\\n  getPos(): number[] {\\n    const { position, width, height } = this;\\n    if (position < width) return [position, 0];\\n    if (position < width + height - 1) return [width - 1, position - width + 1];\\n    if (position < width * 2 + height - 2)\\n      return [width * 2 + height - 3 - position, height - 1];\\n    return [0, width * 2 + height * 2 - 4 - position];\\n  }\\n\\n  getDir(): string {\\n    const { moved, position, width, height } = this;\\n    if (!moved) return \"East\";\\n    if (position === 0) return \"South\";\\n    if (position < width) return \"East\";\\n    if (position < width + height - 1) return \"North\";\\n    if (position < width * 2 + height - 2) return \"West\";\\n    return \"South\";\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3926137,
                "title": "c-python-solution-with-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/1f8ef671-41a1-48b2-ac08-4cbb3bc1b8d4_1692349595.8413227.png)\\ndx and dy record moving directions. east is 1, 0, weat is -1, 0, vise versa.\\nif turining right, dx, dy = -dy, dx.\\nuse a variable to record how many time we turining right to print direction\\nforward(step) is the robot walks straight forward until it reaches the wall, and returns how many steps it has not walked.\\n\\ntc of step is O(6), getPos and  getDir are O(1), sc is O(1).\\n\\n### python\\n\\n```python\\nmapping = [\"East\", \"North\", \"West\", \"South\"]\\nclass Robot:\\n\\n    def __init__(self, width: int, height: int):\\n        self.width = width\\n        self.height = height\\n        self.dir = 0\\n        self.x = self.y = 0\\n        self.dx = 1\\n        self.dy = 0\\n    \\n    def step(self, num: int) -> None:\\n        while num:\\n            num = self.forward(num)\\n    \\n    def forward(self, step):\\n        self.x += step * self.dx\\n        self.y += step * self.dy\\n        if self.x >= self.width or self.x < 0:\\n            diff = (self.x - self.width + 1 if self.x >= self.width else -self.x) % ((self.width + self.height - 2) * 2)\\n            self.x = self.width - 1 if self.x >= self.width else 0\\n            if diff:\\n                self.dx, self.dy = -self.dy, self.dx\\n                self.dir = (self.dir + 1) % 4\\n            return diff\\n        \\n        elif self.y >= self.height or self.y < 0:\\n            diff = (self.y - self.height + 1 if self.y >= self.height else -self.y) % ((self.width + self.height - 2) * 2)\\n            self.y = self.height - 1 if self.y >= self.height else 0\\n            if diff:\\n                self.dx, self.dy = -self.dy, self.dx\\n                self.dir = (self.dir + 1) % 4\\n            return diff\\n        return 0\\n        \\n    def getPos(self) -> List[int]:\\n        return [self.x, self.y]\\n\\n    def getDir(self) -> str:\\n        return mapping[self.dir]\\n```\\n\\n### c++\\n```cpp\\nconst string mapping[] = {\"East\", \"North\", \"West\", \"South\"};\\nclass Robot {\\npublic:\\n    int dx, dy, x, y, dir, width, height;\\n    Robot(int width, int height): dx(1), dy(0), x(0), y(0), dir(0), width(width), height(height) {}\\n    \\n    void step(int num) {\\n        while (num) num = this -> forward(num);\\n    }\\n    \\n    int forward(int step) {\\n        this -> x += step * dx;\\n        this -> y += step * dy;\\n        if (this -> x >= this -> width || this -> x < 0) {\\n            int diff = (this -> x >= this -> width ? this -> x - this -> width + 1: -this -> x) % ((this -> width + this -> height - 2) * 2);\\n            this -> x = this -> x >= this -> width? this -> width - 1: 0;\\n            if (diff) {\\n                swap(this -> dx, this -> dy);\\n                this -> dx *= -1;\\n                this -> dir = (this -> dir + 1) % 4;\\n            }\\n            return diff;\\n        } else if (this -> y >= this -> height || this -> y < 0) {\\n            int diff = (this -> y >= this -> height ? this -> y - this -> height + 1: -this -> y) % ((this -> width + this -> height - 2) * 2);\\n            this -> y = this -> y >= this -> height? this -> height - 1: 0;\\n            if (diff) {\\n                swap(this -> dx, this -> dy);\\n                this -> dx *= -1;\\n                this -> dir = (this -> dir + 1) % 4;\\n            }\\n            return diff;\\n        }\\n        return 0;\\n    }\\n    vector<int> getPos() {\\n        return {this -> x, this -> y};\\n    }\\n    \\n    string getDir() {\\n        return mapping[this -> dir];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```python\\nmapping = [\"East\", \"North\", \"West\", \"South\"]\\nclass Robot:\\n\\n    def __init__(self, width: int, height: int):\\n        self.width = width\\n        self.height = height\\n        self.dir = 0\\n        self.x = self.y = 0\\n        self.dx = 1\\n        self.dy = 0\\n    \\n    def step(self, num: int) -> None:\\n        while num:\\n            num = self.forward(num)\\n    \\n    def forward(self, step):\\n        self.x += step * self.dx\\n        self.y += step * self.dy\\n        if self.x >= self.width or self.x < 0:\\n            diff = (self.x - self.width + 1 if self.x >= self.width else -self.x) % ((self.width + self.height - 2) * 2)\\n            self.x = self.width - 1 if self.x >= self.width else 0\\n            if diff:\\n                self.dx, self.dy = -self.dy, self.dx\\n                self.dir = (self.dir + 1) % 4\\n            return diff\\n        \\n        elif self.y >= self.height or self.y < 0:\\n            diff = (self.y - self.height + 1 if self.y >= self.height else -self.y) % ((self.width + self.height - 2) * 2)\\n            self.y = self.height - 1 if self.y >= self.height else 0\\n            if diff:\\n                self.dx, self.dy = -self.dy, self.dx\\n                self.dir = (self.dir + 1) % 4\\n            return diff\\n        return 0\\n        \\n    def getPos(self) -> List[int]:\\n        return [self.x, self.y]\\n\\n    def getDir(self) -> str:\\n        return mapping[self.dir]\\n```\n```cpp\\nconst string mapping[] = {\"East\", \"North\", \"West\", \"South\"};\\nclass Robot {\\npublic:\\n    int dx, dy, x, y, dir, width, height;\\n    Robot(int width, int height): dx(1), dy(0), x(0), y(0), dir(0), width(width), height(height) {}\\n    \\n    void step(int num) {\\n        while (num) num = this -> forward(num);\\n    }\\n    \\n    int forward(int step) {\\n        this -> x += step * dx;\\n        this -> y += step * dy;\\n        if (this -> x >= this -> width || this -> x < 0) {\\n            int diff = (this -> x >= this -> width ? this -> x - this -> width + 1: -this -> x) % ((this -> width + this -> height - 2) * 2);\\n            this -> x = this -> x >= this -> width? this -> width - 1: 0;\\n            if (diff) {\\n                swap(this -> dx, this -> dy);\\n                this -> dx *= -1;\\n                this -> dir = (this -> dir + 1) % 4;\\n            }\\n            return diff;\\n        } else if (this -> y >= this -> height || this -> y < 0) {\\n            int diff = (this -> y >= this -> height ? this -> y - this -> height + 1: -this -> y) % ((this -> width + this -> height - 2) * 2);\\n            this -> y = this -> y >= this -> height? this -> height - 1: 0;\\n            if (diff) {\\n                swap(this -> dx, this -> dy);\\n                this -> dx *= -1;\\n                this -> dir = (this -> dir + 1) % 4;\\n            }\\n            return diff;\\n        }\\n        return 0;\\n    }\\n    vector<int> getPos() {\\n        return {this -> x, this -> y};\\n    }\\n    \\n    string getDir() {\\n        return mapping[this -> dir];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889641,
                "title": "o-1-easy-solution",
                "content": "# Approach\\nI represent the outer edge of the grid as a continuous circular array and store the position of the robot on that array as the index.\\n\\n\\n# Complexity\\n- Time complexity:\\n\\nAll functions are $$O(1)$$\\n\\n- Space complexity:\\n\\nAll functions are $$O(1)$$\\n\\n# Code\\n```\\nclass Robot:\\n\\n    def __init__(self, width: int, height: int):\\n        self.pos = 0\\n        self.dir = 0\\n        self.dirs = {0: \"East\", 1: \"North\", 2: \"West\", 3: \"South\"}\\n        self.width = width - 1\\n        self.height = height - 1\\n        self.mid = height + width - 2\\n\\n    def step(self, num: int) -> None:\\n        self.pos += num\\n        self.pos %= (self.mid * 2)\\n        if self.pos > self.mid + self.width:\\n            self.dir = 3\\n        elif self.pos > self.mid:\\n            self.dir = 2\\n        elif self.pos > self.width:\\n            self.dir = 1\\n        elif not self.pos:\\n            self.dir = 3\\n        else:\\n            self.dir = 0\\n\\n    def getPos(self) -> List[int]:\\n        if self.pos > self.mid + self.width:\\n            return [0,self.height - (self.pos - self.mid - self.width)]\\n        elif self.pos > self.mid:\\n            return [self.width - (self.pos - self.mid) ,self.height]\\n        elif self.pos > self.width:\\n            return [self.width, self.pos - self.width ]\\n        else:\\n            return [self.pos,0]\\n\\n    def getDir(self) -> str:\\n        return self.dirs[self.dir]\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Robot:\\n\\n    def __init__(self, width: int, height: int):\\n        self.pos = 0\\n        self.dir = 0\\n        self.dirs = {0: \"East\", 1: \"North\", 2: \"West\", 3: \"South\"}\\n        self.width = width - 1\\n        self.height = height - 1\\n        self.mid = height + width - 2\\n\\n    def step(self, num: int) -> None:\\n        self.pos += num\\n        self.pos %= (self.mid * 2)\\n        if self.pos > self.mid + self.width:\\n            self.dir = 3\\n        elif self.pos > self.mid:\\n            self.dir = 2\\n        elif self.pos > self.width:\\n            self.dir = 1\\n        elif not self.pos:\\n            self.dir = 3\\n        else:\\n            self.dir = 0\\n\\n    def getPos(self) -> List[int]:\\n        if self.pos > self.mid + self.width:\\n            return [0,self.height - (self.pos - self.mid - self.width)]\\n        elif self.pos > self.mid:\\n            return [self.width - (self.pos - self.mid) ,self.height]\\n        elif self.pos > self.width:\\n            return [self.width, self.pos - self.width ]\\n        else:\\n            return [self.pos,0]\\n\\n    def getDir(self) -> str:\\n        return self.dirs[self.dir]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873144,
                "title": "java-59ms-beats-93-and-clean-code",
                "content": "# Approach\\n1. As an overall idea, the robot will keep track of its position[]{x,y} and its current orientation: (0,1,2,3 - East, North, West, South).\\n2. The robot can only walk on the edges of the imaginary grid, thus we only need to know x/y\\n3. The robot can be given a high number of steps to walk, but, if those steps > perimeter of grid, the robot will only walk in circles. \\nThus, a full walk cycle = 2 * width + 2 * (height -1).\\nThe real number of steps = steps % fullCycle.\\nIf steps == 0 (x full cycles), the robot actually stays in place (does x circles arriving on same pot)\\n4. Edge case: if x full cycle are given from the first time, the robot should make full cycles, arriving at 0,0, with orientation S. However, as we skip full cicles, the robot will be fixed pointing East, although it needs to point south.\\n    - Ths, this needs to be fixed with a set direction that will make robot point south if at 0,0\\n5. In a while loop,\\n    - orientate robot to correct walking direction. EG: if robot @ [5,0], the robot should steer to north as it can only walk there.\\n    - after steering, determine possibleSteps it can make (until it reaches the edge or the given number of totalSteps)\\n    - deduct the possibleSteps from totalnumber of steps\\n    - stop when total number of steps becomes 0. \\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$ stack-calls-of-method-vars\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Robot {\\n    private final int width, height;\\n    private final int[] position;\\n    private final String[] orientation = {\"East\", \"North\", \"West\", \"South\"};\\n    private int currentOrientation = 0;\\n    private int fullCycle;\\n    public Robot(int width, int height) {\\n        this.width = width;\\n        this.height = height;\\n        fullCycle = 2 * width + 2 * (height - 2);\\n        position = new int[]{0, 0};\\n    }\\n    \\n    public void step(int num) {\\n        num = num % fullCycle;\\n        while(num > 0) {\\n            orientateRobot();\\n            num -= moveRobot(num);\\n        }\\n        setDirection();\\n    }\\n    \\n    public int[] getPos() {\\n        return position;\\n    }\\n    \\n    public String getDir() {\\n        return orientation[currentOrientation];\\n    }\\n\\n    private int moveRobot(int steps) {\\n        int possibleSteps = currentOrientation % 2 == 0 \\n            ? currentOrientation == 0 ? (width -1 - position[0]) : position[0]\\n            : currentOrientation == 1 ? (height -1 - position[1]) : position[1];\\n        walkSteps(Math.min(possibleSteps, steps));\\n        return Math.min(possibleSteps, steps);\\n    }\\n\\n    private void walkSteps(int steps) {\\n        if (currentOrientation % 2 == 0) {\\n            position[0] = currentOrientation == 0 ? position[0] + steps : position[0] - steps;\\n        } else {\\n            position[1] = currentOrientation == 1 ? position[1] + steps : position[1] - steps;\\n        }\\n    }\\n\\n    private void setDirection() {\\n        if (position[1] == 0) { \\n            currentOrientation = position[0] == 0 ? 3 : 0;\\n        } else if (position[1] == height - 1) {\\n            currentOrientation = position[0] == width -1 ? 1 : 2;\\n        } else {\\n            currentOrientation = position[0] == 0 ? 3 : 1;\\n        }\\n    }\\n\\n    private void orientateRobot() {\\n        if (currentOrientation == 0) {\\n            currentOrientation = position[0] == width -1 ? 1 : 0;\\n        } else if (currentOrientation == 1) {\\n            currentOrientation = position[1] == height -1 ? 2 : 1;\\n        } else if (currentOrientation == 2) {\\n            currentOrientation =  position[0] == 0 ? 3 : 2;\\n        } else {\\n            currentOrientation = position[1] == 0 ? 0 : 3;          \\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Simulation"
                ],
                "code": "```\\nclass Robot {\\n    private final int width, height;\\n    private final int[] position;\\n    private final String[] orientation = {\"East\", \"North\", \"West\", \"South\"};\\n    private int currentOrientation = 0;\\n    private int fullCycle;\\n    public Robot(int width, int height) {\\n        this.width = width;\\n        this.height = height;\\n        fullCycle = 2 * width + 2 * (height - 2);\\n        position = new int[]{0, 0};\\n    }\\n    \\n    public void step(int num) {\\n        num = num % fullCycle;\\n        while(num > 0) {\\n            orientateRobot();\\n            num -= moveRobot(num);\\n        }\\n        setDirection();\\n    }\\n    \\n    public int[] getPos() {\\n        return position;\\n    }\\n    \\n    public String getDir() {\\n        return orientation[currentOrientation];\\n    }\\n\\n    private int moveRobot(int steps) {\\n        int possibleSteps = currentOrientation % 2 == 0 \\n            ? currentOrientation == 0 ? (width -1 - position[0]) : position[0]\\n            : currentOrientation == 1 ? (height -1 - position[1]) : position[1];\\n        walkSteps(Math.min(possibleSteps, steps));\\n        return Math.min(possibleSteps, steps);\\n    }\\n\\n    private void walkSteps(int steps) {\\n        if (currentOrientation % 2 == 0) {\\n            position[0] = currentOrientation == 0 ? position[0] + steps : position[0] - steps;\\n        } else {\\n            position[1] = currentOrientation == 1 ? position[1] + steps : position[1] - steps;\\n        }\\n    }\\n\\n    private void setDirection() {\\n        if (position[1] == 0) { \\n            currentOrientation = position[0] == 0 ? 3 : 0;\\n        } else if (position[1] == height - 1) {\\n            currentOrientation = position[0] == width -1 ? 1 : 2;\\n        } else {\\n            currentOrientation = position[0] == 0 ? 3 : 1;\\n        }\\n    }\\n\\n    private void orientateRobot() {\\n        if (currentOrientation == 0) {\\n            currentOrientation = position[0] == width -1 ? 1 : 0;\\n        } else if (currentOrientation == 1) {\\n            currentOrientation = position[1] == height -1 ? 2 : 1;\\n        } else if (currentOrientation == 2) {\\n            currentOrientation =  position[0] == 0 ? 3 : 2;\\n        } else {\\n            currentOrientation = position[1] == 0 ? 0 : 3;          \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861814,
                "title": "easy-to-understand-python-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: O((m+n)*num) i.e O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m*n) i.e O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom typing import List\\n\\nclass Robot:\\n    def __init__(self, width: int, height: int):\\n        self.width = width\\n        self.height = height\\n        self.pos_array = [[0, 0]]\\n        self.dir_array = [\\'East\\']\\n\\n    def reset_class(self):\\n        self.pos_array = [[0, 0]]\\n        self.dir_array = [\\'East\\']\\n\\n    def step(self, num: int) -> None:\\n        m, n = self.width - 1, self.height - 1\\n        pos = self.pos_array[-1]\\n        diri = self.dir_array[-1]\\n\\n        while num != 0:\\n            peri = 2 * (m + n + 2) - 4\\n\\n            if num > peri:\\n                rem = num % peri\\n                num = rem\\n                if num == 0:\\n                    if pos[0] == 0 and pos[1] == 0:\\n                        self.dir_array.append(\"South\")\\n                    elif pos[0] == m and pos[1] == 0:\\n                        self.dir_array.append(\"East\")\\n                    elif pos[0] == m and pos[1] == n:\\n                        self.dir_array.append(\"North\")\\n                    elif pos[0] == 0 and pos[1] == n:\\n                        self.dir_array.append(\"West\")\\n            else:\\n                if pos[0] == 0 and pos[1] == 0:\\n                    if diri != \"East\":\\n                        self.dir_array.append(\"East\")\\n                    if num > m:\\n                        pos[0] = pos[0] + m\\n                        num = num - m\\n                        self.dir_array.append(\"North\")\\n                    else:\\n                        pos[0] = pos[0] + num\\n                        num = 0\\n\\n                elif pos[0] == m and pos[1] == 0:\\n                    if diri != \"North\":\\n                        self.dir_array.append(\"North\")\\n                    if num > n:\\n                        pos[1] = pos[1] + n\\n                        num = num - n\\n                        self.dir_array.append(\"West\")\\n                    else:\\n                        pos[1] = pos[1] + num\\n                        num = 0\\n\\n                elif pos[0] == m and pos[1] == n:\\n                    if diri != \"West\":\\n                        self.dir_array.append(\"West\")\\n                    if num > m:\\n                        pos[0] = pos[0] - m\\n                        num = num - m\\n                        self.dir_array.append(\"South\")\\n                    else:\\n                        pos[0] = pos[0] - num\\n                        num = 0\\n\\n                elif pos[0] == 0 and pos[1] == n:\\n                    if diri != \"South\":\\n                        self.dir_array.append(\"South\")\\n                    if num > n:\\n                        pos[1] = pos[1] - n\\n                        num = num - n\\n                        self.dir_array.append(\"East\")\\n                    else:\\n                        pos[1] = pos[1] - num\\n                        num = 0\\n\\n                elif diri == \"East\":\\n                    right_m = m - pos[0]\\n                    if num > right_m:\\n                        pos[0] += right_m\\n                        num = num - right_m\\n                        self.dir_array.append(\"North\")\\n                    else:\\n                        pos[0] += num\\n                        num = 0\\n\\n                elif diri == \"North\":\\n                    top_n = n - pos[1]\\n                    if num > top_n:\\n                        pos[1] += top_n\\n                        num -= top_n\\n                        self.dir_array.append(\"West\")\\n                    else:\\n                        pos[1] += num\\n                        num = 0\\n\\n                elif diri == \"West\":\\n                    left_m = pos[0]\\n                    if num > left_m:\\n                        pos[0] -= left_m\\n                        num = num - left_m\\n                        self.dir_array.append(\"South\")\\n                    else:\\n                        pos[0] -= num\\n                        num = 0\\n\\n                elif diri == \"South\":\\n                    bottom_n = pos[1]\\n                    if num > bottom_n:\\n                        pos[1] -= bottom_n\\n                        num -= bottom_n\\n                        self.dir_array.append(\"East\")\\n                    else:\\n                        pos[1] -= num\\n                        num = 0\\n\\n    def getPos(self) -> List[int]:\\n        return self.pos_array[-1]\\n\\n    def getDir(self) -> str:\\n        return self.dir_array[-1]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom typing import List\\n\\nclass Robot:\\n    def __init__(self, width: int, height: int):\\n        self.width = width\\n        self.height = height\\n        self.pos_array = [[0, 0]]\\n        self.dir_array = [\\'East\\']\\n\\n    def reset_class(self):\\n        self.pos_array = [[0, 0]]\\n        self.dir_array = [\\'East\\']\\n\\n    def step(self, num: int) -> None:\\n        m, n = self.width - 1, self.height - 1\\n        pos = self.pos_array[-1]\\n        diri = self.dir_array[-1]\\n\\n        while num != 0:\\n            peri = 2 * (m + n + 2) - 4\\n\\n            if num > peri:\\n                rem = num % peri\\n                num = rem\\n                if num == 0:\\n                    if pos[0] == 0 and pos[1] == 0:\\n                        self.dir_array.append(\"South\")\\n                    elif pos[0] == m and pos[1] == 0:\\n                        self.dir_array.append(\"East\")\\n                    elif pos[0] == m and pos[1] == n:\\n                        self.dir_array.append(\"North\")\\n                    elif pos[0] == 0 and pos[1] == n:\\n                        self.dir_array.append(\"West\")\\n            else:\\n                if pos[0] == 0 and pos[1] == 0:\\n                    if diri != \"East\":\\n                        self.dir_array.append(\"East\")\\n                    if num > m:\\n                        pos[0] = pos[0] + m\\n                        num = num - m\\n                        self.dir_array.append(\"North\")\\n                    else:\\n                        pos[0] = pos[0] + num\\n                        num = 0\\n\\n                elif pos[0] == m and pos[1] == 0:\\n                    if diri != \"North\":\\n                        self.dir_array.append(\"North\")\\n                    if num > n:\\n                        pos[1] = pos[1] + n\\n                        num = num - n\\n                        self.dir_array.append(\"West\")\\n                    else:\\n                        pos[1] = pos[1] + num\\n                        num = 0\\n\\n                elif pos[0] == m and pos[1] == n:\\n                    if diri != \"West\":\\n                        self.dir_array.append(\"West\")\\n                    if num > m:\\n                        pos[0] = pos[0] - m\\n                        num = num - m\\n                        self.dir_array.append(\"South\")\\n                    else:\\n                        pos[0] = pos[0] - num\\n                        num = 0\\n\\n                elif pos[0] == 0 and pos[1] == n:\\n                    if diri != \"South\":\\n                        self.dir_array.append(\"South\")\\n                    if num > n:\\n                        pos[1] = pos[1] - n\\n                        num = num - n\\n                        self.dir_array.append(\"East\")\\n                    else:\\n                        pos[1] = pos[1] - num\\n                        num = 0\\n\\n                elif diri == \"East\":\\n                    right_m = m - pos[0]\\n                    if num > right_m:\\n                        pos[0] += right_m\\n                        num = num - right_m\\n                        self.dir_array.append(\"North\")\\n                    else:\\n                        pos[0] += num\\n                        num = 0\\n\\n                elif diri == \"North\":\\n                    top_n = n - pos[1]\\n                    if num > top_n:\\n                        pos[1] += top_n\\n                        num -= top_n\\n                        self.dir_array.append(\"West\")\\n                    else:\\n                        pos[1] += num\\n                        num = 0\\n\\n                elif diri == \"West\":\\n                    left_m = pos[0]\\n                    if num > left_m:\\n                        pos[0] -= left_m\\n                        num = num - left_m\\n                        self.dir_array.append(\"South\")\\n                    else:\\n                        pos[0] -= num\\n                        num = 0\\n\\n                elif diri == \"South\":\\n                    bottom_n = pos[1]\\n                    if num > bottom_n:\\n                        pos[1] -= bottom_n\\n                        num -= bottom_n\\n                        self.dir_array.append(\"East\")\\n                    else:\\n                        pos[1] -= num\\n                        num = 0\\n\\n    def getPos(self) -> List[int]:\\n        return self.pos_array[-1]\\n\\n    def getDir(self) -> str:\\n        return self.dir_array[-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3829033,
                "title": "silly-question-too-many-tricks",
                "content": "# Intuition\\n\\nJust simulate the problem.\\nTo avoid TLE, just do a modulo since the robot can only move on perimeter. \\n\\none solution is that you can just keep one index and keep incrementing the move. And then, for each position, just mark which move would land you there. \\n\\nAlso, the first time robot visits (0, 0) its direction is east, but next time its going to be south.\\n\\n# Approach\\n\\nSimulation\\nJust make sure you avoid TLE.\\n# Complexity\\n- Time complexity: O(m+n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nimport java.util.Arrays;\\n\\nclass Robot {\\n\\n    int width, height, x, y;\\n    String dir;\\n    int cycle;\\n\\n    public Robot(int width, int height) {\\n        this.width = width;\\n        this.height = height;\\n        this.x = 0;\\n        this.y = 0;\\n        this.dir = \"East\";\\n        this.cycle = (width + height - 2 + width + height - 2);\\n    }\\n\\n    public void step(int num) {\\n        num = num % (cycle);\\n        if (num == 0) num = cycle;\\n        do {\\n            switch (dir) {\\n                case \"East\":\\n                    if (x + num < width) {\\n                        x = x + num;\\n                        num = 0;\\n                    } else {\\n                        dir = \"North\";\\n                        int temp = x;\\n                        x = width - 1;\\n                        num = num - (width - temp - 1);\\n                    }\\n                    break;\\n                case \"West\":\\n                    if (x - num >= 0) {\\n                        x = x - num;\\n                        num = 0;\\n                    } else {\\n                        dir = \"South\";\\n                        int tmp = x;\\n                        x = 0;\\n                        num = num - tmp;\\n                    }\\n                    break;\\n                case \"South\":\\n                    if (y - num >= 0) {\\n                        y = y - num;\\n                        num = 0;\\n                    } else {\\n                        dir = \"East\";\\n                        int tmp = y;\\n                        y = 0;\\n                        num = num - tmp;\\n                    }\\n                    break;\\n                case \"North\":\\n                    if (y + num < height) {\\n                        y = y + num;\\n                        num = 0;\\n                    } else {\\n                        dir = \"West\";\\n                        int tmp = y;\\n                        y = height - 1;\\n                        num = num - (height - tmp - 1);\\n                    }\\n                    break;\\n            }\\n        } while (num != 0);\\n    }\\n\\n    public int[] getPos() {\\n        return new int[]{x, y};\\n    }\\n\\n    public String getDir() {\\n        return dir;\\n    }\\n\\n    public static void main(String[] args) {\\n        Robot robot = new Robot(2, 3);\\n        robot.step(24);\\n\\n\\n        System.out.println(Arrays.toString(robot.getPos()));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.Arrays;\\n\\nclass Robot {\\n\\n    int width, height, x, y;\\n    String dir;\\n    int cycle;\\n\\n    public Robot(int width, int height) {\\n        this.width = width;\\n        this.height = height;\\n        this.x = 0;\\n        this.y = 0;\\n        this.dir = \"East\";\\n        this.cycle = (width + height - 2 + width + height - 2);\\n    }\\n\\n    public void step(int num) {\\n        num = num % (cycle);\\n        if (num == 0) num = cycle;\\n        do {\\n            switch (dir) {\\n                case \"East\":\\n                    if (x + num < width) {\\n                        x = x + num;\\n                        num = 0;\\n                    } else {\\n                        dir = \"North\";\\n                        int temp = x;\\n                        x = width - 1;\\n                        num = num - (width - temp - 1);\\n                    }\\n                    break;\\n                case \"West\":\\n                    if (x - num >= 0) {\\n                        x = x - num;\\n                        num = 0;\\n                    } else {\\n                        dir = \"South\";\\n                        int tmp = x;\\n                        x = 0;\\n                        num = num - tmp;\\n                    }\\n                    break;\\n                case \"South\":\\n                    if (y - num >= 0) {\\n                        y = y - num;\\n                        num = 0;\\n                    } else {\\n                        dir = \"East\";\\n                        int tmp = y;\\n                        y = 0;\\n                        num = num - tmp;\\n                    }\\n                    break;\\n                case \"North\":\\n                    if (y + num < height) {\\n                        y = y + num;\\n                        num = 0;\\n                    } else {\\n                        dir = \"West\";\\n                        int tmp = y;\\n                        y = height - 1;\\n                        num = num - (height - tmp - 1);\\n                    }\\n                    break;\\n            }\\n        } while (num != 0);\\n    }\\n\\n    public int[] getPos() {\\n        return new int[]{x, y};\\n    }\\n\\n    public String getDir() {\\n        return dir;\\n    }\\n\\n    public static void main(String[] args) {\\n        Robot robot = new Robot(2, 3);\\n        robot.step(24);\\n\\n\\n        System.out.println(Arrays.toString(robot.getPos()));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3802594,
                "title": "java-solution-easy-circular-array",
                "content": "Just from reading the question, we know that we need to traverse the perimeter of the grid. So just project the permiter onto a 1D array. This array can then store the coordinates and direction the robot would be facing when on that point. We can have an index pointing to the element of the array which stores the current location. We can just add the number of steps directly to the index and do modular arthimetic to get the new location of the robot.\\n\\n\\n# Code\\n```\\nclass Robot {\\n    class Pair{\\n        int x,y;\\n        char dir;\\n        Pair(int x, int y, char dir){\\n            this.x = x;\\n            this.y = y;\\n            this.dir = dir;\\n        }\\n    }\\n    int i, w, h;\\n    Pair[] arr;\\n    boolean moved = false;\\n    public Robot(int width, int height) {\\n        w = width;\\n        h = height;\\n        i = 0;\\n        arr = new Pair[width + height -1 + width - 1 + height - 2];\\n        int i = 0;\\n        for(i = 1; i < width; i++){\\n            arr[i] = new Pair(i,0, \\'e\\');\\n        }\\n        for(i= i; i < width + height-1; i++){\\n            arr[i] = new Pair(width-1, i - width + 1, \\'n\\');\\n        }\\n        int temp = width - 2;\\n        for(i =i; i < width + height-1 + width-1; i++){\\n            arr[i] = new Pair(temp,height-1, \\'w\\');\\n            temp--;\\n        }\\n        temp = height - 2;\\n        for(i =i; i < width + height-1 + width-1 + height - 2; i++){\\n            arr[i] = new Pair(0,temp, \\'s\\');\\n            temp--;\\n        }\\n        arr[0] = new Pair(0,0,\\'s\\');\\n    }\\n    \\n    public void step(int num) {\\n        moved = true;\\n        i = (i + num) % arr.length;\\n    }\\n    \\n    public int[] getPos() {\\n        int arr[] = new int[2];\\n        arr[0] = this.arr[i].x;\\n        arr[1]  = this.arr[i].y;\\n        return arr;\\n    }\\n    \\n    public String getDir() {\\n        if(moved == false){\\n            return \"East\";\\n        }\\n        char ch = this.arr[i].dir;\\n        if(ch == \\'n\\'){\\n            return \"North\";\\n        }\\n        else if(ch == \\'e\\'){\\n            return \"East\";\\n        }\\n        else if(ch == \\'s\\'){\\n            return \"South\";\\n        }\\n        else{\\n            return \"West\";\\n        }\\n    }\\n}\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot obj = new Robot(width, height);\\n * obj.step(num);\\n * int[] param_2 = obj.getPos();\\n * String param_3 = obj.getDir();\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Robot {\\n    class Pair{\\n        int x,y;\\n        char dir;\\n        Pair(int x, int y, char dir){\\n            this.x = x;\\n            this.y = y;\\n            this.dir = dir;\\n        }\\n    }\\n    int i, w, h;\\n    Pair[] arr;\\n    boolean moved = false;\\n    public Robot(int width, int height) {\\n        w = width;\\n        h = height;\\n        i = 0;\\n        arr = new Pair[width + height -1 + width - 1 + height - 2];\\n        int i = 0;\\n        for(i = 1; i < width; i++){\\n            arr[i] = new Pair(i,0, \\'e\\');\\n        }\\n        for(i= i; i < width + height-1; i++){\\n            arr[i] = new Pair(width-1, i - width + 1, \\'n\\');\\n        }\\n        int temp = width - 2;\\n        for(i =i; i < width + height-1 + width-1; i++){\\n            arr[i] = new Pair(temp,height-1, \\'w\\');\\n            temp--;\\n        }\\n        temp = height - 2;\\n        for(i =i; i < width + height-1 + width-1 + height - 2; i++){\\n            arr[i] = new Pair(0,temp, \\'s\\');\\n            temp--;\\n        }\\n        arr[0] = new Pair(0,0,\\'s\\');\\n    }\\n    \\n    public void step(int num) {\\n        moved = true;\\n        i = (i + num) % arr.length;\\n    }\\n    \\n    public int[] getPos() {\\n        int arr[] = new int[2];\\n        arr[0] = this.arr[i].x;\\n        arr[1]  = this.arr[i].y;\\n        return arr;\\n    }\\n    \\n    public String getDir() {\\n        if(moved == false){\\n            return \"East\";\\n        }\\n        char ch = this.arr[i].dir;\\n        if(ch == \\'n\\'){\\n            return \"North\";\\n        }\\n        else if(ch == \\'e\\'){\\n            return \"East\";\\n        }\\n        else if(ch == \\'s\\'){\\n            return \"South\";\\n        }\\n        else{\\n            return \"West\";\\n        }\\n    }\\n}\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot obj = new Robot(width, height);\\n * obj.step(num);\\n * int[] param_2 = obj.getPos();\\n * String param_3 = obj.getDir();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3752346,
                "title": "simple-c-solution",
                "content": "# Approach\\nSimple logic to move around the perimeter by checking against the limits. Uses a vector of tuples to store direction name, direction sign, limits and pointer to the coordinate to update.\\n\\nBefore even trying to update, checks if the total number of steps is a multiple of the perimeter and update the robot position only considering the remainder.\\n\\n# Code\\n```\\nclass Robot {\\npublic:\\n    Robot(int width, int height) :\\n        width_(width), \\n        height_(height), \\n        perimeter_(4 + 2 * (width_ - 2) + 2 * (height_ - 2))\\n    {\\n        parameters_ = \\n        { \\n            {\"East\",  1,  width_- 1,   &x_},\\n            {\"North\", 1,  height_ - 1, &y_},\\n            {\"West\", -1,  0,           &x_},\\n            {\"South\", -1, 0,           &y_}\\n        };\\n    }\\n    \\n    void step(int num) {\\n        \\n        int remaining = num;\\n\\n        // If we make full circles, the robot ends up in the same position\\n        int number_full_circles = int(remaining / perimeter_);\\n        remaining -= number_full_circles * perimeter_;\\n\\n        // Handle corner case\\n        if (number_full_circles > 0 and x_ == 0 and y_ == 0)\\n            direction_index_ = 3;\\n\\n        // Do the remaining steps\\n        while (remaining > 0)\\n        {\\n            int direction = std::get<1>(parameters_[direction_index_]);\\n            int limit = std::get<2>(parameters_[direction_index_]);\\n            int* coordinate = std::get<3>(parameters_[direction_index_]);\\n\\n            int previous_coordinate = *coordinate;\\n            (*coordinate) += remaining * direction;\\n            if (direction * (*coordinate) > limit)\\n            {\\n                direction_index_ = (direction_index_ + 1) % 4;\\n                (*coordinate) = limit;\\n            }\\n\\n            remaining -= abs(previous_coordinate - *coordinate);\\n        }\\n    }\\n    \\n    vector<int> getPos() {\\n        return std::vector<int> {x_, y_};\\n    }\\n    \\n    string getDir() {\\n        return std::get<0>(parameters_[direction_index_]);\\n    }\\n\\n    int width_;\\n    int height_;\\n    int x_ = 0;\\n    int y_ = 0;\\n    int direction_index_ = 0;\\n    const int perimeter_;\\n    std::vector<std::tuple<std::string, int, int, int*> > parameters_;\\n};\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot* obj = new Robot(width, height);\\n * obj->step(num);\\n * vector<int> param_2 = obj->getPos();\\n * string param_3 = obj->getDir();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Robot {\\npublic:\\n    Robot(int width, int height) :\\n        width_(width), \\n        height_(height), \\n        perimeter_(4 + 2 * (width_ - 2) + 2 * (height_ - 2))\\n    {\\n        parameters_ = \\n        { \\n            {\"East\",  1,  width_- 1,   &x_},\\n            {\"North\", 1,  height_ - 1, &y_},\\n            {\"West\", -1,  0,           &x_},\\n            {\"South\", -1, 0,           &y_}\\n        };\\n    }\\n    \\n    void step(int num) {\\n        \\n        int remaining = num;\\n\\n        // If we make full circles, the robot ends up in the same position\\n        int number_full_circles = int(remaining / perimeter_);\\n        remaining -= number_full_circles * perimeter_;\\n\\n        // Handle corner case\\n        if (number_full_circles > 0 and x_ == 0 and y_ == 0)\\n            direction_index_ = 3;\\n\\n        // Do the remaining steps\\n        while (remaining > 0)\\n        {\\n            int direction = std::get<1>(parameters_[direction_index_]);\\n            int limit = std::get<2>(parameters_[direction_index_]);\\n            int* coordinate = std::get<3>(parameters_[direction_index_]);\\n\\n            int previous_coordinate = *coordinate;\\n            (*coordinate) += remaining * direction;\\n            if (direction * (*coordinate) > limit)\\n            {\\n                direction_index_ = (direction_index_ + 1) % 4;\\n                (*coordinate) = limit;\\n            }\\n\\n            remaining -= abs(previous_coordinate - *coordinate);\\n        }\\n    }\\n    \\n    vector<int> getPos() {\\n        return std::vector<int> {x_, y_};\\n    }\\n    \\n    string getDir() {\\n        return std::get<0>(parameters_[direction_index_]);\\n    }\\n\\n    int width_;\\n    int height_;\\n    int x_ = 0;\\n    int y_ = 0;\\n    int direction_index_ = 0;\\n    const int perimeter_;\\n    std::vector<std::tuple<std::string, int, int, int*> > parameters_;\\n};\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot* obj = new Robot(width, height);\\n * obj->step(num);\\n * vector<int> param_2 = obj->getPos();\\n * string param_3 = obj->getDir();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3678463,
                "title": "java-solution",
                "content": "# Code\\n```\\nclass Robot {\\n    int width;\\n    int height;\\n    String dir;\\n    int x;\\n    int y;\\n    int perimeter; \\n\\n    public Robot(int width, int height) {\\n        this.width = width;\\n        this.height = height;\\n        dir = \"East\";\\n        x = 0;\\n        y = 0;\\n        perimeter = 2 * (width+height-2);\\n    }\\n    \\n    public void step(int num) {        \\n        while(num>0){    \\n            if(x == 0 || x == width-1 || y == 0 || y == height-1){\\n                num = num%perimeter;\\n            }\\n            if(num==0){\\n                if(x==0 && y==0){\\n                    dir = \"South\";\\n                }else if(x==width-1 && y==0){\\n                    dir = \"East\";\\n                }else if(x==width-1 && y==height-1){\\n                    dir = \"North\";\\n                }else if(x==0 && y==height-1){\\n                    dir = \"West\";\\n                }\\n                return;\\n            }\\n            switch(dir){\\n                case \"East\":{                                                        \\n                    int val = Math.min(width-1-x,num);\\n                    x += val;\\n                    num -= val;\\n                    if(num > 0){                        \\n                        dir = \"North\";                                      \\n                    }\\n                }\\n                break;\\n                case \"North\":{                                        \\n                    int val = Math.min(height-1-y,num);\\n                    y += val;\\n                    num -= val;\\n                    if(num > 0){\\n                        dir = \"West\";                                          \\n                    }\\n                }\\n                break;\\n                case \"West\":{                    \\n                    int val = Math.min(x,num);\\n                    x -= val;\\n                    num -= val;\\n                    if(num > 0){\\n                        dir = \"South\";                     \\n                    }\\n                }\\n                break;\\n                case \"South\":{\\n                    int val = Math.min(y,num);\\n                    y -= val;\\n                    num -= val;\\n                    if(num > 0){\\n                        dir = \"East\";                                                               \\n                    }\\n                }\\n                break;                    \\n            }            \\n        }\\n    }\\n    \\n    public int[] getPos() {\\n        return new int[]{x,y};\\n    }\\n    \\n    public String getDir() {\\n        return dir;\\n    }\\n}\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot obj = new Robot(width, height);\\n * obj.step(num);\\n * int[] param_2 = obj.getPos();\\n * String param_3 = obj.getDir();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Robot {\\n    int width;\\n    int height;\\n    String dir;\\n    int x;\\n    int y;\\n    int perimeter; \\n\\n    public Robot(int width, int height) {\\n        this.width = width;\\n        this.height = height;\\n        dir = \"East\";\\n        x = 0;\\n        y = 0;\\n        perimeter = 2 * (width+height-2);\\n    }\\n    \\n    public void step(int num) {        \\n        while(num>0){    \\n            if(x == 0 || x == width-1 || y == 0 || y == height-1){\\n                num = num%perimeter;\\n            }\\n            if(num==0){\\n                if(x==0 && y==0){\\n                    dir = \"South\";\\n                }else if(x==width-1 && y==0){\\n                    dir = \"East\";\\n                }else if(x==width-1 && y==height-1){\\n                    dir = \"North\";\\n                }else if(x==0 && y==height-1){\\n                    dir = \"West\";\\n                }\\n                return;\\n            }\\n            switch(dir){\\n                case \"East\":{                                                        \\n                    int val = Math.min(width-1-x,num);\\n                    x += val;\\n                    num -= val;\\n                    if(num > 0){                        \\n                        dir = \"North\";                                      \\n                    }\\n                }\\n                break;\\n                case \"North\":{                                        \\n                    int val = Math.min(height-1-y,num);\\n                    y += val;\\n                    num -= val;\\n                    if(num > 0){\\n                        dir = \"West\";                                          \\n                    }\\n                }\\n                break;\\n                case \"West\":{                    \\n                    int val = Math.min(x,num);\\n                    x -= val;\\n                    num -= val;\\n                    if(num > 0){\\n                        dir = \"South\";                     \\n                    }\\n                }\\n                break;\\n                case \"South\":{\\n                    int val = Math.min(y,num);\\n                    y -= val;\\n                    num -= val;\\n                    if(num > 0){\\n                        dir = \"East\";                                                               \\n                    }\\n                }\\n                break;                    \\n            }            \\n        }\\n    }\\n    \\n    public int[] getPos() {\\n        return new int[]{x,y};\\n    }\\n    \\n    public String getDir() {\\n        return dir;\\n    }\\n}\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot obj = new Robot(width, height);\\n * obj.step(num);\\n * int[] param_2 = obj.getPos();\\n * String param_3 = obj.getDir();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3626900,
                "title": "kotlin-o-1-solution-with-modulo-division",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nRobot walks only on the outerband \\'circle\\' in a counter clockwise direction. We can calculate the direction and the position based on the number of steps.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nUse modulo division by the number of all fields where the robot can walk to avoid loops\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Robot(width: Int, height: Int) {\\n\\n    var currPos: Int = 0\\n    val east = \"East\"\\n    val north = \"North\"\\n    val west = \"West\"\\n    val south = \"South\"\\n\\n    //example for grid: 6x3\\n    val topRow = height - 1\\n    val roundLength = width * 2 + (height - 2) * 2 // 12 + 2 = 14\\n    val rightDown = width - 1 //  5\\n    val rightTop = rightDown + height - 1 //5 + 3 -1 = 7\\n    val leftTop = rightTop + rightDown // 7 + 5 = 12\\n    var totalSteps = 0\\n\\n\\n    fun step(num: Int) {\\n        totalSteps += num\\n        currPos = totalSteps % roundLength\\n    }\\n\\n    fun getPos(): IntArray = when (currPos) {\\n        in 0..rightDown -> arrayOf(currPos, 0).toIntArray() // 2 -> [2,0] 5-> [5,0]\\n        in rightDown + 1..rightTop -> arrayOf(rightDown, currPos - rightDown).toIntArray() // 6 -> [5,1], 7-> [5, 2]\\n        in rightTop + 1..leftTop -> arrayOf(\\n            rightDown - (currPos - rightTop),\\n            topRow\\n        ).toIntArray()// 8-> [5-(8-7),2], 12->[5-(12-7)]\\n        else -> arrayOf(0, topRow - (currPos - leftTop)).toIntArray()// 13->[0, 2-(13-12)] -> [0,1]\\n    }\\n\\n    fun getDir(): String = when (currPos) {\\n        in 0..rightDown -> {\\n            //robot keeps the direction so when it does the round robin trip and reaches [0,0] it should keep \\'South\\' direction\\n            // instead of \\'East\\' that was initially set at the start\\n            if ((totalSteps / roundLength > 0) && currPos == 0) south\\n            else east\\n        }\\n\\n        in rightDown + 1..rightTop -> north\\n        in rightTop + 1..leftTop -> west\\n        else -> south\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Robot(width: Int, height: Int) {\\n\\n    var currPos: Int = 0\\n    val east = \"East\"\\n    val north = \"North\"\\n    val west = \"West\"\\n    val south = \"South\"\\n\\n    //example for grid: 6x3\\n    val topRow = height - 1\\n    val roundLength = width * 2 + (height - 2) * 2 // 12 + 2 = 14\\n    val rightDown = width - 1 //  5\\n    val rightTop = rightDown + height - 1 //5 + 3 -1 = 7\\n    val leftTop = rightTop + rightDown // 7 + 5 = 12\\n    var totalSteps = 0\\n\\n\\n    fun step(num: Int) {\\n        totalSteps += num\\n        currPos = totalSteps % roundLength\\n    }\\n\\n    fun getPos(): IntArray = when (currPos) {\\n        in 0..rightDown -> arrayOf(currPos, 0).toIntArray() // 2 -> [2,0] 5-> [5,0]\\n        in rightDown + 1..rightTop -> arrayOf(rightDown, currPos - rightDown).toIntArray() // 6 -> [5,1], 7-> [5, 2]\\n        in rightTop + 1..leftTop -> arrayOf(\\n            rightDown - (currPos - rightTop),\\n            topRow\\n        ).toIntArray()// 8-> [5-(8-7),2], 12->[5-(12-7)]\\n        else -> arrayOf(0, topRow - (currPos - leftTop)).toIntArray()// 13->[0, 2-(13-12)] -> [0,1]\\n    }\\n\\n    fun getDir(): String = when (currPos) {\\n        in 0..rightDown -> {\\n            //robot keeps the direction so when it does the round robin trip and reaches [0,0] it should keep \\'South\\' direction\\n            // instead of \\'East\\' that was initially set at the start\\n            if ((totalSteps / roundLength > 0) && currPos == 0) south\\n            else east\\n        }\\n\\n        in rightDown + 1..rightTop -> north\\n        in rightTop + 1..leftTop -> west\\n        else -> south\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3605385,
                "title": "rust-easy-o-1-solution",
                "content": "# Intuition\\nThis problem involves simulating the movement of a robot that travels in cycles around the perimeter of a rectangular area. The robot\\'s position is tracked by a number corresponding to its current cell on the perimeter. As the robot moves, this number is incremented. If the number exceeds the perimeter\\'s length, it wraps back around.\\n\\nThe most complex part of this problem is determining the robot\\'s position and direction based on the current cell on the perimeter.\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nenum Direction {\\n    North,\\n    East,\\n    South,\\n    West\\n}\\n\\nstruct Robot {\\n    max_x: i32,\\n    max_y: i32,\\n    current_route_num: i32,\\n    position_cache: (i32, i32, Direction)\\n}\\n\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl Robot {\\n\\n    fn new(width: i32, height: i32) -> Self {\\n        return Robot{max_x: width - 1, max_y: height - 1, current_route_num: -1, position_cache: (0,0,Direction::East)};\\n    }\\n    \\n    fn step(&mut self, num: i32) {\\n        // Mark robot that we started moving.\\n        if self.current_route_num < 0 {\\n            self.current_route_num = 0;\\n        }\\n\\n        let perim = (self.max_x + 1) * 2  + (self.max_y - 1) * 2;\\n\\n        self.current_route_num += num;\\n        self.current_route_num %= perim;\\n        self.set_position_data();\\n    }\\n    \\n    fn get_pos(&self) -> Vec<i32> {\\n        return vec![self.position_cache.0.clone(), self.position_cache.1.clone()];\\n    }\\n    \\n    fn get_dir(&self) -> String {\\n        return match self.position_cache.2 {\\n            Direction::North => \"North\",\\n            Direction::East => \"East\",\\n            Direction::South => \"South\",\\n            Direction::West => \"West\",\\n        }.to_string();\\n    }\\n\\n    fn set_position_data(&mut self) {\\n        self.position_cache = if self.current_route_num < 0 {\\n            (0, 0, Direction::East)\\n        } else if self.current_route_num == 0 {\\n            (self.current_route_num, 0, Direction::South)\\n        } else if self.current_route_num <= self.max_x {\\n            (self.current_route_num, 0, Direction::East)\\n        } else if self.current_route_num <= self.max_x + self.max_y {\\n            (self.max_x, self.current_route_num - self.max_x, Direction::North)\\n        } else if self.current_route_num <= 2*self.max_x + self.max_y {\\n            (self.max_x - (self.current_route_num - self.max_x - self.max_y), self.max_y, Direction::West)\\n        } else {\\n            (0, self.max_y - (self.current_route_num - 2 * self.max_x - self.max_y), Direction::South)\\n        }\\n    }\\n}\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * let obj = Robot::new(width, height);\\n * obj.step(num);\\n * let ret_2: Vec<i32> = obj.get_pos();\\n * let ret_3: String = obj.get_dir();\\n */\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nenum Direction {\\n    North,\\n    East,\\n    South,\\n    West\\n}\\n\\nstruct Robot {\\n    max_x: i32,\\n    max_y: i32,\\n    current_route_num: i32,\\n    position_cache: (i32, i32, Direction)\\n}\\n\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl Robot {\\n\\n    fn new(width: i32, height: i32) -> Self {\\n        return Robot{max_x: width - 1, max_y: height - 1, current_route_num: -1, position_cache: (0,0,Direction::East)};\\n    }\\n    \\n    fn step(&mut self, num: i32) {\\n        // Mark robot that we started moving.\\n        if self.current_route_num < 0 {\\n            self.current_route_num = 0;\\n        }\\n\\n        let perim = (self.max_x + 1) * 2  + (self.max_y - 1) * 2;\\n\\n        self.current_route_num += num;\\n        self.current_route_num %= perim;\\n        self.set_position_data();\\n    }\\n    \\n    fn get_pos(&self) -> Vec<i32> {\\n        return vec![self.position_cache.0.clone(), self.position_cache.1.clone()];\\n    }\\n    \\n    fn get_dir(&self) -> String {\\n        return match self.position_cache.2 {\\n            Direction::North => \"North\",\\n            Direction::East => \"East\",\\n            Direction::South => \"South\",\\n            Direction::West => \"West\",\\n        }.to_string();\\n    }\\n\\n    fn set_position_data(&mut self) {\\n        self.position_cache = if self.current_route_num < 0 {\\n            (0, 0, Direction::East)\\n        } else if self.current_route_num == 0 {\\n            (self.current_route_num, 0, Direction::South)\\n        } else if self.current_route_num <= self.max_x {\\n            (self.current_route_num, 0, Direction::East)\\n        } else if self.current_route_num <= self.max_x + self.max_y {\\n            (self.max_x, self.current_route_num - self.max_x, Direction::North)\\n        } else if self.current_route_num <= 2*self.max_x + self.max_y {\\n            (self.max_x - (self.current_route_num - self.max_x - self.max_y), self.max_y, Direction::West)\\n        } else {\\n            (0, self.max_y - (self.current_route_num - 2 * self.max_x - self.max_y), Direction::South)\\n        }\\n    }\\n}\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * let obj = Robot::new(width, height);\\n * obj.step(num);\\n * let ret_2: Vec<i32> = obj.get_pos();\\n * let ret_3: String = obj.get_dir();\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3454508,
                "title": "python-solution-with-explanation-and-comments-on-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe start moving the robot first by one turn around the board. When the robot moves one turn, it doesn\\'t change the direction either, only in case if its current location was [0,0], then we need to make sure the direction will be saved as \\'South\\', since the initial location is [0,0] and the direction is \\'East\\'\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe save the current location and current direction of the robot at any moment. That would make the implementation of ```getPos``` and ```getDir``` easier. For implementing the ```step``` we calculate the number of moves for the robot to turn one round on the board, if the number of steps is greater than that, we can divide number by the moves that takes for one turn. This will either result in 0 or a reminder which is less than a turn. We then start moving the robot by maximum possible move in the current direction till steps reaches zero.\\n\\n# Code\\n```\\nclass Robot:\\n\\n    def __init__(self, width: int, height: int):\\n        self.width = width - 1\\n        self.height = height - 1\\n        # find the next direction\\n        self.next_dir = {\\n            \\'East\\': \\'North\\',\\n            \\'North\\': \\'West\\',\\n            \\'West\\': \\'South\\',\\n            \\'South\\': \\'East\\'\\n        }\\n        # moves based on current direction\\n        self.moves = {\\n            \\'East\\': [1, 0],\\n            \\'North\\': [0, 1],\\n            \\'West\\': [-1, 0],\\n            \\'South\\': [0, -1]\\n        }\\n\\n        # current loc and direction\\n        self.loc = [0, 0]\\n        self.dir = \\'East\\'\\n\\n        # moving one turn in the board\\n        self.one_turn = self.width * 2 + self.height * 2\\n\\n    def step(self, num: int) -> None:\\n\\n        # Calculate the number of turns\\n        if num > self.one_turn:\\n            num = num - (num // self.one_turn) * self.one_turn\\n\\n            # Only happens for [0, 0] since the initial direction is [0,0]\\n            # and the direction is East instead of South\\n            if num == 0 and self.loc == [0, 0]:\\n                self.dir = \\'South\\'\\n\\n        # Move the robot maximum each time \\n        while num > 0:\\n            cur_move = self.moves[self.dir]\\n            max_move = min(self.max_move_dir(), num)\\n            num -= max_move\\n            new_width, new_height = self.loc[0] + cur_move[0] * max_move, self.loc[1] + cur_move[1] * max_move\\n            self.loc = [new_width, new_height]\\n            # only if there is still move, we need to change the direction\\n            if num > 0:\\n                self.dir = self.next_dir[self.dir]\\n\\n    # return the maximum move the robot can make in the direction\\n    def max_move_dir(self):\\n        if self.dir == \\'East\\':\\n            return self.width - self.loc[0]\\n        if self.dir == \\'North\\':\\n            return self.height - self.loc[1]\\n        if self.dir == \\'West\\':\\n            return self.loc[0] - 0\\n        if self.dir == \\'South\\':\\n            return self.loc[1] - 0\\n\\n    def getPos(self) -> List[int]:\\n        return self.loc\\n\\n    def getDir(self) -> str:\\n        return self.dir\\n\\n\\n# Your Robot object will be instantiated and called as such:\\n# obj = Robot(width, height)\\n# obj.step(num)\\n# param_2 = obj.getPos()\\n# param_3 = obj.getDir()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```getPos```\n```getDir```\n```step```\n```\\nclass Robot:\\n\\n    def __init__(self, width: int, height: int):\\n        self.width = width - 1\\n        self.height = height - 1\\n        # find the next direction\\n        self.next_dir = {\\n            \\'East\\': \\'North\\',\\n            \\'North\\': \\'West\\',\\n            \\'West\\': \\'South\\',\\n            \\'South\\': \\'East\\'\\n        }\\n        # moves based on current direction\\n        self.moves = {\\n            \\'East\\': [1, 0],\\n            \\'North\\': [0, 1],\\n            \\'West\\': [-1, 0],\\n            \\'South\\': [0, -1]\\n        }\\n\\n        # current loc and direction\\n        self.loc = [0, 0]\\n        self.dir = \\'East\\'\\n\\n        # moving one turn in the board\\n        self.one_turn = self.width * 2 + self.height * 2\\n\\n    def step(self, num: int) -> None:\\n\\n        # Calculate the number of turns\\n        if num > self.one_turn:\\n            num = num - (num // self.one_turn) * self.one_turn\\n\\n            # Only happens for [0, 0] since the initial direction is [0,0]\\n            # and the direction is East instead of South\\n            if num == 0 and self.loc == [0, 0]:\\n                self.dir = \\'South\\'\\n\\n        # Move the robot maximum each time \\n        while num > 0:\\n            cur_move = self.moves[self.dir]\\n            max_move = min(self.max_move_dir(), num)\\n            num -= max_move\\n            new_width, new_height = self.loc[0] + cur_move[0] * max_move, self.loc[1] + cur_move[1] * max_move\\n            self.loc = [new_width, new_height]\\n            # only if there is still move, we need to change the direction\\n            if num > 0:\\n                self.dir = self.next_dir[self.dir]\\n\\n    # return the maximum move the robot can make in the direction\\n    def max_move_dir(self):\\n        if self.dir == \\'East\\':\\n            return self.width - self.loc[0]\\n        if self.dir == \\'North\\':\\n            return self.height - self.loc[1]\\n        if self.dir == \\'West\\':\\n            return self.loc[0] - 0\\n        if self.dir == \\'South\\':\\n            return self.loc[1] - 0\\n\\n    def getPos(self) -> List[int]:\\n        return self.loc\\n\\n    def getDir(self) -> str:\\n        return self.dir\\n\\n\\n# Your Robot object will be instantiated and called as such:\\n# obj = Robot(width, height)\\n# obj.step(num)\\n# param_2 = obj.getPos()\\n# param_3 = obj.getDir()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282545,
                "title": "easiest-solution-to-understand",
                "content": "```\\nclass Robot {\\n    String dir = \"East\";int w=0,h=0;\\n    int pos[] = new int[]{0,0};\\n    public Robot(int width, int height) {\\n        w = width; h = height;\\n    }\\n    \\n    public void step(int num) {\\n        int tot = 2*(w+h)-4;\\n        num=num%tot;\\n        if(num==0) num=tot;\\n        while(num>0){\\n            if(dir.equals(\"East\")){\\n                if(w-pos[0]-1>=num) { pos[0] = pos[0]+num; num = 0; } //remain in that same dir\\n                else{ num -= (w-pos[0]); pos[0] = w-1; pos[1] = 1;  dir = \"North\"; }//change in that dir\\n            }\\n            else if(dir.equals(\"North\")){\\n                if(h-pos[1]-1>=num) { pos[1] = pos[1]+num; num = 0; }//remain in that same dir\\n                else{ num -= (h-pos[1]); pos[0] = w-2; pos[1] = h-1;  dir = \"West\"; }//change in that dir\\n            }\\n            else if(dir.equals(\"West\")){\\n                if(pos[0]>=num) { pos[0] = pos[0]-num; num = 0; }//remain in that same dir\\n                else{ num -= (pos[0]+1); pos[0] = 0; pos[1] = h-2; dir = \"South\"; }//change in that dir\\n            }\\n            else{\\n                if(pos[1]>=num) { pos[1] = pos[1]-num; num = 0; }//remain in that same dir\\n                else{ num -= (pos[1]+1); pos[0] = 1; pos[1] = 0;  dir = \"East\"; }//change in that dir\\n            }\\n        }\\n    }\\n    \\n    public int[] getPos() {\\n        return pos;\\n    }\\n    \\n    public String getDir() {\\n        return dir;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Robot {\\n    String dir = \"East\";int w=0,h=0;\\n    int pos[] = new int[]{0,0};\\n    public Robot(int width, int height) {\\n        w = width; h = height;\\n    }\\n    \\n    public void step(int num) {\\n        int tot = 2*(w+h)-4;\\n        num=num%tot;\\n        if(num==0) num=tot;\\n        while(num>0){\\n            if(dir.equals(\"East\")){\\n                if(w-pos[0]-1>=num) { pos[0] = pos[0]+num; num = 0; } //remain in that same dir\\n                else{ num -= (w-pos[0]); pos[0] = w-1; pos[1] = 1;  dir = \"North\"; }//change in that dir\\n            }\\n            else if(dir.equals(\"North\")){\\n                if(h-pos[1]-1>=num) { pos[1] = pos[1]+num; num = 0; }//remain in that same dir\\n                else{ num -= (h-pos[1]); pos[0] = w-2; pos[1] = h-1;  dir = \"West\"; }//change in that dir\\n            }\\n            else if(dir.equals(\"West\")){\\n                if(pos[0]>=num) { pos[0] = pos[0]-num; num = 0; }//remain in that same dir\\n                else{ num -= (pos[0]+1); pos[0] = 0; pos[1] = h-2; dir = \"South\"; }//change in that dir\\n            }\\n            else{\\n                if(pos[1]>=num) { pos[1] = pos[1]-num; num = 0; }//remain in that same dir\\n                else{ num -= (pos[1]+1); pos[0] = 1; pos[1] = 0;  dir = \"East\"; }//change in that dir\\n            }\\n        }\\n    }\\n    \\n    public int[] getPos() {\\n        return pos;\\n    }\\n    \\n    public String getDir() {\\n        return dir;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 3249970,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nstruct Robot {\\n    dir: Vec<Vec<i32>>,\\n    dir_str: Vec<String>,\\n    pos: Vec<i32>,\\n    w: i32,\\n    h: i32,\\n    idx: usize,\\n    count: i32,\\n}\\n\\nimpl Robot {\\n    fn new(width: i32, height: i32) -> Self {\\n        Robot {\\n            dir: vec![vec![1, 0], vec![0, 1], vec![-1, 0], vec![0, -1]],\\n            dir_str: vec![\\n                \"East\".to_string(),\\n                \"North\".to_string(),\\n                \"West\".to_string(),\\n                \"South\".to_string(),\\n            ],\\n            pos: vec![0, 0],\\n            w: width,\\n            h: height,\\n            idx: 0,\\n            count: 0,\\n        }\\n    }\\n\\n    fn step(&mut self, num: i32) {\\n        self.count = (self.count + num) % (2 * (self.w + self.h - 2));\\n        if self.count >= 0 && self.count < self.w {\\n            self.pos = vec![self.count, 0];\\n            self.idx = if self.count == 0 { 3 } else { 0 };\\n        } else if self.count >= self.w && self.count < self.w + self.h - 1 {\\n            self.pos = vec![self.w - 1, self.count - self.w + 1];\\n            self.idx = 1;\\n        } else if self.count >= self.w + self.h - 1 && self.count < 2 * self.w + self.h - 2 {\\n            self.pos = vec![2 * self.w + self.h - self.count - 3, self.h - 1];\\n            self.idx = 2;\\n        } else {\\n            self.pos = vec![0, 2 * self.h + 2 * self.w - self.count - 4];\\n            self.idx = 3;\\n        }\\n    }\\n\\n    fn get_pos(&self) -> Vec<i32> {\\n        self.pos.clone()\\n    }\\n\\n    fn get_dir(&self) -> String {\\n        self.dir_str[self.idx].clone()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nstruct Robot {\\n    dir: Vec<Vec<i32>>,\\n    dir_str: Vec<String>,\\n    pos: Vec<i32>,\\n    w: i32,\\n    h: i32,\\n    idx: usize,\\n    count: i32,\\n}\\n\\nimpl Robot {\\n    fn new(width: i32, height: i32) -> Self {\\n        Robot {\\n            dir: vec![vec![1, 0], vec![0, 1], vec![-1, 0], vec![0, -1]],\\n            dir_str: vec![\\n                \"East\".to_string(),\\n                \"North\".to_string(),\\n                \"West\".to_string(),\\n                \"South\".to_string(),\\n            ],\\n            pos: vec![0, 0],\\n            w: width,\\n            h: height,\\n            idx: 0,\\n            count: 0,\\n        }\\n    }\\n\\n    fn step(&mut self, num: i32) {\\n        self.count = (self.count + num) % (2 * (self.w + self.h - 2));\\n        if self.count >= 0 && self.count < self.w {\\n            self.pos = vec![self.count, 0];\\n            self.idx = if self.count == 0 { 3 } else { 0 };\\n        } else if self.count >= self.w && self.count < self.w + self.h - 1 {\\n            self.pos = vec![self.w - 1, self.count - self.w + 1];\\n            self.idx = 1;\\n        } else if self.count >= self.w + self.h - 1 && self.count < 2 * self.w + self.h - 2 {\\n            self.pos = vec![2 * self.w + self.h - self.count - 3, self.h - 1];\\n            self.idx = 2;\\n        } else {\\n            self.pos = vec![0, 2 * self.h + 2 * self.w - self.count - 4];\\n            self.idx = 3;\\n        }\\n    }\\n\\n    fn get_pos(&self) -> Vec<i32> {\\n        self.pos.clone()\\n    }\\n\\n    fn get_dir(&self) -> String {\\n        self.dir_str[self.idx].clone()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3209968,
                "title": "o-1-math-solution",
                "content": "# Code\\n```\\nclass Robot {\\npublic:\\n    int m, n, pos=0;\\n    bool flag = false;\\n\\n    Robot(int width, int height) {\\n        m = width;\\n        n = height;    \\n    }\\n    \\n    void step(int num) {\\n        pos = (pos + num) % (2*m + 2*n - 4);\\n\\n        if(pos == 0) flag = true;\\n        else flag = false;\\n    }\\n    \\n    vector<int> getPos() {\\n        if(pos <= m-1) return {pos, 0};\\n        if(pos <= m-1+n-1) return {m-1, pos-(m-1)};\\n        if(pos <= 2*(m-1)+n-1) return {2*(m-1)+n-1-pos, n-1};\\n        else return {0, 2*(n-1)+2*(m-1)-pos};\\n    }\\n    \\n    string getDir() {\\n        if(pos <= m-1) return flag ? \"South\" : \"East\";\\n        else if(pos <= m-1+n-1) return \"North\";\\n        else if(pos <= 2*(m-1)+n-1) return \"West\";\\n        else return \"South\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Robot {\\npublic:\\n    int m, n, pos=0;\\n    bool flag = false;\\n\\n    Robot(int width, int height) {\\n        m = width;\\n        n = height;    \\n    }\\n    \\n    void step(int num) {\\n        pos = (pos + num) % (2*m + 2*n - 4);\\n\\n        if(pos == 0) flag = true;\\n        else flag = false;\\n    }\\n    \\n    vector<int> getPos() {\\n        if(pos <= m-1) return {pos, 0};\\n        if(pos <= m-1+n-1) return {m-1, pos-(m-1)};\\n        if(pos <= 2*(m-1)+n-1) return {2*(m-1)+n-1-pos, n-1};\\n        else return {0, 2*(n-1)+2*(m-1)-pos};\\n    }\\n    \\n    string getDir() {\\n        if(pos <= m-1) return flag ? \"South\" : \"East\";\\n        else if(pos <= m-1+n-1) return \"North\";\\n        else if(pos <= 2*(m-1)+n-1) return \"West\";\\n        else return \"South\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3104185,
                "title": "o-1-laps-on-the-edge-initial-direction-edge-case",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe robot only moves around the edge of the grid in counterclockwise laps.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nA lap consists of `2 * (width + height - 2)` steps because the robot doesn\\'t skip a move at the corners.\\n\\nThe current position of the robot can be encoded as a number (`lapSquare`) in the range `[0, lap)`, so to implement `step` we increment by `num` and wrap around with `% lap`.\\n\\nThe function `getPos` decodes this number by checking which edge of the grid it lies on and how far along that edge it travelled.\\n\\nThe direction can be inferred from the position but we need to be careful at the corners. There is an edge case at the initial position when the robot is at `(0, 0)` but facing `\"East\"` while in every following lap the robot will be facing `\"South\"` when it is at `(0, 0)`. We take care of that with the `init` flag.\\n\\n# Complexity\\n- Time complexity: `step`: O(1), `getPos`: O(1), `getDir`: O(1), `__init__`: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Robot:\\n\\n    def __init__(self, width: int, height: int):\\n        self.lapSquare = 0\\n        self.lap = 2 * (width + height - 2)\\n        self.width = width - 1\\n        self.height = height - 1\\n        self.init = True\\n\\n    def step(self, num: int) -> None:\\n        self.lapSquare = (self.lapSquare + num) % self.lap\\n        self.init = False\\n\\n    def getPos(self) -> List[int]:\\n        if self.lapSquare <= self.width:\\n            return [self.lapSquare, 0]\\n        if self.lapSquare <= self.width + self.height:\\n            return [self.width, self.lapSquare - self.width]\\n        if self.lapSquare <= 2 * self.width + self.height:\\n            return [2 * self.width + self.height - self.lapSquare, self.height]\\n        return [0, self.lap - self.lapSquare]\\n        \\n    def getDir(self) -> str:\\n        if self.lapSquare == 0 and not self.init:\\n            return \"South\"\\n        if 0 <= self.lapSquare <= self.width:\\n            return \"East\"\\n        if self.lapSquare <= self.width + self.height:\\n            return \"North\"\\n        if self.lapSquare <= 2 * self.width + self.height:\\n            return \"West\"\\n        return \"South\"\\n\\n# Your Robot object will be instantiated and called as such:\\n# obj = Robot(width, height)\\n# obj.step(num)\\n# param_2 = obj.getPos()\\n# param_3 = obj.getDir()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Robot:\\n\\n    def __init__(self, width: int, height: int):\\n        self.lapSquare = 0\\n        self.lap = 2 * (width + height - 2)\\n        self.width = width - 1\\n        self.height = height - 1\\n        self.init = True\\n\\n    def step(self, num: int) -> None:\\n        self.lapSquare = (self.lapSquare + num) % self.lap\\n        self.init = False\\n\\n    def getPos(self) -> List[int]:\\n        if self.lapSquare <= self.width:\\n            return [self.lapSquare, 0]\\n        if self.lapSquare <= self.width + self.height:\\n            return [self.width, self.lapSquare - self.width]\\n        if self.lapSquare <= 2 * self.width + self.height:\\n            return [2 * self.width + self.height - self.lapSquare, self.height]\\n        return [0, self.lap - self.lapSquare]\\n        \\n    def getDir(self) -> str:\\n        if self.lapSquare == 0 and not self.init:\\n            return \"South\"\\n        if 0 <= self.lapSquare <= self.width:\\n            return \"East\"\\n        if self.lapSquare <= self.width + self.height:\\n            return \"North\"\\n        if self.lapSquare <= 2 * self.width + self.height:\\n            return \"West\"\\n        return \"South\"\\n\\n# Your Robot object will be instantiated and called as such:\\n# obj = Robot(width, height)\\n# obj.step(num)\\n# param_2 = obj.getPos()\\n# param_3 = obj.getDir()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3101615,
                "title": "c",
                "content": "```\\n\\n\\ntypedef struct {\\n    int x ;\\n    int y ;\\n    int cur ;\\n    int w ;\\n    int h ;\\n    int total ;\\n} Robot;\\n\\n\\nRobot* robotCreate(int width, int height) {\\n    Robot* ret = malloc( sizeof(Robot) ) ;\\n    ret->w = width ;\\n    ret->h = height ;\\n    ret->x = 0 ;\\n    ret->y = 0 ;\\n    ret->cur = 0 ;\\n    ret->total = 2*width + 2*height - 4 ;\\n    return ret ;\\n}\\n\\nvoid robotStep(Robot* obj, int num) {\\n     int dirt[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0,-1} } ;\\n     int org_x = obj->x ;\\n     int org_y = obj->y ;\\n     num %= obj->total ;\\n     int flag = num / obj->total ;\\n     int x = obj->x ;\\n     int y = obj->y ;\\n     int w = obj->w ;\\n     int h = obj->h ;\\n     int cur = obj->cur ;\\n     for(int i = 1; i <= num; i++){\\n         x += dirt[cur][0] ;\\n         y += dirt[cur][1] ;\\n         if(x < 0 || x >= obj->w || y < 0 || y >= obj->h){\\n            x -= dirt[cur][0] ;\\n            y -= dirt[cur][1] ; \\n            cur = (cur + 1) % 4 ;\\n            x += dirt[cur][0] ;\\n            y += dirt[cur][1] ;\\n         }\\n     }     \\n     obj->x = x;\\n     obj->y = y;\\n\\n     if(x ==0 && y == 0)\\n         cur = 3 ;\\n     obj->cur = cur ;\\n}\\n\\nint* robotGetPos(Robot* obj, int* retSize) {\\n    int* ret = malloc(2 * sizeof(int)) ;\\n    ret[0] = obj->x ;\\n    ret[1] = obj->y ;\\n    *retSize = 2 ;\\n    return ret ;\\n}\\n\\nchar * robotGetDir(Robot* obj) {\\n    if(obj->cur == 0)\\n        return \"East\" ;\\n    if(obj->cur == 1)\\n        return \"North\" ;\\n    if(obj->cur == 2)\\n        return \"West\" ;\\n    if(obj->cur == 3)\\n        return \"South\" ;\\n    return NULL ;\\n}\\n\\nvoid robotFree(Robot* obj) {\\n    free(obj) ;\\n}\\n\\n/**\\n * Your Robot struct will be instantiated and called as such:\\n * Robot* obj = robotCreate(width, height);\\n * robotStep(obj, num);\\n \\n * int* param_2 = robotGetPos(obj, retSize);\\n \\n * char * param_3 = robotGetDir(obj);\\n \\n * robotFree(obj);\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\ntypedef struct {\\n    int x ;\\n    int y ;\\n    int cur ;\\n    int w ;\\n    int h ;\\n    int total ;\\n} Robot;\\n\\n\\nRobot* robotCreate(int width, int height) {\\n    Robot* ret = malloc( sizeof(Robot) ) ;\\n    ret->w = width ;\\n    ret->h = height ;\\n    ret->x = 0 ;\\n    ret->y = 0 ;\\n    ret->cur = 0 ;\\n    ret->total = 2*width + 2*height - 4 ;\\n    return ret ;\\n}\\n\\nvoid robotStep(Robot* obj, int num) {\\n     int dirt[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0,-1} } ;\\n     int org_x = obj->x ;\\n     int org_y = obj->y ;\\n     num %= obj->total ;\\n     int flag = num / obj->total ;\\n     int x = obj->x ;\\n     int y = obj->y ;\\n     int w = obj->w ;\\n     int h = obj->h ;\\n     int cur = obj->cur ;\\n     for(int i = 1; i <= num; i++){\\n         x += dirt[cur][0] ;\\n         y += dirt[cur][1] ;\\n         if(x < 0 || x >= obj->w || y < 0 || y >= obj->h){\\n            x -= dirt[cur][0] ;\\n            y -= dirt[cur][1] ; \\n            cur = (cur + 1) % 4 ;\\n            x += dirt[cur][0] ;\\n            y += dirt[cur][1] ;\\n         }\\n     }     \\n     obj->x = x;\\n     obj->y = y;\\n\\n     if(x ==0 && y == 0)\\n         cur = 3 ;\\n     obj->cur = cur ;\\n}\\n\\nint* robotGetPos(Robot* obj, int* retSize) {\\n    int* ret = malloc(2 * sizeof(int)) ;\\n    ret[0] = obj->x ;\\n    ret[1] = obj->y ;\\n    *retSize = 2 ;\\n    return ret ;\\n}\\n\\nchar * robotGetDir(Robot* obj) {\\n    if(obj->cur == 0)\\n        return \"East\" ;\\n    if(obj->cur == 1)\\n        return \"North\" ;\\n    if(obj->cur == 2)\\n        return \"West\" ;\\n    if(obj->cur == 3)\\n        return \"South\" ;\\n    return NULL ;\\n}\\n\\nvoid robotFree(Robot* obj) {\\n    free(obj) ;\\n}\\n\\n/**\\n * Your Robot struct will be instantiated and called as such:\\n * Robot* obj = robotCreate(width, height);\\n * robotStep(obj, num);\\n \\n * int* param_2 = robotGetPos(obj, retSize);\\n \\n * char * param_3 = robotGetDir(obj);\\n \\n * robotFree(obj);\\n*/\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3033530,
                "title": "beats-90-on-python",
                "content": "\\n```\\nclass Robot:\\n\\n    def __init__(self, width, height):\\n        \\n        from collections import deque \\n        self.width = height\\n        self.height = width \\n        self.directions=deque([ (0,1) ,(1,0),(0,-1),(-1,0) ])             \\n        self.pos=(0,0)\\n        self.hashmap = {(0,1):\\'East\\',(1,0):\\'North\\',(0,-1):\\'West\\',(-1,0):\\'South\\'}\\n        self.pos_dir,self.distance = {},{}\\n        steps = 0 \\n        self.flag = False\\n\\n        for i in range(2 *(self.width + self.height-2)):\\n            steps +=1\\n            x,y = self.pos \\n            i,j = self.directions[0]\\n            if not 0<=x+i<=self.width -1  or not 0<=y + j <=self.height - 1:self.directions.append(self.directions.popleft())\\n            self.pos = x+self.directions[0][0],y+self.directions[0][-1]\\n            self.pos_dir[steps]=(self.pos,self.hashmap[self.directions[0]])\\n            self.distance[self.pos]=steps\\n        self.pos_dir[0]=((0,0),\\'South\\')\\n        self.distance[0,0]=0\\n\\n    def step(self, num): \\n        if not self.flag:self.flag =  True\\n        num +=self.distance[self.pos]\\n        num=num% (2 *(self.width + self.height-2))\\n        self.pos = self.pos_dir[num][0]\\n\\n    def getPos(self):return self.pos[1],self.pos[0]\\n    def getDir(self):return self.pos_dir[self.distance[self.pos]][1] if self.flag else \\'East\\'\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Robot:\\n\\n    def __init__(self, width, height):\\n        \\n        from collections import deque \\n        self.width = height\\n        self.height = width \\n        self.directions=deque([ (0,1) ,(1,0),(0,-1),(-1,0) ])             \\n        self.pos=(0,0)\\n        self.hashmap = {(0,1):\\'East\\',(1,0):\\'North\\',(0,-1):\\'West\\',(-1,0):\\'South\\'}\\n        self.pos_dir,self.distance = {},{}\\n        steps = 0 \\n        self.flag = False\\n\\n        for i in range(2 *(self.width + self.height-2)):\\n            steps +=1\\n            x,y = self.pos \\n            i,j = self.directions[0]\\n            if not 0<=x+i<=self.width -1  or not 0<=y + j <=self.height - 1:self.directions.append(self.directions.popleft())\\n            self.pos = x+self.directions[0][0],y+self.directions[0][-1]\\n            self.pos_dir[steps]=(self.pos,self.hashmap[self.directions[0]])\\n            self.distance[self.pos]=steps\\n        self.pos_dir[0]=((0,0),\\'South\\')\\n        self.distance[0,0]=0\\n\\n    def step(self, num): \\n        if not self.flag:self.flag =  True\\n        num +=self.distance[self.pos]\\n        num=num% (2 *(self.width + self.height-2))\\n        self.pos = self.pos_dir[num][0]\\n\\n    def getPos(self):return self.pos[1],self.pos[0]\\n    def getDir(self):return self.pos_dir[self.distance[self.pos]][1] if self.flag else \\'East\\'\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3032351,
                "title": "pure-simulation-with-modulo-still-slow-but-simple",
                "content": "\\n```\\nclass Robot:\\n\\n    def __init__(self, width, height):\\n        \\n        from collections import deque \\n        self.width = height\\n        self.height = width \\n        self.directions=deque([ (0,1) ,(1,0),(0,-1),(-1,0) ])             \\n        self.pos=(0,0)\\n        self.hashmap = {(0,1):\\'East\\',(1,0):\\'North\\',(0,-1):\\'West\\',(-1,0):\\'South\\'}\\n\\n    def step(self, num):\\n        num = num % (2 *(self.width + self.height-2))\\n        if not num :num = 2 *(self.width + self.height-2)\\n\\n        for i in range(num):\\n            x,y = self.pos \\n            i,j = self.directions[0]\\n            if not 0<=x+i<=self.width -1  or not 0<=y + j <=self.height - 1:self.directions.append(self.directions.popleft())\\n            self.pos = x+self.directions[0][0],y+self.directions[0][-1]\\n   \\n    def getPos(self):return self.pos[1],self.pos[0]\\n\\n    def getDir(self):return self.hashmap[self.directions[0]]\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Robot:\\n\\n    def __init__(self, width, height):\\n        \\n        from collections import deque \\n        self.width = height\\n        self.height = width \\n        self.directions=deque([ (0,1) ,(1,0),(0,-1),(-1,0) ])             \\n        self.pos=(0,0)\\n        self.hashmap = {(0,1):\\'East\\',(1,0):\\'North\\',(0,-1):\\'West\\',(-1,0):\\'South\\'}\\n\\n    def step(self, num):\\n        num = num % (2 *(self.width + self.height-2))\\n        if not num :num = 2 *(self.width + self.height-2)\\n\\n        for i in range(num):\\n            x,y = self.pos \\n            i,j = self.directions[0]\\n            if not 0<=x+i<=self.width -1  or not 0<=y + j <=self.height - 1:self.directions.append(self.directions.popleft())\\n            self.pos = x+self.directions[0][0],y+self.directions[0][-1]\\n   \\n    def getPos(self):return self.pos[1],self.pos[0]\\n\\n    def getDir(self):return self.hashmap[self.directions[0]]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897707,
                "title": "hahahahah-eight-seconds-100-sometimes-tle-typescript-js",
                "content": "\\n\\n# Code\\n```\\nclass Robot {\\n    protected mapWidth: number;\\n    protected mapHeight: number;\\n    protected currPosition: number[] = [0,0];\\n    protected directions: string[] = [\"East\",\"North\",\"West\",\"South\"];\\n    protected currDirection: number = 0;\\n    // 0 : \"East\"\\n    // 1 : \"North\"\\n    // 2 : \"West\"\\n    // 3 : \"South\"\\n    constructor(width: number, height: number) {\\n        this.mapWidth = width;\\n        this.mapHeight = height;\\n    }\\n\\n    step(num: number): void {\\n        let stepLeft: number = num;\\n        // check directions first\\n        // so we know which coordinate that we need to add\\n        let isMoving: boolean = true;\\n        while (isMoving){\\n            if (this.currDirection === 0 && stepLeft > 0){ // East    \\n                // without loop\\n                if (this.currPosition[0] === this.mapWidth-1){\\n                    this.currDirection += 1;\\n                }else if (this.currPosition[0] + stepLeft <= this.mapWidth-1){\\n                    this.currPosition[0] += stepLeft;\\n                    stepLeft = 0;\\n                }else{\\n                    const left: number = (this.mapWidth-1) - this.currPosition[0];\\n                    this.currPosition[0] = this.mapWidth-1;\\n                    this.currDirection += 1;\\n                    stepLeft -= left;\\n                }\\n                //\\n                // while (stepLeft > 0){ // LOOP : TLE\\n                //     if (this.currPosition[0] === this.mapWidth-1){\\n                //         this.currDirection += 1;\\n                //         break;\\n                //     }\\n                //     // if it not exceed the width\\n                //     this.currPosition[0] += 1;\\n                //     stepLeft -= 1;\\n                // }\\n            }\\n            if (this.currDirection === 1 && stepLeft > 0){ // North\\n                // without loop\\n                if (this.currPosition[1] === this.mapHeight-1){\\n                    this.currDirection += 1;\\n                }else if (this.currPosition[1] + stepLeft <= this.mapHeight-1){\\n                    this.currPosition[1] += stepLeft;\\n                    stepLeft = 0;\\n                }else{\\n                    const left: number = (this.mapHeight-1) - this.currPosition[1];\\n                    this.currPosition[1] = this.mapHeight-1;\\n                    this.currDirection += 1;\\n                    stepLeft -= left;\\n                }\\n                //\\n                // while (stepLeft > 0){ // LOOP : TLE\\n                //     if (this.currPosition[1] === this.mapHeight-1){\\n                //         this.currDirection += 1;\\n                //         break;\\n                //     }\\n                //     this.currPosition[1] += 1;\\n                //     stepLeft -= 1;\\n                // }\\n            }\\n            if (this.currDirection === 2 && stepLeft > 0){ // West\\n                // without loop\\n                if (this.currPosition[0] === 0){\\n                    this.currDirection += 1;\\n                }else if (this.currPosition[0] - stepLeft >= 0){\\n                    this.currPosition[0] -= stepLeft;\\n                    stepLeft = 0;\\n                }else{\\n                    const left: number = this.currPosition[0];\\n                    this.currPosition[0] = 0;\\n                    this.currDirection += 1;\\n                    stepLeft -= left;\\n                }\\n                //\\n                // while (stepLeft > 0){ // LOOP : TLE\\n                //     if (this.currPosition[0] === 0){\\n                //         this.currDirection += 1;\\n                //         break;\\n                //     }\\n                //     this.currPosition[0] -= 1;\\n                //     stepLeft -= 1;\\n                // }\\n            }\\n            if (this.currDirection === 3 && stepLeft > 0){ // South\\n                // without loop\\n                if (this.currPosition[1] === 0){\\n                    this.currDirection = 0;\\n                }else if (this.currPosition[1] - stepLeft >= 0){\\n                    this.currPosition[1] -= stepLeft;\\n                    stepLeft = 0;\\n                }else{\\n                    const left: number = this.currPosition[1];\\n                    this.currPosition[1] = 0;\\n                    this.currDirection = 0;\\n                    stepLeft -= left;\\n                }\\n                //\\n                // while (stepLeft > 0){ // LOOP : TLE\\n                //     if (this.currPosition[1] === 0){\\n                //         this.currDirection = 0;\\n                //         break;\\n                //     }\\n                //     this.currPosition[1] -= 1;\\n                //     stepLeft -= 1;\\n                // }\\n            }\\n            if (stepLeft === 0) isMoving = false;\\n        }\\n        \\n    }\\n\\n    getPos(): number[] {\\n        return this.currPosition;\\n    }\\n\\n    getDir(): string {\\n        return this.directions[this.currDirection];\\n    }\\n}\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * var obj = new Robot(width, height)\\n * obj.step(num)\\n * var param_2 = obj.getPos()\\n * var param_3 = obj.getDir()\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Design",
                    "Simulation"
                ],
                "code": "```\\nclass Robot {\\n    protected mapWidth: number;\\n    protected mapHeight: number;\\n    protected currPosition: number[] = [0,0];\\n    protected directions: string[] = [\"East\",\"North\",\"West\",\"South\"];\\n    protected currDirection: number = 0;\\n    // 0 : \"East\"\\n    // 1 : \"North\"\\n    // 2 : \"West\"\\n    // 3 : \"South\"\\n    constructor(width: number, height: number) {\\n        this.mapWidth = width;\\n        this.mapHeight = height;\\n    }\\n\\n    step(num: number): void {\\n        let stepLeft: number = num;\\n        // check directions first\\n        // so we know which coordinate that we need to add\\n        let isMoving: boolean = true;\\n        while (isMoving){\\n            if (this.currDirection === 0 && stepLeft > 0){ // East    \\n                // without loop\\n                if (this.currPosition[0] === this.mapWidth-1){\\n                    this.currDirection += 1;\\n                }else if (this.currPosition[0] + stepLeft <= this.mapWidth-1){\\n                    this.currPosition[0] += stepLeft;\\n                    stepLeft = 0;\\n                }else{\\n                    const left: number = (this.mapWidth-1) - this.currPosition[0];\\n                    this.currPosition[0] = this.mapWidth-1;\\n                    this.currDirection += 1;\\n                    stepLeft -= left;\\n                }\\n                //\\n                // while (stepLeft > 0){ // LOOP : TLE\\n                //     if (this.currPosition[0] === this.mapWidth-1){\\n                //         this.currDirection += 1;\\n                //         break;\\n                //     }\\n                //     // if it not exceed the width\\n                //     this.currPosition[0] += 1;\\n                //     stepLeft -= 1;\\n                // }\\n            }\\n            if (this.currDirection === 1 && stepLeft > 0){ // North\\n                // without loop\\n                if (this.currPosition[1] === this.mapHeight-1){\\n                    this.currDirection += 1;\\n                }else if (this.currPosition[1] + stepLeft <= this.mapHeight-1){\\n                    this.currPosition[1] += stepLeft;\\n                    stepLeft = 0;\\n                }else{\\n                    const left: number = (this.mapHeight-1) - this.currPosition[1];\\n                    this.currPosition[1] = this.mapHeight-1;\\n                    this.currDirection += 1;\\n                    stepLeft -= left;\\n                }\\n                //\\n                // while (stepLeft > 0){ // LOOP : TLE\\n                //     if (this.currPosition[1] === this.mapHeight-1){\\n                //         this.currDirection += 1;\\n                //         break;\\n                //     }\\n                //     this.currPosition[1] += 1;\\n                //     stepLeft -= 1;\\n                // }\\n            }\\n            if (this.currDirection === 2 && stepLeft > 0){ // West\\n                // without loop\\n                if (this.currPosition[0] === 0){\\n                    this.currDirection += 1;\\n                }else if (this.currPosition[0] - stepLeft >= 0){\\n                    this.currPosition[0] -= stepLeft;\\n                    stepLeft = 0;\\n                }else{\\n                    const left: number = this.currPosition[0];\\n                    this.currPosition[0] = 0;\\n                    this.currDirection += 1;\\n                    stepLeft -= left;\\n                }\\n                //\\n                // while (stepLeft > 0){ // LOOP : TLE\\n                //     if (this.currPosition[0] === 0){\\n                //         this.currDirection += 1;\\n                //         break;\\n                //     }\\n                //     this.currPosition[0] -= 1;\\n                //     stepLeft -= 1;\\n                // }\\n            }\\n            if (this.currDirection === 3 && stepLeft > 0){ // South\\n                // without loop\\n                if (this.currPosition[1] === 0){\\n                    this.currDirection = 0;\\n                }else if (this.currPosition[1] - stepLeft >= 0){\\n                    this.currPosition[1] -= stepLeft;\\n                    stepLeft = 0;\\n                }else{\\n                    const left: number = this.currPosition[1];\\n                    this.currPosition[1] = 0;\\n                    this.currDirection = 0;\\n                    stepLeft -= left;\\n                }\\n                //\\n                // while (stepLeft > 0){ // LOOP : TLE\\n                //     if (this.currPosition[1] === 0){\\n                //         this.currDirection = 0;\\n                //         break;\\n                //     }\\n                //     this.currPosition[1] -= 1;\\n                //     stepLeft -= 1;\\n                // }\\n            }\\n            if (stepLeft === 0) isMoving = false;\\n        }\\n        \\n    }\\n\\n    getPos(): number[] {\\n        return this.currPosition;\\n    }\\n\\n    getDir(): string {\\n        return this.directions[this.currDirection];\\n    }\\n}\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * var obj = new Robot(width, height)\\n * obj.step(num)\\n * var param_2 = obj.getPos()\\n * var param_3 = obj.getDir()\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2861309,
                "title": "o-1-time-and-space-complexity-solution",
                "content": "# Intuition\\nSince the Robot walks only on perimeter, we can convert the rectangle into a line and mark tiles from 0 to P-1\\nP = perimeter = 2 * (width + height - 2)\\n\\n# Approach\\nWhen robot walks N times we add N to a current position and mod by P\\n\\nThen according to it\\'s position on a line we can calculate it\\'s coordinates and which direction it is looking at.\\n\\nEdge case: tile 0, coordinate (0, 0). If robot did not move then it faces \"East\". After it moved, when it comes back to this tile, it faces \"South\"\\n\\n# Complexity\\nEvery function has $$O(1)$$ time complexity \\n\\nEvery function has $$O(1)$$ space complexity \\nThe class has a $$O(1)$$ space complexity\\n\\n# Code\\n```\\nclass Robot {\\n    let width: Int\\n    let height: Int\\n    let per: Int\\n    var pos: Int\\n    var moved: Bool\\n\\n    init(_ width: Int, _ height: Int) {\\n        self.width = width\\n        self.height = height\\n        self.per = 2 * (width + height - 2)\\n        self.pos = 0\\n        self.moved = false\\n    }\\n    \\n    func step(_ num: Int) {\\n        pos = (pos + num) % per\\n        if !moved {moved = true}\\n    }\\n    \\n    func getPos() -> [Int] {\\n        var coord: [Int] = []\\n        \\n        if 0 <= pos && pos < width {\\n            coord = [pos, 0]\\n        } else if width - 1 <= pos && pos < width + height - 1 {\\n            coord = [width - 1, pos - (width-1)]\\n        } else if width + height - 2 <= pos && pos < 2*width + height - 2 {\\n            coord = [(width-1) - (pos - (width + height - 2)) , height - 1]\\n        } else {\\n            coord = [0, (height-1) - (pos - (2*width + height - 3)) ]\\n        }\\n\\n        return coord\\n    }\\n    \\n    func getDir() -> String {\\n        if 1 <= pos && pos < width {\\n            return \"East\"\\n        } else if width <= pos && pos < width + height - 1 {\\n            return \"North\"\\n        } else if  width + height - 1 <= pos && pos <  2 * width + height - 2 {\\n            return \"West\"\\n        } else {\\n            if !moved {return \"East\"}\\n            return \"South\"\\n        }\\n    }\\n}\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * let obj = Robot(width, height)\\n * obj.step(num)\\n * let ret_2: [Int] = obj.getPos()\\n * let ret_3: String = obj.getDir()\\n */\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Robot {\\n    let width: Int\\n    let height: Int\\n    let per: Int\\n    var pos: Int\\n    var moved: Bool\\n\\n    init(_ width: Int, _ height: Int) {\\n        self.width = width\\n        self.height = height\\n        self.per = 2 * (width + height - 2)\\n        self.pos = 0\\n        self.moved = false\\n    }\\n    \\n    func step(_ num: Int) {\\n        pos = (pos + num) % per\\n        if !moved {moved = true}\\n    }\\n    \\n    func getPos() -> [Int] {\\n        var coord: [Int] = []\\n        \\n        if 0 <= pos && pos < width {\\n            coord = [pos, 0]\\n        } else if width - 1 <= pos && pos < width + height - 1 {\\n            coord = [width - 1, pos - (width-1)]\\n        } else if width + height - 2 <= pos && pos < 2*width + height - 2 {\\n            coord = [(width-1) - (pos - (width + height - 2)) , height - 1]\\n        } else {\\n            coord = [0, (height-1) - (pos - (2*width + height - 3)) ]\\n        }\\n\\n        return coord\\n    }\\n    \\n    func getDir() -> String {\\n        if 1 <= pos && pos < width {\\n            return \"East\"\\n        } else if width <= pos && pos < width + height - 1 {\\n            return \"North\"\\n        } else if  width + height - 1 <= pos && pos <  2 * width + height - 2 {\\n            return \"West\"\\n        } else {\\n            if !moved {return \"East\"}\\n            return \"South\"\\n        }\\n    }\\n}\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * let obj = Robot(width, height)\\n * obj.step(num)\\n * let ret_2: [Int] = obj.getPos()\\n * let ret_3: String = obj.getDir()\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831313,
                "title": "js-beats-100-memory-speed",
                "content": "THANKS A LOT to [this explanation](https://leetcode.com/problems/walking-robot-simulation-ii/solutions/1575926/worst-question-ever-java-solution-with-explanation/) of the modular math in the method step(num). Everything else is pretty straight forward if you are comfortable with grid simulations. \\n\\n# Code\\n```\\nclass Robot {\\n    /**\\n    * @param {number} width\\n    * @param {number} height\\n    */\\n    constructor(width, height) {\\n        this.width = width;\\n        this.height = height;\\n\\n        this.direction = 0;\\n        this.directions = [\\'East\\', \\'North\\', \\'West\\', \\'South\\'];\\n        this.directionOffsets = [\\n            [1, 0],  // East\\n            [0, 1],  // North\\n            [-1, 0], // West\\n            [0, -1]  // South\\n        ];\\n\\n        this.position = {\\n            x: 0,\\n            y: 0,\\n        }\\n    }\\n\\n    /** \\n    * @param {number} num\\n    * @return {void}\\n    */\\n    step(num) {\\n        num %= this.width * 2 + this.height * 2 - 4;\\n        if (!num) num = this.width * 2 + this.height * 2 - 4;\\n\\n        for (let _step = 0; _step < num; _step++) \\n            if (this.#inRange())\\n                this.#performStep();\\n            else {\\n                this.#nextDirection();\\n                _step--;\\n            }\\n        \\n    }\\n\\n    /**\\n    * @return {number[]}\\n    */\\n    getPos() {\\n        return [this.position.x, this.position.y];\\n    }\\n\\n    /**\\n    * @return {string}\\n    */\\n    getDir() {\\n        return this.directions[this.direction];\\n    }\\n\\n    #move() {\\n        return this.directionOffsets[this.direction];\\n    }\\n\\n    #inRange() {\\n        const [xOff, yOff] = this.#move();\\n        const x = this.position.x + xOff, \\n              y = this.position.y + yOff;\\n\\n        return (\\n            x > -1 && x < this.width &&\\n            y > -1 && y < this.height \\n        );\\n    }\\n\\n    #performStep() {\\n        const [xOff, yOff] = this.#move();\\n        this.position.x += xOff;\\n        this.position.y += yOff;\\n    }\\n\\n    #nextDirection() {\\n        this.direction++;\\n        if (this.direction >= this.directions.length)\\n            this.direction = 0;\\n    }\\n}\\n\\n/** \\n * Your Robot object will be instantiated and called as such:\\n * var obj = new Robot(width, height)\\n * obj.step(num)\\n * var param_2 = obj.getPos()\\n * var param_3 = obj.getDir()\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Robot {\\n    /**\\n    * @param {number} width\\n    * @param {number} height\\n    */\\n    constructor(width, height) {\\n        this.width = width;\\n        this.height = height;\\n\\n        this.direction = 0;\\n        this.directions = [\\'East\\', \\'North\\', \\'West\\', \\'South\\'];\\n        this.directionOffsets = [\\n            [1, 0],  // East\\n            [0, 1],  // North\\n            [-1, 0], // West\\n            [0, -1]  // South\\n        ];\\n\\n        this.position = {\\n            x: 0,\\n            y: 0,\\n        }\\n    }\\n\\n    /** \\n    * @param {number} num\\n    * @return {void}\\n    */\\n    step(num) {\\n        num %= this.width * 2 + this.height * 2 - 4;\\n        if (!num) num = this.width * 2 + this.height * 2 - 4;\\n\\n        for (let _step = 0; _step < num; _step++) \\n            if (this.#inRange())\\n                this.#performStep();\\n            else {\\n                this.#nextDirection();\\n                _step--;\\n            }\\n        \\n    }\\n\\n    /**\\n    * @return {number[]}\\n    */\\n    getPos() {\\n        return [this.position.x, this.position.y];\\n    }\\n\\n    /**\\n    * @return {string}\\n    */\\n    getDir() {\\n        return this.directions[this.direction];\\n    }\\n\\n    #move() {\\n        return this.directionOffsets[this.direction];\\n    }\\n\\n    #inRange() {\\n        const [xOff, yOff] = this.#move();\\n        const x = this.position.x + xOff, \\n              y = this.position.y + yOff;\\n\\n        return (\\n            x > -1 && x < this.width &&\\n            y > -1 && y < this.height \\n        );\\n    }\\n\\n    #performStep() {\\n        const [xOff, yOff] = this.#move();\\n        this.position.x += xOff;\\n        this.position.y += yOff;\\n    }\\n\\n    #nextDirection() {\\n        this.direction++;\\n        if (this.direction >= this.directions.length)\\n            this.direction = 0;\\n    }\\n}\\n\\n/** \\n * Your Robot object will be instantiated and called as such:\\n * var obj = new Robot(width, height)\\n * obj.step(num)\\n * var param_2 = obj.getPos()\\n * var param_3 = obj.getDir()\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779718,
                "title": "javascript-cool-kids-can-do-the-robot",
                "content": "```\\nvar Robot = function(width, height) {\\n    this.wid = width;\\n    this.hgt = height;\\n    this.perimeter = width*2 + height*2 - 4;\\n    this.x = 0;\\n    this.y = 0;\\n    this.dirn = 0;\\n    this.dir = [1,0];\\n    this.dirs = [ [1,0], [0,1], [-1,0], [0,-1] ];\\n};\\n\\nRobot.prototype.step = function(num) {\\n    while( num > 0 ) {\\n        if( this.y + this.dir[1]*num >= this.hgt ||\\n            this.y + this.dir[1]*num < 0 ||\\n            this.x + this.dir[0]*num >= this.wid ||\\n            this.x + this.dir[0]*num < 0 ) {\\n            \\n            var steps;\\n            \\n            switch( this.dirn ) {\\n                case 0: // east\\n                    steps = this.wid-1 - this.x;\\n                    this.x = this.wid-1;\\n                    break;\\n                case 1: // north\\n                    steps = this.hgt-1 - this.y;\\n                    this.y = this.hgt-1;\\n                    break;\\n                case 2: // west\\n                    steps = this.x;\\n                    this.x = 0;\\n                    break;\\n                case 3:\\n                    steps = this.y;\\n                    this.y = 0;\\n                    break;\\n            }\\n            \\n            num -= steps;\\n            this.dirn = (this.dirn+1)%4;\\n            if( num >= this.perimeter && steps != 0 ) {\\n                num = num % this.perimeter;\\n                \\n                if( this.x == 0 && this.y == 0 ) this.dirn = 3;\\n                else if( this.x == 0 && this.y == this.hgt-1 ) this.dirn = 2;\\n                else if( this.x == this.wid-1 && this.y == 0 ) this.dirn = 0;\\n                else if( this.x == this.wid-1 && this.y == this.hgt-1 ) this.dirn = 1;\\n                \\n            }\\n            this.dir = this.dirs[this.dirn];\\n        } else {\\n            this.x += this.dir[0]*num;\\n            this.y += this.dir[1]*num;\\n            num = 0;\\n        }\\n    }\\n};\\n\\nRobot.prototype.getPos = function() {\\n    return [this.x, this.y];\\n};\\n\\nRobot.prototype.getDir = function() {\\n    return [\"East\", \"North\", \"West\", \"South\"][this.dirn];\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar Robot = function(width, height) {\\n    this.wid = width;\\n    this.hgt = height;\\n    this.perimeter = width*2 + height*2 - 4;\\n    this.x = 0;\\n    this.y = 0;\\n    this.dirn = 0;\\n    this.dir = [1,0];\\n    this.dirs = [ [1,0], [0,1], [-1,0], [0,-1] ];\\n};\\n\\nRobot.prototype.step = function(num) {\\n    while( num > 0 ) {\\n        if( this.y + this.dir[1]*num >= this.hgt ||\\n            this.y + this.dir[1]*num < 0 ||\\n            this.x + this.dir[0]*num >= this.wid ||\\n            this.x + this.dir[0]*num < 0 ) {\\n            \\n            var steps;\\n            \\n            switch( this.dirn ) {\\n                case 0: // east\\n                    steps = this.wid-1 - this.x;\\n                    this.x = this.wid-1;\\n                    break;\\n                case 1: // north\\n                    steps = this.hgt-1 - this.y;\\n                    this.y = this.hgt-1;\\n                    break;\\n                case 2: // west\\n                    steps = this.x;\\n                    this.x = 0;\\n                    break;\\n                case 3:\\n                    steps = this.y;\\n                    this.y = 0;\\n                    break;\\n            }\\n            \\n            num -= steps;\\n            this.dirn = (this.dirn+1)%4;\\n            if( num >= this.perimeter && steps != 0 ) {\\n                num = num % this.perimeter;\\n                \\n                if( this.x == 0 && this.y == 0 ) this.dirn = 3;\\n                else if( this.x == 0 && this.y == this.hgt-1 ) this.dirn = 2;\\n                else if( this.x == this.wid-1 && this.y == 0 ) this.dirn = 0;\\n                else if( this.x == this.wid-1 && this.y == this.hgt-1 ) this.dirn = 1;\\n                \\n            }\\n            this.dir = this.dirs[this.dirn];\\n        } else {\\n            this.x += this.dir[0]*num;\\n            this.y += this.dir[1]*num;\\n            num = 0;\\n        }\\n    }\\n};\\n\\nRobot.prototype.getPos = function() {\\n    return [this.x, this.y];\\n};\\n\\nRobot.prototype.getDir = function() {\\n    return [\"East\", \"North\", \"West\", \"South\"][this.dirn];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2759422,
                "title": "golang-formula",
                "content": "```\\ntype Robot struct {\\n\\tstarted   bool\\n\\tcircleLen int\\n\\tcurrPoint int\\n\\tw, h      int\\n}\\n\\nfunc Constructor(width int, height int) Robot {\\n\\tcircleLen := 2*width + (height-2)*2\\n\\n\\treturn Robot{\\n\\t\\tstarted:   false,\\n\\t\\tcircleLen: circleLen,\\n\\t\\tcurrPoint: 0,\\n\\t\\tw:         width,\\n\\t\\th:         height,\\n\\t}\\n}\\n\\nfunc (r *Robot) Step(num int) {\\n\\tif num > 0 {\\n\\t\\tr.started = true\\n\\t}\\n\\n\\tr.currPoint = (r.currPoint + num) % r.circleLen\\n}\\n\\nfunc (r *Robot) GetPos() []int {\\n\\tswitch {\\n\\tcase r.currPoint < r.w:\\n\\t\\treturn []int{r.currPoint, 0}\\n\\tcase r.currPoint < r.w+r.h-2:\\n\\t\\treturn []int{r.w - 1, r.currPoint - r.w + 1}\\n\\tcase r.currPoint < 2*r.w+r.h-2:\\n\\t\\treturn []int{r.w - (r.currPoint - r.w - (r.h - 2) + 1), r.h - 1}\\n\\tdefault:\\n\\t\\treturn []int{0, r.h - (r.currPoint - 2*r.w - (r.h - 2) + 2)}\\n\\t}\\n}\\n\\nfunc (r *Robot) GetDir() string {\\n\\tif !r.started {\\n\\t\\treturn \"East\"\\n\\t}\\n\\n\\tswitch {\\n\\tcase r.currPoint == 0:\\n\\t\\treturn \"South\"\\n\\tcase r.currPoint < r.w:\\n\\t\\treturn \"East\"\\n\\tcase r.currPoint < r.w+r.h-1:\\n\\t\\treturn \"North\"\\n\\tcase r.currPoint < 2*r.w+r.h-2:\\n\\t\\treturn \"West\"\\n\\tdefault:\\n\\t\\treturn \"South\"\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype Robot struct {\\n\\tstarted   bool\\n\\tcircleLen int\\n\\tcurrPoint int\\n\\tw, h      int\\n}\\n\\nfunc Constructor(width int, height int) Robot {\\n\\tcircleLen := 2*width + (height-2)*2\\n\\n\\treturn Robot{\\n\\t\\tstarted:   false,\\n\\t\\tcircleLen: circleLen,\\n\\t\\tcurrPoint: 0,\\n\\t\\tw:         width,\\n\\t\\th:         height,\\n\\t}\\n}\\n\\nfunc (r *Robot) Step(num int) {\\n\\tif num > 0 {\\n\\t\\tr.started = true\\n\\t}\\n\\n\\tr.currPoint = (r.currPoint + num) % r.circleLen\\n}\\n\\nfunc (r *Robot) GetPos() []int {\\n\\tswitch {\\n\\tcase r.currPoint < r.w:\\n\\t\\treturn []int{r.currPoint, 0}\\n\\tcase r.currPoint < r.w+r.h-2:\\n\\t\\treturn []int{r.w - 1, r.currPoint - r.w + 1}\\n\\tcase r.currPoint < 2*r.w+r.h-2:\\n\\t\\treturn []int{r.w - (r.currPoint - r.w - (r.h - 2) + 1), r.h - 1}\\n\\tdefault:\\n\\t\\treturn []int{0, r.h - (r.currPoint - 2*r.w - (r.h - 2) + 2)}\\n\\t}\\n}\\n\\nfunc (r *Robot) GetDir() string {\\n\\tif !r.started {\\n\\t\\treturn \"East\"\\n\\t}\\n\\n\\tswitch {\\n\\tcase r.currPoint == 0:\\n\\t\\treturn \"South\"\\n\\tcase r.currPoint < r.w:\\n\\t\\treturn \"East\"\\n\\tcase r.currPoint < r.w+r.h-1:\\n\\t\\treturn \"North\"\\n\\tcase r.currPoint < 2*r.w+r.h-2:\\n\\t\\treturn \"West\"\\n\\tdefault:\\n\\t\\treturn \"South\"\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2715247,
                "title": "python-simple-maths",
                "content": "\\n    def __init__(self, width, height):\\n        self.x = width-1\\n        self.y = height-1\\n        self.perimeter = self.x + self.y + self.x + self.y\\n        self.pos = 0\\n        self.first_step = 0\\n        \\n    def step(self, num):\\n        self.first_step = 1\\n        num = num%self.perimeter\\n        self.pos += num\\n        self.pos = self.pos%self.perimeter\\n        \\n    def getPos(self):\\n        if self.pos <= self.x: return [self.pos,0]\\n        elif self.pos <= self.x + self.y: return [self.x,self.pos-self.x]\\n        elif self.pos <= self.x + self.y + self.x: return [self.x+self.y+self.x-self.pos,self.y]\\n        else: return [0, self.x+self.y+self.x+self.y-self.pos]\\n\\n    def getDir(self):\\n        if self.pos == 0 and self.first_step: return \"South\"\\n        \\n        if self.pos <= self.x: return \"East\"\\n        elif self.pos <= self.x + self.y: return \"North\"\\n        elif self.pos <= self.x + self.y + self.x: return \"West\"\\n        else: return \"South\"\\n",
                "solutionTags": [],
                "code": "\\n    def __init__(self, width, height):\\n        self.x = width-1\\n        self.y = height-1\\n        self.perimeter = self.x + self.y + self.x + self.y\\n        self.pos = 0\\n        self.first_step = 0\\n        \\n    def step(self, num):\\n        self.first_step = 1\\n        num = num%self.perimeter\\n        self.pos += num\\n        self.pos = self.pos%self.perimeter\\n        \\n    def getPos(self):\\n        if self.pos <= self.x: return [self.pos,0]\\n        elif self.pos <= self.x + self.y: return [self.x,self.pos-self.x]\\n        elif self.pos <= self.x + self.y + self.x: return [self.x+self.y+self.x-self.pos,self.y]\\n        else: return [0, self.x+self.y+self.x+self.y-self.pos]\\n\\n    def getDir(self):\\n        if self.pos == 0 and self.first_step: return \"South\"\\n        \\n        if self.pos <= self.x: return \"East\"\\n        elif self.pos <= self.x + self.y: return \"North\"\\n        elif self.pos <= self.x + self.y + self.x: return \"West\"\\n        else: return \"South\"\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2590019,
                "title": "golang-solution-simulation",
                "content": "```go\\ntype Robot struct {\\n    w int\\n    h int\\n    x int\\n    y int\\n    d int // E, N, W, S\\n}\\n\\n\\nvar DIRS = [][]int{{1, 0}, {0, 1}, {-1, 0}, {0, -1}}\\nvar DIRStr = []string{\"East\", \"North\", \"West\", \"South\"}\\n\\nfunc Constructor(width int, height int) Robot {\\n    return Robot {\\n        w: width,\\n        h: height,\\n        x: 0,\\n        y: 0,\\n        d: 0,\\n    }\\n}\\n\\n\\nfunc (this *Robot) Step(num int)  {\\n    num = num % ((this.h - 1) * 2 + (this.w - 1) * 2)\\n    if num == 0 && this.x == 0 && this.y == 0 {\\n        // init, this.d = 0, East direction\\n        // after walking a cycle, the direction is South\\n        this.d = 3\\n    }\\n    this.x, this.y = this.x + DIRS[this.d][0] * num, this.y + DIRS[this.d][1] * num\\n    \\n    if this.x >= 0 && this.x < this.w && this.y >= 0 && this.y < this.h {\\n        return\\n    }\\n    \\n    rs := 0\\n    if this.x < 0 {\\n        rs = -this.x\\n        this.x = 0\\n    } else if this.y < 0 {\\n        rs = -this.y\\n        this.y = 0\\n    } else if this.x >= this.w {\\n        rs = this.x - this.w + 1\\n        this.x = this.w - 1\\n\\n    } else if this.y >= this.h {\\n        rs = this.y - this.h + 1\\n        this.y = this.h - 1\\n    }\\n    \\n    if rs > 0 {\\n        this.d = (this.d + 1) % 4\\n        this.Step(rs)\\n    }\\n}\\n\\n\\nfunc (this *Robot) GetPos() []int {\\n    return []int{this.x, this.y}\\n}\\n\\n\\nfunc (this *Robot) GetDir() string {\\n    return DIRStr[this.d]\\n}\\n\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * obj := Constructor(width, height);\\n * obj.Step(num);\\n * param_2 := obj.GetPos();\\n * param_3 := obj.GetDir();\\n */\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\ntype Robot struct {\\n    w int\\n    h int\\n    x int\\n    y int\\n    d int // E, N, W, S\\n}\\n\\n\\nvar DIRS = [][]int{{1, 0}, {0, 1}, {-1, 0}, {0, -1}}\\nvar DIRStr = []string{\"East\", \"North\", \"West\", \"South\"}\\n\\nfunc Constructor(width int, height int) Robot {\\n    return Robot {\\n        w: width,\\n        h: height,\\n        x: 0,\\n        y: 0,\\n        d: 0,\\n    }\\n}\\n\\n\\nfunc (this *Robot) Step(num int)  {\\n    num = num % ((this.h - 1) * 2 + (this.w - 1) * 2)\\n    if num == 0 && this.x == 0 && this.y == 0 {\\n        // init, this.d = 0, East direction\\n        // after walking a cycle, the direction is South\\n        this.d = 3\\n    }\\n    this.x, this.y = this.x + DIRS[this.d][0] * num, this.y + DIRS[this.d][1] * num\\n    \\n    if this.x >= 0 && this.x < this.w && this.y >= 0 && this.y < this.h {\\n        return\\n    }\\n    \\n    rs := 0\\n    if this.x < 0 {\\n        rs = -this.x\\n        this.x = 0\\n    } else if this.y < 0 {\\n        rs = -this.y\\n        this.y = 0\\n    } else if this.x >= this.w {\\n        rs = this.x - this.w + 1\\n        this.x = this.w - 1\\n\\n    } else if this.y >= this.h {\\n        rs = this.y - this.h + 1\\n        this.y = this.h - 1\\n    }\\n    \\n    if rs > 0 {\\n        this.d = (this.d + 1) % 4\\n        this.Step(rs)\\n    }\\n}\\n\\n\\nfunc (this *Robot) GetPos() []int {\\n    return []int{this.x, this.y}\\n}\\n\\n\\nfunc (this *Robot) GetDir() string {\\n    return DIRStr[this.d]\\n}\\n\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * obj := Constructor(width, height);\\n * obj.Step(num);\\n * param_2 := obj.GetPos();\\n * param_3 := obj.GetDir();\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2567398,
                "title": "java-store-the-positions-optimized-solution",
                "content": "```\\nclass Robot {\\n    private int[][] dp ;\\n    private int[] position ;\\n    private boolean moved ;\\n    private int tracer, width, height ;\\n    \\n    public Robot(int width, int height) {\\n        dp = new int [(width + height - 2) * 2][2] ;\\n        position = new int [2] ;\\n        moved = false ;\\n        tracer = 0 ;\\n        this.width = width ;\\n        this.height = height ;\\n        int k = 0 ;\\n        \\n        for (int i = 0; i < width; i++) {\\n            dp[k][0] = i ;\\n            dp[k++][1] = 0 ;\\n        }\\n        for (int i = 1; i < height; i++) {\\n            dp[k][0] = width-1 ;\\n            dp[k++][1] = i ;\\n        }\\n        for (int i = width-2; i >= 0; i--) {\\n            dp[k][0] = i ;\\n            dp[k++][1] = height-1 ;\\n        }\\n        for (int i = height-2; i > 0; i--) {\\n            dp[k][0] = 0 ;\\n            dp[k++][1] = i ;\\n        }\\n    }\\n    \\n    public void step(int num) {\\n        moved = true ;\\n        num %= dp.length ;\\n        tracer = (tracer + num) % dp.length ;\\n        position[0] = dp[tracer][0] ;\\n        position[1] = dp[tracer][1] ;\\n    }\\n    \\n    public int[] getPos() {\\n        return position ;\\n    }\\n    \\n    public String getDir() {\\n        if (!moved) return \"East\" ;\\n        if (position[0] >= 1 && position[0] < width && position[1] == 0) return \"East\" ;\\n        if (position[0] >= 0 && position[0] < width-1 && position[1] == height-1) return \"West\" ;\\n        if (position[0] == width-1 && position[1] >= 1 && position[1] < height) return \"North\" ;\\n        return \"South\" ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Robot {\\n    private int[][] dp ;\\n    private int[] position ;\\n    private boolean moved ;\\n    private int tracer, width, height ;\\n    \\n    public Robot(int width, int height) {\\n        dp = new int [(width + height - 2) * 2][2] ;\\n        position = new int [2] ;\\n        moved = false ;\\n        tracer = 0 ;\\n        this.width = width ;\\n        this.height = height ;\\n        int k = 0 ;\\n        \\n        for (int i = 0; i < width; i++) {\\n            dp[k][0] = i ;\\n            dp[k++][1] = 0 ;\\n        }\\n        for (int i = 1; i < height; i++) {\\n            dp[k][0] = width-1 ;\\n            dp[k++][1] = i ;\\n        }\\n        for (int i = width-2; i >= 0; i--) {\\n            dp[k][0] = i ;\\n            dp[k++][1] = height-1 ;\\n        }\\n        for (int i = height-2; i > 0; i--) {\\n            dp[k][0] = 0 ;\\n            dp[k++][1] = i ;\\n        }\\n    }\\n    \\n    public void step(int num) {\\n        moved = true ;\\n        num %= dp.length ;\\n        tracer = (tracer + num) % dp.length ;\\n        position[0] = dp[tracer][0] ;\\n        position[1] = dp[tracer][1] ;\\n    }\\n    \\n    public int[] getPos() {\\n        return position ;\\n    }\\n    \\n    public String getDir() {\\n        if (!moved) return \"East\" ;\\n        if (position[0] >= 1 && position[0] < width && position[1] == 0) return \"East\" ;\\n        if (position[0] >= 0 && position[0] < width-1 && position[1] == height-1) return \"West\" ;\\n        if (position[0] == width-1 && position[1] >= 1 && position[1] < height) return \"North\" ;\\n        return \"South\" ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424135,
                "title": "python-very-easy-to-understand",
                "content": "```\\nclass Robot:\\n\\n    def __init__(self, w: int, h: int):\\n\\n        self.build = {0:[[0, 0], \\'e\\']}\\n        self.moves = 0\\n        self.isMoved = False\\n        \\n        x, y = 1, 0\\n        d = \\'e\\'\\n        count = 1\\n        while x or y:\\n            \\n            self.build[count] = [[x, y], d]\\n            \\n            \\n            if x == w - 1 and d == \\'e\\':\\n                d = \\'n\\'\\n            if y == h - 1 and d == \\'n\\':\\n                d = \\'w\\'\\n            if x == 0 and d == \\'w\\':\\n                d = \\'s\\'\\n  \\n            \\n            \\n            if d == \\'e\\':\\n                x += 1\\n                \\n            if d == \\'n\\':\\n                y += 1\\n            if d == \\'w\\':\\n                x -= 1\\n            if d == \\'s\\':\\n                y -= 1\\n            \\n            count += 1\\n        \\n        # print(self.build)\\n    \\n\\n    def step(self, num: int) -> None:\\n        self.isMoved = True\\n        self.moves += num\\n        self.moves %= len(self.build)\\n \\n    def getPos(self) -> List[int]:\\n        \\n        pos, d = self.build[self.moves]\\n        \\n        return pos\\n        \\n\\n    def getDir(self) -> str:\\n        \\n        pos, d = self.build[self.moves]\\n        \\n        dirMap = {\\'e\\':\\'East\\', \\'n\\': \\'North\\', \\'s\\':\"South\", \\'w\\': \\'West\\'}\\n        \\n        \\n        if self.isMoved and self.moves == 0:\\n            return \\'South\\'\\n        \\n        return dirMap[d]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Hash Table"
                ],
                "code": "```\\nclass Robot:\\n\\n    def __init__(self, w: int, h: int):\\n\\n        self.build = {0:[[0, 0], \\'e\\']}\\n        self.moves = 0\\n        self.isMoved = False\\n        \\n        x, y = 1, 0\\n        d = \\'e\\'\\n        count = 1\\n        while x or y:\\n            \\n            self.build[count] = [[x, y], d]\\n            \\n            \\n            if x == w - 1 and d == \\'e\\':\\n                d = \\'n\\'\\n            if y == h - 1 and d == \\'n\\':\\n                d = \\'w\\'\\n            if x == 0 and d == \\'w\\':\\n                d = \\'s\\'\\n  \\n            \\n            \\n            if d == \\'e\\':\\n                x += 1\\n                \\n            if d == \\'n\\':\\n                y += 1\\n            if d == \\'w\\':\\n                x -= 1\\n            if d == \\'s\\':\\n                y -= 1\\n            \\n            count += 1\\n        \\n        # print(self.build)\\n    \\n\\n    def step(self, num: int) -> None:\\n        self.isMoved = True\\n        self.moves += num\\n        self.moves %= len(self.build)\\n \\n    def getPos(self) -> List[int]:\\n        \\n        pos, d = self.build[self.moves]\\n        \\n        return pos\\n        \\n\\n    def getDir(self) -> str:\\n        \\n        pos, d = self.build[self.moves]\\n        \\n        dirMap = {\\'e\\':\\'East\\', \\'n\\': \\'North\\', \\'s\\':\"South\", \\'w\\': \\'West\\'}\\n        \\n        \\n        if self.isMoved and self.moves == 0:\\n            return \\'South\\'\\n        \\n        return dirMap[d]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2301850,
                "title": "100-less-memory-js",
                "content": "```\\n/**\\n * @param {number} width\\n * @param {number} height\\n */\\n\\nclass Robot {\\n    constructor(width, height) {\\n        this.width = width;\\n        this.height = height;\\n        this.x = 0;\\n        this.y = 0;\\n        this.dir = \"East\"\\n\\n        this.directionMap = {\\n            \"North\": (num) => {\\n                if(this.y + num > this.height - 1) {\\n                    this.dir = \"West\"\\n                    let currentY = this.y\\n                    this.y = this.height - 1\\n                    this.move((num  + currentY) - this.y)\\n                } else {\\n                    this.y = Math.min(this.y + num, this.height - 1)\\n                }\\n            },\\n            \"East\": (num) => {\\n                if(this.x + num > this.width - 1) {\\n                    this.dir = \"North\"\\n                    let currentX = this.x\\n                    this.x = this.width - 1\\n                    this.move((num  + currentX) - this.x)\\n                } else {\\n                    this.x = Math.min(this.x + num, this.width - 1)\\n                }\\n               \\n            }, \"South\": (num) => {\\n                if(this.y - num < 0) {\\n                    this.dir = \"East\"\\n                    let currentY = this.y\\n                    this.y = 0\\n                    this.move(num  - currentY)\\n                } else {\\n                    this.y = Math.max(this.y - num, 0)\\n                }\\n               \\n            }, \"West\": (num) => {\\n                if(this.x - num < 0) {\\n                    this.dir = \"South\"\\n                    let currentX = this.x\\n                    this.x = 0\\n                    this.move(num - currentX)\\n                } else {\\n                    this.x = Math.max(this.x - num, 0);\\n                }\\n                \\n            }\\n        }\\n    }\\n\\n    step = function (num) {\\n\\n        let count = this.howManyStepsNeedForCameBack();\\n        if(count < num) {\\n            const newNum = num - Math.trunc(num / count) * count \\n            this.move(newNum)\\n        } else if (count === num){\\n            // DO NOTHING ..\\n        } else {\\n            this.move(num);\\n        }\\n    };\\n\\n    move = num => {\\n        this.directionMap[this.dir](num)\\n    }\\n\\n    /**\\n     * @return {number[]}\\n     */\\n    getPos = function () {\\n        return [this.x, this.y];\\n    };\\n\\n    /**\\n     * @return {string}\\n     */\\n    getDir = function () {\\n        return this.dir;\\n    };\\n\\n    print = () => {\\n        console.log(this.getPos(), this.dir);\\n    }\\n\\n    posAreDifferent = pos => {\\n        return pos[0] != this.x || pos[1] != this.y\\n    }\\n\\n    howManyStepsNeedForCameBack = () => {\\n\\n        if(this.width <= 1 && this.height <= 1){\\n            return 0;\\n        }\\n\\n        let currentPos = this.getPos();\\n        this.move(1);\\n        let count = 1\\n        while(this.posAreDifferent(currentPos)){\\n            this.move(1);\\n            count++\\n        }\\n        return count;\\n    }\\n\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} width\\n * @param {number} height\\n */\\n\\nclass Robot {\\n    constructor(width, height) {\\n        this.width = width;\\n        this.height = height;\\n        this.x = 0;\\n        this.y = 0;\\n        this.dir = \"East\"\\n\\n        this.directionMap = {\\n            \"North\": (num) => {\\n                if(this.y + num > this.height - 1) {\\n                    this.dir = \"West\"\\n                    let currentY = this.y\\n                    this.y = this.height - 1\\n                    this.move((num  + currentY) - this.y)\\n                } else {\\n                    this.y = Math.min(this.y + num, this.height - 1)\\n                }\\n            },\\n            \"East\": (num) => {\\n                if(this.x + num > this.width - 1) {\\n                    this.dir = \"North\"\\n                    let currentX = this.x\\n                    this.x = this.width - 1\\n                    this.move((num  + currentX) - this.x)\\n                } else {\\n                    this.x = Math.min(this.x + num, this.width - 1)\\n                }\\n               \\n            }, \"South\": (num) => {\\n                if(this.y - num < 0) {\\n                    this.dir = \"East\"\\n                    let currentY = this.y\\n                    this.y = 0\\n                    this.move(num  - currentY)\\n                } else {\\n                    this.y = Math.max(this.y - num, 0)\\n                }\\n               \\n            }, \"West\": (num) => {\\n                if(this.x - num < 0) {\\n                    this.dir = \"South\"\\n                    let currentX = this.x\\n                    this.x = 0\\n                    this.move(num - currentX)\\n                } else {\\n                    this.x = Math.max(this.x - num, 0);\\n                }\\n                \\n            }\\n        }\\n    }\\n\\n    step = function (num) {\\n\\n        let count = this.howManyStepsNeedForCameBack();\\n        if(count < num) {\\n            const newNum = num - Math.trunc(num / count) * count \\n            this.move(newNum)\\n        } else if (count === num){\\n            // DO NOTHING ..\\n        } else {\\n            this.move(num);\\n        }\\n    };\\n\\n    move = num => {\\n        this.directionMap[this.dir](num)\\n    }\\n\\n    /**\\n     * @return {number[]}\\n     */\\n    getPos = function () {\\n        return [this.x, this.y];\\n    };\\n\\n    /**\\n     * @return {string}\\n     */\\n    getDir = function () {\\n        return this.dir;\\n    };\\n\\n    print = () => {\\n        console.log(this.getPos(), this.dir);\\n    }\\n\\n    posAreDifferent = pos => {\\n        return pos[0] != this.x || pos[1] != this.y\\n    }\\n\\n    howManyStepsNeedForCameBack = () => {\\n\\n        if(this.width <= 1 && this.height <= 1){\\n            return 0;\\n        }\\n\\n        let currentPos = this.getPos();\\n        this.move(1);\\n        let count = 1\\n        while(this.posAreDifferent(currentPos)){\\n            this.move(1);\\n            count++\\n        }\\n        return count;\\n    }\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2285298,
                "title": "c-save-circular-distance-to-0-0",
                "content": "```\\n//save the circular distance to (0,0), because robot always circular around on the side in counter-clockwise direction\\n//with this distance we can find out which row/column robot at\\nclass Robot {\\npublic:\\n    Robot(int width, int height): w(width),h(height) { }\\n\\n    void step(int num) {\\n        int round = 2 * w + 2 * (h - 2);\\n        pos = (pos + num) % round;  //update circular distance from (0,0)\\n        started = true;\\n    }\\n\\n    vector<int> getPos() {\\n        if (pos < w)              return { pos, 0 };\\n        if (pos < w + h - 1)      return { w - 1, pos - (w - 1) };\\n        if (pos < 2 * w + h - 2)  return { 2 * w + h - 2 - (pos + 1), h - 1 };\\n        \\n        return { 0, 2 * w + 2 * (h - 2) - pos };\\n    }\\n\\n    string getDir() {\\n        if (!started)     return \"East\";\\n        if(pos==0)        return \"South\";\\n        if(pos<w)         return \"East\";\\n        if(pos<w+h-1)     return \"North\";\\n        if(pos<2*w+h-2)   return \"West\";\\n\\n        return \"South\";\\n    }\\nprivate:\\n    int w = 0;\\n    int h = 0;\\n    int pos = 0; //circular distance from (0,0)\\n    bool started = false;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//save the circular distance to (0,0), because robot always circular around on the side in counter-clockwise direction\\n//with this distance we can find out which row/column robot at\\nclass Robot {\\npublic:\\n    Robot(int width, int height): w(width),h(height) { }\\n\\n    void step(int num) {\\n        int round = 2 * w + 2 * (h - 2);\\n        pos = (pos + num) % round;  //update circular distance from (0,0)\\n        started = true;\\n    }\\n\\n    vector<int> getPos() {\\n        if (pos < w)              return { pos, 0 };\\n        if (pos < w + h - 1)      return { w - 1, pos - (w - 1) };\\n        if (pos < 2 * w + h - 2)  return { 2 * w + h - 2 - (pos + 1), h - 1 };\\n        \\n        return { 0, 2 * w + 2 * (h - 2) - pos };\\n    }\\n\\n    string getDir() {\\n        if (!started)     return \"East\";\\n        if(pos==0)        return \"South\";\\n        if(pos<w)         return \"East\";\\n        if(pos<w+h-1)     return \"North\";\\n        if(pos<2*w+h-2)   return \"West\";\\n\\n        return \"South\";\\n    }\\nprivate:\\n    int w = 0;\\n    int h = 0;\\n    int pos = 0; //circular distance from (0,0)\\n    bool started = false;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2281187,
                "title": "while-loop-only-java-small-trick",
                "content": "```\\nclass Robot {\\n    // east = 0; north = 1; west = 2; south = 3;\\n    int rows, cols, x, y, currentFacing = 0;\\n    int[][] directions = {{1,0},{0,1},{-1,0},{0,-1}};\\n\\n    public Robot(int width, int height) {\\n        this.rows = height;\\n        this.cols = width;\\n        this.x = this.y = 0;\\n    }\\n    \\n    public void step(int num) {\\n        num %= this.cols * 2 + this.rows * 2 - 4;\\n        if (num == 0) num = this.cols * 2 + this.rows * 2 - 4;\\n        while (num > 0) {\\n            if (this.x + directions[currentFacing][0] < 0 ||\\n                this.x + directions[currentFacing][0] >= cols ||\\n                this.y + directions[currentFacing][1] < 0 ||\\n                this.y + directions[currentFacing][1] >= rows) {\\n                currentFacing = (currentFacing + 1) % 4;\\n            }\\n            \\n            this.x += directions[currentFacing][0];\\n            this.y += directions[currentFacing][1];\\n            num--;\\n        }\\n    }\\n    \\n    public int[] getPos() {\\n        return new int[] {this.x, this.y};\\n    }\\n    \\n    public String getDir() {\\n        return this.currentFacing == 0 ? \"East\": (currentFacing == 1 ? \"North\": (currentFacing == 2 ? \"West\": \"South\"));\\n    }\\n}\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot obj = new Robot(width, height);\\n * obj.step(num);\\n * int[] param_2 = obj.getPos();\\n * String param_3 = obj.getDir();\\n */\\n ```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Robot {\\n    // east = 0; north = 1; west = 2; south = 3;\\n    int rows, cols, x, y, currentFacing = 0;\\n    int[][] directions = {{1,0},{0,1},{-1,0},{0,-1}};\\n\\n    public Robot(int width, int height) {\\n        this.rows = height;\\n        this.cols = width;\\n        this.x = this.y = 0;\\n    }\\n    \\n    public void step(int num) {\\n        num %= this.cols * 2 + this.rows * 2 - 4;\\n        if (num == 0) num = this.cols * 2 + this.rows * 2 - 4;\\n        while (num > 0) {\\n            if (this.x + directions[currentFacing][0] < 0 ||\\n                this.x + directions[currentFacing][0] >= cols ||\\n                this.y + directions[currentFacing][1] < 0 ||\\n                this.y + directions[currentFacing][1] >= rows) {\\n                currentFacing = (currentFacing + 1) % 4;\\n            }\\n            \\n            this.x += directions[currentFacing][0];\\n            this.y += directions[currentFacing][1];\\n            num--;\\n        }\\n    }\\n    \\n    public int[] getPos() {\\n        return new int[] {this.x, this.y};\\n    }\\n    \\n    public String getDir() {\\n        return this.currentFacing == 0 ? \"East\": (currentFacing == 1 ? \"North\": (currentFacing == 2 ? \"West\": \"South\"));\\n    }\\n}\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot obj = new Robot(width, height);\\n * obj.step(num);\\n * int[] param_2 = obj.getPos();\\n * String param_3 = obj.getDir();\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2259995,
                "title": "clean-c-solution",
                "content": "Clean and easy to maintain code doesn\\'t seem to matter here, but here it is (both recursive and non-recursive) - \\n\\n```\\npublic class Robot\\n        {\\n            private int CurrentRow;\\n            private int CurrentColumn;\\n            private readonly int MaxRows;\\n            private readonly int MaxColumns;\\n            private enum Direction { East, North, West, South };\\n            private Direction CurrentDirection;\\n            \\n            public Robot(int width, int height)\\n            {\\n                MaxRows = height;\\n                MaxColumns = width;\\n                CurrentDirection = Direction.East;\\n                CurrentRow = 0;\\n                CurrentColumn = 0;\\n            }\\n\\n            public void Step(int num)\\n            {\\n                while (num > 0)\\n                {\\n                    switch (CurrentDirection)\\n                    {\\n                        case Direction.South:\\n                            if (CurrentRow - num >= 0)\\n                            {\\n                                CurrentRow -= num;\\n                                num = 0;\\n                            }\\n                            else\\n                            {\\n                                var temp = CurrentRow;\\n                                CurrentRow = 0;\\n                                CurrentDirection = Direction.East;\\n                                num -= temp;\\n                            }\\n                            break;\\n                        case Direction.East:\\n                            if (CurrentColumn + num < MaxColumns)\\n                            {\\n                                CurrentColumn += num;\\n                                num = 0;\\n                            }\\n                            else\\n                            {\\n                                var temp = CurrentColumn;\\n                                CurrentColumn = MaxColumns - 1;\\n                                CurrentDirection = Direction.North;\\n                                num -= (MaxColumns - 1 - temp);\\n                            }\\n                            break;\\n                        case Direction.North:\\n                            if (CurrentRow + num < MaxRows)\\n                            {\\n                                CurrentRow += num;\\n                                num = 0;\\n                            }\\n                            else\\n                            {\\n                                var temp = CurrentRow;\\n                                CurrentRow = MaxRows - 1;\\n                                CurrentDirection = Direction.West;\\n                                num -= (MaxRows - 1 - temp);\\n                            }\\n\\n                            break;\\n                        case Direction.West:\\n                            if (CurrentColumn - num >= 0)\\n                            {\\n                                CurrentColumn -= num;\\n                                num = 0;\\n                            }\\n                            else\\n                            {\\n                                var temp = CurrentColumn;\\n                                CurrentColumn = 0;\\n                                CurrentDirection = Direction.South;\\n                                num -= temp;\\n                            }\\n                            break;\\n                    }\\n                }\\n            }\\n\\n            public void StepRecursive(int num)\\n            {\\n                if (num <= 0)\\n                    return;\\n                switch(CurrentDirection)\\n                {\\n                    case Direction.South:\\n                        if (CurrentRow - num >= 0)\\n                        {\\n                            CurrentRow -= num;\\n                        }\\n                        else\\n                        {\\n                            var temp = CurrentRow;\\n                            CurrentRow = 0;\\n                            CurrentDirection = Direction.East;\\n                            Step(num - temp);\\n                        }\\n                        break;\\n                    case Direction.East:\\n                        if(CurrentColumn + num < MaxColumns)\\n                        {\\n                            CurrentColumn += num;\\n                        }\\n                        else\\n                        {\\n                            var temp = CurrentColumn;\\n                            CurrentColumn = MaxColumns - 1;\\n                            CurrentDirection = Direction.North;\\n                            Step(num - (MaxColumns - 1 - temp));\\n                        }\\n                        break;\\n                    case Direction.North:\\n                        if (CurrentRow + num < MaxRows)\\n                        {\\n                            CurrentRow += num;\\n                        }\\n                        else\\n                        {\\n                            var temp = CurrentRow;\\n                            CurrentRow = MaxRows - 1;\\n                            CurrentDirection = Direction.West;\\n                            Step(num - (MaxRows - 1 - temp));\\n                        }\\n                        \\n                        break;\\n                    case Direction.West:\\n                        if (CurrentColumn - num >= 0)\\n                        {\\n                            CurrentColumn -= num;\\n                        }\\n                        else\\n                        {\\n                            var temp = CurrentColumn;\\n                            CurrentColumn = 0;\\n                            CurrentDirection = Direction.South;\\n                            Step(num - temp);\\n                        }\\n                        break;\\n                }\\n            }\\n\\n            public int[] GetPos() => new[] { CurrentColumn, CurrentRow };\\n\\n            public string GetDir() => CurrentDirection.ToString();\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Robot\\n        {\\n            private int CurrentRow;\\n            private int CurrentColumn;\\n            private readonly int MaxRows;\\n            private readonly int MaxColumns;\\n            private enum Direction { East, North, West, South };\\n            private Direction CurrentDirection;\\n            \\n            public Robot(int width, int height)\\n            {\\n                MaxRows = height;\\n                MaxColumns = width;\\n                CurrentDirection = Direction.East;\\n                CurrentRow = 0;\\n                CurrentColumn = 0;\\n            }\\n\\n            public void Step(int num)\\n            {\\n                while (num > 0)\\n                {\\n                    switch (CurrentDirection)\\n                    {\\n                        case Direction.South:\\n                            if (CurrentRow - num >= 0)\\n                            {\\n                                CurrentRow -= num;\\n                                num = 0;\\n                            }\\n                            else\\n                            {\\n                                var temp = CurrentRow;\\n                                CurrentRow = 0;\\n                                CurrentDirection = Direction.East;\\n                                num -= temp;\\n                            }\\n                            break;\\n                        case Direction.East:\\n                            if (CurrentColumn + num < MaxColumns)\\n                            {\\n                                CurrentColumn += num;\\n                                num = 0;\\n                            }\\n                            else\\n                            {\\n                                var temp = CurrentColumn;\\n                                CurrentColumn = MaxColumns - 1;\\n                                CurrentDirection = Direction.North;\\n                                num -= (MaxColumns - 1 - temp);\\n                            }\\n                            break;\\n                        case Direction.North:\\n                            if (CurrentRow + num < MaxRows)\\n                            {\\n                                CurrentRow += num;\\n                                num = 0;\\n                            }\\n                            else\\n                            {\\n                                var temp = CurrentRow;\\n                                CurrentRow = MaxRows - 1;\\n                                CurrentDirection = Direction.West;\\n                                num -= (MaxRows - 1 - temp);\\n                            }\\n\\n                            break;\\n                        case Direction.West:\\n                            if (CurrentColumn - num >= 0)\\n                            {\\n                                CurrentColumn -= num;\\n                                num = 0;\\n                            }\\n                            else\\n                            {\\n                                var temp = CurrentColumn;\\n                                CurrentColumn = 0;\\n                                CurrentDirection = Direction.South;\\n                                num -= temp;\\n                            }\\n                            break;\\n                    }\\n                }\\n            }\\n\\n            public void StepRecursive(int num)\\n            {\\n                if (num <= 0)\\n                    return;\\n                switch(CurrentDirection)\\n                {\\n                    case Direction.South:\\n                        if (CurrentRow - num >= 0)\\n                        {\\n                            CurrentRow -= num;\\n                        }\\n                        else\\n                        {\\n                            var temp = CurrentRow;\\n                            CurrentRow = 0;\\n                            CurrentDirection = Direction.East;\\n                            Step(num - temp);\\n                        }\\n                        break;\\n                    case Direction.East:\\n                        if(CurrentColumn + num < MaxColumns)\\n                        {\\n                            CurrentColumn += num;\\n                        }\\n                        else\\n                        {\\n                            var temp = CurrentColumn;\\n                            CurrentColumn = MaxColumns - 1;\\n                            CurrentDirection = Direction.North;\\n                            Step(num - (MaxColumns - 1 - temp));\\n                        }\\n                        break;\\n                    case Direction.North:\\n                        if (CurrentRow + num < MaxRows)\\n                        {\\n                            CurrentRow += num;\\n                        }\\n                        else\\n                        {\\n                            var temp = CurrentRow;\\n                            CurrentRow = MaxRows - 1;\\n                            CurrentDirection = Direction.West;\\n                            Step(num - (MaxRows - 1 - temp));\\n                        }\\n                        \\n                        break;\\n                    case Direction.West:\\n                        if (CurrentColumn - num >= 0)\\n                        {\\n                            CurrentColumn -= num;\\n                        }\\n                        else\\n                        {\\n                            var temp = CurrentColumn;\\n                            CurrentColumn = 0;\\n                            CurrentDirection = Direction.South;\\n                            Step(num - temp);\\n                        }\\n                        break;\\n                }\\n            }\\n\\n            public int[] GetPos() => new[] { CurrentColumn, CurrentRow };\\n\\n            public string GetDir() => CurrentDirection.ToString();\\n        }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2234032,
                "title": "java-code",
                "content": "```\\nclass Robot {\\n\\n    int x;\\n    int y;\\n    int currentX;\\n    int currentY;\\n    String currentDir;\\n    boolean first;\\n    \\n    public Robot(int width, int height) {\\n        x = height;\\n        y = width;   \\n        currentX = 0;\\n        currentY = 0;\\n        currentDir  = \"East\";\\n    }\\n    \\n    public void step(int num) {\\n        \\n        num%=(2*x+2*y-4);\\n        if(num == 0){\\n            if(currentX==0 && currentY==0)\\n                currentDir = \"South\";\\n        }\\n        first = false;\\n        if(currentDir == \"East\"){\\n            if(currentY+num<y)\\n                currentY+=num;\\n            else{\\n                int remaining = num - (y-currentY-1);\\n                currentDir = \"North\";\\n                currentY = y-1;\\n                step(remaining);\\n            }\\n        }\\n        else if(currentDir == \"West\"){\\n            if(currentY-num>=0)\\n                currentY-=num;\\n            else{\\n                int remaining = num-currentY;\\n                currentDir = \"South\";\\n                currentY = 0;\\n                step(remaining);\\n            }\\n        }else if(currentDir == \"North\"){\\n            if(currentX+num<x)\\n                currentX+=num;\\n            else{\\n                int remaining = num-(x-currentX-1);\\n                currentDir = \"West\";\\n                currentX = x-1;\\n                step(remaining);\\n            }\\n        }\\n        else\\n        {\\n             if(currentDir == \"South\"){\\n            if(currentX-num>=0)\\n                currentX-=num;\\n            else{\\n                int remaining = num-currentX;\\n                currentDir = \"East\";\\n                currentX = 0;\\n                step(remaining);\\n            }\\n        }\\n    }}\\n    \\n    public int[] getPos() {\\n        return new int[]{currentY,currentX};\\n    }\\n    \\n    public String getDir() {\\n        return currentDir;\\n    }\\n}\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot obj = new Robot(width, height);\\n * obj.step(num);\\n * int[] param_2 = obj.getPos();\\n * String param_3 = obj.getDir();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass Robot {\\n\\n    int x;\\n    int y;\\n    int currentX;\\n    int currentY;\\n    String currentDir;\\n    boolean first;\\n    \\n    public Robot(int width, int height) {\\n        x = height;\\n        y = width;   \\n        currentX = 0;\\n        currentY = 0;\\n        currentDir  = \"East\";\\n    }\\n    \\n    public void step(int num) {\\n        \\n        num%=(2*x+2*y-4);\\n        if(num == 0){\\n            if(currentX==0 && currentY==0)\\n                currentDir = \"South\";\\n        }\\n        first = false;\\n        if(currentDir == \"East\"){\\n            if(currentY+num<y)\\n                currentY+=num;\\n            else{\\n                int remaining = num - (y-currentY-1);\\n                currentDir = \"North\";\\n                currentY = y-1;\\n                step(remaining);\\n            }\\n        }\\n        else if(currentDir == \"West\"){\\n            if(currentY-num>=0)\\n                currentY-=num;\\n            else{\\n                int remaining = num-currentY;\\n                currentDir = \"South\";\\n                currentY = 0;\\n                step(remaining);\\n            }\\n        }else if(currentDir == \"North\"){\\n            if(currentX+num<x)\\n                currentX+=num;\\n            else{\\n                int remaining = num-(x-currentX-1);\\n                currentDir = \"West\";\\n                currentX = x-1;\\n                step(remaining);\\n            }\\n        }\\n        else\\n        {\\n             if(currentDir == \"South\"){\\n            if(currentX-num>=0)\\n                currentX-=num;\\n            else{\\n                int remaining = num-currentX;\\n                currentDir = \"East\";\\n                currentX = 0;\\n                step(remaining);\\n            }\\n        }\\n    }}\\n    \\n    public int[] getPos() {\\n        return new int[]{currentY,currentX};\\n    }\\n    \\n    public String getDir() {\\n        return currentDir;\\n    }\\n}\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot obj = new Robot(width, height);\\n * obj.step(num);\\n * int[] param_2 = obj.getPos();\\n * String param_3 = obj.getDir();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2200683,
                "title": "python-without-tracking-x-y-coordinates",
                "content": "```\\nclass Robot:\\n\\n    def __init__(self, width: int, height: int):\\n        \\n        self.X = width - 1\\n        self.Y = height -1\\n        self.peri = height + height + width + width - 4\\n        \\n        self.pos = 0\\n        \\n        self.first_step = 0\\n\\n    def step(self, num: int) -> None:\\n        \\n        self.first_step = 1\\n        \\n        num %= self.peri\\n        self.pos += num\\n        self.pos %= self.peri\\n        \\n\\n    def getPos(self) -> List[int]:\\n        \\n        if self.pos <= self.X : return [self.pos, 0]\\n        elif self.pos <= self.X + self.Y : return [self.X, self.pos - self.X]\\n        elif self.pos <= self.X + self.X + self.Y : return [self.X + self.X + self.Y - self.pos, self.Y]\\n        else : return  [0, self.X + self.X + self.Y + self.Y  - self.pos]\\n        \\n\\n    def getDir(self) -> str:\\n        \\n        if self.pos == 0 and self.first_step : return \\'South\\'\\n        \\n        if self.pos <= self.X : return \\'East\\'\\n        elif self.pos <= self.X + self.Y : return \\'North\\'\\n        elif self.pos <= self.X + self.X + self.Y : return \\'West\\'\\n        else : return \\'South\\'\\n        \\n\\n\\n# Your Robot object will be instantiated and called as such:\\n# obj = Robot(width, height)\\n# obj.step(num)\\n# param_2 = obj.getPos()\\n# param_3 = obj.getDir()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Robot:\\n\\n    def __init__(self, width: int, height: int):\\n        \\n        self.X = width - 1\\n        self.Y = height -1\\n        self.peri = height + height + width + width - 4\\n        \\n        self.pos = 0\\n        \\n        self.first_step = 0\\n\\n    def step(self, num: int) -> None:\\n        \\n        self.first_step = 1\\n        \\n        num %= self.peri\\n        self.pos += num\\n        self.pos %= self.peri\\n        \\n\\n    def getPos(self) -> List[int]:\\n        \\n        if self.pos <= self.X : return [self.pos, 0]\\n        elif self.pos <= self.X + self.Y : return [self.X, self.pos - self.X]\\n        elif self.pos <= self.X + self.X + self.Y : return [self.X + self.X + self.Y - self.pos, self.Y]\\n        else : return  [0, self.X + self.X + self.Y + self.Y  - self.pos]\\n        \\n\\n    def getDir(self) -> str:\\n        \\n        if self.pos == 0 and self.first_step : return \\'South\\'\\n        \\n        if self.pos <= self.X : return \\'East\\'\\n        elif self.pos <= self.X + self.Y : return \\'North\\'\\n        elif self.pos <= self.X + self.X + self.Y : return \\'West\\'\\n        else : return \\'South\\'\\n        \\n\\n\\n# Your Robot object will be instantiated and called as such:\\n# obj = Robot(width, height)\\n# obj.step(num)\\n# param_2 = obj.getPos()\\n# param_3 = obj.getDir()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2175914,
                "title": "java-solution",
                "content": "**Brute Force Solution using HashMaps, TLE**\\n\\nclass Robot {\\n\\n    int m;\\n    int n;\\n    int x;\\n    int y;\\n    String direction;\\n    HashMap<String, List<Integer>> map;\\n    HashMap<String, Integer> dir;\\n    HashMap<Integer, String> dir2;\\n    public Robot(int width, int height) {\\n        m = height;\\n        n = width;\\n        x = 0;\\n        y = 0;\\n        direction = \"East\";\\n        map = new HashMap<>();\\n        map.put(\"East\", new ArrayList<>(Arrays.asList(0, 1)));\\n        map.put(\"West\", new ArrayList<>(Arrays.asList(0, -1)));\\n        map.put(\"South\", new ArrayList<>(Arrays.asList(-1, 0)));\\n        map.put(\"North\", new ArrayList<>(Arrays.asList(1, 0)));\\n        \\n        dir = new HashMap<>();\\n        dir.put(\"East\", 0);\\n        dir.put(\"North\", 1);\\n        dir.put(\"West\", 2);\\n        dir.put(\"South\", 3);\\n        \\n        dir2 = new HashMap<>();\\n        dir2.put(0, \"East\");\\n        dir2.put(1, \"North\");\\n        dir2.put(2, \"West\");\\n        dir2.put(3, \"South\");\\n        \\n    }\\n    \\n    public void step(int num) {\\n        for (int i=1; i<=num; i++) {\\n            int nextX = map.get(direction).get(0);\\n            int nextY = map.get(direction).get(1);\\n            \\n            int pos = dir.get(direction);\\n            int start = pos;\\n            int counter = 0;\\n            \\n            while (!isSafe(x + nextX, y + nextY, m, n)) {\\n                pos++;\\n                if (pos > 3) {\\n                    pos = 0;\\n                }\\n                if (pos == start) {\\n                    counter = 1;\\n                    break;\\n                }\\n                \\n                direction = dir2.get(pos);\\n                nextX = map.get(direction).get(0);\\n                nextY = map.get(direction).get(1);\\n            }\\n            \\n            if (counter == 1) {\\n                break;\\n            }\\n            \\n            x = x + nextX;\\n            y = y + nextY;\\n            \\n        }\\n    }\\n    \\n    public int[] getPos() {\\n        return new int[]{y, x};\\n    }\\n    \\n    public String getDir() {\\n        return direction;\\n    }\\n    \\n    public boolean isSafe(int i, int j, int m, int n) {\\n        return (i >= 0 && i < m && j >= 0 && j < n);\\n    }\\n}\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot obj = new Robot(width, height);\\n * obj.step(num);\\n * int[] param_2 = obj.getPos();\\n * String param_3 = obj.getDir();\\n */\\n \\n \\n** Optimisted soltuion by traversing only boundary lines of matrix**\\n\\nclass Robot {\\n\\n    int pos;\\n    int w;\\n    int h;\\n    public Robot(int width, int height) {\\n        pos = 0;\\n        w = width-1;\\n        h = height-1;\\n    }\\n    \\n    public void step(int num) {\\n        pos = pos + num;\\n    }\\n    \\n    public int[] getPos() {\\n        int modFunction = 2*(w + h);\\n        \\n        int steps = pos%modFunction;\\n        \\n        if (steps <= w) {\\n            return new int[]{steps, 0};\\n        }\\n        steps -= w;\\n        \\n        if (steps <= h) {\\n            return new int[]{w, steps};\\n        }\\n        steps -= h;\\n        \\n        if (steps <= w) {\\n            return new int[]{w - steps, h};\\n        }\\n        steps -= w;\\n        \\n        return new int[]{0, h - steps};\\n    }\\n    \\n    public String getDir() {\\n        int[] currentPosition = getPos();\\n        int width = currentPosition[0];\\n        int height = currentPosition[1];\\n        \\n        if (pos == 0 || width > 0 && height == 0) {\\n            return \"East\";\\n        }\\n        \\n        if (width == w && height > 0) {\\n            return \"North\";\\n        }\\n        \\n        if (height == h && width < w) {\\n            return \"West\";\\n        }\\n        \\n        return \"South\";\\n    }\\n}\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot obj = new Robot(width, height);\\n * obj.step(num);\\n * int[] param_2 = obj.getPos();\\n * String param_3 = obj.getDir();\\n */",
                "solutionTags": [
                    "Java"
                ],
                "code": "**Brute Force Solution using HashMaps, TLE**\\n\\nclass Robot {\\n\\n    int m;\\n    int n;\\n    int x;\\n    int y;\\n    String direction;\\n    HashMap<String, List<Integer>> map;\\n    HashMap<String, Integer> dir;\\n    HashMap<Integer, String> dir2;\\n    public Robot(int width, int height) {\\n        m = height;\\n        n = width;\\n        x = 0;\\n        y = 0;\\n        direction = \"East\";\\n        map = new HashMap<>();\\n        map.put(\"East\", new ArrayList<>(Arrays.asList(0, 1)));\\n        map.put(\"West\", new ArrayList<>(Arrays.asList(0, -1)));\\n        map.put(\"South\", new ArrayList<>(Arrays.asList(-1, 0)));\\n        map.put(\"North\", new ArrayList<>(Arrays.asList(1, 0)));\\n        \\n        dir = new HashMap<>();\\n        dir.put(\"East\", 0);\\n        dir.put(\"North\", 1);\\n        dir.put(\"West\", 2);\\n        dir.put(\"South\", 3);\\n        \\n        dir2 = new HashMap<>();\\n        dir2.put(0, \"East\");\\n        dir2.put(1, \"North\");\\n        dir2.put(2, \"West\");\\n        dir2.put(3, \"South\");\\n        \\n    }\\n    \\n    public void step(int num) {\\n        for (int i=1; i<=num; i++) {\\n            int nextX = map.get(direction).get(0);\\n            int nextY = map.get(direction).get(1);\\n            \\n            int pos = dir.get(direction);\\n            int start = pos;\\n            int counter = 0;\\n            \\n            while (!isSafe(x + nextX, y + nextY, m, n)) {\\n                pos++;\\n                if (pos > 3) {\\n                    pos = 0;\\n                }\\n                if (pos == start) {\\n                    counter = 1;\\n                    break;\\n                }\\n                \\n                direction = dir2.get(pos);\\n                nextX = map.get(direction).get(0);\\n                nextY = map.get(direction).get(1);\\n            }\\n            \\n            if (counter == 1) {\\n                break;\\n            }\\n            \\n            x = x + nextX;\\n            y = y + nextY;\\n            \\n        }\\n    }\\n    \\n    public int[] getPos() {\\n        return new int[]{y, x};\\n    }\\n    \\n    public String getDir() {\\n        return direction;\\n    }\\n    \\n    public boolean isSafe(int i, int j, int m, int n) {\\n        return (i >= 0 && i < m && j >= 0 && j < n);\\n    }\\n}\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot obj = new Robot(width, height);\\n * obj.step(num);\\n * int[] param_2 = obj.getPos();\\n * String param_3 = obj.getDir();\\n */\\n \\n \\n** Optimisted soltuion by traversing only boundary lines of matrix**\\n\\nclass Robot {\\n\\n    int pos;\\n    int w;\\n    int h;\\n    public Robot(int width, int height) {\\n        pos = 0;\\n        w = width-1;\\n        h = height-1;\\n    }\\n    \\n    public void step(int num) {\\n        pos = pos + num;\\n    }\\n    \\n    public int[] getPos() {\\n        int modFunction = 2*(w + h);\\n        \\n        int steps = pos%modFunction;\\n        \\n        if (steps <= w) {\\n            return new int[]{steps, 0};\\n        }\\n        steps -= w;\\n        \\n        if (steps <= h) {\\n            return new int[]{w, steps};\\n        }\\n        steps -= h;\\n        \\n        if (steps <= w) {\\n            return new int[]{w - steps, h};\\n        }\\n        steps -= w;\\n        \\n        return new int[]{0, h - steps};\\n    }\\n    \\n    public String getDir() {\\n        int[] currentPosition = getPos();\\n        int width = currentPosition[0];\\n        int height = currentPosition[1];\\n        \\n        if (pos == 0 || width > 0 && height == 0) {\\n            return \"East\";\\n        }\\n        \\n        if (width == w && height > 0) {\\n            return \"North\";\\n        }\\n        \\n        if (height == h && width < w) {\\n            return \"West\";\\n        }\\n        \\n        return \"South\";\\n    }\\n}\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot obj = new Robot(width, height);\\n * obj.step(num);\\n * int[] param_2 = obj.getPos();\\n * String param_3 = obj.getDir();\\n */",
                "codeTag": "Java"
            },
            {
                "id": 2172349,
                "title": "javascript-solution-simulation",
                "content": "```\\nvar Robot = function(width, height) {\\n    this.m = height;\\n    this.n = width;\\n    this.coords = {};\\n    this.totSteps = 0;\\n    this.size = width + width + height + height - 4;\\n    \\n    let index = 1;\\n    let x = 0;\\n    let y = 0;\\n    \\n    this.coords[0] = [x, y, \"East\"];\\n    \\n    const dirs = [[1, 0, width - 1, \"East\"], [0, 1, height - 1, \"North\"], [-1, 0, width - 1, \"West\"], [0, -1, height - 1, \"South\"]];\\n    \\n    for (let i = 0; i < dirs.length; ++i) {\\n        const [xDir, yDir, len, dirStr] = dirs[i]; // the len is the distance the robot has to travel before making a turn\\n        \\n        for (let j = 0; j < len; ++j) {\\n            x += xDir;\\n            y += yDir;\\n            \\n            this.coords[index] = [x, y, dirStr];\\n            ++index;\\n        }\\n    }\\n}; \\n\\n\\nRobot.prototype.step = function(num) {\\n    this.totSteps += num;\\n};\\n\\n\\nRobot.prototype.getPos = function() {\\n    const idx = this.totSteps % this.size;\\n    const [x, y, _] = this.coords[idx];\\n    return [x, y];\\n}; \\n\\n\\nRobot.prototype.getDir = function() {\\n    const idx = this.totSteps % this.size;\\n    const [x, y, dir] = this.coords[idx];\\n    \\n    if (x === 0 && y === 0) {\\n        if (this.totSteps === 0) return dir;\\n        else return \"South\";\\n    }\\n    else {\\n        return dir;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Simulation"
                ],
                "code": "```\\nvar Robot = function(width, height) {\\n    this.m = height;\\n    this.n = width;\\n    this.coords = {};\\n    this.totSteps = 0;\\n    this.size = width + width + height + height - 4;\\n    \\n    let index = 1;\\n    let x = 0;\\n    let y = 0;\\n    \\n    this.coords[0] = [x, y, \"East\"];\\n    \\n    const dirs = [[1, 0, width - 1, \"East\"], [0, 1, height - 1, \"North\"], [-1, 0, width - 1, \"West\"], [0, -1, height - 1, \"South\"]];\\n    \\n    for (let i = 0; i < dirs.length; ++i) {\\n        const [xDir, yDir, len, dirStr] = dirs[i]; // the len is the distance the robot has to travel before making a turn\\n        \\n        for (let j = 0; j < len; ++j) {\\n            x += xDir;\\n            y += yDir;\\n            \\n            this.coords[index] = [x, y, dirStr];\\n            ++index;\\n        }\\n    }\\n}; \\n\\n\\nRobot.prototype.step = function(num) {\\n    this.totSteps += num;\\n};\\n\\n\\nRobot.prototype.getPos = function() {\\n    const idx = this.totSteps % this.size;\\n    const [x, y, _] = this.coords[idx];\\n    return [x, y];\\n}; \\n\\n\\nRobot.prototype.getDir = function() {\\n    const idx = this.totSteps % this.size;\\n    const [x, y, dir] = this.coords[idx];\\n    \\n    if (x === 0 && y === 0) {\\n        if (this.totSteps === 0) return dir;\\n        else return \"South\";\\n    }\\n    else {\\n        return dir;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2120385,
                "title": "c",
                "content": "```\\nclass Robot {\\n    //dir 0,1,2,3: east, north, west, south\\n    int x, y, w, h, dir;\\n    string dirstr[4] = {\"East\", \"North\", \"West\", \"South\"};\\n    \\npublic:\\n    Robot(int width, int height) {\\n        w = width-1, h = height-1, x = 0, y = 0, dir = 0;\\n    }\\n    \\n    void step(int num) {\\n        //move to origin and adjust steps\\n        if (dir==0)\\n            num += x + y;\\n        else if (dir==1)\\n            num += w - x + y + w;\\n        else if (dir==2)\\n            num += h - y + w - x + w + h;\\n        else\\n            num += x + h - y + 2 * w + h;\\n      \\n        //calculate count of change in direction and set direction\\n        dir = (num/(w+h))%2 * 2;\\n        int r = num %(w+h);\\n        if (r > w) \\n            dir += 1;\\n        //calculate x, y \\n        if (dir == 3) {x=0;y=h-r+w;} \\n        else if (dir == 2) {x=w-r; y=h;}\\n        else if (dir == 1) {x=w; y=r-w;}\\n        else {x=r;y=0;}\\n\\t\\t//if stop in corner step back one in direction\\n        if (r==0)\\n            dir = dir==0?3:dir-1;\\n    }\\n    \\n    vector<int> getPos() {\\n        return vector<int>({x,y});\\n    }\\n    \\n    string getDir() {\\n        return dirstr[dir];\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Robot {\\n    //dir 0,1,2,3: east, north, west, south\\n    int x, y, w, h, dir;\\n    string dirstr[4] = {\"East\", \"North\", \"West\", \"South\"};\\n    \\npublic:\\n    Robot(int width, int height) {\\n        w = width-1, h = height-1, x = 0, y = 0, dir = 0;\\n    }\\n    \\n    void step(int num) {\\n        //move to origin and adjust steps\\n        if (dir==0)\\n            num += x + y;\\n        else if (dir==1)\\n            num += w - x + y + w;\\n        else if (dir==2)\\n            num += h - y + w - x + w + h;\\n        else\\n            num += x + h - y + 2 * w + h;\\n      \\n        //calculate count of change in direction and set direction\\n        dir = (num/(w+h))%2 * 2;\\n        int r = num %(w+h);\\n        if (r > w) \\n            dir += 1;\\n        //calculate x, y \\n        if (dir == 3) {x=0;y=h-r+w;} \\n        else if (dir == 2) {x=w-r; y=h;}\\n        else if (dir == 1) {x=w; y=r-w;}\\n        else {x=r;y=0;}\\n\\t\\t//if stop in corner step back one in direction\\n        if (r==0)\\n            dir = dir==0?3:dir-1;\\n    }\\n    \\n    vector<int> getPos() {\\n        return vector<int>({x,y});\\n    }\\n    \\n    string getDir() {\\n        return dirstr[dir];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2119429,
                "title": "tle-to-optimised-solution-easy",
                "content": "Brute force approach gives TLE solution.\\n\\n```\\nclass Robot {\\n    int[] cur_pos = {0,0};\\n    int cur_dir = 0;\\n    String[] dir = {\"East\", \"North\", \"West\", \"South\"};\\n    int n;\\n    int m;\\n    \\n    public Robot(int width, int height) {\\n        n = width;\\n        m = height;\\n    }\\n    \\n    public void step(int num) {\\n        int x = cur_pos[0];\\n        int y = cur_pos[1];\\n        while(num > 0) {\\n            if(cur_dir==0) {\\n                if(x+1<n) {\\n                    num--;\\n                    x++;\\n                }\\n                else\\n                    cur_dir = 1;\\n            }\\n            else if(cur_dir==1) {\\n                if(y+1<m) {\\n                    num--;\\n                    y++;\\n                }\\n                else\\n                    cur_dir = 2;\\n            }\\n            else if(cur_dir==2) {\\n                if(x-1>=0) {\\n                    num--;\\n                    x--;\\n                }\\n                else\\n                    cur_dir = 3;\\n            }\\n            else {\\n                if(y-1>=0) {\\n                    num--;\\n                    y--;\\n                }\\n                else\\n                    cur_dir = 0;\\n            }\\n        }\\n        \\n        cur_pos[0] = x;\\n        cur_pos[1] = y;\\n    }\\n    \\n    public int[] getPos() {\\n        return cur_pos;\\n    }\\n    \\n    public String getDir() {\\n        return dir[cur_dir];\\n    }\\n}\\n```\\n\\nOptimized Approach - \\n\\n1. We know the bot will be moving only at the edges of the box.\\n2. After the bot completes 1 round the positions will start to repeat.\\n3. So we think of a way to get the position using total no. of steps.\\n4. We use a mod of total steps that can be travelled to reach to original position i.e. 2(w+h)-4.\\n5. For finding the direction, we check the edges and return the appropriate value based on that.\\n\\n```\\nclass Robot {\\n    int n;\\n    int m;\\n    int mod;\\n    int pos;\\n    \\n    public Robot(int width, int height) {\\n        n = width;\\n        m = height;\\n        mod = 2*(n+m)-4;\\n        pos = 0;\\n    }\\n    \\n    public void step(int num) {\\n        pos = pos+num;\\n    }\\n    \\n    public int[] getPos() {\\n        int steps = pos%mod;\\n        \\n        if(steps<n)\\n            return new int[]{steps,0};    \\n        if(steps<m+n-2)\\n            return new int[]{n-1,steps-(n-1)};\\n        if(steps<n+n+m-3)\\n            return new int[]{n+n+m-3-steps,m-1};\\n        return new int[]{0,n+n+m+m-4-steps};\\n    }\\n    \\n    public String getDir() {\\n        int[] position = getPos();\\n        int x = position[0];\\n        int y = position[1];\\n        \\n        if(pos==0 || (y==0 && x>0)) //Bootom row\\n            return \"East\";\\n        else if(x==n-1) //right-most column\\n            return \"North\";\\n        else if(y==m-1) //top row\\n            return \"West\";\\n        else //left-most column\\n            return \"South\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Robot {\\n    int[] cur_pos = {0,0};\\n    int cur_dir = 0;\\n    String[] dir = {\"East\", \"North\", \"West\", \"South\"};\\n    int n;\\n    int m;\\n    \\n    public Robot(int width, int height) {\\n        n = width;\\n        m = height;\\n    }\\n    \\n    public void step(int num) {\\n        int x = cur_pos[0];\\n        int y = cur_pos[1];\\n        while(num > 0) {\\n            if(cur_dir==0) {\\n                if(x+1<n) {\\n                    num--;\\n                    x++;\\n                }\\n                else\\n                    cur_dir = 1;\\n            }\\n            else if(cur_dir==1) {\\n                if(y+1<m) {\\n                    num--;\\n                    y++;\\n                }\\n                else\\n                    cur_dir = 2;\\n            }\\n            else if(cur_dir==2) {\\n                if(x-1>=0) {\\n                    num--;\\n                    x--;\\n                }\\n                else\\n                    cur_dir = 3;\\n            }\\n            else {\\n                if(y-1>=0) {\\n                    num--;\\n                    y--;\\n                }\\n                else\\n                    cur_dir = 0;\\n            }\\n        }\\n        \\n        cur_pos[0] = x;\\n        cur_pos[1] = y;\\n    }\\n    \\n    public int[] getPos() {\\n        return cur_pos;\\n    }\\n    \\n    public String getDir() {\\n        return dir[cur_dir];\\n    }\\n}\\n```\n```\\nclass Robot {\\n    int n;\\n    int m;\\n    int mod;\\n    int pos;\\n    \\n    public Robot(int width, int height) {\\n        n = width;\\n        m = height;\\n        mod = 2*(n+m)-4;\\n        pos = 0;\\n    }\\n    \\n    public void step(int num) {\\n        pos = pos+num;\\n    }\\n    \\n    public int[] getPos() {\\n        int steps = pos%mod;\\n        \\n        if(steps<n)\\n            return new int[]{steps,0};    \\n        if(steps<m+n-2)\\n            return new int[]{n-1,steps-(n-1)};\\n        if(steps<n+n+m-3)\\n            return new int[]{n+n+m-3-steps,m-1};\\n        return new int[]{0,n+n+m+m-4-steps};\\n    }\\n    \\n    public String getDir() {\\n        int[] position = getPos();\\n        int x = position[0];\\n        int y = position[1];\\n        \\n        if(pos==0 || (y==0 && x>0)) //Bootom row\\n            return \"East\";\\n        else if(x==n-1) //right-most column\\n            return \"North\";\\n        else if(y==m-1) //top row\\n            return \"West\";\\n        else //left-most column\\n            return \"South\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2092206,
                "title": "c-code",
                "content": "```\\ntypedef struct {\\n\\tint pos;\\n\\tint len;\\n\\tint height;\\n\\tint width;\\n\\tint c1;\\n\\tint c2;\\n\\tint c3;\\n\\tint c4;\\n\\tbool init;\\n} Robot;\\n\\n\\nRobot* robotCreate(int width, int height) {\\n\\tRobot *obj;\\n\\n\\tobj = malloc(sizeof(Robot));\\n\\n\\tobj->pos = 0;\\n\\tobj->len = 2*(height+width-2);\\n\\tobj->width = width-1;\\n\\tobj->height = height-1;\\n\\tobj->c1 = width-1;\\n\\tobj->c2 = width+height-2;\\n\\tobj->c3 = width*2+height-3;\\n\\tobj->c4 = 2*(width+height-2);\\n\\tobj->init = true;\\n\\n\\treturn obj;\\n}\\n\\nvoid robotStep(Robot* obj, int num) {\\n\\n\\tobj->pos = (obj->pos+num) % obj->len;\\n\\tif(num>0)\\n\\t\\tobj->init = false;;\\n}\\n\\nint* robotGetPos(Robot* obj, int* retSize) {\\n\\tint *p;\\n\\tp = malloc(sizeof(int)*2);\\n\\t*retSize = 2;\\n\\n\\tif(obj->pos <= obj->c1){\\n\\t\\tp[0] = obj->pos;\\n\\t\\tp[1] = 0;\\n\\t}\\n\\telse if(obj->pos <= obj->c2){\\n\\t\\tp[0] = obj->width;\\n\\t\\tp[1] = obj->pos - obj->c1;\\n\\t}\\n\\telse if(obj->pos <= obj->c3){\\n\\t\\tp[0] = obj->c3 - obj->pos;\\n\\t\\tp[1] = obj->height;\\n\\t}\\n\\telse{\\n\\t\\tp[0] = 0;\\n\\t\\tp[1] = obj->c4 - obj->pos;\\n\\t}\\n\\n\\treturn p;\\n\\n}\\n\\nchar * robotGetDir(Robot* obj) {\\n\\tchar *dir=malloc(sizeof(int)*6);\\n\\n\\tif(obj->pos == 0 && (obj->init)){\\n\\t\\tstrcpy(dir, \"East\");\\n\\t\\treturn dir;\\n\\t}\\n\\n\\tif(obj->pos == 0){\\n\\t\\tstrcpy(dir, \"South\");\\n\\t\\treturn dir;\\n\\t}\\n\\n\\tif(obj->pos <= obj->c1){\\n\\t\\tstrcpy(dir, \"East\");\\n\\t}\\n\\telse if(obj->pos <= obj->c2){\\n\\t\\tstrcpy(dir, \"North\");\\n\\t}\\n\\telse if(obj->pos <= obj->c3)\\n\\t\\tstrcpy(dir, \"West\");\\n\\telse\\n\\t\\tstrcpy(dir, \"South\");\\n\\n\\treturn dir;\\n}\\n\\nvoid robotFree(Robot* obj) {\\n\\tfree(obj);\\n}\\n\\n\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ntypedef struct {\\n\\tint pos;\\n\\tint len;\\n\\tint height;\\n\\tint width;\\n\\tint c1;\\n\\tint c2;\\n\\tint c3;\\n\\tint c4;\\n\\tbool init;\\n} Robot;\\n\\n\\nRobot* robotCreate(int width, int height) {\\n\\tRobot *obj;\\n\\n\\tobj = malloc(sizeof(Robot));\\n\\n\\tobj->pos = 0;\\n\\tobj->len = 2*(height+width-2);\\n\\tobj->width = width-1;\\n\\tobj->height = height-1;\\n\\tobj->c1 = width-1;\\n\\tobj->c2 = width+height-2;\\n\\tobj->c3 = width*2+height-3;\\n\\tobj->c4 = 2*(width+height-2);\\n\\tobj->init = true;\\n\\n\\treturn obj;\\n}\\n\\nvoid robotStep(Robot* obj, int num) {\\n\\n\\tobj->pos = (obj->pos+num) % obj->len;\\n\\tif(num>0)\\n\\t\\tobj->init = false;;\\n}\\n\\nint* robotGetPos(Robot* obj, int* retSize) {\\n\\tint *p;\\n\\tp = malloc(sizeof(int)*2);\\n\\t*retSize = 2;\\n\\n\\tif(obj->pos <= obj->c1){\\n\\t\\tp[0] = obj->pos;\\n\\t\\tp[1] = 0;\\n\\t}\\n\\telse if(obj->pos <= obj->c2){\\n\\t\\tp[0] = obj->width;\\n\\t\\tp[1] = obj->pos - obj->c1;\\n\\t}\\n\\telse if(obj->pos <= obj->c3){\\n\\t\\tp[0] = obj->c3 - obj->pos;\\n\\t\\tp[1] = obj->height;\\n\\t}\\n\\telse{\\n\\t\\tp[0] = 0;\\n\\t\\tp[1] = obj->c4 - obj->pos;\\n\\t}\\n\\n\\treturn p;\\n\\n}\\n\\nchar * robotGetDir(Robot* obj) {\\n\\tchar *dir=malloc(sizeof(int)*6);\\n\\n\\tif(obj->pos == 0 && (obj->init)){\\n\\t\\tstrcpy(dir, \"East\");\\n\\t\\treturn dir;\\n\\t}\\n\\n\\tif(obj->pos == 0){\\n\\t\\tstrcpy(dir, \"South\");\\n\\t\\treturn dir;\\n\\t}\\n\\n\\tif(obj->pos <= obj->c1){\\n\\t\\tstrcpy(dir, \"East\");\\n\\t}\\n\\telse if(obj->pos <= obj->c2){\\n\\t\\tstrcpy(dir, \"North\");\\n\\t}\\n\\telse if(obj->pos <= obj->c3)\\n\\t\\tstrcpy(dir, \"West\");\\n\\telse\\n\\t\\tstrcpy(dir, \"South\");\\n\\n\\treturn dir;\\n}\\n\\nvoid robotFree(Robot* obj) {\\n\\tfree(obj);\\n}\\n\\n\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2080893,
                "title": "python3-simple-simulation-with-1-edge-case",
                "content": "\\nO(width+height) time complexity and O(1) space\\nrobot can only move around the perimeter so just only consider it for 1 cycle.\\n\\n    def __init__(self, width: int, height: int):\\n        self.w=width\\n        self.h=height\\n        self.x=0\\n        self.y=0\\n        self.dir=\"E\"\\n        \\n    def step(self, num: int) -> None:\\n        if num==0:\\n            return\\n        num%=((self.w)*2+(self.h)*2-4) # to avoid redoing \\n        if num==0: # if num was initially not 0  and now it is 0 change  it to 1 cycle so we don\\'t cause any direction error\\n            num=self.w*2+self.h*2-4\\n        while num:\\n            if self.dir==\\'E\\':\\n                if self.inside(self.x+num,self.y):\\n                    self.x+=num\\n                    num=0\\n                else:\\n                    num-=(self.w-self.x-1)\\n                    self.x=self.w-1\\n                    self.dir=\\'N\\'\\n                    # num--1\\n            if self.dir==\\'N\\':\\n                if self.inside(self.x,self.y+num):\\n                    self.y+=num\\n                    num=0\\n                else:\\n                    num-=(self.h-self.y-1)\\n                    self.y=self.h-1\\n                    self.dir=\\'W\\'\\n            if self.dir==\\'W\\':\\n                if self.inside(self.x-num,self.y):\\n                    self.x-=num\\n                    num=0\\n                else:\\n                    num-=(self.x)\\n                    self.x=0\\n                    self.dir=\\'S\\'\\n            if self.dir==\\'S\\':\\n                if self.inside(self.x,self.y-num):\\n                    self.y-=num\\n                    num=0\\n                else:\\n                    num-=(self.y)\\n                    self.y=0\\n                    self.dir=\\'E\\'\\n\\n    def getPos(self) -> List[int]:\\n        return [self.x,self.y]\\n\\n    def getDir(self) -> str:\\n        a={\\'E\\':\"East\",\\'W\\':\"West\",\\'N\\':\"North\",\\'S\\':\"South\"}\\n        return a[self.dir]\\n    def inside(self,x,y):\\n        return x>=0 and y>=0 and y<self.h and x<self.w",
                "solutionTags": [
                    "Python3",
                    "Simulation"
                ],
                "code": "\\nO(width+height) time complexity and O(1) space\\nrobot can only move around the perimeter so just only consider it for 1 cycle.\\n\\n    def __init__(self, width: int, height: int):\\n        self.w=width\\n        self.h=height\\n        self.x=0\\n        self.y=0\\n        self.dir=\"E\"\\n        \\n    def step(self, num: int) -> None:\\n        if num==0:\\n            return\\n        num%=((self.w)*2+(self.h)*2-4) # to avoid redoing \\n        if num==0: # if num was initially not 0  and now it is 0 change  it to 1 cycle so we don\\'t cause any direction error\\n            num=self.w*2+self.h*2-4\\n        while num:\\n            if self.dir==\\'E\\':\\n                if self.inside(self.x+num,self.y):\\n                    self.x+=num\\n                    num=0\\n                else:\\n                    num-=(self.w-self.x-1)\\n                    self.x=self.w-1\\n                    self.dir=\\'N\\'\\n                    # num--1\\n            if self.dir==\\'N\\':\\n                if self.inside(self.x,self.y+num):\\n                    self.y+=num\\n                    num=0\\n                else:\\n                    num-=(self.h-self.y-1)\\n                    self.y=self.h-1\\n                    self.dir=\\'W\\'\\n            if self.dir==\\'W\\':\\n                if self.inside(self.x-num,self.y):\\n                    self.x-=num\\n                    num=0\\n                else:\\n                    num-=(self.x)\\n                    self.x=0\\n                    self.dir=\\'S\\'\\n            if self.dir==\\'S\\':\\n                if self.inside(self.x,self.y-num):\\n                    self.y-=num\\n                    num=0\\n                else:\\n                    num-=(self.y)\\n                    self.y=0\\n                    self.dir=\\'E\\'\\n\\n    def getPos(self) -> List[int]:\\n        return [self.x,self.y]\\n\\n    def getDir(self) -> str:\\n        a={\\'E\\':\"East\",\\'W\\':\"West\",\\'N\\':\"North\",\\'S\\':\"South\"}\\n        return a[self.dir]\\n    def inside(self,x,y):\\n        return x>=0 and y>=0 and y<self.h and x<self.w",
                "codeTag": "Python3"
            },
            {
                "id": 2077254,
                "title": "python-3-all-o-1-time-and-space",
                "content": "```\\nclass Robot:\\n\\n    def __init__(self, width: int, height: int):\\n        self.perimeter = 2*width + 2*(height - 2)\\n        self.pos = 0\\n        self.atStart = True\\n\\n        self.bottomRight = width - 1\\n        self.topRight = self.bottomRight + (height - 1)\\n        self.topLeft = self.topRight + (width - 1)\\n\\n    def step(self, num: int) -> None:\\n        self.atStart = False\\n        self.pos = (self.pos + num) % self.perimeter\\n\\n    def getPos(self) -> List[int]:\\n        if 0 <= self.pos <= self.bottomRight:\\n            return [self.pos, 0]\\n\\n        if self.bottomRight < self.pos <= self.topRight:\\n            return [self.bottomRight, self.pos - self.bottomRight]\\n\\n        if self.topRight < self.pos <= self.topLeft:\\n            return [self.bottomRight - (self.pos - self.topRight), self.topRight - self.bottomRight]\\n        \\n        return [0, self.topRight - self.bottomRight - (self.pos - self.topLeft)]\\n\\n    def getDir(self) -> str:\\n        if self.atStart or 0 < self.pos <= self.bottomRight:\\n            return \\'East\\'\\n\\n        if self.bottomRight < self.pos <= self.topRight:\\n            return \\'North\\'\\n\\n        if self.topRight < self.pos <= self.topLeft:\\n            return \\'West\\'\\n        \\n        return \\'Sout",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Robot:\\n\\n    def __init__(self, width: int, height: int):\\n        self.perimeter = 2*width + 2*(height - 2)\\n        self.pos = 0\\n        self.atStart = True\\n\\n        self.bottomRight = width - 1\\n        self.topRight = self.bottomRight + (height - 1)\\n        self.topLeft = self.topRight + (width - 1)\\n\\n    def step(self, num: int) -> None:\\n        self.atStart = False\\n        self.pos = (self.pos + num) % self.perimeter\\n\\n    def getPos(self) -> List[int]:\\n        if 0 <= self.pos <= self.bottomRight:\\n            return [self.pos, 0]\\n\\n        if self.bottomRight < self.pos <= self.topRight:\\n            return [self.bottomRight, self.pos - self.bottomRight]\\n\\n        if self.topRight < self.pos <= self.topLeft:\\n            return [self.bottomRight - (self.pos - self.topRight), self.topRight - self.bottomRight]\\n        \\n        return [0, self.topRight - self.bottomRight - (self.pos - self.topLeft)]\\n\\n    def getDir(self) -> str:\\n        if self.atStart or 0 < self.pos <= self.bottomRight:\\n            return \\'East\\'\\n\\n        if self.bottomRight < self.pos <= self.topRight:\\n            return \\'North\\'\\n\\n        if self.topRight < self.pos <= self.topLeft:\\n            return \\'West\\'\\n        \\n        return \\'Sout",
                "codeTag": "Java"
            },
            {
                "id": 2016034,
                "title": "python3-simulation-o-m-n",
                "content": "* the trick is to go to the border first, after that we need to do num=num%(width*2+height*2-4) to cut all unecessary loops around the board. After that, just simulate to get the last position\\n```\\nclass Robot:\\n\\n    def __init__(self, width: int, height: int):\\n        self.nxt={\\'R\\':\\'U\\',\\'U\\':\\'L\\',\\'L\\':\\'D\\',\\'D\\':\\'R\\'}\\n        self.add={\\'R\\':(1,0),\\'U\\':(0,1),\\'L\\':(-1,0),\\'D\\':(0,-1)}\\n        self.x=self.y=0\\n        self.m,self.n=height,width\\n        self.d=\\'R\\'\\n        \\n    def step(self, num: int) -> None:\\n        x,y=self.x,self.y\\n        m,n=self.m,self.n\\n        d=self.d\\n        addX,addY=self.add[d]\\n        while num>0 and 0<=x+addX<n and 0<=y+addY<m:\\n            x+=addX\\n            y+=addY\\n            num-=1\\n        if num==0:\\n            self.x,self.y=x,y\\n            return\\n        num%=(m*2+n*2-4)\\n        addX,addY=self.add[d]\\n        while num>0:\\n            if not (0<=x+addX<n and 0<=y+addY<m):\\n                d=self.nxt[d]\\n                addX,addY=self.add[d]\\n            x+=addX\\n            y+=addY\\n            num-=1\\n        self.d=d\\n        self.x,self.y=x,y\\n        addX,addY=self.add[d]\\n\\n    def getPos(self) -> List[int]:\\n        return [self.x,self.y]\\n\\n    def getDir(self) -> str:\\n        if self.d==\\'R\\': return \\'East\\'\\n        if self.d==\\'U\\': return \\'North\\'\\n        if self.d==\\'L\\': return \\'West\\'\\n        if self.d==\\'D\\': return \\'South\\'\\n```",
                "solutionTags": [],
                "code": "```\\nclass Robot:\\n\\n    def __init__(self, width: int, height: int):\\n        self.nxt={\\'R\\':\\'U\\',\\'U\\':\\'L\\',\\'L\\':\\'D\\',\\'D\\':\\'R\\'}\\n        self.add={\\'R\\':(1,0),\\'U\\':(0,1),\\'L\\':(-1,0),\\'D\\':(0,-1)}\\n        self.x=self.y=0\\n        self.m,self.n=height,width\\n        self.d=\\'R\\'\\n        \\n    def step(self, num: int) -> None:\\n        x,y=self.x,self.y\\n        m,n=self.m,self.n\\n        d=self.d\\n        addX,addY=self.add[d]\\n        while num>0 and 0<=x+addX<n and 0<=y+addY<m:\\n            x+=addX\\n            y+=addY\\n            num-=1\\n        if num==0:\\n            self.x,self.y=x,y\\n            return\\n        num%=(m*2+n*2-4)\\n        addX,addY=self.add[d]\\n        while num>0:\\n            if not (0<=x+addX<n and 0<=y+addY<m):\\n                d=self.nxt[d]\\n                addX,addY=self.add[d]\\n            x+=addX\\n            y+=addY\\n            num-=1\\n        self.d=d\\n        self.x,self.y=x,y\\n        addX,addY=self.add[d]\\n\\n    def getPos(self) -> List[int]:\\n        return [self.x,self.y]\\n\\n    def getDir(self) -> str:\\n        if self.d==\\'R\\': return \\'East\\'\\n        if self.d==\\'U\\': return \\'North\\'\\n        if self.d==\\'L\\': return \\'West\\'\\n        if self.d==\\'D\\': return \\'South\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2004017,
                "title": "python-pre-create-perimeter-faster-than-100",
                "content": "I hope this can help to someone. \\nThe solution is simple, I create the perimeter of any possible positions and directions in a list.\\nWhen pos or dir is asked, then I return the position in the list. \\n\\n```\\nclass Robot(object):\\n\\n    def __init__(self, width, height):\\n        \"\"\"\\n        :type width: int\\n        :type height: int\\n        \"\"\"\\n        self.perimeter = [(\"East\", [i+1,0]) for i in range(width-1)]\\n        self.perimeter.extend([(\"North\", [width-1, i+1]) for i in range(height-1)])\\n        self.perimeter.extend([(\"West\",  [width-2-i, height-1]) for i in range(width-1)])\\n        self.perimeter.extend([(\"South\", [0, height-2-i]) for i in range(height-1)])\\n        self.width  = width\\n        self.height = height\\n        self.len_perimeter = len(self.perimeter)\\n        self.moved  = False\\n        self.steps  = 0\\n        \\n    def step(self, num):\\n        \"\"\"\\n        :type num: int\\n        :rtype: None\\n        \"\"\"\\n        self.steps += num\\n        self.moved = True\\n                    \\n\\n    def getPos(self):\\n        \"\"\"\\n        :rtype: List[int]\\n        \"\"\"\\n        return self.perimeter[(self.steps%self.len_perimeter)-1][1]\\n        \\n\\n    def getDir(self):\\n        \"\"\"\\n        :rtype: str\\n        \"\"\"\\n        if not self.moved and self.getPos() == [0,0]:\\n            return \"East\"\\n        return self.perimeter[(self.steps%self.len_perimeter)-1][0]\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Robot(object):\\n\\n    def __init__(self, width, height):\\n        \"\"\"\\n        :type width: int\\n        :type height: int\\n        \"\"\"\\n        self.perimeter = [(\"East\", [i+1,0]) for i in range(width-1)]\\n        self.perimeter.extend([(\"North\", [width-1, i+1]) for i in range(height-1)])\\n        self.perimeter.extend([(\"West\",  [width-2-i, height-1]) for i in range(width-1)])\\n        self.perimeter.extend([(\"South\", [0, height-2-i]) for i in range(height-1)])\\n        self.width  = width\\n        self.height = height\\n        self.len_perimeter = len(self.perimeter)\\n        self.moved  = False\\n        self.steps  = 0\\n        \\n    def step(self, num):\\n        \"\"\"\\n        :type num: int\\n        :rtype: None\\n        \"\"\"\\n        self.steps += num\\n        self.moved = True\\n                    \\n\\n    def getPos(self):\\n        \"\"\"\\n        :rtype: List[int]\\n        \"\"\"\\n        return self.perimeter[(self.steps%self.len_perimeter)-1][1]\\n        \\n\\n    def getDir(self):\\n        \"\"\"\\n        :rtype: str\\n        \"\"\"\\n        if not self.moved and self.getPos() == [0,0]:\\n            return \"East\"\\n        return self.perimeter[(self.steps%self.len_perimeter)-1][0]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1965969,
                "title": "java-solution-with-comments",
                "content": "```\\nclass Robot {\\n\\n    int maxX;\\n    int maxY;\\n    String dir;\\n    int curX;\\n    int curY;\\n    int changeX;\\n    int changeY;\\n    int peri;\\n    public Robot(int width, int height) {\\n        this.maxX=width-1;\\n        this.maxY=height-1;\\n        this.curY = 0;\\n        this.curX = 0;\\n        this.dir = \"East\";\\n        this.peri = 2 * (width + height) - 4;\\n        this.changeX = 1;\\n        this.changeY = 0;\\n    }\\n    \\n\\t// Considering current robot face, returns distance from boundary.\\n    int distanceFromBoundary() {\\n        if (dir.equals(\"East\")) return maxX-curX;\\n        if (dir.equals(\"West\")) return curX;\\n        if (dir.equals(\"North\")) return maxY-curY;\\n        return curY;\\n    }\\n    \\n\\t// This will change move direction and update x and y multipliers accordingly\\n     void changeDirectionOnBoundary() {\\n        if (dir.equals(\"East\")) {\\n            dir = \"North\";\\n            changeY= 1;\\n            changeX=0;\\n        } else if (dir.equals(\"West\")) {\\n            dir = \"South\";\\n            changeY= -1;\\n            changeX=0;\\n        } else if (dir.equals(\"North\")) {\\n            dir = \"West\";\\n            changeY= 0;\\n            changeX=-1;\\n        } else {\\n            dir = \"East\";\\n            changeY= 0;\\n            changeX=1;\\n        }\\n    }\\n    \\n    \\n    public void step(int num) {\\n        if (num <= 0) return;\\n      \\n        int dis = distanceFromBoundary();\\n\\t\\t// If there is enough distance to walk without hitting boundary\\n\\t\\t// walk that distance, else go to boundary and walk remaining steps.\\n\\t\\t\\n        if (num <= dis) {\\n           curX = curX+changeX*num;\\n           curY = curY+changeY*num;\\n           return; \\n        } else {\\n           curX = curX+changeX*dis;\\n           curY = curY+changeY*dis; \\n            \\n           // We are at start and will end up looping if steps are more than perimeter\\n           // Hence take only remaining step of all loops\\n           if (curX== 0 && curY==0) {\\n              num =(num-dis)%peri; \\n           } else {\\n             num = num-dis;\\n           }\\n            \\n            // if there is a remaining steps then change direction and take steps.\\n           if (num>0) {\\n               changeDirectionOnBoundary();\\n               step(num);\\n           }\\n        }\\n    }\\n    \\n    public int[] getPos() {\\n        return new int[]{curX, curY};\\n        \\n    }\\n    \\n    public String getDir() {\\n        return dir;\\n    }\\n}\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot obj = new Robot(width, height);\\n * obj.step(num);\\n * int[] param_2 = obj.getPos();\\n * String param_3 = obj.getDir();\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass Robot {\\n\\n    int maxX;\\n    int maxY;\\n    String dir;\\n    int curX;\\n    int curY;\\n    int changeX;\\n    int changeY;\\n    int peri;\\n    public Robot(int width, int height) {\\n        this.maxX=width-1;\\n        this.maxY=height-1;\\n        this.curY = 0;\\n        this.curX = 0;\\n        this.dir = \"East\";\\n        this.peri = 2 * (width + height) - 4;\\n        this.changeX = 1;\\n        this.changeY = 0;\\n    }\\n    \\n\\t// Considering current robot face, returns distance from boundary.\\n    int distanceFromBoundary() {\\n        if (dir.equals(\"East\")) return maxX-curX;\\n        if (dir.equals(\"West\")) return curX;\\n        if (dir.equals(\"North\")) return maxY-curY;\\n        return curY;\\n    }\\n    \\n\\t// This will change move direction and update x and y multipliers accordingly\\n     void changeDirectionOnBoundary() {\\n        if (dir.equals(\"East\")) {\\n            dir = \"North\";\\n            changeY= 1;\\n            changeX=0;\\n        } else if (dir.equals(\"West\")) {\\n            dir = \"South\";\\n            changeY= -1;\\n            changeX=0;\\n        } else if (dir.equals(\"North\")) {\\n            dir = \"West\";\\n            changeY= 0;\\n            changeX=-1;\\n        } else {\\n            dir = \"East\";\\n            changeY= 0;\\n            changeX=1;\\n        }\\n    }\\n    \\n    \\n    public void step(int num) {\\n        if (num <= 0) return;\\n      \\n        int dis = distanceFromBoundary();\\n\\t\\t// If there is enough distance to walk without hitting boundary\\n\\t\\t// walk that distance, else go to boundary and walk remaining steps.\\n\\t\\t\\n        if (num <= dis) {\\n           curX = curX+changeX*num;\\n           curY = curY+changeY*num;\\n           return; \\n        } else {\\n           curX = curX+changeX*dis;\\n           curY = curY+changeY*dis; \\n            \\n           // We are at start and will end up looping if steps are more than perimeter\\n           // Hence take only remaining step of all loops\\n           if (curX== 0 && curY==0) {\\n              num =(num-dis)%peri; \\n           } else {\\n             num = num-dis;\\n           }\\n            \\n            // if there is a remaining steps then change direction and take steps.\\n           if (num>0) {\\n               changeDirectionOnBoundary();\\n               step(num);\\n           }\\n        }\\n    }\\n    \\n    public int[] getPos() {\\n        return new int[]{curX, curY};\\n        \\n    }\\n    \\n    public String getDir() {\\n        return dir;\\n    }\\n}\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot obj = new Robot(width, height);\\n * obj.step(num);\\n * int[] param_2 = obj.getPos();\\n * String param_3 = obj.getDir();\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1929237,
                "title": "share-some-crucial-hints",
                "content": "We might agree this is not a dam complicated problem, but many of us might get stocked in the middle of no where.\\nThe devil is in the details.\\nHere I share some crucial hints after I finally conquer it after few hours.\\n1. modulo *num* with ***(w + h - 2) * 2***, not ***(w + h) * 2***.\\n2. when the end position is at the corner, don\\'t turn it just yet.\\n\\n```\\nclass Robot {\\n    string str[4] = {\"East\", \"North\", \"West\", \"South\"};\\n    int d;\\n    int w;\\n    int h;\\n    int x;\\n    int y;\\n    int loop;\\n    \\npublic:\\n    Robot(int width, int height) {\\n        w = width;\\n        h = height;\\n        d = 0;\\n        x = 0;\\n        y = 0;\\n        loop = (w + h - 2) * 2;\\n    }\\n    \\n    void step(int num) {\\n        // this is crucial.\\n        num %= loop;\\n        \\n        // this is also crucial.\\n        if (num == 0)\\n            num = loop;\\n        \\n        if (d == 0)\\n        {\\n            if (x + num < w)\\n                x += num;\\n            else\\n            {\\n                num -= w - x - 1;\\n                x = w - 1;\\n                d = 1;\\n                step(num);\\n            }\\n        }\\n        else if (d == 1)\\n        {\\n            if (y + num < h)\\n                y += num;\\n            else\\n            {\\n                num -= h - y - 1;\\n                y = h - 1;\\n                d = 2;\\n                step(num);\\n            }\\n        }\\n        else if (d == 2)\\n        {\\n            if (x >= num)\\n                x -= num;\\n            else\\n            {\\n                num -= x;\\n                x = 0;\\n                d = 3;\\n                step(num);\\n            }\\n        }\\n        else if (d == 3)\\n        {\\n            if (y >= num)\\n                y -= num;\\n            else\\n            {\\n                num -= y;\\n                y = 0;\\n                d = 0;\\n                step(num);\\n            }\\n        }\\n        else\\n        {\\n            \\n        }\\n    }\\n    \\n    vector<int> getPos() {\\n        return {x, y};\\n    }\\n    \\n    string getDir() {\\n        return str[d];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Simulation"
                ],
                "code": "```\\nclass Robot {\\n    string str[4] = {\"East\", \"North\", \"West\", \"South\"};\\n    int d;\\n    int w;\\n    int h;\\n    int x;\\n    int y;\\n    int loop;\\n    \\npublic:\\n    Robot(int width, int height) {\\n        w = width;\\n        h = height;\\n        d = 0;\\n        x = 0;\\n        y = 0;\\n        loop = (w + h - 2) * 2;\\n    }\\n    \\n    void step(int num) {\\n        // this is crucial.\\n        num %= loop;\\n        \\n        // this is also crucial.\\n        if (num == 0)\\n            num = loop;\\n        \\n        if (d == 0)\\n        {\\n            if (x + num < w)\\n                x += num;\\n            else\\n            {\\n                num -= w - x - 1;\\n                x = w - 1;\\n                d = 1;\\n                step(num);\\n            }\\n        }\\n        else if (d == 1)\\n        {\\n            if (y + num < h)\\n                y += num;\\n            else\\n            {\\n                num -= h - y - 1;\\n                y = h - 1;\\n                d = 2;\\n                step(num);\\n            }\\n        }\\n        else if (d == 2)\\n        {\\n            if (x >= num)\\n                x -= num;\\n            else\\n            {\\n                num -= x;\\n                x = 0;\\n                d = 3;\\n                step(num);\\n            }\\n        }\\n        else if (d == 3)\\n        {\\n            if (y >= num)\\n                y -= num;\\n            else\\n            {\\n                num -= y;\\n                y = 0;\\n                d = 0;\\n                step(num);\\n            }\\n        }\\n        else\\n        {\\n            \\n        }\\n    }\\n    \\n    vector<int> getPos() {\\n        return {x, y};\\n    }\\n    \\n    string getDir() {\\n        return str[d];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1926976,
                "title": "simplified-java-solution-with-some-observation",
                "content": "```\\nclass Robot {\\n    \\n    // Observations -> \\n    // 1. you reach to the same point after moving (2 * rows + 2 * cols - 4) steps hence while moving we can reduce the number of moves by finding mod of given steps.\\n    // 2. if you are facing a direction and move (2 * rows + 2 * cols - 4) steps then it will only change the current direction if already standing on the corners. check method findCurrentDirectionAfterReachingSamePoint()\\n    // 3. check max steps you can go in the direction towards which you are facing. after going max steps, your current direction will not change but the direction you will go ahead will change.\\n    \\n\\n    int grid[][];\\n    int rows, cols;\\n    \\n    int EAST = 1, WEST = 2, NORTH = 3, SOUTH = 4;\\n    int goDir;\\n    int currDir;\\n    int r = 0, c = 0;\\n    int mod;\\n    \\n    public Robot(int width, int height) {\\n        this.cols = width;\\n        this.rows = height;\\n        grid = new int[rows][cols];\\n        goDir = EAST;\\n        currDir = EAST;\\n        mod = 2 * rows + 2 * cols - 4;\\n    }\\n    \\n    public void step(int num) {\\n        if(num >= mod) {\\n            findCurrentDirectionAfterReachingSamePoint();\\n        }\\n        num %= mod;\\n        while(num > 0) {\\n            if(goDir == EAST) {\\n                int maxStep = cols - 1 - c;\\n                if(num >= maxStep) {\\n                    c = cols-1;\\n                    goDir = NORTH;\\n                    num -= maxStep;\\n                } else {\\n                    c += num;\\n                    num = 0;\\n                }\\n                currDir = EAST;\\n            } else if(goDir == WEST) {\\n\\n                int maxStep = c;\\n                if(num >= maxStep) {\\n                    num -= maxStep;\\n                    goDir = SOUTH;\\n                    c = 0;\\n                } else {\\n                    c -= num;\\n                    num = 0;\\n                }\\n                currDir = WEST;\\n\\n            } else if(goDir == SOUTH) {\\n\\n                int maxStep = r;\\n                if(num >= maxStep) {\\n                    num -= maxStep;\\n                    goDir = EAST;\\n                    r = 0;\\n                } else {\\n                    r -= num;\\n                    num = 0;\\n                }\\n                \\n                currDir = SOUTH;\\n\\n            } else if(goDir == NORTH) {\\n\\n                int maxStep = rows - 1 - r;\\n                if(num >= maxStep) {\\n                    r = rows-1;\\n                    goDir = WEST;\\n                    num -= maxStep;\\n                } else {\\n                    r += num;\\n                    num = 0;\\n                }\\n                \\n                currDir = NORTH;\\n\\n            }\\n        }\\n    }\\n    \\n    public int[] getPos() {\\n        return new int[] {c, r};\\n    }\\n    \\n    public String getDir() {\\n        switch(currDir) {\\n            case 1 :\\n                return \"East\";\\n            case 2:\\n                return \"West\";\\n            case 3:\\n                return \"North\";\\n            case 4:\\n                return \"South\";\\n            default:\\n                return \"\";\\n        }\\n    }\\n    \\n    private void findCurrentDirectionAfterReachingSamePoint() {\\n        if(goDir == EAST) {\\n            if(c != 0) {\\n                currDir = EAST;\\n            } else {\\n                currDir = SOUTH;\\n            }\\n        } else if(goDir == NORTH) {\\n            if(r != 0) {\\n                currDir = NORTH; \\n            } else {\\n                currDir = EAST;\\n            }\\n        } else if(goDir == WEST) {\\n            if(c != cols-1) {\\n                currDir = WEST;\\n            } else {\\n                currDir = NORTH;\\n            }\\n        } else if(goDir == SOUTH) {\\n            if(r != rows-1) {\\n                currDir = SOUTH;\\n            } else {\\n                currDir = WEST;\\n            }\\n        }\\n    }\\n}\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot obj = new Robot(width, height);\\n * obj.step(num);\\n * int[] param_2 = obj.getPos();\\n * String param_3 = obj.getDir();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Robot {\\n    \\n    // Observations -> \\n    // 1. you reach to the same point after moving (2 * rows + 2 * cols - 4) steps hence while moving we can reduce the number of moves by finding mod of given steps.\\n    // 2. if you are facing a direction and move (2 * rows + 2 * cols - 4) steps then it will only change the current direction if already standing on the corners. check method findCurrentDirectionAfterReachingSamePoint()\\n    // 3. check max steps you can go in the direction towards which you are facing. after going max steps, your current direction will not change but the direction you will go ahead will change.\\n    \\n\\n    int grid[][];\\n    int rows, cols;\\n    \\n    int EAST = 1, WEST = 2, NORTH = 3, SOUTH = 4;\\n    int goDir;\\n    int currDir;\\n    int r = 0, c = 0;\\n    int mod;\\n    \\n    public Robot(int width, int height) {\\n        this.cols = width;\\n        this.rows = height;\\n        grid = new int[rows][cols];\\n        goDir = EAST;\\n        currDir = EAST;\\n        mod = 2 * rows + 2 * cols - 4;\\n    }\\n    \\n    public void step(int num) {\\n        if(num >= mod) {\\n            findCurrentDirectionAfterReachingSamePoint();\\n        }\\n        num %= mod;\\n        while(num > 0) {\\n            if(goDir == EAST) {\\n                int maxStep = cols - 1 - c;\\n                if(num >= maxStep) {\\n                    c = cols-1;\\n                    goDir = NORTH;\\n                    num -= maxStep;\\n                } else {\\n                    c += num;\\n                    num = 0;\\n                }\\n                currDir = EAST;\\n            } else if(goDir == WEST) {\\n\\n                int maxStep = c;\\n                if(num >= maxStep) {\\n                    num -= maxStep;\\n                    goDir = SOUTH;\\n                    c = 0;\\n                } else {\\n                    c -= num;\\n                    num = 0;\\n                }\\n                currDir = WEST;\\n\\n            } else if(goDir == SOUTH) {\\n\\n                int maxStep = r;\\n                if(num >= maxStep) {\\n                    num -= maxStep;\\n                    goDir = EAST;\\n                    r = 0;\\n                } else {\\n                    r -= num;\\n                    num = 0;\\n                }\\n                \\n                currDir = SOUTH;\\n\\n            } else if(goDir == NORTH) {\\n\\n                int maxStep = rows - 1 - r;\\n                if(num >= maxStep) {\\n                    r = rows-1;\\n                    goDir = WEST;\\n                    num -= maxStep;\\n                } else {\\n                    r += num;\\n                    num = 0;\\n                }\\n                \\n                currDir = NORTH;\\n\\n            }\\n        }\\n    }\\n    \\n    public int[] getPos() {\\n        return new int[] {c, r};\\n    }\\n    \\n    public String getDir() {\\n        switch(currDir) {\\n            case 1 :\\n                return \"East\";\\n            case 2:\\n                return \"West\";\\n            case 3:\\n                return \"North\";\\n            case 4:\\n                return \"South\";\\n            default:\\n                return \"\";\\n        }\\n    }\\n    \\n    private void findCurrentDirectionAfterReachingSamePoint() {\\n        if(goDir == EAST) {\\n            if(c != 0) {\\n                currDir = EAST;\\n            } else {\\n                currDir = SOUTH;\\n            }\\n        } else if(goDir == NORTH) {\\n            if(r != 0) {\\n                currDir = NORTH; \\n            } else {\\n                currDir = EAST;\\n            }\\n        } else if(goDir == WEST) {\\n            if(c != cols-1) {\\n                currDir = WEST;\\n            } else {\\n                currDir = NORTH;\\n            }\\n        } else if(goDir == SOUTH) {\\n            if(r != rows-1) {\\n                currDir = SOUTH;\\n            } else {\\n                currDir = WEST;\\n            }\\n        }\\n    }\\n}\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot obj = new Robot(width, height);\\n * obj.step(num);\\n * int[] param_2 = obj.getPos();\\n * String param_3 = obj.getDir();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1894428,
                "title": "typescript-solution",
                "content": "```\\nconst dx = [1, 0, -1, 0];\\nconst dy = [0, 1, 0, -1];\\n\\nclass Robot {\\n    width: number;\\n    height: number;\\n    dir: number;\\n    x: number;\\n    y: number;\\n\\n\\n    constructor(width: number, height: number) {\\n        this.width = width;\\n        this.height = height;\\n        this.dir = 0;\\n        this.x = 0;\\n        this.y = 0;\\n    }\\n\\n    step(num: number): void {\\n        // \\u53D6\\u6A21\\uFF0C\\u4E0D\\u7136\\u4F1A\\u8D85\\u65F6\\u3002\\u5148\\u51CF\\u4E00\\u540E\\u52A0\\u4E00\\uFF0C\\u5904\\u7406\\u7684\\u60C5\\u51B5\\u662F\\u539F\\u70B9\\u7279\\u6B8A\\u60C5\\u51B5\\n        num = (num - 1) % ((this.width - 1 + this.height - 1) * 2) + 1;\\n        for (let i = 0; i < num; i++) {\\n            let nextX = this.x + dx[this.dir];\\n            let nextY = this.y + dy[this.dir];\\n            if (nextX >= this.width || nextX <= -1 || nextY >= this.height || nextY <= -1) {\\n                //turn direction and recompute the nextX and nextY\\n                this.dir = (this.dir + 1) % 4;\\n                nextX = this.x + dx[this.dir];\\n                nextY = this.y + dy[this.dir];\\n            }\\n            this.x = nextX;\\n            this.y = nextY;\\n        }\\n        \\n    }\\n\\n    getPos(): number[] {\\n        return [this.x, this.y];\\n    }\\n\\n    getDir(): string {\\n        return [\"East\", \"North\", \"West\", \"South\"][this.dir];\\n    }\\n}\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * var obj = new Robot(width, height)\\n * obj.step(num)\\n * var param_2 = obj.getPos()\\n * var param_3 = obj.getDir()\\n */\\n ```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nconst dx = [1, 0, -1, 0];\\nconst dy = [0, 1, 0, -1];\\n\\nclass Robot {\\n    width: number;\\n    height: number;\\n    dir: number;\\n    x: number;\\n    y: number;\\n\\n\\n    constructor(width: number, height: number) {\\n        this.width = width;\\n        this.height = height;\\n        this.dir = 0;\\n        this.x = 0;\\n        this.y = 0;\\n    }\\n\\n    step(num: number): void {\\n        // \\u53D6\\u6A21\\uFF0C\\u4E0D\\u7136\\u4F1A\\u8D85\\u65F6\\u3002\\u5148\\u51CF\\u4E00\\u540E\\u52A0\\u4E00\\uFF0C\\u5904\\u7406\\u7684\\u60C5\\u51B5\\u662F\\u539F\\u70B9\\u7279\\u6B8A\\u60C5\\u51B5\\n        num = (num - 1) % ((this.width - 1 + this.height - 1) * 2) + 1;\\n        for (let i = 0; i < num; i++) {\\n            let nextX = this.x + dx[this.dir];\\n            let nextY = this.y + dy[this.dir];\\n            if (nextX >= this.width || nextX <= -1 || nextY >= this.height || nextY <= -1) {\\n                //turn direction and recompute the nextX and nextY\\n                this.dir = (this.dir + 1) % 4;\\n                nextX = this.x + dx[this.dir];\\n                nextY = this.y + dy[this.dir];\\n            }\\n            this.x = nextX;\\n            this.y = nextY;\\n        }\\n        \\n    }\\n\\n    getPos(): number[] {\\n        return [this.x, this.y];\\n    }\\n\\n    getDir(): string {\\n        return [\"East\", \"North\", \"West\", \"South\"][this.dir];\\n    }\\n}\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * var obj = new Robot(width, height)\\n * obj.step(num)\\n * var param_2 = obj.getPos()\\n * var param_3 = obj.getDir()\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1854942,
                "title": "simple-c-solution-why-robot-should-face-south",
                "content": "```\\nclass Robot {\\npublic:\\n    unordered_map<int, string> mp = {{0,\"East\"}, {1,\"North\"}, {2,\"West\"}, {3,\"South\"}};\\n    vector<vector<int>> v;\\n    int dir = 0, m, n;\\n    pair<int,int> p;\\n    void move_east(int num){\\n        if(p.second + num < n){\\n            p.second += num;\\n        }\\n        else {\\n            num = num -(n - p.second)+1;\\n            p = {m-1,n-1};\\n            dir = 1;\\n            move_north(num);\\n        }\\n    }\\n    \\n    void move_north(int num){\\n        if(p.first - num >= 0){\\n            p.first -= num;\\n        }\\n        else {\\n            num = num - p.first;\\n            p = {0,n-1};\\n            dir = 2;\\n            move_west(num);\\n        }\\n    }\\n    \\n    void move_west(int num){\\n        if(p.second - num >= 0){\\n            p.second -= num;\\n        }\\n        else {\\n            num = num - p.second;\\n            p = {0,0};\\n            dir = 3;\\n            move_south(num);\\n        }\\n    }\\n    \\n    void move_south(int num){\\n        if(p.first + num < m){\\n            p.first += num;\\n        }\\n        else {\\n            num = num -(m - p.first)+1;\\n            p = {m-1,0};\\n            if(num){\\n                dir = 0;\\n                move_east(num);\\n            }\\n        }\\n    }\\n    \\n    Robot(int width, int height) {\\n        v.resize(height,vector<int>(0,width));\\n        m = height, n = width;\\n        p = {m-1, 0};\\n    }\\n    \\n    void step(int num) {\\n        int s = 2*(n + m) - 4;\\n        if(num >= s){\\n            // because robot has taken a complete trip of the grid so it should face south\\n            if (p.second == 0 && p.first == m-1 && dir == 0) \\n                dir = 3;\\n            num %= s;\\n        }\\n        if(dir == 0)\\n            move_east(num);\\n        else if(dir == 1)\\n            move_north(num);\\n        else if(dir == 2)\\n            move_west(num);\\n        else move_south(num);\\n    }\\n    \\n    vector<int> getPos() {\\n        return {p.second, m - p.first-1};\\n    }\\n    \\n    string getDir() {\\n        return mp[dir];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\nclass Robot {\\npublic:\\n    unordered_map<int, string> mp = {{0,\"East\"}, {1,\"North\"}, {2,\"West\"}, {3,\"South\"}};\\n    vector<vector<int>> v;\\n    int dir = 0, m, n;\\n    pair<int,int> p;\\n    void move_east(int num){\\n        if(p.second + num < n){\\n            p.second += num;\\n        }\\n        else {\\n            num = num -(n - p.second)+1;\\n            p = {m-1,n-1};\\n            dir = 1;\\n            move_north(num);\\n        }\\n    }\\n    \\n    void move_north(int num){\\n        if(p.first - num >= 0){\\n            p.first -= num;\\n        }\\n        else {\\n            num = num - p.first;\\n            p = {0,n-1};\\n            dir = 2;\\n            move_west(num);\\n        }\\n    }\\n    \\n    void move_west(int num){\\n        if(p.second - num >= 0){\\n            p.second -= num;\\n        }\\n        else {\\n            num = num - p.second;\\n            p = {0,0};\\n            dir = 3;\\n            move_south(num);\\n        }\\n    }\\n    \\n    void move_south(int num){\\n        if(p.first + num < m){\\n            p.first += num;\\n        }\\n        else {\\n            num = num -(m - p.first)+1;\\n            p = {m-1,0};\\n            if(num){\\n                dir = 0;\\n                move_east(num);\\n            }\\n        }\\n    }\\n    \\n    Robot(int width, int height) {\\n        v.resize(height,vector<int>(0,width));\\n        m = height, n = width;\\n        p = {m-1, 0};\\n    }\\n    \\n    void step(int num) {\\n        int s = 2*(n + m) - 4;\\n        if(num >= s){\\n            // because robot has taken a complete trip of the grid so it should face south\\n            if (p.second == 0 && p.first == m-1 && dir == 0) \\n                dir = 3;\\n            num %= s;\\n        }\\n        if(dir == 0)\\n            move_east(num);\\n        else if(dir == 1)\\n            move_north(num);\\n        else if(dir == 2)\\n            move_west(num);\\n        else move_south(num);\\n    }\\n    \\n    vector<int> getPos() {\\n        return {p.second, m - p.first-1};\\n    }\\n    \\n    string getDir() {\\n        return mp[dir];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1847717,
                "title": "c-simple-solution",
                "content": "```\\npublic class Robot \\n{\\n    int[,] _matrix;\\n    int _totalMovement;\\n    string[] _directions = {\"East\", \"North\", \"West\",\"South\"};\\n    int[,] _dirChange = {{1,0},{0,1},{-1,0},{0,-1}};\\n    int _dir = 0;\\n    int Dir \\n    { \\n        get\\n        {\\n            _dir = _dir % 4;\\n            return _dir;\\n        }\\n        set\\n        {\\n            _dir = value;\\n        }\\n    }\\n    \\n    int[] _pos = {0,0};\\n    \\n    public Robot(int width, int height) \\n    {\\n        _matrix = new int[width,height];\\n        _totalMovement = 2*width + 2*(height-2);\\n    }\\n    \\n    public void Step(int num) \\n    {\\n        num = num%_totalMovement;\\n        \\n        if(num==0 && _pos[0]==0 && _pos[1]==0)\\n            Dir = 3;\\n        \\n        for(int i=0;i<num;i++)\\n        {\\n            int x = _pos[0] + _dirChange[Dir,0];\\n            int y = _pos[1] + _dirChange[Dir,1];\\n            \\n            while(IsInValidMove(x,y))\\n            {\\n                Dir++;\\n                x = _pos[0] + _dirChange[Dir,0];\\n                y = _pos[1] + _dirChange[Dir,1];\\n            }\\n            \\n            _pos[0] = x;\\n            _pos[1] = y;\\n        }\\n    }\\n    \\n    private bool IsInValidMove(int x, int y)=> x<0 || x>=_matrix.GetLength(0) || y<0 || y>=_matrix.GetLength(1);\\n    \\n    public int[] GetPos() {\\n        return _pos;\\n    }\\n    \\n    public string GetDir() \\n    {\\n        return _directions[Dir];\\n    }\\n}\\n ```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Robot \\n{\\n    int[,] _matrix;\\n    int _totalMovement;\\n    string[] _directions = {\"East\", \"North\", \"West\",\"South\"};\\n    int[,] _dirChange = {{1,0},{0,1},{-1,0},{0,-1}};\\n    int _dir = 0;\\n    int Dir \\n    { \\n        get\\n        {\\n            _dir = _dir % 4;\\n            return _dir;\\n        }\\n        set\\n        {\\n            _dir = value;\\n        }\\n    }\\n    \\n    int[] _pos = {0,0};\\n    \\n    public Robot(int width, int height) \\n    {\\n        _matrix = new int[width,height];\\n        _totalMovement = 2*width + 2*(height-2);\\n    }\\n    \\n    public void Step(int num) \\n    {\\n        num = num%_totalMovement;\\n        \\n        if(num==0 && _pos[0]==0 && _pos[1]==0)\\n            Dir = 3;\\n        \\n        for(int i=0;i<num;i++)\\n        {\\n            int x = _pos[0] + _dirChange[Dir,0];\\n            int y = _pos[1] + _dirChange[Dir,1];\\n            \\n            while(IsInValidMove(x,y))\\n            {\\n                Dir++;\\n                x = _pos[0] + _dirChange[Dir,0];\\n                y = _pos[1] + _dirChange[Dir,1];\\n            }\\n            \\n            _pos[0] = x;\\n            _pos[1] = y;\\n        }\\n    }\\n    \\n    private bool IsInValidMove(int x, int y)=> x<0 || x>=_matrix.GetLength(0) || y<0 || y>=_matrix.GetLength(1);\\n    \\n    public int[] GetPos() {\\n        return _pos;\\n    }\\n    \\n    public string GetDir() \\n    {\\n        return _directions[Dir];\\n    }\\n}\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1847429,
                "title": "test-case-140-fails-anyone-can-help-debug-java-soln",
                "content": "Here is my code\\n```\\nclass Robot {\\n    \\n    int x;\\n    int y;\\n    int xMax;\\n    int yMax;\\n    int dir;\\n    Map<Integer,String> dirMap;\\n\\n    public Robot(int width, int height) {\\n        x=0;\\n        y=0;\\n        xMax = width-1;\\n        yMax = height-1;\\n        dirMap = new HashMap<Integer,String>();\\n        dirMap.put(0,\"East\");\\n        dirMap.put(1,\"North\");\\n        dirMap.put(2,\"West\");\\n        dirMap.put(3,\"South\");\\n    }\\n    \\n    public void step(int num) {\\n        /* num of steps can be very high, but it will\\n        can be adjusted by taking mod of (2*height + 2*weight*)\\n        since it will actually keep looping in the same area otherwise */\\n        num = num % (2*xMax+2*yMax);\\n        int steps = 0;\\n        int remaining = num;\\n        while(steps != num && remaining != 0)\\n        {\\n            int canGo = 0;\\n            if(dir == 0)\\n            {\\n                canGo = xMax-x;\\n                if(canGo>=remaining)\\n                {  \\n                    x = x+remaining;\\n                    steps += remaining;\\n                    remaining = 0;\\n                }\\n                else\\n                {\\n                    x += canGo;\\n                    steps += canGo;\\n                    remaining = remaining - canGo;\\n                    dir = 1;\\n                }\\n            }\\n            else if(dir == 1)\\n            {\\n                canGo = yMax-y;\\n                if(canGo>=remaining)\\n                {  \\n                    y = y+remaining;\\n                    steps += remaining;\\n                    remaining = 0;\\n                }\\n                else\\n                {\\n                    y += canGo;\\n                    steps += canGo;\\n                    remaining = remaining - canGo;\\n                    dir = 2;\\n                }   \\n            }\\n            else if(dir == 2)\\n            {\\n                canGo = x-0;\\n                if(canGo>=remaining)\\n                {  \\n                    x = x-remaining;\\n                    steps += remaining;\\n                    remaining = 0;\\n                }\\n                else\\n                {\\n                    x -= canGo;\\n                    steps += canGo;\\n                    remaining = remaining - canGo;\\n                    dir = 3;\\n                }   \\n            }\\n            else//dir = 3\\n            {   canGo = y - 0;\\n                if(canGo>=remaining)\\n                {  \\n                    y = y-remaining;\\n                    steps += remaining;\\n                    remaining = 0;\\n                }\\n                else\\n                {\\n                    y -= canGo;\\n                    steps += canGo;\\n                    remaining = remaining - canGo;\\n                    dir = 0;\\n                }\\n                \\n            }\\n        }\\n        \\n    }\\n    \\n    public int[] getPos() {\\n        int[] result = new int[2];\\n        result[0] = x;\\n        result[1] = y;\\n        return result;\\n    }\\n    \\n    public String getDir() {\\n        return dirMap.get(dir);\\n    }\\n}\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot obj = new Robot(width, height);\\n * obj.step(num);\\n * int[] param_2 = obj.getPos();\\n * String param_3 = obj.getDir();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Robot {\\n    \\n    int x;\\n    int y;\\n    int xMax;\\n    int yMax;\\n    int dir;\\n    Map<Integer,String> dirMap;\\n\\n    public Robot(int width, int height) {\\n        x=0;\\n        y=0;\\n        xMax = width-1;\\n        yMax = height-1;\\n        dirMap = new HashMap<Integer,String>();\\n        dirMap.put(0,\"East\");\\n        dirMap.put(1,\"North\");\\n        dirMap.put(2,\"West\");\\n        dirMap.put(3,\"South\");\\n    }\\n    \\n    public void step(int num) {\\n        /* num of steps can be very high, but it will\\n        can be adjusted by taking mod of (2*height + 2*weight*)\\n        since it will actually keep looping in the same area otherwise */\\n        num = num % (2*xMax+2*yMax);\\n        int steps = 0;\\n        int remaining = num;\\n        while(steps != num && remaining != 0)\\n        {\\n            int canGo = 0;\\n            if(dir == 0)\\n            {\\n                canGo = xMax-x;\\n                if(canGo>=remaining)\\n                {  \\n                    x = x+remaining;\\n                    steps += remaining;\\n                    remaining = 0;\\n                }\\n                else\\n                {\\n                    x += canGo;\\n                    steps += canGo;\\n                    remaining = remaining - canGo;\\n                    dir = 1;\\n                }\\n            }\\n            else if(dir == 1)\\n            {\\n                canGo = yMax-y;\\n                if(canGo>=remaining)\\n                {  \\n                    y = y+remaining;\\n                    steps += remaining;\\n                    remaining = 0;\\n                }\\n                else\\n                {\\n                    y += canGo;\\n                    steps += canGo;\\n                    remaining = remaining - canGo;\\n                    dir = 2;\\n                }   \\n            }\\n            else if(dir == 2)\\n            {\\n                canGo = x-0;\\n                if(canGo>=remaining)\\n                {  \\n                    x = x-remaining;\\n                    steps += remaining;\\n                    remaining = 0;\\n                }\\n                else\\n                {\\n                    x -= canGo;\\n                    steps += canGo;\\n                    remaining = remaining - canGo;\\n                    dir = 3;\\n                }   \\n            }\\n            else//dir = 3\\n            {   canGo = y - 0;\\n                if(canGo>=remaining)\\n                {  \\n                    y = y-remaining;\\n                    steps += remaining;\\n                    remaining = 0;\\n                }\\n                else\\n                {\\n                    y -= canGo;\\n                    steps += canGo;\\n                    remaining = remaining - canGo;\\n                    dir = 0;\\n                }\\n                \\n            }\\n        }\\n        \\n    }\\n    \\n    public int[] getPos() {\\n        int[] result = new int[2];\\n        result[0] = x;\\n        result[1] = y;\\n        return result;\\n    }\\n    \\n    public String getDir() {\\n        return dirMap.get(dir);\\n    }\\n}\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot obj = new Robot(width, height);\\n * obj.step(num);\\n * int[] param_2 = obj.getPos();\\n * String param_3 = obj.getDir();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846968,
                "title": "javascript-solution-beat-100",
                "content": "```\\n/**\\n * @param {number} width\\n * @param {number} height\\n */\\nvar Robot = function(width, height) {\\n    this.width = width - 1;\\n    this.height = height - 1;\\n    this.position = 0;\\n    this.mod = (this.width + this.height) * 2;\\n    this.direction = \\'East\\';\\n    this.moved = false;\\n};\\n\\n/** \\n * @param {number} num\\n * @return {void}\\n */\\nRobot.prototype.step = function(num) {\\n    this.moved = true;\\n    this.position += num;\\n    this.position = this.position % this.mod;\\n};\\n\\n/**\\n * @return {number[]}\\n */\\nRobot.prototype.getPos = function() {\\n    let pos = this.position;\\n    if (pos <= this.width) {\\n        return [pos, 0];\\n    }\\n    pos -= this.width;\\n    if (pos <= this.height) {\\n        return [this.width, pos];\\n    }\\n    pos -= this.height;\\n    if (pos <= this.width) {\\n        return [this.width - pos, this.height];\\n    }\\n    pos -= this.width;\\n    if (pos <= this.height) {\\n        return [0, this.height - pos];\\n    }\\n    \\n};\\n\\n/**\\n * @return {string}\\n */\\nRobot.prototype.getDir = function() {\\n    let pos = this.position;\\n    if (pos === 0) {\\n        return this.moved ? \\'South\\' : \\'East\\'\\n    }\\n    if (pos <= this.width) {\\n        return \\'East\\';\\n    }\\n    pos -= this.width;\\n    if (pos <= this.height) {\\n        return \\'North\\';\\n    }\\n    pos -= this.height;\\n    if (pos <= this.width) {\\n        return \\'West\\';\\n    }\\n    pos -= this.width;\\n    if (pos <= this.height) {\\n        return \\'South\\';\\n    }\\n    \\n};\\n\\n/** \\n * Your Robot object will be instantiated and called as such:\\n * var obj = new Robot(width, height)\\n * obj.step(num)\\n * var param_2 = obj.getPos()\\n * var param_3 = obj.getDir()\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} width\\n * @param {number} height\\n */\\nvar Robot = function(width, height) {\\n    this.width = width - 1;\\n    this.height = height - 1;\\n    this.position = 0;\\n    this.mod = (this.width + this.height) * 2;\\n    this.direction = \\'East\\';\\n    this.moved = false;\\n};\\n\\n/** \\n * @param {number} num\\n * @return {void}\\n */\\nRobot.prototype.step = function(num) {\\n    this.moved = true;\\n    this.position += num;\\n    this.position = this.position % this.mod;\\n};\\n\\n/**\\n * @return {number[]}\\n */\\nRobot.prototype.getPos = function() {\\n    let pos = this.position;\\n    if (pos <= this.width) {\\n        return [pos, 0];\\n    }\\n    pos -= this.width;\\n    if (pos <= this.height) {\\n        return [this.width, pos];\\n    }\\n    pos -= this.height;\\n    if (pos <= this.width) {\\n        return [this.width - pos, this.height];\\n    }\\n    pos -= this.width;\\n    if (pos <= this.height) {\\n        return [0, this.height - pos];\\n    }\\n    \\n};\\n\\n/**\\n * @return {string}\\n */\\nRobot.prototype.getDir = function() {\\n    let pos = this.position;\\n    if (pos === 0) {\\n        return this.moved ? \\'South\\' : \\'East\\'\\n    }\\n    if (pos <= this.width) {\\n        return \\'East\\';\\n    }\\n    pos -= this.width;\\n    if (pos <= this.height) {\\n        return \\'North\\';\\n    }\\n    pos -= this.height;\\n    if (pos <= this.width) {\\n        return \\'West\\';\\n    }\\n    pos -= this.width;\\n    if (pos <= this.height) {\\n        return \\'South\\';\\n    }\\n    \\n};\\n\\n/** \\n * Your Robot object will be instantiated and called as such:\\n * var obj = new Robot(width, height)\\n * obj.step(num)\\n * var param_2 = obj.getPos()\\n * var param_3 = obj.getDir()\\n */\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1768288,
                "title": "simple-java-solution-100-efficient",
                "content": "class Robot {\\n    \\n\\tString[] dir;\\n    int[][] coordinates;\\n    int currCoordinate, limit;\\n    \\n    \\n    public Robot(int width, int height) {\\n        dir = new String[]{\"East\", \"North\", \"West\", \"South\"};\\n        \\n        limit = 2 * width + 2 * (height - 2);\\n        coordinates = new int[limit][3];\\n        \\n        int currCoordinate = 0, X = 0, Y = 1;\\n        \\n        while(X < width){\\n            coordinates[currCoordinate][0] = X;\\n            currCoordinate++; X++;\\n        }\\n        \\n        X -= 1;\\n        \\n        while(Y < height){\\n            coordinates[currCoordinate][0] = X;\\n            coordinates[currCoordinate][1] = Y;\\n            coordinates[currCoordinate][2] = 1;\\n            currCoordinate++; Y++;\\n        }\\n        \\n        Y -= 1;\\n        X -= 1;\\n        \\n        while(X >= 0){\\n            coordinates[currCoordinate][0] = X;\\n            coordinates[currCoordinate][1] = Y;\\n            coordinates[currCoordinate][2] = 2;\\n            currCoordinate++; X--;\\n        }\\n        \\n        X += 1;\\n        Y -= 1;\\n        \\n        while(Y >= 1){\\n            coordinates[currCoordinate][0] = X;\\n            coordinates[currCoordinate][1] = Y;\\n            coordinates[currCoordinate][2] = 3;\\n            currCoordinate++; Y--;\\n        }\\n        \\n        currCoordinate = 0;\\n    }\\n    \\n    public void step(int num) {\\n        currCoordinate = (currCoordinate + num) % limit;\\n        if(coordinates[0][2] == 0){\\n            coordinates[0][2] = 3;\\n        }\\n    }\\n    \\n    public int[] getPos() {\\n        return new int[]{coordinates[currCoordinate][0], coordinates[currCoordinate][1]};\\n    }\\n    \\n    public String getDir() {\\n        return dir[coordinates[currCoordinate][2]];\\n    }\\n}\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot obj = new Robot(width, height);\\n * obj.step(num);\\n * int[] param_2 = obj.getPos();\\n * String param_3 = obj.getDir();\\n */",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Robot {\\n    \\n\\tString[] dir;\\n    int[][] coordinates;\\n    int currCoordinate, limit;\\n    \\n    \\n    public Robot(int width, int height) {\\n        dir = new String[]{\"East\", \"North\", \"West\", \"South\"};\\n        \\n        limit = 2 * width + 2 * (height - 2);\\n        coordinates = new int[limit][3];\\n        \\n        int currCoordinate = 0, X = 0, Y = 1;\\n        \\n        while(X < width){\\n            coordinates[currCoordinate][0] = X;\\n            currCoordinate++; X++;\\n        }\\n        \\n        X -= 1;\\n        \\n        while(Y < height){\\n            coordinates[currCoordinate][0] = X;\\n            coordinates[currCoordinate][1] = Y;\\n            coordinates[currCoordinate][2] = 1;\\n            currCoordinate++; Y++;\\n        }\\n        \\n        Y -= 1;\\n        X -= 1;\\n        \\n        while(X >= 0){\\n            coordinates[currCoordinate][0] = X;\\n            coordinates[currCoordinate][1] = Y;\\n            coordinates[currCoordinate][2] = 2;\\n            currCoordinate++; X--;\\n        }\\n        \\n        X += 1;\\n        Y -= 1;\\n        \\n        while(Y >= 1){\\n            coordinates[currCoordinate][0] = X;\\n            coordinates[currCoordinate][1] = Y;\\n            coordinates[currCoordinate][2] = 3;\\n            currCoordinate++; Y--;\\n        }\\n        \\n        currCoordinate = 0;\\n    }\\n    \\n    public void step(int num) {\\n        currCoordinate = (currCoordinate + num) % limit;\\n        if(coordinates[0][2] == 0){\\n            coordinates[0][2] = 3;\\n        }\\n    }\\n    \\n    public int[] getPos() {\\n        return new int[]{coordinates[currCoordinate][0], coordinates[currCoordinate][1]};\\n    }\\n    \\n    public String getDir() {\\n        return dir[coordinates[currCoordinate][2]];\\n    }\\n}\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot obj = new Robot(width, height);\\n * obj.step(num);\\n * int[] param_2 = obj.getPos();\\n * String param_3 = obj.getDir();\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1764291,
                "title": "my-brute-force-solution-easy-to-understand",
                "content": "Basically, mod the num of step and then let the robot roll. \\n\\n```java\\nclass Robot {\\n\\n    enum Direction{\\n        North,\\n        West,\\n        South,\\n        East\\n    }\\n    \\n    static int[][] BOARD; \\n    int[] position; \\n    Direction direction;\\n    int round = 0;\\n        \\n   public Robot(int width, int height) {\\n        // bottom-left (0,0). top-right (width-1, height-1);\\n        this.BOARD = new int[height][width]; \\n        this.position = new int[] { 0, 0 };  //intial position \\n        this.direction = Direction.East; //initial direction \\n       this.round = 2 * (width -1 + height - 1);\\n    }\\n\\n    public void step(int num) {\\n        // cc-wise: east -> north -> west -> south\\n        int width = BOARD[0].length; \\n        int height = BOARD.length;  \\n        num = num % round; // 140/142 cases with only this part \\n        \\n        //have to add this to pass all 142 test cases \\n        if (num == 0){\\n\\t\\t\\tnum = round;\\n        }\\n\\t\\t\\n        while (num > 0) {\\n            num--;\\n            switch (this.direction) {\\n                case East:\\n                    if (++position[0] < width) {\\n                        continue; \\n                    } else {\\n                        position[0]--; \\n                        position[1]++;\\n                        this.direction = Direction.North;\\n                    }\\n                    break;\\n                case North:\\n                    if (++position[1] < height) { \\n                        continue;\\n                    } else {\\n                        position[1]--; \\n                        position[0]--;\\n                        this.direction = Direction.West;\\n                    }\\n                    break;\\n                case West:\\n                    if (--position[0] >= 0) { \\n                        continue;\\n                    } else {\\n                        position[0]++;\\n                        position[1]--;\\n                        this.direction = Direction.South;\\n                    }\\n                    break;\\n                case South:\\n                    if (--position[1] >= 0) {\\n                        continue;\\n                    } else {\\n                        position[1]++;\\n                        position[0]++;\\n                        this.direction = Direction.East;\\n                    }\\n                    break;\\n            }\\n        }\\n    }\\n    \\n    public int[] getPos() {\\n        return this.position;  \\n    }\\n    \\n    public String getDir() {\\n        return this.direction.name(); \\n    }\\n}\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot obj = new Robot(width, height);\\n * obj.step(num);\\n * int[] param_2 = obj.getPos();\\n * String param_3 = obj.getDir();\\n */\\n ```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Robot {\\n\\n    enum Direction{\\n        North,\\n        West,\\n        South,\\n        East\\n    }\\n    \\n    static int[][] BOARD; \\n    int[] position; \\n    Direction direction;\\n    int round = 0;\\n        \\n   public Robot(int width, int height) {\\n        // bottom-left (0,0). top-right (width-1, height-1);\\n        this.BOARD = new int[height][width]; \\n        this.position = new int[] { 0, 0 };  //intial position \\n        this.direction = Direction.East; //initial direction \\n       this.round = 2 * (width -1 + height - 1);\\n    }\\n\\n    public void step(int num) {\\n        // cc-wise: east -> north -> west -> south\\n        int width = BOARD[0].length; \\n        int height = BOARD.length;  \\n        num = num % round; // 140/142 cases with only this part \\n        \\n        //have to add this to pass all 142 test cases \\n        if (num == 0){\\n\\t\\t\\tnum = round;\\n        }\\n\\t\\t\\n        while (num > 0) {\\n            num--;\\n            switch (this.direction) {\\n                case East:\\n                    if (++position[0] < width) {\\n                        continue; \\n                    } else {\\n                        position[0]--; \\n                        position[1]++;\\n                        this.direction = Direction.North;\\n                    }\\n                    break;\\n                case North:\\n                    if (++position[1] < height) { \\n                        continue;\\n                    } else {\\n                        position[1]--; \\n                        position[0]--;\\n                        this.direction = Direction.West;\\n                    }\\n                    break;\\n                case West:\\n                    if (--position[0] >= 0) { \\n                        continue;\\n                    } else {\\n                        position[0]++;\\n                        position[1]--;\\n                        this.direction = Direction.South;\\n                    }\\n                    break;\\n                case South:\\n                    if (--position[1] >= 0) {\\n                        continue;\\n                    } else {\\n                        position[1]++;\\n                        position[0]++;\\n                        this.direction = Direction.East;\\n                    }\\n                    break;\\n            }\\n        }\\n    }\\n    \\n    public int[] getPos() {\\n        return this.position;  \\n    }\\n    \\n    public String getDir() {\\n        return this.direction.name(); \\n    }\\n}\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot obj = new Robot(width, height);\\n * obj.step(num);\\n * int[] param_2 = obj.getPos();\\n * String param_3 = obj.getDir();\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1757275,
                "title": "python-o-1-solution",
                "content": "Basic idea: count the total number of steps we have taken and then use the total steps to calculate our position and direction;\\n```\\nclass Robot:\\n    DIRS = [\\'North\\', \\'East\\', \\'South\\', \\'West\\']\\n    def __init__(self, width: int, height: int):\\n        self.width = width\\n        self.height=height\\n        self.dir = 1\\n        self.steps = 0\\n\\n    def turn(self) -> None:\\n        self.dir = (self.dir+3) % 4\\n        \\n    def step(self, num: int) -> None:\\n        self.steps+=num\\n\\n    def getPos(self) -> List[int]:\\n        delta = self.steps%(self.width*2+self.height*2 -4)\\n        if delta < self.width:\\n            return [delta, 0]\\n        elif delta < self.width + self.height-1:\\n            return [self.width-1, delta-self.width+1]\\n        elif delta < self.width * 2 + self.height - 2:\\n            return [self.width * 2 + self.height - 3 - delta, self.height-1]\\n        else:\\n            return [0, self.width*2+self.height*2 -4 - delta]\\n\\n    def getDir(self) -> str:\\n        delta = self.steps%(self.width*2+self.height*2 -4)\\n        if delta == 0 and self.steps>0:\\n            return \\'South\\'\\n        if delta < self.width:\\n            return \\'East\\'\\n        elif delta < self.width + self.height-1:\\n            return \\'North\\'\\n        elif delta < self.width * 2 + self.height - 2:\\n            return \\'West\\'\\n        else:\\n            return \\'South\\'\\n        \\n        \\n\\n\\n# Your Robot object will be instantiated and called as such:\\n# obj = Robot(width, height)\\n# obj.step(num)\\n# param_2 = obj.getPos()\\n# param_3 = obj.getDir()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Robot:\\n    DIRS = [\\'North\\', \\'East\\', \\'South\\', \\'West\\']\\n    def __init__(self, width: int, height: int):\\n        self.width = width\\n        self.height=height\\n        self.dir = 1\\n        self.steps = 0\\n\\n    def turn(self) -> None:\\n        self.dir = (self.dir+3) % 4\\n        \\n    def step(self, num: int) -> None:\\n        self.steps+=num\\n\\n    def getPos(self) -> List[int]:\\n        delta = self.steps%(self.width*2+self.height*2 -4)\\n        if delta < self.width:\\n            return [delta, 0]\\n        elif delta < self.width + self.height-1:\\n            return [self.width-1, delta-self.width+1]\\n        elif delta < self.width * 2 + self.height - 2:\\n            return [self.width * 2 + self.height - 3 - delta, self.height-1]\\n        else:\\n            return [0, self.width*2+self.height*2 -4 - delta]\\n\\n    def getDir(self) -> str:\\n        delta = self.steps%(self.width*2+self.height*2 -4)\\n        if delta == 0 and self.steps>0:\\n            return \\'South\\'\\n        if delta < self.width:\\n            return \\'East\\'\\n        elif delta < self.width + self.height-1:\\n            return \\'North\\'\\n        elif delta < self.width * 2 + self.height - 2:\\n            return \\'West\\'\\n        else:\\n            return \\'South\\'\\n        \\n        \\n\\n\\n# Your Robot object will be instantiated and called as such:\\n# obj = Robot(width, height)\\n# obj.step(num)\\n# param_2 = obj.getPos()\\n# param_3 = obj.getDir()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1742098,
                "title": "very-easy-to-understand-c-solution",
                "content": "1. Calculate the position of robot when you take next step and accordingly change the coordinates\\n2. The catch is to remove TLE we will do num=num%(2*h+2*w-4) the idea behid this was taken from this post  https://leetcode.com/problems/walking-robot-simulation-ii/discuss/1575926/Worst-Question-ever-Java-Solution-with-Explanation\\n\\n```\\nclass Robot {\\npublic:\\n    char curr=\\'e\\';\\n    int  i=0 , j=0 , h =0 , w=0;\\n    //Funtion to get direction in which next step would be taken\\n    char dir( char &curr , int &i , int  &j)\\n    {\\n      if(curr==\\'n\\')\\n      {\\n        if(j==h-1)  return \\'w\\';        \\n        else return curr;\\n      }\\n      if(curr==\\'s\\')\\n      {\\n        if(j==0) return \\'e\\';\\n        else return curr;\\n      }\\n      if(curr==\\'e\\') \\n      {\\n        if(i==w-1) return \\'n\\';\\n        else return curr;\\n      }\\n      if(curr==\\'w\\')\\n      {\\n        if(i==0) return \\'s\\';\\n        else return curr;\\n      }\\n      return \\'c\\';\\n    }\\n  \\n    Robot(int width, int height) {\\n      h=height , w=width;\\n    }\\n    \\n    void step(int num) {\\n      num %= w * 2 + h * 2 - 4;    // without this line the code will give tle\\n      if (num == 0) num = w * 2 + h * 2 - 4;   \\n      while(num--)\\n      { \\n        char next = dir(curr,i,j);\\n        if(next==\\'n\\') j++;\\n        if(next==\\'s\\') j--;\\n        if(next==\\'e\\') i++;\\n        if(next==\\'w\\') i--;\\n        curr=next;\\n      }       \\n    }\\n    \\n    vector<int> getPos() {\\n      vector<int> ans={i,j};\\n      return ans;        \\n    }\\n    \\n    string getDir() {\\n      if(curr==\\'n\\') return \"North\";\\n      if(curr==\\'s\\') return \"South\";\\n      if(curr==\\'e\\') return \"East\";\\n      if(curr==\\'w\\') return \"West\";\\n      return \"\";\\n    }\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot* obj = new Robot(width, height);\\n * obj->step(num);\\n * vector<int> param_2 = obj->getPos();\\n * string param_3 = obj->getDir();\\n */",
                "solutionTags": [],
                "code": "1. Calculate the position of robot when you take next step and accordingly change the coordinates\\n2. The catch is to remove TLE we will do num=num%(2*h+2*w-4) the idea behid this was taken from this post  https://leetcode.com/problems/walking-robot-simulation-ii/discuss/1575926/Worst-Question-ever-Java-Solution-with-Explanation\\n\\n```\\nclass Robot {\\npublic:\\n    char curr=\\'e\\';\\n    int  i=0 , j=0 , h =0 , w=0;\\n    //Funtion to get direction in which next step would be taken\\n    char dir( char &curr , int &i , int  &j)\\n    {\\n      if(curr==\\'n\\')\\n      {\\n        if(j==h-1)  return \\'w\\';        \\n        else return curr;\\n      }\\n      if(curr==\\'s\\')\\n      {\\n        if(j==0) return \\'e\\';\\n        else return curr;\\n      }\\n      if(curr==\\'e\\') \\n      {\\n        if(i==w-1) return \\'n\\';\\n        else return curr;\\n      }\\n      if(curr==\\'w\\')\\n      {\\n        if(i==0) return \\'s\\';\\n        else return curr;\\n      }\\n      return \\'c\\';\\n    }\\n  \\n    Robot(int width, int height) {\\n      h=height , w=width;\\n    }\\n    \\n    void step(int num) {\\n      num %= w * 2 + h * 2 - 4;    // without this line the code will give tle\\n      if (num == 0) num = w * 2 + h * 2 - 4;   \\n      while(num--)\\n      { \\n        char next = dir(curr,i,j);\\n        if(next==\\'n\\') j++;\\n        if(next==\\'s\\') j--;\\n        if(next==\\'e\\') i++;\\n        if(next==\\'w\\') i--;\\n        curr=next;\\n      }       \\n    }\\n    \\n    vector<int> getPos() {\\n      vector<int> ans={i,j};\\n      return ans;        \\n    }\\n    \\n    string getDir() {\\n      if(curr==\\'n\\') return \"North\";\\n      if(curr==\\'s\\') return \"South\";\\n      if(curr==\\'e\\') return \"East\";\\n      if(curr==\\'w\\') return \"West\";\\n      return \"\";\\n    }\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot* obj = new Robot(width, height);\\n * obj->step(num);\\n * vector<int> param_2 = obj->getPos();\\n * string param_3 = obj->getDir();\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1699309,
                "title": "java-solution-o-1",
                "content": "Call to any method is O(1).\\n\\nTime Complexity : O(N), where N is the total number of method called.\\n\\n```\\nclass Robot {\\n    int w;\\n    int h;\\n    int x;\\n    int y;\\n    int dir;\\n    int[][] ar;\\n    public Robot(int width, int height) {\\n        x = 0;\\n        y = 0;\\n        w = width;\\n        h = height;\\n        dir = 0;\\n        ar = new int[][] {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n    }\\n    \\n    public void step(int num) {\\n        num %= w * 2 + h * 2 - 4;\\n        \\n        if (num == 0 && x== 0 && y == 0)\\n            dir = 3; // South\\n        \\n        x += num*ar[dir][0];\\n        y += num*ar[dir][1];\\n        int left = 0;\\n        \\n        // This while loop will run atmost 4 times only. \\n        while( x >= w || y >= h || x < 0 || y < 0){\\n            if( x >= w || y >= h) {\\n                left = Math.max(x - w + 1, y - h + 1);\\n                x = Math.min(w - 1, x);\\n                y = Math.min(h - 1, y);\\n            }\\n            else{\\n                left = -1 * Math.min(x, y);\\n                x = Math.max(0, x);\\n                y = Math.max(0, y);\\n            }\\n            dir = (dir + 1) % 4;\\n            x += left * ar[dir][0];\\n            y += left * ar[dir][1];\\n        }\\n    }\\n    \\n    public int[] getPos() {\\n        return new int[] {x, y};\\n    }\\n    \\n    public String getDir() {\\n        if( dir == 0)\\n            return \"East\";\\n        else if (dir == 1)\\n            return \"North\";\\n        else if (dir == 2)\\n            return \"West\";\\n        return \"South\"; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Robot {\\n    int w;\\n    int h;\\n    int x;\\n    int y;\\n    int dir;\\n    int[][] ar;\\n    public Robot(int width, int height) {\\n        x = 0;\\n        y = 0;\\n        w = width;\\n        h = height;\\n        dir = 0;\\n        ar = new int[][] {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n    }\\n    \\n    public void step(int num) {\\n        num %= w * 2 + h * 2 - 4;\\n        \\n        if (num == 0 && x== 0 && y == 0)\\n            dir = 3; // South\\n        \\n        x += num*ar[dir][0];\\n        y += num*ar[dir][1];\\n        int left = 0;\\n        \\n        // This while loop will run atmost 4 times only. \\n        while( x >= w || y >= h || x < 0 || y < 0){\\n            if( x >= w || y >= h) {\\n                left = Math.max(x - w + 1, y - h + 1);\\n                x = Math.min(w - 1, x);\\n                y = Math.min(h - 1, y);\\n            }\\n            else{\\n                left = -1 * Math.min(x, y);\\n                x = Math.max(0, x);\\n                y = Math.max(0, y);\\n            }\\n            dir = (dir + 1) % 4;\\n            x += left * ar[dir][0];\\n            y += left * ar[dir][1];\\n        }\\n    }\\n    \\n    public int[] getPos() {\\n        return new int[] {x, y};\\n    }\\n    \\n    public String getDir() {\\n        if( dir == 0)\\n            return \"East\";\\n        else if (dir == 1)\\n            return \"North\";\\n        else if (dir == 2)\\n            return \"West\";\\n        return \"South\"; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1692448,
                "title": "c-184-ms",
                "content": "```\\nclass Robot {\\npublic:\\n    Robot(int width, int height):w(--width),h(--height),p(w+w+h+h) {}\\n    \\n    void step(int num) {\\n        if(num and d==4) --d; //for first move\\n        num%=p;\\n        while(num) {\\n            switch(d) {\\n                case 0:\\n                    if(x+num<=w) { x+=num; num=0; }\\n                    else { num-=w-x; x=w; d=1; }\\n                    break;\\n                case 1:\\n                    if(y+num<=h) { y+=num; num=0; }\\n                    else { num-=h-y; y=h; d=2; }\\n                    break;\\n                case 2:\\n                    if(x-num>=0) { x-=num; num=0; }\\n                    else { num-=x; x=0; d=3; }\\n                    break;\\n                case 3:\\n                    if(y-num>=0) { y-=num; num=0; }\\n                    else { num-=y; y=0; d=0; }\\n            };\\n        }\\n    }\\n    \\n    vector<int> getPos() {\\n        return {x,y};\\n    }\\n    \\n    string getDir() {\\n        switch(d) {\\n            case 1 : return \"North\";\\n            case 2 : return \"West\" ;\\n            case 3 : return \"South\";\\n            default: return \"East\" ;\\n        };\\n    }\\nprivate:\\n    int x=0,y=0,d=4,w,h,p;\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Robot {\\npublic:\\n    Robot(int width, int height):w(--width),h(--height),p(w+w+h+h) {}\\n    \\n    void step(int num) {\\n        if(num and d==4) --d; //for first move\\n        num%=p;\\n        while(num) {\\n            switch(d) {\\n                case 0:\\n                    if(x+num<=w) { x+=num; num=0; }\\n                    else { num-=w-x; x=w; d=1; }\\n                    break;\\n                case 1:\\n                    if(y+num<=h) { y+=num; num=0; }\\n                    else { num-=h-y; y=h; d=2; }\\n                    break;\\n                case 2:\\n                    if(x-num>=0) { x-=num; num=0; }\\n                    else { num-=x; x=0; d=3; }\\n                    break;\\n                case 3:\\n                    if(y-num>=0) { y-=num; num=0; }\\n                    else { num-=y; y=0; d=0; }\\n            };\\n        }\\n    }\\n    \\n    vector<int> getPos() {\\n        return {x,y};\\n    }\\n    \\n    string getDir() {\\n        switch(d) {\\n            case 1 : return \"North\";\\n            case 2 : return \"West\" ;\\n            case 3 : return \"South\";\\n            default: return \"East\" ;\\n        };\\n    }\\nprivate:\\n    int x=0,y=0,d=4,w,h,p;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1683085,
                "title": "python3-easy-to-understand-solution-with-comments-for-walking-robot-simulation-ii-problem",
                "content": "This question gave me a lot of trouble... If it has first moved and comesback to 0,0, it\\'s facing South still... not East...\\n```\\nclass Robot:\\n\\n    def __init__(self, width: int, height: int):\\n        self.direction = \"East\"  # Faces East at the start\\n        self.position = [0, 0]  # Is at position (0,0) on the board at the start\\n        self.moved = False # Had to add this so if we\\'re at 0,0 and we moved, we\\'re facing south and not East\\n        \\n    def step(self, num: int) -> None:\\n\\n        dictio = {\\n            \"South\": (-1, 0),\\n            \"East\": (0, 1),\\n            \"North\": (1, 0),\\n            \"West\": (0, -1)\\n        }\\n\\n        horizontal = len(self.board[0]) # Width of the board\\n        vertical = len(self.board) # Height of the board\\n\\n        steps = num % (horizontal * 2 + vertical * 2 - 4) # 1 complete lap is 2 times the width + 2 times the height - 4 (-4 because we don\\'t wanna count every corners twice for one lap)\\n        self.moved = True\\n        while steps > 0: # We\\'ll now do the steps that will actually move the robot from its position\\n            if 0 <= self.position[0] + dictio.get(self.direction)[0] < vertical and 0 <= self.position[1] + dictio.get(self.direction)[1] < horizontal:\\n                self.position[0] += dictio.get(self.direction)[0]\\n                self.position[1] += dictio.get(self.direction)[1]\\n                steps -= 1\\n\\n                if steps == 0:\\n                    break\\n            else:\\n                # Change direction of the robot since we can\\'t move anymore in that direction (out of bounds)\\n                if self.direction != \"West\": # If it\\'s not west, we just wanna get the next one\\n                    new_direction = list(dictio.keys())[list(dictio.keys()).index(self.direction) + 1]  # Get the following direction from the dict\\n                else: # If it\\'s West, just change our direction to South\\n                    new_direction = \"South\"\\n                self.direction = new_direction\\n\\n\\n\\n\\n    def getPos(self):\\n        return self.position[::-1]\\n\\n    def getDir(self):\\n        if self.moved and self.position[0] == 0 and self.position[1] == 0:\\n            self.direction = \"South\"\\n            return self.direction\\n        else:\\n            return self.direction\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Robot:\\n\\n    def __init__(self, width: int, height: int):\\n        self.direction = \"East\"  # Faces East at the start\\n        self.position = [0, 0]  # Is at position (0,0) on the board at the start\\n        self.moved = False # Had to add this so if we\\'re at 0,0 and we moved, we\\'re facing south and not East\\n        \\n    def step(self, num: int) -> None:\\n\\n        dictio = {\\n            \"South\": (-1, 0),\\n            \"East\": (0, 1),\\n            \"North\": (1, 0),\\n            \"West\": (0, -1)\\n        }\\n\\n        horizontal = len(self.board[0]) # Width of the board\\n        vertical = len(self.board) # Height of the board\\n\\n        steps = num % (horizontal * 2 + vertical * 2 - 4) # 1 complete lap is 2 times the width + 2 times the height - 4 (-4 because we don\\'t wanna count every corners twice for one lap)\\n        self.moved = True\\n        while steps > 0: # We\\'ll now do the steps that will actually move the robot from its position\\n            if 0 <= self.position[0] + dictio.get(self.direction)[0] < vertical and 0 <= self.position[1] + dictio.get(self.direction)[1] < horizontal:\\n                self.position[0] += dictio.get(self.direction)[0]\\n                self.position[1] += dictio.get(self.direction)[1]\\n                steps -= 1\\n\\n                if steps == 0:\\n                    break\\n            else:\\n                # Change direction of the robot since we can\\'t move anymore in that direction (out of bounds)\\n                if self.direction != \"West\": # If it\\'s not west, we just wanna get the next one\\n                    new_direction = list(dictio.keys())[list(dictio.keys()).index(self.direction) + 1]  # Get the following direction from the dict\\n                else: # If it\\'s West, just change our direction to South\\n                    new_direction = \"South\"\\n                self.direction = new_direction\\n\\n\\n\\n\\n    def getPos(self):\\n        return self.position[::-1]\\n\\n    def getDir(self):\\n        if self.moved and self.position[0] == 0 and self.position[1] == 0:\\n            self.direction = \"South\"\\n            return self.direction\\n        else:\\n            return self.direction\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1653926,
                "title": "java-soln-100",
                "content": "```\\nclass Robot {\\n\\n    int height;\\n    int width;\\n    int totalSquares;\\n    int currPos;\\n    boolean started;\\n    \\n    public Robot(int width, int height) {\\n        this.width = width;\\n        this.height = height;\\n        \\n        started = false;\\n        currPos = 0;\\n        \\n        totalSquares = 2 * width + 2 * height - 4;  \\n    }\\n    \\n    public void step(int num) {\\n        \\n        currPos += num; \\n \\n        if (currPos > 0){\\n            started = true; \\n        }\\n        \\n        currPos = currPos % totalSquares;\\n    }\\n    \\n    public int[] getPos() {\\n        \\n        if (currPos < width){\\n            return new int[]{currPos, 0};\\n        }\\n        \\n        if (currPos >= width - 1 && currPos <= width + height - 2){\\n            return new int[]{width - 1, currPos - width + 1};\\n        }\\n        \\n        if (currPos >= width + height - 2 && currPos < 2 * width + height - 2){\\n            return new int[]{width - (currPos - (width + height - 2)) - 1, height - 1};\\n        }\\n        \\n        if (currPos >= 2 * width + height - 4){\\n            return new int[]{0, (totalSquares - currPos)};\\n        }\\n        \\n        return null;\\n        \\n    }\\n    \\n    public String getDir() {\\n        \\n        if (currPos == 0 && started){\\n            return \"South\";\\n        }\\n        else if (currPos < width){\\n            return \"East\";\\n        }\\n        else if (currPos >= width - 1 && currPos <= width + height - 2){\\n            return \"North\";\\n        }\\n        else if (currPos >= width + height - 2 && currPos < 2 * width + height - 2){\\n            return \"West\";\\n        }\\n        else {\\n            return \"South\";\\n        }        \\n    }\\n}\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot obj = new Robot(width, height);\\n * obj.step(num);\\n * int[] param_2 = obj.getPos();\\n * String param_3 = obj.getDir();\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass Robot {\\n\\n    int height;\\n    int width;\\n    int totalSquares;\\n    int currPos;\\n    boolean started;\\n    \\n    public Robot(int width, int height) {\\n        this.width = width;\\n        this.height = height;\\n        \\n        started = false;\\n        currPos = 0;\\n        \\n        totalSquares = 2 * width + 2 * height - 4;  \\n    }\\n    \\n    public void step(int num) {\\n        \\n        currPos += num; \\n \\n        if (currPos > 0){\\n            started = true; \\n        }\\n        \\n        currPos = currPos % totalSquares;\\n    }\\n    \\n    public int[] getPos() {\\n        \\n        if (currPos < width){\\n            return new int[]{currPos, 0};\\n        }\\n        \\n        if (currPos >= width - 1 && currPos <= width + height - 2){\\n            return new int[]{width - 1, currPos - width + 1};\\n        }\\n        \\n        if (currPos >= width + height - 2 && currPos < 2 * width + height - 2){\\n            return new int[]{width - (currPos - (width + height - 2)) - 1, height - 1};\\n        }\\n        \\n        if (currPos >= 2 * width + height - 4){\\n            return new int[]{0, (totalSquares - currPos)};\\n        }\\n        \\n        return null;\\n        \\n    }\\n    \\n    public String getDir() {\\n        \\n        if (currPos == 0 && started){\\n            return \"South\";\\n        }\\n        else if (currPos < width){\\n            return \"East\";\\n        }\\n        else if (currPos >= width - 1 && currPos <= width + height - 2){\\n            return \"North\";\\n        }\\n        else if (currPos >= width + height - 2 && currPos < 2 * width + height - 2){\\n            return \"West\";\\n        }\\n        else {\\n            return \"South\";\\n        }        \\n    }\\n}\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot obj = new Robot(width, height);\\n * obj.step(num);\\n * int[] param_2 = obj.getPos();\\n * String param_3 = obj.getDir();\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1652104,
                "title": "c-switch-easy",
                "content": "```\\nclass Robot {\\n    int w,h;\\n    int currx,curry;\\n    string direc;\\npublic:\\n    Robot(int width, int height) {\\n        w=width;\\n        h=height;\\n        currx=0,curry=0;\\n        direc=\"East\";\\n    }\\n    \\n    void step(int num) {\\n        num=num%(2*(h+w)-4);\\n        if(!num) num=(2*(h+w)-4);\\n        int dir=(direc==\"East\"?1:(direc==\"North\"?3:(direc==\"West\"?2:(direc==\"South\"?4:0))));\\n        while(num){\\n            switch(dir){\\n                case 1:\\n                    for(int i=currx+1;i<w && num>0;i++,num--) currx=i;\\n                    if(num>0) direc=\"North\",dir=3;\\n                    break;\\n                case 2:\\n                    for(int i=currx-1;i>=0 && num>0;i--,num--) currx=i;\\n                    if(num>0) direc=\"South\",dir=4;\\n                    break;\\n                case 3:\\n                    for(int i=curry+1;i<h && num>0 ;i++,num--) curry=i;\\n                    if(num>0) direc=\"West\",dir=2;\\n                    break;\\n                case 4:\\n                    for(int i=curry-1;i>=0 && num>0 ;i--,num--) curry=i;\\n                    if(num>0) direc=\"East\",dir=1;\\n                    break;\\n            }\\n        }\\n        \\n    }\\n    \\n    vector<int> getPos() {\\n        return {currx,curry};\\n    }\\n    \\n    string getDir() {\\n        return direc;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Robot {\\n    int w,h;\\n    int currx,curry;\\n    string direc;\\npublic:\\n    Robot(int width, int height) {\\n        w=width;\\n        h=height;\\n        currx=0,curry=0;\\n        direc=\"East\";\\n    }\\n    \\n    void step(int num) {\\n        num=num%(2*(h+w)-4);\\n        if(!num) num=(2*(h+w)-4);\\n        int dir=(direc==\"East\"?1:(direc==\"North\"?3:(direc==\"West\"?2:(direc==\"South\"?4:0))));\\n        while(num){\\n            switch(dir){\\n                case 1:\\n                    for(int i=currx+1;i<w && num>0;i++,num--) currx=i;\\n                    if(num>0) direc=\"North\",dir=3;\\n                    break;\\n                case 2:\\n                    for(int i=currx-1;i>=0 && num>0;i--,num--) currx=i;\\n                    if(num>0) direc=\"South\",dir=4;\\n                    break;\\n                case 3:\\n                    for(int i=curry+1;i<h && num>0 ;i++,num--) curry=i;\\n                    if(num>0) direc=\"West\",dir=2;\\n                    break;\\n                case 4:\\n                    for(int i=curry-1;i>=0 && num>0 ;i--,num--) curry=i;\\n                    if(num>0) direc=\"East\",dir=1;\\n                    break;\\n            }\\n        }\\n        \\n    }\\n    \\n    vector<int> getPos() {\\n        return {currx,curry};\\n    }\\n    \\n    string getDir() {\\n        return direc;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1651389,
                "title": "c-easy-solution",
                "content": "```\\npublic class Robot {\\n    private readonly int MaxX;\\n    private readonly int MaxY;\\n    private readonly int FullRoundLength;\\n    \\n    private int currentLocation = 0;\\n    private int currentX = 0;\\n    private int currentY = 0;\\n    \\n    private enum Direction {\\n        East = 0,\\n        North = 1,\\n        West = 2,\\n        South = 3,\\n    }\\n    \\n    private Direction direction = Direction.East;\\n    \\n    public Robot(int width, int height) {\\n        MaxX = width - 1;\\n        MaxY = height - 1;\\n        FullRoundLength = (MaxX + MaxY) * 2;\\n    }\\n    \\n    public void Step(int num) {\\n        if (num == 0) return;\\n        \\n        currentLocation += num;\\n        currentLocation %= FullRoundLength;\\n        \\n        currentX = -1;\\n    }\\n    \\n    public int[] GetPos() {\\n        CalculatePositionAndDirectionIfNeeded();\\n        return new[]{ currentX, currentY };\\n    }\\n    \\n    public string GetDir() {\\n        CalculatePositionAndDirectionIfNeeded();\\n        return direction.ToString();\\n    }\\n    \\n    private void CalculatePositionAndDirectionIfNeeded() {\\n        if (currentX != -1) return;\\n        \\n        if (currentLocation == 0) {\\n            direction = Direction.South;\\n            currentX = currentY = 0;\\n        } else if (currentLocation <= MaxX) {\\n            direction = Direction.East;\\n            currentX = currentLocation;\\n            currentY = 0;\\n        } else if (currentLocation <= MaxX + MaxY) {\\n            direction = Direction.North;\\n            currentX = MaxX;\\n            currentY = currentLocation - MaxX;\\n        } else if (currentLocation <= MaxX + MaxY + MaxX) {\\n            direction = Direction.West;\\n            currentX = MaxX - (currentLocation - MaxX - MaxY);\\n            currentY = MaxY;\\n        } else {\\n            direction = Direction.South;\\n            currentX = 0;\\n            currentY = MaxY - (currentLocation - MaxX - MaxY - MaxX);\\n        }        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Robot {\\n    private readonly int MaxX;\\n    private readonly int MaxY;\\n    private readonly int FullRoundLength;\\n    \\n    private int currentLocation = 0;\\n    private int currentX = 0;\\n    private int currentY = 0;\\n    \\n    private enum Direction {\\n        East = 0,\\n        North = 1,\\n        West = 2,\\n        South = 3,\\n    }\\n    \\n    private Direction direction = Direction.East;\\n    \\n    public Robot(int width, int height) {\\n        MaxX = width - 1;\\n        MaxY = height - 1;\\n        FullRoundLength = (MaxX + MaxY) * 2;\\n    }\\n    \\n    public void Step(int num) {\\n        if (num == 0) return;\\n        \\n        currentLocation += num;\\n        currentLocation %= FullRoundLength;\\n        \\n        currentX = -1;\\n    }\\n    \\n    public int[] GetPos() {\\n        CalculatePositionAndDirectionIfNeeded();\\n        return new[]{ currentX, currentY };\\n    }\\n    \\n    public string GetDir() {\\n        CalculatePositionAndDirectionIfNeeded();\\n        return direction.ToString();\\n    }\\n    \\n    private void CalculatePositionAndDirectionIfNeeded() {\\n        if (currentX != -1) return;\\n        \\n        if (currentLocation == 0) {\\n            direction = Direction.South;\\n            currentX = currentY = 0;\\n        } else if (currentLocation <= MaxX) {\\n            direction = Direction.East;\\n            currentX = currentLocation;\\n            currentY = 0;\\n        } else if (currentLocation <= MaxX + MaxY) {\\n            direction = Direction.North;\\n            currentX = MaxX;\\n            currentY = currentLocation - MaxX;\\n        } else if (currentLocation <= MaxX + MaxY + MaxX) {\\n            direction = Direction.West;\\n            currentX = MaxX - (currentLocation - MaxX - MaxY);\\n            currentY = MaxY;\\n        } else {\\n            direction = Direction.South;\\n            currentX = 0;\\n            currentY = MaxY - (currentLocation - MaxX - MaxY - MaxX);\\n        }        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1645829,
                "title": "c-simulate-robot-steps-o-q-m-n-tle",
                "content": "This solution gives TLE, nevertheless, it is important to learn how to simulate such robot/game based problems. You can find my optimal solution 90% beats here: [link](https://leetcode.com/problems/walking-robot-simulation-ii/discuss/1645809/C%2B%2B-oror-Just-Walk-On-Boundary-oror-O(M%2BN)-Preprocess-oror-Most-Concise-oror-Verbose-oror)\\n```\\nclass Robot {\\npublic:\\n    int R; int C;\\n    int i; int j;\\n    int dir;\\n\\n    vector<int> x{+1,0,-1,0};\\n    vector<int> y{0,+1,0,-1};\\n\\n    Robot(int width, int height) {\\n        this-> R = width;\\n        this-> C = height;\\n        this->i = 0;\\n        this->j = 0;\\n        this-> dir = 0;\\n\\n    }\\n    \\n    void step(int num) {\\n        while(num){\\n            int newI = i + x[dir];\\n            int newJ = j + y[dir];\\n            if(inBounds(newI, newJ)){\\n                i = newI;\\n                j = newJ;\\n                num--;\\n            }\\n            else{\\n                while(!inBounds(newI, newJ)){\\n                    dir = (dir + 1)%4;\\n                    newI = i + x[dir];\\n                    newJ = j + y[dir];\\n                }\\n\\n                i = newI;\\n                j = newJ;\\n                num--;\\n            }\\n        }\\n        return;\\n    }\\n    \\n    vector<int> getPos() {\\n        return {i,j};\\n    }\\n    \\n    string getDir() {\\n        switch(dir){\\n            case 0:\\n                return \"East\";\\n                break;\\n            \\n            case 1:\\n                return \"North\";\\n                break;\\n            \\n            case 2:\\n                return \"West\";\\n                break;\\n            \\n            case 3:\\n                return \"South\";\\n                break;\\n\\n            default:\\n                exit(100);\\n        }\\n    }\\n\\n    bool inBounds(int i, int j){\\n        return (i >=0 && i<R && j>=0 && j<C);\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Robot {\\npublic:\\n    int R; int C;\\n    int i; int j;\\n    int dir;\\n\\n    vector<int> x{+1,0,-1,0};\\n    vector<int> y{0,+1,0,-1};\\n\\n    Robot(int width, int height) {\\n        this-> R = width;\\n        this-> C = height;\\n        this->i = 0;\\n        this->j = 0;\\n        this-> dir = 0;\\n\\n    }\\n    \\n    void step(int num) {\\n        while(num){\\n            int newI = i + x[dir];\\n            int newJ = j + y[dir];\\n            if(inBounds(newI, newJ)){\\n                i = newI;\\n                j = newJ;\\n                num--;\\n            }\\n            else{\\n                while(!inBounds(newI, newJ)){\\n                    dir = (dir + 1)%4;\\n                    newI = i + x[dir];\\n                    newJ = j + y[dir];\\n                }\\n\\n                i = newI;\\n                j = newJ;\\n                num--;\\n            }\\n        }\\n        return;\\n    }\\n    \\n    vector<int> getPos() {\\n        return {i,j};\\n    }\\n    \\n    string getDir() {\\n        switch(dir){\\n            case 0:\\n                return \"East\";\\n                break;\\n            \\n            case 1:\\n                return \"North\";\\n                break;\\n            \\n            case 2:\\n                return \"West\";\\n                break;\\n            \\n            case 3:\\n                return \"South\";\\n                break;\\n\\n            default:\\n                exit(100);\\n        }\\n    }\\n\\n    bool inBounds(int i, int j){\\n        return (i >=0 && i<R && j>=0 && j<C);\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1645809,
                "title": "c-just-walk-on-boundary-o-1-each-query-o-m-n-preprocess",
                "content": "Initially, I come up with O( Q*(M+N) ) solution which TLE. You can find that solution here: [link](https://leetcode.com/problems/walking-robot-simulation-ii/discuss/1645829/C%2B%2B-oror-Simulate-Robot-Steps-oror-O(-Q*(M%2BN)-)-oror-TLE)\\n\\nThen, I think more and come up with O( M+N ) solutution which beat 90%. You can find that solution below.\\n\\n```\\n    /* \\n    Main Idea: Robot only walks on the boundary\\n    Approach: Just store the boundary coordinates in a 1D array and increment\\n    step to (index + step)%n. \\n    Also, store the direction for each boundary corrdinate in another array \\n\\t\\n\\t\\n\\tTime and Space Analysis:\\n\\tTime: \\n\\t- Preprocess O(M+N) Linear Time\\n\\t- For each Query, O(1) Constant Time\\n\\t-\\n\\tSpace: \\n\\t- Preprocess O(M+N) \\n    */\\nclass Robot {\\npublic:\\n    int R; int C; // total rows and columns \\n    int idx; // the current index the robot is at\\n    int n; // the total number of elements in the boundary on which robot walks\\n    int flag; // flag = 0 when no step has been taken, else step = 1\\n\\n    vector<pair<int,int>> pos;// the position/coordiates of the boundary \\n    vector<string> dir; // the corresponding direction the robot is oriented at \\n\\n    Robot(int width, int height) {\\n        R = height;\\n        C = width;\\n        n = 2*C + 2*R - 4; // number of cells in the boundary \\n        idx = 0;\\n        flag = 0;\\n        \\n    \\n        pos.resize(n);\\n        dir.resize(n);\\n        \\n        for(int j=0;j<C;j++){ // walk east \\n            pos[idx] = {j,0};\\n            dir[idx] = \"East\";\\n            idx = (idx+1)%n;\\n        }\\n\\n        for(int i=1;i<R;i++){ // walk north \\n            pos[idx] = {C-1,i};\\n            dir[idx] = \"North\";\\n            idx = (idx+1)%n;\\n        }\\n\\n        for(int j=C-2; j>=0;j--){ // walk west \\n            pos[idx] = {j,R-1};\\n            dir[idx] = \"West\";\\n            idx = (idx+1)%n;\\n        }\\n\\n        for(int i=R-2;i>=0;i--){ // walk south \\n            pos[idx] = {0,i};\\n            dir[idx] = \"South\";\\n            idx = (idx+1)%n;\\n        }\\n        \\n        \\n        \\n        idx = 0; // initally robot starts at 0,0\\n    }\\n    \\n    void step(int num) {\\n        idx = (idx+num)%n;\\n        \\n        flag=1;\\n        return;\\n    }\\n    \\n    vector<int> getPos() {\\n        auto [i,j] = pos[idx];\\n        return {i,j};\\n    }\\n    \\n    string getDir() {\\n        if(flag == 0)\\n            return \"East\";\\n        else\\n            return dir[idx];\\n    }\\n\\n  \\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    /* \\n    Main Idea: Robot only walks on the boundary\\n    Approach: Just store the boundary coordinates in a 1D array and increment\\n    step to (index + step)%n. \\n    Also, store the direction for each boundary corrdinate in another array \\n\\t\\n\\t\\n\\tTime and Space Analysis:\\n\\tTime: \\n\\t- Preprocess O(M+N) Linear Time\\n\\t- For each Query, O(1) Constant Time\\n\\t-\\n\\tSpace: \\n\\t- Preprocess O(M+N) \\n    */\\nclass Robot {\\npublic:\\n    int R; int C; // total rows and columns \\n    int idx; // the current index the robot is at\\n    int n; // the total number of elements in the boundary on which robot walks\\n    int flag; // flag = 0 when no step has been taken, else step = 1\\n\\n    vector<pair<int,int>> pos;// the position/coordiates of the boundary \\n    vector<string> dir; // the corresponding direction the robot is oriented at \\n\\n    Robot(int width, int height) {\\n        R = height;\\n        C = width;\\n        n = 2*C + 2*R - 4; // number of cells in the boundary \\n        idx = 0;\\n        flag = 0;\\n        \\n    \\n        pos.resize(n);\\n        dir.resize(n);\\n        \\n        for(int j=0;j<C;j++){ // walk east \\n            pos[idx] = {j,0};\\n            dir[idx] = \"East\";\\n            idx = (idx+1)%n;\\n        }\\n\\n        for(int i=1;i<R;i++){ // walk north \\n            pos[idx] = {C-1,i};\\n            dir[idx] = \"North\";\\n            idx = (idx+1)%n;\\n        }\\n\\n        for(int j=C-2; j>=0;j--){ // walk west \\n            pos[idx] = {j,R-1};\\n            dir[idx] = \"West\";\\n            idx = (idx+1)%n;\\n        }\\n\\n        for(int i=R-2;i>=0;i--){ // walk south \\n            pos[idx] = {0,i};\\n            dir[idx] = \"South\";\\n            idx = (idx+1)%n;\\n        }\\n        \\n        \\n        \\n        idx = 0; // initally robot starts at 0,0\\n    }\\n    \\n    void step(int num) {\\n        idx = (idx+num)%n;\\n        \\n        flag=1;\\n        return;\\n    }\\n    \\n    vector<int> getPos() {\\n        auto [i,j] = pos[idx];\\n        return {i,j};\\n    }\\n    \\n    string getDir() {\\n        if(flag == 0)\\n            return \"East\";\\n        else\\n            return dir[idx];\\n    }\\n\\n  \\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1643204,
                "title": "c-easy-implementation",
                "content": "```\\nclass Robot {\\npublic:\\n    \\n    int x,y,a,b,d;\\n    map<int,string> dir;\\n    \\n    int val;\\n    Robot(int width, int height) {\\n        x=width;\\n        x--;\\n        \\n        y=height;\\n        y--;\\n        a=0;\\n        b=0;\\n        dir[0]=\"East\";\\n        dir[1]=\"North\";\\n        dir[2]=\"West\";\\n        dir[3]=\"South\";\\n        d=0;\\n        val=2*x+2*y;\\n        \\n    }\\n    \\n    void step(int num) {\\n        \\n        if(num%val==0)\\n        {\\n            if(a==0 && b==0)\\n            {\\n                d=3;\\n            }\\n            num=num%val;\\n        }\\n        else{\\n            num=num%val;\\n        }\\n        \\n        while(num>0)\\n        {\\n            if(d==0)\\n            {\\n                if(a+1<=x)\\n                {\\n                    a++;\\n                    num--;\\n                }\\n                else{\\n                    d++;\\n                   // num+=1;\\n                    if(b+1<=y)\\n                {\\n                    b++;\\n                    num--;\\n                }\\n                }\\n            }\\n            else if(d==1)\\n            {\\n                if(b+1<=y)\\n                {\\n                    b++;\\n                    num--;\\n                }\\n                else{\\n                    d++;\\n                   // num+=1;\\n                    if(a-1>=0)\\n                {\\n                    a--;\\n                    num--;\\n                }\\n                }\\n            }\\n            else if(d==2)\\n            {\\n                if(a-1>=0)\\n                {\\n                    a--;\\n                    num--;\\n                }\\n                else{\\n                    d++;\\n                    //num+=1;\\n                    if(b-1>=0)\\n                {\\n                    b--;\\n                    num--;\\n                    \\n                }\\n                }\\n            }\\n            else if(d==3)\\n            {\\n                if(b-1>=0)\\n                {\\n                    b--;\\n                    num--;\\n                    \\n                }\\n                else{\\n                    d=0;\\n                   // num+=1;\\n                    if(a+1<=x)\\n                {\\n                    a++;\\n                    num--;\\n                }\\n                }\\n            }\\n        }\\n        //cout<<a<<\" \"<<b<<endl;\\n        \\n    }\\n    \\n    vector<int> getPos() {\\n        \\n        \\n        return vector<int> {a,b};\\n        \\n    }\\n    \\n    string getDir() {\\n     \\n        return dir[d];\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "```\\nclass Robot {\\npublic:\\n    \\n    int x,y,a,b,d;\\n    map<int,string> dir;\\n    \\n    int val;\\n    Robot(int width, int height) {\\n        x=width;\\n        x--;\\n        \\n        y=height;\\n        y--;\\n        a=0;\\n        b=0;\\n        dir[0]=\"East\";\\n        dir[1]=\"North\";\\n        dir[2]=\"West\";\\n        dir[3]=\"South\";\\n        d=0;\\n        val=2*x+2*y;\\n        \\n    }\\n    \\n    void step(int num) {\\n        \\n        if(num%val==0)\\n        {\\n            if(a==0 && b==0)\\n            {\\n                d=3;\\n            }\\n            num=num%val;\\n        }\\n        else{\\n            num=num%val;\\n        }\\n        \\n        while(num>0)\\n        {\\n            if(d==0)\\n            {\\n                if(a+1<=x)\\n                {\\n                    a++;\\n                    num--;\\n                }\\n                else{\\n                    d++;\\n                   // num+=1;\\n                    if(b+1<=y)\\n                {\\n                    b++;\\n                    num--;\\n                }\\n                }\\n            }\\n            else if(d==1)\\n            {\\n                if(b+1<=y)\\n                {\\n                    b++;\\n                    num--;\\n                }\\n                else{\\n                    d++;\\n                   // num+=1;\\n                    if(a-1>=0)\\n                {\\n                    a--;\\n                    num--;\\n                }\\n                }\\n            }\\n            else if(d==2)\\n            {\\n                if(a-1>=0)\\n                {\\n                    a--;\\n                    num--;\\n                }\\n                else{\\n                    d++;\\n                    //num+=1;\\n                    if(b-1>=0)\\n                {\\n                    b--;\\n                    num--;\\n                    \\n                }\\n                }\\n            }\\n            else if(d==3)\\n            {\\n                if(b-1>=0)\\n                {\\n                    b--;\\n                    num--;\\n                    \\n                }\\n                else{\\n                    d=0;\\n                   // num+=1;\\n                    if(a+1<=x)\\n                {\\n                    a++;\\n                    num--;\\n                }\\n                }\\n            }\\n        }\\n        //cout<<a<<\" \"<<b<<endl;\\n        \\n    }\\n    \\n    vector<int> getPos() {\\n        \\n        \\n        return vector<int> {a,b};\\n        \\n    }\\n    \\n    string getDir() {\\n     \\n        return dir[d];\\n    }\\n};\\n",
                "codeTag": "C++"
            },
            {
                "id": 1642270,
                "title": "c-easy-bruteforce",
                "content": "```\\nclass Robot {\\npublic:\\n    string dir=\"East\";\\n    int x=0,y=0;\\n    int w,h,pm;\\n    Robot(int width, int height) {\\n        w=width;\\n        h=height;\\n        pm=2*(h-2) + 2*w; \\n    }\\n    \\n    void step(int num) { \\n        num%=pm;        \\n        if(!num && x == 0 && y == 0) dir = \"South\";\\n        while(num--){\\n            if(dir==\"East\"){\\n                if(x+1>=w){\\n                    dir=\"North\";\\n                    y++;\\n                }\\n                else x++;\\n            }\\n            else if(dir==\"West\"){\\n                if(x-1<0){\\n                   dir=\"South\";\\n                   y--;\\n                } \\n                else x--;\\n            }\\n            else if(dir==\"South\"){\\n                if(y-1<0){\\n                    dir=\"East\";\\n                    x++;\\n                }\\n                else y--;\\n            }\\n            else if(dir==\"North\"){\\n                if(y+1>=h){\\n                    dir=\"West\";\\n                    x--;\\n                }\\n                else y++;\\n            }            \\n        } \\n    }\\n    \\n    vector<int> getPos() {\\n        return {x,y};\\n    }\\n    \\n    string getDir() {\\n        return dir;\\n    }\\n};\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot* obj = new Robot(width, height);\\n * obj->step(num);\\n * vector<int> param_2 = obj->getPos();\\n * string param_3 = obj->getDir();\\n */\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Robot {\\npublic:\\n    string dir=\"East\";\\n    int x=0,y=0;\\n    int w,h,pm;\\n    Robot(int width, int height) {\\n        w=width;\\n        h=height;\\n        pm=2*(h-2) + 2*w; \\n    }\\n    \\n    void step(int num) { \\n        num%=pm;        \\n        if(!num && x == 0 && y == 0) dir = \"South\";\\n        while(num--){\\n            if(dir==\"East\"){\\n                if(x+1>=w){\\n                    dir=\"North\";\\n                    y++;\\n                }\\n                else x++;\\n            }\\n            else if(dir==\"West\"){\\n                if(x-1<0){\\n                   dir=\"South\";\\n                   y--;\\n                } \\n                else x--;\\n            }\\n            else if(dir==\"South\"){\\n                if(y-1<0){\\n                    dir=\"East\";\\n                    x++;\\n                }\\n                else y--;\\n            }\\n            else if(dir==\"North\"){\\n                if(y+1>=h){\\n                    dir=\"West\";\\n                    x--;\\n                }\\n                else y++;\\n            }            \\n        } \\n    }\\n    \\n    vector<int> getPos() {\\n        return {x,y};\\n    }\\n    \\n    string getDir() {\\n        return dir;\\n    }\\n};\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot* obj = new Robot(width, height);\\n * obj->step(num);\\n * vector<int> param_2 = obj->getPos();\\n * string param_3 = obj->getDir();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1641970,
                "title": "bruteforce-irritating-question",
                "content": "Just Bruteforce, nothing to explain - \\n\\nTLE - \\n\\n\\n```\\nclass Robot {\\npublic:\\n    int row, col, x, y, dir, v;\\n    string name[4] = {\"East\", \"North\", \"West\", \"South\"};\\n    Robot(int width, int height) {\\n        row = width;\\n        col = height;\\n        x = y = 0;\\n        dir = 0;\\n        v = (width*2) + (height-2)*2;\\n    }\\n    \\n    void step(int num) {\\n        num %= v;\\n        if(!num && x == 0 && y == 0) dir = 3;\\n        while(num){\\n            if(dir == 0){\\n                if(x+1 >= row){\\n                    dir++;\\n                    continue;\\n                }\\n                x++;\\n            }\\n            else if(dir == 1){\\n                if(y+1 >= col){\\n                    dir++;\\n                    continue;\\n                }\\n                y++;\\n            }\\n            else if(dir == 2){\\n                if(x-1 < 0){\\n                    dir++;\\n                    continue;\\n                }\\n                x--;\\n            }\\n            else{\\n                if(y-1 < 0){\\n                    dir = 0;\\n                    continue;\\n                }\\n                y--;\\n            }\\n            num--;\\n        }\\n    }\\n    \\n    vector<int> getPos() {\\n        return {x, y};\\n    }\\n    \\n    string getDir() {\\n        return name[dir];\\n    }\\n};\\n```\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nSlightly Optimising (Pass)-\\n\\n```\\nclass Robot {\\npublic:\\n    int row, col, x, y, dir, v;\\n    string name[4] = {\"East\", \"North\", \"West\", \"South\"};\\n    Robot(int width, int height) {\\n        row = width;\\n        col = height;\\n        x = y = 0;\\n        dir = 0;\\n        v = (width*2) + (height-2)*2;\\n    }\\n    \\n    void step(int num) {\\n        num %= v;\\n        if(!num && x == 0 && y == 0) dir = 3;\\n        while(num){\\n            if(dir == 0){\\n                if(x+1 >= row){\\n                    dir++;\\n                    continue;\\n                }\\n                x++;\\n            }\\n            else if(dir == 1){\\n                if(y+1 >= col){\\n                    dir++;\\n                    continue;\\n                }\\n                y++;\\n            }\\n            else if(dir == 2){\\n                if(x-1 < 0){\\n                    dir++;\\n                    continue;\\n                }\\n                x--;\\n            }\\n            else{\\n                if(y-1 < 0){\\n                    dir = 0;\\n                    continue;\\n                }\\n                y--;\\n            }\\n            num--;\\n        }\\n    }\\n    \\n    vector<int> getPos() {\\n        return {x, y};\\n    }\\n    \\n    string getDir() {\\n        return name[dir];\\n    }\\n};\\n```\\n\\nLeetcode, please stop posting rubbish question :(",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Robot {\\npublic:\\n    int row, col, x, y, dir, v;\\n    string name[4] = {\"East\", \"North\", \"West\", \"South\"};\\n    Robot(int width, int height) {\\n        row = width;\\n        col = height;\\n        x = y = 0;\\n        dir = 0;\\n        v = (width*2) + (height-2)*2;\\n    }\\n    \\n    void step(int num) {\\n        num %= v;\\n        if(!num && x == 0 && y == 0) dir = 3;\\n        while(num){\\n            if(dir == 0){\\n                if(x+1 >= row){\\n                    dir++;\\n                    continue;\\n                }\\n                x++;\\n            }\\n            else if(dir == 1){\\n                if(y+1 >= col){\\n                    dir++;\\n                    continue;\\n                }\\n                y++;\\n            }\\n            else if(dir == 2){\\n                if(x-1 < 0){\\n                    dir++;\\n                    continue;\\n                }\\n                x--;\\n            }\\n            else{\\n                if(y-1 < 0){\\n                    dir = 0;\\n                    continue;\\n                }\\n                y--;\\n            }\\n            num--;\\n        }\\n    }\\n    \\n    vector<int> getPos() {\\n        return {x, y};\\n    }\\n    \\n    string getDir() {\\n        return name[dir];\\n    }\\n};\\n```\n```\\nclass Robot {\\npublic:\\n    int row, col, x, y, dir, v;\\n    string name[4] = {\"East\", \"North\", \"West\", \"South\"};\\n    Robot(int width, int height) {\\n        row = width;\\n        col = height;\\n        x = y = 0;\\n        dir = 0;\\n        v = (width*2) + (height-2)*2;\\n    }\\n    \\n    void step(int num) {\\n        num %= v;\\n        if(!num && x == 0 && y == 0) dir = 3;\\n        while(num){\\n            if(dir == 0){\\n                if(x+1 >= row){\\n                    dir++;\\n                    continue;\\n                }\\n                x++;\\n            }\\n            else if(dir == 1){\\n                if(y+1 >= col){\\n                    dir++;\\n                    continue;\\n                }\\n                y++;\\n            }\\n            else if(dir == 2){\\n                if(x-1 < 0){\\n                    dir++;\\n                    continue;\\n                }\\n                x--;\\n            }\\n            else{\\n                if(y-1 < 0){\\n                    dir = 0;\\n                    continue;\\n                }\\n                y--;\\n            }\\n            num--;\\n        }\\n    }\\n    \\n    vector<int> getPos() {\\n        return {x, y};\\n    }\\n    \\n    string getDir() {\\n        return name[dir];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1632345,
                "title": "java-tle-114-147-test-cases-using-enum-s-working-on-full-solution",
                "content": "```\\n\\nenum Direction {\\n    North, South, East, West;\\n}\\n\\npublic class Robot {\\n\\n    int x, y;\\n    int curr_x = 0, curr_y = 0;\\n    Direction direction;\\n\\n    public Robot(int width, int height) {\\n        this.x = width;\\n        this.y = height;\\n        direction = Direction.East;\\n    }\\n\\n    public void step(int num) {\\n        // Taking one step at a time!\\n        while(num-- > 0){\\n            if (direction == Direction.East) {\\n                if (curr_x + 1 < x)\\n                    curr_x++;\\n                else {\\n                    curr_y++;\\n                    direction = Direction.North;\\n                }\\n            }\\n            else if (direction == Direction.North) {\\n                if (curr_y + 1 < y)\\n                    curr_y++;\\n                else {\\n                    curr_x--;\\n                    direction = Direction.West;\\n                }\\n            }\\n            else if (direction == Direction.West) {\\n                if (curr_x - 1 >= 0)\\n                    curr_x--;\\n                else {\\n                    curr_y--;\\n                    direction = Direction.South;\\n                }\\n            }\\n            else if (direction == Direction.South) {\\n                if (curr_y - 1 >= 0)\\n                    curr_y--;\\n                else {\\n                    curr_x++;\\n                    direction = Direction.East;\\n                }\\n            }   \\n        }\\n    }\\n\\n    public int[] getPos() {\\n        return new int[]{curr_x, curr_y};\\n    }\\n\\n    public String getDir() {\\n        return direction.toString();\\n    }\\n}\\n\\n```\\n\\nCould have used switch statement~\\uD83D\\uDE17!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nenum Direction {\\n    North, South, East, West;\\n}\\n\\npublic class Robot {\\n\\n    int x, y;\\n    int curr_x = 0, curr_y = 0;\\n    Direction direction;\\n\\n    public Robot(int width, int height) {\\n        this.x = width;\\n        this.y = height;\\n        direction = Direction.East;\\n    }\\n\\n    public void step(int num) {\\n        // Taking one step at a time!\\n        while(num-- > 0){\\n            if (direction == Direction.East) {\\n                if (curr_x + 1 < x)\\n                    curr_x++;\\n                else {\\n                    curr_y++;\\n                    direction = Direction.North;\\n                }\\n            }\\n            else if (direction == Direction.North) {\\n                if (curr_y + 1 < y)\\n                    curr_y++;\\n                else {\\n                    curr_x--;\\n                    direction = Direction.West;\\n                }\\n            }\\n            else if (direction == Direction.West) {\\n                if (curr_x - 1 >= 0)\\n                    curr_x--;\\n                else {\\n                    curr_y--;\\n                    direction = Direction.South;\\n                }\\n            }\\n            else if (direction == Direction.South) {\\n                if (curr_y - 1 >= 0)\\n                    curr_y--;\\n                else {\\n                    curr_x++;\\n                    direction = Direction.East;\\n                }\\n            }   \\n        }\\n    }\\n\\n    public int[] getPos() {\\n        return new int[]{curr_x, curr_y};\\n    }\\n\\n    public String getDir() {\\n        return direction.toString();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1628638,
                "title": "c",
                "content": "```\\nclass Robot {\\npublic:\\n    int m,n,dir,x,y;\\n    int dx[4]={1,0,-1,0};\\n    int dy[4]={0,1,0,-1};\\n    string get[4]={\"East\",\"North\",\"West\",\"South\"};\\n    Robot(int width, int height) \\n    {\\n        m=width,n=height;\\n        dir=0,x=0,y=0;\\n    }\\n    \\n    void step(int num) \\n    {\\n        \\n        while(num)\\n        {\\n            int x1=x+dx[dir],y1=y+dy[dir];\\n            if(x1<0 || y1<0 || x1>=m || y1>=n)\\n            {\\n                break;\\n            }\\n            else\\n            {\\n                x=x1,y=y1;\\n                num--;\\n            }\\n        }\\n        int round=2*(m+n-2);\\n        num=num%round;\\n        while(num)\\n        {\\n            int x1=x+dx[dir],y1=y+dy[dir];\\n            if(x1<0 || y1<0 || x1>=m || y1>=n)\\n            {\\n                dir=(dir+1)%4;\\n            }\\n            else\\n            {\\n                x=x1,y=y1;\\n                num--;\\n            }\\n        }\\n    }\\n    \\n    vector<int> getPos() \\n    {\\n        return {x,y};\\n    }\\n    \\n    string getDir() \\n    {\\n        return get[dir];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Robot {\\npublic:\\n    int m,n,dir,x,y;\\n    int dx[4]={1,0,-1,0};\\n    int dy[4]={0,1,0,-1};\\n    string get[4]={\"East\",\"North\",\"West\",\"South\"};\\n    Robot(int width, int height) \\n    {\\n        m=width,n=height;\\n        dir=0,x=0,y=0;\\n    }\\n    \\n    void step(int num) \\n    {\\n        \\n        while(num)\\n        {\\n            int x1=x+dx[dir],y1=y+dy[dir];\\n            if(x1<0 || y1<0 || x1>=m || y1>=n)\\n            {\\n                break;\\n            }\\n            else\\n            {\\n                x=x1,y=y1;\\n                num--;\\n            }\\n        }\\n        int round=2*(m+n-2);\\n        num=num%round;\\n        while(num)\\n        {\\n            int x1=x+dx[dir],y1=y+dy[dir];\\n            if(x1<0 || y1<0 || x1>=m || y1>=n)\\n            {\\n                dir=(dir+1)%4;\\n            }\\n            else\\n            {\\n                x=x1,y=y1;\\n                num--;\\n            }\\n        }\\n    }\\n    \\n    vector<int> getPos() \\n    {\\n        return {x,y};\\n    }\\n    \\n    string getDir() \\n    {\\n        return get[dir];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1622253,
                "title": "c-solution",
                "content": "```\\npublic class Robot {\\n    int[,] m;\\n    int x = 0, y = 0, w, h;\\n    string d = \"East\";\\n    public Robot(int w, int h) {\\n        m = new int[w, h];\\n        this.w = h;\\n        this.h = w;\\n    }\\n    \\n    public void Step(int num) {\\n        if (num == 0) return;\\n        \\n        num %= 2 * h + 2 * w - 4;\\n        if (num == 0) {\\n            if (x == 0 && y == 0) d = \"South\";\\n            else if (x == m.GetLength(0) - 1 && y == 0) d = \"East\";\\n            else if (x == m.GetLength(0) - 1 && y == m.GetLength(1) - 1) d = \"North\";\\n            else if (x == 0 && y == m.GetLength(1) - 1) d = \"West\";\\n        } else {\\n            if (x == 0 && y == 0) d = \"East\";\\n            else if (x == m.GetLength(0) - 1 && y == 0) d = \"North\";\\n            else if (x == m.GetLength(0) - 1 && y == m.GetLength(1) - 1) d = \"West\";\\n            else if (x == 0 && y == m.GetLength(1) - 1) d = \"South\";\\n            \\n            if (d == \"North\") {\\n                int ny = Math.Min(m.GetLength(1) - 1, y + num);\\n                num -= ny - y;\\n                y = ny;\\n            } else if (d == \"West\") {\\n                int nx = Math.Max(0, x - num);\\n                num -= x - nx;\\n                x = nx;\\n            } else if (d == \"South\") {\\n                int ny = Math.Max(0, y - num);\\n                num -= y - ny;\\n                y = ny;\\n            } else if (d == \"East\") {\\n                int nx = Math.Min(m.GetLength(0) - 1, x + num);\\n                num -= nx - x;\\n                x = nx;\\n            }\\n\\n            if (num > 0) {\\n                Step(num);\\n            }\\n        }\\n    }\\n    \\n    public int[] GetPos() {\\n        return new int[2] { x, y };\\n    }\\n    \\n    public string GetDir() {\\n        return d;\\n    }\\n}\\n```\\n\\nWithout Matrix\\n```\\npublic class Robot {\\n    int x = 0, y = 0, w, h;\\n    string d = \"East\";\\n    public Robot(int w, int h) {\\n        this.w = w;\\n        this.h = h;\\n    }\\n    \\n    public void Step(int num) {\\n        num %= 2 * h + 2 * w - 4;\\n        if (num == 0) num = 2 * h + 2 * w - 4;\\n        \\n        for (int i = 0; i < num; ++i) {\\n            switch (d) {\\n                case \"East\":\\n                    if (x == w - 1) {\\n                        d = \"North\";\\n                        y++;\\n                    } else {\\n                        x++;\\n                    }\\n                    break;\\n                case \"North\":\\n                    if (y == h - 1) {\\n                        d = \"West\";\\n                        x--;\\n                    } else {\\n                        y++;\\n                    }\\n                    break;\\n                case \"West\":\\n                    if (x == 0) {\\n                        d = \"South\";\\n                        y--;\\n                    } else {\\n                        x--;\\n                    }\\n                    break;\\n                case \"South\":\\n                    if (y == 0) {\\n                        d = \"East\";\\n                        x++;\\n                    } else {\\n                        y--;\\n                    }\\n                    break;\\n            }\\n        }\\n    }\\n    \\n    public int[] GetPos() {\\n        return new int[2] { x, y };\\n    }\\n    \\n    public string GetDir() {\\n        return d;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Robot {\\n    int[,] m;\\n    int x = 0, y = 0, w, h;\\n    string d = \"East\";\\n    public Robot(int w, int h) {\\n        m = new int[w, h];\\n        this.w = h;\\n        this.h = w;\\n    }\\n    \\n    public void Step(int num) {\\n        if (num == 0) return;\\n        \\n        num %= 2 * h + 2 * w - 4;\\n        if (num == 0) {\\n            if (x == 0 && y == 0) d = \"South\";\\n            else if (x == m.GetLength(0) - 1 && y == 0) d = \"East\";\\n            else if (x == m.GetLength(0) - 1 && y == m.GetLength(1) - 1) d = \"North\";\\n            else if (x == 0 && y == m.GetLength(1) - 1) d = \"West\";\\n        } else {\\n            if (x == 0 && y == 0) d = \"East\";\\n            else if (x == m.GetLength(0) - 1 && y == 0) d = \"North\";\\n            else if (x == m.GetLength(0) - 1 && y == m.GetLength(1) - 1) d = \"West\";\\n            else if (x == 0 && y == m.GetLength(1) - 1) d = \"South\";\\n            \\n            if (d == \"North\") {\\n                int ny = Math.Min(m.GetLength(1) - 1, y + num);\\n                num -= ny - y;\\n                y = ny;\\n            } else if (d == \"West\") {\\n                int nx = Math.Max(0, x - num);\\n                num -= x - nx;\\n                x = nx;\\n            } else if (d == \"South\") {\\n                int ny = Math.Max(0, y - num);\\n                num -= y - ny;\\n                y = ny;\\n            } else if (d == \"East\") {\\n                int nx = Math.Min(m.GetLength(0) - 1, x + num);\\n                num -= nx - x;\\n                x = nx;\\n            }\\n\\n            if (num > 0) {\\n                Step(num);\\n            }\\n        }\\n    }\\n    \\n    public int[] GetPos() {\\n        return new int[2] { x, y };\\n    }\\n    \\n    public string GetDir() {\\n        return d;\\n    }\\n}\\n```\n```\\npublic class Robot {\\n    int x = 0, y = 0, w, h;\\n    string d = \"East\";\\n    public Robot(int w, int h) {\\n        this.w = w;\\n        this.h = h;\\n    }\\n    \\n    public void Step(int num) {\\n        num %= 2 * h + 2 * w - 4;\\n        if (num == 0) num = 2 * h + 2 * w - 4;\\n        \\n        for (int i = 0; i < num; ++i) {\\n            switch (d) {\\n                case \"East\":\\n                    if (x == w - 1) {\\n                        d = \"North\";\\n                        y++;\\n                    } else {\\n                        x++;\\n                    }\\n                    break;\\n                case \"North\":\\n                    if (y == h - 1) {\\n                        d = \"West\";\\n                        x--;\\n                    } else {\\n                        y++;\\n                    }\\n                    break;\\n                case \"West\":\\n                    if (x == 0) {\\n                        d = \"South\";\\n                        y--;\\n                    } else {\\n                        x--;\\n                    }\\n                    break;\\n                case \"South\":\\n                    if (y == 0) {\\n                        d = \"East\";\\n                        x++;\\n                    } else {\\n                        y--;\\n                    }\\n                    break;\\n            }\\n        }\\n    }\\n    \\n    public int[] GetPos() {\\n        return new int[2] { x, y };\\n    }\\n    \\n    public string GetDir() {\\n        return d;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1613476,
                "title": "python-longest-solution-xd",
                "content": "```\\nclass Robot:\\n\\n    def __init__(self, width: int, height: int):\\n        self.width = width - 1\\n        self.height = height - 1\\n        self.rPos = [0,0]\\n        self.cards = [\\'East\\',\\'North\\',\\'West\\',\\'South\\']\\n        self.dir = 0\\n\\n    def step(self, num: int) -> None:\\n        width = self.width\\n        height = self.height\\n        num = num % (2 * (height+width+2) - 4)\\n        if not num and not sum(self.rPos): self.dir = 3\\n        while num > 0:\\n            if self.dir == 0:\\n                if self.rPos[0] + num > width:\\n                    num = self.rPos[0] + num - width\\n                    self.rPos[0] = width\\n                    self.dir = 1\\n                else:\\n                    self.rPos[0] = self.rPos[0] + num\\n                    num = 0\\n            elif self.dir == 1:\\n                if self.rPos[1] + num > height:\\n                    num = self.rPos[1] + num - height\\n                    self.rPos[1] = height\\n                    self.dir = 2\\n                else:\\n                    self.rPos[1] = self.rPos[1] + num\\n                    num = 0\\n            elif self.dir == 2:\\n                if self.rPos[0] - num < 0:\\n                    num -= self.rPos[0]\\n                    self.rPos[0] = 0\\n                    self.dir = 3\\n                else:\\n                    self.rPos[0] -= num\\n                    num = 0\\n            else:\\n                if self.rPos[1] - num < 0:\\n                    num -= self.rPos[1]\\n                    self.rPos[1] = 0\\n                    self.dir = 0\\n                else:\\n                    self.rPos[1] -= num\\n                    num = 0\\n            \\n\\n    def getPos(self) -> List[int]:\\n        return self.rPos\\n        \\n\\n    def getDir(self) -> str:\\n        return self.cards[self.dir]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Robot:\\n\\n    def __init__(self, width: int, height: int):\\n        self.width = width - 1\\n        self.height = height - 1\\n        self.rPos = [0,0]\\n        self.cards = [\\'East\\',\\'North\\',\\'West\\',\\'South\\']\\n        self.dir = 0\\n\\n    def step(self, num: int) -> None:\\n        width = self.width\\n        height = self.height\\n        num = num % (2 * (height+width+2) - 4)\\n        if not num and not sum(self.rPos): self.dir = 3\\n        while num > 0:\\n            if self.dir == 0:\\n                if self.rPos[0] + num > width:\\n                    num = self.rPos[0] + num - width\\n                    self.rPos[0] = width\\n                    self.dir = 1\\n                else:\\n                    self.rPos[0] = self.rPos[0] + num\\n                    num = 0\\n            elif self.dir == 1:\\n                if self.rPos[1] + num > height:\\n                    num = self.rPos[1] + num - height\\n                    self.rPos[1] = height\\n                    self.dir = 2\\n                else:\\n                    self.rPos[1] = self.rPos[1] + num\\n                    num = 0\\n            elif self.dir == 2:\\n                if self.rPos[0] - num < 0:\\n                    num -= self.rPos[0]\\n                    self.rPos[0] = 0\\n                    self.dir = 3\\n                else:\\n                    self.rPos[0] -= num\\n                    num = 0\\n            else:\\n                if self.rPos[1] - num < 0:\\n                    num -= self.rPos[1]\\n                    self.rPos[1] = 0\\n                    self.dir = 0\\n                else:\\n                    self.rPos[1] -= num\\n                    num = 0\\n            \\n\\n    def getPos(self) -> List[int]:\\n        return self.rPos\\n        \\n\\n    def getDir(self) -> str:\\n        return self.cards[self.dir]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603954,
                "title": "special-handling-for-initial-position",
                "content": "```\\n/**\\n * @param {number} width\\n * @param {number} height\\n */\\nvar Robot = function(width, height) {\\n    const c = this.c = 2 * (width + height) - 4\\n    const positions = this.positions = new Array(c)\\n    \\n    let x = 0, y = 0\\n    let stepX = 1, stepY = 0\\n    for (let i = 0; i < c; i++) {\\n        positions[i] = { x, y, stepX, stepY }\\n        \\n        if (stepX === 1) {\\n            if (x !== width - 1)\\n                x++\\n            else {\\n                y++\\n                stepX = 0\\n                stepY = 1\\n            }\\n        } else if (stepX === -1) {\\n            if (x !== 0)\\n                x--\\n            else {\\n                y--\\n                stepX = 0\\n                stepY = -1\\n            }\\n        } else if (stepY === 1) {\\n            if (y !== height - 1)\\n                y++\\n            else {\\n                x--\\n                stepX = -1\\n                stepY = 0\\n            }\\n        } else if (stepY === -1) {\\n            if (y !== 0)\\n                y--\\n            else {\\n                x++\\n                stepX = 1\\n                stepY = 0\\n            }\\n        }\\n    }\\n    this.index = 0\\n    \\n    const firstPosition = positions[0]\\n    firstPosition.stepX = 0\\n    firstPosition.stepY = -1\\n};\\n\\n/** \\n * @param {number} num\\n * @return {void}\\n */\\nRobot.prototype.step = function(num) {\\n    this.index += num\\n};\\n\\n/**\\n * @return {number[]}\\n */\\nRobot.prototype.getPos = function() {\\n    const { positions, index, c } = this\\n    const position = positions[index % c]\\n    const { x, y } = position\\n    return [x, y]\\n};\\n\\n/**\\n * @return {string}\\n */\\nRobot.prototype.getDir = function() {\\n    const { positions, index, c } = this\\n    if (index === 0)    return \\'East\\'\\n    \\n    \\n    const position = positions[index % c]\\n    const { stepX, stepY } = position\\n    \\n    if (stepX === 1)\\n        return \\'East\\'\\n    else if (stepX === -1)\\n        return \\'West\\'\\n    else if (stepY === 1)\\n        return \\'North\\'\\n    else if (stepY === -1)\\n        return \\'South\\'\\n};\\n\\n/** \\n * Your Robot object will be instantiated and called as such:\\n * var obj = new Robot(width, height)\\n * obj.step(num)\\n * var param_2 = obj.getPos()\\n * var param_3 = obj.getDir()\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} width\\n * @param {number} height\\n */\\nvar Robot = function(width, height) {\\n    const c = this.c = 2 * (width + height) - 4\\n    const positions = this.positions = new Array(c)\\n    \\n    let x = 0, y = 0\\n    let stepX = 1, stepY = 0\\n    for (let i = 0; i < c; i++) {\\n        positions[i] = { x, y, stepX, stepY }\\n        \\n        if (stepX === 1) {\\n            if (x !== width - 1)\\n                x++\\n            else {\\n                y++\\n                stepX = 0\\n                stepY = 1\\n            }\\n        } else if (stepX === -1) {\\n            if (x !== 0)\\n                x--\\n            else {\\n                y--\\n                stepX = 0\\n                stepY = -1\\n            }\\n        } else if (stepY === 1) {\\n            if (y !== height - 1)\\n                y++\\n            else {\\n                x--\\n                stepX = -1\\n                stepY = 0\\n            }\\n        } else if (stepY === -1) {\\n            if (y !== 0)\\n                y--\\n            else {\\n                x++\\n                stepX = 1\\n                stepY = 0\\n            }\\n        }\\n    }\\n    this.index = 0\\n    \\n    const firstPosition = positions[0]\\n    firstPosition.stepX = 0\\n    firstPosition.stepY = -1\\n};\\n\\n/** \\n * @param {number} num\\n * @return {void}\\n */\\nRobot.prototype.step = function(num) {\\n    this.index += num\\n};\\n\\n/**\\n * @return {number[]}\\n */\\nRobot.prototype.getPos = function() {\\n    const { positions, index, c } = this\\n    const position = positions[index % c]\\n    const { x, y } = position\\n    return [x, y]\\n};\\n\\n/**\\n * @return {string}\\n */\\nRobot.prototype.getDir = function() {\\n    const { positions, index, c } = this\\n    if (index === 0)    return \\'East\\'\\n    \\n    \\n    const position = positions[index % c]\\n    const { stepX, stepY } = position\\n    \\n    if (stepX === 1)\\n        return \\'East\\'\\n    else if (stepX === -1)\\n        return \\'West\\'\\n    else if (stepY === 1)\\n        return \\'North\\'\\n    else if (stepY === -1)\\n        return \\'South\\'\\n};\\n\\n/** \\n * Your Robot object will be instantiated and called as such:\\n * var obj = new Robot(width, height)\\n * obj.step(num)\\n * var param_2 = obj.getPos()\\n * var param_3 = obj.getDir()\\n */\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1596992,
                "title": "very-very-precise-solution",
                "content": "```\\nclass Robot \\n{\\n    int m;\\n    int n;\\n    int i;\\n    int j;\\n    int k;\\n    string direction[4] = {\"East\",\"North\",\"West\",\"South\"};\\npublic:\\n    Robot(int width, int height) \\n    {\\n      k = 0;\\n        m = width;\\n        n = height;\\n        i = n-1;\\n        j = 0;\\n    }\\n    \\n    void traverse(int num)\\n    {\\n        // cout << \"num : \" << num << endl;\\n        // cout << \"i : \" << i << endl;\\n        // cout << \"j : \" << j << endl;\\n        // cout << \"k : \" << k << endl;\\n        if(k == 0)\\n        {\\n            //cout << \"here\";\\n            //I have to move in right direction\\n            //The maximum that I can move in right direction is \\n            if(j + num < m)\\n            {\\n                j = j + num;\\n                //cout << \"j : \" << j << endl;\\n                return;\\n            }\\n            else\\n            {\\n                num = num - (m-1 - j);\\n                j = m-1;\\n                k = 1;\\n                traverse(num);\\n            }\\n        }\\n        else if(k == 1)\\n        {\\n            if(i - num >= 0)\\n            {\\n                i = i - num;\\n                return;\\n            }\\n            else\\n            {\\n                num = num - i;\\n                i = 0;\\n                k = 2;\\n                traverse(num);\\n            }\\n        }\\n        else if(k == 2)\\n        {\\n            if(j - num >= 0)\\n            {\\n                j = j - num;\\n                return;\\n            }\\n            else\\n            {\\n                num = num - (j);\\n                j = 0;\\n                k = 3;\\n                traverse(num);\\n            }   \\n        }\\n        else if(k == 3)\\n        {\\n            if(i + num < n)\\n            {\\n                i = i + num;\\n                return;\\n            }\\n            else\\n            {\\n                num = num - (n-1 - i);\\n                i = n - 1;\\n                k = 0;\\n                traverse(num);\\n            }\\n        }\\n        return;\\n    }\\n    \\n    void step(int num) \\n    {\\n        num = num % (2*((m-1)+(n-1)));\\n        if(num != 0)\\n        {\\n            traverse(num); \\n        }\\n        else\\n        {\\n            if(i == n-1 && j == 0 && k == 0)\\n            {\\n                k = 3;\\n            }\\n        }\\n    }\\n    \\n    vector<int> getPos() \\n    {\\n        return {j,n-1-i};\\n        \\n    }\\n    \\n    string getDir() {\\n        return direction[k];\\n    }\\n};\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot* obj = new Robot(width, height);\\n * obj->step(num);\\n * vector<int> param_2 = obj->getPos();\\n * string param_3 = obj->getDir();\\n */\\n```\\nPlease Upvote",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Robot \\n{\\n    int m;\\n    int n;\\n    int i;\\n    int j;\\n    int k;\\n    string direction[4] = {\"East\",\"North\",\"West\",\"South\"};\\npublic:\\n    Robot(int width, int height) \\n    {\\n      k = 0;\\n        m = width;\\n        n = height;\\n        i = n-1;\\n        j = 0;\\n    }\\n    \\n    void traverse(int num)\\n    {\\n        // cout << \"num : \" << num << endl;\\n        // cout << \"i : \" << i << endl;\\n        // cout << \"j : \" << j << endl;\\n        // cout << \"k : \" << k << endl;\\n        if(k == 0)\\n        {\\n            //cout << \"here\";\\n            //I have to move in right direction\\n            //The maximum that I can move in right direction is \\n            if(j + num < m)\\n            {\\n                j = j + num;\\n                //cout << \"j : \" << j << endl;\\n                return;\\n            }\\n            else\\n            {\\n                num = num - (m-1 - j);\\n                j = m-1;\\n                k = 1;\\n                traverse(num);\\n            }\\n        }\\n        else if(k == 1)\\n        {\\n            if(i - num >= 0)\\n            {\\n                i = i - num;\\n                return;\\n            }\\n            else\\n            {\\n                num = num - i;\\n                i = 0;\\n                k = 2;\\n                traverse(num);\\n            }\\n        }\\n        else if(k == 2)\\n        {\\n            if(j - num >= 0)\\n            {\\n                j = j - num;\\n                return;\\n            }\\n            else\\n            {\\n                num = num - (j);\\n                j = 0;\\n                k = 3;\\n                traverse(num);\\n            }   \\n        }\\n        else if(k == 3)\\n        {\\n            if(i + num < n)\\n            {\\n                i = i + num;\\n                return;\\n            }\\n            else\\n            {\\n                num = num - (n-1 - i);\\n                i = n - 1;\\n                k = 0;\\n                traverse(num);\\n            }\\n        }\\n        return;\\n    }\\n    \\n    void step(int num) \\n    {\\n        num = num % (2*((m-1)+(n-1)));\\n        if(num != 0)\\n        {\\n            traverse(num); \\n        }\\n        else\\n        {\\n            if(i == n-1 && j == 0 && k == 0)\\n            {\\n                k = 3;\\n            }\\n        }\\n    }\\n    \\n    vector<int> getPos() \\n    {\\n        return {j,n-1-i};\\n        \\n    }\\n    \\n    string getDir() {\\n        return direction[k];\\n    }\\n};\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot* obj = new Robot(width, height);\\n * obj->step(num);\\n * vector<int> param_2 = obj->getPos();\\n * string param_3 = obj->getDir();\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1591836,
                "title": "java-thought-coding",
                "content": "```\\nclass Robot {\\n    int width,height,x,y;\\n    String[] dir = new String[]{\"East\",\"North\",\"West\",\"South\"};\\n    int[][] move = new int[][]{{1,0},{0,1},{-1,0},{0,-1}};\\n    int currDir = 0;\\n    int permeter = 0;\\n    public Robot(int width, int height) {\\n        this.width=width;\\n        this.height=height;\\n        x=0;\\n        y=0;\\n        permeter = 2*width + (2*(height-2));\\n    }\\n    \\n    public void step(int num) {\\n        num%=permeter;\\n        while(num>0){\\n            if(x + num*move[currDir][0]<0 || y + num*move[currDir][1]<0 || x + num*move[currDir][0]>=width || y + num*move[currDir][1]>=height){\\n                int cx = move[currDir][0],cy=move[currDir][1];\\n                if(cx==1){\\n                    num = num - (width-x-1);\\n                    x=width-1;\\n                }\\n                else if(cx==-1){\\n                    num = num - (x);\\n                    x=0;\\n                }\\n                else if(cy == 1){\\n                    num = num - (height-y-1);\\n                    y=height-1;\\n                }\\n                else if(cy==-1){\\n                    num = num - (y);\\n                    y=0;\\n                }\\n                currDir++;\\n                currDir%=4;\\n            }\\n            else{\\n                x += num*move[currDir][0];\\n                y += num*move[currDir][1];\\n                num=0;\\n            }\\n        }\\n        if(x==0 && y==0) currDir=3;\\n    }\\n    \\n    public int[] getPos() {\\n        return new int[]{x,y};\\n    }\\n    \\n    public String getDir() {\\n        return dir[currDir];\\n    }\\n}\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot obj = new Robot(width, height);\\n * obj.step(num);\\n * int[] param_2 = obj.getPos();\\n * String param_3 = obj.getDir();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Robot {\\n    int width,height,x,y;\\n    String[] dir = new String[]{\"East\",\"North\",\"West\",\"South\"};\\n    int[][] move = new int[][]{{1,0},{0,1},{-1,0},{0,-1}};\\n    int currDir = 0;\\n    int permeter = 0;\\n    public Robot(int width, int height) {\\n        this.width=width;\\n        this.height=height;\\n        x=0;\\n        y=0;\\n        permeter = 2*width + (2*(height-2));\\n    }\\n    \\n    public void step(int num) {\\n        num%=permeter;\\n        while(num>0){\\n            if(x + num*move[currDir][0]<0 || y + num*move[currDir][1]<0 || x + num*move[currDir][0]>=width || y + num*move[currDir][1]>=height){\\n                int cx = move[currDir][0],cy=move[currDir][1];\\n                if(cx==1){\\n                    num = num - (width-x-1);\\n                    x=width-1;\\n                }\\n                else if(cx==-1){\\n                    num = num - (x);\\n                    x=0;\\n                }\\n                else if(cy == 1){\\n                    num = num - (height-y-1);\\n                    y=height-1;\\n                }\\n                else if(cy==-1){\\n                    num = num - (y);\\n                    y=0;\\n                }\\n                currDir++;\\n                currDir%=4;\\n            }\\n            else{\\n                x += num*move[currDir][0];\\n                y += num*move[currDir][1];\\n                num=0;\\n            }\\n        }\\n        if(x==0 && y==0) currDir=3;\\n    }\\n    \\n    public int[] getPos() {\\n        return new int[]{x,y};\\n    }\\n    \\n    public String getDir() {\\n        return dir[currDir];\\n    }\\n}\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot obj = new Robot(width, height);\\n * obj.step(num);\\n * int[] param_2 = obj.getPos();\\n * String param_3 = obj.getDir();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1587643,
                "title": "c-easy-and-concise-solution",
                "content": "```\\nclass Robot {\\npublic:\\n    int rows,cols;\\n    string dir;\\n    int x,y;\\n    int total;\\n    Robot(int width, int height) {\\n        rows=height;\\n        cols=width;\\n        x=0;y=0;\\n        dir=\"East\";\\n        total=width*2+(height-2)*2;\\n    }\\n    \\n    void step(int num) {\\n        //robot walks only corner rows and cols\\n        num=num%total;\\n        if(x==0 && y==0  && num==0)\\n            dir=\"South\";\\n        int steps;\\n        while(num!=0)\\n        {\\n            if(dir==\"East\")\\n            {\\n                \\n                //increase the x\\n                steps=min(cols-(x+1),num);\\n                num-=steps;\\n               \\n                if(num)\\n                {\\n                    dir=\"North\";\\n                }\\n                x+=steps;\\n            }\\n            else if(dir==\"North\")\\n            {\\n                \\n                steps=min(rows-(y+1),num);\\n                num-=steps;\\n              \\n                if(num)\\n                    dir=\"West\";\\n                y+=steps;\\n            }\\n            else if(dir==\"West\")\\n            {\\n                steps=min(x,num);\\n                num-=steps;\\n                \\n                if(num)\\n                {\\n                    dir=\"South\";\\n                }\\n                x-=steps;\\n            }\\n            else if(dir==\"South\")\\n            {\\n                steps=min(y,num);\\n                num-=steps;\\n              \\n                if(num)\\n                    dir=\"East\";\\n                y-=steps;\\n            }\\n            \\n            \\n        }\\n    }\\n    \\n    vector<int> getPos() {\\n        return {x,y};\\n    }\\n    \\n    string getDir() {\\n        return  dir;\\n    }\\n};\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot* obj = new Robot(width, height);\\n * obj->step(num);\\n * vector<int> param_2 = obj->getPos();\\n * string param_3 = obj->getDir();\\n */\\n\\n```\\n**upvote if this helps you :)**",
                "solutionTags": [],
                "code": "```\\nclass Robot {\\npublic:\\n    int rows,cols;\\n    string dir;\\n    int x,y;\\n    int total;\\n    Robot(int width, int height) {\\n        rows=height;\\n        cols=width;\\n        x=0;y=0;\\n        dir=\"East\";\\n        total=width*2+(height-2)*2;\\n    }\\n    \\n    void step(int num) {\\n        //robot walks only corner rows and cols\\n        num=num%total;\\n        if(x==0 && y==0  && num==0)\\n            dir=\"South\";\\n        int steps;\\n        while(num!=0)\\n        {\\n            if(dir==\"East\")\\n            {\\n                \\n                //increase the x\\n                steps=min(cols-(x+1),num);\\n                num-=steps;\\n               \\n                if(num)\\n                {\\n                    dir=\"North\";\\n                }\\n                x+=steps;\\n            }\\n            else if(dir==\"North\")\\n            {\\n                \\n                steps=min(rows-(y+1),num);\\n                num-=steps;\\n              \\n                if(num)\\n                    dir=\"West\";\\n                y+=steps;\\n            }\\n            else if(dir==\"West\")\\n            {\\n                steps=min(x,num);\\n                num-=steps;\\n                \\n                if(num)\\n                {\\n                    dir=\"South\";\\n                }\\n                x-=steps;\\n            }\\n            else if(dir==\"South\")\\n            {\\n                steps=min(y,num);\\n                num-=steps;\\n              \\n                if(num)\\n                    dir=\"East\";\\n                y-=steps;\\n            }\\n            \\n            \\n        }\\n    }\\n    \\n    vector<int> getPos() {\\n        return {x,y};\\n    }\\n    \\n    string getDir() {\\n        return  dir;\\n    }\\n};\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot* obj = new Robot(width, height);\\n * obj->step(num);\\n * vector<int> param_2 = obj->getPos();\\n * string param_3 = obj->getDir();\\n */\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1586520,
                "title": "python3-area-perimeter-and-laps-counting",
                "content": "```\\nclass Robot:\\n\\n    def __init__(self, width: int, height: int):\\n        \\n        self.w = width\\n        self.h = height\\n        self.p = (self.w-1)*2+(self.h-1)*2\\n        \\n        self.pos = (0, 0)\\n        self.dir = 3\\n\\n        self.grid = [[0]*width for _ in range(height)]\\n        \\n        self.__moves = [\\n            (1, 0),\\n            (0, -1),\\n            (-1, 0),\\n            (0, 1),\\n        ]\\n\\n        self.__move_words = {\\n            0: \\'North\\',\\n            1: \\'West\\',\\n            2: \\'South\\',\\n            3: \\'East\\'\\n        }\\n    \\n    def calc_pos(self, num: int) -> None:\\n        \\n        while num > 0:\\n\\n            dist = None\\n\\n            if self.dir == 1:\\n                dist = abs(0 - self.pos[1])\\n            elif self.dir == 3:\\n                dist = (self.w-1) - self.pos[1]\\n            elif self.dir == 2:\\n                dist = abs(0 - self.pos[0])\\n            elif self.dir == 0:\\n                dist = (self.h-1) - self.pos[0]\\n\\n            # case 1: num of steps <= dist\\n            if num <= dist:\\n\\n                next_y = self.pos[0] + self.__moves[self.dir][0]*min(dist, num)\\n                next_x = self.pos[1] + self.__moves[self.dir][1]*min(dist, num)\\n\\n                self.pos = (next_y, next_x)\\n\\n                num -= min(dist, num)\\n\\n                continue\\n\\n            # case 2: num of steps > dist\\n            # num - dist and switch direction\\n            next_y = self.pos[0] + self.__moves[self.dir][0]*dist\\n            next_x = self.pos[1] + self.__moves[self.dir][1]*dist\\n\\n            self.pos = (next_y, next_x)\\n            self.dir = self.dir + 1 if self.dir + 1 < len(self.__moves) else 0\\n\\n            num -= dist\\n            \\n        return self.pos\\n            \\n    def step(self, num: int) -> None:\\n        \\n        laps = num // self.p\\n        remainder = num % self.p\\n       \\n        if remainder == 0 and laps == 0:\\n            return\\n                \\n        if laps == 0 and remainder > 0:\\n            self.calc_pos(num)\\n        elif laps >= 1 and remainder == 0:\\n            # if starts from (0,0) and walk full lap -> change direction\\n            # otherwise -> nothing\\n            if self.pos[1] == 0 and self.pos[0] == 0:\\n                self.dir = 2\\n        elif laps > 0 and remainder > 0:\\n            if self.pos[1] == 0 and self.pos[0] == 0:\\n                self.dir = 2\\n            self.calc_pos(remainder)\\n\\t\\n    def getPos(self) -> List[int]:\\n        return  self.pos[::-1]\\n\\n    def getDir(self) -> str:\\n        return self.__move_words.get(self.dir)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Robot:\\n\\n    def __init__(self, width: int, height: int):\\n        \\n        self.w = width\\n        self.h = height\\n        self.p = (self.w-1)*2+(self.h-1)*2\\n        \\n        self.pos = (0, 0)\\n        self.dir = 3\\n\\n        self.grid = [[0]*width for _ in range(height)]\\n        \\n        self.__moves = [\\n            (1, 0),\\n            (0, -1),\\n            (-1, 0),\\n            (0, 1),\\n        ]\\n\\n        self.__move_words = {\\n            0: \\'North\\',\\n            1: \\'West\\',\\n            2: \\'South\\',\\n            3: \\'East\\'\\n        }\\n    \\n    def calc_pos(self, num: int) -> None:\\n        \\n        while num > 0:\\n\\n            dist = None\\n\\n            if self.dir == 1:\\n                dist = abs(0 - self.pos[1])\\n            elif self.dir == 3:\\n                dist = (self.w-1) - self.pos[1]\\n            elif self.dir == 2:\\n                dist = abs(0 - self.pos[0])\\n            elif self.dir == 0:\\n                dist = (self.h-1) - self.pos[0]\\n\\n            # case 1: num of steps <= dist\\n            if num <= dist:\\n\\n                next_y = self.pos[0] + self.__moves[self.dir][0]*min(dist, num)\\n                next_x = self.pos[1] + self.__moves[self.dir][1]*min(dist, num)\\n\\n                self.pos = (next_y, next_x)\\n\\n                num -= min(dist, num)\\n\\n                continue\\n\\n            # case 2: num of steps > dist\\n            # num - dist and switch direction\\n            next_y = self.pos[0] + self.__moves[self.dir][0]*dist\\n            next_x = self.pos[1] + self.__moves[self.dir][1]*dist\\n\\n            self.pos = (next_y, next_x)\\n            self.dir = self.dir + 1 if self.dir + 1 < len(self.__moves) else 0\\n\\n            num -= dist\\n            \\n        return self.pos\\n            \\n    def step(self, num: int) -> None:\\n        \\n        laps = num // self.p\\n        remainder = num % self.p\\n       \\n        if remainder == 0 and laps == 0:\\n            return\\n                \\n        if laps == 0 and remainder > 0:\\n            self.calc_pos(num)\\n        elif laps >= 1 and remainder == 0:\\n            # if starts from (0,0) and walk full lap -> change direction\\n            # otherwise -> nothing\\n            if self.pos[1] == 0 and self.pos[0] == 0:\\n                self.dir = 2\\n        elif laps > 0 and remainder > 0:\\n            if self.pos[1] == 0 and self.pos[0] == 0:\\n                self.dir = 2\\n            self.calc_pos(remainder)\\n\\t\\n    def getPos(self) -> List[int]:\\n        return  self.pos[::-1]\\n\\n    def getDir(self) -> str:\\n        return self.__move_words.get(self.dir)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1582504,
                "title": "golang-simple-solution",
                "content": "```go\\ntype Robot struct {\\n\\tcurr int\\n\\tbase int\\n\\tpos  [][]int\\n\\tdir  []string\\n}\\n\\nfunc Constructor(width int, height int) Robot {\\n\\tbase := (width + height) * 2 - 4\\n\\tpos := make([][]int, base)\\n\\tdir := make([]string, base)\\n\\tdir[0] = \"South\"\\n\\tpos[0] = []int{0, 0}\\n\\tfor i := 1; i < width; i++ {\\n\\t\\tdir[i] = \"East\"\\n\\t\\tpos[i] = []int{i, 0}\\n\\t}\\n\\tfor i := width; i < width+height-1; i++ {\\n\\t\\tdir[i] = \"North\"\\n\\t\\tpos[i] = []int{width-1, i-width+1}\\n\\t}\\n\\tfor i := width+height-1; i < 2*width+height-2; i++ {\\n\\t\\tdir[i] = \"West\"\\n\\t\\tpos[i] = []int{2*width+height-3-i, height-1}\\n\\t}\\n\\tfor i := 2*width+height-2; i < base; i++ {\\n\\t\\tdir[i] = \"South\"\\n\\t\\tpos[i] = []int{0, base-i}\\n\\t}\\n\\treturn Robot{\\n\\t\\tcurr: 0,\\n\\t\\tbase: base,\\n\\t\\tpos:  pos,\\n\\t\\tdir:  dir,\\n\\t}\\n}\\n\\nfunc (r *Robot) Move(num int)  {\\n\\tr.curr += num\\n}\\n\\nfunc (r *Robot) GetPos() []int {\\n\\treturn r.pos[r.curr%r.base]\\n}\\n\\nfunc (r *Robot) GetDir() string {\\n\\tif r.curr == 0 {\\n\\t\\treturn \"East\"\\n\\t}\\n\\treturn r.dir[r.curr%r.base]\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\ntype Robot struct {\\n\\tcurr int\\n\\tbase int\\n\\tpos  [][]int\\n\\tdir  []string\\n}\\n\\nfunc Constructor(width int, height int) Robot {\\n\\tbase := (width + height) * 2 - 4\\n\\tpos := make([][]int, base)\\n\\tdir := make([]string, base)\\n\\tdir[0] = \"South\"\\n\\tpos[0] = []int{0, 0}\\n\\tfor i := 1; i < width; i++ {\\n\\t\\tdir[i] = \"East\"\\n\\t\\tpos[i] = []int{i, 0}\\n\\t}\\n\\tfor i := width; i < width+height-1; i++ {\\n\\t\\tdir[i] = \"North\"\\n\\t\\tpos[i] = []int{width-1, i-width+1}\\n\\t}\\n\\tfor i := width+height-1; i < 2*width+height-2; i++ {\\n\\t\\tdir[i] = \"West\"\\n\\t\\tpos[i] = []int{2*width+height-3-i, height-1}\\n\\t}\\n\\tfor i := 2*width+height-2; i < base; i++ {\\n\\t\\tdir[i] = \"South\"\\n\\t\\tpos[i] = []int{0, base-i}\\n\\t}\\n\\treturn Robot{\\n\\t\\tcurr: 0,\\n\\t\\tbase: base,\\n\\t\\tpos:  pos,\\n\\t\\tdir:  dir,\\n\\t}\\n}\\n\\nfunc (r *Robot) Move(num int)  {\\n\\tr.curr += num\\n}\\n\\nfunc (r *Robot) GetPos() []int {\\n\\treturn r.pos[r.curr%r.base]\\n}\\n\\nfunc (r *Robot) GetDir() string {\\n\\tif r.curr == 0 {\\n\\t\\treturn \"East\"\\n\\t}\\n\\treturn r.dir[r.curr%r.base]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1582247,
                "title": "java-clear-solution-o-1-space",
                "content": "Improved version (beats 98%), O(1) space:\\n```\\n    class Robot {\\n        private int[] currPos = new int[2];\\n        private int width, height, perimeter, currInd;\\n        private boolean bMoved;\\n\\t\\t\\n        public Robot(int width, int height) {\\n            this.width = width;\\n            this.height = height;\\n            perimeter = (width + height)*2 - 4;\\n        }\\n        public void move(int num) {\\n            bMoved = true;\\n            currInd = (currInd+num)%perimeter;\\n        }\\n        public int[] getPos() {\\n            if(currInd < width){\\n                currPos[0] = currInd;\\n                currPos[1] = 0;\\n            }else if(currInd >= width && currInd < width + height -1){\\n                currPos[0] = width-1;\\n                currPos[1] = currInd - width +1 ;\\n            }else if(currInd >= width + height - 1 && currInd < width + height - 1 + width - 1){\\n                currPos[0] = width - (currInd - width - height +1) -1 -1;\\n                currPos[1] = height -1;\\n            }else{\\n                currPos[0] = 0;\\n                currPos[1] = height - (currInd - width - height +1 - width + 1) -1 -1;\\n            }\\n            return currPos;\\n        }\\n        public String getDir() {\\n            if(!bMoved || currInd >0 && currInd < width)\\n                return \"East\";\\n            else if(currInd >= width && currInd < width + height -1)\\n                return \"North\";\\n            else if(currInd >= width + height - 1 && currInd < width + height - 1 + width - 1)\\n                return \"West\";\\n            return \"South\";\\n        }\\n    }\\n```\\n\\n\\nPrevious version ( beats 65%), O(1) space:\\n```\\n    class Robot {\\n        private static final int[] dirs = {0,1,0,-1,0};\\n        private static final int EAST_DIR = 0,  NORTH_DIR = 1, WEST_DIR = 2, SOUTH_DIR = 3, DIR_NUM = dirs.length -1;\\n        private static final String[] dirNames = {\"East\", \"North\", \"West\", \"South\"};\\n\\n        private int currDir;\\n        private int[] currPos = new int[2];\\n        private int width, height, perimeter;\\n        private long neededSteps;\\n\\n        public Robot(int width, int height) {\\n            this.width = width;\\n            this.height = height;\\n            perimeter = (width + height)*2 - 4;\\n        }\\n        public void move(int num) {\\n            neededSteps += num;\\n        }\\n        private void realMove(){\\n            neededSteps %= perimeter;\\n            if(neededSteps==0)\\n                neededSteps=perimeter;\\n\\n            while(neededSteps !=0){\\n                if( currDir==EAST_DIR && currPos[0]==width-1 || currDir==WEST_DIR && currPos[0]==0 ||\\n                        currDir==SOUTH_DIR && currPos[1]==0 || currDir==NORTH_DIR && currPos[1]==height-1)\\n                    currDir = (currDir+1)%DIR_NUM;\\n                currPos[1] += dirs[currDir];\\n                currPos[0] += dirs[currDir+1];\\n                neededSteps--;\\n            }\\n        }\\n        public int[] getPos() {\\n            if(neededSteps != 0)\\n                realMove();\\n            return currPos;\\n        }\\n        public String getDir() {\\n            if(neededSteps != 0)\\n                realMove();\\n            return dirNames[currDir];\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    class Robot {\\n        private int[] currPos = new int[2];\\n        private int width, height, perimeter, currInd;\\n        private boolean bMoved;\\n\\t\\t\\n        public Robot(int width, int height) {\\n            this.width = width;\\n            this.height = height;\\n            perimeter = (width + height)*2 - 4;\\n        }\\n        public void move(int num) {\\n            bMoved = true;\\n            currInd = (currInd+num)%perimeter;\\n        }\\n        public int[] getPos() {\\n            if(currInd < width){\\n                currPos[0] = currInd;\\n                currPos[1] = 0;\\n            }else if(currInd >= width && currInd < width + height -1){\\n                currPos[0] = width-1;\\n                currPos[1] = currInd - width +1 ;\\n            }else if(currInd >= width + height - 1 && currInd < width + height - 1 + width - 1){\\n                currPos[0] = width - (currInd - width - height +1) -1 -1;\\n                currPos[1] = height -1;\\n            }else{\\n                currPos[0] = 0;\\n                currPos[1] = height - (currInd - width - height +1 - width + 1) -1 -1;\\n            }\\n            return currPos;\\n        }\\n        public String getDir() {\\n            if(!bMoved || currInd >0 && currInd < width)\\n                return \"East\";\\n            else if(currInd >= width && currInd < width + height -1)\\n                return \"North\";\\n            else if(currInd >= width + height - 1 && currInd < width + height - 1 + width - 1)\\n                return \"West\";\\n            return \"South\";\\n        }\\n    }\\n```\n```\\n    class Robot {\\n        private static final int[] dirs = {0,1,0,-1,0};\\n        private static final int EAST_DIR = 0,  NORTH_DIR = 1, WEST_DIR = 2, SOUTH_DIR = 3, DIR_NUM = dirs.length -1;\\n        private static final String[] dirNames = {\"East\", \"North\", \"West\", \"South\"};\\n\\n        private int currDir;\\n        private int[] currPos = new int[2];\\n        private int width, height, perimeter;\\n        private long neededSteps;\\n\\n        public Robot(int width, int height) {\\n            this.width = width;\\n            this.height = height;\\n            perimeter = (width + height)*2 - 4;\\n        }\\n        public void move(int num) {\\n            neededSteps += num;\\n        }\\n        private void realMove(){\\n            neededSteps %= perimeter;\\n            if(neededSteps==0)\\n                neededSteps=perimeter;\\n\\n            while(neededSteps !=0){\\n                if( currDir==EAST_DIR && currPos[0]==width-1 || currDir==WEST_DIR && currPos[0]==0 ||\\n                        currDir==SOUTH_DIR && currPos[1]==0 || currDir==NORTH_DIR && currPos[1]==height-1)\\n                    currDir = (currDir+1)%DIR_NUM;\\n                currPos[1] += dirs[currDir];\\n                currPos[0] += dirs[currDir+1];\\n                neededSteps--;\\n            }\\n        }\\n        public int[] getPos() {\\n            if(neededSteps != 0)\\n                realMove();\\n            return currPos;\\n        }\\n        public String getDir() {\\n            if(neededSteps != 0)\\n                realMove();\\n            return dirNames[currDir];\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1582026,
                "title": "go-solution",
                "content": "```\\ntype Robot struct {\\n    W int\\n    H int\\n    Per int\\n    X int\\n    Y int\\n    Dir int\\n}\\n\\n\\nfunc Constructor(w int, h int) Robot {\\n    Per := (w + h) * 2 - 4\\n    return Robot{w, h, Per, 0, 0, 0}\\n}\\n\\n\\nfunc (this *Robot) Move(num int)  {\\n    move := num % this.Per\\n    move += this.Per\\n       \\n    for i := 0; i < move; i++ {\\n        this.Correct();\\n        if this.Dir == 0 {\\n            this.X++\\n        } else if this.Dir == 1 {\\n            this.Y++\\n        } else if this.Dir == 2 {\\n            this.X--\\n        } else {\\n            this.Y--\\n        }\\n    }\\n    \\n}\\n\\nfunc (this *Robot) Correct() {\\n    if this.Dir == 0 {\\n        if this.X == this.W - 1 && this.Y == 0 {\\n            this.Dir++\\n        }\\n    } else if this.Dir == 1 {\\n        if this.Y == this.H - 1 && this.X == this.W - 1 {\\n            this.Dir++\\n        }    \\n    } else if this.Dir == 2 {\\n        if this.X == 0 && this.Y == this.H - 1 {\\n            this.Dir++\\n        }\\n    } else {\\n        if this.Y == 0 && this.X == 0 {\\n            this.Dir++\\n        }\\n    }\\n    \\n    this.Dir %= 4\\n}\\n\\nfunc (this *Robot) GetPos() []int {\\n    return []int{this.X, this.Y}\\n}\\n\\n\\nfunc (this *Robot) GetDir() string {\\n    if this.Dir == 0 {\\n        return \"East\"\\n    } else if this.Dir == 1 {\\n        return \"North\"  \\n    } else if this.Dir == 2 {\\n        return \"West\"\\n    } else {\\n        return \"South\"\\n    }\\n}\\n\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * obj := Constructor(width, height);\\n * obj.Move(num);\\n * param_2 := obj.GetPos();\\n * param_3 := obj.GetDir();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\ntype Robot struct {\\n    W int\\n    H int\\n    Per int\\n    X int\\n    Y int\\n    Dir int\\n}\\n\\n\\nfunc Constructor(w int, h int) Robot {\\n    Per := (w + h) * 2 - 4\\n    return Robot{w, h, Per, 0, 0, 0}\\n}\\n\\n\\nfunc (this *Robot) Move(num int)  {\\n    move := num % this.Per\\n    move += this.Per\\n       \\n    for i := 0; i < move; i++ {\\n        this.Correct();\\n        if this.Dir == 0 {\\n            this.X++\\n        } else if this.Dir == 1 {\\n            this.Y++\\n        } else if this.Dir == 2 {\\n            this.X--\\n        } else {\\n            this.Y--\\n        }\\n    }\\n    \\n}\\n\\nfunc (this *Robot) Correct() {\\n    if this.Dir == 0 {\\n        if this.X == this.W - 1 && this.Y == 0 {\\n            this.Dir++\\n        }\\n    } else if this.Dir == 1 {\\n        if this.Y == this.H - 1 && this.X == this.W - 1 {\\n            this.Dir++\\n        }    \\n    } else if this.Dir == 2 {\\n        if this.X == 0 && this.Y == this.H - 1 {\\n            this.Dir++\\n        }\\n    } else {\\n        if this.Y == 0 && this.X == 0 {\\n            this.Dir++\\n        }\\n    }\\n    \\n    this.Dir %= 4\\n}\\n\\nfunc (this *Robot) GetPos() []int {\\n    return []int{this.X, this.Y}\\n}\\n\\n\\nfunc (this *Robot) GetDir() string {\\n    if this.Dir == 0 {\\n        return \"East\"\\n    } else if this.Dir == 1 {\\n        return \"North\"  \\n    } else if this.Dir == 2 {\\n        return \"West\"\\n    } else {\\n        return \"South\"\\n    }\\n}\\n\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * obj := Constructor(width, height);\\n * obj.Move(num);\\n * param_2 := obj.GetPos();\\n * param_3 := obj.GetDir();\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1581703,
                "title": "java-60ms-beats-94-04-super-easy-logic-flatten-to-1d-array",
                "content": "Many People are Criticising this Qs . But Actually this Qs test your analytical skills . \\n\\nLet me Explain the Logic behind this ;\\nThe Robot can only move along the Perimeter of the board ; \\nhanding 2D grid is very difficult . So we Flatten the Perimeter of the grid into a 1D Array : where each index a[i] contiains x,y,dir  of the perimeter of board :\\n\\nConsider a 3*3 grid with width w and height h as shown in Qs with the location of x and y axes . \\n\\n![image](https://assets.leetcode.com/users/images/47ecb879-c2c3-46be-b0ad-6bbe5d90cb59_1637089998.1567314.png)\\n\\ni wrote down all the point forming the perimeter of the grid and add it to array  in anti-clockwise manner\\nnow whenever we need to move Robo . just add the num to current position and mod with Perimeter  ```   pos=(pos+(num%P))%P; ```\\n\\nUsing array instead Enhances the Performance Beats  94% \\nCode : \\n```\\nint W,H;\\n\\tint dir;//0N 1S 2E 3W\\n\\tnode[] a;\\n\\tint P;// Perimeter\\n\\tint pos; //curr pos of robo\\n\\tboolean init=false; // for handling edge case\\n\\tpublic Robot(int width, int height) {\\n\\t\\tP=2*(width+height)-4;\\n\\t\\tthis.pos=0;this.dir=1;\\n\\t\\tthis.W=width;this.H=height;\\n\\t\\ta=new node[P];\\n\\t\\tint x=0,y=0;\\n\\t\\tfor(int i=0;i<a.length;i++) { // traverse the array and store boundary points in it\\n\\t\\t\\ta[i]=new node(x,y,dir);\\n\\t\\t\\tif(x==0&&y==0) dir=2;\\n\\t\\t\\telse if(x==W-1&&y==0) dir=0;\\n\\t\\t\\telse if(x==W-1&&y==H-1) dir=3;\\n\\t\\t\\telse if(x==0&&y==H-1) dir=1;\\n\\t\\t\\t\\n\\t\\t\\tif(dir==0) y++;\\n\\t\\t\\telse if(dir==1) y--;\\n\\t\\t\\telse if(dir==2) x++;\\n\\t\\t\\telse x--;\\n\\t\\t}\\n    }\\n    \\n    public void move(int num) {\\n        pos=(pos+(num%P))%P;\\n       init=true; \\n    }\\n    \\n    public int[] getPos() {\\n        return new int[] {a[pos].x,a[pos].y};\\n    }\\n    \\n    public String getDir() {\\n    \\tif(!init) return \"East\";//for edge case\\n    \\t\\n    \\tif(a[pos].dir==0) return \"North\";\\n    \\telse if(a[pos].dir==1) return \"South\";\\n    \\telse if(a[pos].dir==2) return \"East\";\\n        return \"West\";\\n    }\\n    static class node{\\n    \\tint x,y,dir;\\n    \\tnode(int x,int y,int dir){this.x=x;this.y=y;this.dir=dir;}\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```   pos=(pos+(num%P))%P; ```\n```\\nint W,H;\\n\\tint dir;//0N 1S 2E 3W\\n\\tnode[] a;\\n\\tint P;// Perimeter\\n\\tint pos; //curr pos of robo\\n\\tboolean init=false; // for handling edge case\\n\\tpublic Robot(int width, int height) {\\n\\t\\tP=2*(width+height)-4;\\n\\t\\tthis.pos=0;this.dir=1;\\n\\t\\tthis.W=width;this.H=height;\\n\\t\\ta=new node[P];\\n\\t\\tint x=0,y=0;\\n\\t\\tfor(int i=0;i<a.length;i++) { // traverse the array and store boundary points in it\\n\\t\\t\\ta[i]=new node(x,y,dir);\\n\\t\\t\\tif(x==0&&y==0) dir=2;\\n\\t\\t\\telse if(x==W-1&&y==0) dir=0;\\n\\t\\t\\telse if(x==W-1&&y==H-1) dir=3;\\n\\t\\t\\telse if(x==0&&y==H-1) dir=1;\\n\\t\\t\\t\\n\\t\\t\\tif(dir==0) y++;\\n\\t\\t\\telse if(dir==1) y--;\\n\\t\\t\\telse if(dir==2) x++;\\n\\t\\t\\telse x--;\\n\\t\\t}\\n    }\\n    \\n    public void move(int num) {\\n        pos=(pos+(num%P))%P;\\n       init=true; \\n    }\\n    \\n    public int[] getPos() {\\n        return new int[] {a[pos].x,a[pos].y};\\n    }\\n    \\n    public String getDir() {\\n    \\tif(!init) return \"East\";//for edge case\\n    \\t\\n    \\tif(a[pos].dir==0) return \"North\";\\n    \\telse if(a[pos].dir==1) return \"South\";\\n    \\telse if(a[pos].dir==2) return \"East\";\\n        return \"West\";\\n    }\\n    static class node{\\n    \\tint x,y,dir;\\n    \\tnode(int x,int y,int dir){this.x=x;this.y=y;this.dir=dir;}\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1580991,
                "title": "c-clean-implementation",
                "content": "Solution:\\n```\\nclass Robot {\\nprivate:\\n    \\n    int x = 0;\\n    int y = 0;\\n    char direction = \\'E\\';\\n    pair<int,int> current = {0,0};\\n\\npublic:\\n    Robot(int width, int height) {\\n        x = width-1;\\n        y = height-1;\\n    }\\n    \\n    int changeDirection(int i){\\n        if(current.first > x){\\n            current.first--;\\n            i--;\\n            direction = \\'N\\';\\n        }\\n        if(current.second > y){\\n            current.second--;\\n            i--;\\n            direction = \\'W\\';\\n        }\\n        if(current.first < 0){\\n            current.first++;\\n            i--;\\n            direction = \\'S\\';\\n        }\\n        if(current.second < 0){\\n            current.second++;\\n            i--;\\n            direction = \\'E\\';\\n        }\\n\\n        return i;\\n    }\\n    \\n    void move(int num) {\\n        int i = 0;\\n        int rotation = 2*(x+y);\\n        num = num%(rotation);\\n        \\n        if(num == 0){\\n            num += 2*(x+y);\\n        }\\n        \\n        while(i < num){\\n\\n            i = changeDirection(i);\\n            \\n            // Moving the robot.\\n            if(direction == \\'E\\'){\\n                current.first += 1;\\n                current.second += 0;   \\n            }\\n            if(direction == \\'N\\'){\\n                current.first += 0;\\n                current.second += 1;   \\n            }\\n            if(direction == \\'W\\'){\\n                current.first += -1;\\n                current.second += 0;   \\n            }\\n            if(direction == \\'S\\'){\\n                current.first += 0;\\n                current.second += -1;   \\n            }\\n            \\n            i = changeDirection(i);\\n            \\n            i++;\\n        }\\n    }\\n    \\n    vector<int> getPos() {\\n        vector<int> pos(2,0);\\n    \\n        pos[0] = current.first;\\n        pos[1] = current.second;\\n        \\n        return pos;\\n    }\\n    \\n    string getDir() {\\n        if(direction == \\'E\\'){\\n            return \"East\";\\n        }\\n        \\n        if(direction == \\'W\\'){\\n            return \"West\";\\n        }\\n        \\n        if(direction == \\'N\\'){\\n            return \"North\";\\n        }\\n        \\n        if(direction == \\'S\\'){\\n            return \"South\";\\n        }\\n        \\n        // This shouldn\\'t be the case ever!\\n        return \"\";\\n    }\\n};\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot* obj = new Robot(width, height);\\n * obj->move(num);\\n * vector<int> param_2 = obj->getPos();\\n * string param_3 = obj->getDir();\\n */\\n```\\n\\n\\nThis trick here is that, we can\\'t blindly divide the steps of robot by perimeter. Beacuse once it has completed a traversal along it\\'s perimeter it\\'s direction would be towards down (South) and not East (if we wouldn\\'t do anything, thinking as the steps to be 0.)\\nHence, if nums%perimeter == 0; I manually add the perimeter again, so that the robot can loop again to its perimeter and give the desired direction.\\n",
                "solutionTags": [],
                "code": "```\\nclass Robot {\\nprivate:\\n    \\n    int x = 0;\\n    int y = 0;\\n    char direction = \\'E\\';\\n    pair<int,int> current = {0,0};\\n\\npublic:\\n    Robot(int width, int height) {\\n        x = width-1;\\n        y = height-1;\\n    }\\n    \\n    int changeDirection(int i){\\n        if(current.first > x){\\n            current.first--;\\n            i--;\\n            direction = \\'N\\';\\n        }\\n        if(current.second > y){\\n            current.second--;\\n            i--;\\n            direction = \\'W\\';\\n        }\\n        if(current.first < 0){\\n            current.first++;\\n            i--;\\n            direction = \\'S\\';\\n        }\\n        if(current.second < 0){\\n            current.second++;\\n            i--;\\n            direction = \\'E\\';\\n        }\\n\\n        return i;\\n    }\\n    \\n    void move(int num) {\\n        int i = 0;\\n        int rotation = 2*(x+y);\\n        num = num%(rotation);\\n        \\n        if(num == 0){\\n            num += 2*(x+y);\\n        }\\n        \\n        while(i < num){\\n\\n            i = changeDirection(i);\\n            \\n            // Moving the robot.\\n            if(direction == \\'E\\'){\\n                current.first += 1;\\n                current.second += 0;   \\n            }\\n            if(direction == \\'N\\'){\\n                current.first += 0;\\n                current.second += 1;   \\n            }\\n            if(direction == \\'W\\'){\\n                current.first += -1;\\n                current.second += 0;   \\n            }\\n            if(direction == \\'S\\'){\\n                current.first += 0;\\n                current.second += -1;   \\n            }\\n            \\n            i = changeDirection(i);\\n            \\n            i++;\\n        }\\n    }\\n    \\n    vector<int> getPos() {\\n        vector<int> pos(2,0);\\n    \\n        pos[0] = current.first;\\n        pos[1] = current.second;\\n        \\n        return pos;\\n    }\\n    \\n    string getDir() {\\n        if(direction == \\'E\\'){\\n            return \"East\";\\n        }\\n        \\n        if(direction == \\'W\\'){\\n            return \"West\";\\n        }\\n        \\n        if(direction == \\'N\\'){\\n            return \"North\";\\n        }\\n        \\n        if(direction == \\'S\\'){\\n            return \"South\";\\n        }\\n        \\n        // This shouldn\\'t be the case ever!\\n        return \"\";\\n    }\\n};\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot* obj = new Robot(width, height);\\n * obj->move(num);\\n * vector<int> param_2 = obj->getPos();\\n * string param_3 = obj->getDir();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1580829,
                "title": "need-help",
                "content": "![image](https://assets.leetcode.com/users/images/eb02e33e-243b-478b-ae1b-ddd92ff5f07f_1637048289.3600085.png)\\n\\n```\\nclass Robot {\\n\\n    int width,height;\\n    int i,j;\\n    char face;\\n    int rem;\\n    public Robot(int width, int height) {\\n        this.width=width;\\n        this.height=height;\\n        this.i=0;\\n        this.j=0;\\n        this.face=\\'e\\';\\n        this.rem=0;\\n    }\\n    public void move(int num) {\\n        moveHere(num);\\n        //System.out.println(\"current : \"+i+\" \"+j);\\n        // rem+=num;\\n        // rem%=((width+height)*2);\\n    }\\n    public void moveHere(int num) {\\n        int temp=num;\\n        num=num%(2*width+2*height);\\n        if(temp>0 && num==0){\\n            if(face==\\'s\\')\\n                face=\\'w\\';\\n            else if(face==\\'e\\')\\n                face=\\'s\\';\\n            else if(face==\\'n\\')\\n                face=\\'e\\';\\n            else\\n                face=\\'n\\';\\n            return;\\n        }\\n        if(face==\\'e\\'){\\n            if(j+num<width){\\n                j+=num;\\n            }else{\\n                int rem=num-(width-j-1);\\n                j=width-1;\\n                face=\\'n\\';\\n                moveHere(rem);\\n            }\\n        }else if(face==\\'n\\'){\\n            if(i+num<height){\\n                i+=num;\\n            }else{\\n                int rem=num-(height-i-1);\\n                i=height-1;\\n                face=\\'w\\';\\n                moveHere(rem);\\n            }\\n        }else if(face==\\'w\\'){\\n            if(j-num>=0){\\n                j-=num;\\n            }else{\\n                int rem=num-j;\\n                j=0;\\n                face=\\'s\\';\\n                moveHere(rem);\\n            }\\n        }else{\\n            if(i-num>=0){\\n                i-=num;\\n            }else{\\n                int rem=num-i;\\n                i=0;\\n                face=\\'e\\';\\n                moveHere(rem);\\n            }\\n        }\\n    }\\n    \\n    public int[] getPos() {\\n        moveHere(rem);\\n        rem=0;\\n        int pos[]=new int[2];\\n        pos[0]=j;\\n        pos[1]=i;\\n        return pos;\\n    }\\n    \\n    public String getDir() {\\n        if(face==\\'w\\')\\n            return \"West\";\\n        else if(face==\\'e\\')\\n            return \"East\";\\n        else if(face==\\'s\\')\\n            return \"South\";\\n        else\\n            return \"North\";\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Robot {\\n\\n    int width,height;\\n    int i,j;\\n    char face;\\n    int rem;\\n    public Robot(int width, int height) {\\n        this.width=width;\\n        this.height=height;\\n        this.i=0;\\n        this.j=0;\\n        this.face=\\'e\\';\\n        this.rem=0;\\n    }\\n    public void move(int num) {\\n        moveHere(num);\\n        //System.out.println(\"current : \"+i+\" \"+j);\\n        // rem+=num;\\n        // rem%=((width+height)*2);\\n    }\\n    public void moveHere(int num) {\\n        int temp=num;\\n        num=num%(2*width+2*height);\\n        if(temp>0 && num==0){\\n            if(face==\\'s\\')\\n                face=\\'w\\';\\n            else if(face==\\'e\\')\\n                face=\\'s\\';\\n            else if(face==\\'n\\')\\n                face=\\'e\\';\\n            else\\n                face=\\'n\\';\\n            return;\\n        }\\n        if(face==\\'e\\'){\\n            if(j+num<width){\\n                j+=num;\\n            }else{\\n                int rem=num-(width-j-1);\\n                j=width-1;\\n                face=\\'n\\';\\n                moveHere(rem);\\n            }\\n        }else if(face==\\'n\\'){\\n            if(i+num<height){\\n                i+=num;\\n            }else{\\n                int rem=num-(height-i-1);\\n                i=height-1;\\n                face=\\'w\\';\\n                moveHere(rem);\\n            }\\n        }else if(face==\\'w\\'){\\n            if(j-num>=0){\\n                j-=num;\\n            }else{\\n                int rem=num-j;\\n                j=0;\\n                face=\\'s\\';\\n                moveHere(rem);\\n            }\\n        }else{\\n            if(i-num>=0){\\n                i-=num;\\n            }else{\\n                int rem=num-i;\\n                i=0;\\n                face=\\'e\\';\\n                moveHere(rem);\\n            }\\n        }\\n    }\\n    \\n    public int[] getPos() {\\n        moveHere(rem);\\n        rem=0;\\n        int pos[]=new int[2];\\n        pos[0]=j;\\n        pos[1]=i;\\n        return pos;\\n    }\\n    \\n    public String getDir() {\\n        if(face==\\'w\\')\\n            return \"West\";\\n        else if(face==\\'e\\')\\n            return \"East\";\\n        else if(face==\\'s\\')\\n            return \"South\";\\n        else\\n            return \"North\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1579121,
                "title": "consider-the-perimeter-as-closed-loop-100-speed",
                "content": "![image](https://assets.leetcode.com/users/images/00b3588c-2edf-42bb-ae7b-d8bb31ef10cc_1636957669.1466577.png)\\n\\nFind the perimeter length, `n`. Find boundary points `n1, n2, n3` to know on which side the robot is, depending on its position `pos`. Depending on which side, compute coordinates and direction. `While` loop is not required as `new_pos = (pos + move) % n`.\\n\\n```\\nclass Robot:\\n\\n    def __init__(self, width: int, height: int):\\n        self.n = (width + height) * 2 - 4\\n        self.n1 = width\\n        self.n2 = width + height - 1\\n        self.n3 = 2 * width + height - 2\\n        self.moved = False\\n        self.pos = 0\\n        self.x_right = width - 1\\n        self.y_up = height - 1\\n\\n    def move(self, num: int) -> None:\\n        if not self.moved:\\n            self.moved = True\\n        self.pos += num\\n        self.pos %= self.n\\n\\n    def getPos(self) -> List[int]:\\n        if self.pos < self.n1:\\n            return [self.pos, 0]\\n        elif self.pos < self.n2:\\n            return [self.x_right, self.pos - self.n1 + 1]\\n        elif self.pos < self.n3:\\n            return [self.n3 - 1 - self.pos, self.y_up]\\n        else:\\n            return [0, self.n - self.pos]\\n\\n    def getDir(self) -> str:\\n        if self.pos < self.n1:\\n            if self.moved and self.pos == 0:\\n                return \"South\"\\n            return \"East\"\\n        elif self.pos < self.n2:\\n            return \"North\"\\n        elif self.pos < self.n3:\\n            return \"West\"\\n        else:\\n            return \"South\"\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Robot:\\n\\n    def __init__(self, width: int, height: int):\\n        self.n = (width + height) * 2 - 4\\n        self.n1 = width\\n        self.n2 = width + height - 1\\n        self.n3 = 2 * width + height - 2\\n        self.moved = False\\n        self.pos = 0\\n        self.x_right = width - 1\\n        self.y_up = height - 1\\n\\n    def move(self, num: int) -> None:\\n        if not self.moved:\\n            self.moved = True\\n        self.pos += num\\n        self.pos %= self.n\\n\\n    def getPos(self) -> List[int]:\\n        if self.pos < self.n1:\\n            return [self.pos, 0]\\n        elif self.pos < self.n2:\\n            return [self.x_right, self.pos - self.n1 + 1]\\n        elif self.pos < self.n3:\\n            return [self.n3 - 1 - self.pos, self.y_up]\\n        else:\\n            return [0, self.n - self.pos]\\n\\n    def getDir(self) -> str:\\n        if self.pos < self.n1:\\n            if self.moved and self.pos == 0:\\n                return \"South\"\\n            return \"East\"\\n        elif self.pos < self.n2:\\n            return \"North\"\\n        elif self.pos < self.n3:\\n            return \"West\"\\n        else:\\n            return \"South\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1579042,
                "title": "java-solution-with-approach-explanation",
                "content": "I don\\'t think that this question is as bad as many people believe it is, although I do agree that it offers little more other than tedious mathematical calculations. So I see why many would be annoyed.\\n\\nThe approach is fairly straightforward. Instead of going round the circle with each move, calculate how many laps around the perimeter this move will require, and then using modulo move only the remainder number of steps. The rest is a tedious list of if/else statements with changing direction at each of the 4 corners and keeping track of how many steps are left.\\n\\n```\\nclass Robot {\\n    private int width, height, curX, curY;\\n    private String dir;\\n    public Robot(int width, int height) {\\n        this.width = width;\\n        this.height = height;\\n        dir = \"East\";\\n        curX = 0;\\n        curY = 0;\\n    }\\n    \\n    public void move(int num) {\\n\\t\\t// calculate how many steps we need to move disregarding the number of loops around the perimeter\\n        int steps = num % (2*(height-1) + 2*(width-1));\\n\\t\\t// if we start from the origin and move N loops around ending up at the origin again, we need to change direction to South (since initial direction is East).\\n        if(steps == 0) {\\n            if(curX == 0 && curY == 0)\\n                dir = \"South\";\\n        }\\n        while(steps > 0) {\\n            if(dir.equals(\"East\")) {\\n\\t\\t\\t\\t// if we move forward final position will be in bounds (aka no need to turn)\\n                if(curX + steps < width) {\\n                    curX += steps;\\n                    steps = 0;\\n                }\\n\\t\\t\\t\\t// will need to turn and change direction\\n                else {\\n                    steps -= width - 1 - curX;\\n                    curX = width-1;\\n                    dir = \"North\";\\n                }\\n            }\\n            else if(dir.equals(\"North\")) {\\n                if(curY + steps < height) {\\n                    curY += steps;\\n                    steps = 0;\\n                }\\n                else {\\n                    steps -= height - 1 - curY;\\n                    curY = height-1;\\n                    dir = \"West\";\\n                }\\n            }\\n            else if(dir.equals(\"West\")) {\\n                if(curX - steps >= 0) {\\n                    curX -= steps;\\n                    steps = 0;\\n                }\\n                else {\\n                    steps -= curX;\\n                    curX = 0;\\n                    dir = \"South\";\\n                }\\n            }\\n            else {\\n                if(curY - steps >= 0) {\\n                    curY -= steps;\\n                    steps = 0;\\n                }\\n                else {\\n                    steps -= curY;\\n                    curY = 0;\\n                    dir = \"East\";\\n                }\\n            }\\n        }\\n    }\\n    \\n    public int[] getPos() {\\n        return new int[]{curX, curY};\\n    }\\n    \\n    public String getDir() {\\n        return this.dir;\\n    }\\n}\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot obj = new Robot(width, height);\\n * obj.move(num);\\n * int[] param_2 = obj.getPos();\\n * String param_3 = obj.getDir();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass Robot {\\n    private int width, height, curX, curY;\\n    private String dir;\\n    public Robot(int width, int height) {\\n        this.width = width;\\n        this.height = height;\\n        dir = \"East\";\\n        curX = 0;\\n        curY = 0;\\n    }\\n    \\n    public void move(int num) {\\n\\t\\t// calculate how many steps we need to move disregarding the number of loops around the perimeter\\n        int steps = num % (2*(height-1) + 2*(width-1));\\n\\t\\t// if we start from the origin and move N loops around ending up at the origin again, we need to change direction to South (since initial direction is East).\\n        if(steps == 0) {\\n            if(curX == 0 && curY == 0)\\n                dir = \"South\";\\n        }\\n        while(steps > 0) {\\n            if(dir.equals(\"East\")) {\\n\\t\\t\\t\\t// if we move forward final position will be in bounds (aka no need to turn)\\n                if(curX + steps < width) {\\n                    curX += steps;\\n                    steps = 0;\\n                }\\n\\t\\t\\t\\t// will need to turn and change direction\\n                else {\\n                    steps -= width - 1 - curX;\\n                    curX = width-1;\\n                    dir = \"North\";\\n                }\\n            }\\n            else if(dir.equals(\"North\")) {\\n                if(curY + steps < height) {\\n                    curY += steps;\\n                    steps = 0;\\n                }\\n                else {\\n                    steps -= height - 1 - curY;\\n                    curY = height-1;\\n                    dir = \"West\";\\n                }\\n            }\\n            else if(dir.equals(\"West\")) {\\n                if(curX - steps >= 0) {\\n                    curX -= steps;\\n                    steps = 0;\\n                }\\n                else {\\n                    steps -= curX;\\n                    curX = 0;\\n                    dir = \"South\";\\n                }\\n            }\\n            else {\\n                if(curY - steps >= 0) {\\n                    curY -= steps;\\n                    steps = 0;\\n                }\\n                else {\\n                    steps -= curY;\\n                    curY = 0;\\n                    dir = \"East\";\\n                }\\n            }\\n        }\\n    }\\n    \\n    public int[] getPos() {\\n        return new int[]{curX, curY};\\n    }\\n    \\n    public String getDir() {\\n        return this.dir;\\n    }\\n}\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot obj = new Robot(width, height);\\n * obj.move(num);\\n * int[] param_2 = obj.getPos();\\n * String param_3 = obj.getDir();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578397,
                "title": "java-easy-to-understand-preprocess",
                "content": "Java version of [lee215\\'s elegant solution](https://leetcode.com/problems/walking-robot-simulation-ii/discuss/1576036/Python-Easy-and-Concise-Solution)\\n```\\nclass Robot {\\n    // since the state is countable, and immutable, we can store the state in an array, and move in this array.\\n    // build the 1d array with the length of  2 * (width - 1 + height - 1), store the position and direction\\n    int[][] arr;\\n    // a mapping between integer representation of direction and the direction\\n    Map<Integer, String> map;\\n    int step;\\n    int width;\\n    int height;\\n    \\n    public Robot(int width, int height) {\\n        this.width = width;\\n        this.height = height;\\n        \\n        arr = new int[2 * (width + height - 2)][3];\\n        \\n        // initialize the arr\\n        int pos = 0;\\n        \\n        for (int i = 0; i < width; i++) {\\n            int[] temp = new int[3];\\n            temp[0] = i;\\n            temp[1] = 0;\\n            temp[2] = 0; \\n            arr[pos] = temp;\\n            pos++;\\n        }\\n        \\n        for (int i = 1; i < height; i++) {\\n            int[] temp = new int[3];\\n            temp[0] = width - 1;\\n            temp[1] = i;\\n            temp[2] = 1;\\n            arr[pos] = temp;\\n            pos++;\\n        }\\n        \\n        for (int i = width - 2; i >= 0; i--) {\\n            int[] temp = new int[3];\\n            temp[0] = i;\\n            temp[1] = height - 1;\\n            temp[2] = 2;\\n            arr[pos] = temp;\\n            pos++;\\n        }\\n        \\n        for (int i = height - 2; i > 0; i--) {\\n            int[] temp = new int[3];\\n            temp[0] = 0;\\n            temp[1] = i;\\n            temp[2] = 3;\\n            arr[pos] = temp;\\n            pos++;\\n        }\\n        arr[0] = new int[]{0, 0, 3};\\n        \\n        map = new HashMap<>();\\n        \\n        map.put(0, \"East\");\\n        map.put(1, \"North\");\\n        map.put(2, \"West\");\\n        map.put(3, \"South\");\\n        \\n        step = 0;\\n    }\\n    \\n    public void move(int num) {\\n        step += num;\\n        // System.out.println(step);\\n    }\\n    \\n    public int[] getPos() {\\n        int[] cur = arr[step % (2 *(width + height - 2))];\\n        int[] curPos = new int[2];\\n        curPos[0] = cur[0];\\n        curPos[1] = cur[1];\\n        return curPos;\\n    }\\n    \\n    public String getDir() {\\n        if (step == 0) {\\n            return map.get(0);\\n        }\\n        \\n        int[] cur = arr[step % (2 * (width + height - 2))];\\n        return map.get(cur[2]);\\n    }\\n}\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot obj = new Robot(width, height);\\n * obj.move(num);\\n * int[] param_2 = obj.getPos();\\n * String param_3 = obj.getDir();\\n */\\n ```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Robot {\\n    // since the state is countable, and immutable, we can store the state in an array, and move in this array.\\n    // build the 1d array with the length of  2 * (width - 1 + height - 1), store the position and direction\\n    int[][] arr;\\n    // a mapping between integer representation of direction and the direction\\n    Map<Integer, String> map;\\n    int step;\\n    int width;\\n    int height;\\n    \\n    public Robot(int width, int height) {\\n        this.width = width;\\n        this.height = height;\\n        \\n        arr = new int[2 * (width + height - 2)][3];\\n        \\n        // initialize the arr\\n        int pos = 0;\\n        \\n        for (int i = 0; i < width; i++) {\\n            int[] temp = new int[3];\\n            temp[0] = i;\\n            temp[1] = 0;\\n            temp[2] = 0; \\n            arr[pos] = temp;\\n            pos++;\\n        }\\n        \\n        for (int i = 1; i < height; i++) {\\n            int[] temp = new int[3];\\n            temp[0] = width - 1;\\n            temp[1] = i;\\n            temp[2] = 1;\\n            arr[pos] = temp;\\n            pos++;\\n        }\\n        \\n        for (int i = width - 2; i >= 0; i--) {\\n            int[] temp = new int[3];\\n            temp[0] = i;\\n            temp[1] = height - 1;\\n            temp[2] = 2;\\n            arr[pos] = temp;\\n            pos++;\\n        }\\n        \\n        for (int i = height - 2; i > 0; i--) {\\n            int[] temp = new int[3];\\n            temp[0] = 0;\\n            temp[1] = i;\\n            temp[2] = 3;\\n            arr[pos] = temp;\\n            pos++;\\n        }\\n        arr[0] = new int[]{0, 0, 3};\\n        \\n        map = new HashMap<>();\\n        \\n        map.put(0, \"East\");\\n        map.put(1, \"North\");\\n        map.put(2, \"West\");\\n        map.put(3, \"South\");\\n        \\n        step = 0;\\n    }\\n    \\n    public void move(int num) {\\n        step += num;\\n        // System.out.println(step);\\n    }\\n    \\n    public int[] getPos() {\\n        int[] cur = arr[step % (2 *(width + height - 2))];\\n        int[] curPos = new int[2];\\n        curPos[0] = cur[0];\\n        curPos[1] = cur[1];\\n        return curPos;\\n    }\\n    \\n    public String getDir() {\\n        if (step == 0) {\\n            return map.get(0);\\n        }\\n        \\n        int[] cur = arr[step % (2 * (width + height - 2))];\\n        return map.get(cur[2]);\\n    }\\n}\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot obj = new Robot(width, height);\\n * obj.move(num);\\n * int[] param_2 = obj.getPos();\\n * String param_3 = obj.getDir();\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1577841,
                "title": "swift-100-space-and-time",
                "content": "```\\nclass Robot {\\n\\n    var width: Int\\n    var height: Int\\n    \\n    var x: Int\\n    var y: Int\\n    var idx: (Int, Int)\\n    var direction: Int\\n    /* flagging first movment as accroding to the testcases, \\n\\tit is the only move that should have the direction already set beforehand. \\n\\tAll other moves should change direction at the beginning of the new move and not the end of the last move */\\n    var firstmove = true\\n    \\n    init(_ width: Int, _ height: Int) {\\n        self.width = width\\n        self.height = height\\n        x = 0\\n        y = 0 \\n        // start from south as moving starts with rotating the direction\\n        idx = (0,-1)\\n        direction = 3\\n    }\\n    func move(_ num: Int) {\\n        firstmove = false\\n\\t\\t\\n\\t\\t// only loop through last round\\n        let loop = (2 * (width - 1)) + (2 * (height - 1))\\n        let remaning =  num % loop\\n        if remaning == 0 {    \\n            return \\n        }\\n        \\n        //rotate if on corner\\n        if x == 0 || x == width-1 {\\n            if y == 0 || y == height-1 {\\n                switch direction {\\n                case 1:\\n                    direction = 2\\n                    idx = (-1,0)\\n                case 2:\\n                    direction = 3\\n                    idx = (0,-1)\\n                case 3:\\n                    direction = 0\\n                    idx = (1,0)\\n                default:\\n                    direction = 1\\n                    idx = (0,1)\\n                }\\n            }\\n        }\\n    \\n\\t\\tlet newXJump = x + (idx.0 * remaning)\\n\\t\\tlet newYJump = y + (idx.1 * remaning)\\n\\t\\t\\n\\t\\t// new poition out of bound\\n\\t\\tif newXJump < 0 || newXJump >= width || newYJump < 0 || newYJump >= height{\\n\\t\\t\\t\\n\\t\\t\\tvar jumpableX = 0\\n\\t\\t\\tvar jumpableY = 0\\n            var currentIdx = idx\\n\\t\\t\\tswitch direction {\\n\\t\\t\\t\\tcase 1:\\n                    jumpableY = height - y - 1\\n\\t\\t\\t\\tcase 2:\\n                    jumpableX = x\\n\\t\\t\\t\\tcase 3:\\n                    jumpableY = y\\n\\t\\t\\t\\tdefault:\\n                    jumpableX = (width - x) - 1\\n\\t\\t\\t}\\n\\t\\t\\tlet jump = max(jumpableX, jumpableY)\\n\\t\\t\\tx = x + (jumpableX * idx.0)\\n\\t\\t\\ty = y + (jumpableY * idx.1)\\n            //recall for remaning steps\\n            move(remaning-jump)\\n            return\\n\\t\\t}\\n\\n        //set new x, y\\n        x = newXJump\\n\\t\\ty = newYJump  \\n    }\\n   \\n    func getPos() -> [Int] {\\n        return [x,y]\\n    }\\n    \\n    func getDir() -> String {\\n        if firstmove {return \"East\"}\\n        switch direction {\\n            case 1:\\n                return \"North\"\\n            case 2:\\n                return \"West\"\\n            case 3:\\n                return \"South\"\\n             default:\\n                return \"East\"\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Robot {\\n\\n    var width: Int\\n    var height: Int\\n    \\n    var x: Int\\n    var y: Int\\n    var idx: (Int, Int)\\n    var direction: Int\\n    /* flagging first movment as accroding to the testcases, \\n\\tit is the only move that should have the direction already set beforehand. \\n\\tAll other moves should change direction at the beginning of the new move and not the end of the last move */\\n    var firstmove = true\\n    \\n    init(_ width: Int, _ height: Int) {\\n        self.width = width\\n        self.height = height\\n        x = 0\\n        y = 0 \\n        // start from south as moving starts with rotating the direction\\n        idx = (0,-1)\\n        direction = 3\\n    }\\n    func move(_ num: Int) {\\n        firstmove = false\\n\\t\\t\\n\\t\\t// only loop through last round\\n        let loop = (2 * (width - 1)) + (2 * (height - 1))\\n        let remaning =  num % loop\\n        if remaning == 0 {    \\n            return \\n        }\\n        \\n        //rotate if on corner\\n        if x == 0 || x == width-1 {\\n            if y == 0 || y == height-1 {\\n                switch direction {\\n                case 1:\\n                    direction = 2\\n                    idx = (-1,0)\\n                case 2:\\n                    direction = 3\\n                    idx = (0,-1)\\n                case 3:\\n                    direction = 0\\n                    idx = (1,0)\\n                default:\\n                    direction = 1\\n                    idx = (0,1)\\n                }\\n            }\\n        }\\n    \\n\\t\\tlet newXJump = x + (idx.0 * remaning)\\n\\t\\tlet newYJump = y + (idx.1 * remaning)\\n\\t\\t\\n\\t\\t// new poition out of bound\\n\\t\\tif newXJump < 0 || newXJump >= width || newYJump < 0 || newYJump >= height{\\n\\t\\t\\t\\n\\t\\t\\tvar jumpableX = 0\\n\\t\\t\\tvar jumpableY = 0\\n            var currentIdx = idx\\n\\t\\t\\tswitch direction {\\n\\t\\t\\t\\tcase 1:\\n                    jumpableY = height - y - 1\\n\\t\\t\\t\\tcase 2:\\n                    jumpableX = x\\n\\t\\t\\t\\tcase 3:\\n                    jumpableY = y\\n\\t\\t\\t\\tdefault:\\n                    jumpableX = (width - x) - 1\\n\\t\\t\\t}\\n\\t\\t\\tlet jump = max(jumpableX, jumpableY)\\n\\t\\t\\tx = x + (jumpableX * idx.0)\\n\\t\\t\\ty = y + (jumpableY * idx.1)\\n            //recall for remaning steps\\n            move(remaning-jump)\\n            return\\n\\t\\t}\\n\\n        //set new x, y\\n        x = newXJump\\n\\t\\ty = newYJump  \\n    }\\n   \\n    func getPos() -> [Int] {\\n        return [x,y]\\n    }\\n    \\n    func getDir() -> String {\\n        if firstmove {return \"East\"}\\n        switch direction {\\n            case 1:\\n                return \"North\"\\n            case 2:\\n                return \"West\"\\n            case 3:\\n                return \"South\"\\n             default:\\n                return \"East\"\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577641,
                "title": "c-100-100",
                "content": "```\\npublic class Robot {\\n    private int width;\\n    private int height;\\n    private int x;\\n    private int y;\\n    private bool moved;\\n    public Robot(int width, int height) {\\n        this.width = width;\\n        this.height = height;\\n        x = 0;\\n        y = 0;\\n        moved = false;\\n    }\\n    \\n    public void Move(int num) {\\n        if (num == 0) return;\\n        if (num > 0) moved = true;\\n        num %= ((width + height - 2) * 2);\\n        MoveOnTheBoard(num);\\n    }\\n    \\n    public int[] GetPos() {\\n        return new[] { x, y };\\n    }\\n    \\n    public string GetDir() {\\n        if (moved)\\n        {\\n            if (x < width - 1 && y == height - 1) return \"West\";\\n            if (x == 0 && y < height - 1) return \"South\";\\n            if (0 < x && y == 0) return \"East\";\\n            if (x == width - 1 && 0 < y) return \"North\";\\n        }\\n        return \"East\";\\n    }\\n    private void MoveOnTheBoard(int num)\\n    {\\n        if (num == 0) return;\\n        var dir = GetDir(GetDir());\\n        while (num > 0)\\n        {\\n            switch (dir)\\n            {\\n                case 0:\\n                    var move0 = Math.Min(num, height - 1 - y);\\n                    if (move0 == 0)\\n                    {\\n                        dir = (dir + 1) % 4;\\n                    }\\n                    else\\n                    {\\n                        y += move0;\\n                        num -= move0;\\n                    }\\n                    break;\\n                case 1:\\n                    var move1 = Math.Min(num, x);\\n                    if (move1 == 0)\\n                    {\\n                        dir = (dir + 1) % 4;\\n                    }\\n                    else\\n                    {\\n                        x -= move1;\\n                        num -= move1;\\n                    }\\n                    break;\\n                case 2:\\n                    var move2 = Math.Min(num, y);\\n                    if (move2 == 0)\\n                    {\\n                        dir = (dir + 1) % 4;\\n                    }\\n                    else\\n                    {\\n                        y -= move2;\\n                        num -= move2;\\n                    }\\n                    break;\\n                case 3:\\n                    var move3 = Math.Min(num, width - 1 - x);\\n                    if (move3 == 0)\\n                    {\\n                        dir = (dir + 1) % 4;\\n                    }\\n                    else\\n                    {\\n                        x += move3;\\n                        num -= move3;\\n                    }\\n                    break;\\n            }\\n        }\\n    }\\n    private int GetDir(string dir)\\n    {\\n        switch (dir)\\n        {\\n            case \"North\":\\n                return 0;\\n            case \"West\":\\n                return 1;\\n            case \"South\":\\n                return 2;\\n            case \"East\":\\n                return 3;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Robot {\\n    private int width;\\n    private int height;\\n    private int x;\\n    private int y;\\n    private bool moved;\\n    public Robot(int width, int height) {\\n        this.width = width;\\n        this.height = height;\\n        x = 0;\\n        y = 0;\\n        moved = false;\\n    }\\n    \\n    public void Move(int num) {\\n        if (num == 0) return;\\n        if (num > 0) moved = true;\\n        num %= ((width + height - 2) * 2);\\n        MoveOnTheBoard(num);\\n    }\\n    \\n    public int[] GetPos() {\\n        return new[] { x, y };\\n    }\\n    \\n    public string GetDir() {\\n        if (moved)\\n        {\\n            if (x < width - 1 && y == height - 1) return \"West\";\\n            if (x == 0 && y < height - 1) return \"South\";\\n            if (0 < x && y == 0) return \"East\";\\n            if (x == width - 1 && 0 < y) return \"North\";\\n        }\\n        return \"East\";\\n    }\\n    private void MoveOnTheBoard(int num)\\n    {\\n        if (num == 0) return;\\n        var dir = GetDir(GetDir());\\n        while (num > 0)\\n        {\\n            switch (dir)\\n            {\\n                case 0:\\n                    var move0 = Math.Min(num, height - 1 - y);\\n                    if (move0 == 0)\\n                    {\\n                        dir = (dir + 1) % 4;\\n                    }\\n                    else\\n                    {\\n                        y += move0;\\n                        num -= move0;\\n                    }\\n                    break;\\n                case 1:\\n                    var move1 = Math.Min(num, x);\\n                    if (move1 == 0)\\n                    {\\n                        dir = (dir + 1) % 4;\\n                    }\\n                    else\\n                    {\\n                        x -= move1;\\n                        num -= move1;\\n                    }\\n                    break;\\n                case 2:\\n                    var move2 = Math.Min(num, y);\\n                    if (move2 == 0)\\n                    {\\n                        dir = (dir + 1) % 4;\\n                    }\\n                    else\\n                    {\\n                        y -= move2;\\n                        num -= move2;\\n                    }\\n                    break;\\n                case 3:\\n                    var move3 = Math.Min(num, width - 1 - x);\\n                    if (move3 == 0)\\n                    {\\n                        dir = (dir + 1) % 4;\\n                    }\\n                    else\\n                    {\\n                        x += move3;\\n                        num -= move3;\\n                    }\\n                    break;\\n            }\\n        }\\n    }\\n    private int GetDir(string dir)\\n    {\\n        switch (dir)\\n        {\\n            case \"North\":\\n                return 0;\\n            case \"West\":\\n                return 1;\\n            case \"South\":\\n                return 2;\\n            case \"East\":\\n                return 3;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577584,
                "title": "java-easy-to-understand-with-separate-functions-explanation",
                "content": "```\\n// Time O:(1) \\n// Space: O:(4) == O:(1) (Worse case i travel circumfrence - 1 steps, so i will have 4 recursive function calls at most\\nclass Robot {\\n    int[] position;\\n    String facing;\\n    int maxWidth;\\n    int maxHeight;\\n    int oneCycle;\\n    public Robot(int width, int height) {\\n        position = new int[]{0,0};\\n        facing = \"East\";\\n        maxWidth = width - 1;\\n        maxHeight = height - 1;\\n\\t\\t// oneCycle is the number of steps needed for 1 circumfrence of the grid\\n        oneCycle = maxWidth * 2 + maxHeight * 2;\\n    }\\n    \\n    public void move(int num) {\\n\\t\\t// If this step is not done you will hit TLE\\n        num %= oneCycle; \\n\\t\\t\\n\\t\\t// This check is for the hidden test case\\n\\t\\t// where only at the starting position, if you travel the \\n\\t\\t// circumfrence of the grid, you will end up facing south\\n        if(num == 0 && position[0] == 0 && position[1] == 0) {\\n            facing = \"South\";\\n        }\\n        if(facing == \"East\") {\\n            moveEast(num);\\n        } else if(facing == \"North\") {\\n            moveNorth(num);\\n        } else if(facing == \"West\") {\\n            moveWest(num);\\n        } else {\\n            moveSouth(num);\\n        }\\n        \\n    }\\n    \\n    public int[] getPos() {\\n        return position;\\n    }\\n    \\n    public String getDir() {\\n        return facing;\\n    }\\n    // If im travelling east and i have reached the end with extra steps i must go north\\n    public void moveEast(int steps) {\\n        facing = \"East\";\\n\\t\\t// If i can accomodate all the steps i can stop.\\n        if(steps + position[0] <= maxWidth) {\\n            position[0] += steps;\\n            return;\\n        } else {\\n            steps -= maxWidth - position[0];\\n            position[0] = maxWidth;\\n        }\\n        if(steps > 0) moveNorth(steps);\\n    }\\n    // If im travelling north and i have reached the end with extra steps, i must go west\\n    public void moveNorth(int steps) {\\n        facing = \"North\";\\n        if(steps + position[1] <= maxHeight) {\\n            position[1] += steps;\\n            return;\\n        } else {\\n            steps -= maxHeight - position[1];\\n            position[1] = maxHeight;\\n        }\\n        if(steps > 0) moveWest(steps);\\n    }\\n    // If im travelling west and i have reached the end with extra steps, i must go south\\n    public void moveWest(int steps) {\\n        facing = \"West\";\\n        if(position[0] - steps >= 0) {\\n            position[0] -= steps;\\n            return;\\n        } else {\\n            steps -= position[0];\\n            position[0] = 0;\\n        }\\n        if(steps > 0) moveSouth(steps);\\n    }\\n    // If im travelling south and i have reached the end with extra steps, i must go east\\n    public void moveSouth(int steps) {\\n        facing = \"South\";\\n        if(position[1] - steps >= 0) {\\n            position[1] -= steps;\\n            return;\\n        } else {\\n            steps -= position[1];\\n            position[1] = 0;\\n        }\\n        if(steps > 0) moveEast(steps);\\n    }\\n}",
                "solutionTags": [],
                "code": "```\\n// Time O:(1) \\n// Space: O:(4) == O:(1) (Worse case i travel circumfrence - 1 steps, so i will have 4 recursive function calls at most\\nclass Robot {\\n    int[] position;\\n    String facing;\\n    int maxWidth;\\n    int maxHeight;\\n    int oneCycle;\\n    public Robot(int width, int height) {\\n        position = new int[]{0,0};\\n        facing = \"East\";\\n        maxWidth = width - 1;\\n        maxHeight = height - 1;\\n\\t\\t// oneCycle is the number of steps needed for 1 circumfrence of the grid\\n        oneCycle = maxWidth * 2 + maxHeight * 2;\\n    }\\n    \\n    public void move(int num) {\\n\\t\\t// If this step is not done you will hit TLE\\n        num %= oneCycle; \\n\\t\\t\\n\\t\\t// This check is for the hidden test case\\n\\t\\t// where only at the starting position, if you travel the \\n\\t\\t// circumfrence of the grid, you will end up facing south\\n        if(num == 0 && position[0] == 0 && position[1] == 0) {\\n            facing = \"South\";\\n        }\\n        if(facing == \"East\") {\\n            moveEast(num);\\n        } else if(facing == \"North\") {\\n            moveNorth(num);\\n        } else if(facing == \"West\") {\\n            moveWest(num);\\n        } else {\\n            moveSouth(num);\\n        }\\n        \\n    }\\n    \\n    public int[] getPos() {\\n        return position;\\n    }\\n    \\n    public String getDir() {\\n        return facing;\\n    }\\n    // If im travelling east and i have reached the end with extra steps i must go north\\n    public void moveEast(int steps) {\\n        facing = \"East\";\\n\\t\\t// If i can accomodate all the steps i can stop.\\n        if(steps + position[0] <= maxWidth) {\\n            position[0] += steps;\\n            return;\\n        } else {\\n            steps -= maxWidth - position[0];\\n            position[0] = maxWidth;\\n        }\\n        if(steps > 0) moveNorth(steps);\\n    }\\n    // If im travelling north and i have reached the end with extra steps, i must go west\\n    public void moveNorth(int steps) {\\n        facing = \"North\";\\n        if(steps + position[1] <= maxHeight) {\\n            position[1] += steps;\\n            return;\\n        } else {\\n            steps -= maxHeight - position[1];\\n            position[1] = maxHeight;\\n        }\\n        if(steps > 0) moveWest(steps);\\n    }\\n    // If im travelling west and i have reached the end with extra steps, i must go south\\n    public void moveWest(int steps) {\\n        facing = \"West\";\\n        if(position[0] - steps >= 0) {\\n            position[0] -= steps;\\n            return;\\n        } else {\\n            steps -= position[0];\\n            position[0] = 0;\\n        }\\n        if(steps > 0) moveSouth(steps);\\n    }\\n    // If im travelling south and i have reached the end with extra steps, i must go east\\n    public void moveSouth(int steps) {\\n        facing = \"South\";\\n        if(position[1] - steps >= 0) {\\n            position[1] -= steps;\\n            return;\\n        } else {\\n            steps -= position[1];\\n            position[1] = 0;\\n        }\\n        if(steps > 0) moveEast(steps);\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1577581,
                "title": "o-1-only-using-conditions-c",
                "content": "```\\n int w,h;\\n    vector<int> pos={0,0};\\n    vector<int> side;\\n    int cur=0;\\n    string dir=\"East\";\\n    void updatepos(){\\n        \\n        if(cur<=side[0]){\\n            pos={cur,0};\\n            \\n            dir=cur ? \"East\" : \"South\";\\n        }\\n        else if(cur<=side[1]){\\n            pos={w-1,cur - side[0]};\\n            \\n            dir=\"North\";\\n        }\\n        else if(cur<=side[2]){\\n            pos={side[2] - cur,h-1};\\n            dir=\"West\";\\n        }\\n        else{\\n            pos={0,side[3] - cur};\\n            dir=\"South\";\\n        }\\n    }\\n    \\n    Robot(int we, int he) {\\n        w=we;\\n        h=he;\\n        side={w-1,w-1 + h-1,w-1+h-1+w-1,w-1+h-1+w-1+h-1};\\n    }\\n    \\n    void move(int num) {\\n        \\n        cur=(cur + num)%side[3];\\n        updatepos();\\n    }\\n    \\n    vector<int> getPos() {\\n        \\n        return pos;\\n    }\\n    \\n    string getDir() {\\n        \\n        return dir;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n int w,h;\\n    vector<int> pos={0,0};\\n    vector<int> side;\\n    int cur=0;\\n    string dir=\"East\";\\n    void updatepos(){\\n        \\n        if(cur<=side[0]){\\n            pos={cur,0};\\n            \\n            dir=cur ? \"East\" : \"South\";\\n        }\\n        else if(cur<=side[1]){\\n            pos={w-1,cur - side[0]};\\n            \\n            dir=\"North\";\\n        }\\n        else if(cur<=side[2]){\\n            pos={side[2] - cur,h-1};\\n            dir=\"West\";\\n        }\\n        else{\\n            pos={0,side[3] - cur};\\n            dir=\"South\";\\n        }\\n    }\\n    \\n    Robot(int we, int he) {\\n        w=we;\\n        h=he;\\n        side={w-1,w-1 + h-1,w-1+h-1+w-1,w-1+h-1+w-1+h-1};\\n    }\\n    \\n    void move(int num) {\\n        \\n        cur=(cur + num)%side[3];\\n        updatepos();\\n    }\\n    \\n    vector<int> getPos() {\\n        \\n        return pos;\\n    }\\n    \\n    string getDir() {\\n        \\n        return dir;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1577320,
                "title": "easy-clean-and-efficient-java-solution",
                "content": "\\nclass Robot {\\n    \\n    class Cell{\\n        \\n        int x;\\n        int y;\\n        \\n        Cell(int  x, int y){\\n            \\n            this.x= x;\\n            this.y= y;\\n        }\\n        \\n    }\\n    \\n    Map<String,String> changeDirectionMap;\\n    \\n    int [][] board;\\n    \\n    Cell currPosition;\\n    \\n    String currentDirection;\\n    \\n    boolean isStarting = true;\\n    \\n    public Robot(int width, int height) {\\n        \\n        board = new int[width][height];\\n        currPosition = new Cell(0,0);\\n        \\n        currentDirection = \"East\";\\n \\n        changeDirectionMap = new HashMap<>();\\n        \\n        changeDirectionMap.put(\"East\",\"North\");\\n        changeDirectionMap.put(\"West\",\"South\");\\n        changeDirectionMap.put(\"North\",\"West\");\\n        changeDirectionMap.put(\"South\",\"East\");\\n        \\n    }\\n       \\n    \\n    public void move(int num) {\\n        \\n        int circle = (board.length-1)*2 + (board[0].length-1)*2;\\n        \\n        //Change the direction if it is the first move and it completes the entire circle (Perimeter of the board)\\n        if(num/circle != 0 && isStarting){\\n\\n            currentDirection = \"South\";\\n            \\n        }\\n        \\n        isStarting = false;\\n        \\n        int moves = (num%circle);\\n        \\n        \\n        \\n        while(moves != 0){\\n            \\n            if(currentDirection.equals(\"East\")){\\n                \\n                int newPosition = Math.min(currPosition.x + moves, board.length-1);\\n                \\n                moves -= newPosition - currPosition.x;\\n                \\n                currPosition.x = newPosition; \\n                \\n                \\n            }\\n            \\n            else if(currentDirection.equals(\"West\")){\\n                \\n                int newPosition = Math.max(currPosition.x - moves, 0);\\n                \\n                moves -= currPosition.x - newPosition;                \\n                                \\n                currPosition.x = newPosition; \\n                \\n                \\n            }\\n            \\n             else if(currentDirection.equals(\"North\")){\\n                \\n                int newPosition = Math.min(currPosition.y + moves, board[0].length-1);\\n                \\n                moves -= newPosition - currPosition.y;\\n                \\n                currPosition.y = newPosition; \\n                \\n                \\n            }\\n            \\n            else if(currentDirection.equals(\"South\")){\\n                \\n                int newPosition = Math.max(currPosition.y - moves, 0);\\n                \\n                moves -= currPosition.y - newPosition;\\n                \\n                currPosition.y = newPosition; \\n                \\n                \\n            }\\n                   \\n            \\n            if(moves != 0){\\n                \\n                currentDirection = changeDirectionMap.get(currentDirection);\\n            }\\n        }\\n        \\n        \\n    }\\n    \\n    public int[] getPos() {\\n        \\n        return new int[]{currPosition.x,currPosition.y};\\n        \\n    }\\n    \\n    public String getDir() {\\n        return currentDirection;\\n    }\\n}\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot obj = new Robot(width, height);\\n * obj.move(num);\\n * int[] param_2 = obj.getPos();\\n * String param_3 = obj.getDir();\\n */",
                "solutionTags": [],
                "code": "\\nclass Robot {\\n    \\n    class Cell{\\n        \\n        int x;\\n        int y;\\n        \\n        Cell(int  x, int y){\\n            \\n            this.x= x;\\n            this.y= y;\\n        }\\n        \\n    }\\n    \\n    Map<String,String> changeDirectionMap;\\n    \\n    int [][] board;\\n    \\n    Cell currPosition;\\n    \\n    String currentDirection;\\n    \\n    boolean isStarting = true;\\n    \\n    public Robot(int width, int height) {\\n        \\n        board = new int[width][height];\\n        currPosition = new Cell(0,0);\\n        \\n        currentDirection = \"East\";\\n \\n        changeDirectionMap = new HashMap<>();\\n        \\n        changeDirectionMap.put(\"East\",\"North\");\\n        changeDirectionMap.put(\"West\",\"South\");\\n        changeDirectionMap.put(\"North\",\"West\");\\n        changeDirectionMap.put(\"South\",\"East\");\\n        \\n    }\\n       \\n    \\n    public void move(int num) {\\n        \\n        int circle = (board.length-1)*2 + (board[0].length-1)*2;\\n        \\n        //Change the direction if it is the first move and it completes the entire circle (Perimeter of the board)\\n        if(num/circle != 0 && isStarting){\\n\\n            currentDirection = \"South\";\\n            \\n        }\\n        \\n        isStarting = false;\\n        \\n        int moves = (num%circle);\\n        \\n        \\n        \\n        while(moves != 0){\\n            \\n            if(currentDirection.equals(\"East\")){\\n                \\n                int newPosition = Math.min(currPosition.x + moves, board.length-1);\\n                \\n                moves -= newPosition - currPosition.x;\\n                \\n                currPosition.x = newPosition; \\n                \\n                \\n            }\\n            \\n            else if(currentDirection.equals(\"West\")){\\n                \\n                int newPosition = Math.max(currPosition.x - moves, 0);\\n                \\n                moves -= currPosition.x - newPosition;                \\n                                \\n                currPosition.x = newPosition; \\n                \\n                \\n            }\\n            \\n             else if(currentDirection.equals(\"North\")){\\n                \\n                int newPosition = Math.min(currPosition.y + moves, board[0].length-1);\\n                \\n                moves -= newPosition - currPosition.y;\\n                \\n                currPosition.y = newPosition; \\n                \\n                \\n            }\\n            \\n            else if(currentDirection.equals(\"South\")){\\n                \\n                int newPosition = Math.max(currPosition.y - moves, 0);\\n                \\n                moves -= currPosition.y - newPosition;\\n                \\n                currPosition.y = newPosition; \\n                \\n                \\n            }\\n                   \\n            \\n            if(moves != 0){\\n                \\n                currentDirection = changeDirectionMap.get(currentDirection);\\n            }\\n        }\\n        \\n        \\n    }\\n    \\n    public int[] getPos() {\\n        \\n        return new int[]{currPosition.x,currPosition.y};\\n        \\n    }\\n    \\n    public String getDir() {\\n        return currentDirection;\\n    }\\n}\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot obj = new Robot(width, height);\\n * obj.move(num);\\n * int[] param_2 = obj.getPos();\\n * String param_3 = obj.getDir();\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1577255,
                "title": "java-solution-brute-forse-all-edge-cases-covered-easy-to-understand",
                "content": "\\n\\n```class Robot {\\n\\n    int w; // width\\n    int h; // height    \\n    int dir = 0; // initially direction will be east\\n    int i=0; // i ==x\\n    int j=0; // j == y\\n    \\n    \\n    public Robot(int width, int height) {\\n        // assigining height and width\\n        w = width-1;\\n        h = height-1;    \\n    }\\n    \\n    \\n    public void move(int num) {\\n        \\n        int di = dir;\\n        \\n        int a= 2*w + 2*h; // calculating perimeter of grid;\\n      \\n        \\n                  \\n         num %= a;\\n         if (num ==0){\\n                num =a;\\n            }\\n            \\n        \\n        \\n        if (di ==0) move0(num);           \\n        if (di ==1) move1(num);\\n        if (di ==2) move2(num);\\n        if (di ==3) move3(num);\\n\\n        \\n    }\\n    \\n    public int[] getPos() {\\n        int ans[] =  {j,i};\\n        \\n        return ans;\\n        \\n    }\\n    \\n    public String getDir() {\\n         if (dir ==0) return \"East\";  \\n        if (dir ==1) return \"North\";\\n        if (dir ==2) return \"West\";\\n        if (dir ==3) return \"South\";\\n        return \"East\";\\n        \\n    }\\n    \\n    // Moving toward East\\n private void move0(int n){\\n        \\n        if (n+j <= w) {\\n            j= n+j;\\n       \\n        } else {\\n            n =n-( w-j);\\n            j = w;\\n            dir=1;\\n            move1(n);\\n        }\\n        \\n    }\\n    \\n    // Moving toward North\\n   private void move1(int n){\\n         \\n          if (n+i <= h) {\\n              \\n            i= n+i;\\n        \\n        } else {\\n            n = n - (h-i);\\n            i = h;\\n            dir=2;\\n            move2(n);\\n        }\\n        \\n    }\\n    \\n    // Moving toward West \\n private void move2(int n){\\n          if (j-n >= 0) {\\n            j= j-n;\\n        \\n        } else {\\n            n = n-j;\\n            j = 0;\\n            dir=3;\\n            move3(n);\\n        }\\n        \\n    }\\n    \\n    // Moving toward South\\n private void move3(int n){        \\n           if (i-n >= 0) {\\n            i= i-n;\\n        } else {\\n            n = n-i;\\n            i = 0;\\n            dir=0;\\n            move0(n);\\n        }\\n        \\n    }\\n}\\n //0; i,j++ ; 1; i++,j; 2;i,j--; 3;i--,j\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```class Robot {\\n\\n    int w; // width\\n    int h; // height    \\n    int dir = 0; // initially direction will be east\\n    int i=0; // i ==x\\n    int j=0; // j == y\\n    \\n    \\n    public Robot(int width, int height) {\\n        // assigining height and width\\n        w = width-1;\\n        h = height-1;    \\n    }\\n    \\n    \\n    public void move(int num) {\\n        \\n        int di = dir;\\n        \\n        int a= 2*w + 2*h; // calculating perimeter of grid;\\n      \\n        \\n                  \\n         num %= a;\\n         if (num ==0){\\n                num =a;\\n            }\\n            \\n        \\n        \\n        if (di ==0) move0(num);           \\n        if (di ==1) move1(num);\\n        if (di ==2) move2(num);\\n        if (di ==3) move3(num);\\n\\n        \\n    }\\n    \\n    public int[] getPos() {\\n        int ans[] =  {j,i};\\n        \\n        return ans;\\n        \\n    }\\n    \\n    public String getDir() {\\n         if (dir ==0) return \"East\";  \\n        if (dir ==1) return \"North\";\\n        if (dir ==2) return \"West\";\\n        if (dir ==3) return \"South\";\\n        return \"East\";\\n        \\n    }\\n    \\n    // Moving toward East\\n private void move0(int n){\\n        \\n        if (n+j <= w) {\\n            j= n+j;\\n       \\n        } else {\\n            n =n-( w-j);\\n            j = w;\\n            dir=1;\\n            move1(n);\\n        }\\n        \\n    }\\n    \\n    // Moving toward North\\n   private void move1(int n){\\n         \\n          if (n+i <= h) {\\n              \\n            i= n+i;\\n        \\n        } else {\\n            n = n - (h-i);\\n            i = h;\\n            dir=2;\\n            move2(n);\\n        }\\n        \\n    }\\n    \\n    // Moving toward West \\n private void move2(int n){\\n          if (j-n >= 0) {\\n            j= j-n;\\n        \\n        } else {\\n            n = n-j;\\n            j = 0;\\n            dir=3;\\n            move3(n);\\n        }\\n        \\n    }\\n    \\n    // Moving toward South\\n private void move3(int n){        \\n           if (i-n >= 0) {\\n            i= i-n;\\n        } else {\\n            n = n-i;\\n            i = 0;\\n            dir=0;\\n            move0(n);\\n        }\\n        \\n    }\\n}\\n //0; i,j++ ; 1; i++,j; 2;i,j--; 3;i--,j\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577235,
                "title": "the-only-point-deserves-your-notice",
                "content": "```\\nnum %= round;\\n\\t\\tif (num == 0)\\n\\t\\t\\tnum = round;\\n```",
                "solutionTags": [],
                "code": "```\\nnum %= round;\\n\\t\\tif (num == 0)\\n\\t\\t\\tnum = round;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1577223,
                "title": "java-solution-o-1-for-every-operation",
                "content": "Easy to understand\\n````\\nclass pair {\\n    int x, y;\\n    String dir;\\n    pair(int x, int y, String dir) {\\n        this.x = x;\\n        this.y = y;\\n        this.dir = dir;\\n    }\\n}\\nclass Robot {\\n    ArrayList < pair > list = new ArrayList < > ();\\n    int perimeter = 0, curr = 0;\\n    boolean moved = false;\\n    public Robot(int width, int height) {\\n\\n        perimeter = (width + height - 2) * 2;\\n\\n        list.add(new pair(0, 0, \"South\"));\\n\\n        for (int i = 1; i < width; i++) {\\n            pair p = new pair(i, 0, \"East\");\\n            list.add(p);\\n\\n        }\\n\\n        for (int j = 1; j < height; j++) {\\n            pair p = new pair(width - 1, j, \"North\");\\n            list.add(p);\\n\\n        }\\n\\n        for (int i = width - 2; i >= 0; i--) {\\n            pair p = new pair(i, height - 1, \"West\");\\n            list.add(p);\\n\\n        }\\n\\n        for (int j = height - 2; j > 0; j--) {\\n            pair p = new pair(0, j, \"South\");\\n            list.add(p);\\n\\n        }\\n\\n    }\\n\\n    public void move(int num) {\\n        moved = true;\\n        curr = (curr + num) % perimeter;\\n\\n    }\\n\\n    public int[] getPos() {\\n        int arr[] = new int[2];\\n        arr[0] = list.get(curr).x;\\n        arr[1] = list.get(curr).y;\\n        return arr;\\n\\n\\n    }\\n\\n    public String getDir() {\\n        return moved ? list.get(curr).dir : \"East\";\\n\\n    }\\n}\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot obj = new Robot(width, height);\\n * obj.move(num);\\n * int[] param_2 = obj.getPos();\\n * String param_3 = obj.getDir();\\n */\\n",
                "solutionTags": [],
                "code": "Easy to understand\\n````\\nclass pair {\\n    int x, y;\\n    String dir;\\n    pair(int x, int y, String dir) {\\n        this.x = x;\\n        this.y = y;\\n        this.dir = dir;\\n    }\\n}\\nclass Robot {\\n    ArrayList < pair > list = new ArrayList < > ();\\n    int perimeter = 0, curr = 0;\\n    boolean moved = false;\\n    public Robot(int width, int height) {\\n\\n        perimeter = (width + height - 2) * 2;\\n\\n        list.add(new pair(0, 0, \"South\"));\\n\\n        for (int i = 1; i < width; i++) {\\n            pair p = new pair(i, 0, \"East\");\\n            list.add(p);\\n\\n        }\\n\\n        for (int j = 1; j < height; j++) {\\n            pair p = new pair(width - 1, j, \"North\");\\n            list.add(p);\\n\\n        }\\n\\n        for (int i = width - 2; i >= 0; i--) {\\n            pair p = new pair(i, height - 1, \"West\");\\n            list.add(p);\\n\\n        }\\n\\n        for (int j = height - 2; j > 0; j--) {\\n            pair p = new pair(0, j, \"South\");\\n            list.add(p);\\n\\n        }\\n\\n    }\\n\\n    public void move(int num) {\\n        moved = true;\\n        curr = (curr + num) % perimeter;\\n\\n    }\\n\\n    public int[] getPos() {\\n        int arr[] = new int[2];\\n        arr[0] = list.get(curr).x;\\n        arr[1] = list.get(curr).y;\\n        return arr;\\n\\n\\n    }\\n\\n    public String getDir() {\\n        return moved ? list.get(curr).dir : \"East\";\\n\\n    }\\n}\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot obj = new Robot(width, height);\\n * obj.move(num);\\n * int[] param_2 = obj.getPos();\\n * String param_3 = obj.getDir();\\n */\\n",
                "codeTag": "Java"
            },
            {
                "id": 1576962,
                "title": "using-an-array-as-utility-could-make-the-whole-solution-much-much-much-eaiser",
                "content": "```scala\\n\\n\\nclass Robot(_width: Int, _height: Int) {\\n  val w = _width\\n  val h = _height\\n\\n  var never = true\\n  val total = (w + h) * 2 - 4\\n  case class D(dir: String, x: Int, y: Int)\\n\\n  val arr = Array.ofDim[D](total)\\n  var i   = 0\\n  (0 until w).foreach(x => {\\n    arr(i) = D(\"East\", x, 0)\\n    i += 1\\n  })\\n  (0 until h - 1).foreach(x => {\\n    arr(i) = D(\"North\", w - 1, x + 1)\\n    i += 1\\n  })\\n  (0 until w - 1).foreach(x => {\\n    arr(i) = D(\"West\", w - x - 2, h - 1)\\n    i += 1\\n  })\\n  (0 until h - 2).foreach(x => {\\n    arr(i) = D(\"South\", 0, h - 2 - x)\\n    i += 1\\n  })\\n\\n  var idx = 0\\n  def move(num: Int) {\\n    never = false\\n    var step   = num % total\\n    val remain = total - idx - 1\\n    if (remain >= step) {\\n      idx += step\\n    } else {\\n      idx = step - remain - 1\\n    }\\n\\n  }\\n\\n  def getPos(): Array[Int] = {\\n\\n    Array(arr(idx).x, arr(idx).y)\\n  }\\n\\n  def getDir(): String = {\\n    if (idx == 0 && !never) \"South\" else arr(idx).dir\\n  }\\n\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```scala\\n\\n\\nclass Robot(_width: Int, _height: Int) {\\n  val w = _width\\n  val h = _height\\n\\n  var never = true\\n  val total = (w + h) * 2 - 4\\n  case class D(dir: String, x: Int, y: Int)\\n\\n  val arr = Array.ofDim[D](total)\\n  var i   = 0\\n  (0 until w).foreach(x => {\\n    arr(i) = D(\"East\", x, 0)\\n    i += 1\\n  })\\n  (0 until h - 1).foreach(x => {\\n    arr(i) = D(\"North\", w - 1, x + 1)\\n    i += 1\\n  })\\n  (0 until w - 1).foreach(x => {\\n    arr(i) = D(\"West\", w - x - 2, h - 1)\\n    i += 1\\n  })\\n  (0 until h - 2).foreach(x => {\\n    arr(i) = D(\"South\", 0, h - 2 - x)\\n    i += 1\\n  })\\n\\n  var idx = 0\\n  def move(num: Int) {\\n    never = false\\n    var step   = num % total\\n    val remain = total - idx - 1\\n    if (remain >= step) {\\n      idx += step\\n    } else {\\n      idx = step - remain - 1\\n    }\\n\\n  }\\n\\n  def getPos(): Array[Int] = {\\n\\n    Array(arr(idx).x, arr(idx).y)\\n  }\\n\\n  def getDir(): String = {\\n    if (idx == 0 && !never) \"South\" else arr(idx).dir\\n  }\\n\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576865,
                "title": "can-anyone-help-me-to-find-the-mistake",
                "content": "I know my move function is lengthy but logic is simple please help me to identify the error\\n```\\nclass Robot {\\npublic:\\n    int currX,currY;\\n    string dir;\\n    \\n    int w,h;\\n    \\n    Robot(int width, int height) {\\n        currX = 0;\\n        currY = 0;\\n        dir = \"East\";\\n        w = width;\\n        h = height;\\n        \\n    }\\n    \\n    void move(int num) {\\n        \\n        int para = 2*(w+h-2)+1;\\n        num = num%para;\\n        \\n        if(dir == \"East\"){\\n            if(num<= w-1-currX){\\n                currX = currX+num;\\n            }else{\\n                dir = \"North\";\\n                num -= w-1-currX;\\n                currX = w-1;\\n                \\n                if(num<=h-1){\\n                    currY = num;\\n                }else{\\n                    dir = \"West\";\\n                    currY = h-1;\\n                    num -= h-1;\\n                    if(num<= w-1){\\n                        currX = w-1-num;\\n                    }else{\\n                        dir = \"South\";\\n                        num -= w-1;\\n                        currX = 0;\\n                        currY = h-1-num;\\n                    }\\n                }\\n            }\\n        }else if(dir == \"West\"){\\n            if(num<= currX){\\n                currX -= num;\\n            }else{\\n                dir = \"South\";\\n                num -= currX;\\n                currX = 0;\\n                \\n                if(num<=h-1){\\n                    currY =h-1- num;\\n                }else{\\n                    dir = \"East\";\\n                    currY = 0;\\n                    num -= h-1;\\n                    if(num<= w-1){\\n                        currX = num;\\n                    }else{\\n                        dir = \"North\";\\n                        num -= w-1;\\n                        currX = w-1;\\n                        currY = num;\\n                    }\\n                }\\n            }\\n            \\n            \\n            \\n        }else if(dir == \"South\"){\\n            if(num<= currY){\\n                currY -=num;\\n            }else{\\n                dir = \"East\";\\n                num -= currY;\\n                currY = 0;\\n                \\n                if(num<=w-1){\\n                    currX = num;\\n                }else{\\n                    dir = \"North\";\\n                    currX = w-1;\\n                    num -= w-1;\\n                    if(num<= h-1){\\n                        currY = num;\\n                    }else{\\n                        dir = \"West\";\\n                        num -= h-1;\\n                        currY = h-1;\\n                        currX = w-1-num;\\n                    }\\n                }\\n            }\\n        }else{\\n            if(num<=h-1-currY){\\n                currY = currY+num;\\n            }else{\\n                dir = \"West\";\\n                num -= h-1-currY;\\n                currY = h-1;\\n                \\n                if(num<=w-1){\\n                    currX = w-1-num;\\n                }else{\\n                    dir = \"South\";\\n                    currX = 0;\\n                    num -= w-1;\\n                    if(num<= h-1){\\n                        currY = h-1-num;\\n                    }else{\\n                        dir = \"East\";\\n                        num -= h-1;\\n                        currY = 0;\\n                        currX = num;\\n                    }\\n                }\\n            }   \\n        }\\n        \\n        \\n    }\\n    \\n    vector<int> getPos() {\\n        return {currX,currY};\\n    }\\n    \\n    string getDir() {\\n        return dir;\\n        \\n    }\\n};\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot* obj = new Robot(width, height);\\n * obj->move(num);\\n * vector<int> param_2 = obj->getPos();\\n * string param_3 = obj->getDir();\\n */\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Robot {\\npublic:\\n    int currX,currY;\\n    string dir;\\n    \\n    int w,h;\\n    \\n    Robot(int width, int height) {\\n        currX = 0;\\n        currY = 0;\\n        dir = \"East\";\\n        w = width;\\n        h = height;\\n        \\n    }\\n    \\n    void move(int num) {\\n        \\n        int para = 2*(w+h-2)+1;\\n        num = num%para;\\n        \\n        if(dir == \"East\"){\\n            if(num<= w-1-currX){\\n                currX = currX+num;\\n            }else{\\n                dir = \"North\";\\n                num -= w-1-currX;\\n                currX = w-1;\\n                \\n                if(num<=h-1){\\n                    currY = num;\\n                }else{\\n                    dir = \"West\";\\n                    currY = h-1;\\n                    num -= h-1;\\n                    if(num<= w-1){\\n                        currX = w-1-num;\\n                    }else{\\n                        dir = \"South\";\\n                        num -= w-1;\\n                        currX = 0;\\n                        currY = h-1-num;\\n                    }\\n                }\\n            }\\n        }else if(dir == \"West\"){\\n            if(num<= currX){\\n                currX -= num;\\n            }else{\\n                dir = \"South\";\\n                num -= currX;\\n                currX = 0;\\n                \\n                if(num<=h-1){\\n                    currY =h-1- num;\\n                }else{\\n                    dir = \"East\";\\n                    currY = 0;\\n                    num -= h-1;\\n                    if(num<= w-1){\\n                        currX = num;\\n                    }else{\\n                        dir = \"North\";\\n                        num -= w-1;\\n                        currX = w-1;\\n                        currY = num;\\n                    }\\n                }\\n            }\\n            \\n            \\n            \\n        }else if(dir == \"South\"){\\n            if(num<= currY){\\n                currY -=num;\\n            }else{\\n                dir = \"East\";\\n                num -= currY;\\n                currY = 0;\\n                \\n                if(num<=w-1){\\n                    currX = num;\\n                }else{\\n                    dir = \"North\";\\n                    currX = w-1;\\n                    num -= w-1;\\n                    if(num<= h-1){\\n                        currY = num;\\n                    }else{\\n                        dir = \"West\";\\n                        num -= h-1;\\n                        currY = h-1;\\n                        currX = w-1-num;\\n                    }\\n                }\\n            }\\n        }else{\\n            if(num<=h-1-currY){\\n                currY = currY+num;\\n            }else{\\n                dir = \"West\";\\n                num -= h-1-currY;\\n                currY = h-1;\\n                \\n                if(num<=w-1){\\n                    currX = w-1-num;\\n                }else{\\n                    dir = \"South\";\\n                    currX = 0;\\n                    num -= w-1;\\n                    if(num<= h-1){\\n                        currY = h-1-num;\\n                    }else{\\n                        dir = \"East\";\\n                        num -= h-1;\\n                        currY = 0;\\n                        currX = num;\\n                    }\\n                }\\n            }   \\n        }\\n        \\n        \\n    }\\n    \\n    vector<int> getPos() {\\n        return {currX,currY};\\n    }\\n    \\n    string getDir() {\\n        return dir;\\n        \\n    }\\n};\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot* obj = new Robot(width, height);\\n * obj->move(num);\\n * vector<int> param_2 = obj->getPos();\\n * string param_3 = obj->getDir();\\n */\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576800,
                "title": "javascript-move-one-time-per-turn-an-alternative-to-the-step-by-step-approach",
                "content": "```\\nconst DIRECTIONS = [\\'East\\', \\'North\\', \\'West\\', \\'South\\'];\\nconst DIRECTIONAL_MOVEMENT = [[1, 0], [0, 1], [-1, 0], [0, -1]];\\n\\n/**\\n * @param {number} width\\n * @param {number} height\\n */\\nvar Robot = function(width, height) {\\n    this.width = width;\\n    this.height = height;\\n    this.direction = 0;\\n    \\n    this.current = [0,0];\\n};\\n\\n/** \\n * @param {number} num\\n * @return {void}\\n */\\nRobot.prototype.move = function(num) {\\n    num%=2*this.width+2*this.height-4\\n    if (this.current[0] == 0 && this.current[1] == 0 && this.direction == 0) \\n        this.direction = 3; \\n    \\n    while(num > 0){\\n        const movement = DIRECTIONAL_MOVEMENT[this.direction];\\n        \\n        let newX = this.current[0];\\n        let newY = this.current[1];\\n        switch(this.direction){\\n            case 0:\\n                newX = Math.min(this.width-1, this.current[0] + (movement[0] * num));\\n                break;\\n            case 1:\\n                newY = Math.min(this.height-1, this.current[1] + (movement[1] * num));\\n                break;\\n            case 2:\\n                newX = Math.max(0, this.current[0] + (movement[0] * num));\\n                break;\\n            case 3:\\n                newY = Math.max(0, this.current[1] + (movement[1] * num));\\n                break;\\n        }\\n        \\n        num -= Math.abs(newX-this.current[0]) + Math.abs(newY-this.current[1]);\\n        this.current = [newX, newY];\\n        if(num > 0){\\n            this.turn();\\n        }\\n    }\\n};\\n\\n/**\\n * @return {number[]}\\n */\\nRobot.prototype.getPos = function() {\\n    return this.current;\\n};\\n\\n/**\\n * @return {string}\\n */\\nRobot.prototype.getDir = function() {\\n    return DIRECTIONS[this.direction];\\n};\\n\\nRobot.prototype.turn = function(){\\n    this.direction = (this.direction+1) % DIRECTIONS.length;\\n}\\n\\n/** \\n * Your Robot object will be instantiated and called as such:\\n * var obj = new Robot(width, height)\\n * obj.move(num)\\n * var param_2 = obj.getPos()\\n * var param_3 = obj.getDir()\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nconst DIRECTIONS = [\\'East\\', \\'North\\', \\'West\\', \\'South\\'];\\nconst DIRECTIONAL_MOVEMENT = [[1, 0], [0, 1], [-1, 0], [0, -1]];\\n\\n/**\\n * @param {number} width\\n * @param {number} height\\n */\\nvar Robot = function(width, height) {\\n    this.width = width;\\n    this.height = height;\\n    this.direction = 0;\\n    \\n    this.current = [0,0];\\n};\\n\\n/** \\n * @param {number} num\\n * @return {void}\\n */\\nRobot.prototype.move = function(num) {\\n    num%=2*this.width+2*this.height-4\\n    if (this.current[0] == 0 && this.current[1] == 0 && this.direction == 0) \\n        this.direction = 3; \\n    \\n    while(num > 0){\\n        const movement = DIRECTIONAL_MOVEMENT[this.direction];\\n        \\n        let newX = this.current[0];\\n        let newY = this.current[1];\\n        switch(this.direction){\\n            case 0:\\n                newX = Math.min(this.width-1, this.current[0] + (movement[0] * num));\\n                break;\\n            case 1:\\n                newY = Math.min(this.height-1, this.current[1] + (movement[1] * num));\\n                break;\\n            case 2:\\n                newX = Math.max(0, this.current[0] + (movement[0] * num));\\n                break;\\n            case 3:\\n                newY = Math.max(0, this.current[1] + (movement[1] * num));\\n                break;\\n        }\\n        \\n        num -= Math.abs(newX-this.current[0]) + Math.abs(newY-this.current[1]);\\n        this.current = [newX, newY];\\n        if(num > 0){\\n            this.turn();\\n        }\\n    }\\n};\\n\\n/**\\n * @return {number[]}\\n */\\nRobot.prototype.getPos = function() {\\n    return this.current;\\n};\\n\\n/**\\n * @return {string}\\n */\\nRobot.prototype.getDir = function() {\\n    return DIRECTIONS[this.direction];\\n};\\n\\nRobot.prototype.turn = function(){\\n    this.direction = (this.direction+1) % DIRECTIONS.length;\\n}\\n\\n/** \\n * Your Robot object will be instantiated and called as such:\\n * var obj = new Robot(width, height)\\n * obj.move(num)\\n * var param_2 = obj.getPos()\\n * var param_3 = obj.getDir()\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1576757,
                "title": "java-clean-concise-o-1-multiple-steps-at-a-time",
                "content": "\\n# Solution 1 : Moving Single Step O(borderCells)\\nThe solution is super simple to implement the code is very clean and concise. The only problem with this solution is that for bigger grid sizes it would get slower since complexity of this solution is O(borderCells).\\n\\n```\\nclass Robot2 {\\n    int rows, cols, dir = 0, r = 0, c = 0, border;\\n\\n    int dirs[][] = new int[][]{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n\\n    public Robot2(int width, int height) {\\n        rows = height;\\n        cols = width;\\n        border = cols * 2 + (rows - 2) * 2;\\n    }\\n\\n    boolean bounds(int r, int c) {\\n        return r >= 0 && c >= 0 && r < rows && c < cols;\\n    }\\n\\n    public void move(int num) {\\n        num = num % border;\\n        if (r == 0 && c == 0 && dir == 0 && num == 0) {\\n            rotate();\\n            rotate();\\n            rotate();\\n        }\\n\\n        while ( num > 0) {\\n            int nr = r + dirs[dir][0];\\n            int nc = c + dirs[dir][1];\\n            boolean bounds = bounds(nr, nc);\\n            if (bounds) {\\n                r = nr;\\n                c = nc;\\n                num--;\\n            } else {\\n                rotate();\\n            }\\n        }\\n    }\\n\\n    void rotate() {\\n        dir = (dir + 1) % 4;\\n    }\\n\\n    public int[] getPos() {\\n        return new int[]{c, r};\\n    }\\n\\n    public String getDir() {\\n        if (dir == 0) {\\n            return \"East\";\\n        } else if (dir == 1) {\\n            return \"North\";\\n        } else if (dir == 2) {\\n            return \"West\";\\n        } else {\\n            return \"South\";\\n        }\\n    }\\n}\\n```\\n\\n# Solution 2 : Moving Multiple Steps O(1)\\nThis is solution is super fast, just a bit trickier to implement. This would take constant size irrespective of the grid size.\\n```\\nclass Robot {\\n    int rows, cols, dir = 0, r = 0, c = 0, border;\\n\\n    int dirs[][] = new int[][]{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n\\n    public Robot(int width, int height) {\\n        rows = height;\\n        cols = width;\\n        border = cols * 2 + (rows - 2) * 2;\\n    }\\n\\n    boolean bounds(int r, int c) {\\n        return r >= 0 && c >= 0 && r < rows && c < cols;\\n    }\\n\\n    public void move(int num) {\\n        num = num % border;\\n        if (r == 0 && c == 0 && dir == 0 && num == 0) {\\n            rotate();\\n            rotate();\\n            rotate();\\n        }\\n\\n        while ( num > 0) {\\n            int nr = r + num * dirs[dir][0];\\n            int nc = c + num * dirs[dir][1];\\n            boolean bounds = bounds(nr, nc);\\n            int step = 0;\\n            if (dir == 0) {\\n                step = Integer.min(nc, cols - 1) - c;\\n                c = !bounds ? cols - 1 : nc;\\n            } else if (dir == 1) {\\n                step = Integer.min(nr, rows - 1) - r;\\n                r = !bounds ? rows - 1 : nr;\\n            } else if (dir == 2) {\\n                step = c - Integer.max(0, nc);\\n                c = !bounds ? 0 : nc;\\n            } else if (dir == 3) {\\n                step = r - Integer.max(0, nr);\\n                r = !bounds ? 0 : nr;\\n            }\\n            num -= step;\\n            if (!bounds) {\\n                rotate();\\n            }\\n        }\\n    }\\n\\n    void rotate() {\\n        dir = (dir + 1) % 4;\\n    }\\n\\n    public int[] getPos() {\\n        return new int[]{c, r};\\n    }\\n\\n    public String getDir() {\\n        if (dir == 0) {\\n            return \"East\";\\n        } else if (dir == 1) {\\n            return \"North\";\\n        } else if (dir == 2) {\\n            return \"West\";\\n        } else {\\n            return \"South\";\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Robot2 {\\n    int rows, cols, dir = 0, r = 0, c = 0, border;\\n\\n    int dirs[][] = new int[][]{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n\\n    public Robot2(int width, int height) {\\n        rows = height;\\n        cols = width;\\n        border = cols * 2 + (rows - 2) * 2;\\n    }\\n\\n    boolean bounds(int r, int c) {\\n        return r >= 0 && c >= 0 && r < rows && c < cols;\\n    }\\n\\n    public void move(int num) {\\n        num = num % border;\\n        if (r == 0 && c == 0 && dir == 0 && num == 0) {\\n            rotate();\\n            rotate();\\n            rotate();\\n        }\\n\\n        while ( num > 0) {\\n            int nr = r + dirs[dir][0];\\n            int nc = c + dirs[dir][1];\\n            boolean bounds = bounds(nr, nc);\\n            if (bounds) {\\n                r = nr;\\n                c = nc;\\n                num--;\\n            } else {\\n                rotate();\\n            }\\n        }\\n    }\\n\\n    void rotate() {\\n        dir = (dir + 1) % 4;\\n    }\\n\\n    public int[] getPos() {\\n        return new int[]{c, r};\\n    }\\n\\n    public String getDir() {\\n        if (dir == 0) {\\n            return \"East\";\\n        } else if (dir == 1) {\\n            return \"North\";\\n        } else if (dir == 2) {\\n            return \"West\";\\n        } else {\\n            return \"South\";\\n        }\\n    }\\n}\\n```\n```\\nclass Robot {\\n    int rows, cols, dir = 0, r = 0, c = 0, border;\\n\\n    int dirs[][] = new int[][]{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n\\n    public Robot(int width, int height) {\\n        rows = height;\\n        cols = width;\\n        border = cols * 2 + (rows - 2) * 2;\\n    }\\n\\n    boolean bounds(int r, int c) {\\n        return r >= 0 && c >= 0 && r < rows && c < cols;\\n    }\\n\\n    public void move(int num) {\\n        num = num % border;\\n        if (r == 0 && c == 0 && dir == 0 && num == 0) {\\n            rotate();\\n            rotate();\\n            rotate();\\n        }\\n\\n        while ( num > 0) {\\n            int nr = r + num * dirs[dir][0];\\n            int nc = c + num * dirs[dir][1];\\n            boolean bounds = bounds(nr, nc);\\n            int step = 0;\\n            if (dir == 0) {\\n                step = Integer.min(nc, cols - 1) - c;\\n                c = !bounds ? cols - 1 : nc;\\n            } else if (dir == 1) {\\n                step = Integer.min(nr, rows - 1) - r;\\n                r = !bounds ? rows - 1 : nr;\\n            } else if (dir == 2) {\\n                step = c - Integer.max(0, nc);\\n                c = !bounds ? 0 : nc;\\n            } else if (dir == 3) {\\n                step = r - Integer.max(0, nr);\\n                r = !bounds ? 0 : nr;\\n            }\\n            num -= step;\\n            if (!bounds) {\\n                rotate();\\n            }\\n        }\\n    }\\n\\n    void rotate() {\\n        dir = (dir + 1) % 4;\\n    }\\n\\n    public int[] getPos() {\\n        return new int[]{c, r};\\n    }\\n\\n    public String getDir() {\\n        if (dir == 0) {\\n            return \"East\";\\n        } else if (dir == 1) {\\n            return \"North\";\\n        } else if (dir == 2) {\\n            return \"West\";\\n        } else {\\n            return \"South\";\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576501,
                "title": "java-solution-using-a-single-1d-array-simulation-o-1-tc-o-1-sc-each-query",
                "content": "```\\nclass Robot {\\n    private static enum Directions{\\n        North, South, East, West\\n    }   \\n    \\n    private final int width;\\n    private final int height;\\n    private final int limit;\\n    \\n    private int pos;\\n    private boolean isOneRotationCompleted;\\n    \\n    public Robot(int width, int height) {\\n        this.width = width;\\n        this.height = height;\\n        this.limit = (2*width)+2*(height-2);\\n        \\n        this.pos = 0;\\n        this.isOneRotationCompleted = false;\\n    }\\n    \\n    public void move(int num) {\\n        pos += num;\\n        \\n        if(pos >= limit){\\n            pos %= limit;\\n            isOneRotationCompleted = true;\\n        }\\n    }\\n    \\n    public int[] getPos() {\\n        if(pos >= 0 && pos <= width-1) return new int[] { pos, 0 };\\n        if(pos >= width && pos <= width-1+height-1) return new int[] { width-1, pos-(width-1) };\\n        if(pos >= width-1+height-1+1 && pos <= width-1+height-1+width-1) return new int[] { (width-1)-(pos-(width-1+height-1)), height-1 };\\n        if(pos >= width-1+height-1+width-1+1 && pos <= width-1+height-1+width-1+height-1 - 1) return new int[] { 0, (height-1)-(pos-(width-1+height-1+width-1)) };\\n        \\n        throw new AssertionError();\\n    }\\n    \\n    public String getDir() {\\n        if(!isOneRotationCompleted && pos == 0) return Directions.East.name();\\n        else if(pos == 0) return Directions.South.name();\\n        \\n        if(pos >= 0 && pos <= width-1) return Directions.East.name();\\n        if(pos >= width && pos <= width-1+height-1) return Directions.North.name();\\n        if(pos >= width-1+height-1+1 && pos <= width-1+height-1+width-1) return Directions.West.name();\\n        if(pos >= width-1+height-1+width-1+1 && pos <= width-1+height-1+width-1+height-1 - 1) return Directions.South.name();\\n        \\n        throw new AssertionError();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Robot {\\n    private static enum Directions{\\n        North, South, East, West\\n    }   \\n    \\n    private final int width;\\n    private final int height;\\n    private final int limit;\\n    \\n    private int pos;\\n    private boolean isOneRotationCompleted;\\n    \\n    public Robot(int width, int height) {\\n        this.width = width;\\n        this.height = height;\\n        this.limit = (2*width)+2*(height-2);\\n        \\n        this.pos = 0;\\n        this.isOneRotationCompleted = false;\\n    }\\n    \\n    public void move(int num) {\\n        pos += num;\\n        \\n        if(pos >= limit){\\n            pos %= limit;\\n            isOneRotationCompleted = true;\\n        }\\n    }\\n    \\n    public int[] getPos() {\\n        if(pos >= 0 && pos <= width-1) return new int[] { pos, 0 };\\n        if(pos >= width && pos <= width-1+height-1) return new int[] { width-1, pos-(width-1) };\\n        if(pos >= width-1+height-1+1 && pos <= width-1+height-1+width-1) return new int[] { (width-1)-(pos-(width-1+height-1)), height-1 };\\n        if(pos >= width-1+height-1+width-1+1 && pos <= width-1+height-1+width-1+height-1 - 1) return new int[] { 0, (height-1)-(pos-(width-1+height-1+width-1)) };\\n        \\n        throw new AssertionError();\\n    }\\n    \\n    public String getDir() {\\n        if(!isOneRotationCompleted && pos == 0) return Directions.East.name();\\n        else if(pos == 0) return Directions.South.name();\\n        \\n        if(pos >= 0 && pos <= width-1) return Directions.East.name();\\n        if(pos >= width && pos <= width-1+height-1) return Directions.North.name();\\n        if(pos >= width-1+height-1+1 && pos <= width-1+height-1+width-1) return Directions.West.name();\\n        if(pos >= width-1+height-1+width-1+1 && pos <= width-1+height-1+width-1+height-1 - 1) return Directions.South.name();\\n        \\n        throw new AssertionError();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576499,
                "title": "concise-solution-by-using-mod-2-with-explanation-javascript",
                "content": "### Demonstration:\\nFirstly I want to say that the initial position (0, 0) was set with an unreasonable facing direction. So as soon as there\\'s a move (zero move is not allowed), change the robot direction to the South for later algorithm convenience.\\nSecondly, there are some bitwise tricks I used in the solution to boost performance.\\n* `side << 1 === side * 2`\\n* `k & 1 === k % 2`\\n* `k & 3 === k % 4`\\n* `-~k === k + 1`\\n* `-~k & 3 === (k + 1) % 4`\\n```javascript\\nvar Robot = function(width, height) {\\n  const dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]];\\n  const dirNames = [\\'East\\', \\'North\\', \\'West\\', \\'South\\'];\\n  const pos = [0, 0], side = [width, height];\\n  let k = 0;\\n  this.move = function(num) {\\n    pos[0] === 0 && pos[1] === 0 && k === 0 && (k = 3);\\n    num %= width + height - 2 << 1;\\n    let step, t;\\n    while (num) {\\n      if (pos[t = k & 1] === 0 || pos[t] === side[t] - 1) {\\n        t = (k = -~k & 3) & 1, step = side[t] - 1;\\n      } else if (k > 1) step = pos[t];\\n      else step = side[t] - pos[t] - 1;\\n      if (num < step) step = num, num = 0; else num -= step;\\n      if (k > 1) pos[t] -= step; else pos[t] += step;\\n    }\\n  };\\n  this.getPos = () => pos;\\n  this.getDir = () => dirNames[k];\\n};\\n```\\n### Explanation:\\n```javascript\\nvar Robot = function(width, height) {\\n  const dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]];\\n  const dirNames = [\\'East\\', \\'North\\', \\'West\\', \\'South\\'];\\n  const pos = [0, 0], side = [width, height];\\n  let k = 0;\\n  this.move = function(num) {\\n    // Change the direction to South if the robot is\\n\\t// still at the initial position.\\n    pos[0] === 0 && pos[1] === 0 && k === 0 && (k = 3);\\n\\t\\n\\t// Covering all the bounds will leave the robot\\n\\t// at the same position, so to reduce loops, remove\\n\\t// those whole rounds.\\n    num %= width + height - 2 << 1;\\n\\t\\n    let step, t;\\n\\t\\n    while (num) {\\n\\t\\n\\t  // Case 1: The robot is at one of the corners.\\n      if (pos[t = k & 1] === 0 || pos[t] === side[t] - 1) {\\n\\t    // Change the direction, set the possible\\n\\t\\t// steps forwards the robot can move.\\n        t = (k = -~k & 3) & 1, step = side[t] - 1;\\n      }\\n\\t  \\n\\t  // Case 2: The robot is in the middle of one of the sides.\\n\\t  \\n\\t  // The robot is either on the top or left side, and\\n\\t  // tends to move towards 0.\\n\\t  else if (k > 1) step = pos[t];\\n\\t  // The robot is either on the bottom or right side,\\n\\t  // and tends to move towards width or height.\\n      else step = side[t] - pos[t] - 1;\\n\\t  \\n\\t  // If num doesn\\'t cover step, only reduce num to 0, which\\n\\t  // will leave the robot in the middle of a side instead of\\n\\t  // at a corner.\\n      if (num < step) step = num, num = 0; else num -= step;\\n\\t  \\n\\t  // Update the position based on the robot\\'s current side.\\n      if (k > 1) pos[t] -= step; else pos[t] += step;\\n    }\\n  };\\n  this.getPos = () => pos;\\n  this.getDir = () => dirNames[k];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar Robot = function(width, height) {\\n  const dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]];\\n  const dirNames = [\\'East\\', \\'North\\', \\'West\\', \\'South\\'];\\n  const pos = [0, 0], side = [width, height];\\n  let k = 0;\\n  this.move = function(num) {\\n    pos[0] === 0 && pos[1] === 0 && k === 0 && (k = 3);\\n    num %= width + height - 2 << 1;\\n    let step, t;\\n    while (num) {\\n      if (pos[t = k & 1] === 0 || pos[t] === side[t] - 1) {\\n        t = (k = -~k & 3) & 1, step = side[t] - 1;\\n      } else if (k > 1) step = pos[t];\\n      else step = side[t] - pos[t] - 1;\\n      if (num < step) step = num, num = 0; else num -= step;\\n      if (k > 1) pos[t] -= step; else pos[t] += step;\\n    }\\n  };\\n  this.getPos = () => pos;\\n  this.getDir = () => dirNames[k];\\n};\\n```\n```javascript\\nvar Robot = function(width, height) {\\n  const dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]];\\n  const dirNames = [\\'East\\', \\'North\\', \\'West\\', \\'South\\'];\\n  const pos = [0, 0], side = [width, height];\\n  let k = 0;\\n  this.move = function(num) {\\n    // Change the direction to South if the robot is\\n\\t// still at the initial position.\\n    pos[0] === 0 && pos[1] === 0 && k === 0 && (k = 3);\\n\\t\\n\\t// Covering all the bounds will leave the robot\\n\\t// at the same position, so to reduce loops, remove\\n\\t// those whole rounds.\\n    num %= width + height - 2 << 1;\\n\\t\\n    let step, t;\\n\\t\\n    while (num) {\\n\\t\\n\\t  // Case 1: The robot is at one of the corners.\\n      if (pos[t = k & 1] === 0 || pos[t] === side[t] - 1) {\\n\\t    // Change the direction, set the possible\\n\\t\\t// steps forwards the robot can move.\\n        t = (k = -~k & 3) & 1, step = side[t] - 1;\\n      }\\n\\t  \\n\\t  // Case 2: The robot is in the middle of one of the sides.\\n\\t  \\n\\t  // The robot is either on the top or left side, and\\n\\t  // tends to move towards 0.\\n\\t  else if (k > 1) step = pos[t];\\n\\t  // The robot is either on the bottom or right side,\\n\\t  // and tends to move towards width or height.\\n      else step = side[t] - pos[t] - 1;\\n\\t  \\n\\t  // If num doesn\\'t cover step, only reduce num to 0, which\\n\\t  // will leave the robot in the middle of a side instead of\\n\\t  // at a corner.\\n      if (num < step) step = num, num = 0; else num -= step;\\n\\t  \\n\\t  // Update the position based on the robot\\'s current side.\\n      if (k > 1) pos[t] -= step; else pos[t] += step;\\n    }\\n  };\\n  this.getPos = () => pos;\\n  this.getDir = () => dirNames[k];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1576483,
                "title": "c-solution-with-edge-test-cases-explained-in-comments",
                "content": "/* The code is straightforward, just one good edge case that i got wrong answer on was if we write a logic \\nnum %= perimeter (perimeter = 2*(width + height - 2))  to disregard repeations. Then if we receive a cycle (num/ perimeter > 0) then at that point the direction will not change.\\nFor Example: \\n[\"Robot\",\"move\",\"move\",\"getPos\",\"getDir\"]\\n[[6,3],[14],[14],[],[]]\\nin this test case the value of getPos will be (0,0) but getDir will not change to \"East\" , it will still be \"South\".\\n*/\\n\\n```\\nclass Robot {\\npublic:\\n    vector<int> position ;\\n    string direction; \\n    unordered_map<string,string> dir; \\n    int width; \\n    int height;\\n    bool firstMove; \\n    Robot(int width, int height) {\\n        this-> position.push_back(0); \\n        this -> position.push_back(0);\\n        this -> width = width ; \\n        this -> height = height;\\n        this-> direction = \"South\"; /* to fix the edge case in the comments , we start from the South, if the robot gets obstacle then it will change direction */ \\n        firstMove = false; \\n        dir[\"East\"] = \"North\", dir[\"North\"] = \"West\", dir[\"West\"] = \"South\", dir[\"South\"] = \"East\";   \\n    }\\n    \\n    void move(int num) {\\n        firstMove = true; \\n        int perimeter = 2*(this->width + this-> height - 2);\\n        num %= perimeter;\\n        \\n        string curDirection = this -> direction ; \\n        vector<int> curPos = this->position;\\n        while(num > 0) {\\n            if(curDirection == \"East\") {\\n                int steps = isValid(curPos[0]+num, curPos[1]) ? num : abs(curPos[0] - this->width + 1);\\n                curPos[0]+=steps;\\n                num-=steps; \\n            }\\n            \\n            if(curDirection == \"North\") {\\n                int steps = isValid(curPos[0], curPos[1] + num) ? num : abs(curPos[1] - this->height + 1);\\n                curPos[1]+=steps;\\n                num-=steps; \\n            }\\n            \\n            if(curDirection == \"West\") {\\n                int steps = isValid(curPos[0]-num, curPos[1]) ? num : abs(curPos[0]);\\n                curPos[0]-=steps;\\n                num-=steps; \\n            }\\n            \\n            if(curDirection == \"South\") {\\n                int steps = isValid(curPos[0], curPos[1] - num) ? num : abs(curPos[1]);\\n                curPos[1]-=steps;\\n                num-=steps; \\n            }\\n            if(num > 0) curDirection = this-> dir[curDirection];\\n        }\\n        this->position = curPos; \\n        this->direction = curDirection ; \\n        \\n    }\\n    bool isValid(int w , int h) {\\n        if(w >= this->width || h >= this-> height || w < 0 || h < 0) return false; \\n        return true;\\n    }\\n\\n    vector<int> getPos() {\\n        return this-> position; \\n    }\\n    \\n    string getDir() {\\n        if(!firstMove) return \"East\"; /*In this implementation of starting from south will get wrong answer if the robot still didnot make any move , so we return \"East\" if we called move function 0 times*/\\n        return this-> direction ;\\n    }\\n    \\n};\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot* obj = new Robot(width, height);\\n * obj->move(num);\\n * vector<int> param_2 = obj->getPos();\\n * string param_3 = obj->getDir();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass Robot {\\npublic:\\n    vector<int> position ;\\n    string direction; \\n    unordered_map<string,string> dir; \\n    int width; \\n    int height;\\n    bool firstMove; \\n    Robot(int width, int height) {\\n        this-> position.push_back(0); \\n        this -> position.push_back(0);\\n        this -> width = width ; \\n        this -> height = height;\\n        this-> direction = \"South\"; /* to fix the edge case in the comments , we start from the South, if the robot gets obstacle then it will change direction */ \\n        firstMove = false; \\n        dir[\"East\"] = \"North\", dir[\"North\"] = \"West\", dir[\"West\"] = \"South\", dir[\"South\"] = \"East\";   \\n    }\\n    \\n    void move(int num) {\\n        firstMove = true; \\n        int perimeter = 2*(this->width + this-> height - 2);\\n        num %= perimeter;\\n        \\n        string curDirection = this -> direction ; \\n        vector<int> curPos = this->position;\\n        while(num > 0) {\\n            if(curDirection == \"East\") {\\n                int steps = isValid(curPos[0]+num, curPos[1]) ? num : abs(curPos[0] - this->width + 1);\\n                curPos[0]+=steps;\\n                num-=steps; \\n            }\\n            \\n            if(curDirection == \"North\") {\\n                int steps = isValid(curPos[0], curPos[1] + num) ? num : abs(curPos[1] - this->height + 1);\\n                curPos[1]+=steps;\\n                num-=steps; \\n            }\\n            \\n            if(curDirection == \"West\") {\\n                int steps = isValid(curPos[0]-num, curPos[1]) ? num : abs(curPos[0]);\\n                curPos[0]-=steps;\\n                num-=steps; \\n            }\\n            \\n            if(curDirection == \"South\") {\\n                int steps = isValid(curPos[0], curPos[1] - num) ? num : abs(curPos[1]);\\n                curPos[1]-=steps;\\n                num-=steps; \\n            }\\n            if(num > 0) curDirection = this-> dir[curDirection];\\n        }\\n        this->position = curPos; \\n        this->direction = curDirection ; \\n        \\n    }\\n    bool isValid(int w , int h) {\\n        if(w >= this->width || h >= this-> height || w < 0 || h < 0) return false; \\n        return true;\\n    }\\n\\n    vector<int> getPos() {\\n        return this-> position; \\n    }\\n    \\n    string getDir() {\\n        if(!firstMove) return \"East\"; /*In this implementation of starting from south will get wrong answer if the robot still didnot make any move , so we return \"East\" if we called move function 0 times*/\\n        return this-> direction ;\\n    }\\n    \\n};\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot* obj = new Robot(width, height);\\n * obj->move(num);\\n * vector<int> param_2 = obj->getPos();\\n * string param_3 = obj->getDir();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576480,
                "title": "python-o-m-n-time-o-1-space",
                "content": "```\\nclass Robot:\\n    def __init__(self, width: int, height: int):\\n        self.size = [width, height]\\n        self.current_position = [0, 0]\\n        self.current_direction = \\'East\\'        \\n\\n    def move(self, num: int) -> None:\\n        x, y = self.current_position\\n        direction = self.current_direction\\n        size = self.size\\n        \\n        # Calculate total moves available \\n        total_moves = 2*(size[0]-1 + size[1]-1)\\n        \\n        # Speedup the process\\n        if num >= total_moves: num = num % total_moves\\n            \\n        # Handle EDGE CASE directions\\n        if num == 0 and x == 0 and y == 0: direction = \\'South\\'\\n        elif num == 0 and x == size[0] -1 and y == 0: direction = \\'East\\'\\n        elif num == 0 and x == size[0] -1 and y == size[1]-1: direction = \\'North\\'\\n        elif num == 0 and x == 0 and y == size[1] -1: direction = \\'West\\'\\n            \\n        # Travel remaining distance normally\\n        while num > 0:\\n            if direction == \\'East\\': \\n                if x < size[0] -1: \\n                    x += 1\\n                    num -= 1\\n                else:\\n                    direction = \\'North\\'\\n            \\n            elif direction == \\'North\\': \\n                if y < size[1] -1: \\n                    y += 1\\n                    num -= 1\\n                else:\\n                    direction = \\'West\\'\\n            \\n            elif direction == \\'West\\': \\n                if x > 0:\\n                    x -= 1\\n                    num -=1\\n                else:\\n                    direction = \\'South\\'\\n            \\n            elif direction == \\'South\\': \\n                if y > 0: \\n                    y -= 1\\n                    num -= 1\\n                else:\\n                    direction = \\'East\\'\\n          \\n        self.current_position = [x, y]\\n        self.current_direction = direction\\n\\n    def getPos(self) -> List[int]:\\n        return self.current_position\\n\\n    def getDir(self) -> str:\\n        return self.current_direction\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Robot:\\n    def __init__(self, width: int, height: int):\\n        self.size = [width, height]\\n        self.current_position = [0, 0]\\n        self.current_direction = \\'East\\'        \\n\\n    def move(self, num: int) -> None:\\n        x, y = self.current_position\\n        direction = self.current_direction\\n        size = self.size\\n        \\n        # Calculate total moves available \\n        total_moves = 2*(size[0]-1 + size[1]-1)\\n        \\n        # Speedup the process\\n        if num >= total_moves: num = num % total_moves\\n            \\n        # Handle EDGE CASE directions\\n        if num == 0 and x == 0 and y == 0: direction = \\'South\\'\\n        elif num == 0 and x == size[0] -1 and y == 0: direction = \\'East\\'\\n        elif num == 0 and x == size[0] -1 and y == size[1]-1: direction = \\'North\\'\\n        elif num == 0 and x == 0 and y == size[1] -1: direction = \\'West\\'\\n            \\n        # Travel remaining distance normally\\n        while num > 0:\\n            if direction == \\'East\\': \\n                if x < size[0] -1: \\n                    x += 1\\n                    num -= 1\\n                else:\\n                    direction = \\'North\\'\\n            \\n            elif direction == \\'North\\': \\n                if y < size[1] -1: \\n                    y += 1\\n                    num -= 1\\n                else:\\n                    direction = \\'West\\'\\n            \\n            elif direction == \\'West\\': \\n                if x > 0:\\n                    x -= 1\\n                    num -=1\\n                else:\\n                    direction = \\'South\\'\\n            \\n            elif direction == \\'South\\': \\n                if y > 0: \\n                    y -= 1\\n                    num -= 1\\n                else:\\n                    direction = \\'East\\'\\n          \\n        self.current_position = [x, y]\\n        self.current_direction = direction\\n\\n    def getPos(self) -> List[int]:\\n        return self.current_position\\n\\n    def getDir(self) -> str:\\n        return self.current_direction\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576403,
                "title": "straightforward-simulation-approach",
                "content": "*O(1) space and time solution*\\n\\n* Resuces the number of move steps modulo plane\\'s perimeter, which is 2*(width+height-2)\\n* Handles the special case of a round trip from (0,0) position where direction should be South instead of East\\n* Proceeds each move in two parts - go towards the boundary, then optionally turn and finish the move by making the remaining steps (while loop has at most four iterations as the number of steps is limited by perimeter)\\n* Each move is just an arithmetical manipulations with variables\\n\\n*P.S. There is some dirty similar code blocks inside a switch operator. Maybe I\\'ll clean it up later*\\n\\n```C#\\npublic class Robot\\n{\\n    private enum Direction\\n    {\\n        North,\\n        East,\\n        South,\\n        West\\n    }\\n\\n    private int width;\\n    private int height;\\n    private Direction direction = Direction.East;\\n    private (int x, int y) position = (0, 0);\\n\\n    public Robot(int width, int height)\\n    {\\n        this.width = width;\\n        this.height = height;\\n    }\\n\\n    public void Move(int num)\\n    {\\n        num %= 2 * (width - 1 + height - 1); //handle large number of steps within one move to avoid TLE\\n        if (num == 0 && position.x == 0 && position.y == 0) //handle a special case (round trip from initial position)\\n        {\\n            direction = Direction.South;\\n        }\\n\\n        int x, y, stepsAfterTurn;\\n        var repeatStep = true;\\n        while (repeatStep) //split a move into two parts: move to the bound, then turn and move further\\n        {\\n            switch (direction)\\n            {\\n                case Direction.North:\\n                    y = position.y + num;\\n                    stepsAfterTurn = y - height + 1;\\n                    if (stepsAfterTurn > 0)\\n                    {\\n                        direction = Direction.West;\\n                        y = height - 1;\\n                        num = stepsAfterTurn;\\n                    }\\n                    else\\n                    {\\n                        repeatStep = false;\\n                    }\\n                    position = (position.x, y);\\n                    break;\\n                case Direction.East:\\n                    x = position.x + num;\\n                    stepsAfterTurn = x - width + 1;\\n                    if (stepsAfterTurn > 0)\\n                    {\\n                        direction = Direction.North;\\n                        x = width - 1;\\n                        num = stepsAfterTurn;\\n                    }\\n                    else\\n                    {\\n                        repeatStep = false;\\n                    }\\n                    position = (x, position.y);\\n                    break;\\n                case Direction.South:\\n                    y = position.y - num;\\n                    stepsAfterTurn = -y;\\n                    if (stepsAfterTurn > 0)\\n                    {\\n                        direction = Direction.East;\\n                        y = 0;\\n                        num = stepsAfterTurn;\\n                    }\\n                    else\\n                    {\\n                        repeatStep = false;\\n                    }\\n                    position = (position.x, y);\\n                    break;\\n                case Direction.West:\\n                    x = position.x - num;\\n                    stepsAfterTurn = -x;\\n                    if (stepsAfterTurn > 0)\\n                    {\\n                        direction = Direction.South;\\n                        x = 0;\\n                        num = stepsAfterTurn;\\n                    }\\n                    else\\n                    {\\n                        repeatStep = false;\\n                    }\\n                    position = (x, position.y);\\n                    break;\\n                default:\\n                    throw new ArgumentOutOfRangeException();\\n            }\\n        }\\n    }\\n\\n    public int[] GetPos()\\n    {\\n        return new[] { position.x, position.y };\\n    }\\n\\n    public string GetDir()\\n    {\\n        return direction.ToString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Simulation"
                ],
                "code": "```C#\\npublic class Robot\\n{\\n    private enum Direction\\n    {\\n        North,\\n        East,\\n        South,\\n        West\\n    }\\n\\n    private int width;\\n    private int height;\\n    private Direction direction = Direction.East;\\n    private (int x, int y) position = (0, 0);\\n\\n    public Robot(int width, int height)\\n    {\\n        this.width = width;\\n        this.height = height;\\n    }\\n\\n    public void Move(int num)\\n    {\\n        num %= 2 * (width - 1 + height - 1); //handle large number of steps within one move to avoid TLE\\n        if (num == 0 && position.x == 0 && position.y == 0) //handle a special case (round trip from initial position)\\n        {\\n            direction = Direction.South;\\n        }\\n\\n        int x, y, stepsAfterTurn;\\n        var repeatStep = true;\\n        while (repeatStep) //split a move into two parts: move to the bound, then turn and move further\\n        {\\n            switch (direction)\\n            {\\n                case Direction.North:\\n                    y = position.y + num;\\n                    stepsAfterTurn = y - height + 1;\\n                    if (stepsAfterTurn > 0)\\n                    {\\n                        direction = Direction.West;\\n                        y = height - 1;\\n                        num = stepsAfterTurn;\\n                    }\\n                    else\\n                    {\\n                        repeatStep = false;\\n                    }\\n                    position = (position.x, y);\\n                    break;\\n                case Direction.East:\\n                    x = position.x + num;\\n                    stepsAfterTurn = x - width + 1;\\n                    if (stepsAfterTurn > 0)\\n                    {\\n                        direction = Direction.North;\\n                        x = width - 1;\\n                        num = stepsAfterTurn;\\n                    }\\n                    else\\n                    {\\n                        repeatStep = false;\\n                    }\\n                    position = (x, position.y);\\n                    break;\\n                case Direction.South:\\n                    y = position.y - num;\\n                    stepsAfterTurn = -y;\\n                    if (stepsAfterTurn > 0)\\n                    {\\n                        direction = Direction.East;\\n                        y = 0;\\n                        num = stepsAfterTurn;\\n                    }\\n                    else\\n                    {\\n                        repeatStep = false;\\n                    }\\n                    position = (position.x, y);\\n                    break;\\n                case Direction.West:\\n                    x = position.x - num;\\n                    stepsAfterTurn = -x;\\n                    if (stepsAfterTurn > 0)\\n                    {\\n                        direction = Direction.South;\\n                        x = 0;\\n                        num = stepsAfterTurn;\\n                    }\\n                    else\\n                    {\\n                        repeatStep = false;\\n                    }\\n                    position = (x, position.y);\\n                    break;\\n                default:\\n                    throw new ArgumentOutOfRangeException();\\n            }\\n        }\\n    }\\n\\n    public int[] GetPos()\\n    {\\n        return new[] { position.x, position.y };\\n    }\\n\\n    public string GetDir()\\n    {\\n        return direction.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576379,
                "title": "java-simulation-solution",
                "content": "**Runtime: 82 ms, faster than 75.00% of Java online submissions for Walking Robot Simulation II.\\nMemory Usage: 48.5 MB, less than 100.00% of Java online submissions for Walking Robot Simulation II.**\\n```\\nclass Robot {\\n    int x = 0,y = 0, p_x = 0, p_y = 0;\\n    String dir = \"East\";\\n    public Robot(int width, int height) {\\n        x = width;\\n        y = height;\\n    }\\n    \\n    public void move(int num) {\\n        num %= x * 2 + y * 2 - 4;\\n        if(num == 0)num = x * 2 + y * 2 - 4;\\n        \\n        while(num > 0){\\n            if(dir == \"East\"){\\n                if(p_x == x-1){\\n                    dir = \"North\";\\n                    p_y++;\\n                }else{\\n                    p_x++;\\n                }\\n            }else if(dir == \"North\"){\\n                if(p_y == y-1){\\n                    dir = \"West\";\\n                    p_x--;\\n                }else{\\n                    p_y++;\\n                }\\n            }else if(dir == \"West\"){\\n                if(p_x == 0){\\n                    dir = \"South\";\\n                    p_y--;\\n                }else{\\n                    p_x--;\\n                }\\n            }else if(dir == \"South\"){\\n                if(p_y == 0){\\n                    dir = \"East\";\\n                    p_x++;\\n                }else{\\n                    p_y--;\\n                }\\n            }\\n            num--;\\n        }\\n    }\\n    \\n    public int[] getPos() {\\n        return new int[]{p_x,p_y};\\n    }\\n    \\n    public String getDir() {\\n        return dir;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Robot {\\n    int x = 0,y = 0, p_x = 0, p_y = 0;\\n    String dir = \"East\";\\n    public Robot(int width, int height) {\\n        x = width;\\n        y = height;\\n    }\\n    \\n    public void move(int num) {\\n        num %= x * 2 + y * 2 - 4;\\n        if(num == 0)num = x * 2 + y * 2 - 4;\\n        \\n        while(num > 0){\\n            if(dir == \"East\"){\\n                if(p_x == x-1){\\n                    dir = \"North\";\\n                    p_y++;\\n                }else{\\n                    p_x++;\\n                }\\n            }else if(dir == \"North\"){\\n                if(p_y == y-1){\\n                    dir = \"West\";\\n                    p_x--;\\n                }else{\\n                    p_y++;\\n                }\\n            }else if(dir == \"West\"){\\n                if(p_x == 0){\\n                    dir = \"South\";\\n                    p_y--;\\n                }else{\\n                    p_x--;\\n                }\\n            }else if(dir == \"South\"){\\n                if(p_y == 0){\\n                    dir = \"East\";\\n                    p_x++;\\n                }else{\\n                    p_y--;\\n                }\\n            }\\n            num--;\\n        }\\n    }\\n    \\n    public int[] getPos() {\\n        return new int[]{p_x,p_y};\\n    }\\n    \\n    public String getDir() {\\n        return dir;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576378,
                "title": "python-o-1-time-space-for-all-functions-including-intitialize",
                "content": "The braindead solution is actually to just cache what direction/ position a square belongs to, then walk along the outer ring. Doing this without the extra O(M+N) space though is quite a headache and far beyond the scope of what leetcode wanted, which to me means this is a crappy problem, because that\\'s not flying in an interview.\\n\\nMemorize what square each corner is, and do the calculations accordingly.\\n\\n```\\nclass Robot:\\n    def __init__(self, M: int, N: int):\\n        self.N,self.M = N, M\\n        self.C = 2*M + 2*(N-2)\\n        self.sq = 0\\n        self.dir = \\'East\\'\\n        self.pos = [0,0]\\n        self.bottomLeftSq = 0\\n        self.bottomRightSq = M-1\\n        self.topRightSq = self.bottomRightSq + N-1\\n        self.topLeftSq = self.topRightSq + (M-1)\\n        \\n    def move(self, K: int) -> None:\\n        self.sq = sq = (self.sq + K) % self.C\\n        blc, brc, trc, tlc = self.bottomLeftSq, self.bottomRightSq, self.topRightSq, self.topLeftSq\\n        M, N = self.M, self.N\\n        if blc < sq and sq <= brc:\\n            self.dir = \\'East\\'\\n            self.pos = [sq,0]\\n        elif brc < sq and sq <= trc:\\n            self.dir = \\'North\\'\\n            self.pos = [M-1,sq-brc]\\n        elif trc < sq and sq <= tlc:\\n            self.dir = \\'West\\'\\n            self.pos = [M-1 -(sq-trc), N-1]\\n        else:\\n            self.dir = \\'South\\'\\n            self.pos = [0, (N-1 - (sq-tlc) if sq else 0)]\\n\\n    def getPos(self) -> List[int]:\\n        return self.pos\\n    def getDir(self) -> str:\\n        return self.dir\\n```",
                "solutionTags": [],
                "code": "```\\nclass Robot:\\n    def __init__(self, M: int, N: int):\\n        self.N,self.M = N, M\\n        self.C = 2*M + 2*(N-2)\\n        self.sq = 0\\n        self.dir = \\'East\\'\\n        self.pos = [0,0]\\n        self.bottomLeftSq = 0\\n        self.bottomRightSq = M-1\\n        self.topRightSq = self.bottomRightSq + N-1\\n        self.topLeftSq = self.topRightSq + (M-1)\\n        \\n    def move(self, K: int) -> None:\\n        self.sq = sq = (self.sq + K) % self.C\\n        blc, brc, trc, tlc = self.bottomLeftSq, self.bottomRightSq, self.topRightSq, self.topLeftSq\\n        M, N = self.M, self.N\\n        if blc < sq and sq <= brc:\\n            self.dir = \\'East\\'\\n            self.pos = [sq,0]\\n        elif brc < sq and sq <= trc:\\n            self.dir = \\'North\\'\\n            self.pos = [M-1,sq-brc]\\n        elif trc < sq and sq <= tlc:\\n            self.dir = \\'West\\'\\n            self.pos = [M-1 -(sq-trc), N-1]\\n        else:\\n            self.dir = \\'South\\'\\n            self.pos = [0, (N-1 - (sq-tlc) if sq else 0)]\\n\\n    def getPos(self) -> List[int]:\\n        return self.pos\\n    def getDir(self) -> str:\\n        return self.dir\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576340,
                "title": "c",
                "content": "```\\nint x, y;\\n    int i=0,j=0;\\n    char dir =\\'e\\';\\n    Robot(int width, int height) {\\n        x=width-1;\\n        y =height-1;\\n    }\\n\\n    void move(int num) {\\n    \\n        int d= 2*x + 2*y;\\n       int mov = num%d;\\n        if(mov==0)\\n            mov=d;\\n        for(int k=0;k<5;k++)\\n        {\\n            if(dir==\\'e\\')\\n            {     \\n            int req = x-i;\\n            if(mov<=req)\\n            {\\n                i+= mov;\\n                break;\\n            }\\n            else\\n             {\\n                  mov = mov -req;\\n                  i+= req;\\n                 dir =\\'n\\' ;   \\n             }  \\n            }\\n            \\n           else if(dir==\\'n\\')\\n            {     \\n            int req = y-j;\\n            if(mov<=req)\\n            {\\n                j+= mov;\\n                break;\\n            }\\n            else\\n             {\\n                  mov = mov -req;\\n                  j+= req;\\n                 dir =\\'w\\' ;   \\n             }  \\n            }\\n            \\n             else if(dir==\\'w\\')\\n            {     \\n            int req = i;\\n            if(mov<=req)\\n            {\\n                i-= mov;\\n                break;\\n            }\\n            else\\n             {\\n                  mov = mov -req;\\n                  i-= req;\\n                 dir =\\'s\\' ;   \\n             }  \\n            }\\n            \\n            else if(dir==\\'s\\')\\n            {     \\n            int req = j;\\n            if(mov<=req)\\n            {\\n                j-= mov;\\n                break;\\n            }\\n            else\\n             {\\n                  mov = mov -req;\\n                  j-= req;\\n                 dir =\\'e\\' ;   \\n             }  \\n            }\\n        }\\n       \\n    }\\n    \\n    vector<int> getPos() { \\n        return {i,j};\\n    }\\n    \\n    string getDir() {\\n\\n       if(dir==\\'e\\')\\n           return \"East\";\\n        else if(dir==\\'w\\')\\n            return \"West\";\\n        else if(dir==\\'n\\')\\n            return \"North\";\\n        else\\n            return \"South\";\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nint x, y;\\n    int i=0,j=0;\\n    char dir =\\'e\\';\\n    Robot(int width, int height) {\\n        x=width-1;\\n        y =height-1;\\n    }\\n\\n    void move(int num) {\\n    \\n        int d= 2*x + 2*y;\\n       int mov = num%d;\\n        if(mov==0)\\n            mov=d;\\n        for(int k=0;k<5;k++)\\n        {\\n            if(dir==\\'e\\')\\n            {     \\n            int req = x-i;\\n            if(mov<=req)\\n            {\\n                i+= mov;\\n                break;\\n            }\\n            else\\n             {\\n                  mov = mov -req;\\n                  i+= req;\\n                 dir =\\'n\\' ;   \\n             }  \\n            }\\n            \\n           else if(dir==\\'n\\')\\n            {     \\n            int req = y-j;\\n            if(mov<=req)\\n            {\\n                j+= mov;\\n                break;\\n            }\\n            else\\n             {\\n                  mov = mov -req;\\n                  j+= req;\\n                 dir =\\'w\\' ;   \\n             }  \\n            }\\n            \\n             else if(dir==\\'w\\')\\n            {     \\n            int req = i;\\n            if(mov<=req)\\n            {\\n                i-= mov;\\n                break;\\n            }\\n            else\\n             {\\n                  mov = mov -req;\\n                  i-= req;\\n                 dir =\\'s\\' ;   \\n             }  \\n            }\\n            \\n            else if(dir==\\'s\\')\\n            {     \\n            int req = j;\\n            if(mov<=req)\\n            {\\n                j-= mov;\\n                break;\\n            }\\n            else\\n             {\\n                  mov = mov -req;\\n                  j-= req;\\n                 dir =\\'e\\' ;   \\n             }  \\n            }\\n        }\\n       \\n    }\\n    \\n    vector<int> getPos() { \\n        return {i,j};\\n    }\\n    \\n    string getDir() {\\n\\n       if(dir==\\'e\\')\\n           return \"East\";\\n        else if(dir==\\'w\\')\\n            return \"West\";\\n        else if(dir==\\'n\\')\\n            return \"North\";\\n        else\\n            return \"South\";\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1576285,
                "title": "easy-to-undesrstand-python-o-m-n",
                "content": "```\\nclass Robot:\\n\\n    def __init__(self, width: int, height: int):\\n        self.width = width\\n        self.height = height\\n        self.pos = (0, 0)\\n        self.dirs =[\"East\", \"North\", \"West\", \"South\"]\\n        self.cur_dir = 0\\n        self.has_moved = False\\n        \\n    def move(self, num: int) -> None:\\n        \\n        num %= ((self.width + self.height)* 2 - 4)\\n        self.has_moved = True\\n        \\n        while num:\\n            if self.dirs[self.cur_dir] == \"East\":\\n                if self.pos[0] + 1 in range(self.width):\\n                    self.pos = (self.pos[0] + 1, self.pos[1])\\n                    num -= 1\\n                else:\\n                    self.cur_dir = (self.cur_dir + 1) % 4\\n                    \\n            elif self.dirs[self.cur_dir] == \"North\":\\n                if self.pos[1] + 1 in range(self.height):\\n                    self.pos = (self.pos[0], self.pos[1] + 1)\\n                    num -= 1\\n                else:\\n                    self.cur_dir = (self.cur_dir + 1) % 4\\n                \\n            elif self.dirs[self.cur_dir] == \"West\":\\n                if self.pos[0] - 1 in range(self.width):\\n                    self.pos = (self.pos[0] - 1, self.pos[1])\\n                    num -= 1\\n                else:\\n                    self.cur_dir = (self.cur_dir + 1) % 4\\n            \\n            else:\\n                if self.pos[1] - 1 in range(self.height):\\n                    self.pos = (self.pos[0], self.pos[1] - 1)\\n                    num -= 1\\n                else:\\n                    self.cur_dir = (self.cur_dir + 1) % 4\\n        \\n        \\n    def getPos(self) -> List[int]:\\n        \\n        return self.pos\\n\\n    def getDir(self) -> str:\\n        \\n        if self.getPos() == (0, 0) and self.has_moved:\\n            return \"South\"\\n        \\n        return self.dirs[self.cur_dir]\\n        \\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Robot:\\n\\n    def __init__(self, width: int, height: int):\\n        self.width = width\\n        self.height = height\\n        self.pos = (0, 0)\\n        self.dirs =[\"East\", \"North\", \"West\", \"South\"]\\n        self.cur_dir = 0\\n        self.has_moved = False\\n        \\n    def move(self, num: int) -> None:\\n        \\n        num %= ((self.width + self.height)* 2 - 4)\\n        self.has_moved = True\\n        \\n        while num:\\n            if self.dirs[self.cur_dir] == \"East\":\\n                if self.pos[0] + 1 in range(self.width):\\n                    self.pos = (self.pos[0] + 1, self.pos[1])\\n                    num -= 1\\n                else:\\n                    self.cur_dir = (self.cur_dir + 1) % 4\\n                    \\n            elif self.dirs[self.cur_dir] == \"North\":\\n                if self.pos[1] + 1 in range(self.height):\\n                    self.pos = (self.pos[0], self.pos[1] + 1)\\n                    num -= 1\\n                else:\\n                    self.cur_dir = (self.cur_dir + 1) % 4\\n                \\n            elif self.dirs[self.cur_dir] == \"West\":\\n                if self.pos[0] - 1 in range(self.width):\\n                    self.pos = (self.pos[0] - 1, self.pos[1])\\n                    num -= 1\\n                else:\\n                    self.cur_dir = (self.cur_dir + 1) % 4\\n            \\n            else:\\n                if self.pos[1] - 1 in range(self.height):\\n                    self.pos = (self.pos[0], self.pos[1] - 1)\\n                    num -= 1\\n                else:\\n                    self.cur_dir = (self.cur_dir + 1) % 4\\n        \\n        \\n    def getPos(self) -> List[int]:\\n        \\n        return self.pos\\n\\n    def getDir(self) -> str:\\n        \\n        if self.getPos() == (0, 0) and self.has_moved:\\n            return \"South\"\\n        \\n        return self.dirs[self.cur_dir]\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576280,
                "title": "python-easy-to-understand",
                "content": "```\\nclass Robot:\\n\\n    def __init__(self, width: int, height: int):\\n        self.w = width\\n        self.h = height\\n        self.d = 0\\n        self.dir = [\\'East\\',\\'North\\',\\'West\\',\\'South\\']\\n        self.x,self.y = 0,0\\n        self.dx = [1,0,-1,0]\\n        self.dy = [0,1,0,-1]\\n        \\n\\n    def move(self, num: int) -> None:\\n        _max = 2*self.w + 2* self.h - 4\\n        num %= _max\\n        if num == 0:\\n            if self.x == 0 and self.y == 0:\\n                self.d = 3\\n            if self.x == self.w -1 and self.y ==0:\\n                self.d = 0\\n            if self.x == self.w -1 and self.y == self.h - 1:\\n                self.d = 1\\n            if self.x == 0 and self.y == self.h - 1:\\n                self.d = 2\\n        \\n        for i in range(num,0,-1):\\n            nx = self.dx[self.d] + self.x\\n            ny = self.dy[self.d] + self.y\\n            if nx < 0 or nx >= self.w or ny < 0 or ny >= self.h:\\n                self.d +=1\\n                self.d %=4\\n                nx = self.dx[self.d] + self.x\\n                ny = self.dy[self.d] + self.y\\n            self.x = nx\\n            self.y = ny\\n\\n    def getPos(self) -> List[int]:\\n        return [self.x,self.y]        \\n\\n    def getDir(self) -> str:\\n        return self.dir[self.d]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Robot:\\n\\n    def __init__(self, width: int, height: int):\\n        self.w = width\\n        self.h = height\\n        self.d = 0\\n        self.dir = [\\'East\\',\\'North\\',\\'West\\',\\'South\\']\\n        self.x,self.y = 0,0\\n        self.dx = [1,0,-1,0]\\n        self.dy = [0,1,0,-1]\\n        \\n\\n    def move(self, num: int) -> None:\\n        _max = 2*self.w + 2* self.h - 4\\n        num %= _max\\n        if num == 0:\\n            if self.x == 0 and self.y == 0:\\n                self.d = 3\\n            if self.x == self.w -1 and self.y ==0:\\n                self.d = 0\\n            if self.x == self.w -1 and self.y == self.h - 1:\\n                self.d = 1\\n            if self.x == 0 and self.y == self.h - 1:\\n                self.d = 2\\n        \\n        for i in range(num,0,-1):\\n            nx = self.dx[self.d] + self.x\\n            ny = self.dy[self.d] + self.y\\n            if nx < 0 or nx >= self.w or ny < 0 or ny >= self.h:\\n                self.d +=1\\n                self.d %=4\\n                nx = self.dx[self.d] + self.x\\n                ny = self.dy[self.d] + self.y\\n            self.x = nx\\n            self.y = ny\\n\\n    def getPos(self) -> List[int]:\\n        return [self.x,self.y]        \\n\\n    def getDir(self) -> str:\\n        return self.dir[self.d]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576272,
                "title": "python-easy-to-understand",
                "content": "\"\"\"\\nclass Robot:\\n\\n    def __init__(self, width: int, height: int):\\n        self.grid = [[0 for i in range(width)] for j in range(height)]\\n        self.width = width\\n        self.height = height\\n        self.curr = [0,0]\\n        self.direction = 0\\n        self.dic = {0:\\'East\\',1:\\'North\\',2:\\'West\\',3:\\'South\\'}\\n        self.movement = [[1,0],[0,1],[-1,0],[0,-1]]\\n        \\n\\n    def move(self, num: int) -> None:\\n        num = num % (2*(self.width+self.height-2))\\n        \\n        if num == 0:\\n            num = 2*(self.width+self.height-2)\\n        \\n        index = self.direction\\n        currpos = self.getPos()\\n        move = self.movement[index]\\n        \\n        currx = currpos[0]\\n        curry = currpos[1]\\n        while(0<=currx+move[0]<self.width and 0<=curry+move[1]<self.height and num>0):\\n            currx = currx+move[0]\\n            curry = curry+move[1]\\n            num = num - 1\\n        self.curr = [currx,curry]\\n        if num>0:\\n            self.direction = (self.direction+1)%4\\n            self.move(num)\\n\\n        \\n\\n    def getPos(self) -> List[int]:\\n        return self.curr\\n        \\n\\n    def getDir(self) -> str:\\n        return self.dic[self.direction]\\n\\n\\n\"\"\"",
                "solutionTags": [],
                "code": "\"\"\"\\nclass Robot:\\n\\n    def __init__(self, width: int, height: int):\\n        self.grid = [[0 for i in range(width)] for j in range(height)]\\n        self.width = width\\n        self.height = height\\n        self.curr = [0,0]\\n        self.direction = 0\\n        self.dic = {0:\\'East\\',1:\\'North\\',2:\\'West\\',3:\\'South\\'}\\n        self.movement = [[1,0],[0,1],[-1,0],[0,-1]]\\n        \\n\\n    def move(self, num: int) -> None:\\n        num = num % (2*(self.width+self.height-2))\\n        \\n        if num == 0:\\n            num = 2*(self.width+self.height-2)\\n        \\n        index = self.direction\\n        currpos = self.getPos()\\n        move = self.movement[index]\\n        \\n        currx = currpos[0]\\n        curry = currpos[1]\\n        while(0<=currx+move[0]<self.width and 0<=curry+move[1]<self.height and num>0):\\n            currx = currx+move[0]\\n            curry = curry+move[1]\\n            num = num - 1\\n        self.curr = [currx,curry]\\n        if num>0:\\n            self.direction = (self.direction+1)%4\\n            self.move(num)\\n\\n        \\n\\n    def getPos(self) -> List[int]:\\n        return self.curr\\n        \\n\\n    def getDir(self) -> str:\\n        return self.dic[self.direction]\\n\\n\\n\"\"\"",
                "codeTag": "Java"
            },
            {
                "id": 1576252,
                "title": "java-solution-which-you-can-easily-grasp",
                "content": "```\\nclass Robot {\\n    int i=0,j=0;\\n    int dir=3;//initally we will change the direction to east so kept it south so as when move func call->sets to east\\n    //east-0,north-1,west-2,south-3\\n    int arr[][];\\n    boolean firstmovetillnow=false;\\n    //anit-clockwise order with 90 deg turn when we reach a one\\n    public Robot(int width, int height) { \\n        arr=new int[height][width];\\n        //placed 1 at every corner \\n        arr[0][0]=1;\\n        arr[height-1][0]=1;\\n        arr[0][width-1]=1;\\n        arr[height-1][width-1]=1;\\n    }\\n    \\n    public void move(int num) {\\n    firstmovetillnow=true;\\n     num=num%(2*(arr.length+arr[0].length)-4);//num steps produced cycle steps are removed \\n     while(num-->0)\\n        {\\n            dir=(dir+arr[i][j])%4;//direction change after reaching a corner\\n            if(dir==0)\\n            {\\n             j++; \\n             if(j==arr[0].length-1)\\n             {\\n                 continue;\\n             }\\n            }else if(dir==1){\\n              i++;\\n              if(i==arr.length-1)\\n             {\\n                 continue;\\n             }\\n            }\\n            else if(dir==2){\\n              j--;  \\n             if(j==0)\\n             {\\n                 continue;\\n             }\\n            }\\n            else if(dir==3){\\n              i--;\\n              if(i==0)\\n             {\\n                 continue;\\n             }\\n            }\\n         }\\n    }\\n    \\n    public int[] getPos() {\\n        return new int[]{j,i};\\n    }\\n    \\n    public String getDir() {\\n    if(firstmovetillnow==false)//for the case when move function isn\\'t called till now but direction aksed \\n        return \"East\";\\n        \\n     if(dir==0)\\n         return \"East\";\\n     else if(dir==1)\\n         return \"North\";\\n     else if(dir==2)\\n         return \"West\";\\n     else \\n         return \"South\";\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Robot {\\n    int i=0,j=0;\\n    int dir=3;//initally we will change the direction to east so kept it south so as when move func call->sets to east\\n    //east-0,north-1,west-2,south-3\\n    int arr[][];\\n    boolean firstmovetillnow=false;\\n    //anit-clockwise order with 90 deg turn when we reach a one\\n    public Robot(int width, int height) { \\n        arr=new int[height][width];\\n        //placed 1 at every corner \\n        arr[0][0]=1;\\n        arr[height-1][0]=1;\\n        arr[0][width-1]=1;\\n        arr[height-1][width-1]=1;\\n    }\\n    \\n    public void move(int num) {\\n    firstmovetillnow=true;\\n     num=num%(2*(arr.length+arr[0].length)-4);//num steps produced cycle steps are removed \\n     while(num-->0)\\n        {\\n            dir=(dir+arr[i][j])%4;//direction change after reaching a corner\\n            if(dir==0)\\n            {\\n             j++; \\n             if(j==arr[0].length-1)\\n             {\\n                 continue;\\n             }\\n            }else if(dir==1){\\n              i++;\\n              if(i==arr.length-1)\\n             {\\n                 continue;\\n             }\\n            }\\n            else if(dir==2){\\n              j--;  \\n             if(j==0)\\n             {\\n                 continue;\\n             }\\n            }\\n            else if(dir==3){\\n              i--;\\n              if(i==0)\\n             {\\n                 continue;\\n             }\\n            }\\n         }\\n    }\\n    \\n    public int[] getPos() {\\n        return new int[]{j,i};\\n    }\\n    \\n    public String getDir() {\\n    if(firstmovetillnow==false)//for the case when move function isn\\'t called till now but direction aksed \\n        return \"East\";\\n        \\n     if(dir==0)\\n         return \"East\";\\n     else if(dir==1)\\n         return \"North\";\\n     else if(dir==2)\\n         return \"West\";\\n     else \\n         return \"South\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576212,
                "title": "c-flat-the-index",
                "content": "```\\nclass Robot {\\npublic:\\n    Robot(int width, int height) : w(width), h(height), a{width - 1, height - 1, width - 1} {}\\n    \\n    void move(int num) {\\n        f = 1;\\n        int t = (w + w + h + h) - 4;\\n        l = (l + num) % t;\\n    }\\n    // [2w + h - 2 ~ 0][1 ~ w - 1] [w ~ w + h - 2] [w + h - 1 ~ 2w + h - 3]\\n    vector<int> getPos() {\\n        int t = l, r = -1, c;\\n        if (!t) return {0, 0};\\n        if (a[0] >= t) return {t, 0};\\n        t -= a[0];\\n        if (a[1] >= t) return {w - 1, t};\\n        t -= a[1];\\n        if (a[2] >= t) return {w - t - 1, h - 1};\\n        t -= a[2];\\n        return {0, h - t - 1};\\n    }\\n    \\n    string getDir() {\\n        if (!f) return \"East\";\\n        if (!l) return \"South\";\\n        int t = l;\\n        if (!t) return {0, 0};\\n        for (int i = 0; i < 3; i++) {\\n            if (t > a[i]) t -= a[i];\\n            else return d[i];\\n        }\\n        return d[3];\\n    }\\n    string d[4] = {\"East\", \"North\", \"West\", \"South\"};\\n    int a[3];\\n    int w, h, l = 0, f = 0;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Robot {\\npublic:\\n    Robot(int width, int height) : w(width), h(height), a{width - 1, height - 1, width - 1} {}\\n    \\n    void move(int num) {\\n        f = 1;\\n        int t = (w + w + h + h) - 4;\\n        l = (l + num) % t;\\n    }\\n    // [2w + h - 2 ~ 0][1 ~ w - 1] [w ~ w + h - 2] [w + h - 1 ~ 2w + h - 3]\\n    vector<int> getPos() {\\n        int t = l, r = -1, c;\\n        if (!t) return {0, 0};\\n        if (a[0] >= t) return {t, 0};\\n        t -= a[0];\\n        if (a[1] >= t) return {w - 1, t};\\n        t -= a[1];\\n        if (a[2] >= t) return {w - t - 1, h - 1};\\n        t -= a[2];\\n        return {0, h - t - 1};\\n    }\\n    \\n    string getDir() {\\n        if (!f) return \"East\";\\n        if (!l) return \"South\";\\n        int t = l;\\n        if (!t) return {0, 0};\\n        for (int i = 0; i < 3; i++) {\\n            if (t > a[i]) t -= a[i];\\n            else return d[i];\\n        }\\n        return d[3];\\n    }\\n    string d[4] = {\"East\", \"North\", \"West\", \"South\"};\\n    int a[3];\\n    int w, h, l = 0, f = 0;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576210,
                "title": "c-a-simple-solution-to-fix-the-corner-cases",
                "content": "1. The basic idea to get rid of most of the TLE case is to compute the circumference of the grid  `circ = 2*(w+h)-4`  and `num  = num % circ ` when the robot meets an edge.\\n2. One corner case is when the robot is stuck at the corners and the resulting direction will be wrong. In principle, you can iterate through all the cases for each corner and the lauching directions and this fix seems to be tedious. One easy fix I would like to propose is to take one more move by calling `move(1)` to move the robot out of the corner so that it is attaching to an edge instead of a corner. The direction will be correct in this way.\\n\\n```\\n\\nclass Robot {\\npublic:\\n    Robot(int width, int height) {\\n        w = width;\\n        h = height;\\n        circ = 2*(w+h)-4;\\n        x = 0;\\n        y = 0;\\n        d = 0;\\n        sDir = {\"East\",\"North\",\"West\",\"South\"}; \\n        moves = {{1,0}, {0,1}, {-1,0}, {0,-1}};  \\n    }\\n    \\n    void move(int num) {\\n        while(num>0){\\n            int m = -1;\\n            if(d==0){\\n                m = min(num, w-1-x);\\n            }else if(d==1){\\n                m = min(num,h-1-y);\\n            }else if(d==2){\\n                m = min(num,x);\\n            }else if(d==3){\\n                m = min(num,y);\\n            }\\n            if(m==0){\\n                d = (d+1)%4;\\n                if((x==0 && y==0) || (x==0 && y==h-1) || (x==w-1 && y==0) || (x==w-1 && y==h-1)){\\n                    move(1);\\n                    num -=1;\\n                }\\n                num = num%circ;\\n                continue;\\n            }\\n            x = x + moves[d].first *m;\\n            y = y + moves[d].second * m;\\n            num -= m;\\n        } \\n    }\\n    \\n    vector<int> getPos() {\\n        return {x,y}; \\n    }\\n    \\n    string getDir() {\\n        return sDir[d]; \\n    }\\n    int w;\\n    int h;\\n    int circ;\\n    int x;\\n    int y;\\n    int d;\\n    vector<pair<int,int> > moves;\\n    vector<string> sDir;\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Robot {\\npublic:\\n    Robot(int width, int height) {\\n        w = width;\\n        h = height;\\n        circ = 2*(w+h)-4;\\n        x = 0;\\n        y = 0;\\n        d = 0;\\n        sDir = {\"East\",\"North\",\"West\",\"South\"}; \\n        moves = {{1,0}, {0,1}, {-1,0}, {0,-1}};  \\n    }\\n    \\n    void move(int num) {\\n        while(num>0){\\n            int m = -1;\\n            if(d==0){\\n                m = min(num, w-1-x);\\n            }else if(d==1){\\n                m = min(num,h-1-y);\\n            }else if(d==2){\\n                m = min(num,x);\\n            }else if(d==3){\\n                m = min(num,y);\\n            }\\n            if(m==0){\\n                d = (d+1)%4;\\n                if((x==0 && y==0) || (x==0 && y==h-1) || (x==w-1 && y==0) || (x==w-1 && y==h-1)){\\n                    move(1);\\n                    num -=1;\\n                }\\n                num = num%circ;\\n                continue;\\n            }\\n            x = x + moves[d].first *m;\\n            y = y + moves[d].second * m;\\n            num -= m;\\n        } \\n    }\\n    \\n    vector<int> getPos() {\\n        return {x,y}; \\n    }\\n    \\n    string getDir() {\\n        return sDir[d]; \\n    }\\n    int w;\\n    int h;\\n    int circ;\\n    int x;\\n    int y;\\n    int d;\\n    vector<pair<int,int> > moves;\\n    vector<string> sDir;\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576186,
                "title": "c-explained-and-easy-solution-faster-than-90",
                "content": "The approach is simple ,  taking three variables to take the length of all three sides and the length of all 4 sides on total . Taking a flag variable , in case `getDir` is asked before making any move.  \\n\\n```\\nclass Robot {\\npublic:\\n    int position = 0,total,x1,y1,x2,w,h;\\n    bool flag = true;\\n    Robot(int width, int height) {\\n        w = width;\\n        h = height;\\n        total = 2*(w+h)-4;\\n        x1 = w;         //taking just the 1st side\\n        y1 = w + h - 1;    // taking 1st and 2nd sides\\n        x2 = (2*w+h)-2;    // taking the 3rd side and the prev two sides \\n    }\\n    \\n    void move(int num) {\\n        flag = false;\\n        position = (position+num)%total;\\n        // cout<<position<<endl;\\n    }\\n    \\n    vector<int> getPos() {\\n        \\n        if(position<x1)     \\n            return {position,0};    \\n        if(position<y1)\\n            return {w-1,position-x1+1};\\n        if(position<x2)\\n            return {x2-position-1,h-1};\\n        return {0,total-position};\\n    }\\n    \\n    string getDir() {\\n        if(flag)\\n            return \"East\";\\n        if(position==0)\\n            return \"South\";\\n        if(position<x1)\\n            return \"East\";\\n        if(position<y1)\\n            return \"North\";\\n        if(position<x2)\\n            return \"West\";\\n        return \"South\";\\n    }\\n};\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot* obj = new Robot(width, height);\\n * obj->move(num);\\n * vector<int> param_2 = obj->getPos();\\n * string param_3 = obj->getDir();\\n */\\n ```\\n **If you like it , Do upvote\\n Happy Coding;**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Robot {\\npublic:\\n    int position = 0,total,x1,y1,x2,w,h;\\n    bool flag = true;\\n    Robot(int width, int height) {\\n        w = width;\\n        h = height;\\n        total = 2*(w+h)-4;\\n        x1 = w;         //taking just the 1st side\\n        y1 = w + h - 1;    // taking 1st and 2nd sides\\n        x2 = (2*w+h)-2;    // taking the 3rd side and the prev two sides \\n    }\\n    \\n    void move(int num) {\\n        flag = false;\\n        position = (position+num)%total;\\n        // cout<<position<<endl;\\n    }\\n    \\n    vector<int> getPos() {\\n        \\n        if(position<x1)     \\n            return {position,0};    \\n        if(position<y1)\\n            return {w-1,position-x1+1};\\n        if(position<x2)\\n            return {x2-position-1,h-1};\\n        return {0,total-position};\\n    }\\n    \\n    string getDir() {\\n        if(flag)\\n            return \"East\";\\n        if(position==0)\\n            return \"South\";\\n        if(position<x1)\\n            return \"East\";\\n        if(position<y1)\\n            return \"North\";\\n        if(position<x2)\\n            return \"West\";\\n        return \"South\";\\n    }\\n};\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot* obj = new Robot(width, height);\\n * obj->move(num);\\n * vector<int> param_2 = obj->getPos();\\n * string param_3 = obj->getDir();\\n */\\n ```",
                "codeTag": "C++"
            },
            {
                "id": 1576172,
                "title": "c-o-1-for-each-call-solution",
                "content": "```\\nclass Robot \\n{\\n    public:\\n    int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\\n    string a[4]={\"East\",\"North\",\"West\",\"South\"};\\n    int d=3,x=0,y=0;\\n    int w,h,p;\\n    bool f=false;\\n    Robot(int width, int height) \\n    {\\n        w=width,h=height,p=2*(w+h-2);\\n    }\\n    \\n    void move(int num) \\n    {\\n        f=true;\\n        num%=p;\\n        while(num>0)\\n        {\\n            if((x==0&&d==2)||(y==0&&d==3)||(x==w-1&&d==0)||(y==h-1&&d==1)) d=(d+1)&3;\\n            int step;\\n            \\n            if(d==0) step=min(num,w-1-x);\\n            else if(d==1) step=min(num,h-1-y);\\n            else if(d==2) step=min(num,x);\\n            else step=min(num,y);\\n            \\n            x+=dx[d]*step;\\n            y+=dy[d]*step;\\n            num-=step;\\n        }\\n    }\\n    \\n    vector<int> getPos() \\n    {\\n        return {x,y};\\n    }\\n    \\n    string getDir() \\n    {\\n        if(!f) return \"East\";\\n        return a[d];\\n    }\\n};\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot* obj = new Robot(width, height);\\n * obj->move(num);\\n * vector<int> param_2 = obj->getPos();\\n * string param_3 = obj->getDir();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass Robot \\n{\\n    public:\\n    int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\\n    string a[4]={\"East\",\"North\",\"West\",\"South\"};\\n    int d=3,x=0,y=0;\\n    int w,h,p;\\n    bool f=false;\\n    Robot(int width, int height) \\n    {\\n        w=width,h=height,p=2*(w+h-2);\\n    }\\n    \\n    void move(int num) \\n    {\\n        f=true;\\n        num%=p;\\n        while(num>0)\\n        {\\n            if((x==0&&d==2)||(y==0&&d==3)||(x==w-1&&d==0)||(y==h-1&&d==1)) d=(d+1)&3;\\n            int step;\\n            \\n            if(d==0) step=min(num,w-1-x);\\n            else if(d==1) step=min(num,h-1-y);\\n            else if(d==2) step=min(num,x);\\n            else step=min(num,y);\\n            \\n            x+=dx[d]*step;\\n            y+=dy[d]*step;\\n            num-=step;\\n        }\\n    }\\n    \\n    vector<int> getPos() \\n    {\\n        return {x,y};\\n    }\\n    \\n    string getDir() \\n    {\\n        if(!f) return \"East\";\\n        return a[d];\\n    }\\n};\\n\\n/**\\n * Your Robot object will be instantiated and called as such:\\n * Robot* obj = new Robot(width, height);\\n * obj->move(num);\\n * vector<int> param_2 = obj->getPos();\\n * string param_3 = obj->getDir();\\n */\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564907,
                "content": [
                    {
                        "username": "philipxyc",
                        "content": "I was troubled by this problem for an hour. Finally, I figure out, if you write a logic `num%=2*w+2*h-4`, think about what the direction will be if `num==2*w+2*h-4`. \\ne.g., after the first move of num=4 in 2x2 grid, the direction should be South instead of East.\\n\\nThis means if the robot starts from the beginning, and it moves the num equals to the diameter, its direction should be clockwise turned 90 degree."
                    },
                    {
                        "username": "neuergloves",
                        "content": "Figured out the modulus during contest, wrote the python code. Figuered simulating over `100x100=1000` in linear time should be fine, however in contest got TLE.\\nAfter the contest ended, I submit the same code, but got accepted...\\nLC please take a look!"
                    },
                    {
                        "username": "llivejo",
                        "content": "[UPD] Solved by LeetCode: Robot.move() method renamed to step() \\n\\n======\\nEven if I escape function name as \"r#move\", Leetcode own code gives compile error:\\n\\nCompile Error\\nLine 65, Char 22: expected identifier, found keyword `move` (solution.rs)\\n   |\\n65 |     let result = obj.move(Deserializer::to_int(args[0].as_str()).unwrap());\\n   |                      ^^^^ expected identifier, found keyword\\n   |\\nhelp: you can escape reserved keywords to use them as identifiers\\n   |\\n65 |     let result = obj.r#move(Deserializer::to_int(args[0].as_str()).unwrap());\\n   |                      ^^^^^^\\nerror: aborting due to previous error"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "that was an ugly corner case.\\npun intended..."
                    },
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "Dont bother with simulation with modulus either for every time you take a step . \\nInitiate robot and make one pass across the perimeter and save the location and the steps it took along wid its distance from (0,0) and the direction it inherited in hashmap s. \\nEverytime u add  num steps , get the modulus of num steps + steps it took to reach current position   by perimeter and den return corresponding hashmap vals"
                    }
                ]
            },
            {
                "id": 1575963,
                "content": [
                    {
                        "username": "philipxyc",
                        "content": "I was troubled by this problem for an hour. Finally, I figure out, if you write a logic `num%=2*w+2*h-4`, think about what the direction will be if `num==2*w+2*h-4`. \\ne.g., after the first move of num=4 in 2x2 grid, the direction should be South instead of East.\\n\\nThis means if the robot starts from the beginning, and it moves the num equals to the diameter, its direction should be clockwise turned 90 degree."
                    },
                    {
                        "username": "neuergloves",
                        "content": "Figured out the modulus during contest, wrote the python code. Figuered simulating over `100x100=1000` in linear time should be fine, however in contest got TLE.\\nAfter the contest ended, I submit the same code, but got accepted...\\nLC please take a look!"
                    },
                    {
                        "username": "llivejo",
                        "content": "[UPD] Solved by LeetCode: Robot.move() method renamed to step() \\n\\n======\\nEven if I escape function name as \"r#move\", Leetcode own code gives compile error:\\n\\nCompile Error\\nLine 65, Char 22: expected identifier, found keyword `move` (solution.rs)\\n   |\\n65 |     let result = obj.move(Deserializer::to_int(args[0].as_str()).unwrap());\\n   |                      ^^^^ expected identifier, found keyword\\n   |\\nhelp: you can escape reserved keywords to use them as identifiers\\n   |\\n65 |     let result = obj.r#move(Deserializer::to_int(args[0].as_str()).unwrap());\\n   |                      ^^^^^^\\nerror: aborting due to previous error"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "that was an ugly corner case.\\npun intended..."
                    },
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "Dont bother with simulation with modulus either for every time you take a step . \\nInitiate robot and make one pass across the perimeter and save the location and the steps it took along wid its distance from (0,0) and the direction it inherited in hashmap s. \\nEverytime u add  num steps , get the modulus of num steps + steps it took to reach current position   by perimeter and den return corresponding hashmap vals"
                    }
                ]
            },
            {
                "id": 1570671,
                "content": [
                    {
                        "username": "philipxyc",
                        "content": "I was troubled by this problem for an hour. Finally, I figure out, if you write a logic `num%=2*w+2*h-4`, think about what the direction will be if `num==2*w+2*h-4`. \\ne.g., after the first move of num=4 in 2x2 grid, the direction should be South instead of East.\\n\\nThis means if the robot starts from the beginning, and it moves the num equals to the diameter, its direction should be clockwise turned 90 degree."
                    },
                    {
                        "username": "neuergloves",
                        "content": "Figured out the modulus during contest, wrote the python code. Figuered simulating over `100x100=1000` in linear time should be fine, however in contest got TLE.\\nAfter the contest ended, I submit the same code, but got accepted...\\nLC please take a look!"
                    },
                    {
                        "username": "llivejo",
                        "content": "[UPD] Solved by LeetCode: Robot.move() method renamed to step() \\n\\n======\\nEven if I escape function name as \"r#move\", Leetcode own code gives compile error:\\n\\nCompile Error\\nLine 65, Char 22: expected identifier, found keyword `move` (solution.rs)\\n   |\\n65 |     let result = obj.move(Deserializer::to_int(args[0].as_str()).unwrap());\\n   |                      ^^^^ expected identifier, found keyword\\n   |\\nhelp: you can escape reserved keywords to use them as identifiers\\n   |\\n65 |     let result = obj.r#move(Deserializer::to_int(args[0].as_str()).unwrap());\\n   |                      ^^^^^^\\nerror: aborting due to previous error"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "that was an ugly corner case.\\npun intended..."
                    },
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "Dont bother with simulation with modulus either for every time you take a step . \\nInitiate robot and make one pass across the perimeter and save the location and the steps it took along wid its distance from (0,0) and the direction it inherited in hashmap s. \\nEverytime u add  num steps , get the modulus of num steps + steps it took to reach current position   by perimeter and den return corresponding hashmap vals"
                    }
                ]
            },
            {
                "id": 2049735,
                "content": [
                    {
                        "username": "philipxyc",
                        "content": "I was troubled by this problem for an hour. Finally, I figure out, if you write a logic `num%=2*w+2*h-4`, think about what the direction will be if `num==2*w+2*h-4`. \\ne.g., after the first move of num=4 in 2x2 grid, the direction should be South instead of East.\\n\\nThis means if the robot starts from the beginning, and it moves the num equals to the diameter, its direction should be clockwise turned 90 degree."
                    },
                    {
                        "username": "neuergloves",
                        "content": "Figured out the modulus during contest, wrote the python code. Figuered simulating over `100x100=1000` in linear time should be fine, however in contest got TLE.\\nAfter the contest ended, I submit the same code, but got accepted...\\nLC please take a look!"
                    },
                    {
                        "username": "llivejo",
                        "content": "[UPD] Solved by LeetCode: Robot.move() method renamed to step() \\n\\n======\\nEven if I escape function name as \"r#move\", Leetcode own code gives compile error:\\n\\nCompile Error\\nLine 65, Char 22: expected identifier, found keyword `move` (solution.rs)\\n   |\\n65 |     let result = obj.move(Deserializer::to_int(args[0].as_str()).unwrap());\\n   |                      ^^^^ expected identifier, found keyword\\n   |\\nhelp: you can escape reserved keywords to use them as identifiers\\n   |\\n65 |     let result = obj.r#move(Deserializer::to_int(args[0].as_str()).unwrap());\\n   |                      ^^^^^^\\nerror: aborting due to previous error"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "that was an ugly corner case.\\npun intended..."
                    },
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "Dont bother with simulation with modulus either for every time you take a step . \\nInitiate robot and make one pass across the perimeter and save the location and the steps it took along wid its distance from (0,0) and the direction it inherited in hashmap s. \\nEverytime u add  num steps , get the modulus of num steps + steps it took to reach current position   by perimeter and den return corresponding hashmap vals"
                    }
                ]
            },
            {
                "id": 1752048,
                "content": [
                    {
                        "username": "philipxyc",
                        "content": "I was troubled by this problem for an hour. Finally, I figure out, if you write a logic `num%=2*w+2*h-4`, think about what the direction will be if `num==2*w+2*h-4`. \\ne.g., after the first move of num=4 in 2x2 grid, the direction should be South instead of East.\\n\\nThis means if the robot starts from the beginning, and it moves the num equals to the diameter, its direction should be clockwise turned 90 degree."
                    },
                    {
                        "username": "neuergloves",
                        "content": "Figured out the modulus during contest, wrote the python code. Figuered simulating over `100x100=1000` in linear time should be fine, however in contest got TLE.\\nAfter the contest ended, I submit the same code, but got accepted...\\nLC please take a look!"
                    },
                    {
                        "username": "llivejo",
                        "content": "[UPD] Solved by LeetCode: Robot.move() method renamed to step() \\n\\n======\\nEven if I escape function name as \"r#move\", Leetcode own code gives compile error:\\n\\nCompile Error\\nLine 65, Char 22: expected identifier, found keyword `move` (solution.rs)\\n   |\\n65 |     let result = obj.move(Deserializer::to_int(args[0].as_str()).unwrap());\\n   |                      ^^^^ expected identifier, found keyword\\n   |\\nhelp: you can escape reserved keywords to use them as identifiers\\n   |\\n65 |     let result = obj.r#move(Deserializer::to_int(args[0].as_str()).unwrap());\\n   |                      ^^^^^^\\nerror: aborting due to previous error"
                    },
                    {
                        "username": "BitBlaster",
                        "content": "that was an ugly corner case.\\npun intended..."
                    },
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "Dont bother with simulation with modulus either for every time you take a step . \\nInitiate robot and make one pass across the perimeter and save the location and the steps it took along wid its distance from (0,0) and the direction it inherited in hashmap s. \\nEverytime u add  num steps , get the modulus of num steps + steps it took to reach current position   by perimeter and den return corresponding hashmap vals"
                    }
                ]
            }
        ]
    }
]