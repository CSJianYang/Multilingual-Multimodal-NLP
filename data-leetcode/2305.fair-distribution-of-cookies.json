[
    {
        "title": "Maximum Candies Allocated to K Children",
        "question_content": "You are given a 0-indexed integer array candies. Each element in the array denotes a pile of candies of size candies[i]. You can divide each pile into any number of sub piles, but you cannot merge two piles together.\nYou are also given an integer k. You should allocate piles of candies to k children such that each child gets the same number of candies. Each child can take at most one pile of candies and some piles of candies may go unused.\nReturn the maximum number of candies each child can get.\n&nbsp;\nExample 1:\n\nInput: candies = [5,8,6], k = 3\nOutput: 5\nExplanation: We can divide candies[1] into 2 piles of size 5 and 3, and candies[2] into 2 piles of size 5 and 1. We now have five piles of candies of sizes 5, 5, 3, 5, and 1. We can allocate the 3 piles of size 5 to 3 children. It can be proven that each child cannot receive more than 5 candies.\n\nExample 2:\n\nInput: candies = [2,5], k = 11\nOutput: 0\nExplanation: There are 11 children but only 7 candies in total, so it is impossible to ensure each child receives at least one candy. Thus, each child gets no candy and the answer is 0.\n\n&nbsp;\nConstraints:\n\n\t1 <= candies.length <= 105\n\t1 <= candies[i] <= 107\n\t1 <= k <= 1012",
        "solutions": [
            {
                "id": 1908888,
                "title": "java-c-python-binary-search-with-explanation",
                "content": "# **Intuition**\\nBinary search\\n<br>\\n\\n# **Explanation**\\nAssume we want give each child `m` candies, for each pile of `candies[i]`,\\nwe can divide out at most `candies[i] / m` sub piles with each pile `m` candies.\\n\\nWe can sum up all the sub piles we can divide out, then compare with the `k` children.\\n\\nIf `k > sum`, \\nwe don\\'t allocate to every child, \\nsince the pile of `m` candidies it too big,\\nso we assign `right = m - 1`.\\n\\nIf `k <= sum`, \\nwe are able to allocate to every child, \\nsince the pile of `m` candidies is small enough\\nso we assign `left = m`.\\n\\nWe repeatly do this until `left == right`, and that\\'s the maximum number of candies each child can get.\\n<br>\\n\\n# **Tips**\\nTip1.  `left < right` Vs `left <= right`\\n\\nCheck all my solution, I keep using `left < right`.\\nThe easy but important approach: \\nfollow and upvote my codes,\\ntry to do the same.\\nyou\\'ll find all binary search is similar,\\nnever bother thinking it anymore.\\n\\nTip2. `mid = (left + right + 1) / 2` Vs `mid = (left + right) / 2`\\n\\n`mid = (left + right) / 2` to find **first** element valid\\n`mid = (left + right + 1) / 2 `to find **last** element valid\\n<br>\\n\\n# **Complexity**\\nTime `O(nlog10000000)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public int maximumCandies(int[] A, long k) {\\n        int left = 0, right = 10_000_000;\\n        while (left < right) {\\n            long sum = 0;\\n            int mid = (left + right + 1) / 2;\\n            for (int a : A) {\\n                sum += a / mid;\\n            }\\n            if (k > sum)\\n                right = mid - 1;\\n            else\\n                left = mid;\\n        }\\n        return left;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int maximumCandies(vector<int>& A, long long k) {\\n        int left = 0, right = 1e7;\\n        while (left < right) {\\n            long sum = 0, mid = (left + right + 1) / 2;\\n            for (int& a : A) {\\n                sum += a / mid;\\n            }\\n            if (k > sum)\\n                right = mid - 1;\\n            else\\n                left = mid;\\n        }\\n        return left;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def maximumCandies(self, A, k):\\n        left, right = 0, sum(A) / k\\n        while left < right:\\n            mid = (left + right + 1) / 2\\n            if k > sum(a / mid for a in A):\\n                right = mid - 1\\n            else:\\n                left = mid\\n        return left\\n```\\n<br>\\n\\n# More Good Binary Search Problems\\nHere are some similar binary search problems.\\nAlso find more explanations.\\nGood luck and have fun.\\n\\n- 2226. [Maximum Candies Allocated to K Children](https://leetcode.com/problems/maximum-candies-allocated-to-k-children/discuss/1908888/JavaC%2B%2BPython-Binary-Search-with-Explanation)\\n- 1802. [Maximum Value at a Given Index in a Bounded Array](https://leetcode.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/discuss/1119801/Python-Binary-Search)\\n- 1539. [Kth Missing Positive Number](https://leetcode.com/problems/kth-missing-positive-number/discuss/779999/JavaC++Python-O(logN))\\n- 1482. [Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/discuss/686316/javacpython-binary-search)\\n- 1283. [Find the Smallest Divisor Given a Threshold](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/discuss/446376/javacpython-bianry-search)\\n- 1231. [Divide Chocolate](https://leetcode.com/problems/divide-chocolate/discuss/408503/Python-Binary-Search)\\n- 1011. [Capacity To Ship Packages In N Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/discuss/256729/javacpython-binary-search/)\\n- 875. [Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/discuss/152324/C++JavaPython-Binary-Search)\\n- 774. [Minimize Max Distance to Gas Station](https://leetcode.com/problems/minimize-max-distance-to-gas-station/discuss/113633/Easy-and-Concise-Solution-using-Binary-Search-C++JavaPython)\\n- 410. [Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/)\\n<br>\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int maximumCandies(int[] A, long k) {\\n        int left = 0, right = 10_000_000;\\n        while (left < right) {\\n            long sum = 0;\\n            int mid = (left + right + 1) / 2;\\n            for (int a : A) {\\n                sum += a / mid;\\n            }\\n            if (k > sum)\\n                right = mid - 1;\\n            else\\n                left = mid;\\n        }\\n        return left;\\n    }\\n```\n```cpp\\n    int maximumCandies(vector<int>& A, long long k) {\\n        int left = 0, right = 1e7;\\n        while (left < right) {\\n            long sum = 0, mid = (left + right + 1) / 2;\\n            for (int& a : A) {\\n                sum += a / mid;\\n            }\\n            if (k > sum)\\n                right = mid - 1;\\n            else\\n                left = mid;\\n        }\\n        return left;\\n    }\\n```\n```py\\n    def maximumCandies(self, A, k):\\n        left, right = 0, sum(A) / k\\n        while left < right:\\n            mid = (left + right + 1) / 2\\n            if k > sum(a / mid for a in A):\\n                right = mid - 1\\n            else:\\n                left = mid\\n        return left\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1908695,
                "title": "binary-search",
                "content": "Say we decide to allocate `m` candies. We can check if all `k` kids can get `m` candies in O(n).\\n\\nTherefore, we can binary-search for the maximum value `m`. The overall runtime complexity will be O(n * log m), where `m` is maximum number of candies in a single pile (10000000).\\n\\nThe fact that we can split piles could be confusing. But it simply means that we can distribute `m` candies to ` candies[i] / m` children from pile `i`.\\n\\n**C++**\\n```cpp    \\nint maximumCandies(vector<int>& candies, long long k) {\\n    int l = 0, r = 10000000;\\n    while(l < r) {\\n        long long m = (l + r + 1) / 2, cnt = 0;\\n        for (int i = 0; i < candies.size() && cnt < k; ++i)\\n            cnt += candies[i] / m;\\n        if (cnt >= k)\\n            l = m;\\n        else\\n            r = m - 1;\\n    }\\n    return l;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp    \\nint maximumCandies(vector<int>& candies, long long k) {\\n    int l = 0, r = 10000000;\\n    while(l < r) {\\n        long long m = (l + r + 1) / 2, cnt = 0;\\n        for (int i = 0; i < candies.size() && cnt < k; ++i)\\n            cnt += candies[i] / m;\\n        if (cnt >= k)\\n            l = m;\\n        else\\n            r = m - 1;\\n    }\\n    return l;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1908738,
                "title": "c-easy-solution-with-explanation",
                "content": "Lets see about the brute force solution.\\n\\nWe can check for candies=1,2 and so,on until we find an answer.\\n\\nCan\\'t we do something better,instead of linear search ?.\\n\\nYes, we can do **binary search.**\\n \\nIf we can divide the candies into piles containing x number of candies all the numbers below x,\\nwill also be satisfied.\\n\\nIn this question we have to find the maximum number of candies.\\n\\nLets see the lowest value is 1 and highest value as the maximum element in candies.\\n\\nNow we will find the mid, and we will check weather we can divide mid amount of candies into piles \\nsuch that they will be sufficient for k children.\\n\\nFinally we return the ans.\\n\\n```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    \\n    bool solve(vector<int>& v, ll mid, ll k){\\n        int n = v.size();\\n        ll cnt = 0;\\n        for(int i=0;i<n;i++){\\n            cnt += (v[i]/mid);\\n            if(cnt>=k) return true;\\n        }\\n        return false;\\n    }\\n    \\n    // v is the candies vector.\\n    int maximumCandies(vector<int>& v, long long k) {\\n        int n = v.size();\\n\\t\\tint mx = 0;\\n        for(int i=0;i<n;i++){\\n\\t\\t\\tmx = max(mx,v[i]);\\n        }\\n        \\n        ll low = 1, high = mx;\\n        ll ans = 0;\\n        while(low<=high){\\n            ll mid = low + (high-low)/2;\\n            if(solve(v,mid,k)){\\n                ans = mid;\\n                low = mid+1;\\n            }\\n            else{\\n                high = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Time Complexity= O(nlogp)   // p is the maximum candy.\\nSpace Complexity- O(1);**\\n\\n\\nUpvote if it helps!!\\nThank you!!\\n\\nMore binary search problems:\\n\\nhttps://leetcode.com/problems/capacity-to-ship-packages-within-d-days/\\nhttps://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/\\nhttps://leetcode.com/problems/find-the-duplicate-number/\\nhttps://leetcode.com/problems/minimum-size-subarray-sum/\\nhttps://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/\\nhttps://leetcode.com/problems/most-beautiful-item-for-each-query/\\nhttps://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/\\nhttps://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/\\nhttps://leetcode.com/problems/heaters/\\nhttps://leetcode.com/problems/minimum-absolute-sum-difference/\\nhttps://leetcode.com/problems/frequency-of-the-most-frequent-element/",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    \\n    bool solve(vector<int>& v, ll mid, ll k){\\n        int n = v.size();\\n        ll cnt = 0;\\n        for(int i=0;i<n;i++){\\n            cnt += (v[i]/mid);\\n            if(cnt>=k) return true;\\n        }\\n        return false;\\n    }\\n    \\n    // v is the candies vector.\\n    int maximumCandies(vector<int>& v, long long k) {\\n        int n = v.size();\\n\\t\\tint mx = 0;\\n        for(int i=0;i<n;i++){\\n\\t\\t\\tmx = max(mx,v[i]);\\n        }\\n        \\n        ll low = 1, high = mx;\\n        ll ans = 0;\\n        while(low<=high){\\n            ll mid = low + (high-low)/2;\\n            if(solve(v,mid,k)){\\n                ans = mid;\\n                low = mid+1;\\n            }\\n            else{\\n                high = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908797,
                "title": "binary-search-solution-with-explanation-java-o-n-log-max-candies",
                "content": "Simple Binary Search Solution | Java | O(n log(max(candies)))\\n\\n**Idea**:\\nBrute force :Start with 1 candy and see if we can allocate. If yes, then check for 2 candy. \\nOptimization: Instead of checking every candy at a time, why can\\'t we directly check for a number to see if we can allocate that many candy. This way we reduce our search space. Best way to do it is binary search.\\n\\n**Approach**:\\nFirst go through each pile and store the maximum of candy of that pile.\\nNow your seach space will be `[0 - max]`. Now, we will pick `mid` from that and check if we can allocate that many candies to k children. If yes, update `lo`, if not update `hi`.\\n0 is trickey number because you can always allocate that many candies. So, at the end I do a check one more time on lo to see if I can allocate that candies. otherwise return lo-1.\\n\\n**TimeComplexity**:\\n`O(n)` to check if you can allocate x candies to k people\\ncalling above function `log(max(candies))`.\\nSo, overall time complexity `O(n log(max(candies)))`\\n\\n**Upvote if it helps. Thanks :)**\\n\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        \\n        int max = 0;\\n        for(int candy : candies)\\n            max = Math.max(max, candy);\\n        int lo = 0, hi = max;\\n        \\n        while(lo < hi) {            \\n            int mid = lo + (hi-lo)/2;\\n            if(canAllocate(candies, k, mid)) {\\n                lo = mid+1;\\n            } else {\\n                hi = mid ;\\n            }\\n        }  \\n        return canAllocate(candies, k, lo) ? lo : lo-1;\\n    }\\n    \\n    public boolean canAllocate(int[] candies, long k, int allow) {\\n        if(allow == 0)\\n            return true;\\n        long total = 0;\\n        for(int candy : candies) {\\n            total += candy / allow;\\n            if(total >= k)\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        \\n        int max = 0;\\n        for(int candy : candies)\\n            max = Math.max(max, candy);\\n        int lo = 0, hi = max;\\n        \\n        while(lo < hi) {            \\n            int mid = lo + (hi-lo)/2;\\n            if(canAllocate(candies, k, mid)) {\\n                lo = mid+1;\\n            } else {\\n                hi = mid ;\\n            }\\n        }  \\n        return canAllocate(candies, k, lo) ? lo : lo-1;\\n    }\\n    \\n    public boolean canAllocate(int[] candies, long k, int allow) {\\n        if(allow == 0)\\n            return true;\\n        long total = 0;\\n        for(int candy : candies) {\\n            total += candy / allow;\\n            if(total >= k)\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908862,
                "title": "binary-search-intutive-intution-explanation",
                "content": "Intution : We Know we had  to distribute  maximum candies , whenever face Problem in which we  have   to distribute  and finding the maximum or minium, See the Time Complexity if Time Complexity isaround 10^4, and your answer require optimal ways then think of dp solution, if Time Complexity is around 10^5 either it can be done by  sorting with greedy or binary search on ans. Now with this it was clear it is binary search on ans problem. So Just checked how can I distribute \\n1. Search space can be 1 to sum(candies), Why\\n Becuase you have to give them at least one so low = 1.\\n 2. Just find the mid and check, if distributing mid candies it is possible to distribute if yes, then reduce your search space so that more optimal ans can be find.\\n\\n**Please UPVOTE Guys , If it helps, That motivates**\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& candies, long long k, long long mid) {\\n        long long split = 0;\\n        for(int i = 0; i < candies.size(); ++i) {\\n            split += candies[i]/mid;\\n        }   \\n        return split>=k;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long sum = 0;\\n        for(int i = 0; i < candies.size(); ++i) {\\n            sum += candies[i];\\n        }\\n        \\n        long long start = 1, end = sum;\\n        long long ans = 0;\\n        \\n        while(start <= end) {\\n            long long mid = (start + end)/2;\\n            if(check(candies, k, mid)) {\\n                ans = mid;\\n                start = mid + 1;\\n            } else {\\n                end = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nTime Complexity : nlog(m}\\nSpace Complexity: O(1)",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool check(vector<int>& candies, long long k, long long mid) {\\n        long long split = 0;\\n        for(int i = 0; i < candies.size(); ++i) {\\n            split += candies[i]/mid;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1908775,
                "title": "100-faster-c-python-java-binary-search-with-logic",
                "content": "![image](https://assets.leetcode.com/users/images/82a7e416-2997-4676-929e-712206ab4b1a_1648961313.8131979.png)\\n\\n**Idea**\\n\\n* start can be taken as 1 , highest we can distribute equally is average.\\n\\n* Use Binary Search and try to distribute the candies equal to mid, if possible try to maximize it by moving on right, else if not possible try it by decreasing the value by moving on left\\n* **TC: O(NlogN) SC: O(1)**\\n\\n```\\ndef canSplit(candies, mid, k):\\n    split = 0\\n    for i in candies:\\n        split += i//mid\\n    if split >= k:\\n        return True\\n    else:\\n        return False\\n    \\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        end = sum(candies)//k\\n        start = 1\\n        ans = 0\\n        while start <= end:\\n            mid = (start + end)//2\\n            if canSplit(candies, mid, k):\\n                start = mid + 1\\n                ans = mid\\n            else:\\n                end = mid - 1\\n        return ans\\n        \\n```\\n\\n**C++**\\n\\n```\\nclass Solution {\\npublic:\\n    bool canSplit(vector<int>& candies, long long k, long long mid) {\\n        long long split = 0;\\n        for(int i = 0; i < candies.size(); ++i) {\\n            split += candies[i]/mid;\\n        }   \\n        if(split >= k)\\n            return true;\\n        else\\n            return false;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long sum = 0;\\n        for(int i = 0; i < candies.size(); ++i) {\\n            sum += candies[i];\\n        }\\n        long long start = 1, end = sum/k;\\n        long long ans = 0;\\n        while(start <= end) {\\n            long long mid = (start + end)/2;\\n            if(canSplit(candies, k, mid)) {\\n                ans = mid;\\n                start = mid + 1;\\n            } else {\\n                end = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Java**\\n```\\nclass Solution {\\n    public boolean canSplit(int[] candies, long k, long mid) {\\n        long split = 0;\\n        for(int i = 0; i < candies.length; ++i) {\\n            split += candies[i]/mid;\\n        }   \\n        if(split >= k)\\n            return true;\\n        else\\n            return false;\\n    }\\n    \\n    public int maximumCandies(int[] candies, long k) {\\n        long sum = 0;\\n        for(int i = 0; i < candies.length; ++i) {\\n            sum += candies[i];\\n        }\\n        long start = 1, end = sum;\\n        long ans = 0;\\n        while(start <= end) {\\n            long mid = (start + end)/2;\\n            if(canSplit(candies, k, mid)) {\\n                ans = mid;\\n                start = mid + 1;\\n            } else {\\n                end = mid-1;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Binary Search"
                ],
                "code": "```\\ndef canSplit(candies, mid, k):\\n    split = 0\\n    for i in candies:\\n        split += i//mid\\n    if split >= k:\\n        return True\\n    else:\\n        return False\\n    \\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        end = sum(candies)//k\\n        start = 1\\n        ans = 0\\n        while start <= end:\\n            mid = (start + end)//2\\n            if canSplit(candies, mid, k):\\n                start = mid + 1\\n                ans = mid\\n            else:\\n                end = mid - 1\\n        return ans\\n        \\n```\n```\\nclass Solution {\\npublic:\\n    bool canSplit(vector<int>& candies, long long k, long long mid) {\\n        long long split = 0;\\n        for(int i = 0; i < candies.size(); ++i) {\\n            split += candies[i]/mid;\\n        }   \\n        if(split >= k)\\n            return true;\\n        else\\n            return false;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long sum = 0;\\n        for(int i = 0; i < candies.size(); ++i) {\\n            sum += candies[i];\\n        }\\n        long long start = 1, end = sum/k;\\n        long long ans = 0;\\n        while(start <= end) {\\n            long long mid = (start + end)/2;\\n            if(canSplit(candies, k, mid)) {\\n                ans = mid;\\n                start = mid + 1;\\n            } else {\\n                end = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public boolean canSplit(int[] candies, long k, long mid) {\\n        long split = 0;\\n        for(int i = 0; i < candies.length; ++i) {\\n            split += candies[i]/mid;\\n        }   \\n        if(split >= k)\\n            return true;\\n        else\\n            return false;\\n    }\\n    \\n    public int maximumCandies(int[] candies, long k) {\\n        long sum = 0;\\n        for(int i = 0; i < candies.length; ++i) {\\n            sum += candies[i];\\n        }\\n        long start = 1, end = sum;\\n        long ans = 0;\\n        while(start <= end) {\\n            long mid = (start + end)/2;\\n            if(canSplit(candies, k, mid)) {\\n                ans = mid;\\n                start = mid + 1;\\n            } else {\\n                end = mid-1;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908707,
                "title": "binary-search-explained",
                "content": "**Explanation :**\\nBinary search between **[1, max(candies)]** to find the result.\\n**if we can allocate currCandy candies to k children. then update start, if not update end.**\\nSimilar Question : [https://leetcode.com/problems/koko-eating-bananas/]\\n**Time O(Nlog(MaxC))\\nSpace O(1)**\\n    \\n    \\n```\\nclass Solution {\\npublic:\\n    \\n    bool doit(int currCandy, vector<int>& candies, long long k) {\\n       \\n\\t\\t// c candies can be divided into (c/currCandy) number of piles of size currCandy.\\n        for (auto& c : candies)   k -= (c/currCandy);\\n        return k <= 0;\\n    }\\n    \\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        int start(1), end(INT_MIN);\\n        for (auto& candy : candies) end = max(end, candy);\\n        \\n        while (start <= end) {\\n            int currCandy = start+(end-start)/2;\\n\\t\\t\\t// If we can divide the candies into piles containing currCandy number of candies all the numbers below currCandy can be distributed too.\\n            if (doit(currCandy, candies, k))    start = currCandy+1;\\n            else    end = currCandy-1;\\n        }\\n        return end;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool doit(int currCandy, vector<int>& candies, long long k) {\\n       \\n\\t\\t// c candies can be divided into (c/currCandy) number of piles of size currCandy.\\n        for (auto& c : candies)   k -= (c/currCandy);\\n        return k <= 0;\\n    }\\n    \\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        int start(1), end(INT_MIN);\\n        for (auto& candy : candies) end = max(end, candy);\\n        \\n        while (start <= end) {\\n            int currCandy = start+(end-start)/2;\\n\\t\\t\\t// If we can divide the candies into piles containing currCandy number of candies all the numbers below currCandy can be distributed too.\\n            if (doit(currCandy, candies, k))    start = currCandy+1;\\n            else    end = currCandy-1;\\n        }\\n        return end;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266489,
                "title": "easy-to-understand-optimized-binary-search-approach-beginner-friendly-detail-explained",
                "content": "\\n# Approach\\n1. minimum size of candy can be 1,less than 1 can not be possible.\\n2. maximum size of candy can be maximum element of given candies array,greater than max element can not be possible.\\n3. we chose candy size by bianry search, so that we can choose in optimised time.\\n4. function func give information about that, candies array\\'s element can be divided into mid size.\\n5. In function func,\\'cnt\\' count the nummber of \\'mid\\' size candy can be divided from candies array elements.\\n6. when count of mid size candy greater than our need(k), then we return true, *i.e.*  our answer should be mid but greater than mid can be possible.\\n# Complexity\\n- Time complexity:$$O(N*logN)$$\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool func(vector<int>&pile,long long h,int mid)\\n    {\\n        long long cnt=0;\\n        for(int i=0;i<pile.size();i++)\\n        {\\n            cnt += pile[i]/mid ;\\n            if(cnt>h)\\n            return true;\\n        }\\n        return cnt>=h;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) \\n    {\\n        int s = 1,e = *max_element(candies.begin(),candies.end());\\n        int ans=0;\\n        while(s<=e)\\n        {\\n            int mid = s+ (e-s)/2;\\n            if(func(candies,k,mid))\\n            {\\n                ans = mid;\\n                s = mid+1;\\n            }\\n            else\\n            e = mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**If you feel this helpful then plz like and upvote this solution \\uD83D\\uDE0A\\nKEEP LEETCODING.............**\\n![upvote.png](https://assets.leetcode.com/users/images/2fccf5b3-2212-4efd-afe0-0a5ca0b80d68_1678151551.9504004.png)\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool func(vector<int>&pile,long long h,int mid)\\n    {\\n        long long cnt=0;\\n        for(int i=0;i<pile.size();i++)\\n        {\\n            cnt += pile[i]/mid ;\\n            if(cnt>h)\\n            return true;\\n        }\\n        return cnt>=h;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) \\n    {\\n        int s = 1,e = *max_element(candies.begin(),candies.end());\\n        int ans=0;\\n        while(s<=e)\\n        {\\n            int mid = s+ (e-s)/2;\\n            if(func(candies,k,mid))\\n            {\\n                ans = mid;\\n                s = mid+1;\\n            }\\n            else\\n            e = mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909217,
                "title": "c-solution-100-faster",
                "content": "\"\"\"\\n#define ll long long\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        ll left=1,right=*max_element(candies.begin(),candies.end());\\n        ll size=candies.size();\\n        ll maxi=0;\\n        while(left<=right){\\n            ll mid=left+(right-left)/2;\\n            ll temp=0;\\n            for(int i=0;i<size;i++){\\n                temp+=candies[i]/mid;\\n            }\\n            if(temp>=k){\\n                maxi=mid;\\n                left=mid+1;\\n            }else{\\n                right=mid-1;\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n\"\"\"\\n\\nPlease Upvote if you find it Helpful \\uD83D\\uDE42.",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "class Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        ll left=1,right=*max_element(candies.begin(),candies.end());\\n        ll size=candies.size();\\n        ll maxi=0;\\n        while(left<=right){\\n            ll mid=left+(right-left)/2;\\n            ll temp=0;\\n            for(int i=0;i<size;i++){\\n                temp+=candies[i]/mid;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1909039,
                "title": "c-binary-search-on-answer-explained-o-nlogn",
                "content": "**CONCEPT**\\n* In these type of question first we have to find search space which is the possible set of answers which this question can have. Like in this case minimum answer can be zero and maximum can be maximum of the candies not more than that. \\n* Simply apply binary search on this range [0,max] and if mid is possible answer than we will try to increase this answer by reducing our search space to [mid+1,max] else we will try to find answer in [0,mid].\\n* isPossible function tells whether is it possible to divide the candies or not. So it is implemented greedily. So i have count the maximum number of children i can distribute candies to and if it is greater than equal to k than it is possible to divide else not.\\n* Time:O(NlogN) and Space:O(1\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums, long long k, long long mid){\\n        long long cnt=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>=mid){\\n                cnt+=(nums[i]/mid);\\n            }\\n        }\\n        return cnt>=k;\\n    }\\n    \\n    \\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        sort(candies.begin(),candies.end());\\n        int n=candies.size();\\n        long long sum=0;\\n        int mx=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            sum+=candies[i];\\n            mx=max(mx,candies[i]);\\n            \\n        }\\n        \\n        long long l=1,r=mx;\\n        int res=0;\\n        while(l<=r){\\n            long long mid=l+(r-l)/2;\\n            if(isPossible(candies,k,mid)){\\n                l=mid+1;\\n            }else{\\n                r=mid-1;\\n            }\\n        }\\n        \\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& nums, long long k, long long mid){\\n        long long cnt=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>=mid){\\n                cnt+=(nums[i]/mid);\\n            }\\n        }\\n        return cnt>=k;\\n    }\\n    \\n    \\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        sort(candies.begin(),candies.end());\\n        int n=candies.size();\\n        long long sum=0;\\n        int mx=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            sum+=candies[i];\\n            mx=max(mx,candies[i]);\\n            \\n        }\\n        \\n        long long l=1,r=mx;\\n        int res=0;\\n        while(l<=r){\\n            long long mid=l+(r-l)/2;\\n            if(isPossible(candies,k,mid)){\\n                l=mid+1;\\n            }else{\\n                r=mid-1;\\n            }\\n        }\\n        \\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908820,
                "title": "c-binary-search",
                "content": "\\nSee my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Binary Answer\\n\\nBinary search in range `L = 1, R = max(A)`.\\n\\nFor a given `M = (L + R) / 2`, we test if we can give `M` candies to each child, which can be done by traversing the array once, taking `O(N)` time. \\n\\nIf possible/valid, we make `L = M + 1`; otherwise, we make `R = M - 1`.\\n\\nIn the end, since we are looking for the greatest valid number, we return `R`.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-287/problems/maximum-candies-allocated-to-k-children/\\n// Author: github.com/lzl124631x\\n// Time: O(Nlog(sum(A)))\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& A, long long k) {\\n        long L = 1, R = *max_element(begin(A), end(A)), N = A.size();\\n        auto valid = [&](long m) {\\n            long cnt = 0;\\n            for (int n : A) {\\n                cnt += n / m;\\n                if (cnt >= k) return true;\\n            }\\n            return false;\\n        };\\n        while (L <= R) {\\n            long M = L + (R - L) / 2;\\n            if (valid(M)) L = M + 1;\\n            else R = M - 1;\\n        }\\n        return R;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-287/problems/maximum-candies-allocated-to-k-children/\\n// Author: github.com/lzl124631x\\n// Time: O(Nlog(sum(A)))\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& A, long long k) {\\n        long L = 1, R = *max_element(begin(A), end(A)), N = A.size();\\n        auto valid = [&](long m) {\\n            long cnt = 0;\\n            for (int n : A) {\\n                cnt += n / m;\\n                if (cnt >= k) return true;\\n            }\\n            return false;\\n        };\\n        while (L <= R) {\\n            long M = L + (R - L) / 2;\\n            if (valid(M)) L = M + 1;\\n            else R = M - 1;\\n        }\\n        return R;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909387,
                "title": "c-accepted-solution-binary-search-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        long long sum=0;\\n        \\n        int n=candies.size();\\n        \\n        //calculate sum\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=(long long)candies[i];\\n        }\\n        \\n        \\n        // if sum<k then we are not able to give a single one candy\\n        if(sum<k) return 0;\\n        \\n        \\n        long long h=sum/k;  // max possible ans cant exceed sum/k\\n        long long l=1;      // min possible ans will be 1\\n        long long res=1;\\n        \\n        \\n        //next part is just binary search\\n        while(h>=l)\\n        {\\n            long long m=(h+l)/2;\\n            long long count=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                count+=candies[i]/m;\\n            }\\n            \\n            if(count>=k)\\n            {\\n                res=max(res,m);\\n                l=m+1;\\n            }\\n            else\\n            {\\n                h=m-1;\\n            }\\n        }\\n        return res;\\n        \\n        \\n    }\\n};\\n```\\n**upvote**",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        long long sum=0;\\n        \\n        int n=candies.size();\\n        \\n        //calculate sum\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=(long long)candies[i];\\n        }\\n        \\n        \\n        // if sum<k then we are not able to give a single one candy\\n        if(sum<k) return 0;\\n        \\n        \\n        long long h=sum/k;  // max possible ans cant exceed sum/k\\n        long long l=1;      // min possible ans will be 1\\n        long long res=1;\\n        \\n        \\n        //next part is just binary search\\n        while(h>=l)\\n        {\\n            long long m=(h+l)/2;\\n            long long count=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                count+=candies[i]/m;\\n            }\\n            \\n            if(count>=k)\\n            {\\n                res=max(res,m);\\n                l=m+1;\\n            }\\n            else\\n            {\\n                h=m-1;\\n            }\\n        }\\n        return res;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3361579,
                "title": "c-binary-search-simple-explanation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhat comes to my mind is to check what number of candies(search space) is satisfying children.\\nSo by this intuition we can find the search space. \\n\\nMinimum candy child can  get will be 1:\\nExample: [1,2,3,4] and k=5\\nTotal 5 children and all of them should have same amount of candies\\nso for example let candy=2 now check whether we can get 2 candies from all the piles or not\\n1st pile:- candies[0]=1 and we can\\'t get 2 candies -> count=0\\n2nd pile:- candies[1]=2 we can get 2 candies -> count=1\\n3rd pile:- candies[2]=3 we can get 2 candies -> count=2\\n4th pile:- candies[3]=4 we can get total pair of 2 candy -> count=4\\n\\nAt end we can only satisfy 4 children but we need to satisfy 5 children(k=5)\\nso minimum value child can get will be 1 candy.\\n\\nMaximum candy child can get will be maximum element in candies:\\nExample candies=[1,2,3,4] and k=1\\nHere we need to satisy 1 children and it should have maximum candy we can just allocate all candy to single children \\nso maximum value of candy child can get will be 4.\\n\\nWe got our search space here\\nstart=1 and end=max_element\\n\\nNow approach is to apply binary search and check whether particular number of candies satisfies all the children or not\\nExample: candies=[5,8,6], k = 3\\nsuppose we reached mid=5 now count the number of 5 candies from each pile:\\n```\\n bool isSatisfying(vector<int> candies,long long mid ,long long k){\\n        long long count=0;\\n\\n        for(auto x: candies){\\n            count=count+(x/mid);\\n        }\\n        if(count>=k) return true;\\n        return false;\\n    }\\n```\\nWe are dividing each piles with mid value and checking how many number of 5 candies we can get.\\nFor [5,8,6]->\\n    Each child gets 1 pile of total 5 candies\\n    5/5=1 -> For first child\\n    8/5=1 -> For second child\\n    6/5=1 -> For third child\\n\\nWe can distribute max 5 candies to 3 children\\nIf count is greater or equal to children then we can distribute equal candies to all children .\\n\\n# Complexity\\n- Time complexity:\\n $$O(n(log(end)))$$ where n=candies.size() and end=max_element\\n\\n- Space complexity\\n    $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isSatisfying(vector<int> candies,long long mid ,long long k){\\n        long long count=0;\\n\\n        for(auto x: candies){\\n            count=count+(x/mid);\\n        }\\n\\n        if(count>=k) return true;\\n        return false;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int start=1;\\n        int end=*max_element(candies.begin(),candies.end());\\n        int ans=0;\\n\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(isSatisfying(candies,mid,k)){\\n                //we need to maximize search space so storing answer and finding anther maxi\\n                ans=mid;\\n                start=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Binary Search"
                ],
                "code": "```\\n bool isSatisfying(vector<int> candies,long long mid ,long long k){\\n        long long count=0;\\n\\n        for(auto x: candies){\\n            count=count+(x/mid);\\n        }\\n        if(count>=k) return true;\\n        return false;\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    bool isSatisfying(vector<int> candies,long long mid ,long long k){\\n        long long count=0;\\n\\n        for(auto x: candies){\\n            count=count+(x/mid);\\n        }\\n\\n        if(count>=k) return true;\\n        return false;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int start=1;\\n        int end=*max_element(candies.begin(),candies.end());\\n        int ans=0;\\n\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(isSatisfying(candies,mid,k)){\\n                //we need to maximize search space so storing answer and finding anther maxi\\n                ans=mid;\\n                start=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909559,
                "title": "easy-tricky-binary-search-approach-explained-along-with-code",
                "content": "# This problem is a kind of Upper Bond problem of Binary search.\\nHere we just simply have to make an binary search call by setting the min and max variables which is the range in which we have to be get the correct answer. Since we can give as minimum as 0 candies to k children because there are not many candies for everyone so our min = 0. and the maximum candies which we can give is the maximum pile of candie which is available with us because there is no way we can distribute more candies than what we have available.\\nTo Calculate mid we will use this formula **mid = min + (max-min)/2** this will give us the exact possible value of mid everytime.\\nAnd then we need a condtion to verify if the current **mid** is a right input so for that we have a condition that the number of candie pile can be divided such that all the **k** childeren should get same number of candy so we will make a boolean function to check the exact same thing which we  discussed.\\n\\n\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int min = 1;\\n        int max = Integer.MIN_VALUE;\\n        for(int candie : candies){\\n            max = Math.max(candie,max);\\n        }\\n        \\n        int answer = 0;\\n        while(min <= max){\\n            int mid = min + (max - min)/2;\\n            if(checkIfTrue(candies,k,mid)){\\n                answer = mid;\\n                min = mid+1;\\n            }else{\\n                max = mid-1;\\n            }\\n        }\\n        return answer;\\n    }\\n    \\n    public boolean checkIfTrue(int[] candies,long k,int divid){\\n        long cnt = 0;\\n        for(int candie : candies){\\n            cnt += (long) Math.floor(candie/divid);\\n        }\\n        if(cnt >= k) return true;\\n        return false;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int min = 1;\\n        int max = Integer.MIN_VALUE;\\n        for(int candie : candies){\\n            max = Math.max(candie,max);\\n        }\\n        \\n        int answer = 0;\\n        while(min <= max){\\n            int mid = min + (max - min)/2;\\n            if(checkIfTrue(candies,k,mid)){\\n                answer = mid;\\n                min = mid+1;\\n            }else{\\n                max = mid-1;\\n            }\\n        }\\n        return answer;\\n    }\\n    \\n    public boolean checkIfTrue(int[] candies,long k,int divid){\\n        long cnt = 0;\\n        for(int candie : candies){\\n            cnt += (long) Math.floor(candie/divid);\\n        }\\n        if(cnt >= k) return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182046,
                "title": "best-solution-in-c-binarysearch-on-answer",
                "content": "# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n**Please Upvote if u liked my Solution**\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    bool occurrences(int x,vector<int>& candies,long k){\\n        long ans=0;\\n        for(auto it:candies){\\n            ans+=it/x;\\n            if(ans>=k)\\n                return true;\\n        }\\n        return false;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int size=candies.size(),ans=-1;\\n        long sum=0;\\n        for(auto it:candies)\\n            sum+=it;\\n        if(sum<k)\\n            return 0;\\n        int ll=1,ul=sum/k,mid;\\n        while(ll<=ul){\\n            mid= (ll+ul) >> 1;\\n            if(occurrences(mid,candies,k)){\\n                ans=mid;\\n                ll=mid+1;\\n            }\\n            else\\n                ul=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool occurrences(int x,vector<int>& candies,long k){\\n        long ans=0;\\n        for(auto it:candies){\\n            ans+=it/x;\\n            if(ans>=k)\\n                return true;\\n        }\\n        return false;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int size=candies.size(),ans=-1;\\n        long sum=0;\\n        for(auto it:candies)\\n            sum+=it;\\n        if(sum<k)\\n            return 0;\\n        int ll=1,ul=sum/k,mid;\\n        while(ll<=ul){\\n            mid= (ll+ul) >> 1;\\n            if(occurrences(mid,candies,k)){\\n                ans=mid;\\n                ll=mid+1;\\n            }\\n            else\\n                ul=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2958952,
                "title": "concise-binary-search-c",
                "content": "```\\nclass Solution {\\n    bool good(int x, vector<int> &c, long long k) {\\n        long long cnt = 0;\\n        for(int i : c) cnt += i / x;\\n        return cnt < k ? false : true;\\n    }\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int s = 1, e = 1e9, ans = INT_MIN;\\n        while(s <= e) {\\n            int m = (s + e) / 2;\\n            if(good(m, candies, k)) ans = max(ans, m), s = m + 1;\\n            else e = m - 1;\\n        }\\n        return ans == INT_MIN ? 0 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    bool good(int x, vector<int> &c, long long k) {\\n        long long cnt = 0;\\n        for(int i : c) cnt += i / x;\\n        return cnt < k ? false : true;\\n    }\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int s = 1, e = 1e9, ans = INT_MIN;\\n        while(s <= e) {\\n            int m = (s + e) / 2;\\n            if(good(m, candies, k)) ans = max(ans, m), s = m + 1;\\n            else e = m - 1;\\n        }\\n        return ans == INT_MIN ? 0 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2434695,
                "title": "java-solution-using-binary-search",
                "content": "```\\nprivate boolean isPossible(int[] candies,int max,long k){\\n        long sum = 0;\\n        for(int i = 0; i<candies.length;i++){\\n            sum += (candies[i]/max);\\n        }\\n        if(sum>=k){\\n            return true;\\n        }\\n        return false;\\n    }\\n    public int maximumCandies(int[] candies, long k) {\\n        int s = 1;\\n        int e = 0;\\n        for(int i = 0; i< candies.length;i++){\\n            e = Math.max(e,candies[i]);                  // ans can\\'t be more than the height number in the array so take end, the max candie from array.\\n        }\\n        int ans = 0;\\n        while(s<=e){\\n            int mid = s+(e-s)/2;\\n            if(isPossible(candies,mid,k)){       // if posible to distribute candies with mid then store ans and increase start to mid + 1, Becoz we need maximum possible ans according to question.\\n                ans = mid;\\n                s = mid+1;\\n            }\\n            else{\\n                e = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nprivate boolean isPossible(int[] candies,int max,long k){\\n        long sum = 0;\\n        for(int i = 0; i<candies.length;i++){\\n            sum += (candies[i]/max);\\n        }\\n        if(sum>=k){\\n            return true;\\n        }\\n        return false;\\n    }\\n    public int maximumCandies(int[] candies, long k) {\\n        int s = 1;\\n        int e = 0;\\n        for(int i = 0; i< candies.length;i++){\\n            e = Math.max(e,candies[i]);                  // ans can\\'t be more than the height number in the array so take end, the max candie from array.\\n        }\\n        int ans = 0;\\n        while(s<=e){\\n            int mid = s+(e-s)/2;\\n            if(isPossible(candies,mid,k)){       // if posible to distribute candies with mid then store ans and increase start to mid + 1, Becoz we need maximum possible ans according to question.\\n                ans = mid;\\n                s = mid+1;\\n            }\\n            else{\\n                e = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1975986,
                "title": "python-easy-to-understand-50-faster",
                "content": "```\\nclass Solution:\\n    \"\"\"\\n    approach: \\n    the problem can be tackled using binary search \\n    max_candies that can be allocated to children = max(candies)\\n    min_candies that can be allocated to children = 1\\n    \\n    we will apply binary search on finding the optimal values of candies that can be\\n    distributed to children. \\n    \"\"\"\\n    def check_fulfilment(self, candies, elem, k):\\n        count = 0\\n        for candy in candies:\\n            count+= candy // elem\\n        if count >= k:\\n            return True\\n        return False\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        low = 1\\n        high = max(candies)\\n        if sum(candies) < k:\\n            return 0\\n        while low <= high:\\n            mid = (low+high) // 2\\n            # check if I can fulfil that order\\n            status = self.check_fulfilment(candies, mid, k)\\n            if status:\\n                low = mid+1\\n            else:         \\n                high = mid-1\\n        # low is the maximum number of candies that can be  distributed\\n        return high\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    \"\"\"\\n    approach: \\n    the problem can be tackled using binary search \\n    max_candies that can be allocated to children = max(candies)\\n    min_candies that can be allocated to children = 1\\n    \\n    we will apply binary search on finding the optimal values of candies that can be\\n    distributed to children. \\n    \"\"\"\\n    def check_fulfilment(self, candies, elem, k):\\n        count = 0\\n        for candy in candies:\\n            count+= candy // elem\\n        if count >= k:\\n            return True\\n        return False\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        low = 1\\n        high = max(candies)\\n        if sum(candies) < k:\\n            return 0\\n        while low <= high:\\n            mid = (low+high) // 2\\n            # check if I can fulfil that order\\n            status = self.check_fulfilment(candies, mid, k)\\n            if status:\\n                low = mid+1\\n            else:         \\n                high = mid-1\\n        # low is the maximum number of candies that can be  distributed\\n        return high\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1960155,
                "title": "c-discrete-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(long val,vector<int>&candies,long k){\\n        long sum = 0;\\n        for(auto it : candies){\\n            sum += (it/val);\\n        }\\n        return sum >= k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long start = 1, end = 1e9;\\n        while(start < end){\\n            long mid = (start + end) / 2;\\n            if(!check(mid,candies,k)){\\n                end = mid;\\n            }\\n            else start = mid+1;\\n        }\\n        return start-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(long val,vector<int>&candies,long k){\\n        long sum = 0;\\n        for(auto it : candies){\\n            sum += (it/val);\\n        }\\n        return sum >= k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long start = 1, end = 1e9;\\n        while(start < end){\\n            long mid = (start + end) / 2;\\n            if(!check(mid,candies,k)){\\n                end = mid;\\n            }\\n            else start = mid+1;\\n        }\\n        return start-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1912213,
                "title": "easy-to-understand-python-solution-binary-search",
                "content": "```\\nclass Solution:\\n    def maximumCandies(self, candies, k):\\n        n = len(candies)\\n        left = 1  # the least number of candy in each stack we can give to each student is one\\n        right = max(candies)  # the max number of candy in each stack that we can give to each student is the maximum number in the candies array\\n        ans = 0 # ans here is used to store the maximum amount in each stack that we can give to each children. \\n               # If we don\\'t have enough to distribute, we will return 0 at the end so we initialize it to be 0 now.\\n\\n        while left <= right:  # binary search\\n            numberOfPiles = 0\\n            mid = (left) + (right - left) // 2  # the number of candies we require to form a stack\\n\\n            for i in range(n):   # loop through the array to find the numbers of stack we can form\\n                numberOfPiles += candies[i] // mid   # we add to the numberOfPiles whenever we find that this current stack (candies[i]) can be split into mid (the number of candies we require to form a stack)\\n\\n            if numberOfPiles >= k: # if our number of piles is greater or equal than the students we have, so we have enough to distribute\\n                ans = max(ans, mid)   # we first store the max no. of candies in each stack that we can give to each student \\n                left = mid + 1      # we will try to increase the number of candies in each stack that we can give to each student\\n            else: \\n                right = mid - 1   # we will try to reduce the number of candies in each stack that we can give to each student\\n        return ans\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, candies, k):\\n        n = len(candies)\\n        left = 1  # the least number of candy in each stack we can give to each student is one\\n        right = max(candies)  # the max number of candy in each stack that we can give to each student is the maximum number in the candies array\\n        ans = 0 # ans here is used to store the maximum amount in each stack that we can give to each children. \\n               # If we don\\'t have enough to distribute, we will return 0 at the end so we initialize it to be 0 now.\\n\\n        while left <= right:  # binary search\\n            numberOfPiles = 0\\n            mid = (left) + (right - left) // 2  # the number of candies we require to form a stack\\n\\n            for i in range(n):   # loop through the array to find the numbers of stack we can form\\n                numberOfPiles += candies[i] // mid   # we add to the numberOfPiles whenever we find that this current stack (candies[i]) can be split into mid (the number of candies we require to form a stack)\\n\\n            if numberOfPiles >= k: # if our number of piles is greater or equal than the students we have, so we have enough to distribute\\n                ans = max(ans, mid)   # we first store the max no. of candies in each stack that we can give to each student \\n                left = mid + 1      # we will try to increase the number of candies in each stack that we can give to each student\\n            else: \\n                right = mid - 1   # we will try to reduce the number of candies in each stack that we can give to each student\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911684,
                "title": "1-liner-python-ruby",
                "content": "Binary-search the smallest allocation `a` that\\'s too large, the answer is 1 lower. Ruby still excels at this, though Python improved now that it supports a `key`.\\n\\nRuby:\\n```\\ndef maximum_candies(candies, k)\\n  (1..10**8).bsearch { |a| candies.sum { |c| c / a } < k } - 1\\nend\\n```\\nPython:\\n\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        return bisect_left(range(1, 10**8), True, key=lambda a: sum(c // a for c in candies) < k)\\n",
                "solutionTags": [
                    "Python",
                    "Ruby",
                    "Binary Tree"
                ],
                "code": "```\\ndef maximum_candies(candies, k)\\n  (1..10**8).bsearch { |a| candies.sum { |c| c / a } < k } - 1\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1910012,
                "title": "c-o-n-solution-with-explanation-binary-search",
                "content": "**Code:**\\n**TC: O(N), SC: O(1)**\\n```\\nclass Solution {\\npublic:\\n    \\n    bool isPossible(vector<int>& candies, int mid, long long k)\\n    {\\n        //it contains piles of candies that tells whether we can distribute or not assign to children equally \\n        long count=0;\\n        for(auto it:candies)\\n        {\\n            count += it/mid;\\n        \\n            //whenever count is greater than or equal to k it tells we can distribute mid to k children and return true;\\n            if(count>=k) return true;\\n        }\\n        //when we can\\'t distribute mid piles to k children, we return false;\\n        return false;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) \\n    {\\n        //initialize two pointers, 1 for minimum no. of candy, 1 for maximum no. of candy\\n        int min_candy = 1;\\n        int max_candy = *max_element(begin(candies), end(candies)); //we can also use for(auto it:candies) max_candy = max(max_candy, it)\\n        \\n        //use binary search for finding candies that can get by each child\\n        while(min_candy<=max_candy)\\n        {\\n            //find mid value\\n            long mid = (min_candy+max_candy)>>1;\\n            \\n            //if we can distribute mid piles of candies to k children successfully\\n            //we check for next greater candies\\n            if(isPossible(candies, mid, k))\\n            {\\n                min_candy = mid+1;\\n            }\\n            \\n            //if we can\\'t distribute mid piles of candies to k children\\n            //we check for lesser candies\\n            else\\n            {\\n                max_candy = mid-1;\\n                \\n            }\\n        }\\n        \\n        //return maxi_candies that can assign to each child\\n        return max_candy;\\n        \\n    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool isPossible(vector<int>& candies, int mid, long long k)\\n    {\\n        //it contains piles of candies that tells whether we can distribute or not assign to children equally \\n        long count=0;\\n        for(auto it:candies)\\n        {\\n            count += it/mid;\\n        \\n            //whenever count is greater than or equal to k it tells we can distribute mid to k children and return true;\\n            if(count>=k) return true;\\n        }\\n        //when we can\\'t distribute mid piles to k children, we return false;\\n        return false;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) \\n    {\\n        //initialize two pointers, 1 for minimum no. of candy, 1 for maximum no. of candy\\n        int min_candy = 1;\\n        int max_candy = *max_element(begin(candies), end(candies)); //we can also use for(auto it:candies) max_candy = max(max_candy, it)\\n        \\n        //use binary search for finding candies that can get by each child\\n        while(min_candy<=max_candy)\\n        {\\n            //find mid value\\n            long mid = (min_candy+max_candy)>>1;\\n            \\n            //if we can distribute mid piles of candies to k children successfully\\n            //we check for next greater candies\\n            if(isPossible(candies, mid, k))\\n            {\\n                min_candy = mid+1;\\n            }\\n            \\n            //if we can\\'t distribute mid piles of candies to k children\\n            //we check for lesser candies\\n            else\\n            {\\n                max_candy = mid-1;\\n                \\n            }\\n        }\\n        \\n        //return maxi_candies that can assign to each child\\n        return max_candy;\\n        \\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909538,
                "title": "easy-understandable-java-accepted",
                "content": "```\\nclass Solution {\\n    public static int maximumCandies(int[] arr, long k) {\\n\\t\\tArrays.sort(arr);\\n\\t\\tint low = 1;\\n\\t\\tint right = arr[arr.length - 1];\\n\\t\\twhile (low <= right) {\\n\\t\\t\\tint mid = (right - low) / 2 + low;\\n\\t\\t\\tif (helper(arr, k, mid)) {\\n\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tright = mid - 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn right;\\n\\t}\\n\\n\\tpublic static boolean helper(int[] arr, long k, int mid) {\\n\\t\\tlong curr = 0;\\n\\t\\tfor (int i = arr.length - 1; i >= 0 && curr < k; i--) {\\n\\t\\t\\tcurr += arr[i] / mid;\\n\\t\\t}\\n\\t\\treturn curr >= k;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public static int maximumCandies(int[] arr, long k) {\\n\\t\\tArrays.sort(arr);\\n\\t\\tint low = 1;\\n\\t\\tint right = arr[arr.length - 1];\\n\\t\\twhile (low <= right) {\\n\\t\\t\\tint mid = (right - low) / 2 + low;\\n\\t\\t\\tif (helper(arr, k, mid)) {\\n\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tright = mid - 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn right;\\n\\t}\\n\\n\\tpublic static boolean helper(int[] arr, long k, int mid) {\\n\\t\\tlong curr = 0;\\n\\t\\tfor (int i = arr.length - 1; i >= 0 && curr < k; i--) {\\n\\t\\t\\tcurr += arr[i] / mid;\\n\\t\\t}\\n\\t\\treturn curr >= k;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909171,
                "title": "intuition-behind-binary-search-on-answers",
                "content": "<br>\\n\\n`When there are multiple answers that are valid but we need to find the maximum possible valid answer or minimum possible valid answer then we can use binary search on answers.`\\n\\n**How does it work ?**\\n\\nin this problem we know that minimum number of candies that we can allocate is 0 and maximum is max(candies), so in all such problems we need to find the **minimum possible answer** and **maximum possible answer** and binary search between them to find **maximum / minimum valid answer** in logarithmic time.\\n\\nAnd binary search on answers can be used only in those problems in which **we can validate whether the current answer in valid or not**. In this problem we can do that by checking if we can allocate x number of candies among k children by dividing some piles, so we can do binary search here.\\n\\n<br>\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        int left = 1, ans = 0;\\n        int right = *max_element(candies.begin(), candies.end());\\n        \\n        while(left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if(canAllocate(candies, k, mid)) {\\n                left = mid + 1;\\n                ans = mid;\\n            }\\n            else {\\n                right = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n\\nprivate:\\n    bool canAllocate(vector<int>& candies, long long k, int candy) {\\n        \\n        long long total = 0;\\n        \\n        for(int c: candies) {\\n            total += c / candy;\\n            if(total >= k) return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\\n<br>\\n\\n**Time complexity: O(n) * log(max(candies))\\nSpace complexity: O(1)**\\n\\n<br>",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        int left = 1, ans = 0;\\n        int right = *max_element(candies.begin(), candies.end());\\n        \\n        while(left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if(canAllocate(candies, k, mid)) {\\n                left = mid + 1;\\n                ans = mid;\\n            }\\n            else {\\n                right = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n\\nprivate:\\n    bool canAllocate(vector<int>& candies, long long k, int candy) {\\n        \\n        long long total = 0;\\n        \\n        for(int c: candies) {\\n            total += c / candy;\\n            if(total >= k) return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909087,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long l=1,h=0;\\n        for(int& t:candies)\\n            h+=t;\\n        int ans=0;\\n        while(l<=h)\\n        {\\n            long long mid=l+(h-l)/2;\\n            long long val=0;\\n            for(auto t:candies)\\n                val+=(t/mid);\\n            if(val>=k)\\n            {\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else h=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long l=1,h=0;\\n        for(int& t:candies)\\n            h+=t;\\n        int ans=0;\\n        while(l<=h)\\n        {\\n            long long mid=l+(h-l)/2;\\n            long long val=0;\\n            for(auto t:candies)\\n                val+=(t/mid);\\n            if(val>=k)\\n            {\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else h=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908890,
                "title": "javascript-2226-maximum-candies-allocated-to-k-children",
                "content": "\\n**Weekly Contest 287**\\n\\n- Q1 answer\\n  - https://leetcode.com/problems/minimum-number-of-operations-to-convert-time/discuss/1908839/JavaScript-2224.-Minimum-Number-of-Operations-to-Convert-Time\\n- Q2 answer\\n  - https://leetcode.com/problems/find-players-with-zero-or-one-losses/discuss/1908871/JavaScript-2225.-Find-Players-With-Zero-or-One-Losses\\n- Q3 answer\\n  - https://leetcode.com/problems/maximum-candies-allocated-to-k-children/discuss/1908890/JavaScript-2226.-Maximum-Candies-Allocated-to-K-Children\\n  - **below**\\n    - Similar to some other DP problems, but this is greedy\\n    - **Less code** solution\\n    - **More code - with comments** solution\\n\\n---\\n\\nHope it is simple to understand.\\n\\n---\\n\\n**Less code** solution\\n\\n```\\nvar maximumCandies = function (candies, k) {\\n    function ok(min_candy) {\\n        let count = 0;\\n        for (let candy of candies) count += Math.floor(candy / min_candy);\\n        return count >= k;\\n    }\\n\\n    let l = 0,\\n        h = Math.max(...candies);\\n\\n    while (l <= h) {\\n        let m = l + Math.trunc((h - l) / 2);\\n        if (ok(m)) l = m + 1;\\n        else h = m - 1;\\n    }\\n    return h;\\n};\\n```\\n\\n---\\n\\n**More code - with comments** solution\\n\\n```\\nvar maximumCandies = function (cand, k) {\\n    function is_good_number_of_candies(cmin) {\\n        let count = 0;\\n        for (let c of cand) {\\n            count += Math.trunc(c / cmin); // how many mins (cmin) can we give from this pile (c)\\n        }\\n        return count >= k;\\n    }\\n\\n    let sum = cand.reduce((sum, x) => sum + x, 0);\\n    if (sum < k) return 0; // not enough, to give at least 1 candy\\n\\n    let lo = 1; // 1 is possible\\n    let hi = cand.reduce((max, x) => Math.max(max, x), -Infinity); // max possible\\n\\n    // since # of candies are too large, try binary search\\n    while (lo <= hi) {\\n        let mid = lo + Math.trunc((hi - lo) / 2);\\n        if (is_good_number_of_candies(mid)) {\\n            lo = mid + 1; // mid is good (##), try next one\\n        } else {\\n            hi = mid - 1;\\n        }\\n    }\\n    return lo - 1; // last good was mid, 1 below lo (## above)\\n};\\n```\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maximumCandies = function (candies, k) {\\n    function ok(min_candy) {\\n        let count = 0;\\n        for (let candy of candies) count += Math.floor(candy / min_candy);\\n        return count >= k;\\n    }\\n\\n    let l = 0,\\n        h = Math.max(...candies);\\n\\n    while (l <= h) {\\n        let m = l + Math.trunc((h - l) / 2);\\n        if (ok(m)) l = m + 1;\\n        else h = m - 1;\\n    }\\n    return h;\\n};\\n```\n```\\nvar maximumCandies = function (cand, k) {\\n    function is_good_number_of_candies(cmin) {\\n        let count = 0;\\n        for (let c of cand) {\\n            count += Math.trunc(c / cmin); // how many mins (cmin) can we give from this pile (c)\\n        }\\n        return count >= k;\\n    }\\n\\n    let sum = cand.reduce((sum, x) => sum + x, 0);\\n    if (sum < k) return 0; // not enough, to give at least 1 candy\\n\\n    let lo = 1; // 1 is possible\\n    let hi = cand.reduce((max, x) => Math.max(max, x), -Infinity); // max possible\\n\\n    // since # of candies are too large, try binary search\\n    while (lo <= hi) {\\n        let mid = lo + Math.trunc((hi - lo) / 2);\\n        if (is_good_number_of_candies(mid)) {\\n            lo = mid + 1; // mid is good (##), try next one\\n        } else {\\n            hi = mid - 1;\\n        }\\n    }\\n    return lo - 1; // last good was mid, 1 below lo (## above)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1908756,
                "title": "c-binary-search-fastest",
                "content": "```\\nclass Solution {\\npublic:\\n    long long solve(vector<int>& c , long long mid){\\n        int n = c.size();\\n        long long cnt = 0;\\n        for(int i = n-1 ; i >= 0 ; i--){\\n            cnt += (c[i]/mid);\\n        }\\n        return cnt;\\n    }\\n    int maximumCandies(vector<int>& c, long long k) {\\n        long long sol = 0;\\n        int n = c.size();\\n        int low = 1;\\n        int high = *max_element(c.begin(),c.end());\\n        while(low <= high){\\n            long long mid = (high+low)/2;\\n            cout<<mid<<\" \";\\n            if(solve(c,mid) >= k){\\n                sol = mid;\\n                low = mid+1;\\n            }\\n            else{\\n                high = mid-1;\\n            }\\n        }\\n        \\n        return sol;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long solve(vector<int>& c , long long mid){\\n        int n = c.size();\\n        long long cnt = 0;\\n        for(int i = n-1 ; i >= 0 ; i--){\\n            cnt += (c[i]/mid);\\n        }\\n        return cnt;\\n    }\\n    int maximumCandies(vector<int>& c, long long k) {\\n        long long sol = 0;\\n        int n = c.size();\\n        int low = 1;\\n        int high = *max_element(c.begin(),c.end());\\n        while(low <= high){\\n            long long mid = (high+low)/2;\\n            cout<<mid<<\" \";\\n            if(solve(c,mid) >= k){\\n                sol = mid;\\n                low = mid+1;\\n            }\\n            else{\\n                high = mid-1;\\n            }\\n        }\\n        \\n        return sol;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3925584,
                "title": "c-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& arr, long long k) {\\n          long long int result = 0 ;\\n          long long int low  = 1;\\n          auto it = max_element(arr.begin() , arr.end());\\n          long long int high = (long long int)(*it);\\n          int n = arr.size();\\n          while(low <= high){\\n              long long int mid = low + (high - low)/2;\\n              long long int count = 0;\\n              for(int i = 0 ; i < n ; i++){\\n                  count += ((long long int)arr[i] / mid);\\n                  if(count >= k)break;\\n              }\\n              if(count >= k){\\n                   result = mid;\\n                   low = mid + 1;\\n               }else{\\n                   high = mid - 1;\\n              }\\n          }\\n          return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& arr, long long k) {\\n          long long int result = 0 ;\\n          long long int low  = 1;\\n          auto it = max_element(arr.begin() , arr.end());\\n          long long int high = (long long int)(*it);\\n          int n = arr.size();\\n          while(low <= high){\\n              long long int mid = low + (high - low)/2;\\n              long long int count = 0;\\n              for(int i = 0 ; i < n ; i++){\\n                  count += ((long long int)arr[i] / mid);\\n                  if(count >= k)break;\\n              }\\n              if(count >= k){\\n                   result = mid;\\n                   low = mid + 1;\\n               }else{\\n                   high = mid - 1;\\n              }\\n          }\\n          return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3601419,
                "title": "binary-search-c-with-explanation",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere i apply **Binary Search Algorithm** to find out Maximum Number of candies.\\n\\nMaximum Number of Candies Always Belong to range **[1 , Maximum of array]** , number of Maximum Candies can be any Element from this sorted array that satisfy the given condition-\\n**[1,2,3,4,5,6,7,8,9...........Maximum of given array]**\\n\\nFirst  = 1 \\nLast   = Maximum\\n\\nFind Index That Satisfy the Given Condition(allocate piles of candies to k children such that each child gets the same number of candies) ?\\n\\n**Note:-Here I also apply the same approach, have a look at these problems and try to solve with the same approach.**\\n\\n**Problem:-** https://leetcode.com/problems/koko-eating-bananas/description/\\n**Solution:-** https://leetcode.com/problems/koko-eating-bananas/solutions/3601174/binary-search-c-with-explanation/\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:O(N*Log(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int> arr,long long k,int n)\\n    {\\n        long long count = 0;\\n        for(int i = 0;i<arr.size();i++)\\n        count+=(arr[i]/n);\\n        \\n        if(count>=k)\\n        return true;\\n\\n        return false;\\n    }\\n    int maximumCandies(vector<int>& arr, long long k) {\\n        \\n           int n = arr.size(),ans = 0;\\n           int first = 1,last = INT_MIN;\\n\\n           for(int i = 0;i<n;i++)\\n           last = max(last,arr[i])+1;\\n        \\n           while(first<last)\\n           {\\n               int mid = (first+last)/2;\\n\\n               if(check(arr,k,mid))\\n               {\\n                   first = mid+1;\\n                   ans = max(ans,mid);\\n               }\\n               else\\n               last = mid;\\n           }\\n           \\n           return ans;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/4d957791-93e7-424e-a2ba-a546017c5145_1685983637.253224.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int> arr,long long k,int n)\\n    {\\n        long long count = 0;\\n        for(int i = 0;i<arr.size();i++)\\n        count+=(arr[i]/n);\\n        \\n        if(count>=k)\\n        return true;\\n\\n        return false;\\n    }\\n    int maximumCandies(vector<int>& arr, long long k) {\\n        \\n           int n = arr.size(),ans = 0;\\n           int first = 1,last = INT_MIN;\\n\\n           for(int i = 0;i<n;i++)\\n           last = max(last,arr[i])+1;\\n        \\n           while(first<last)\\n           {\\n               int mid = (first+last)/2;\\n\\n               if(check(arr,k,mid))\\n               {\\n                   first = mid+1;\\n                   ans = max(ans,mid);\\n               }\\n               else\\n               last = mid;\\n           }\\n           \\n           return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3365306,
                "title": "using-binary-search-on-answer-explanation",
                "content": "instead of applying binary search directly on array we will apply binary search on the range of the answer.\\n\\nlow = 1 because there can be minimum 1 candy in the array\\nhigh = maximum in the array because that is the maaximum amount of candies that can be present in the pile\\n\\n\\nnow we want to validate each mid that we will get \\n# Code\\n```\\nclass Solution {\\n    public int maximumCandies (int[] candies, long k) {\\n        int max = 0;\\n        for (int i : candies) {\\n            max = (max > i) ? max : i;\\n        }\\n        int start = 1, end = max, mid = 0, res = 0;\\n        while (start <= end) {\\n            mid = start + (end - start) / 2;\\n            if (isValid(candies, k, mid)) {\\n                res = mid;\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        return res;\\n    }\\n    private boolean isValid(int[] candies, long k, int mid) {\\n        long totalPiles = 0;\\n        for (int i : candies) {\\n            int toAdd = i / mid;\\n            totalPiles += toAdd;\\n        }\\n        return totalPiles >= k;\\n    }\\n\\n}\\n```\\nyou can check out my github repository where i am uploading famous interview questions topic wise with solutions.\\nlink-- https://github.com/Abhaydutt2003/DataStructureAndAlgoPractice \\nkindly upvote if you like my solution. you can ask doubts below.\\n",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies (int[] candies, long k) {\\n        int max = 0;\\n        for (int i : candies) {\\n            max = (max > i) ? max : i;\\n        }\\n        int start = 1, end = max, mid = 0, res = 0;\\n        while (start <= end) {\\n            mid = start + (end - start) / 2;\\n            if (isValid(candies, k, mid)) {\\n                res = mid;\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        return res;\\n    }\\n    private boolean isValid(int[] candies, long k, int mid) {\\n        long totalPiles = 0;\\n        for (int i : candies) {\\n            int toAdd = i / mid;\\n            totalPiles += toAdd;\\n        }\\n        return totalPiles >= k;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272035,
                "title": "c-binary-search-on-search-space-easy-solution",
                "content": "**Time Complexity : O(n*logm)** , where m is the maximum number of candies in the single pile.\\n```\\nclass Solution {\\nprivate:\\n    bool isValid(vector<int>& candies, long long k, int max_candies){\\n        long long child_cnt = 0;\\n        \\n        for(auto candies: candies)\\n            child_cnt += candies/max_candies;\\n        \\n        return child_cnt >= k;\\n    }\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int start = 1;\\n        int end = *max_element(candies.begin(), candies.end());\\n        int res = 0;\\n\\t\\t\\n        while(start <= end){\\n            int mid = start+(end-start)/2;\\n            if(isValid(candies, k, mid)){\\n                res = mid;\\n                start = mid+1;\\n            }\\n            else\\n                end = mid-1;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\nUpvote if this helps.\\nThanks!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool isValid(vector<int>& candies, long long k, int max_candies){\\n        long long child_cnt = 0;\\n        \\n        for(auto candies: candies)\\n            child_cnt += candies/max_candies;\\n        \\n        return child_cnt >= k;\\n    }\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int start = 1;\\n        int end = *max_element(candies.begin(), candies.end());\\n        int res = 0;\\n\\t\\t\\n        while(start <= end){\\n            int mid = start+(end-start)/2;\\n            if(isValid(candies, k, mid)){\\n                res = mid;\\n                start = mid+1;\\n            }\\n            else\\n                end = mid-1;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269073,
                "title": "easy-java-code-beats-99",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst find the range of candies to be distributed then,\\nUse Binary Search to find the maximum number of candies distributed.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nlogn)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        \\n        long sum = 0;\\n        for(int i = 0 ; i < candies.length; i++){\\n            sum+= candies[i];\\n        }\\n        int left = 1;\\n        int right = (int)(sum/k);\\n        // System.out.println(sum+\" \"+right);\\n        \\n        while(left <= right){\\n            int mid = (right - left) / 2 + left;\\n            long count = 0;\\n            \\n            for(int i = 0 ; i < candies.length; i++){\\n                count+= candies[i]/mid;\\n            }\\n            if(count >= k){\\n                left = mid+1;\\n            }\\n            else{\\n                right = mid-1;\\n            }\\n        }\\n        return right;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        \\n        long sum = 0;\\n        for(int i = 0 ; i < candies.length; i++){\\n            sum+= candies[i];\\n        }\\n        int left = 1;\\n        int right = (int)(sum/k);\\n        // System.out.println(sum+\" \"+right);\\n        \\n        while(left <= right){\\n            int mid = (right - left) / 2 + left;\\n            long count = 0;\\n            \\n            for(int i = 0 ; i < candies.length; i++){\\n                count+= candies[i]/mid;\\n            }\\n            if(count >= k){\\n                left = mid+1;\\n            }\\n            else{\\n                right = mid-1;\\n            }\\n        }\\n        return right;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3157693,
                "title": "java-sol-easy-binary-search-simple",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int low = 1;\\n        int high = Arrays.stream(candies).max().getAsInt();\\n        int ans = 0;\\n        while (low<=high) {\\n            int mid = low + (high-low)/2;\\n            long currAns = 0;\\n            for (int i : candies) {\\n                currAns += i/mid;\\n            }\\n            if (currAns >= k) {\\n                low = mid+1;\\n                ans = Math.max(ans, mid);\\n            }\\n            else {\\n                high = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int low = 1;\\n        int high = Arrays.stream(candies).max().getAsInt();\\n        int ans = 0;\\n        while (low<=high) {\\n            int mid = low + (high-low)/2;\\n            long currAns = 0;\\n            for (int i : candies) {\\n                currAns += i/mid;\\n            }\\n            if (currAns >= k) {\\n                low = mid+1;\\n                ans = Math.max(ans, mid);\\n            }\\n            else {\\n                high = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911441,
                "title": "binary-search-method",
                "content": "class Solution {\\npublic:\\n    bool allocation(vector<int>& candies,long long k,long long mid){\\n        if(mid==0) return true;\\n        \\n        long long q=0;\\n        long long count=0;\\n         for(int i=0;i<candies.size();i++){\\n            int q=candies[i]/mid;\\n            count+=q;\\n            if(count>=k){\\n               return true;\\n              }\\n        }\\n        \\n        return false;\\n        \\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        int ans=0;\\n        for(int i=0;i<candies.size();i++){\\n          ans=max(ans,candies[i]);\\n        }  \\n        long long low=0,high=ans;\\n        while(low<high){\\n            long long mid=(low+high)/2;\\n            \\n            if(allocation(candies,k,mid)){\\n                low=mid+1;\\n            }else{\\n                high=mid;\\n            }\\n        }\\n       \\n       return allocation(candies,k,low)?low:low-1;\\n        \\n       \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool allocation(vector<int>& candies,long long k,long long mid){\\n        if(mid==0) return true;\\n        \\n        long long q=0;\\n        long long count=0;\\n         for(int i=0;i<candies.size();i++){\\n            int q=candies[i]/mid;\\n            count+=q;\\n            if(count>=k){\\n               return true;\\n              }",
                "codeTag": "Java"
            },
            {
                "id": 1911109,
                "title": "c-simple-binary-search-solution-o-n-log-max-candies",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& arr,int mid, long long k){\\n        long long count = 0;\\n        for(int i : arr){\\n            count += (i/mid);\\n        }\\n        \\n        return (count >= k);\\n    }\\n    \\n    int maximumCandies(vector<int>& arr, long long k) {\\n        int lo = 1, hi = *max_element(arr.begin(),arr.end()),ans = 0;        \\n        while(lo <= hi){\\n            int mid = lo + (hi - lo)/2;\\n            if(check(arr,mid,k)){\\n                ans = mid;\\n                lo = mid + 1;\\n            }else{\\n                hi = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& arr,int mid, long long k){\\n        long long count = 0;\\n        for(int i : arr){\\n            count += (i/mid);\\n        }\\n        \\n        return (count >= k);\\n    }\\n    \\n    int maximumCandies(vector<int>& arr, long long k) {\\n        int lo = 1, hi = *max_element(arr.begin(),arr.end()),ans = 0;        \\n        while(lo <= hi){\\n            int mid = lo + (hi - lo)/2;\\n            if(check(arr,mid,k)){\\n                ans = mid;\\n                lo = mid + 1;\\n            }else{\\n                hi = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909817,
                "title": "c-binary-search",
                "content": "```\\n  bool is_possible(vector<int>& candies, int mid, long long k)\\n    {\\n        long long count = 0;\\n        \\n        for(int i = 0; i < candies.size(); i++)\\n        {\\n            count += candies[i] / mid;\\n        }\\n        \\n        if(count >= k)\\n            return true;\\n        \\n        return false;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        int n = candies.size();\\n        \\n        int low = 1;\\n        \\n        int high = *max_element(candies.begin(), candies.end());\\n        \\n        int ans = 0;\\n        \\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            \\n            if(is_possible(candies, mid, k))\\n            {\\n                ans = mid;\\n                \\n                low = mid + 1;\\n            }\\n            else\\n            {\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    \\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n  bool is_possible(vector<int>& candies, int mid, long long k)\\n    {\\n        long long count = 0;\\n        \\n        for(int i = 0; i < candies.size(); i++)\\n        {\\n            count += candies[i] / mid;\\n        }\\n        \\n        if(count >= k)\\n            return true;\\n        \\n        return false;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        int n = candies.size();\\n        \\n        int low = 1;\\n        \\n        int high = *max_element(candies.begin(), candies.end());\\n        \\n        int ans = 0;\\n        \\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            \\n            if(is_possible(candies, mid, k))\\n            {\\n                ans = mid;\\n                \\n                low = mid + 1;\\n            }\\n            else\\n            {\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1909667,
                "title": "c-binary-search-solution",
                "content": "**Please Upvote If It Helps**\\n```\\nclass Solution {\\npublic:\\n    bool valid(int mid,vector<int>& candies,long long k)\\n    {\\n        // it will containg the count that will tell we can assign or not assign candies to children \\n        long sum = 0;\\n        for(auto it : candies)\\n        {\\n            sum += (it/mid);\\n            \\n            // if any time our sum is reches to k childrens it means we can assign so return true\\n            if(sum>=k)\\n                return true;\\n        }\\n        return false;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) \\n    {\\n        // initializing two pointers onr for min one for max\\n        // our answer lies between both of them it is final\\n        long left  = 1;\\n        long right = *max_element(begin(candies), end(candies));\\n        \\n        // applyting the binary search for searching that element\\n        while(left<=right)\\n        {\\n            // deriving mid value\\n            long mid = left+(right-left)/2;\\n            \\n            // if we can assign mid candies to k childrens successfully \\n            // then can check for next bigger value\\n            if(valid(mid,candies,k))\\n            {\\n                left = mid+1;\\n            }\\n            \\n            // if we can not assign mid candies to k childrens successfully\\n            // then can check for lesser value\\n            else\\n            {\\n                right = mid-1;\\n            }\\n        }\\n        return right;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool valid(int mid,vector<int>& candies,long long k)\\n    {\\n        // it will containg the count that will tell we can assign or not assign candies to children \\n        long sum = 0;\\n        for(auto it : candies)\\n        {\\n            sum += (it/mid);\\n            \\n            // if any time our sum is reches to k childrens it means we can assign so return true\\n            if(sum>=k)\\n                return true;\\n        }\\n        return false;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) \\n    {\\n        // initializing two pointers onr for min one for max\\n        // our answer lies between both of them it is final\\n        long left  = 1;\\n        long right = *max_element(begin(candies), end(candies));\\n        \\n        // applyting the binary search for searching that element\\n        while(left<=right)\\n        {\\n            // deriving mid value\\n            long mid = left+(right-left)/2;\\n            \\n            // if we can assign mid candies to k childrens successfully \\n            // then can check for next bigger value\\n            if(valid(mid,candies,k))\\n            {\\n                left = mid+1;\\n            }\\n            \\n            // if we can not assign mid candies to k childrens successfully\\n            // then can check for lesser value\\n            else\\n            {\\n                right = mid-1;\\n            }\\n        }\\n        return right;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909092,
                "title": "java-binary-search-easy-to-understand",
                "content": "**Here I am discussing my approach to this problem**\\n**Approach:**\\n1. First calculate **total number** of candies. Let it be `sum`.\\n2. If `sum < k`, **return 0** we have **more children than candies**.\\n3. If `sum = k`, **return 1** as we have** as many children as candies**.\\n4. Else, perform **binary search** on **number of candies** in the range where `low = 1`, and `high = max of candies`.\\n5. Check for `mid`, if we can distribute mid number of candies to each children, then we can move `low to mid + 1`, else move` high to mid - 1.`\\n6. Store the **last satisfied mid value in `ans`**.\\n7. Return `ans`.\\n\\n**Source Code:**\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        long sum = 0;\\n        long max = 0;\\n        \\n        for(int v : candies) {\\n            sum += v;\\n            max = Math.max(v, max);\\n        }\\n        \\n        if(sum < k)\\n            return 0;\\n        \\n        if(sum == k)\\n            return 1;\\n        \\n        long x = 1, y = max, ans = 1;\\n        \\n        while(x <= y) {\\n            long mid = (x + y) >> 1;\\n            long cur = 0;\\n            \\n            for(int v : candies) {\\n                cur += v / mid;\\n            }\\n            \\n            if(cur>= k) {\\n                ans = mid;\\n                x = mid + 1;\\n            }\\n            else\\n                y = mid - 1;\\n        }\\n        \\n        return (int) (ans);\\n        \\n    }\\n}\\n```\\n\\n**Complexity Analysis:**\\n```\\nTime Complexity: O(n * log(max)) // n = number of candy piles, max = max value of candy pile\\nSpace Complexity : O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        long sum = 0;\\n        long max = 0;\\n        \\n        for(int v : candies) {\\n            sum += v;\\n            max = Math.max(v, max);\\n        }\\n        \\n        if(sum < k)\\n            return 0;\\n        \\n        if(sum == k)\\n            return 1;\\n        \\n        long x = 1, y = max, ans = 1;\\n        \\n        while(x <= y) {\\n            long mid = (x + y) >> 1;\\n            long cur = 0;\\n            \\n            for(int v : candies) {\\n                cur += v / mid;\\n            }\\n            \\n            if(cur>= k) {\\n                ans = mid;\\n                x = mid + 1;\\n            }\\n            else\\n                y = mid - 1;\\n        }\\n        \\n        return (int) (ans);\\n        \\n    }\\n}\\n```\n```\\nTime Complexity: O(n * log(max)) // n = number of candy piles, max = max value of candy pile\\nSpace Complexity : O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909052,
                "title": "c-binary-search-easy-explaination-code",
                "content": "```\\n\\nclass Solution\\n{\\npublic:\\n    long long int maxPiles(vector<int> candies, long long int k)\\n    {\\n        long long int l = 1; // We can select an minimum 1 element\\n        long long int h = 0;\\n        for (auto i : candies)\\n        {\\n            h += i;\\n        }\\n        if (k > h)\\n        {\\n            return 0;\\n        }\\n        h /= k; // at most selection\\n                //  this ans for storing mid value\\n        int ans = 0;\\n        while (l <= h)\\n        {\\n            long long mid = (l + h) / 2;\\n            long long int count = 0;\\n            for (auto i : candies)\\n            {\\n                int tt = (i / mid);\\n                count += tt;\\n            }\\n            if (count >= k)\\n            {\\n                ans = mid; // updating mid\\n                l = mid + 1;\\n            }\\n            else\\n            {\\n                h = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int maximumCandies(vector<int> &candies, long long k)\\n    {\\n        return maxPiles(candies, k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n\\nclass Solution\\n{\\npublic:\\n    long long int maxPiles(vector<int> candies, long long int k)\\n    {\\n        long long int l = 1; // We can select an minimum 1 element\\n        long long int h = 0;\\n        for (auto i : candies)\\n        {\\n            h += i;\\n        }\\n        if (k > h)\\n        {\\n            return 0;\\n        }\\n        h /= k; // at most selection\\n                //  this ans for storing mid value\\n        int ans = 0;\\n        while (l <= h)\\n        {\\n            long long mid = (l + h) / 2;\\n            long long int count = 0;\\n            for (auto i : candies)\\n            {\\n                int tt = (i / mid);\\n                count += tt;\\n            }\\n            if (count >= k)\\n            {\\n                ans = mid; // updating mid\\n                l = mid + 1;\\n            }\\n            else\\n            {\\n                h = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int maximumCandies(vector<int> &candies, long long k)\\n    {\\n        return maxPiles(candies, k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908784,
                "title": "cpp-binary-search-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    //checks if each children can get C candies\\n    bool isPossible(vector<int>& candies, long long C, long long k) {\\n        long long cnt = 0;\\n        for(auto c : candies) {\\n            cnt += (long long)(c/C);\\n        }\\n        \\n        return cnt >= k;\\n    }\\n    \\n    //Binary Search on ans(no. of candies each can get)\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long sum = 0;\\n        for(auto c : candies) sum += (long long)c;\\n        \\n        long long end = sum / k + 1;\\n        long long beg = 0;\\n        while(beg + 1 < end) {\\n            long long mid = (beg + end) / 2;\\n            if(isGood(candies, mid, k)) beg = mid;\\n            else end = mid;\\n        }\\n        \\n        return (int)beg;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    //checks if each children can get C candies\\n    bool isPossible(vector<int>& candies, long long C, long long k) {\\n        long long cnt = 0;\\n        for(auto c : candies) {\\n            cnt += (long long)(c/C);\\n        }\\n        \\n        return cnt >= k;\\n    }\\n    \\n    //Binary Search on ans(no. of candies each can get)\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long sum = 0;\\n        for(auto c : candies) sum += (long long)c;\\n        \\n        long long end = sum / k + 1;\\n        long long beg = 0;\\n        while(beg + 1 < end) {\\n            long long mid = (beg + end) / 2;\\n            if(isGood(candies, mid, k)) beg = mid;\\n            else end = mid;\\n        }\\n        \\n        return (int)beg;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908729,
                "title": "python-solution-with-binary-search-explained",
                "content": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        # The lower bound is 1 and higher bound is maximum value from candies. \\n        lo, hi = 1, max(candies)\\n        # This higher bound is not generally possible except for cases like candies = [5,5,5,5] & k = 4\\n        res = 0 # Current maximum result\\n        if sum(candies) < k: # If true then we cannot give even 1 candy to each child thus return 0\\n            return 0\\n        \\n        def cal_num_of_piles(pile_size): # Criterion function\\n            count = 0\\n            for c in candies:\\n                count += c // pile_size\\n            return count >= k\\n        \\n        while lo <= hi: # Binary Search Algorithm \\n            mid = (lo + hi + 1) // 2 # Expected answer\\n            if cal_num_of_piles(mid): # Check if mid is a possible answer.\\n                res = mid # Update the current maximum answer\\n                lo = mid + 1 # Check ahead of mid\\n            else:\\n                hi = mid - 1 # Check below mid\\n        return res\\n```\\n\\n**Concept of Binary Search on Answer:**\\nThe best way to explain Binary Search the Answer is that we use binary search to guess the answer to the problem. By guessing we mean that we will get several \\u201CYES\\u201D or \\u201CNO\\u201D feedback or maybe \\u201Ctoo high\\u201D, \\u201Ctoo low\\u201D, or \\u201Cexactly\\u201D responses. Since we need the maximum answer Binary Search tries to converge on the largest possible answer till the possibility exists.\\n\\n**Binary Search on Answer has 3 basic requirements:**\\n1. The problem must have multiple possible answers. **[Range of possible solutions]**\\n2. The problem must be an optimization problem. **[Minimizing/Maximizing the result]**\\n3. We must develope a function/criterion to determine when to update left and right pointers. **[Criterion to update pointers]**\\n\\n**Observations:**\\n`For candies = [5,8,6] & k = 3` we have many possible answers: 1, 2, 3, 4, 5 all seem to work fine but we return 5 as it is the largest.\\n1. Thus we have a range of solutions and we are asked to maximize the final result. **Requirement 1 and 2 are fulfilled**.\\n2. One might feel that the possible answers must be smaller than the smallest value of an array. Eg: `for candies = [5,6,8] & k = 3` then the answer is 5. For say `candies = [7,9,13] & k = 4` the possible answers are 6, 5...2, 1. However this is not always correct. For Eg: `candies = [1,2,3,4,10] & k = 5` the possible answers are 1, 2, 3. Here we can neglect the 0th and 1st piles to get a better answer. This is because we are told that we may let some piles of candies go unused.\\n3. **Developing the criterion:** Since we only need to check if a given value can be possibly divided k times with the given candies array. Hence we get an easy update function. \\n\\t```\\n\\tdef cal_num_of_piles(pile_size):\\n\\t\\tcount = 0 # Number of divisions with current pile_size\\n\\t\\tfor c in candies:\\n\\t\\t\\tcount += c // pile_size # Add how many piles can be generated with ith candies with given pile_size\\n\\t\\treturn count >= k\\n\\t```\\n***So all three requirements are now fulfilled.***\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        # The lower bound is 1 and higher bound is maximum value from candies. \\n        lo, hi = 1, max(candies)\\n        # This higher bound is not generally possible except for cases like candies = [5,5,5,5] & k = 4\\n        res = 0 # Current maximum result\\n        if sum(candies) < k: # If true then we cannot give even 1 candy to each child thus return 0\\n            return 0\\n        \\n        def cal_num_of_piles(pile_size): # Criterion function\\n            count = 0\\n            for c in candies:\\n                count += c // pile_size\\n            return count >= k\\n        \\n        while lo <= hi: # Binary Search Algorithm \\n            mid = (lo + hi + 1) // 2 # Expected answer\\n            if cal_num_of_piles(mid): # Check if mid is a possible answer.\\n                res = mid # Update the current maximum answer\\n                lo = mid + 1 # Check ahead of mid\\n            else:\\n                hi = mid - 1 # Check below mid\\n        return res\\n```\n```\\n\\tdef cal_num_of_piles(pile_size):\\n\\t\\tcount = 0 # Number of divisions with current pile_size\\n\\t\\tfor c in candies:\\n\\t\\t\\tcount += c // pile_size # Add how many piles can be generated with ith candies with given pile_size\\n\\t\\treturn count >= k\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 3822063,
                "title": "beats-100-binary-search-easy-approach",
                "content": "# Complexity\\n- Time complexity : $$O(NlogN + NlogM)$$ M = Range i.e. high-low = totSum/k-1\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int n = candies.size();\\n        sort(begin(candies),end(candies));\\n\\n        long long totSum = accumulate(begin(candies),end(candies),0ll);\\n        if(totSum < k) return 0;\\n\\n        long long low=1 , high=totSum/k; // can also take some bigger value like 1e8\\n        while(low <= high) {\\n            long long mid = low + (high-low)/2;\\n\\n            if(isPossible(mid,candies,k)) low = mid+1;\\n            else high = mid-1;\\n        }\\n        return high;\\n    }\\n\\n    bool isPossible(long long mid, vector<int> &candies, long long k) {\\n        int n = candies.size();\\n        long long cnt = 0;\\n        for(int i=0 ; i<n ; i++) {\\n            cnt += 1ll*(candies[i]/mid);\\n        }\\n        return cnt>=k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int n = candies.size();\\n        sort(begin(candies),end(candies));\\n\\n        long long totSum = accumulate(begin(candies),end(candies),0ll);\\n        if(totSum < k) return 0;\\n\\n        long long low=1 , high=totSum/k; // can also take some bigger value like 1e8\\n        while(low <= high) {\\n            long long mid = low + (high-low)/2;\\n\\n            if(isPossible(mid,candies,k)) low = mid+1;\\n            else high = mid-1;\\n        }\\n        return high;\\n    }\\n\\n    bool isPossible(long long mid, vector<int> &candies, long long k) {\\n        int n = candies.size();\\n        long long cnt = 0;\\n        for(int i=0 ; i<n ; i++) {\\n            cnt += 1ll*(candies[i]/mid);\\n        }\\n        return cnt>=k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3273752,
                "title": "beats-99-easy-binary-search",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int n=candies.size();\\n        long long sum=0;\\n        for(auto i:candies)sum+=i;\\n        int mn=*min_element(candies.begin(),candies.end());\\n        long long s=mn/((k+n-1)/n);\\n        long long e=sum/k;\\n        long long m;\\n        while(s<=e){\\n            m=(s+e)/2;\\n            long long ct=0;\\n            if(m==0){\\n                ct=LONG_MAX;\\n            }else{\\n            for(auto i:candies){\\n                ct+=(i/m);\\n            }\\n            }\\n            if(ct<k){\\n                e=m-1;\\n            }else{\\n                s=m+1;\\n            }\\n        }\\n        return e;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int n=candies.size();\\n        long long sum=0;\\n        for(auto i:candies)sum+=i;\\n        int mn=*min_element(candies.begin(),candies.end());\\n        long long s=mn/((k+n-1)/n);\\n        long long e=sum/k;\\n        long long m;\\n        while(s<=e){\\n            m=(s+e)/2;\\n            long long ct=0;\\n            if(m==0){\\n                ct=LONG_MAX;\\n            }else{\\n            for(auto i:candies){\\n                ct+=(i/m);\\n            }\\n            }\\n            if(ct<k){\\n                e=m-1;\\n            }else{\\n                s=m+1;\\n            }\\n        }\\n        return e;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268223,
                "title": "range-bs-runtime-174-ms-beats-98-32-must-see",
                "content": "# Code\\n```\\n//for fast io\\nstatic int fast_io = []() \\n{ \\n    std::ios::sync_with_stdio(false); \\n    cin.tie(nullptr); \\n    cout.tie(nullptr); \\n    return 0; \\n}();\\n\\n#ifdef LOCAL\\n    freopen(\"input.txt\", \"r\" , stdin);\\n    freopen(\"output.txt\", \"w\", stdout);\\n#endif\\n//actual code\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) \\n    {\\n        long long int maxele = *max_element(candies.begin(),candies.end());\\n        long long int start = 0;\\n        long long int end   = maxele;\\n        long long int ans = 0;\\n\\n        while(start <= end)\\n        {\\n            long long int mid = (start + ((end-start)/2));\\n\\n            //we will try to allocate the piles to every children \\n            //having exactly mid candies\\n\\n            if(fun(candies,mid,k) == true)\\n            {\\n                if(mid > ans) ans = mid;\\n                start = mid+1;\\n            }\\n            else \\n            {\\n                end = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    bool fun(vector<int>&arr,long long int &mid,long long int &k)\\n    {\\n        if(mid == 0) return true;\\n\\n        long long int count = 0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            long long int temp = (arr[i]/mid);\\n            count = count + temp;\\n        }\\n        if(count >= k) return true;\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\n//for fast io\\nstatic int fast_io = []() \\n{ \\n    std::ios::sync_with_stdio(false); \\n    cin.tie(nullptr); \\n    cout.tie(nullptr); \\n    return 0; \\n}();\\n\\n#ifdef LOCAL\\n    freopen(\"input.txt\", \"r\" , stdin);\\n    freopen(\"output.txt\", \"w\", stdout);\\n#endif\\n//actual code\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) \\n    {\\n        long long int maxele = *max_element(candies.begin(),candies.end());\\n        long long int start = 0;\\n        long long int end   = maxele;\\n        long long int ans = 0;\\n\\n        while(start <= end)\\n        {\\n            long long int mid = (start + ((end-start)/2));\\n\\n            //we will try to allocate the piles to every children \\n            //having exactly mid candies\\n\\n            if(fun(candies,mid,k) == true)\\n            {\\n                if(mid > ans) ans = mid;\\n                start = mid+1;\\n            }\\n            else \\n            {\\n                end = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    bool fun(vector<int>&arr,long long int &mid,long long int &k)\\n    {\\n        if(mid == 0) return true;\\n\\n        long long int count = 0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            long long int temp = (arr[i]/mid);\\n            count = count + temp;\\n        }\\n        if(count >= k) return true;\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2962740,
                "title": "c-binary-search-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>& candies, long long k, int mid) {\\n        long long n = candies.size(), candy = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            candy = candy + candies[i]/mid;\\n        }\\n\\n        if(candy >= k) \\n            return true;\\n\\n        else return false;\\n        \\n    }\\n\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long n = candies.size(), max = INT_MIN;\\n        long long sum = 0;\\n\\n        for(int i = 0; i < n; i++) {\\n            sum = candies[i] + sum;         //calculating sum of all candies\\n            if(candies[i] > max) {          //calculating minimum pile of candy\\n                max = candies[i];\\n            }\\n        }\\n\\n        if(sum < k) {\\n            return 0;       // bcoz no. children is more than total candy\\n        }\\n\\n        long long start = 1, end = max, ans = 0;\\n        long long mid = start + (end - start)/2;\\n\\n        while(start <= end) {\\n            int mid = start + (end - start)/2;\\n\\n            if(solve(candies, k, mid)) {\\n                start = mid + 1;\\n                ans = mid;\\n            }\\n\\n            else {\\n                end = mid - 1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n# Complexity\\n- Time complexity: O(n log m)\\n\\n- Space complexity: O(1)",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>& candies, long long k, int mid) {\\n        long long n = candies.size(), candy = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            candy = candy + candies[i]/mid;\\n        }\\n\\n        if(candy >= k) \\n            return true;\\n\\n        else return false;\\n        \\n    }\\n\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long n = candies.size(), max = INT_MIN;\\n        long long sum = 0;\\n\\n        for(int i = 0; i < n; i++) {\\n            sum = candies[i] + sum;         //calculating sum of all candies\\n            if(candies[i] > max) {          //calculating minimum pile of candy\\n                max = candies[i];\\n            }\\n        }\\n\\n        if(sum < k) {\\n            return 0;       // bcoz no. children is more than total candy\\n        }\\n\\n        long long start = 1, end = max, ans = 0;\\n        long long mid = start + (end - start)/2;\\n\\n        while(start <= end) {\\n            int mid = start + (end - start)/2;\\n\\n            if(solve(candies, k, mid)) {\\n                start = mid + 1;\\n                ans = mid;\\n            }\\n\\n            else {\\n                end = mid - 1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2836560,
                "title": "simple-c-solution-using-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int n;\\n    bool good(int x , long long k , vector<int> &arr ){\\n        long long ct = 0;\\n        for(int i=0 ; i<n ; i++){\\n            ct += (arr[i]/x);\\n        }\\n        return (ct>=k);\\n    }\\n    int maximumCandies(vector<int>& arr, long long k) {\\n        int low = 1;\\n        int high = 1e9+1;\\n        n = arr.size();\\n        int ans = 0;\\n        \\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            \\n            if(good(mid , k , arr)){\\n                ans = mid;\\n                low = mid+1;\\n            }\\n            else{\\n                high = mid-1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n// [4,7,5]\\n// 4\\n\\n// op -> 3\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    bool good(int x , long long k , vector<int> &arr ){\\n        long long ct = 0;\\n        for(int i=0 ; i<n ; i++){\\n            ct += (arr[i]/x);\\n        }\\n        return (ct>=k);\\n    }\\n    int maximumCandies(vector<int>& arr, long long k) {\\n        int low = 1;\\n        int high = 1e9+1;\\n        n = arr.size();\\n        int ans = 0;\\n        \\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            \\n            if(good(mid , k , arr)){\\n                ans = mid;\\n                low = mid+1;\\n            }\\n            else{\\n                high = mid-1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n// [4,7,5]\\n// 4\\n\\n// op -> 3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2565461,
                "title": "99-faster-python-solution",
                "content": "![image](https://assets.leetcode.com/users/images/8f3fb19a-40a0-4acf-9475-84ea66780864_1662967246.5710497.png)\\n\\n```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        if sum(candies)<k:return 0\\n        else:\\n            low=0 \\n            high=max(candies)\\n            while low<high:\\n                mid=math.ceil((low+high)/2)\\n                if sum(c//mid for c in candies)>=k: low=mid\\n                else: high=mid-1\\n            return low\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        if sum(candies)<k:return 0\\n        else:\\n            low=0 \\n            high=max(candies)\\n            while low<high:\\n                mid=math.ceil((low+high)/2)\\n                if sum(c//mid for c in candies)>=k: low=mid\\n                else: high=mid-1\\n            return low\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2503906,
                "title": "binary-search-ac-code-explained-with-comments",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    \\n    bool isValid(vector<int> &candies, long long k, long long mid){\\n\\n        long long total = 0;\\n        \\n        for(int i=0;i<candies.size();i++){ \\n            \\n           //Here we are maintaining the count of candies that we are distributing. \\n           total += candies[i]/mid;\\n            \\n        }\\n        \\n        //Checking if the total number of candies that can be distirbuted\\n        //for the pile of value \\'mid\\' is less than or equal to total no. of children.\\n        //If the above condition is false then we cannot divide the candies into piler of size mid\\n        return (total>=k);\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        //We will do the binary search for all the elements \\n        // from \\'1\\' to the largest value in the candies.\\n        int low = 1;\\n        int high = INT_MIN;\\n        \\n        for(int i=0;i<candies.size();i++){\\n            high = max(high, candies[i]);\\n        }\\n        \\n        int ans = 0;\\n        \\n        while(low<=high){\\n            long long mid = (low+high)/2;\\n            \\n            //Checking if the middle element can be a valid pile.\\n            //If the function returns true than we will move to the left side to\\n            //check if even a larger answer is possible.\\n            if(isValid(candies, k, mid)){\\n                ans = mid;\\n                low = mid+1;\\n            }else{\\n                //If the function returns false then we will move to the left half\\n                //to find the possible valid pile value.\\n                high = mid-1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool isValid(vector<int> &candies, long long k, long long mid){\\n\\n        long long total = 0;\\n        \\n        for(int i=0;i<candies.size();i++){ \\n            \\n           //Here we are maintaining the count of candies that we are distributing. \\n           total += candies[i]/mid;\\n            \\n        }\\n        \\n        //Checking if the total number of candies that can be distirbuted\\n        //for the pile of value \\'mid\\' is less than or equal to total no. of children.\\n        //If the above condition is false then we cannot divide the candies into piler of size mid\\n        return (total>=k);\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        //We will do the binary search for all the elements \\n        // from \\'1\\' to the largest value in the candies.\\n        int low = 1;\\n        int high = INT_MIN;\\n        \\n        for(int i=0;i<candies.size();i++){\\n            high = max(high, candies[i]);\\n        }\\n        \\n        int ans = 0;\\n        \\n        while(low<=high){\\n            long long mid = (low+high)/2;\\n            \\n            //Checking if the middle element can be a valid pile.\\n            //If the function returns true than we will move to the left side to\\n            //check if even a larger answer is possible.\\n            if(isValid(candies, k, mid)){\\n                ans = mid;\\n                low = mid+1;\\n            }else{\\n                //If the function returns false then we will move to the left half\\n                //to find the possible valid pile value.\\n                high = mid-1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2442477,
                "title": "c-efficient-sol-with-explanation-complexity",
                "content": "***Explanation :***\\nAccording to question we have to find the maximum size of each pile that we can get to satisfy k children.\\nWe do this using ***Binary Search : (why?)***\\n***Binary Search can be used on following type of problems :***\\n***1. Maximization problems\\n2. Minimization problems***\\nWe binary search for the maximum size of the pile . \\n***Range of binary search :*** \\n***lo=1***, (cannot be 0 sized pile) ***hi=maximum elemnt in candies array.***\\nFor every mid value , we check if it is possible to make k or more piles of size ***mid***\\n***If yes*** , we move ***lo= mid+1***, to get maximum possible size of pile .\\n***If no*** , then we move ***hi= mid-1*** , to decrease size of pile .\\n\\n***Complexity Analysis :\\nTC : O(n log x ) ( x--> maximum elment in candies array)\\nSC : O(1)***\\n\\n**UPVOTE IF YOU LIKE** \\u2705\\uD83D\\uDE0A\\n```\\nclass Solution {\\npublic:\\n    bool isPossible_to_divide(vector<int>&candies,long long size,long long k){\\n        long long ans=0;\\n        for(int i=0;i<candies.size();i++){\\n            ans+=(candies[i]/size);\\n        }\\n        return ans>=k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long lo=1,hi=*max_element(candies.begin(),candies.end()),mid,ans=0;\\n        while(lo<=hi){\\n            mid=lo+(hi-lo)/2;\\n            if(isPossible_to_divide(candies, mid, k)){\\n                ans=mid;\\n                lo=mid+1;\\n            }\\n            else hi=mid-1;\\n        }\\n        return  ans;\\n    }\\n};\\n// Any other queries are welcomed as well.\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible_to_divide(vector<int>&candies,long long size,long long k){\\n        long long ans=0;\\n        for(int i=0;i<candies.size();i++){\\n            ans+=(candies[i]/size);\\n        }\\n        return ans>=k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long lo=1,hi=*max_element(candies.begin(),candies.end()),mid,ans=0;\\n        while(lo<=hi){\\n            mid=lo+(hi-lo)/2;\\n            if(isPossible_to_divide(candies, mid, k)){\\n                ans=mid;\\n                lo=mid+1;\\n            }\\n            else hi=mid-1;\\n        }\\n        return  ans;\\n    }\\n};\\n// Any other queries are welcomed as well.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2402075,
                "title": "c-binary-search-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& c, long long k) {\\n        int left = 1, right = *max_element(c.begin(), c.end());\\n        int ans = 0;\\n        while(left <= right){\\n            int Cand = (left + right) >> 1;\\n            long long sum = 0;\\n            for(auto it: c){\\n                sum += it / Cand;\\n                if(sum >= k) break;\\n            }\\n            if(sum >= k){\\n                ans = Cand;\\n                left = Cand + 1;\\n            }\\n            else{\\n                right = Cand-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& c, long long k) {\\n        int left = 1, right = *max_element(c.begin(), c.end());\\n        int ans = 0;\\n        while(left <= right){\\n            int Cand = (left + right) >> 1;\\n            long long sum = 0;\\n            for(auto it: c){\\n                sum += it / Cand;\\n                if(sum >= k) break;\\n            }\\n            if(sum >= k){\\n                ans = Cand;\\n                left = Cand + 1;\\n            }\\n            else{\\n                right = Cand-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2276939,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& c,long long k,int mid)\\n    {\\n        if(!mid)\\n            return 1;\\n      long long x=0;    \\n        for(int i=0;i<c.size();i++)\\n        {\\n            x+=(c[i]/mid);\\n        }\\n        return x>=k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int low=0,ans=0;\\n       int high=*max_element(candies.begin(),candies.end());\\n        while(low<=high)\\n        {\\n           int mid=(high+low)>>1;\\n            if(solve(candies,k,mid))\\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else\\n            {\\n                high=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& c,long long k,int mid)\\n    {\\n        if(!mid)\\n            return 1;\\n      long long x=0;    \\n        for(int i=0;i<c.size();i++)\\n        {\\n            x+=(c[i]/mid);\\n        }\\n        return x>=k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int low=0,ans=0;\\n       int high=*max_element(candies.begin(),candies.end());\\n        while(low<=high)\\n        {\\n           int mid=(high+low)>>1;\\n            if(solve(candies,k,mid))\\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else\\n            {\\n                high=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2158323,
                "title": "binary-search-approach-with-detailed-explained-in-comments",
                "content": "### Please Upvote if you like this\\n\\n#### Time Complexity: Log(mx)  * O(N)\\n#### Log(mx) for binary search and O(N) for iterating through the candies array.\\n\\n#### Space Complexity: O(1) because we did use constant extra space.\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n//         get the sum and mx of all candies\\n        long long sum = 0;\\n        int mx = INT_MIN;\\n//         Iterate the loop to get the sum of all values and maximum among then\\n        for(int &i: candies){\\n            sum += i;\\n            mx = max(i, mx);\\n        }\\n        \\n//         if sum < k then return 0 because it will never fulfill the k children requirements:\\n//         \"each child gets the same number of candies\" it impossible to distribute atleast 1 candy to all so return 0\\n        \\n        if(sum < k) return 0;\\n        \\n//         start pointers for binary search\\n        int start = 1, end = mx;\\n        int ans = 0;\\n        \\n        \\n        while(start <= end){\\n            \\n            int mid = start + (end-start)/2;\\n            long long cand = 0;\\n            \\n//             take floor all values or simply write (i/mid) because it won\\'t let candies to merged\\n            for(int &i: candies){\\n                cand += floor(i/mid);\\n            }\\n            \\n//             cand >= k means that no. of mid candies can be distributed among all children. If cand >= k update the answer and search for more bigger value.\\n            if(cand >= k){\\n                ans = mid;\\n                start = mid + 1;\\n            }\\n//             if it doesn\\'t satisfy the condition then search for lower value.\\n            else{\\n                end = mid-1;\\n            }\\n        }\\n        // return the possible answer if it is otherwise return 0 as default value of ans.\\n        return ans;\\n    }\\n};\\n```\\n### Please Upvote if you like this",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n//         get the sum and mx of all candies\\n        long long sum = 0;\\n        int mx = INT_MIN;\\n//         Iterate the loop to get the sum of all values and maximum among then\\n        for(int &i: candies){\\n            sum += i;\\n            mx = max(i, mx);\\n        }\\n        \\n//         if sum < k then return 0 because it will never fulfill the k children requirements:\\n//         \"each child gets the same number of candies\" it impossible to distribute atleast 1 candy to all so return 0\\n        \\n        if(sum < k) return 0;\\n        \\n//         start pointers for binary search\\n        int start = 1, end = mx;\\n        int ans = 0;\\n        \\n        \\n        while(start <= end){\\n            \\n            int mid = start + (end-start)/2;\\n            long long cand = 0;\\n            \\n//             take floor all values or simply write (i/mid) because it won\\'t let candies to merged\\n            for(int &i: candies){\\n                cand += floor(i/mid);\\n            }\\n            \\n//             cand >= k means that no. of mid candies can be distributed among all children. If cand >= k update the answer and search for more bigger value.\\n            if(cand >= k){\\n                ans = mid;\\n                start = mid + 1;\\n            }\\n//             if it doesn\\'t satisfy the condition then search for lower value.\\n            else{\\n                end = mid-1;\\n            }\\n        }\\n        // return the possible answer if it is otherwise return 0 as default value of ans.\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017213,
                "title": "c-binary-search-by-value",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        // corner case\\n        long long sum = 0;\\n        for(auto c : candies){\\n            sum += c;\\n        }\\n        if(sum < k){\\n            return 0;\\n        }\\n        // binary search\\n        long long start = 1, end = *max_element(candies.begin(), candies.end());\\n        while(start < end){\\n            long long mid = start + (end - start + 1) / 2; // since we want to get the upper bound of the answers(maximum)\\n            long long count = numKidsAllocatedWithGivenCandyNum(candies, mid);\\n            if(count < k){\\n                // the number is too large, mid cannot be the answer\\n                end = mid - 1; \\n            }\\n            else{\\n                // the number is too small, but could be the answer\\n                start = mid;\\n            }\\n        }\\n        \\n        return start;\\n    }\\n    \\n    long long numKidsAllocatedWithGivenCandyNum(vector<int>& candies, int val){\\n        long long count = 0;\\n        for(auto candy : candies){\\n            count += candy / val;\\n        }\\n        return count;\\n    }\\n \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        // corner case\\n        long long sum = 0;\\n        for(auto c : candies){\\n            sum += c;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2008765,
                "title": "python-binary-search",
                "content": "\\n    def maximumCandies(self, candies, k):\\n        def dfs(c):\\n            count = 0\\n            \\n            for candy in candies:\\n                count += candy//c\\n                \\n            if count >= k:\\n                return True\\n            \\n            return False\\n            \\n        low, high = 1, max(candies)\\n        \\n        while low<=high:\\n            mid = (low+high)//2\\n            \\n            if dfs(mid):\\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n                \\n        return high\\n",
                "solutionTags": [],
                "code": "\\n    def maximumCandies(self, candies, k):\\n        def dfs(c):\\n            count = 0\\n            \\n            for candy in candies:\\n                count += candy//c\\n                \\n            if count >= k:\\n                return True\\n            \\n            return False\\n            \\n        low, high = 1, max(candies)\\n        \\n        while low<=high:\\n            mid = (low+high)//2\\n            \\n            if dfs(mid):\\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n                \\n        return high\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1988406,
                "title": "python-binary-search-99",
                "content": "\\n\\n\\n```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        \\n        total_candies = sum(candies)\\n        max_candies = total_candies//k\\n        \\n        if max_candies<=1:\\n            return max_candies\\n        \\n\\n        i, j = 2, max_candies\\n        \\n        \\n        while i<=j:\\n            candy = (i+j)//2\\n            \\n            n_pile = sum([each//candy for each in candies])\\n            \\n            if n_pile>=k: \\n                i = candy+1\\n            else: \\n                j = candy-1\\n                \\n            \\n                \\n        return candy if n_pile >= k else candy-1\\n            \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        \\n        total_candies = sum(candies)\\n        max_candies = total_candies//k\\n        \\n        if max_candies<=1:\\n            return max_candies\\n        \\n\\n        i, j = 2, max_candies\\n        \\n        \\n        while i<=j:\\n            candy = (i+j)//2\\n            \\n            n_pile = sum([each//candy for each in candies])\\n            \\n            if n_pile>=k: \\n                i = candy+1\\n            else: \\n                j = candy-1\\n                \\n            \\n                \\n        return candy if n_pile >= k else candy-1\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1985777,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int n=candies.length;\\n        long sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=candies[i];\\n        }\\n        if(sum<k)return 0;\\n        if(sum==k)return 1;\\n        long ans=sum/k;\\n       // System.out.println(ans);\\n        if(ans==1)return (int)ans;\\n        long l=0;\\n        long mid=0;\\n        long h=ans;\\n\\t\\t//binary search\\n        while(l<=h){\\n            mid=l+(h-l)/2;\\n              long c=0;\\n            for(int j=0;j<n;j++){\\n                c+=(long)candies[j]/mid;\\n            }\\n            if(c>=k){\\n                ans=mid;\\n               // System.out.println(ans);\\n                l=mid+1;\\n            }\\n            else{\\n                h=mid-1;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n}",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "class Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int n=candies.length;\\n        long sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=candies[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1976270,
                "title": "java-beats-100-00-memory-speed-0ms-april-2022",
                "content": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int max = Integer.MIN_VALUE;\\n        long sum = 0;\\n        \\n        for (int num: candies) {\\n            max = Math.max(max, num);\\n            sum += num;\\n        }\\n        \\n        if (sum < k) {\\n            return 0;\\n        }\\n        \\n        int left = 1, right = max;\\n        \\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            if (canBeDistributed(mid, candies, k)) {\\n                if (!canBeDistributed(mid + 1, candies, k)) {\\n                    return mid;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\n    public boolean canBeDistributed(int num, int[] candies, long k) {\\n        for (int i = 0; i < candies.length && k > 0; ++ i) {\\n            k -= candies[i] / num;\\n        }\\n        \\n        return k <= 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int max = Integer.MIN_VALUE;\\n        long sum = 0;\\n        \\n        for (int num: candies) {\\n            max = Math.max(max, num);\\n            sum += num;\\n        }\\n        \\n        if (sum < k) {\\n            return 0;\\n        }\\n        \\n        int left = 1, right = max;\\n        \\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            if (canBeDistributed(mid, candies, k)) {\\n                if (!canBeDistributed(mid + 1, candies, k)) {\\n                    return mid;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\n    public boolean canBeDistributed(int num, int[] candies, long k) {\\n        for (int i = 0; i < candies.length && k > 0; ++ i) {\\n            k -= candies[i] / num;\\n        }\\n        \\n        return k <= 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1931345,
                "title": "kotlin-binary-search-solution",
                "content": "```\\nclass Solution {\\n    fun maximumCandies(candies: IntArray, k: Long): Int {\\n        var (min, max, sum) = Triple(1, Integer.MIN_VALUE, 0L)\\n        candies.forEach { sum += it.also { if (it > max) max = it } }\\n        if (sum < k) return 0\\n\\n        var result = min\\n        while (max > min) {\\n            if (canEachChildGetCCandies(result, candies, k)) min = result\\n            else max = result -1\\n            result = (min + max + 1) / 2\\n        }\\n        return result\\n    }\\n\\n    fun canEachChildGetCCandies(c: Int, candies: IntArray, k: Long) =\\n        candies.fold(0L) { sum, it -> sum + it / c } >= k\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    fun maximumCandies(candies: IntArray, k: Long): Int {\\n        var (min, max, sum) = Triple(1, Integer.MIN_VALUE, 0L)\\n        candies.forEach { sum += it.also { if (it > max) max = it } }\\n        if (sum < k) return 0\\n\\n        var result = min\\n        while (max > min) {\\n            if (canEachChildGetCCandies(result, candies, k)) min = result\\n            else max = result -1\\n            result = (min + max + 1) / 2\\n        }\\n        return result\\n    }\\n\\n    fun canEachChildGetCCandies(c: Int, candies: IntArray, k: Long) =\\n        candies.fold(0L) { sum, it -> sum + it / c } >= k\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1929691,
                "title": "2-python-solutions-binary-search",
                "content": "### ***Solution 1: Time O(nlog n) / Memory O(1)***\\n```\\nclass Solution:\\n    def maximumCandies(self, C: List[int], k: int) -> int:\\n        lo=0 ; hi=sum(C)//k\\n        while lo<hi:\\n            mid=(lo+hi)//2+1\\n            if sum(c//mid for c in C)>=k: lo=mid\\n            else: hi=mid-1\\n        return lo\\n```\\n-----------------\\n### ***Solution 2: One-Line Version   -->  Time O(nlog n) / Memory O(1)***\\n```\\nclass Solution:\\n    def maximumCandies(self, C: List[int], k: int) -> int:\\n        return bisect_left(range(1,sum(C)//k+1), True, key=lambda x:sum(c//x for c in C)<k)\\n```\\n-------------------\\n***----- Taha Choura -----***\\n*taha.choura@outlook.com*",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, C: List[int], k: int) -> int:\\n        lo=0 ; hi=sum(C)//k\\n        while lo<hi:\\n            mid=(lo+hi)//2+1\\n            if sum(c//mid for c in C)>=k: lo=mid\\n            else: hi=mid-1\\n        return lo\\n```\n```\\nclass Solution:\\n    def maximumCandies(self, C: List[int], k: int) -> int:\\n        return bisect_left(range(1,sum(C)//k+1), True, key=lambda x:sum(c//x for c in C)<k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1927152,
                "title": "c-easy-to-understand-with-simple-binary-search",
                "content": "Expalnation  : \\nstep 1 : find minimum and maximum values of candies you can give to each child that gives you the range of minimum and maximum candies minimum is always 0.\\nstep 2: check for one by one each candies per child on range of minimum and maximum what maximum satisfy your condition but linearly you may get TLE so think of Binary search.\\n\\n\\t    // Binary search on minimum and maximum possible values and \\n\\t   //\\tcheck according to mid value it is possible to allocate mid candies to each child\\n\\t  //  if yess then increase low to mid because we want a maximum candies per child\\n...\\n\\n\\nint maximumCandies(vector<int>& candies, long long k) {\\n        long long sum = 0;\\n        for(long long i=0;i<candies.size();i++)\\n            sum += candies[i];\\n        if(sum < k)\\n            return 0;\\n        if(sum==k)\\n            return 1;\\n        long long low = 0;\\n        long long high = sum/k+1;\\n        \\n        long long ans=0;\\n\\t\\t// Binary search on minimum and maximum possible values and \\n\\t\\t//check according to mid value it is possible to allocate mid candies to each child\\n\\t\\t//if yess then increase low to mid because we want a maximum candies per child\\n       while(low < high)\\n       {\\n           int mid = low + (high - low)/2;\\n           if(mid == 0) return 0;\\n           long long count=0;\\n           for(int j=0;j<candies.size();j++)\\n            {\\n               long long pile = candies[j];\\n                count +=  (pile/mid);\\n            }\\n           if(count>=k)\\n           {\\n               if(mid>ans)\\n                   ans = mid;\\n               low = mid+1;\\n           }\\n           else\\n               high = mid;\\n           \\n       }\\n        return ans==0 ? 0 : ans;\\n    }\\n\\t\\n...",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "Expalnation  : \\nstep 1 : find minimum and maximum values of candies you can give to each child that gives you the range of minimum and maximum candies minimum is always 0.\\nstep 2: check for one by one each candies per child on range of minimum and maximum what maximum satisfy your condition but linearly you may get TLE so think of Binary search.\\n\\n\\t    // Binary search on minimum and maximum possible values and \\n\\t   //\\tcheck according to mid value it is possible to allocate mid candies to each child\\n\\t  //  if yess then increase low to mid because we want a maximum candies per child\\n...\\n\\n\\nint maximumCandies(vector<int>& candies, long long k) {\\n        long long sum = 0;\\n        for(long long i=0;i<candies.size();i++)\\n            sum += candies[i];\\n        if(sum < k)\\n            return 0;\\n        if(sum==k)\\n            return 1;\\n        long long low = 0;\\n        long long high = sum/k+1;\\n        \\n        long long ans=0;\\n\\t\\t// Binary search on minimum and maximum possible values and \\n\\t\\t//check according to mid value it is possible to allocate mid candies to each child\\n\\t\\t//if yess then increase low to mid because we want a maximum candies per child\\n       while(low < high)\\n       {\\n           int mid = low + (high - low)/2;\\n           if(mid == 0) return 0;\\n           long long count=0;\\n           for(int j=0;j<candies.size();j++)\\n            {\\n               long long pile = candies[j];\\n                count +=  (pile/mid);\\n            }\\n           if(count>=k)\\n           {\\n               if(mid>ans)\\n                   ans = mid;\\n               low = mid+1;\\n           }\\n           else\\n               high = mid;\\n           \\n       }\\n        return ans==0 ? 0 : ans;\\n    }\\n\\t\\n...",
                "codeTag": "Unknown"
            },
            {
                "id": 1923331,
                "title": "a-few-solutions",
                "content": "Use binary search to find the maximal `k` candy \"chunks\" we can `take` from each `A[i]`<sup>th</sup> pile of candies to satisfy threshold `T` children.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun maximumCandies(A: IntArray, T: Long): Int {\\n        var i = 0\\n        var j = A.max()!!\\n        while (i < j) {\\n            var k = (i + j + 1) / 2\\n            var take = A.map{ it.toLong() / k }.sum()\\n            if (T <= take)\\n                i = k\\n            else\\n                j = k - 1\\n        }\\n        return i\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet maximumCandies = (A, T) => {\\n    let i = 0,\\n        j = Math.max(...A);\\n    while (i < j) {\\n        let k = Math.floor((i + j + 1) / 2);\\n        let take = _.sum(A.map(x => Math.floor(x / k)));\\n        if (T <= take)\\n            i = k;\\n        else\\n            j = k - 1;\\n    }\\n    return i;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def maximumCandies(self, A: List[int], T: int) -> int:\\n        i = 0\\n        j = max(A)\\n        while i < j:\\n            k = (i + j + 1) // 2\\n            take = sum(x // k for x in A)\\n            if T <= take:\\n                i = k\\n            else:\\n                j = k - 1\\n        return i\\n```\\n\\n*Rust*\\n```\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn maximum_candies(A: VI, T: i64) -> i32 {\\n        let mut i = 0;\\n        let mut j = *A.iter().max().unwrap();\\n        while i < j {\\n            let k = (i + j + 1) / 2;\\n            let take: i64 = A.iter().map(|x| *x as i64 / k as i64).sum();\\n            if T <= take {\\n                i = k;\\n            } else {\\n                j = k - 1;\\n            }\\n        }\\n        return i;\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using LL = long long;\\n    int maximumCandies(VI& A, LL T) {\\n        LL i = 0,\\n           j = *max_element(A.begin(), A.end());\\n        while (i < j) {\\n            auto k = (i + j + 1LL) / 2;\\n            auto take = accumulate(A.begin(), A.end(), 0LL, [=](auto t, auto x) { return t + x / k; });\\n            if (T <= take)\\n                i = k;\\n            else\\n                j = k - 1;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun maximumCandies(A: IntArray, T: Long): Int {\\n        var i = 0\\n        var j = A.max()!!\\n        while (i < j) {\\n            var k = (i + j + 1) / 2\\n            var take = A.map{ it.toLong() / k }.sum()\\n            if (T <= take)\\n                i = k\\n            else\\n                j = k - 1\\n        }\\n        return i\\n    }\\n}\\n```\n```\\nlet maximumCandies = (A, T) => {\\n    let i = 0,\\n        j = Math.max(...A);\\n    while (i < j) {\\n        let k = Math.floor((i + j + 1) / 2);\\n        let take = _.sum(A.map(x => Math.floor(x / k)));\\n        if (T <= take)\\n            i = k;\\n        else\\n            j = k - 1;\\n    }\\n    return i;\\n};\\n```\n```\\nclass Solution:\\n    def maximumCandies(self, A: List[int], T: int) -> int:\\n        i = 0\\n        j = max(A)\\n        while i < j:\\n            k = (i + j + 1) // 2\\n            take = sum(x // k for x in A)\\n            if T <= take:\\n                i = k\\n            else:\\n                j = k - 1\\n        return i\\n```\n```\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn maximum_candies(A: VI, T: i64) -> i32 {\\n        let mut i = 0;\\n        let mut j = *A.iter().max().unwrap();\\n        while i < j {\\n            let k = (i + j + 1) / 2;\\n            let take: i64 = A.iter().map(|x| *x as i64 / k as i64).sum();\\n            if T <= take {\\n                i = k;\\n            } else {\\n                j = k - 1;\\n            }\\n        }\\n        return i;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using LL = long long;\\n    int maximumCandies(VI& A, LL T) {\\n        LL i = 0,\\n           j = *max_element(A.begin(), A.end());\\n        while (i < j) {\\n            auto k = (i + j + 1LL) / 2;\\n            auto take = accumulate(A.begin(), A.end(), 0LL, [=](auto t, auto x) { return t + x / k; });\\n            if (T <= take)\\n                i = k;\\n            else\\n                j = k - 1;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1917758,
                "title": "binary-search-pattern-problem-nlog-max-candy",
                "content": "1. Its the common pattern for the binary search and in this case we need to find the maximum candies that can be allocated to K students where each of them get equal amount of candies.\\n2. So we can give 0 candies in minimum or we can give max(candies) to the students\\n3. Thus our search space will be 0 to max(candies)\\n4. Apply our binary search concept.\\n5. Find the middle and check if middle amount of candies can be distributed to k students, if yes, we need to find maximum, so we think there is more optimal answer to the right of our search space that will maximize our result, so update low = middle + 1 and store result = middle.\\n6. If we are not able to distribute middle amount of candies to k number of students, then any candies to the right of middle is also of no use, we need to explore the left part and move right = middle - 1;\\n7. Finally return our result.\\n\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        if (candies == null || candies.length == 0) {\\n            return 0;\\n        }\\n        int low = 0;\\n        int high = findMax(candies);\\n        return binarySearch(candies, k, low, high);\\n    }\\n    \\n    public int binarySearch(int [] candies, long k, int low, int high) {\\n        int result = -1;\\n        while (low <= high) {\\n            int middle = low + (high - low) / 2;\\n            if (isPossibleToDivide(candies, middle, k)) {\\n                result = middle;\\n                low = middle + 1;\\n            }\\n            else {\\n                high = middle - 1;\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    public boolean isPossibleToDivide(int [] candies, int inHand, long k) {\\n        if (inHand == 0) {\\n            return true;\\n        }\\n        long total = 0;\\n        for (int num : candies) {\\n            total += (num) / inHand;\\n            if (total >= k) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public int findMax(int [] candies) {\\n        int max = 0;\\n        for (int num : candies) {\\n            if (max < num) {\\n                max = num;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        if (candies == null || candies.length == 0) {\\n            return 0;\\n        }\\n        int low = 0;\\n        int high = findMax(candies);\\n        return binarySearch(candies, k, low, high);\\n    }\\n    \\n    public int binarySearch(int [] candies, long k, int low, int high) {\\n        int result = -1;\\n        while (low <= high) {\\n            int middle = low + (high - low) / 2;\\n            if (isPossibleToDivide(candies, middle, k)) {\\n                result = middle;\\n                low = middle + 1;\\n            }\\n            else {\\n                high = middle - 1;\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    public boolean isPossibleToDivide(int [] candies, int inHand, long k) {\\n        if (inHand == 0) {\\n            return true;\\n        }\\n        long total = 0;\\n        for (int num : candies) {\\n            total += (num) / inHand;\\n            if (total >= k) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public int findMax(int [] candies) {\\n        int max = 0;\\n        for (int num : candies) {\\n            if (max < num) {\\n                max = num;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910615,
                "title": "cpp-easy-solution-binary-search",
                "content": "## **APPROACH**\\n* First check out how many number of maximum candies we can give to children if there were no constraints\\n* That would be dividing the sum in k children.\\n* So now we know our answer for number of candies we can give each child range from 1 to sum/k  and ( 0 in case of not enough candies)\\n* So find r which is sum/k and l which is 1\\n* And do binary search\\n* in this binary search we need to check that for a pile , how many parts we can create of mid number of candies.\\n* Then add all the parts we got of mid size.\\n* and if this number is more than k , it means , we can possibly give even more candies to each child , so decrease the search space and look for more number of candies that whether it could be a possible ans or not. \\n\\n\\n## **CODE**\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    \\n    bool isValid(vector<int>& candies, ll temp,ll k)\\n    {\\n        ll val=0;\\n        for(auto x:candies)\\n        {\\n            val+=(x/temp);\\n        }\\n        \\n        return val>=k;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        // binary search \\n        // find range\\n        \\n        ll sum=0;\\n        for(auto x:candies)\\n        {\\n            sum+=x;\\n        }\\n        \\n        ll l=1,r=sum/k;\\n        \\n        if(r==0)\\n            return 0;\\n        \\n        // now do BS\\n        int ans=0;\\n        while(l<=r)\\n        {\\n            ll mid=l+(r-l)/2;\\n            \\n            bool check=isValid(candies,mid,k);\\n            \\n            if(check)\\n            {\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else\\n            {\\n                r=mid-1;\\n            }\\n                \\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n\\n```\\n\\n### **TIME-COMPLEXITY** :\\nO(nlogm)  where m can be 10^12 in worst case.\\n### **SPACE-COMPLEXITY**:\\nO(1)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    \\n    bool isValid(vector<int>& candies, ll temp,ll k)\\n    {\\n        ll val=0;\\n        for(auto x:candies)\\n        {\\n            val+=(x/temp);\\n        }\\n        \\n        return val>=k;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        // binary search \\n        // find range\\n        \\n        ll sum=0;\\n        for(auto x:candies)\\n        {\\n            sum+=x;\\n        }\\n        \\n        ll l=1,r=sum/k;\\n        \\n        if(r==0)\\n            return 0;\\n        \\n        // now do BS\\n        int ans=0;\\n        while(l<=r)\\n        {\\n            ll mid=l+(r-l)/2;\\n            \\n            bool check=isValid(candies,mid,k);\\n            \\n            if(check)\\n            {\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else\\n            {\\n                r=mid-1;\\n            }\\n                \\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910250,
                "title": "binary-search-c",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    long long calculate(vector<int> & candies, int num){\\n        long long ans = 0;\\n        for(int i=0;i<candies.size();i++){\\n            ans+=candies[i]/num;\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int low = 1;\\n        int ans = 0;\\n        int high = 10000005;\\n        while(low<=high){\\n            int mid = low+(high-low)/2;\\n            long long curr = calculate(candies,mid);\\n            if(curr>=k){\\n                low = mid+1;\\n                ans = mid;\\n            }\\n            else\\n                high = mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long calculate(vector<int> & candies, int num){\\n        long long ans = 0;\\n        for(int i=0;i<candies.size();i++){\\n            ans+=candies[i]/num;\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int low = 1;\\n        int ans = 0;\\n        int high = 10000005;\\n        while(low<=high){\\n            int mid = low+(high-low)/2;\\n            long long curr = calculate(candies,mid);\\n            if(curr>=k){\\n                low = mid+1;\\n                ans = mid;\\n            }\\n            else\\n                high = mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910232,
                "title": "c-solution-binary-search-faster-that-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long right = *max_element(candies.begin(), candies.end());\\n        long long left = 0;\\n        while(right > left){\\n            long long mid = (right + left + 1)/2;\\n            long long sum = 0;\\n            for(int i = 0;i < candies.size(); i++){\\n                sum += candies[i]/mid;\\n            }\\n            if (sum < k){\\n                right = mid - 1;\\n            }else if (sum >= k){\\n                left = mid;\\n            }\\n        }\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long right = *max_element(candies.begin(), candies.end());\\n        long long left = 0;\\n        while(right > left){\\n            long long mid = (right + left + 1)/2;\\n            long long sum = 0;\\n            for(int i = 0;i < candies.size(); i++){\\n                sum += candies[i]/mid;\\n            }\\n            if (sum < k){\\n                right = mid - 1;\\n            }else if (sum >= k){\\n                left = mid;\\n            }\\n        }\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909852,
                "title": "java-o-nlogn-solution",
                "content": "\\n\\n        \\n        long sum=0;\\n        for(int i:candies)\\n            sum+=i;\\n        long low=0,high=sum;\\n        long ans=0;\\n        while(low<=high)\\n        {\\n            long mid=low+(high-low)/2;\\n            if(mid==0)\\n            {\\n                low=mid+1;\\n                continue;\\n            }\\n            long tmp=0;\\n            for(int i=0;i<candies.length;i++)\\n            {\\n                tmp+=candies[i]/mid;\\n            }\\n            if(tmp>=k)\\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else\\n                high=mid-1;\\n        }\\n        return (int)ans;\\n    \\n\\t",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "\\n\\n        \\n        long sum=0;\\n        for(int i:candies)\\n            sum+=i;\\n        long low=0,high=sum;\\n        long ans=0;\\n        while(low<=high)\\n        {\\n            long mid=low+(high-low)/2;\\n            if(mid==0)\\n            {\\n                low=mid+1;\\n                continue;\\n            }\\n            long tmp=0;\\n            for(int i=0;i<candies.length;i++)\\n            {\\n                tmp+=candies[i]/mid;\\n            }\\n            if(tmp>=k)\\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else\\n                high=mid-1;\\n        }\\n        return (int)ans;\\n    \\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1909799,
                "title": "left-right-1-2-vs-left-right-2",
                "content": "This post mainly focus on `(left+right+1)/2` and `(left+right)/2`.\\n\\n`mid = (left + right) / 2` to find *first* element valid\\n`mid = (left + right + 1) / 2` to find *last* element valid\\n\\nE.g. `[0, 1, 1, 1, 1]`\\n`mid = (left + right) / 2` would give index 1\\n`mid = (left + right + 1) / 2` would give index 5\\n\\nFor `mid = (left + right + 1) / 2`:\\n1. if `sum == k`, since we are going to find the last valid one, then move `left` till the very left: `left = mid`;\\n2. when go out of while loop, it\\'s getting to the first element NOT valid, so `right` need to decrement by one: `right = mid - 1`. So it would be:\\n\\n```\\nif (sum >= k) left = mid\\nelse right = mid -1\\n```\\nIf one wonders it\\'s `sum >= k` or `sum > k`, just take a moment think about if you want to first or last same element\\n\\nUsually we write `mid = (left + right) / 2` in\\n```\\nif (num[mid] < target) left = mid + 1\\nelse right = mid\\n```\\n\\nBtw, if using a helper `sum` function, be sure to return a `long` type not `int` otherwise you will hit error\\n\\nOriginal answer:\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        // binary search\\n        int left = 0, right = 10000000;\\n        \\n        while (left < right) {\\n            int mid = (left + right + 1) / 2;\\n\\n            // equal: go to the rightmost of these same numbers\\n            if (sum(candies, mid) >= k) \\n                left = mid;\\n            else \\n                right = mid - 1;\\n        }\\n        \\n        return left;\\n    }\\n    \\n    private long sum(int[] candies, int mid) {\\n        long count = 0;\\n        for (int c : candies) {\\n            count += c / mid;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nif (sum >= k) left = mid\\nelse right = mid -1\\n```\n```\\nif (num[mid] < target) left = mid + 1\\nelse right = mid\\n```\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        // binary search\\n        int left = 0, right = 10000000;\\n        \\n        while (left < right) {\\n            int mid = (left + right + 1) / 2;\\n\\n            // equal: go to the rightmost of these same numbers\\n            if (sum(candies, mid) >= k) \\n                left = mid;\\n            else \\n                right = mid - 1;\\n        }\\n        \\n        return left;\\n    }\\n    \\n    private long sum(int[] candies, int mid) {\\n        long count = 0;\\n        for (int c : candies) {\\n            count += c / mid;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909786,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Time Complexity : O(N * log(max. element in array))***\\n* ***Space Complexity : O(1)***\\n\\n```\\n    bool is_possible(vector<int>& candies, int mid, long long k)\\n    {\\n        long long count = 0;\\n        \\n        for(int i = 0; i < candies.size(); i++)\\n        {\\n            count += candies[i] / mid;\\n        }\\n        \\n        if(count >= k)\\n            return true;\\n        \\n        return false;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        int n = candies.size();\\n        \\n        int low = 1;\\n        \\n        int high = *max_element(candies.begin(), candies.end());\\n        \\n        int ans = 0;\\n        \\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            \\n            if(is_possible(candies, mid, k))\\n            {\\n                ans = mid;\\n                \\n                low = mid + 1;\\n            }\\n            else\\n            {\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\n    bool is_possible(vector<int>& candies, int mid, long long k)\\n    {\\n        long long count = 0;\\n        \\n        for(int i = 0; i < candies.size(); i++)\\n        {\\n            count += candies[i] / mid;\\n        }\\n        \\n        if(count >= k)\\n            return true;\\n        \\n        return false;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        int n = candies.size();\\n        \\n        int low = 1;\\n        \\n        int high = *max_element(candies.begin(), candies.end());\\n        \\n        int ans = 0;\\n        \\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            \\n            if(is_possible(candies, mid, k))\\n            {\\n                ans = mid;\\n                \\n                low = mid + 1;\\n            }\\n            else\\n            {\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1909572,
                "title": "python3-binary-search",
                "content": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        if sum(candies) < k:\\n            return 0\\n        \\n        low,high = 0,sum(candies)\\n        while low < high:\\n            mid = low + (high - low)//2 + 1\\n            if sum(i//mid for i in candies) >= k:\\n                low = mid\\n            else:\\n                high = mid-1\\n                \\n        return low\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        if sum(candies) < k:\\n            return 0\\n        \\n        low,high = 0,sum(candies)\\n        while low < high:\\n            mid = low + (high - low)//2 + 1\\n            if sum(i//mid for i in candies) >= k:\\n                low = mid\\n            else:\\n                high = mid-1\\n                \\n        return low\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909404,
                "title": "c-binary-search-easy-to-understand",
                "content": "```\\nint maximumCandies(vector<int>& c, long long k) \\n    {\\n        // I got the intuition because it was following the pattern of breaking down the question into two parts, I had to check if a number was feasible to keep and also no way of obviously finding it anyway else. Check Koko Eating bananas and similar pattern questions\\n        \\n        int left = 1 ;\\n        int right = 1e9;\\n        int res = INT_MIN;\\n        \\n        int n = c.size();\\n        long long sum = 0;\\n        \\n        \\n        while(left <= right)\\n        {\\n            int mid = left + (right-left)/2;\\n            \\n            if(isfeasible(c,k,mid))\\n            {\\n                res = max(res,mid);\\n                left = mid+1;\\n            }\\n            \\n            else\\n            {\\n                right = mid - 1;\\n            }\\n        }\\n        \\n        return res == INT_MIN? 0 : res; // if we didn\\'t find any feasible value and the result is the initial one we had\\n    }\\n    \\n    bool isfeasible(vector<int> &c, long long k, int candy)\\n    {\\n        // checking feasibility\\n        long long count = 0;\\n        for(int i=0;i<c.size();i++)\\n        {\\n            count+= c[i]/candy; // counting number of children that can have piles with \\'candy\\' number of candies\\n        }\\n        \\n        if(count>=k)\\n            return true;\\n        else\\n            return false;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nint maximumCandies(vector<int>& c, long long k) \\n    {\\n        // I got the intuition because it was following the pattern of breaking down the question into two parts, I had to check if a number was feasible to keep and also no way of obviously finding it anyway else. Check Koko Eating bananas and similar pattern questions\\n        \\n        int left = 1 ;\\n        int right = 1e9;\\n        int res = INT_MIN;\\n        \\n        int n = c.size();\\n        long long sum = 0;\\n        \\n        \\n        while(left <= right)\\n        {\\n            int mid = left + (right-left)/2;\\n            \\n            if(isfeasible(c,k,mid))\\n            {\\n                res = max(res,mid);\\n                left = mid+1;\\n            }\\n            \\n            else\\n            {\\n                right = mid - 1;\\n            }\\n        }\\n        \\n        return res == INT_MIN? 0 : res; // if we didn\\'t find any feasible value and the result is the initial one we had\\n    }\\n    \\n    bool isfeasible(vector<int> &c, long long k, int candy)\\n    {\\n        // checking feasibility\\n        long long count = 0;\\n        for(int i=0;i<c.size();i++)\\n        {\\n            count+= c[i]/candy; // counting number of children that can have piles with \\'candy\\' number of candies\\n        }\\n        \\n        if(count>=k)\\n            return true;\\n        else\\n            return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1909394,
                "title": "java-c-greedy-binary-search-explained-easy-to-understand",
                "content": "Idea: .Minimun and maximum candies that can be given to a child form a monotonically increasing function.\\n    .Thus to find the maximum candies to a single child, binary search can be applied in the above mentioned search space\\n\\t\\nC++\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& cd, long long k) {\\n        long long l = 0, r = 1E7;\\n        long long ans = 0;\\n        while (l <= r) {\\n            //each child getting m candies\\n            auto m = l + (r-l) / 2;\\n            //number of children Getting Candies\\n            auto cgc = 0LL;\\n            if(m != 0l)\\n            {\\n                for (auto x : cd) {\\n                    cgc += x / m;\\n                }\\n            }\\n            if (cgc >= k) {\\n                ans = m;\\n                l = m+1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nJava\\n```\\nclass Solution {\\n    public int maximumCandies(int[] cd, long k) {\\n        long l = 0, r = 10000000;\\n        long ans = 0;\\n        while (l <= r) {\\n            //each child getting m candies\\n            var m = l + (r-l) / 2;\\n            //number of children Getting Candies\\n            var cgc = 0l;\\n            if(m != 0l)\\n            {\\n                for (var x : cd) {\\n                    cgc += x / m;\\n                }\\n            }\\n            if (cgc >= k) {\\n                ans = m;\\n                l = m+1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n}\\n```\\nAny corrections, suggestions or optimizations to code are welcomed. :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& cd, long long k) {\\n        long long l = 0, r = 1E7;\\n        long long ans = 0;\\n        while (l <= r) {\\n            //each child getting m candies\\n            auto m = l + (r-l) / 2;\\n            //number of children Getting Candies\\n            auto cgc = 0LL;\\n            if(m != 0l)\\n            {\\n                for (auto x : cd) {\\n                    cgc += x / m;\\n                }\\n            }\\n            if (cgc >= k) {\\n                ans = m;\\n                l = m+1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int maximumCandies(int[] cd, long k) {\\n        long l = 0, r = 10000000;\\n        long ans = 0;\\n        while (l <= r) {\\n            //each child getting m candies\\n            var m = l + (r-l) / 2;\\n            //number of children Getting Candies\\n            var cgc = 0l;\\n            if(m != 0l)\\n            {\\n                for (var x : cd) {\\n                    cgc += x / m;\\n                }\\n            }\\n            if (cgc >= k) {\\n                ans = m;\\n                l = m+1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909330,
                "title": "c-binary-search-on-asnwer",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long \\n    \\n    bool isPossible(vector<int>& candies, ll k , ll mid ){\\n        ll children = 0 ;\\n        for(auto &x : candies) children += x / mid ;\\n        return children >= k ;\\n        \\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        ll totalCandies = accumulate(begin(candies),end(candies),0LL) ;\\n        ll lo = 1 , hi = totalCandies/k ;\\n        \\n        int ans = -1 ;\\n        while(lo <= hi){\\n            ll mid = lo + (hi-lo)/2LL ;\\n            if(isPossible(candies,k,mid)){\\n               ans = mid ;\\n               lo = mid + 1 ;\\n            }\\n            else hi = mid - 1 ;\\n        }\\n        return ans==-1 ? 0 : ans  ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long \\n    \\n    bool isPossible(vector<int>& candies, ll k , ll mid ){\\n        ll children = 0 ;\\n        for(auto &x : candies) children += x / mid ;\\n        return children >= k ;\\n        \\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        ll totalCandies = accumulate(begin(candies),end(candies),0LL) ;\\n        ll lo = 1 , hi = totalCandies/k ;\\n        \\n        int ans = -1 ;\\n        while(lo <= hi){\\n            ll mid = lo + (hi-lo)/2LL ;\\n            if(isPossible(candies,k,mid)){\\n               ans = mid ;\\n               lo = mid + 1 ;\\n            }\\n            else hi = mid - 1 ;\\n        }\\n        return ans==-1 ? 0 : ans  ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909268,
                "title": "binary-search-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int ans = 0;\\n        int l = 0,h = INT_MAX,m;\\n        while(l <= h) {\\n            m = l + (h -l )/2;\\n            if(isPossible(candies, m, k)) {\\n                ans = max(ans, m);\\n                l = m + 1;\\n            } else {\\n                h = m - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    bool isPossible(vector<int>& candies, int amount, long long k) {\\n        long long sum = 0;\\n        long long int cnt = 0;\\n        for(int candie : candies) {\\n            if(candie >= amount && amount != 0) cnt += candie/amount;\\n        }\\n        return cnt >= k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int ans = 0;\\n        int l = 0,h = INT_MAX,m;\\n        while(l <= h) {\\n            m = l + (h -l )/2;\\n            if(isPossible(candies, m, k)) {\\n                ans = max(ans, m);\\n                l = m + 1;\\n            } else {\\n                h = m - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    bool isPossible(vector<int>& candies, int amount, long long k) {\\n        long long sum = 0;\\n        long long int cnt = 0;\\n        for(int candie : candies) {\\n            if(candie >= amount && amount != 0) cnt += candie/amount;\\n        }\\n        return cnt >= k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909224,
                "title": "c-binary-search",
                "content": "\\ttypedef long long ll;\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint help(ll mid,vector<int>&nums,ll k){\\n\\t\\t\\tll res = 0;\\n\\t\\t\\tfor(int i=0;i<nums.size();i++) res+=(nums[i]/mid);\\n\\t\\t\\treturn res>=k;\\n\\t\\t}\\n\\n\\t\\tint maximumCandies(vector<int>& candies, long long k) {\\n\\t\\t\\tll i = 1, j = 1e9;\\n\\t\\t\\twhile(i<=j){\\n\\t\\t\\t\\tll mid = (i+j)/2;\\n\\t\\t\\t\\tif(help(mid,candies,k)) i = mid+1;\\n\\t\\t\\t\\telse j = mid-1;\\n\\t\\t\\t}\\n\\t\\t\\treturn i-1;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint help(ll mid,vector<int>&nums,ll k){\\n\\t\\t\\tll res = 0;\\n\\t\\t\\tfor(int i=0;i<nums.size();i++) res+=(nums[i]/mid);\\n\\t\\t\\treturn res>=k;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1909207,
                "title": "java-efficient-binary-search-approach-explained",
                "content": "**Find total candies**\\n\\tif `total < k,` then we cannot give candy to all child, so `return 0`.\\n\\tif `total == k`, then each child can get only `1 candy`.\\n\\nOtherwise,\\n\\tUse binary search to find possible candies.\\n\\tHere, `high = total / k` as this is maximum we can assign to each child.\\n\\tFor each mid, find **how many piles can be created** `(candy / mid)`. If numbers of piles i.e. `sum >= k` then we can assign atleast `mid` candies.\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        long total = 0;\\n        for (int candy : candies) {\\n            total += candy;\\n        }\\n        if (total < k) {\\n            return 0;\\n        }\\n        if (total == k) {\\n            return 1;\\n        }\\n        long low = 1;\\n        long high = total / k;\\n        int ans = 0;\\n        while (low <= high) {\\n            long mid = (low + high) / 2;\\n            long sum = 0;\\n            for (int candy: candies) {\\n                sum += (candy / mid);\\n            }\\n            if (sum >= k) {\\n                ans = (int) mid;\\n                low = mid + 1;\\n            } else {\\n                high = mid -1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        long total = 0;\\n        for (int candy : candies) {\\n            total += candy;\\n        }\\n        if (total < k) {\\n            return 0;\\n        }\\n        if (total == k) {\\n            return 1;\\n        }\\n        long low = 1;\\n        long high = total / k;\\n        int ans = 0;\\n        while (low <= high) {\\n            long mid = (low + high) / 2;\\n            long sum = 0;\\n            for (int candy: candies) {\\n                sum += (candy / mid);\\n            }\\n            if (sum >= k) {\\n                ans = (int) mid;\\n                low = mid + 1;\\n            } else {\\n                high = mid -1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909168,
                "title": "binary-search-similar-approach-as-book-allocation-problem-in-cpp",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& can, long long k) {\\n        int l=1,h=*max_element(can.begin(),can.end());  //here l initialised by 1 for the case when h=1\\n        int ans=0;\\n        while(l<=h)\\n        {\\n            int mid=l+(h-l)/2;\\n            long long cnt=0;\\n            if(mid==0)\\n                break;\\n            for(int i=0;i<can.size();i++)\\n            {\\n                cnt+=1ll*can[i]/mid;\\n            }\\n            if(cnt>=k)\\n            {\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else\\n                h=mid-1;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    int maximumCandies(vector<int>& can, long long k) {\\n        int l=1,h=*max_element(can.begin(),can.end());  //here l initialised by 1 for the case when h=1\\n        int ans=0;\\n        while(l<=h)\\n        {\\n            int mid=l+(h-l)/2;\\n            long long cnt=0;\\n            if(mid==0)\\n                break;\\n            for(int i=0;i<can.size();i++)\\n            {\\n                cnt+=1ll*can[i]/mid;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1909006,
                "title": "c-binary-search-faster-than-100",
                "content": "~~~\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& nums, long long k) {\\n        int n=nums.size();\\n        int mx=0;\\n        for(int i=0;i<nums.size();i++){\\n            mx=max(mx,nums[i]);\\n        }\\n        if(k==1)return mx;\\n        long long l=0,h=mx;\\n        long long ans=0;\\n        while(l<=h){\\n            long long mid=l+(h-l)/2;\\n            if(solve(nums,mid,k)){\\n                ans=mid;\\n                l=mid+1;\\n            }else{\\n                h=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int solve(vector<int> nums,long long val,long long k){\\n        if(val==0)return true;\\n        long long c=0;\\n        for(int i=0;i<nums.size();i++){\\n            c+=nums[i]/val;\\n        }\\n        if(c>=k)return true;\\n        return false;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maximumCandies(vector<int>& nums, long long k) {\\n        int n=nums.size();\\n        int mx=0;\\n        for(int i=0;i<nums.size();i++){\\n            mx=max(mx,nums[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1908944,
                "title": "binary-search-time-o-nlogn-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(long long mid,long long k, vector<int>&candies)\\n    {\\n        long long temp=0;\\n        for(int i=0;i<candies.size();i++)\\n        {\\n            temp+=candies[i]/mid;\\n            if(temp>=k)\\n                return true;\\n        }\\n        return false;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long sum=0;\\n        int ans=0;\\n        for(int i=0;i<candies.size();i++)\\n        {\\n            sum+=candies[i];\\n        }\\n        long long l=1,h=sum;\\n        while(l<=h)\\n        {\\n            long long mid=l+(h-l)/2;\\n            \\n            if(check(mid,k,candies))\\n            {\\n                ans=(int)mid;\\n                l=mid+1;\\n            }\\n            else\\n            {\\n                h=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Like it? Please Upvote ;-)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(long long mid,long long k, vector<int>&candies)\\n    {\\n        long long temp=0;\\n        for(int i=0;i<candies.size();i++)\\n        {\\n            temp+=candies[i]/mid;\\n            if(temp>=k)\\n                return true;\\n        }\\n        return false;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long sum=0;\\n        int ans=0;\\n        for(int i=0;i<candies.size();i++)\\n        {\\n            sum+=candies[i];\\n        }\\n        long long l=1,h=sum;\\n        while(l<=h)\\n        {\\n            long long mid=l+(h-l)/2;\\n            \\n            if(check(mid,k,candies))\\n            {\\n                ans=(int)mid;\\n                l=mid+1;\\n            }\\n            else\\n            {\\n                h=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908896,
                "title": "c-binary-search-clean-and-concise",
                "content": "```\\n#define ll long long \\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        \\n        ll sum=0;\\n        for(auto i:candies)\\n            sum+=i;\\n        if(sum<k)\\n            return 0;\\n        ll low=1;\\n        ll high=1e15;\\n        ll ans=0;\\n        while(low<=high)\\n        {\\n            ll mid=(low+high)/2;\\n           ll st=0;\\n            for(auto i:candies)\\n            {\\n                if(mid!=0)\\n                st+=(i/mid);\\n            }\\n            if(st>=k)\\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else\\n            {\\n                high=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Pls upvote the solution if you found helpful, it means a lot.\\nAlso comment down your doubts.\\nHappy Coding : )**\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n#define ll long long \\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        \\n        ll sum=0;\\n        for(auto i:candies)\\n            sum+=i;\\n        if(sum<k)\\n            return 0;\\n        ll low=1;\\n        ll high=1e15;\\n        ll ans=0;\\n        while(low<=high)\\n        {\\n            ll mid=(low+high)/2;\\n           ll st=0;\\n            for(auto i:candies)\\n            {\\n                if(mid!=0)\\n                st+=(i/mid);\\n            }\\n            if(st>=k)\\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else\\n            {\\n                high=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908845,
                "title": "easy-python-binary-search",
                "content": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        l, r = 1, max(candies)\\n        while l <= r:\\n            m = (l + r)//2\\n            if self.countPile(candies, m) >= k:\\n                if self.countPile(candies, m + 1) < k: return m\\n                l = m + 1\\n            else:\\n                r = m - 1\\n        return 0\\n                \\n    def countPile(self, candies, pileSize):\\n        return sum(candy//pileSize for candy in candies)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        l, r = 1, max(candies)\\n        while l <= r:\\n            m = (l + r)//2\\n            if self.countPile(candies, m) >= k:\\n                if self.countPile(candies, m + 1) < k: return m\\n                l = m + 1\\n            else:\\n                r = m - 1\\n        return 0\\n                \\n    def countPile(self, candies, pileSize):\\n        return sum(candy//pileSize for candy in candies)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908844,
                "title": "java-simple-binarysearch-tc-o-n-log-max",
                "content": "Solution:\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int max = Integer.MIN_VALUE;\\n        long sum = 0;\\n        \\n        for (int num: candies) {\\n            max = Math.max(max, num);\\n            sum += num;\\n        }\\n        \\n        if (sum < k) {\\n            return 0;\\n        }\\n        \\n        int left = 1, right = max;\\n        \\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            if (canBeDistributed(mid, candies, k)) {\\n                if (!canBeDistributed(mid + 1, candies, k)) {\\n                    return mid;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\n    public boolean canBeDistributed(int num, int[] candies, long k) {\\n        for (int i = 0; i < candies.length && k > 0; ++ i) {\\n            k -= candies[i] / num;\\n        }\\n        \\n        return k <= 0;\\n    }\\n}\\n```\\n\\n**TimeComplexity:** O(N * log(Max)) where N is the number of candies.",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int max = Integer.MIN_VALUE;\\n        long sum = 0;\\n        \\n        for (int num: candies) {\\n            max = Math.max(max, num);\\n            sum += num;\\n        }\\n        \\n        if (sum < k) {\\n            return 0;\\n        }\\n        \\n        int left = 1, right = max;\\n        \\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            if (canBeDistributed(mid, candies, k)) {\\n                if (!canBeDistributed(mid + 1, candies, k)) {\\n                    return mid;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\n    public boolean canBeDistributed(int num, int[] candies, long k) {\\n        for (int i = 0; i < candies.length && k > 0; ++ i) {\\n            k -= candies[i] / num;\\n        }\\n        \\n        return k <= 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908830,
                "title": "c-easy-binary-search",
                "content": "Approach:\\n* Firstly we will take given range and apply binary search.\\n* low will be 1 as min 1 candy shoud be given and high is upper limit of candy group in given constraint i.e 10^7.\\n* Firstly we will calculate mid and check if candy pile of k forms k groups or not if it is forming more than or equal to k groups then  we can take it as a possible answer and take low=mid+1 because we have to find max answer and there might exist any number more than mid that may satisfy given condition. if groups of mid are less than k then we have to search in left part fo high=mid-1.\\n    \\nComplexity:\\n* \\tTime: O(n log (10^7)) we are using binary search from 1 to 10^7 so log (10^7) and at each step we have to traverse array so it is multiplied by n.\\n* \\tSpace: O(1)\\n```\\t\\nclass Solution {\\npublic:\\n    using ll=long long;\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        ll low=1,high=10000001;\\n        int answer=0;\\n        while(low<=high){\\n            ll mid=(low+high)/2;\\n            ll groups=getGroups(candies,mid);\\n            if(groups>=k){\\n\\t\\t\\t\\t//probable any might be mid.\\n                answer=mid;\\n                low=mid+1;\\n            }else{\\n                high=mid-1;\\n            }\\n        }\\n        return answer;\\n    }\\n    ll getGroups(vector<int> &candies,ll mid){\\n        ll groups=0;\\n        for(auto can:candies){\\n            groups+=(can/mid);\\n        }\\n        return groups;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\t\\nclass Solution {\\npublic:\\n    using ll=long long;\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        ll low=1,high=10000001;\\n        int answer=0;\\n        while(low<=high){\\n            ll mid=(low+high)/2;\\n            ll groups=getGroups(candies,mid);\\n            if(groups>=k){\\n\\t\\t\\t\\t//probable any might be mid.\\n                answer=mid;\\n                low=mid+1;\\n            }else{\\n                high=mid-1;\\n            }\\n        }\\n        return answer;\\n    }\\n    ll getGroups(vector<int> &candies,ll mid){\\n        ll groups=0;\\n        for(auto can:candies){\\n            groups+=(can/mid);\\n        }\\n        return groups;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908821,
                "title": "c-binary-search-concise",
                "content": "```\\nclass Solution{\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long sum = 0, n = candies.size();\\n        for(int i =0;i<n;i++){\\n            sum+= candies[i];\\n        }\\n        if(k>sum) return 0;\\n        long long lower = 1;\\n        long long upper = sum/k;\\n        \\n        long long ans = 0;\\n        \\n        while(lower<=upper){ \\n             long long mid = lower + (upper-lower)/2;\\n             long long count = 0;\\n             for(int i =0;i<n;i++){\\n                count+= candies[i]/mid;\\n             }\\n             if(count>=k){\\n                ans = max(ans,mid);\\n                lower = mid+1;\\n             }\\n             else{\\n                upper = mid-1;\\n             }\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution{\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long sum = 0, n = candies.size();\\n        for(int i =0;i<n;i++){\\n            sum+= candies[i];\\n        }\\n        if(k>sum) return 0;\\n        long long lower = 1;\\n        long long upper = sum/k;\\n        \\n        long long ans = 0;\\n        \\n        while(lower<=upper){ \\n             long long mid = lower + (upper-lower)/2;\\n             long long count = 0;\\n             for(int i =0;i<n;i++){\\n                count+= candies[i]/mid;\\n             }\\n             if(count>=k){\\n                ans = max(ans,mid);\\n                lower = mid+1;\\n             }\\n             else{\\n                upper = mid-1;\\n             }\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908813,
                "title": "binary-search-same-as-koko-eating-bananas-python3",
                "content": "This problem is the very similar to the [Koko Eating bananas](https://leetcode.com/problems/koko-eating-bananas/). In fact, the only thing that changes in the condition and boundaries.\\n\\n\\n```\\ndef maximumCandies(self, candies: List[int], k: int) -> int:\\n        \\n        def can_take(target):\\n            count = 0\\n            for candy in candies:\\n                if candy >= target:\\n                    count += (candy // target) # Find out how many children this pile can feed :) \\n            return count >= k   # Make sure that we have enough to feed all the children\\n        \\n        l, r = 1, max(candies)\\n        res = 0\\n        while l <= r:\\n            m = (l + r) // 2\\n            if can_take(m):\\n                res = m\\n                l = m + 1\\n            else:\\n                r = m - 1\\n        return res\\n  ```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\ndef maximumCandies(self, candies: List[int], k: int) -> int:\\n        \\n        def can_take(target):\\n            count = 0\\n            for candy in candies:\\n                if candy >= target:\\n                    count += (candy // target) # Find out how many children this pile can feed :) \\n            return count >= k   # Make sure that we have enough to feed all the children\\n        \\n        l, r = 1, max(candies)\\n        res = 0\\n        while l <= r:\\n            m = (l + r) // 2\\n            if can_take(m):\\n                res = m\\n                l = m + 1\\n            else:\\n                r = m - 1\\n        return res\\n  ```",
                "codeTag": "Python3"
            },
            {
                "id": 1908805,
                "title": "python-java-binary-search",
                "content": "\\tclass Solution:\\n\\t\\tdef maximumCandies(self, candies: List[int], k: int) -> int:\\n\\t\\t\\tl = 1\\n\\t\\t\\tr = sum(candies)\\n\\t\\t\\tif r < k:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\tdef allocate(m):\\n\\t\\t\\t\\tcnt = 0\\n\\t\\t\\t\\tfor candy in candies:\\n\\t\\t\\t\\t\\tcnt += candy // m\\n\\t\\t\\t\\treturn cnt\\n\\t\\t\\twhile l + 1 < r:\\n\\t\\t\\t\\tm = (l + r) // 2\\n\\t\\t\\t\\tif allocate(m) < k:\\n\\t\\t\\t\\t\\tr = m - 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tl = m\\n\\t\\t\\tif allocate(r) >= k:\\n\\t\\t\\t\\treturn r\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn l\\n\\n\\n\\tclass Solution {\\n\\t\\tpublic int maximumCandies(int[] candies, long k) {\\n\\t\\t\\tlong l = 1;\\n\\t\\t\\tlong r = 0;\\n\\t\\t\\tfor (int candy: candies) {\\n\\t\\t\\t\\tr += candy;\\n\\t\\t\\t}\\n\\t\\t\\tif (r < k) {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\twhile (l + 1 < r) {\\n\\t\\t\\t\\tlong m = (r - l) / 2 + l;\\n\\t\\t\\t\\tif (allocate(candies, m) < k) {\\n\\t\\t\\t\\t\\tr = m - 1;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tl = m;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (allocate(candies, r) >= k) {\\n\\t\\t\\t\\treturn (int)r;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn (int)l;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tprivate long allocate(int[] candies, long m) {\\n\\t\\t\\tlong cnt = 0;\\n\\t\\t\\tfor (int candy: candies) {\\n\\t\\t\\t\\tcnt += candy / m;\\n\\t\\t\\t}\\n\\t\\t\\treturn cnt;\\n\\t\\t} \\n\\t}",
                "solutionTags": [],
                "code": "class Solution:\\n\\t\\tdef maximumCandies(self, candies: List[int], k: int) -> int:\\n\\t\\t\\tl = 1\\n\\t\\t\\tr = sum(candies)\\n\\t\\t\\tif r < k:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\tdef allocate(m):\\n\\t\\t\\t\\tcnt = 0\\n\\t\\t\\t\\tfor candy in candies:\\n\\t\\t\\t\\t\\tcnt += candy // m\\n\\t\\t\\t\\treturn cnt\\n\\t\\t\\twhile l + 1 < r:\\n\\t\\t\\t\\tm = (l + r) // 2\\n\\t\\t\\t\\tif allocate(m) < k:\\n\\t\\t\\t\\t\\tr = m - 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tl = m\\n\\t\\t\\tif allocate(r) >= k:\\n\\t\\t\\t\\treturn r\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn l\\n\\n\\n\\tclass Solution {\\n\\t\\tpublic int maximumCandies(int[] candies, long k) {\\n\\t\\t\\tlong l = 1;\\n\\t\\t\\tlong r = 0;\\n\\t\\t\\tfor (int candy: candies) {\\n\\t\\t\\t\\tr += candy;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1908799,
                "title": "python-binary-search-solution-and-explanation",
                "content": "**\\uD83D\\uDC46Please UPVOTE it if you find my soulutions are useful \\uD83D\\uDC46 Feel free to ask any question**\\n# [Python] \\uD83C\\uDF1F Binary Search Solution and Explanation \\uD83D\\uDC95\\n## 1\\uFE0F\\u20E3 Main Idea:\\nWe can greedy test every potential target from 1~ total//k.\\nSo we use binary Search to find our maximum target.\\n* canDivide: Simply use res += candy // target. To check whether a candy pile could split into how many piles to fit the target.\\n\\n## Complexity Analysis\\n* Time: O(NlogN)\\n* Space: O(1)\\n\\n## Code\\n\\n**Python**\\n```python\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        total = sum(candies)\\n        if total < k:\\n            return 0\\n        \\n        # We can test our current target is valid\\n        def canDivide(target):\\n            res = 0\\n            for candy in candies:\\n                res += candy // target\\n            return res >= k\\n        \\n        # Greedy high would be total // k\\n        low, high = 1, total // k\\n        res = 0\\n        # Binary Search\\n        while low <= high:\\n            target = low + (high - low) // 2\\n            if canDivide(target):\\n                res = target\\n                low = target + 1\\n            else:\\n                high = target - 1\\n        return res\\n```\\n* See more 2022 Daily Challenge Solution : [GitHub](https://github.com/gcobs0834/2022-Daily-LeetCoding-Challenge-python3-)",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        total = sum(candies)\\n        if total < k:\\n            return 0\\n        \\n        # We can test our current target is valid\\n        def canDivide(target):\\n            res = 0\\n            for candy in candies:\\n                res += candy // target\\n            return res >= k\\n        \\n        # Greedy high would be total // k\\n        low, high = 1, total // k\\n        res = 0\\n        # Binary Search\\n        while low <= high:\\n            target = low + (high - low) // 2\\n            if canDivide(target):\\n                res = target\\n                low = target + 1\\n            else:\\n                high = target - 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908787,
                "title": "c-binary-search-o-nlogn-intiution-comments",
                "content": "intiution : our search space(no of candies we can allocate) will be 1  to max number in array . if we can allocate a particular number of candy then search for next higher number else search number lower than that particular number.\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int maxCand = INT_MIN;\\n        long long s = 0;\\n        for(int i = 0;i < candies.size();i++){\\n            if(candies[i] > maxCand)\\n                maxCand = candies[i];\\n            s += candies[i];\\n        }\\n\\t\\t// if total number of candies are less than the no of children then we can never allocate same number of candies to children hence return 0\\n        if(k > s)\\n            return 0;\\n        int l = 1;\\n        int h = maxCand;\\n        while(l <= h){\\n            int mid = l + (h - l) / 2;\\n            long long sum = 0;\\n            for(int i =a 0;i < candies.size();i++){\\n\\t\\t\\t// mid means the number that we check if we can allocate that number of candy to children.\\n\\t\\t\\t// [ 5 8 6] and if mid = 2 then we can get 2 piles of 2 candies from 5 and 2 piles from 8 and 3 piles from 6.\\n                sum += candies[i] / mid;\\n            }\\n\\t\\t\\t// if total no of piles of mid number candy is >= k then we can allocate mid number candy to children hence check for next higher possible number.\\n            if(sum >= k)\\n                l = mid + 1;\\n\\t\\t\\t\\t// else check for lower number than mid.\\n            else\\n                h = mid - 1;\\n        }\\n\\t\\t// at end h points to a maximum number that we can allocate to children.\\n        return h;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int maxCand = INT_MIN;\\n        long long s = 0;\\n        for(int i = 0;i < candies.size();i++){\\n            if(candies[i] > maxCand)\\n                maxCand = candies[i];\\n            s += candies[i];\\n        }\\n\\t\\t// if total number of candies are less than the no of children then we can never allocate same number of candies to children hence return 0\\n        if(k > s)\\n            return 0;\\n        int l = 1;\\n        int h = maxCand;\\n        while(l <= h){\\n            int mid = l + (h - l) / 2;\\n            long long sum = 0;\\n            for(int i =a 0;i < candies.size();i++){\\n\\t\\t\\t// mid means the number that we check if we can allocate that number of candy to children.\\n\\t\\t\\t// [ 5 8 6] and if mid = 2 then we can get 2 piles of 2 candies from 5 and 2 piles from 8 and 3 piles from 6.\\n                sum += candies[i] / mid;\\n            }\\n\\t\\t\\t// if total no of piles of mid number candy is >= k then we can allocate mid number candy to children hence check for next higher possible number.\\n            if(sum >= k)\\n                l = mid + 1;\\n\\t\\t\\t\\t// else check for lower number than mid.\\n            else\\n                h = mid - 1;\\n        }\\n\\t\\t// at end h points to a maximum number that we can allocate to children.\\n        return h;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908745,
                "title": "binary-search-clean-java-solution",
                "content": "```\\nclass Solution {\\n    \\n    public boolean valid(int mid, int candies[], long k){\\n      \\n        long c=0;\\n        \\n        for(int i=0;i<candies.length;i++){\\n            int val=candies[i];\\n            c+=val/mid;\\n            if(c>=k){\\n                \\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n        \\n    }\\n    \\n    public int maximumCandies(int[] candies, long k) {\\n        int max=Integer.MIN_VALUE;\\n        \\n        for(int i=0;i<candies.length;i++){\\n            max=Math.max(candies[i],max);\\n        }\\n        \\n        int low=1;\\n        int high=max;\\n        \\n        int ans=0;\\n        \\n        while(low<=high){\\n            int mid= low +(high-low) / 2;\\n            \\n            if(valid(mid,candies,k)){\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            \\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public boolean valid(int mid, int candies[], long k){\\n      \\n        long c=0;\\n        \\n        for(int i=0;i<candies.length;i++){\\n            int val=candies[i];\\n            c+=val/mid;\\n            if(c>=k){\\n                \\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n        \\n    }\\n    \\n    public int maximumCandies(int[] candies, long k) {\\n        int max=Integer.MIN_VALUE;\\n        \\n        for(int i=0;i<candies.length;i++){\\n            max=Math.max(candies[i],max);\\n        }\\n        \\n        int low=1;\\n        int high=max;\\n        \\n        int ans=0;\\n        \\n        while(low<=high){\\n            int mid= low +(high-low) / 2;\\n            \\n            if(valid(mid,candies,k)){\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            \\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908742,
                "title": "python-binary-search",
                "content": "\\n\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n\\t\\n        n = len(candies)\\n        \\n        if k > sum(candies):\\n            return 0\\n        \\n        def check(m):\\n            cnt = 0\\n            for c in candies:\\n                cnt += c//m\\n            \\n            if cnt >= k:\\n                return True\\n            else:\\n                return False\\n        \\n        l = 1\\n        r = max(candies)\\n        \\n        while l < r:\\n            m = l + (r-l+1)//2\\n            \\n            if check(m):\\n                l = m\\n            else:\\n                r = m - 1\\n        \\n        return l\\n        \\n",
                "solutionTags": [],
                "code": "\\n\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n\\t\\n        n = len(candies)\\n        \\n        if k > sum(candies):\\n            return 0\\n        \\n        def check(m):\\n            cnt = 0\\n            for c in candies:\\n                cnt += c//m\\n            \\n            if cnt >= k:\\n                return True\\n            else:\\n                return False\\n        \\n        l = 1\\n        r = max(candies)\\n        \\n        while l < r:\\n            m = l + (r-l+1)//2\\n            \\n            if check(m):\\n                l = m\\n            else:\\n                r = m - 1\\n        \\n        return l\\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 1908739,
                "title": "easy-concept-using-binary-search",
                "content": "\\nSimply do binary search, \\'guess\\' the max number of candies each child can get\\nsearching range: left = 0, right = (sum(candies)//k)+1\\nin each guess, we go through the whole candies array and check whether this guess is valid\\n\\ntime complexity: O(logS)*O(N), where S is the span of searching range\\nspace complexity: O(1)\\n\\n```\\nfrom typing import List\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        def is_valid(x):\\n            if x == 0: return True\\n            cnt = 0\\n            for p in candies:\\n                if p >= x:              # we can divide pile into any number of sub-piles\\n                    cnt += p//x\\n                if cnt >= k:\\n                    return True\\n            return False\\n        \\n        l, r = 0, (sum(candies)//k)+1\\n        while l < r:\\n            m = (l+r+1)//2\\n            if is_valid(m):             # everyone can get m candies, but could get more: try bigger m\\n                l = m\\n            else:\\n                r = m-1\\n\\n        return l\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\nfrom typing import List\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        def is_valid(x):\\n            if x == 0: return True\\n            cnt = 0\\n            for p in candies:\\n                if p >= x:              # we can divide pile into any number of sub-piles\\n                    cnt += p//x\\n                if cnt >= k:\\n                    return True\\n            return False\\n        \\n        l, r = 0, (sum(candies)//k)+1\\n        while l < r:\\n            m = (l+r+1)//2\\n            if is_valid(m):             # everyone can get m candies, but could get more: try bigger m\\n                l = m\\n            else:\\n                r = m-1\\n\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908704,
                "title": "binary-search-c-o-nlogk",
                "content": "```\\n// use binary search to get optimum valuse\\n// O(n)\\n\\nclass Solution {\\npublic:\\n    bool check( long long mid, vector<int> &candies, long long k){\\n        long long cnt=0;\\n        for(auto c : candies){\\n            cnt += 1ll*c/mid;\\n        }\\n        return cnt >= k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long lo=0, hi = 1e12+1;  // check for highest possible (although it will be max(candies))\\n        while(lo < hi){\\n            long long mid = lo+(hi-lo+1)/2;  \\n            if(mid == 0)\\n                return 0;\\n            if(check(mid, candies, k))\\n                lo = mid;\\n            else\\n                hi = mid-1;\\n        }\\n        return hi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\n// use binary search to get optimum valuse\\n// O(n)\\n\\nclass Solution {\\npublic:\\n    bool check( long long mid, vector<int> &candies, long long k){\\n        long long cnt=0;\\n        for(auto c : candies){\\n            cnt += 1ll*c/mid;\\n        }\\n        return cnt >= k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long lo=0, hi = 1e12+1;  // check for highest possible (although it will be max(candies))\\n        while(lo < hi){\\n            long long mid = lo+(hi-lo+1)/2;  \\n            if(mid == 0)\\n                return 0;\\n            if(check(mid, candies, k))\\n                lo = mid;\\n            else\\n                hi = mid-1;\\n        }\\n        return hi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908700,
                "title": "easy-to-understand-with-detailed-explanation-and-java-code-binary-search",
                "content": "***Please upvote if you find this helpful :)***\\n\\nA typical binary search implemetation. \\n\\nWe need to find the maximum candies every child can get. We take a lower and an upper bound and try to find if the current candy count can be given to every child or not. In case it can be given, then we try to find the same thing for a higher candy count and hence update our low to mid+1. In case, the current count is not valid, then we decrease the count to high = mid-1\\n\\nEdge case - If the sum of candies is less than no of students then the candies can\\'t be distributed and the ans will be 0.\\n\\n```\\nclass Solution {\\n    \\n    private boolean isValid(int[] candies, long k, int target){\\n        long ans = 0;\\n        for(int candy: candies){\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0ans += (long)(candy/target);\\n        }\\n        return (ans>=k);\\n    }\\n    public int maximumCandies(int[] candies, long k) {\\n        int low = 0;\\n        int high = 10000000;\\n        int ans = 0;\\n        long sum = 0;\\n        for(int candy: candies){\\n            sum += candy;\\n        }\\n        if(sum<k){\\n            return 0;\\n        }\\n        while(low<=high){\\n            int mid = (low+high)/2;\\n            if(isValid(candies,k,mid)){\\n                ans = mid;\\n                low = mid+1;\\n            }else{\\n                high = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private boolean isValid(int[] candies, long k, int target){\\n        long ans = 0;\\n        for(int candy: candies){\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0ans += (long)(candy/target);\\n        }\\n        return (ans>=k);\\n    }\\n    public int maximumCandies(int[] candies, long k) {\\n        int low = 0;\\n        int high = 10000000;\\n        int ans = 0;\\n        long sum = 0;\\n        for(int candy: candies){\\n            sum += candy;\\n        }\\n        if(sum<k){\\n            return 0;\\n        }\\n        while(low<=high){\\n            int mid = (low+high)/2;\\n            if(isValid(candies,k,mid)){\\n                ans = mid;\\n                low = mid+1;\\n            }else{\\n                high = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908698,
                "title": "c-binary-search-on-search-space-o-n-log-m-time-o-1-space",
                "content": "\\n**Binary search on Search space**\\nWe can atleast give 1 candy  and atmost max(candies) to each child. So, we binary search between 1 to max(candies).\\n\\n**How do we check, if we can give X candies to K children?**\\nIf we divide candy heaps into K or more sub heapes of size X. So, we try to divide each candy heap and see how many candy sub heaps of size X we can form. Sum of all X candy heaps in the array >= K children. Then we can say, we can divide X candies to K children.\\n\\n**Time complexity:** O(n log m), where n = size of array & m = max element in array\\n**Space complexity:** O(1)\\n\\n```\\n\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& candies, long long k, int val) {\\n        long long count = 0;\\n        for(int candy: candies) {\\n            count += candy / val;\\n        }\\n        \\n        return count >= k;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int left = 1;\\n        int right = INT_MIN;\\n        long long sum = 0;\\n        for(int candy: candies) { \\n            right = max(right, candy);\\n            sum += candy;\\n        }\\n        \\n        if(sum < k) { return 0; }\\n        \\n        long long result = 0;\\n        while(left <= right) {\\n            long long mid = left + (right - left) / 2;\\n            if(isPossible(candies, k, mid)) {\\n                result = mid;\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& candies, long long k, int val) {\\n        long long count = 0;\\n        for(int candy: candies) {\\n            count += candy / val;\\n        }\\n        \\n        return count >= k;\\n    }\\n    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int left = 1;\\n        int right = INT_MIN;\\n        long long sum = 0;\\n        for(int candy: candies) { \\n            right = max(right, candy);\\n            sum += candy;\\n        }\\n        \\n        if(sum < k) { return 0; }\\n        \\n        long long result = 0;\\n        while(left <= right) {\\n            long long mid = left + (right - left) / 2;\\n            if(isPossible(candies, k, mid)) {\\n                result = mid;\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4052744,
                "title": "c-solution-using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nbinary search approach similar to koko eating bananas\\n\\n# Complexity\\n- Time complexity:\\n- O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool noOfCandies(vector<int> candies,int n,long long candiesPerChild,long long totalNoOfKids){\\n        long long noOfKidsWithCandies=0;\\n        for(int i=0;i<n;i++){\\n            noOfKidsWithCandies+=candies[i]/candiesPerChild;\\n            if(noOfKidsWithCandies>=totalNoOfKids){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int n=candies.size();\\n        long long low=1;\\n        long long high=0;\\n        for(int i=0;i<n;i++){\\n            high+=candies[i];\\n        }\\n        if(k>high){\\n            return 0;\\n        }\\n        while(low<=high){\\n            long long mid=low+(high-low)/2;\\n            if(noOfCandies(candies,n,mid,k)){\\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return high;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool noOfCandies(vector<int> candies,int n,long long candiesPerChild,long long totalNoOfKids){\\n        long long noOfKidsWithCandies=0;\\n        for(int i=0;i<n;i++){\\n            noOfKidsWithCandies+=candies[i]/candiesPerChild;\\n            if(noOfKidsWithCandies>=totalNoOfKids){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }    \\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int n=candies.size();\\n        long long low=1;\\n        long long high=0;\\n        for(int i=0;i<n;i++){\\n            high+=candies[i];\\n        }\\n        if(k>high){\\n            return 0;\\n        }\\n        while(low<=high){\\n            long long mid=low+(high-low)/2;\\n            if(noOfCandies(candies,n,mid,k)){\\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return high;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024376,
                "title": "exactly-the-same-as-koko-eat-banana",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int max = Integer.MIN_VALUE;\\n        for (int candy : candies) max = Math.max(max, candy);\\n        int l = 0, r = max;\\n        while (l < r) {\\n            System.out.println(l + \" \" + r);\\n            int mid = r - (r - l ) / 2; // mid as unit\\n            if (canDivide(candies, k, mid)) {\\n                l = mid;\\n            } else {\\n                r = mid - 1;\\n            }\\n        }\\n        return l;\\n\\n    }\\n\\n    private boolean canDivide(int[] candies, long k, int unit) {\\n        if (unit == 0) return true; // This is different from koko question\\n        long cnt = 0;\\n        for (int candy : candies) {\\n            cnt += (long) candy / unit;\\n        }\\n\\n        return cnt >= k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int max = Integer.MIN_VALUE;\\n        for (int candy : candies) max = Math.max(max, candy);\\n        int l = 0, r = max;\\n        while (l < r) {\\n            System.out.println(l + \" \" + r);\\n            int mid = r - (r - l ) / 2; // mid as unit\\n            if (canDivide(candies, k, mid)) {\\n                l = mid;\\n            } else {\\n                r = mid - 1;\\n            }\\n        }\\n        return l;\\n\\n    }\\n\\n    private boolean canDivide(int[] candies, long k, int unit) {\\n        if (unit == 0) return true; // This is different from koko question\\n        long cnt = 0;\\n        for (int candy : candies) {\\n            cnt += (long) candy / unit;\\n        }\\n\\n        return cnt >= k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023068,
                "title": "c-binary-search-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long x=*max_element(candies.begin(),candies.end());\\n        long long low=1,high=x;\\n        long long ans=0;\\n        while(low<=high){\\n            long long mid=(low+high)/2;\\n            long long cnt=0;\\n            for(int i=0;i<candies.size();i++){\\n                cnt=cnt+candies[i]/mid;\\n            }\\n            if(cnt>=k){\\n                ans=max(ans,mid);\\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long x=*max_element(candies.begin(),candies.end());\\n        long long low=1,high=x;\\n        long long ans=0;\\n        while(low<=high){\\n            long long mid=(low+high)/2;\\n            long long cnt=0;\\n            for(int i=0;i<candies.size();i++){\\n                cnt=cnt+candies[i]/mid;\\n            }\\n            if(cnt>=k){\\n                ans=max(ans,mid);\\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988243,
                "title": "9-o-n-solution-using-binary-search",
                "content": "# Intuition\\nbecause equal no. of candies have to be distributed among k children, so we will have to check the feasibility of the number of candies that can be distributed.\\n\\nex: for cadies [ 5, 6, 8] and k = 3,\\nwe have to distriburte among k = 3 children, so we will find the largest number that can be extracted from any of the indexes k (3) times.\\nIt can be in different indexes or the same indexes.\\nfor the above example, it can be sub-divided into\\n[5, [5, 1], [5, 3]], so we can have 5 as the largest number of candies that can be distributed.\\n\\nif we had candies: [2, 20], k = 3;\\nhere we simply have to divide 20 into 3 equal numbers\\n[2, [6, 6, 6, 2]]\\nin the above we have 6 as an answer.\\n\\ntry solving problem number : 875\\n# Approach\\nfor every feasible number T from 1 -> totalSumOfCandies / n candies, we will check for each of them if its feasible or not to divide the array on that number T.\\nwe will use BS for this\\n\\n\\n# Complexity\\n- Time complexity:\\nN*O(N)\\n- Space complexity:\\nO(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n\\t\\t\\tint n = candies.size();\\n\\n\\t\\t\\tlong long totalCandies = accumulate(begin(candies),end(candies),0ll);\\n\\n\\t\\t\\tif(totalCandies < k)\\treturn 0;\\n\\n\\t\\t\\tlong long s = 1, e = totalCandies/k;\\n\\t\\t\\tlong long mid = -1;\\n\\n\\t\\t\\twhile(s <= e) {\\n\\t\\t\\t\\tmid = s + (e-s)/2;\\n\\n\\t\\t\\t\\tlong int cnt = 0;\\n\\t\\t\\t\\tfor(int i = 0; i < n; i++) {\\n\\t\\t\\t\\t\\tif(candies[i] >= mid)\\n\\t\\t\\t\\t\\t\\tcnt += 1ll*(candies[i]/mid);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif(cnt >= k)\\ts = mid+1;\\n\\t\\t\\t\\telse\\t\\t\\te = mid-1;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn e;\\n\\t\\t}\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n\\t\\t\\tint n = candies.size();\\n\\n\\t\\t\\tlong long totalCandies = accumulate(begin(candies),end(candies),0ll);\\n\\n\\t\\t\\tif(totalCandies < k)\\treturn 0;\\n\\n\\t\\t\\tlong long s = 1, e = totalCandies/k;\\n\\t\\t\\tlong long mid = -1;\\n\\n\\t\\t\\twhile(s <= e) {\\n\\t\\t\\t\\tmid = s + (e-s)/2;\\n\\n\\t\\t\\t\\tlong int cnt = 0;\\n\\t\\t\\t\\tfor(int i = 0; i < n; i++) {\\n\\t\\t\\t\\t\\tif(candies[i] >= mid)\\n\\t\\t\\t\\t\\t\\tcnt += 1ll*(candies[i]/mid);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif(cnt >= k)\\ts = mid+1;\\n\\t\\t\\t\\telse\\t\\t\\te = mid-1;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn e;\\n\\t\\t}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963858,
                "title": "simple-python-solution",
                "content": "# Intuition\\nThis is similar to minimizing the result but now we have to find the maximum that satisfies some condition. If you remember firstBadVersion problem, you know we didn\\'t stop until we found the result, the only difference is minimum lies on the left side of our inputs, and maximum on the right side. \\n\\n# Approach\\nBinary Search and narrow down till we have our result.\\n\\n# Code\\n```\\ndef success(number, candies, children):    \\n    count = 0\\n    for candy in candies:\\n        if number > 0:\\n            count += math.floor(candy/number)\\n        \\n        if count >= children:\\n            return True\\n    \\n    return False\\n\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        if sum(candies) < k:\\n            return 0\\n\\n        left = 1\\n        right = max(set(candies))\\n\\n        result = 0\\n        while left <= right:\\n            mid  = (left + right)//2\\n            if success(mid, candies, k):\\n                result = mid\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n\\n        return result\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef success(number, candies, children):    \\n    count = 0\\n    for candy in candies:\\n        if number > 0:\\n            count += math.floor(candy/number)\\n        \\n        if count >= children:\\n            return True\\n    \\n    return False\\n\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        if sum(candies) < k:\\n            return 0\\n\\n        left = 1\\n        right = max(set(candies))\\n\\n        result = 0\\n        while left <= right:\\n            mid  = (left + right)//2\\n            if success(mid, candies, k):\\n                result = mid\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n\\n        return result\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947592,
                "title": "c-solution-faster-than-95",
                "content": "# Intuition\\nImplementation of Book Allocation problem using Binary Search\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool isPossible(vector<int> arr, long long k, int mid) {\\n        long long int children = 0;\\n        for (int i : arr) {\\n            children += i / mid;\\n            if (children >= k) return true;\\n        }\\n        return false;\\n    }\\n\\n\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long int start = 1;\\n        long long int end = *max_element(candies.begin(), candies.end());;\\n        long long int mid = start + (end - start) / 2;\\n        long long int ans = 0;\\n\\n        while(start <= end) {\\n            if(isPossible(candies, k, mid)) {\\n                ans = mid;\\n                start = mid + 1;\\n            }\\n            else end = mid - 1;\\n            mid = start + (end - start) / 2;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n# Approach\\nI\\'ll try to explain using a testcase and dry run:\\n\\n### Input:\\ncandies = [5, 8, 6]\\nk = 3\\n\\n\\n\\n### Dry Run:\\n\\n1. Initialize start as 1, end as the maximum element in candies, which is 8, and mid as (1 + 8) / 2 = 4. ans is initialized as 0.\\n\\n\\n2. Enter the binary search loop:\\n- Check if it\\'s possible to distribute candies with mid = 4 among 3 children using isPossible().\\n    - Initialize children as 0.\\n    - Loop through each pile of candies:\\n        - For the first pile of 5 candies, children += 5 / 4, which is 1.\\n        - For the second pile of 8 candies, children += 8 / 4, which is 3.\\n        - For the third pile of 6 candies, children += 6 / 4, which is 4.\\n    - Check if children (4) is greater than or equal to k (3). It\\'s true.\\n    - Set ans to 4 and update start to mid + 1, which is 5.\\n    - Update mid to (5 + 8) / 2 = 6.\\n\\n\\n3. Loop again:\\n- Check if it\\'s possible to distribute candies with mid = 6 among 3 children using isPossible().\\n    - Initialize children as 0.\\n    - Loop through each pile of candies:\\n        - For the first pile of 5 candies, children += 5 / 6, which is 0.\\n        - For the second pile of 8 candies, children += 8 / 6, which is 1.\\n        - For the third pile of 6 candies, children += 6 / 6, which is 1.\\n    - Check if children (1) is greater than or equal to k (3). It\\'s false.\\n    - Update end to mid - 1, which is 5.\\n    - Update mid to (5 + 5) / 2 = 5.\\n\\n\\n4. Loop again:\\n- Check if it\\'s possible to distribute candies with mid = 5 among 3 children using isPossible().\\n    - Initialize children as 0.\\n    - Loop through each pile of candies:\\n        - For the first pile of 5 candies, children += 5 / 5, which is 1.\\n        - For the second pile of 8 candies, children += 8 / 5, which is 2.\\n        - For the third pile of 6 candies, children += 6 / 5, which is 3.\\n    - Check if children (3) is greater than or equal to k (3). It\\'s true.\\n    - Set ans to 5 and update start to mid + 1, which is 6.\\n    - Update mid to (6 + 5) / 2 = 5.\\n\\n5. Since start is not less than or equal to end, the loop ends.\\n\\n\\n### Output:\\nThe function returns ans, which is 5. This means each child can receive at most 5 candies.\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n * log(max_element))\\n\\n- Space complexity: O(1)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool isPossible(vector<int> arr, long long k, int mid) {\\n        long long int children = 0;\\n        for (int i : arr) {\\n            children += i / mid;\\n            if (children >= k) return true;\\n        }\\n        return false;\\n    }\\n\\n\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long int start = 1;\\n        long long int end = *max_element(candies.begin(), candies.end());;\\n        long long int mid = start + (end - start) / 2;\\n        long long int ans = 0;\\n\\n        while(start <= end) {\\n            if(isPossible(candies, k, mid)) {\\n                ans = mid;\\n                start = mid + 1;\\n            }\\n            else end = mid - 1;\\n            mid = start + (end - start) / 2;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3936994,
                "title": "c-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n     public int MaximumCandies(int[] candies, long k)\\n    {\\n        long left = 1;\\n        long right = 0;\\n\\n        long sum = 0;\\n        foreach (var candy in candies)\\n        {\\n            sum += candy;\\n        }\\n\\n        right = sum / k;\\n        var answer = 0;\\n        \\n        while (left <= right)\\n        {\\n            var mid = left + (right - left) / 2;\\n            var count = CalculateCandies(mid, candies);\\n            \\n            if (count < k)\\n            {\\n                right = mid - 1;\\n            }\\n            else\\n            {\\n                answer = (int)mid;\\n                left = mid + 1;\\n            }\\n        }\\n\\n        return answer;\\n    }\\n\\n    long CalculateCandies(long mid, int[] candies)\\n    {\\n        long count = 0;\\n        \\n        foreach (var candy in candies)\\n        {\\n            if (candy >= mid)\\n            {\\n                count += candy / mid;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n     public int MaximumCandies(int[] candies, long k)\\n    {\\n        long left = 1;\\n        long right = 0;\\n\\n        long sum = 0;\\n        foreach (var candy in candies)\\n        {\\n            sum += candy;\\n        }\\n\\n        right = sum / k;\\n        var answer = 0;\\n        \\n        while (left <= right)\\n        {\\n            var mid = left + (right - left) / 2;\\n            var count = CalculateCandies(mid, candies);\\n            \\n            if (count < k)\\n            {\\n                right = mid - 1;\\n            }\\n            else\\n            {\\n                answer = (int)mid;\\n                left = mid + 1;\\n            }\\n        }\\n\\n        return answer;\\n    }\\n\\n    long CalculateCandies(long mid, int[] candies)\\n    {\\n        long count = 0;\\n        \\n        foreach (var candy in candies)\\n        {\\n            if (candy >= mid)\\n            {\\n                count += candy / mid;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3931339,
                "title": "easy-binary-search-solution",
                "content": "Using Binary search optimized approach\\n\\n```\\nclass Solution {\\npublic:\\n    bool func(long long n,vector<int>& arr,long long k)\\n    {\\n        long long res=0;\\n        for(int i=0;i<arr.size();i++)\\n            res+=(long long)arr[i]/n;\\n        return res>=k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long l=1,n=candies.size();\\n        long long h=1;\\n        for(int i=0;i<n;i++)\\n            h=max(h,(long long)candies[i]);\\n        long long ans=0;\\n        while(l<=h)\\n        {\\n            long long mid=(l+h)/2;\\n            if(func(mid,candies,k))\\n            {\\n                ans=max(ans,mid);\\n                l=mid+1;\\n            }\\n            else\\n                h=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool func(long long n,vector<int>& arr,long long k)\\n    {\\n        long long res=0;\\n        for(int i=0;i<arr.size();i++)\\n            res+=(long long)arr[i]/n;\\n        return res>=k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long l=1,n=candies.size();\\n        long long h=1;\\n        for(int i=0;i<n;i++)\\n            h=max(h,(long long)candies[i]);\\n        long long ans=0;\\n        while(l<=h)\\n        {\\n            long long mid=(l+h)/2;\\n            if(func(mid,candies,k))\\n            {\\n                ans=max(ans,mid);\\n                l=mid+1;\\n            }\\n            else\\n                h=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3927055,
                "title": "easy-java-solution-for-beginners",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maximumCandies(int[] nums, long k) {\\n        int n=nums.length;\\n        int max=0;\\n        for(int x:nums){\\n            max=Math.max(x,max);\\n        }\\n        int st=1;\\n        int end=max;\\n        int ans=0;\\n        while(st<=end){\\n            int mid=(st+end)/2;\\n            if(solve(nums,mid)>=k){\\n                ans=Math.max(ans,mid);\\n                st=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    public double solve(int[] nums,int t){\\n        double count=0;\\n        if(t==0) return 0;\\n        for(int x:nums){\\n            count+=x/t;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] nums, long k) {\\n        int n=nums.length;\\n        int max=0;\\n        for(int x:nums){\\n            max=Math.max(x,max);\\n        }\\n        int st=1;\\n        int end=max;\\n        int ans=0;\\n        while(st<=end){\\n            int mid=(st+end)/2;\\n            if(solve(nums,mid)>=k){\\n                ans=Math.max(ans,mid);\\n                st=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    public double solve(int[] nums,int t){\\n        double count=0;\\n        if(t==0) return 0;\\n        for(int x:nums){\\n            count+=x/t;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924412,
                "title": "go-binary-search-100-runtime-90-memory",
                "content": "```\\nfunc maximumCandies(candies []int, k int64) int {\\n    sum := 0\\n    for _, c := range candies {\\n        sum+=c\\n    }\\n    if k > int64(sum) {\\n        return 0\\n    }\\n\\n    l, r, res := 1, sum/int(k), 0\\n\\n    for l <= r {\\n        m := (l+r)/2\\n        numOfCandies := 0\\n        \\n        for _, c := range candies {\\n            numOfCandies += (c / m)\\n        }\\n        if int64(numOfCandies) < k {\\n            r = m - 1\\n        } else {\\n            res = m\\n            l = m + 1\\n        }\\n    }\\n\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maximumCandies(candies []int, k int64) int {\\n    sum := 0\\n    for _, c := range candies {\\n        sum+=c\\n    }\\n    if k > int64(sum) {\\n        return 0\\n    }\\n\\n    l, r, res := 1, sum/int(k), 0\\n\\n    for l <= r {\\n        m := (l+r)/2\\n        numOfCandies := 0\\n        \\n        for _, c := range candies {\\n            numOfCandies += (c / m)\\n        }\\n        if int64(numOfCandies) < k {\\n            r = m - 1\\n        } else {\\n            res = m\\n            l = m + 1\\n        }\\n    }\\n\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3902866,
                "title": "c-binary-search",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(\\\\log{max(candies)})$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        sort(candies.begin(), candies.end());\\n        int lo = 1, hi = 0, mid, res = 0, n = candies.size();\\n        hi = candies.back();\\n        while (lo <= hi) {\\n            mid = (lo + hi) / 2;\\n            long long tmp = k;\\n            for (int i = n - 1; i >= 0; -- i) {\\n                tmp -= 1LL * candies[i] / mid;\\n                if (tmp <= 0) break;\\n            }\\n            if (tmp <= 0) {\\n                res = mid;\\n                lo = mid + 1;\\n            } else hi = mid - 1;\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Please upvote if u like the solution :)**",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        sort(candies.begin(), candies.end());\\n        int lo = 1, hi = 0, mid, res = 0, n = candies.size();\\n        hi = candies.back();\\n        while (lo <= hi) {\\n            mid = (lo + hi) / 2;\\n            long long tmp = k;\\n            for (int i = n - 1; i >= 0; -- i) {\\n                tmp -= 1LL * candies[i] / mid;\\n                if (tmp <= 0) break;\\n            }\\n            if (tmp <= 0) {\\n                res = mid;\\n                lo = mid + 1;\\n            } else hi = mid - 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3901111,
                "title": "binary-search-on-solution-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe number of piles, given the number of candies per child, can be calculated in linear time and is monotonic. So we can binary search on the solution space.\\n\\n# Complexity\\n- Time complexity: $$O(N*log(k))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn maximum_candies(candies: Vec<i32>, k: i64) -> i32 {\\n        let count_piles = |n| {\\n            candies.iter().map(|&c| (c / n) as i64).sum::<i64>()\\n        };\\n\\n        let mut lo = 0;\\n        let mut hi = *candies.iter().max().unwrap();\\n        while lo < hi {\\n            let mid = lo + (hi - lo + 1) / 2;\\n            if count_piles(mid) >= k { lo = mid }\\n            else { hi = mid - 1 }\\n        }\\n        lo\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn maximum_candies(candies: Vec<i32>, k: i64) -> i32 {\\n        let count_piles = |n| {\\n            candies.iter().map(|&c| (c / n) as i64).sum::<i64>()\\n        };\\n\\n        let mut lo = 0;\\n        let mut hi = *candies.iter().max().unwrap();\\n        while lo < hi {\\n            let mid = lo + (hi - lo + 1) / 2;\\n            if count_piles(mid) >= k { lo = mid }\\n            else { hi = mid - 1 }\\n        }\\n        lo\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3900497,
                "title": "c-solution-binary-search",
                "content": "\\n# Complexity\\n- Time complexity:\\n$$O(nlong(n))$$\\n- Space complexity:\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int high = INT_MIN;\\n        for(auto it : candies){\\n            high = max(high,it);\\n        }\\n        int low =1;\\n        while(low <= high){\\n            long long candiesget=0;\\n            int mid = (low+high)/2;\\n            for(auto it : candies){\\n                candiesget += (it)/mid;\\n\\n            }\\n            if(candiesget >= k){\\n                low = mid+1;\\n            }else{\\n                high = mid-1;\\n            }\\n        }\\n        return high;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int high = INT_MIN;\\n        for(auto it : candies){\\n            high = max(high,it);\\n        }\\n        int low =1;\\n        while(low <= high){\\n            long long candiesget=0;\\n            int mid = (low+high)/2;\\n            for(auto it : candies){\\n                candiesget += (it)/mid;\\n\\n            }\\n            if(candiesget >= k){\\n                low = mid+1;\\n            }else{\\n                high = mid-1;\\n            }\\n        }\\n        return high;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3893424,
                "title": "easy-solution-5-lines",
                "content": "# Complexity\\n- Time complexity:\\nO(log n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        l, r = 0, max(candies)\\n        while l <= r:\\n            m = (l+r)//2\\n            l, r = (m+1, r) if not m or sum(candy // m for candy in candies) >= k else (l, m-1)\\n        return r\\n```\\n\\nPlease let me know if any improvements can be made.\\n\\nThanks",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        l, r = 0, max(candies)\\n        while l <= r:\\n            m = (l+r)//2\\n            l, r = (m+1, r) if not m or sum(candy // m for candy in candies) >= k else (l, m-1)\\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3891171,
                "title": "best-approach-v-easy-to-understand-beats-90",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBinary Search\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool morePossible(vector<int>& candies, long long k, int amount){\\n        long long count = 0;\\n        for(int i = 0; i<candies.size(); i++){\\n            count += (candies[i]/amount);\\n        }\\n        if(count >= k)return true;\\n\\n        return false;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int right = *max_element(candies.begin(), candies.end());\\n        int left = 1;\\n        int res = 0;\\n       \\n        while(left <= right){\\n            int mid = (left +right)/2;\\n            if(morePossible(candies, k, mid)){\\n                res = mid;\\n                left = mid+1;\\n            }else{\\n                right = mid-1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool morePossible(vector<int>& candies, long long k, int amount){\\n        long long count = 0;\\n        for(int i = 0; i<candies.size(); i++){\\n            count += (candies[i]/amount);\\n        }\\n        if(count >= k)return true;\\n\\n        return false;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int right = *max_element(candies.begin(), candies.end());\\n        int left = 1;\\n        int res = 0;\\n       \\n        while(left <= right){\\n            int mid = (left +right)/2;\\n            if(morePossible(candies, k, mid)){\\n                res = mid;\\n                left = mid+1;\\n            }else{\\n                right = mid-1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890228,
                "title": "kotlin-solution",
                "content": "# Binary search\\n```\\nclass Solution {\\n    fun maximumCandies(candies: IntArray, k: Long): Int {\\n        var left = 0\\n        var right = 10_000_000\\n\\n        while (left < right) {\\n            val m = (left + right + 1) / 2\\n            var childWithCandies: Long = 0\\n\\n            candies.forEach {\\n                childWithCandies += it / m\\n            }\\n\\n            if (childWithCandies >= k) left = m\\n            else right = m - 1\\n        }\\n\\n        return left\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun maximumCandies(candies: IntArray, k: Long): Int {\\n        var left = 0\\n        var right = 10_000_000\\n\\n        while (left < right) {\\n            val m = (left + right + 1) / 2\\n            var childWithCandies: Long = 0\\n\\n            candies.forEach {\\n                childWithCandies += it / m\\n            }\\n\\n            if (childWithCandies >= k) left = m\\n            else right = m - 1\\n        }\\n\\n        return left\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887281,
                "title": "java-solution-binary-search-on-answer-beats-95",
                "content": "\\n\\n\\n# Complexity\\n- Time complexity: O(N*logM) M is range of max element.. \\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n       int low =1;\\n       int high = findMax(candies); \\n       while(low <= high){\\n           int mid = low + (high-low)/2;\\n           if(isValid(candies,mid,k)){\\n               low = mid+1;\\n           }else {\\n               high = mid-1;\\n           }\\n       }\\n       return high;\\n    }\\n    public int findMax(int [] candies){\\n        int max = 0;\\n        for(int i:candies){\\n            max = Math.max(max,i);\\n        }\\n        return max;\\n    }\\n\\n    public boolean isValid(int [] candies, int mid,long k){\\n        long piles = 0;\\n        for(int i: candies){\\n            int add = i/mid;\\n            piles += add;\\n        }\\n        return piles >=k;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n       int low =1;\\n       int high = findMax(candies); \\n       while(low <= high){\\n           int mid = low + (high-low)/2;\\n           if(isValid(candies,mid,k)){\\n               low = mid+1;\\n           }else {\\n               high = mid-1;\\n           }\\n       }\\n       return high;\\n    }\\n    public int findMax(int [] candies){\\n        int max = 0;\\n        for(int i:candies){\\n            max = Math.max(max,i);\\n        }\\n        return max;\\n    }\\n\\n    public boolean isValid(int [] candies, int mid,long k){\\n        long piles = 0;\\n        for(int i: candies){\\n            int add = i/mid;\\n            piles += add;\\n        }\\n        return piles >=k;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3880468,
                "title": "simple-binary-search-beginers",
                "content": "# Intuition\\nThe very simple binary search with simple and easy checker function \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFirst just put a binary search on the possible values of the answer in the vector simple and easy approch \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(  log(n) )\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checker(int target,long long int k ,vector <int > & candies)\\n    {\\n        for(int i=0;i<candies.size();i++)\\n        {\\n            k-=candies[i]/target;\\n        }\\n        if(k>0) return false;\\n        else return true;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long int low=1,mid,high=*max_element(candies.begin(),candies.end());\\n        int ans=0;\\n        while(low<=high)\\n        {\\n            mid=low+(high-low)/2;\\n            if(checker(mid,k,candies))\\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else high=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checker(int target,long long int k ,vector <int > & candies)\\n    {\\n        for(int i=0;i<candies.size();i++)\\n        {\\n            k-=candies[i]/target;\\n        }\\n        if(k>0) return false;\\n        else return true;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long int low=1,mid,high=*max_element(candies.begin(),candies.end());\\n        int ans=0;\\n        while(low<=high)\\n        {\\n            mid=low+(high-low)/2;\\n            if(checker(mid,k,candies))\\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else high=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879864,
                "title": "easy-c-sol",
                "content": "# Intuition\\njust use binary search to find mid and check that mid is possible or not..\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int>&candies,int mid,long long k)\\n    {\\n        long long cnt=0;\\n        for(int i=0;i<candies.size();i++)\\n        {\\n            cnt+=(candies[i]/mid);\\n        }\\n        return cnt>=k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n         int high=*max_element(candies.begin(),candies.end());\\n         int low=1;\\n         int ans=0;\\n         while(low<=high)\\n         {\\n              int mid=(low+high)/2;\\n              if(check(candies,mid,k))\\n              {\\n                  ans=max(ans,mid);\\n                  low=mid+1;\\n              }\\n              else high=mid-1;\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>&candies,int mid,long long k)\\n    {\\n        long long cnt=0;\\n        for(int i=0;i<candies.size();i++)\\n        {\\n            cnt+=(candies[i]/mid);\\n        }\\n        return cnt>=k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n         int high=*max_element(candies.begin(),candies.end());\\n         int low=1;\\n         int ans=0;\\n         while(low<=high)\\n         {\\n              int mid=(low+high)/2;\\n              if(check(candies,mid,k))\\n              {\\n                  ans=max(ans,mid);\\n                  low=mid+1;\\n              }\\n              else high=mid-1;\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3872085,
                "title": "detailed-thought-process-start-with-linear-search-and-convert-your-thought-to-binary-search-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBinary search: \\nHere this is the problem of maximisation over sorted search space.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# **First think of searching maximum candy linearly :**\\n\\nWhat will be sorted search space for this problem:\\n    Here candies = {5,8,6}; k = 3\\n   here total candies = (5+8+6) = 19 and these 19 candies we have to distribute on k children.\\n\\nso one just intuitive way comes to our mind that just devide 19 by 3 i.e 19/3 = 6 candy.  so distribute 6 candy to each children 6*3 = 18 candy will be distributed. so here one possible ans could be 6,\\nsay ans = 6, now check if this ans is valid or not\\n\\nhere we are distributing 6 candy to each children, then one thing we have to make sure that each of the piles must contains candy greater than or equal to 6 candy then only we will be able to distribute 6 candy to each children. as in problem statement it is clearly mentioned that you can\\'t merge two piles of candies.  but we can distribute two children from one pile. but candy from two pile can\\'t be distributed to single child.\\n\\nHere candies[0] = 5 < ans =6, so here it is not possible to distribute 6 candy to each children.\\nas to distribute 6 candy, we have to 2 extra candy to pile candies[1] = 8, so if we are using these 2 extra candy in candies[0] = 5 to distribute 6, then it is a king of merging candy from two piles that is conflicting the problem statement. so this is not possible.\\n\\n\\nNow lets reduce the amount of candy from 6 to 5, say ans = 5, lets check if we can distribute , so clearly we can see that each of the piles has greater than or equal to 5 candy. so this is our feasible ans.\\n\\nso we will not go below 5 as we need maximum candy to distribute.\\n\\n# Binary Search thought:\\n\\nSo above idea to search the maximum candy linearley. \\n\\nbut here search space is sorted we can apply binary search on the search space low = 1 and high = 10^7 or (sum of all candy)/ k\\n\\nhere low = 1 as we can distribute 1 candy for sure as 1<=candies[i]<= 10^7\\nand high = (sum of all candy)/ k or we can take directly 10^7 as it is the max possible value of candy in a pile. any thing greater than 10^7 is not possible. \\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int min = 0; int max = 0;\\n        long sum = 0;\\n        for(int candy : candies){\\n            sum += candy;\\n        }\\n\\n        if(sum < k) return 0;\\n        long s = 1;\\n        long e = (long)1e7;//sum/k;\\n        long ans = s;\\n        while(s <= e){\\n            long mid = s + (e-s)/2;\\n            if(canDistribute(candies,mid, k)){\\n                ans = mid;\\n                s = mid + 1;\\n            } else {\\n                e = mid -1;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n\\n\\n    private boolean canDistribute(int [] candies, long mid, long k){\\n        long count = 0;\\n        for(int candy : candies){\\n           count += candy/mid;\\n        }\\n        return count >= k;\\n    }\\n}\\n```\\n# Complexity\\n- Time complexity: O(nlog(Max{candies[i]})) as a for loop is running at starting to find the sum. \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int min = 0; int max = 0;\\n        long sum = 0;\\n        for(int candy : candies){\\n            sum += candy;\\n        }\\n\\n        if(sum < k) return 0;\\n        long s = 1;\\n        long e = (long)1e7;//sum/k;\\n        long ans = s;\\n        while(s <= e){\\n            long mid = s + (e-s)/2;\\n            if(canDistribute(candies,mid, k)){\\n                ans = mid;\\n                s = mid + 1;\\n            } else {\\n                e = mid -1;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n\\n\\n    private boolean canDistribute(int [] candies, long mid, long k){\\n        long count = 0;\\n        for(int candy : candies){\\n           count += candy/mid;\\n        }\\n        return count >= k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862887,
                "title": "binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long findNumberOfPeople(vector<int>& candies, long long mid) {\\n        long long total = 0;\\n        for(int i=0; i<candies.size(); i++) {\\n            total += candies[i] / mid;\\n        }\\n        return total;\\n    }\\n\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        if(accumulate(candies.begin(),candies.end(),0ll)<k)\\n        return 0;\\n        long long s = 1;\\n        long long h = *max_element(candies.begin(), candies.end());\\n        while (s < h) {\\n            long long m = s + (h - s + 1) / 2;\\n            if (findNumberOfPeople(candies, m) >= k) {\\n                s = m;\\n            }\\n            else {\\n                h = m - 1;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long findNumberOfPeople(vector<int>& candies, long long mid) {\\n        long long total = 0;\\n        for(int i=0; i<candies.size(); i++) {\\n            total += candies[i] / mid;\\n        }\\n        return total;\\n    }\\n\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        if(accumulate(candies.begin(),candies.end(),0ll)<k)\\n        return 0;\\n        long long s = 1;\\n        long long h = *max_element(candies.begin(), candies.end());\\n        while (s < h) {\\n            long long m = s + (h - s + 1) / 2;\\n            if (findNumberOfPeople(candies, m) >= k) {\\n                s = m;\\n            }\\n            else {\\n                h = m - 1;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849983,
                "title": "binary-search-13-ms-beats-99-7-runtime-98-77-memory",
                "content": "# Complexity\\n- Time complexity:\\nO(k * log(sum(candies)/k))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n  public int maximumCandies(int[] candies, long k) {\\n    long countCandies = 0;\\n    for (int i = 0; i < candies.length; i++) {\\n      countCandies += candies[i];\\n    }\\n\\n    long left = 1, right = countCandies / k;\\n    long maxCandies = 0;\\n    while (left <= right) {\\n      long mid = left + (right - left) / 2;\\n      long countAlloted = 0;\\n      for (int i = 0; i < candies.length; i++) {\\n        countAlloted += candies[i] / mid;\\n        if (countAlloted >= k) {\\n          break;\\n        }\\n      }\\n\\n      if (countAlloted >= k) {\\n        maxCandies = mid;\\n        left = mid + 1;\\n        continue;\\n      }\\n\\n      right = mid - 1;\\n    }\\n\\n    return (int) maxCandies;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n  public int maximumCandies(int[] candies, long k) {\\n    long countCandies = 0;\\n    for (int i = 0; i < candies.length; i++) {\\n      countCandies += candies[i];\\n    }\\n\\n    long left = 1, right = countCandies / k;\\n    long maxCandies = 0;\\n    while (left <= right) {\\n      long mid = left + (right - left) / 2;\\n      long countAlloted = 0;\\n      for (int i = 0; i < candies.length; i++) {\\n        countAlloted += candies[i] / mid;\\n        if (countAlloted >= k) {\\n          break;\\n        }\\n      }\\n\\n      if (countAlloted >= k) {\\n        maxCandies = mid;\\n        left = mid + 1;\\n        continue;\\n      }\\n\\n      right = mid - 1;\\n    }\\n\\n    return (int) maxCandies;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3848305,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    bool isPossible(vector<int>&candies,long long k,long long mid){\\n        long long count = 0;\\n        long long sum = 0;\\n        for(auto i:candies)\\n            count += i/mid;\\n        return count >= k;\\n    }\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int low = 1;\\n        long long high = 0;\\n        for(auto i:candies)\\n            high += i;\\n        long long ans = 0;\\n        long long mid = 0;\\n        if(high < k)\\n            return 0;\\n        while(low <= high){\\n            mid = low + (high - low)/2;\\n            if(isPossible(candies,k,mid)){\\n                ans = mid;\\n                low = mid + 1;\\n            }\\n            else\\n                high = mid - 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    bool isPossible(vector<int>&candies,long long k,long long mid){\\n        long long count = 0;\\n        long long sum = 0;\\n        for(auto i:candies)\\n            count += i/mid;\\n        return count >= k;\\n    }\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int low = 1;\\n        long long high = 0;\\n        for(auto i:candies)\\n            high += i;\\n        long long ans = 0;\\n        long long mid = 0;\\n        if(high < k)\\n            return 0;\\n        while(low <= high){\\n            mid = low + (high - low)/2;\\n            if(isPossible(candies,k,mid)){\\n                ans = mid;\\n                low = mid + 1;\\n            }\\n            else\\n                high = mid - 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3829075,
                "title": "faster-than-100-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n*log(right))\\n\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        if sum(candies)<k : \\n            return 0 \\n        \\n        def helper (val): \\n            crr = 0 \\n            for ele in candies : \\n                crr += (ele//val)\\n            if crr >= k : \\n                return True \\n            return False \\n        \\n        left =1\\n        right = sum(candies)//k \\n\\n        while left < right : \\n            mid = left + (right-left)//2\\n            if helper(mid): \\n                left = mid + 1 \\n            else : \\n                right = mid \\n        return left if helper(left) else left-1 \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        if sum(candies)<k : \\n            return 0 \\n        \\n        def helper (val): \\n            crr = 0 \\n            for ele in candies : \\n                crr += (ele//val)\\n            if crr >= k : \\n                return True \\n            return False \\n        \\n        left =1\\n        right = sum(candies)//k \\n\\n        while left < right : \\n            mid = left + (right-left)//2\\n            if helper(mid): \\n                left = mid + 1 \\n            else : \\n                right = mid \\n        return left if helper(left) else left-1 \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824964,
                "title": "python-binary-search-solution",
                "content": "# Intuition \\nBinary Search, where the max amount is the number of available candies we have. We want to maximize this so we update our result.\\n# Approach\\nThe only addition to binary search is to consider when a valid amount is foundm updating the max when an amount can be satisfied using integer division.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n log(m)), where m = sum(candies), the number of candies we can distribute, and n is the length of candies. \\n\\n- Space complexity:\\nO(1), we are only storing integer variables.\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        if sum(candies) < k:\\n            return 0\\n        res = 0\\n        def can(amt, kids):\\n            for val in candies:\\n                if val >= amt:\\n                    kids -= (val // amt)\\n                    if kids <= 0:\\n                        return True\\n            return kids <= 0\\n        l, r = 1, sum(candies)\\n        while l <= r:\\n            m = (l + r) // 2\\n            if can(m, k):\\n                res = m\\n                l = m + 1\\n            else:\\n                r = m - 1\\n        return res\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        if sum(candies) < k:\\n            return 0\\n        res = 0\\n        def can(amt, kids):\\n            for val in candies:\\n                if val >= amt:\\n                    kids -= (val // amt)\\n                    if kids <= 0:\\n                        return True\\n            return kids <= 0\\n        l, r = 1, sum(candies)\\n        while l <= r:\\n            m = (l + r) // 2\\n            if can(m, k):\\n                res = m\\n                l = m + 1\\n            else:\\n                r = m - 1\\n        return res\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821954,
                "title": "o-nlogn-solution-c-java-solution",
                "content": "\\n# Code\\n**Java**\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int n=candies.length;\\n        int l=1,r=Integer.MIN_VALUE;\\n        for(int i=0;i<n;i++) r=Math.max(r,candies[i]);\\n        // System.out.println(r);\\n        int ans=0;\\n        while(l<=r){\\n            int mid=l+(r-l)/2;\\n            if(bs(candies,mid,k)){\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else r=mid-1;\\n        }\\n        return ans;\\n    }\\n    public boolean bs(int[] candies, int candy,long k){\\n        long total=0;\\n        for(int c:candies){\\n            total+=(c/candy);\\n        }\\n        return k<=total;\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(std::vector<int>& candies, long long k) {\\n        int n = candies.size();\\n        int l = 1, r = INT_MIN;\\n        for (int i = 0; i < n; i++) {\\n            r = std::max(r, candies[i]);\\n        }\\n\\n        int ans = 0;\\n        while (l <= r) {\\n            int mid = l + (r - l) / 2;\\n            if (bs(candies, mid, k)) {\\n                ans = mid;\\n                l = mid + 1;\\n            } else {\\n                r = mid - 1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    bool bs(std::vector<int>& candies, int candy, long long k) {\\n        long long total = 0;\\n        for (int c : candies) {\\n            total += (c / candy);\\n        }\\n        return k <= total;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int n=candies.length;\\n        int l=1,r=Integer.MIN_VALUE;\\n        for(int i=0;i<n;i++) r=Math.max(r,candies[i]);\\n        // System.out.println(r);\\n        int ans=0;\\n        while(l<=r){\\n            int mid=l+(r-l)/2;\\n            if(bs(candies,mid,k)){\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else r=mid-1;\\n        }\\n        return ans;\\n    }\\n    public boolean bs(int[] candies, int candy,long k){\\n        long total=0;\\n        for(int c:candies){\\n            total+=(c/candy);\\n        }\\n        return k<=total;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(std::vector<int>& candies, long long k) {\\n        int n = candies.size();\\n        int l = 1, r = INT_MIN;\\n        for (int i = 0; i < n; i++) {\\n            r = std::max(r, candies[i]);\\n        }\\n\\n        int ans = 0;\\n        while (l <= r) {\\n            int mid = l + (r - l) / 2;\\n            if (bs(candies, mid, k)) {\\n                ans = mid;\\n                l = mid + 1;\\n            } else {\\n                r = mid - 1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    bool bs(std::vector<int>& candies, int candy, long long k) {\\n        long long total = 0;\\n        for (int c : candies) {\\n            total += (c / candy);\\n        }\\n        return k <= total;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820911,
                "title": "java-general-approach-to-handle-these-king-of-question-binary-search",
                "content": "\\tIn This question we know that we will have at least 1 candy in pile and maximum it can 10^7 and each pile can be divded  and we have to find our answer in that range \\n\\t\\n\\tNow there can be cases such that 1 pile is so big that it itself generate the answer from itself and here we check it through our valid \"MOSTLY THIS PART CHANGES IN THIS TYPE OF QUESTION\" .\\n\\tand there is simpy shifting left pointer to maximize the result ; \\n\\t\\n\\t\\n```\\nclass Solution {\\n    boolean valid(int[] arr, long k , int mid ){\\n        long piles = 0; \\n        for(int i = 0 ; i< arr.length ; ++i){\\n            piles += arr[i]/mid;\\n            if(piles >= k) return true;\\n        }\\n        return false;\\n                \\n        \\n    };\\n    public int maximumCandies(int[] candies, long k) {\\n        int l = 1 ,r = 10000000 ; \\n        \\n        int ans = 0; \\n        \\n        while( l <= r ){\\n            int mid = l + (r - l )/2;\\n            \\n            if(valid(candies,k,mid)){\\n                ans = mid; \\n                l = mid + 1; \\n            }\\n            else{\\n                r = mid -1; \\n            }\\n        }\\n        return ans ; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Array",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    boolean valid(int[] arr, long k , int mid ){\\n        long piles = 0; \\n        for(int i = 0 ; i< arr.length ; ++i){\\n            piles += arr[i]/mid;\\n            if(piles >= k) return true;\\n        }\\n        return false;\\n                \\n        \\n    };\\n    public int maximumCandies(int[] candies, long k) {\\n        int l = 1 ,r = 10000000 ; \\n        \\n        int ans = 0; \\n        \\n        while( l <= r ){\\n            int mid = l + (r - l )/2;\\n            \\n            if(valid(candies,k,mid)){\\n                ans = mid; \\n                l = mid + 1; \\n            }\\n            else{\\n                r = mid -1; \\n            }\\n        }\\n        return ans ; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820402,
                "title": "simple-binary-search",
                "content": "# Intuition\\ncheck how much we can give\\n\\n# Approach\\nBinary Search\\n\\n# Complexity**Bold**\\n- Time complexity:\\nnlog(1e7)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& candies, long long k,long long mid)\\n    {\\n        long long t=0;\\n        int n=candies.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            t+=(long long)candies[i]/mid;\\n        }\\n        return t>=k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long low=1,high=1e7;\\n        long long ans=0;\\n        while(low<=high)\\n        {\\n            long long mid=(low+high)/2;\\n            if(check(candies,k,mid))\\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else high=mid-1;\\n        }\\n        return int(ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& candies, long long k,long long mid)\\n    {\\n        long long t=0;\\n        int n=candies.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            t+=(long long)candies[i]/mid;\\n        }\\n        return t>=k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long low=1,high=1e7;\\n        long long ans=0;\\n        while(low<=high)\\n        {\\n            long long mid=(low+high)/2;\\n            if(check(candies,k,mid))\\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else high=mid-1;\\n        }\\n        return int(ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819137,
                "title": "easy-c-solution",
                "content": "class Solution {\\npublic:\\n    \\n    bool check(vector<int> &candies, long long k, int mid){\\n        long long numofPiles = 0;\\n        for(int it:candies){\\n            numofPiles += it/mid;\\n        }\\n        return numofPiles >= k;\\n    }\\n    int maximumCandies(vector<int> &candies, long long k) {\\n        int l=1, r=1e7, ans = 0;\\n        while(l<=r){\\n            int mid = (l+r)/2;\\n            if(check(candies, k, mid) == true){\\n                ans = mid;\\n                l = mid+1;\\n            }\\n            else{\\n                r = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    bool check(vector<int> &candies, long long k, int mid){\\n        long long numofPiles = 0;\\n        for(int it:candies){\\n            numofPiles += it/mid;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3810289,
                "title": "similar-to-book-allocations",
                "content": "# Intuition\\nWe have to find how much we can divide so that it is distributed equally.\\n**Naive**\\n- we can start looking form 1 to infinity and once it fails we know previous one is the correct distribution eg:- the max distribution we can do.\\nNow we can optimize it for binary search\\n\\n\\n\\n\\n# Approach\\n**Binary search**\\n- we can find the range how can we distribute as in question (there can be piles that will be unused) therefore as we dont have to include every pile then **MAX pile is the upper bound**\\n- Lower bound will be 1 as we can distribute 1 to each kid\\n\\nSo as we are looking for MAX ,where distribution is doable then we have to look into the right half (upper bound) and vice versa.\\n\\n# Complexity\\n- Time complexity:\\nO(log(max-1+1).N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        long low=1,high= getMaxPile(candies);\\n\\n        while(low<=high)\\n        {\\n            long mid=low+(high-low)/2;\\n\\n            if(canDivide(candies,k,mid))\\n            {\\n                low=mid+1;      \\n            }\\n            else\\n            {\\n                high=mid-1;\\n            }\\n        }\\n        return (int)high;\\n    }\\n\\n    public boolean canDivide(int[] candies, long k, long amount)\\n    {\\n        long count=0;\\n\\n        for(int candy : candies)\\n        {\\n            count+=(candy/amount);\\n        } \\n      //  System.out.println((k<=amount));\\n        return count>=k;  \\n    }\\n\\n    public long getMaxPile(int[] candies)\\n    {\\n        long max=candies[0];\\n\\n        for(int candy : candies)\\n        {\\n            if(candy>max)\\n            {\\n                max=candy;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        long low=1,high= getMaxPile(candies);\\n\\n        while(low<=high)\\n        {\\n            long mid=low+(high-low)/2;\\n\\n            if(canDivide(candies,k,mid))\\n            {\\n                low=mid+1;      \\n            }\\n            else\\n            {\\n                high=mid-1;\\n            }\\n        }\\n        return (int)high;\\n    }\\n\\n    public boolean canDivide(int[] candies, long k, long amount)\\n    {\\n        long count=0;\\n\\n        for(int candy : candies)\\n        {\\n            count+=(candy/amount);\\n        } \\n      //  System.out.println((k<=amount));\\n        return count>=k;  \\n    }\\n\\n    public long getMaxPile(int[] candies)\\n    {\\n        long max=candies[0];\\n\\n        for(int candy : candies)\\n        {\\n            if(candy>max)\\n            {\\n                max=candy;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807049,
                "title": "bs",
                "content": "**time: `O(KlogN)`; space: `O(1)`**\\n```\\nint maximumCandies(vector<int>& c, long long K)\\n{\\n\\tint l{}, h{10000001};\\n\\tfor( ; l+1<h; )\\n\\t{\\n\\t\\tint m = (l+h)/2;\\n\\t\\t(accumulate(begin(c), end(c), 0ll, [&](auto s, auto & c){ return s+1ll*c/m; })>=K ? l : h) = m;\\n\\t}\\n\\treturn l;\\n}\\n```\\n**Similar problems:**\\n[875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/discuss/2053517/bs?currentPage=1&orderBy=most_relevant&query=android)\\n[1891. Cutting Ribbons](https://leetcode.com/problems/cutting-ribbons/discuss/2963593/bs)\\n[2064. Minimized Maximum of Products Distributed to Any Store](https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/discuss/2127417/binary-search)\\n[1760. Minimum Limit of Balls in a Bag](https://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/discuss/1676227/binary-search)\\n[1300. Sum of Mutated Array Closest to Target](https://leetcode.com/problems/sum-of-mutated-array-closest-to-target/discuss/2969866/bs)\\n[1552. Magnetic Force Between Two Balls](https://leetcode.com/problems/magnetic-force-between-two-balls/discuss/3251398/ok)\\n[2517. Maximum Tastiness of Candy Basket](https://leetcode.com/problems/maximum-tastiness-of-candy-basket/discuss/3251393/ok)\\n[1482. Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/discuss/3253585/bs)\\n[1231. Divide Chocolate](https://leetcode.com/problems/divide-chocolate/discuss/3254564/bs)\\n[2226. Maximum Candies Allocated to K Children](https://leetcode.com/problems/maximum-candies-allocated-to-k-children/discuss/3807049/bs)\\n[2187. Minimum Time to Complete Trips](https://leetcode.com/problems/minimum-time-to-complete-trips/discuss/3808940/bs)\\n[2594. Minimum Time to Repair Cars](https://leetcode.com/problems/minimum-time-to-repair-cars/discuss/3945204/range-bs)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint maximumCandies(vector<int>& c, long long K)\\n{\\n\\tint l{}, h{10000001};\\n\\tfor( ; l+1<h; )\\n\\t{\\n\\t\\tint m = (l+h)/2;\\n\\t\\t(accumulate(begin(c), end(c), 0ll, [&](auto s, auto & c){ return s+1ll*c/m; })>=K ? l : h) = m;\\n\\t}\\n\\treturn l;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3805686,
                "title": "python-bs",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        \\n        def ispossible(n):\\n            if n==0:\\n                return True\\n            count = 0\\n            for e in candies:\\n                if e < n:\\n                    continue\\n                elif e == n:\\n                    count+=1\\n                else:\\n                    count+=e//n\\n            return count >= k\\n\\n        l = 0\\n        u = 10000000\\n        while l<=u:\\n            mid = (l+u)//2\\n            if ispossible(mid):\\n                l = mid+1\\n            else:\\n                u = mid-1\\n\\n        return l-1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        \\n        def ispossible(n):\\n            if n==0:\\n                return True\\n            count = 0\\n            for e in candies:\\n                if e < n:\\n                    continue\\n                elif e == n:\\n                    count+=1\\n                else:\\n                    count+=e//n\\n            return count >= k\\n\\n        l = 0\\n        u = 10000000\\n        while l<=u:\\n            mid = (l+u)//2\\n            if ispossible(mid):\\n                l = mid+1\\n            else:\\n                u = mid-1\\n\\n        return l-1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797209,
                "title": "easy-c-solution-using-bs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& A, long long k) {\\n        int left = 0, right = * max_element ( A.begin() , A.end());\\n        while (left < right) {\\n            long sum = 0, mid = (left + right + 1) / 2;\\n            for (int& a : A) {\\n                sum += a / mid;\\n            }\\n            if (k > sum)\\n                right = mid - 1;\\n            else\\n                left = mid;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& A, long long k) {\\n        int left = 0, right = * max_element ( A.begin() , A.end());\\n        while (left < right) {\\n            long sum = 0, mid = (left + right + 1) / 2;\\n            for (int& a : A) {\\n                sum += a / mid;\\n            }\\n            if (k > sum)\\n                right = mid - 1;\\n            else\\n                left = mid;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3759528,
                "title": "easy-to-understand-clean-code-commented-binary-search-in-the-possible-answer",
                "content": "# Approach\\nLet\\'s say you can give maximum `X` candies. How do you find if it\\'s true or not?\\nTry to spit the piles keeping at least `X` candies on that and calculate how many piles you can build. If the number of piles is greater than number of kids then answer is true otherwise false.\\n\\nNow try to find a suitable `X` using binary search.\\n\\n# Complexity\\n- Time complexity:\\n`O(n log N)`\\n\\n- Space complexity:\\n`O(1)` - No extra space\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long min_possible = 1;\\n        long long max_possible = *max_element(candies.begin(), candies.end());\\n        long long ans = 0;\\n\\n        // Find the number of pile you can build keeping at least\\n        // `value` candies in it */\\n        auto check = [&] (int value) {\\n            long long piles = 0;\\n            for (const auto &candy : candies) {\\n                piles += (candy / value);\\n            }\\n\\n            return piles >= k;\\n        };\\n\\n        // find a suitalbe answer using binary search\\n        while (min_possible <= max_possible) {\\n            long long trial = (min_possible + max_possible) / 2;\\n            if (check(trial)) {\\n                ans = max(ans, trial);\\n                min_possible = trial + 1;\\n            } else {\\n                max_possible = trial - 1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long min_possible = 1;\\n        long long max_possible = *max_element(candies.begin(), candies.end());\\n        long long ans = 0;\\n\\n        // Find the number of pile you can build keeping at least\\n        // `value` candies in it */\\n        auto check = [&] (int value) {\\n            long long piles = 0;\\n            for (const auto &candy : candies) {\\n                piles += (candy / value);\\n            }\\n\\n            return piles >= k;\\n        };\\n\\n        // find a suitalbe answer using binary search\\n        while (min_possible <= max_possible) {\\n            long long trial = (min_possible + max_possible) / 2;\\n            if (check(trial)) {\\n                ans = max(ans, trial);\\n                min_possible = trial + 1;\\n            } else {\\n                max_possible = trial - 1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3759367,
                "title": "maximum-candies-allocated-to-k-children",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCandies(self, a: List[int], k: int) -> int:\\n        ##Method 1\\n        def chq(a,v,k):\\n            c=0\\n            for i in a:\\n                c+=i//v\\n            return c>=k\\n            mx=float(\"-inf\")\\n        ans=0\\n        l=1\\n        h=max(a)\\n        while l<=h:\\n            m=(l+h)//2\\n            if chq(a,m,k):\\n                ans=m\\n                l=m+1\\n            else:\\n                h=m-1\\n        return(ans)\\n        ### Method 2 (Brute Force)\\n            # d={}\\n            # for i in range(len(a)):\\n            #     n=a[i]\\n            #     if n<v:\\n            #         if n in d:\\n            #             d[n]+=1\\n            #         else:\\n            #             d[n]=1\\n            #         continue\\n            #     while n:\\n            #         if n==0:\\n            #             break\\n            #         elif n<v:\\n            #             if n not in d:\\n            #                 d[n]=1\\n            #             else:\\n            #                 d[n]+=1\\n            #             break\\n            #         else:\\n            #             if v not in d:\\n            #                 d[v]=1\\n            #             else:\\n            #                 d[v]+=1\\n            #             n-=v\\n            # mx=float(\"-inf\")\\n            # for i in d:\\n            #     if d[i]>=k:\\n            #         mx=max(mx,i)\\n            # return mx\\n        # print(chq(a,8,k))\\n        \\n        # for i in range(1,max(a)+1):\\n        #     if chq(a,i,k)!=float(\"-inf\"):\\n        #         mx=max(mx,i)\\n        # if mx==float(\"-inf\"):return 0\\n        # return mx\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, a: List[int], k: int) -> int:\\n        ##Method 1\\n        def chq(a,v,k):\\n            c=0\\n            for i in a:\\n                c+=i//v\\n            return c>=k\\n            mx=float(\"-inf\")\\n        ans=0\\n        l=1\\n        h=max(a)\\n        while l<=h:\\n            m=(l+h)//2\\n            if chq(a,m,k):\\n                ans=m\\n                l=m+1\\n            else:\\n                h=m-1\\n        return(ans)\\n        ### Method 2 (Brute Force)\\n            # d={}\\n            # for i in range(len(a)):\\n            #     n=a[i]\\n            #     if n<v:\\n            #         if n in d:\\n            #             d[n]+=1\\n            #         else:\\n            #             d[n]=1\\n            #         continue\\n            #     while n:\\n            #         if n==0:\\n            #             break\\n            #         elif n<v:\\n            #             if n not in d:\\n            #                 d[n]=1\\n            #             else:\\n            #                 d[n]+=1\\n            #             break\\n            #         else:\\n            #             if v not in d:\\n            #                 d[v]=1\\n            #             else:\\n            #                 d[v]+=1\\n            #             n-=v\\n            # mx=float(\"-inf\")\\n            # for i in d:\\n            #     if d[i]>=k:\\n            #         mx=max(mx,i)\\n            # return mx\\n        # print(chq(a,8,k))\\n        \\n        # for i in range(1,max(a)+1):\\n        #     if chq(a,i,k)!=float(\"-inf\"):\\n        #         mx=max(mx,i)\\n        # if mx==float(\"-inf\"):return 0\\n        # return mx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3757149,
                "title": "binary-search-with-intuition",
                "content": "# Code\\n```\\nclass Solution {\\n    // Intuition: Doing binary search as possible range of ans is available\\n    // TC: O(logr * candies.length)\\n    // SC: O(1)\\n    public int maximumCandies(int[] candies, long totalChildren) {\\n        long l = 1;\\n        long r = candies[0];\\n        for(int c:candies){\\n            r+=c;\\n        }\\n        if(r<totalChildren){\\n            return 0;\\n        }\\n        long ans = 0;\\n        long mid = 0;\\n        // TC: O(logr)\\n        while(l<=r){\\n            mid = (l+r)/2;\\n            // TC: O(candies.length)\\n            if(canDistributeEqually(candies,totalChildren,mid)){\\n                ans = mid;\\n                l = mid+1;\\n            }else{\\n                r = mid-1;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n\\n    private boolean canDistributeEqually(int[] candies, long totalChildren, long eachMustHave){\\n        long count = 0;\\n        for(int c:candies){\\n            count+= c/eachMustHave;\\n        }\\n        return count>=totalChildren;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    // Intuition: Doing binary search as possible range of ans is available\\n    // TC: O(logr * candies.length)\\n    // SC: O(1)\\n    public int maximumCandies(int[] candies, long totalChildren) {\\n        long l = 1;\\n        long r = candies[0];\\n        for(int c:candies){\\n            r+=c;\\n        }\\n        if(r<totalChildren){\\n            return 0;\\n        }\\n        long ans = 0;\\n        long mid = 0;\\n        // TC: O(logr)\\n        while(l<=r){\\n            mid = (l+r)/2;\\n            // TC: O(candies.length)\\n            if(canDistributeEqually(candies,totalChildren,mid)){\\n                ans = mid;\\n                l = mid+1;\\n            }else{\\n                r = mid-1;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n\\n    private boolean canDistributeEqually(int[] candies, long totalChildren, long eachMustHave){\\n        long count = 0;\\n        for(int c:candies){\\n            count+= c/eachMustHave;\\n        }\\n        return count>=totalChildren;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710929,
                "title": "easy-to-understand-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe first notice that the maximum amount of candies in a pile can range from 0 to the max of candies, max(candies). We binary search over this range, utilizing a helper function to check if the chosen number for every pile is okay to allocate with. If we are successful in choosing the number for the maximum of this pile, we can find the max of this key value with our previous maximum. If we are not successful, then we decrease the size of our pile and binary search to the left. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        candies.sort()\\n        \\n        maximumNumCandies = 0\\n        \\n        #each child can take at most one pile of candies (some may go unused)\\n        #allocate piles of candies to k children such that each child gets the same number of candies\\n\\n        def canAllocatePiles(value):\\n            if value == 0:\\n                return True\\n            allocatedPiles = 0\\n            for pile in candies:\\n                allocatedPiles += (pile // value)\\n            return allocatedPiles >= k\\n\\n\\n        #the lower bound of candies a child can receive is 0. an upper bound is max(candies)\\n        lower, upper = 0, max(candies)\\n        #binary search through\\n        \\n        while lower <= upper:\\n            middle = (lower + upper) // 2\\n            \\n            if canAllocatePiles(middle):\\n                maximumNumCandies = max(maximumNumCandies, middle)\\n                lower = middle + 1\\n            else:\\n                upper = middle - 1\\n        \\n\\n        return maximumNumCandies\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        candies.sort()\\n        \\n        maximumNumCandies = 0\\n        \\n        #each child can take at most one pile of candies (some may go unused)\\n        #allocate piles of candies to k children such that each child gets the same number of candies\\n\\n        def canAllocatePiles(value):\\n            if value == 0:\\n                return True\\n            allocatedPiles = 0\\n            for pile in candies:\\n                allocatedPiles += (pile // value)\\n            return allocatedPiles >= k\\n\\n\\n        #the lower bound of candies a child can receive is 0. an upper bound is max(candies)\\n        lower, upper = 0, max(candies)\\n        #binary search through\\n        \\n        while lower <= upper:\\n            middle = (lower + upper) // 2\\n            \\n            if canAllocatePiles(middle):\\n                maximumNumCandies = max(maximumNumCandies, middle)\\n                lower = middle + 1\\n            else:\\n                upper = middle - 1\\n        \\n\\n        return maximumNumCandies\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704735,
                "title": "c-easy-solution-striver-approach-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& candies, int mid, long long k){\\n        long long cntOfsplit = 0;\\n        for(int i = 0; i < candies.size(); i++){\\n            cntOfsplit += candies[i]/mid;\\n        }\\n        return cntOfsplit >= k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int low = 1;\\n        int high = *max_element(candies.begin(), candies.end());\\n        while(low <= high){\\n            int mid = low+ (high- low)/2;\\n            if(isPossible(candies, mid, k)){\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid - 1;\\n            }\\n        }\\n        return high;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& candies, int mid, long long k){\\n        long long cntOfsplit = 0;\\n        for(int i = 0; i < candies.size(); i++){\\n            cntOfsplit += candies[i]/mid;\\n        }\\n        return cntOfsplit >= k;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int low = 1;\\n        int high = *max_element(candies.begin(), candies.end());\\n        while(low <= high){\\n            int mid = low+ (high- low)/2;\\n            if(isPossible(candies, mid, k)){\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid - 1;\\n            }\\n        }\\n        return high;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703155,
                "title": "binary-search-intuition-explained-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nClearly answer will be in between 0 and the max element of the vector.\\nWhen k is too high, answer have to b 0\\nWhen k is very low, (e.g. = 1) answer have to be maximum element\\n\\nSo Binary Search\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimply apply Binary search from with  l =0 and h = max_element. And for every mid element we will calculate in how many kids we can distribue the canides or subpiles. For that we just have to do $candies[i]/mid$. SO,,,,,,,,\\n\\n# Edge Case\\nJust keep in mind that we have low as 0. And when we will divide by mid, in cases mid can be 0 too. So, make a seprate case of that.\\n\\n# Complexity\\n- Time complexity:$O(nlogm)$ \\n- $n$ = Length of candies vector\\n- $m$ = max element of vector\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$O(1)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) \\n    {\\n        int i =0;\\n        long long j = *max_element(candies.begin(),candies.end());\\n        int ans=0;\\n        while(i<=j)\\n        {\\n            long long mid = i + (j-i)/2;\\n            long long temp=0;\\n            if(mid==0) temp=k;\\n            else\\n            {\\n                for(int a=0;a<candies.size();a++)\\n                {\\n                    temp = temp + floor((double)candies[a]/(double)mid);\\n                }\\n            }   \\n            if(temp>=k)\\n            {\\n                ans=mid;\\n                i=mid+1;\\n            }\\n            else\\n            {\\n                j=mid-1;\\n            }\\n        }    \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) \\n    {\\n        int i =0;\\n        long long j = *max_element(candies.begin(),candies.end());\\n        int ans=0;\\n        while(i<=j)\\n        {\\n            long long mid = i + (j-i)/2;\\n            long long temp=0;\\n            if(mid==0) temp=k;\\n            else\\n            {\\n                for(int a=0;a<candies.size();a++)\\n                {\\n                    temp = temp + floor((double)candies[a]/(double)mid);\\n                }\\n            }   \\n            if(temp>=k)\\n            {\\n                ans=mid;\\n                i=mid+1;\\n            }\\n            else\\n            {\\n                j=mid-1;\\n            }\\n        }    \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683524,
                "title": "swift-binary-search-solution-space",
                "content": "# Intuition\\n Define a solution space to perform a binary search to find the max # of candies per pile\\n \\n # Approach\\n Define a solution space of possible values.\\n The minimum pile count has to be 1 since a pile cannot contain 0 candies.\\n The maximum pile count is `max(candies)` since piles cannot be merged.\\n Use a binary search to find the max pile count that satisfies `checkPiles`.\\n \\n # Complexity\\n - Time complexity:\\n O(n log n) where `n` is `candies.count`.\\n O(n)(find max) * O(log n)(binary search) * O(n)(checkPiles)\\n \\n - Space complexity:\\n O(1) only a few integers are stored.\\n \\n This problem is similar to to [875. Koko eating bananas](https://leetcode.com/problems/koko-eating-bananas/)\\n\\n```\\nclass Solution {\\n\\n    func checkPiles(_ candies: [Int], _ k: Int, _ size: Int) -> Bool {\\n        var piles = 0\\n        for c in candies {\\n            piles += c / size\\n        }\\n\\n        return piles >= k\\n    }\\n\\n    func maximumCandies(_ candies: [Int], _ k: Int) -> Int {\\n        // Define the solution space\\n        var l = 1, r = Int.min, sum = 0 \\n        for c in candies {\\n            r = max(r, c)\\n            sum += c\\n        }\\n\\n        // The sum of all the piles has to be at least greater than the number of kids.\\n        guard sum >= k else { return 0 }\\n\\n        while l <= r {\\n            let mid = (l + r) / 2\\n            if checkPiles(candies, k, mid) {\\n                // Max number of candies satisfies the condition.\\n                // Try a bigger pile.\\n                l = mid + 1\\n            } else {\\n                // Num of candies per pile did not satisfy the condition.\\n                // Try a smaller pile.\\n                r = mid - 1\\n            }\\n        }\\n\\n        return r\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n\\n    func checkPiles(_ candies: [Int], _ k: Int, _ size: Int) -> Bool {\\n        var piles = 0\\n        for c in candies {\\n            piles += c / size\\n        }\\n\\n        return piles >= k\\n    }\\n\\n    func maximumCandies(_ candies: [Int], _ k: Int) -> Int {\\n        // Define the solution space\\n        var l = 1, r = Int.min, sum = 0 \\n        for c in candies {\\n            r = max(r, c)\\n            sum += c\\n        }\\n\\n        // The sum of all the piles has to be at least greater than the number of kids.\\n        guard sum >= k else { return 0 }\\n\\n        while l <= r {\\n            let mid = (l + r) / 2\\n            if checkPiles(candies, k, mid) {\\n                // Max number of candies satisfies the condition.\\n                // Try a bigger pile.\\n                l = mid + 1\\n            } else {\\n                // Num of candies per pile did not satisfy the condition.\\n                // Try a smaller pile.\\n                r = mid - 1\\n            }\\n        }\\n\\n        return r\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3639923,
                "title": "java-solution-binary-search-implementation",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int max = Integer.MIN_VALUE;\\n        long sum = 0;\\n        for(int p : candies){\\n            sum += p;\\n            max = Math.max(p, max);\\n        }\\n\\n        if(sum < k){\\n            return 0;\\n        }\\n        int lo = 1;\\n        int hi = max;\\n        int ans = -1;\\n        while(lo <= hi){\\n            long value = 0;\\n            int mid = lo + (hi - lo)/2;\\n            for(int i = 0;i<candies.length;i++){\\n                value += (candies[i]/mid);\\n            }\\n            if(value < k){\\n                \\n                hi = mid - 1;\\n            }\\n            else{\\n                ans = mid;\\n                lo = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int max = Integer.MIN_VALUE;\\n        long sum = 0;\\n        for(int p : candies){\\n            sum += p;\\n            max = Math.max(p, max);\\n        }\\n\\n        if(sum < k){\\n            return 0;\\n        }\\n        int lo = 1;\\n        int hi = max;\\n        int ans = -1;\\n        while(lo <= hi){\\n            long value = 0;\\n            int mid = lo + (hi - lo)/2;\\n            for(int i = 0;i<candies.length;i++){\\n                value += (candies[i]/mid);\\n            }\\n            if(value < k){\\n                \\n                hi = mid - 1;\\n            }\\n            else{\\n                ans = mid;\\n                lo = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630709,
                "title": "java-beats-92-very-easy-solution",
                "content": "# Complexity\\n- Time complexity: O(nlog(k))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int start=1,end=Integer.MIN_VALUE,ansv=0;\\n        for(int i:candies){\\n            end=Math.max(end,i);\\n        }\\n        while(start<=end){\\n            long sum=0;\\n            int mid=start+((end-start)>>1);\\n            for(int i:candies){\\n                sum+=i/mid;\\n            }\\n            if(sum>=k){\\n                    ansv=mid;\\n                    start=mid+1;\\n            }\\n            else\\n            end=mid-1;\\n        }\\n        return ansv;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int start=1,end=Integer.MIN_VALUE,ansv=0;\\n        for(int i:candies){\\n            end=Math.max(end,i);\\n        }\\n        while(start<=end){\\n            long sum=0;\\n            int mid=start+((end-start)>>1);\\n            for(int i:candies){\\n                sum+=i/mid;\\n            }\\n            if(sum>=k){\\n                    ansv=mid;\\n                    start=mid+1;\\n            }\\n            else\\n            end=mid-1;\\n        }\\n        return ansv;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3612438,
                "title": "c-easy-to-understand-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool flag(vector<int>&v,long long int mid,int n,long long int k){\\n    long long int kk=0;\\n    for(int i=0;i<n;i++){\\n        kk=kk+(v[i]/mid);\\n        if(kk>=k)return 1;\\n    }\\n    \\n    return 0;\\n\\n}\\n    int maximumCandies(vector<int>&candies, long long k) {\\n        int n=candies.size();\\n       long long int b=0;\\n       long long int a=1;\\n       int mx=0;\\n       for(int i=0;i<n;i++){\\n           mx=max(mx,candies[i]);\\n       }\\n       long long int ans=0;\\n       b=mx;\\n       while(a<=b){\\n           long long int mid=a+(b-a)/2;\\n           if(flag(candies,mid,n,k)){\\n               ans=mid;\\n               a=mid+1;\\n           }\\n           else{\\n               b=mid-1;\\n           }\\n\\n       }\\n       return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool flag(vector<int>&v,long long int mid,int n,long long int k){\\n    long long int kk=0;\\n    for(int i=0;i<n;i++){\\n        kk=kk+(v[i]/mid);\\n        if(kk>=k)return 1;\\n    }\\n    \\n    return 0;\\n\\n}\\n    int maximumCandies(vector<int>&candies, long long k) {\\n        int n=candies.size();\\n       long long int b=0;\\n       long long int a=1;\\n       int mx=0;\\n       for(int i=0;i<n;i++){\\n           mx=max(mx,candies[i]);\\n       }\\n       long long int ans=0;\\n       b=mx;\\n       while(a<=b){\\n           long long int mid=a+(b-a)/2;\\n           if(flag(candies,mid,n,k)){\\n               ans=mid;\\n               a=mid+1;\\n           }\\n           else{\\n               b=mid-1;\\n           }\\n\\n       }\\n       return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3611752,
                "title": "detailed-explanation-intuition-ranged-binary-search-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- We a given search space in which our answer occurs minimum answer can be 1  maximum answer can be maximum of array.\\n- Suppose a number 5 satisfies so all numbers less than 5 will also satisfy the problem we have to search for elements greater than 5, same is the case if 5 doesnot satisfy we have to search answers less then 5.\\n- All this indicate the use of **Binary Search**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Apply Binary Search\\n- If any element satisfy update the answer.\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        \\n        long l=1L,h=(long)-1e8,ans=0L;\\n        for(int i:candies)\\n            h = Math.max(h,i);\\n\\n        while(l<=h){\\n            long m = (h-l)/2+l;\\n            if(isPossible(candies,k,m)){\\n                ans = m;\\n                l=m+1;\\n            }else{\\n                h=m-1;\\n            }\\n        }\\n\\n        return (int)ans;\\n\\n        \\n    }\\n\\n    public boolean isPossible(int[] candies, long k,long m){\\n\\n        long c = 0L;\\n        for(int i:candies){\\n            if(i<m)\\n                continue;\\n\\n            c += (long)i/m;\\n            if(c>=k)\\n                return true;\\n        }\\n\\n        return c>=k;\\n\\n    }\\n}\\n```\\n\\n\\n**IF YOU LIKE IT PLS UPVOTE**\\n\\n\\n- thanks\\n",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        \\n        long l=1L,h=(long)-1e8,ans=0L;\\n        for(int i:candies)\\n            h = Math.max(h,i);\\n\\n        while(l<=h){\\n            long m = (h-l)/2+l;\\n            if(isPossible(candies,k,m)){\\n                ans = m;\\n                l=m+1;\\n            }else{\\n                h=m-1;\\n            }\\n        }\\n\\n        return (int)ans;\\n\\n        \\n    }\\n\\n    public boolean isPossible(int[] candies, long k,long m){\\n\\n        long c = 0L;\\n        for(int i:candies){\\n            if(i<m)\\n                continue;\\n\\n            c += (long)i/m;\\n            if(c>=k)\\n                return true;\\n        }\\n\\n        return c>=k;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3610302,
                "title": "easy-c-sol",
                "content": "# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        ll n=candies.size();\\n        ll sum=0;\\n        for(auto i:candies)sum+=i;\\n        if(sum<k)return 0;\\n        ll low=1;\\n        ll high=sum;\\n        ll ans=1;\\n        while(low<=high){\\n            ll mid=(low+high)/2;\\n            ll temp=0;\\n            for(int i=0;i<n;i++){\\n                temp+=floor(candies[i]*1.0/mid);\\n            }\\n            if(temp>=k){\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        ll n=candies.size();\\n        ll sum=0;\\n        for(auto i:candies)sum+=i;\\n        if(sum<k)return 0;\\n        ll low=1;\\n        ll high=sum;\\n        ll ans=1;\\n        while(low<=high){\\n            ll mid=(low+high)/2;\\n            ll temp=0;\\n            for(int i=0;i<n;i++){\\n                temp+=floor(candies[i]*1.0/mid);\\n            }\\n            if(temp>=k){\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581078,
                "title": "candies-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long int\\nclass Solution {\\npublic:\\n\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        ll n= candies.size();\\n        ll lo=1,hi=1e15,ans=0;\\n        while(lo<=hi){\\n            ll mid= (lo+hi)/2;\\n            ll totalkitnipilesbnsktihjismecandiesho=0;\\n            for(auto itr:candies){\\n                totalkitnipilesbnsktihjismecandiesho+=(itr/mid);\\n            }\\n            if(totalkitnipilesbnsktihjismecandiesho>=k){\\n                ans=mid;\\n                lo=mid+1;\\n            }\\n            else{\\n                hi=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        ll n= candies.size();\\n        ll lo=1,hi=1e15,ans=0;\\n        while(lo<=hi){\\n            ll mid= (lo+hi)/2;\\n            ll totalkitnipilesbnsktihjismecandiesho=0;\\n            for(auto itr:candies){\\n                totalkitnipilesbnsktihjismecandiesho+=(itr/mid);\\n            }\\n            if(totalkitnipilesbnsktihjismecandiesho>=k){\\n                ans=mid;\\n                lo=mid+1;\\n            }\\n            else{\\n                hi=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581042,
                "title": "java-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        long lo = 1, hi = Integer.MAX_VALUE;\\n        long ans=0;\\n        while(lo <= hi){\\n            long mid = (lo+hi)/2;\\n            long maxCandies=0;\\n            for(int i:candies){\\n                maxCandies += i/mid;\\n            }\\n            if(maxCandies >= k){\\n                ans = mid;\\n                lo = mid+1;\\n            } else{\\n                hi = mid-1;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        long lo = 1, hi = Integer.MAX_VALUE;\\n        long ans=0;\\n        while(lo <= hi){\\n            long mid = (lo+hi)/2;\\n            long maxCandies=0;\\n            for(int i:candies){\\n                maxCandies += i/mid;\\n            }\\n            if(maxCandies >= k){\\n                ans = mid;\\n                lo = mid+1;\\n            } else{\\n                hi = mid-1;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568094,
                "title": "possible-and-impossible-bound",
                "content": "# Approach\\nLet l be the lower bound of return value and r be the upper bound of lowest impossible value.\\nWhen l and r differ by 1, then l is what we want.\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int: \\n        l = 0 #True\\n        r = sum(candies) // k + 1 #False\\n\\n        while r - l > 1:\\n            m = (l + r) // 2\\n\\n            if sum(x // m for x in candies) >= k:\\n                l = m\\n            else:\\n                r = m\\n        \\n        return l\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int: \\n        l = 0 #True\\n        r = sum(candies) // k + 1 #False\\n\\n        while r - l > 1:\\n            m = (l + r) // 2\\n\\n            if sum(x // m for x in candies) >= k:\\n                l = m\\n            else:\\n                r = m\\n        \\n        return l\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567696,
                "title": "easy-approach-to-solve-solution-using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic: \\n    long long satisfiedchildren(int candiesperperson,vector<int>& candies ){\\n        long long  ans=0;\\n        int n=candies.size();\\n        for(int i=0; i<n; i++){\\n            ans += (candies[i]/candiesperperson);\\n\\n        }\\n        return ans;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int max_ele=INT_MIN;\\n        long long sum=0 , n=candies.size();\\n        for(int i=0; i<n; i++){\\n            max_ele= max(max_ele,candies[i]);\\n            sum+=candies[i];\\n        }\\n        if(sum<k) return 0;\\n\\n        int s=1, e=max_ele;\\n        int ans;\\n        while(s<=e)\\n        {\\n            int candiesperperson = s + (e-s)/2;\\n            long long sc = satisfiedchildren(candiesperperson, candies);\\n            if(sc>=k){\\n                ans=candiesperperson;\\n                s=candiesperperson+1;\\n            }\\n            else{\\n                e=candiesperperson-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    long long satisfiedchildren(int candiesperperson,vector<int>& candies ){\\n        long long  ans=0;\\n        int n=candies.size();\\n        for(int i=0; i<n; i++){\\n            ans += (candies[i]/candiesperperson);\\n\\n        }\\n        return ans;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        int max_ele=INT_MIN;\\n        long long sum=0 , n=candies.size();\\n        for(int i=0; i<n; i++){\\n            max_ele= max(max_ele,candies[i]);\\n            sum+=candies[i];\\n        }\\n        if(sum<k) return 0;\\n\\n        int s=1, e=max_ele;\\n        int ans;\\n        while(s<=e)\\n        {\\n            int candiesperperson = s + (e-s)/2;\\n            long long sc = satisfiedchildren(candiesperperson, candies);\\n            if(sc>=k){\\n                ans=candiesperperson;\\n                s=candiesperperson+1;\\n            }\\n            else{\\n                e=candiesperperson-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3517862,
                "title": "rust-solution-using-binary-search",
                "content": "# Code\\n```\\nimpl Solution {\\n  pub fn maximum_candies(candies: Vec<i32>, k: i64) -> i32 {\\n    let k = k as usize;\\n    let mut count = 0;\\n    let candies = candies.into_iter().map(|v| {\\n      count += v as usize;\\n      v as usize\\n    }).collect::<Vec<usize>>();\\n    if count < k {\\n      return 0\\n    }\\n\\n    let mut left = 0;\\n    let mut right = 10usize.pow(15);\\n    while left + 1 < right {\\n      let mid = (left+right)/2;\\n      let mut temp = 0;\\n      for &v in &candies {\\n        temp += v / mid;\\n      }\\n\\n      if temp < k {\\n        right = mid;\\n      } else {\\n        left = mid;\\n      }\\n    }\\n    left as i32\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Binary Search"
                ],
                "code": "```\\nimpl Solution {\\n  pub fn maximum_candies(candies: Vec<i32>, k: i64) -> i32 {\\n    let k = k as usize;\\n    let mut count = 0;\\n    let candies = candies.into_iter().map(|v| {\\n      count += v as usize;\\n      v as usize\\n    }).collect::<Vec<usize>>();\\n    if count < k {\\n      return 0\\n    }\\n\\n    let mut left = 0;\\n    let mut right = 10usize.pow(15);\\n    while left + 1 < right {\\n      let mid = (left+right)/2;\\n      let mut temp = 0;\\n      for &v in &candies {\\n        temp += v / mid;\\n      }\\n\\n      if temp < k {\\n        right = mid;\\n      } else {\\n        left = mid;\\n      }\\n    }\\n    left as i32\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3495761,
                "title": "easy-to-understand-javascript-solution-binary-search",
                "content": "```\\nvar maximumCandies = function(candies, k) {\\n    const sum = candies.reduce((total, candy) => total + candy);\\n    let min = 1;\\n    let max = Math.floor(sum / k) + 1;\\n    const isEnough = (count) => {\\n        const children = candies.reduce((result, candy) => {\\n            return result - Math.floor(candy / count);\\n        }, k);\\n\\n        return children <= 0;\\n    };\\n\\n    while (min < max) {\\n        const mid = Math.floor((min + max) / 2);\\n\\n        isEnough(mid) ? min = mid + 1 : max = mid;\\n    }\\n    return min - 1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maximumCandies = function(candies, k) {\\n    const sum = candies.reduce((total, candy) => total + candy);\\n    let min = 1;\\n    let max = Math.floor(sum / k) + 1;\\n    const isEnough = (count) => {\\n        const children = candies.reduce((result, candy) => {\\n            return result - Math.floor(candy / count);\\n        }, k);\\n\\n        return children <= 0;\\n    };\\n\\n    while (min < max) {\\n        const mid = Math.floor((min + max) / 2);\\n\\n        isEnough(mid) ? min = mid + 1 : max = mid;\\n    }\\n    return min - 1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3462275,
                "title": "python-binary-search-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        ans,low, high = 0,1, max(candies)\\n\\n        while low<=high:\\n            mid=(low+high)//2\\n            i=0\\n            c=0\\n            while i < len(candies):\\n                c+=candies[i]//mid \\n# integer division to to get number of children consuming mid from each pile \\n                i+=1\\n            if c>=k: \\n# if more than k children can consume candies from piles, it is possible that k children can receive more candies instead\\n                ans=mid\\n                low = mid + 1\\n            else:\\n                high = mid-1\\n        return ans\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        ans,low, high = 0,1, max(candies)\\n\\n        while low<=high:\\n            mid=(low+high)//2\\n            i=0\\n            c=0\\n            while i < len(candies):\\n                c+=candies[i]//mid \\n# integer division to to get number of children consuming mid from each pile \\n                i+=1\\n            if c>=k: \\n# if more than k children can consume candies from piles, it is possible that k children can receive more candies instead\\n                ans=mid\\n                low = mid + 1\\n            else:\\n                high = mid-1\\n        return ans\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3387141,
                "title": "java-easy-solution-aasheesh-111th-day",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int start = 0, end = 0 , ans = 0;\\n        for(int can:candies)    end = Math.max(end , can);\\n        \\n        while(start <= end){\\n            int mid = start + (end - start) /2;\\n            boolean flag = check(candies, k , mid);\\n            if(flag)    end = mid - 1;\\n            else{\\n                ans = mid;\\n                start = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private boolean check(int[] candies, long k, int mid) {\\n        if(mid == 0)    return false;\\n        long sum = 0;\\n        for(int can: candies){\\n            int num = can/mid;\\n            sum +=num;\\n        }\\n        if(sum >= k)   return false;\\n        return true;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumCandies(int[] candies, long k) {\\n        int start = 0, end = 0 , ans = 0;\\n        for(int can:candies)    end = Math.max(end , can);\\n        \\n        while(start <= end){\\n            int mid = start + (end - start) /2;\\n            boolean flag = check(candies, k , mid);\\n            if(flag)    end = mid - 1;\\n            else{\\n                ans = mid;\\n                start = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private boolean check(int[] candies, long k, int mid) {\\n        if(mid == 0)    return false;\\n        long sum = 0;\\n        for(int can: candies){\\n            int num = can/mid;\\n            sum +=num;\\n        }\\n        if(sum >= k)   return false;\\n        return true;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3385996,
                "title": "simple-c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long total =0;\\n        for(auto x:candies){\\n            total += x;\\n        }\\n\\n        if(total < k ){\\n            return 0;\\n        }\\n\\n        if(total == k){\\n            return 1;\\n        }\\n\\n        long long l = 1, r = total;\\n        long long ans = 0;\\n        while(l <= r){\\n            long long mid = (l+r)/2;\\n            long long piles = 0;\\n            for(auto x:candies){\\n                piles += x / mid;\\n            }\\n\\n            if(piles >= k){\\n                ans = max(ans, mid);\\n                l = mid+1;\\n            }\\n            else{\\n                r = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        long long total =0;\\n        for(auto x:candies){\\n            total += x;\\n        }\\n\\n        if(total < k ){\\n            return 0;\\n        }\\n\\n        if(total == k){\\n            return 1;\\n        }\\n\\n        long long l = 1, r = total;\\n        long long ans = 0;\\n        while(l <= r){\\n            long long mid = (l+r)/2;\\n            long long piles = 0;\\n            for(auto x:candies){\\n                piles += x / mid;\\n            }\\n\\n            if(piles >= k){\\n                ans = max(ans, mid);\\n                l = mid+1;\\n            }\\n            else{\\n                r = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384561,
                "title": "easy-to-understand-solution-using-binary-search-in-c",
                "content": "# Approach\\n  => Try to distrubute with large value of chocolates\\n  => Inside binary search, try to see if the chocolates can be distributed among n no. of childrens.\\n  => If it can be distributed then set your  start = mid + 1 and answer = mid value\\n  => Otherwise set end = mid - 1 \\n\\n# Complexity\\n- Time complexity:\\nO(NLogN)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaximumCandies(int[] candies, long k) {\\n        int ans = 0;\\n        int start = 1;\\n        int end =  (int) 1e9;\\n        while(start <= end){\\n            int mid = start + (end - start)/2;\\n            long count = 0;\\n            for(int i=0;i<candies.Length;i++){\\n                if(candies[i] >= mid){\\n                    count +=  candies[i] / mid;\\n                }\\n            }\\n            if(count < k){\\n                end = mid -1;\\n            }\\n            else{\\n                ans = mid;\\n                start = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Binary Search"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaximumCandies(int[] candies, long k) {\\n        int ans = 0;\\n        int start = 1;\\n        int end =  (int) 1e9;\\n        while(start <= end){\\n            int mid = start + (end - start)/2;\\n            long count = 0;\\n            for(int i=0;i<candies.Length;i++){\\n                if(candies[i] >= mid){\\n                    count +=  candies[i] / mid;\\n                }\\n            }\\n            if(count < k){\\n                end = mid -1;\\n            }\\n            else{\\n                ans = mid;\\n                start = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384435,
                "title": "c-binary-search-o-nlog-max-nums-i",
                "content": "```\\nclass Solution {\\npublic:\\n    bool ispossible(vector<int>&nums,long long num,long long k){\\n        \\n        long long students=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i]<num){\\n                continue;\\n            }\\n            else{\\n                int x=nums[i]/num;\\n                students=students+x;\\n                if(students>=k){\\n                    return true;\\n                }\\n            }\\n        }\\n        if(students<k){\\n            return false;\\n        }\\n        return true;\\n    }\\n    int maximumCandies(vector<int>& candies, long long k) {\\n        \\n        long long start=1;\\n        int maxi=-1e9;\\n        int n=candies.size();\\n        for(int i=0;i<n;i++){\\n            maxi=max(maxi,candies[i]);\\n        }\\n        long long end=maxi;\\n        long long ans=0;\\n        while(start<=end){\\n            \\n            long long mid=(start+end)/2;\\n            if(ispossible(candies,mid,k)){\\n                ans=mid;\\n                start=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "class Solution {\\npublic:\\n    bool ispossible(vector<int>&nums,long long num,long long k){\\n        \\n        long long students=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i]<num){\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3383004,
                "title": "c-easy-solution-binary-search-for-beginner",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& c, long long k) {\\n        long long int sum=0;\\n        for(auto x:c) sum+=x;\\n        if(sum<k) return 0; // if total candies is less than the sum then we can not allote atleast one to everyone , So ans is 0\\n        \\n       long long int s=1;\\n        long long int e=sum/k;   //this is the max candies that a child can get,\\n        long long int ans;\\n        while(s<=e){\\n            long long int mid=s+(e-s)/2;\\n            if(isPossible(mid,k,c)){         //this function will tell us, is it possible to allot mid no. of candies to allot a child\\n                ans=mid;\\n                s=mid+1;\\n            }\\n            else{\\n                e=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    private: bool isPossible(long long int mid,long long int k,vector<int>&c){\\n        for(auto x:c){\\n            k-=(x/mid);\\n        }\\n        return k<=0?true:false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumCandies(vector<int>& c, long long k) {\\n        long long int sum=0;\\n        for(auto x:c) sum+=x;\\n        if(sum<k) return 0; // if total candies is less than the sum then we can not allote atleast one to everyone , So ans is 0\\n        \\n       long long int s=1;\\n        long long int e=sum/k;   //this is the max candies that a child can get,\\n        long long int ans;\\n        while(s<=e){\\n            long long int mid=s+(e-s)/2;\\n            if(isPossible(mid,k,c)){         //this function will tell us, is it possible to allot mid no. of candies to allot a child\\n                ans=mid;\\n                s=mid+1;\\n            }\\n            else{\\n                e=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    private: bool isPossible(long long int mid,long long int k,vector<int>&c){\\n        for(auto x:c){\\n            k-=(x/mid);\\n        }\\n        return k<=0?true:false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1688215,
                "content": [
                    {
                        "username": "topswe",
                        "content": "   Hint: very similar to 875. Koko Eating Bananas. binary search the solution space. left = 0, right = max(candies)\n  Given a fixed number of candies each child can get, is easy to check if it is possible to allocate k piles. If possible, set left = mid. Otherwise set right = mid-1.\n\n  O(nlog(max(candies))) time : O(1) space"
                    },
                    {
                        "username": "c0D3M",
                        "content": "I dont want to add my approach as masters already did.\\nBut i wanted to give the link of my post in case anyone wanted to practice more problems like these.\\nhttps://leetcode.com/discuss/study-guide/1529866/solving-kth-kind-of-problems"
                    },
                    {
                        "username": "rnikh",
                        "content": "Similar Question: 2064. Minimized Maximum of Products Distributed to Any Store "
                    },
                    {
                        "username": "mohiwalla",
                        "content": "> Each child can take at most one pile of candies\\n\\n>Return the maximum number of candies each child can get.\\n\\nDo these two statements match?"
                    }
                ]
            },
            {
                "id": 1570836,
                "content": [
                    {
                        "username": "topswe",
                        "content": "   Hint: very similar to 875. Koko Eating Bananas. binary search the solution space. left = 0, right = max(candies)\n  Given a fixed number of candies each child can get, is easy to check if it is possible to allocate k piles. If possible, set left = mid. Otherwise set right = mid-1.\n\n  O(nlog(max(candies))) time : O(1) space"
                    },
                    {
                        "username": "c0D3M",
                        "content": "I dont want to add my approach as masters already did.\\nBut i wanted to give the link of my post in case anyone wanted to practice more problems like these.\\nhttps://leetcode.com/discuss/study-guide/1529866/solving-kth-kind-of-problems"
                    },
                    {
                        "username": "rnikh",
                        "content": "Similar Question: 2064. Minimized Maximum of Products Distributed to Any Store "
                    },
                    {
                        "username": "mohiwalla",
                        "content": "> Each child can take at most one pile of candies\\n\\n>Return the maximum number of candies each child can get.\\n\\nDo these two statements match?"
                    }
                ]
            },
            {
                "id": 1926229,
                "content": [
                    {
                        "username": "topswe",
                        "content": "   Hint: very similar to 875. Koko Eating Bananas. binary search the solution space. left = 0, right = max(candies)\n  Given a fixed number of candies each child can get, is easy to check if it is possible to allocate k piles. If possible, set left = mid. Otherwise set right = mid-1.\n\n  O(nlog(max(candies))) time : O(1) space"
                    },
                    {
                        "username": "c0D3M",
                        "content": "I dont want to add my approach as masters already did.\\nBut i wanted to give the link of my post in case anyone wanted to practice more problems like these.\\nhttps://leetcode.com/discuss/study-guide/1529866/solving-kth-kind-of-problems"
                    },
                    {
                        "username": "rnikh",
                        "content": "Similar Question: 2064. Minimized Maximum of Products Distributed to Any Store "
                    },
                    {
                        "username": "mohiwalla",
                        "content": "> Each child can take at most one pile of candies\\n\\n>Return the maximum number of candies each child can get.\\n\\nDo these two statements match?"
                    }
                ]
            },
            {
                "id": 2006201,
                "content": [
                    {
                        "username": "topswe",
                        "content": "   Hint: very similar to 875. Koko Eating Bananas. binary search the solution space. left = 0, right = max(candies)\n  Given a fixed number of candies each child can get, is easy to check if it is possible to allocate k piles. If possible, set left = mid. Otherwise set right = mid-1.\n\n  O(nlog(max(candies))) time : O(1) space"
                    },
                    {
                        "username": "c0D3M",
                        "content": "I dont want to add my approach as masters already did.\\nBut i wanted to give the link of my post in case anyone wanted to practice more problems like these.\\nhttps://leetcode.com/discuss/study-guide/1529866/solving-kth-kind-of-problems"
                    },
                    {
                        "username": "rnikh",
                        "content": "Similar Question: 2064. Minimized Maximum of Products Distributed to Any Store "
                    },
                    {
                        "username": "mohiwalla",
                        "content": "> Each child can take at most one pile of candies\\n\\n>Return the maximum number of candies each child can get.\\n\\nDo these two statements match?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Count Number of Texts",
        "question_content": "<p>Alice is texting Bob using her phone. The <strong>mapping</strong> of digits to letters is shown in the figure below.</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/15/1200px-telephone-keypad2svg.png\" style=\"width: 200px; height: 162px;\" />\n<p>In order to <strong>add</strong> a letter, Alice has to <strong>press</strong> the key of the corresponding digit <code>i</code> times, where <code>i</code> is the position of the letter in the key.</p>\n\n<ul>\n\t<li>For example, to add the letter <code>&#39;s&#39;</code>, Alice has to press <code>&#39;7&#39;</code> four times. Similarly, to add the letter <code>&#39;k&#39;</code>, Alice has to press <code>&#39;5&#39;</code> twice.</li>\n\t<li>Note that the digits <code>&#39;0&#39;</code> and <code>&#39;1&#39;</code> do not map to any letters, so Alice <strong>does not</strong> use them.</li>\n</ul>\n\n<p>However, due to an error in transmission, Bob did not receive Alice&#39;s text message but received a <strong>string of pressed keys</strong> instead.</p>\n\n<ul>\n\t<li>For example, when Alice sent the message <code>&quot;bob&quot;</code>, Bob received the string <code>&quot;2266622&quot;</code>.</li>\n</ul>\n\n<p>Given a string <code>pressedKeys</code> representing the string received by Bob, return <em>the <strong>total number of possible text messages</strong> Alice could have sent</em>.</p>\n\n<p>Since the answer may be very large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> pressedKeys = &quot;22233&quot;\n<strong>Output:</strong> 8\n<strong>Explanation:</strong>\nThe possible text messages Alice could have sent are:\n&quot;aaadd&quot;, &quot;abdd&quot;, &quot;badd&quot;, &quot;cdd&quot;, &quot;aaae&quot;, &quot;abe&quot;, &quot;bae&quot;, and &quot;ce&quot;.\nSince there are 8 possible messages, we return 8.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> pressedKeys = &quot;222222222222222222222222222222222222&quot;\n<strong>Output:</strong> 82876089\n<strong>Explanation:</strong>\nThere are 2082876103 possible text messages Alice could have sent.\nSince we need to return the answer modulo 10<sup>9</sup> + 7, we return 2082876103 % (10<sup>9</sup> + 7) = 82876089.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= pressedKeys.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>pressedKeys</code> only consists of digits from <code>&#39;2&#39;</code> - <code>&#39;9&#39;</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 2017753,
                "title": "simple-o-n-single-pass-solution",
                "content": "For every number other than 7 and 9, we can consider at most 3 **consecutive** digits whereas for 7 and 9 we can consider atmost 4 **consecutive** digits.\\n\\nLogic:\\n- Make an empty dp array.\\n- Iterate through every key pressed in pressedKeys and for every **i** we can add dp[i-1],dp[i-2],dp[i-3] to dp[i] and if pressedKeys[i] is either 7 or 9 then we can add dp[i-4] also.\\n- <img src=\"https://assets.leetcode.com/users/images/9a4f16ea-9965-4fa6-91a4-b2e3e5629139_1651982047.43855.jpeg\" width=450 height=400 align=center>\\n\\nCode:\\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        MOD=pow(10,9)+7\\n        dp=[0]*(len(pressedKeys)+1)\\n        dp[0]=1\\n        for i in range(1,len(pressedKeys)+1):\\n            dp[i]=dp[i-1]%MOD\\n            if(i-2>=0 and pressedKeys[i-1]==pressedKeys[i-2]):\\n                dp[i]=(dp[i]+dp[i-2])%MOD\\n                if(i-3>=0 and pressedKeys[i-1]==pressedKeys[i-3]):\\n                    dp[i]=(dp[i]+dp[i-3])%MOD\\n                    if(pressedKeys[i-1] in \"79\" and i-4>=0 and pressedKeys[i-1]==pressedKeys[i-4]):\\n                        dp[i]=(dp[i]+dp[i-4])%MOD\\n        return dp[-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        MOD=pow(10,9)+7\\n        dp=[0]*(len(pressedKeys)+1)\\n        dp[0]=1\\n        for i in range(1,len(pressedKeys)+1):\\n            dp[i]=dp[i-1]%MOD\\n            if(i-2>=0 and pressedKeys[i-1]==pressedKeys[i-2]):\\n                dp[i]=(dp[i]+dp[i-2])%MOD\\n                if(i-3>=0 and pressedKeys[i-1]==pressedKeys[i-3]):\\n                    dp[i]=(dp[i]+dp[i-3])%MOD\\n                    if(pressedKeys[i-1] in \"79\" and i-4>=0 and pressedKeys[i-1]==pressedKeys[i-4]):\\n                        dp[i]=(dp[i]+dp[i-4])%MOD\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017810,
                "title": "python-o-n-dp-easy-to-understand-with-explanation",
                "content": "**Observation and intuition**\\n\"return the total number of possible text messages Alice could have sent\" means that this is a counting-number-of-ways problem, which is a signal of trying dynamic programming.\\n\\nLet\\'s have some simple observations trying to get some intuition about the recurrence relations:\\n1. if S = \"2\", then we only have one option: (2)\\n2. if S = \"23\", then we only have one option: (2)(3)\\n3. if S = \"22\", then we have two options: (2)(2), (22)\\n4. if S = \"223\", then we have two options: (2)(2)(3), (22)(3)\\n5. if S = \"222\", then we have four options: (2)(2)(2), (22)(2), (2)(22), (222)\\n\\nNote that ***more options emerge because we can combine the same letters together***, this is the main fact that we should utilize to break down this problem.\\n\\n\\n**Explanation:**\\nWhen we traverse the string S and we are at the index i, there are 3 (or 4 for \"7\" and \"9\") cases to be considered for the letter at index i:\\n1. consider that letter separately, so combination[i] = combination[i - 1]\\n2. if the two last letters stopping at index i are the same, we have an option to combine them, then combination[i] += combination[i - 2]\\n3. if the three last letters stopping at index i are the same, we have an option to combine them, then combination[i] += combination[i - 3]\\n4. if the four last letters (for \"7\" and \"9\") stopping at index i are the same, we have an option to combine them, then combination[i] += combination[i - 4]\\n\\nTake \"2222\" as an example and we are at the last \"2\":\\ncase 1: \"222(2)\", combination[\"2222\"] = combination[\"222\"]\\ncase 2: \"22(22)\", combination[\"2222\"] += combination[\"22\"]\\ncase 3: \"2(222)\", combination[\"2222\"] += combination[\"2\"]\\n\\n```\\nclass Solution:\\n    def countTexts(self, S: str) -> int:\\n        \\n        mod = 10 ** 9 + 7\\n        \\n        dp = [0] * (len(S) + 1)\\n        dp[0] = 1\\n        for i in range(1, len(S) + 1):\\n            dp[i] = dp[i - 1]\\n            if i - 2 >= 0 and S[i-1] == S[i-2]:\\n                dp[i] += dp[i - 2]\\n            if i - 3 >= 0 and S[i-1] == S[i-2] and S[i-1] == S[i-3]:\\n                dp[i] += dp[i - 3]\\n                \\n            if S[i-1] in {\"7\", \"9\"}:\\n                if i - 4 >= 0 and S[i-1] == S[i-2] and S[i-1] == S[i-3] and S[i-1] == S[i-4]:\\n                    dp[i] += dp[i - 4]\\n            dp[i] %= mod\\n            \\n        return dp[-1] % mod",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution:\\n    def countTexts(self, S: str) -> int:\\n        \\n        mod = 10 ** 9 + 7\\n        \\n        dp = [0] * (len(S) + 1)\\n        dp[0] = 1\\n        for i in range(1, len(S) + 1):\\n            dp[i] = dp[i - 1]\\n            if i - 2 >= 0 and S[i-1] == S[i-2]:\\n                dp[i] += dp[i - 2]\\n            if i - 3 >= 0 and S[i-1] == S[i-2] and S[i-1] == S[i-3]:\\n                dp[i] += dp[i - 3]\\n                \\n            if S[i-1] in {\"7\", \"9\"}",
                "codeTag": "Java"
            },
            {
                "id": 2017714,
                "title": "o-n-o-1",
                "content": "We use tabulation `dp` to store the number of possible messages for `i` characters.\\n\\nFor `i + 1`-th character, the number of messages is `dp[i + 1] = dp[i]`, plus:\\n- `dp[i - 1]` if `key[i + 1] == key[i]`\\n- `dp[i - 2]` if `key[i + 1] == key[i - 1]`\\n- `dp[i - 3]` if `key[i + 1] == key[i - 2]`\\n- `dp[i - 4]` if `key[i + 1] == key[i - 3]` and `key[i + 1]` is either 7 or 9.\\n\\nNote that we only need to store the tabulation for 4 previous positions. We can use a circular array to achieve O(1) memory complexity.\\n\\n**C++**\\n```cpp\\nint countTexts(string k) {\\n    int dp[5] = {1, 1, 1, 1, 1}, n = k.size();\\n    for (int i = n - 1; i >= 0; --i) {\\n        dp[i % 5] = 0;\\n        int max_j = min(n, i + (k[i] == \\'7\\' || k[i] == \\'9\\' ? 4 : 3));\\n        for (int j = i; j < max_j && k[i] == k[j]; ++j)\\n            dp[i % 5] = (dp[i % 5] + dp[(j + 1) % 5]) % 1000000007;\\n    }\\n    return dp[0];\\n} \\n```",
                "solutionTags": [],
                "code": "```cpp\\nint countTexts(string k) {\\n    int dp[5] = {1, 1, 1, 1, 1}, n = k.size();\\n    for (int i = n - 1; i >= 0; --i) {\\n        dp[i % 5] = 0;\\n        int max_j = min(n, i + (k[i] == \\'7\\' || k[i] == \\'9\\' ? 4 : 3));\\n        for (int j = i; j < max_j && k[i] == k[j]; ++j)\\n            dp[i % 5] = (dp[i % 5] + dp[(j + 1) % 5]) % 1000000007;\\n    }\\n    return dp[0];\\n} \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2019208,
                "title": "java-from-recursion-to-memoization-to-tabulation-easy-solution",
                "content": "Recursion -->>\\n\\n```\\nclass Solution {\\n    int mod = (1000000007);\\n\\n    public int countTexts(String pressedKeys) {\\n        int[] key = new int[] { 0, 0, 3, 3, 3, 3, 3, 4, 3, 4 };\\n        int n = pressedKeys.length();\\n        return solve(0,pressedKeys,key);\\n    }\\n\\n    public int solve(int ind, String s, int[] key) {\\n        if (ind == s.length()) {\\n            return 1;\\n        }\\n        int count = 0;\\n        int num = s.charAt(ind) - \\'0\\';\\n        int rep = key[num];\\n        for (int i = 0; i < rep && ind + i < s.length() && s.charAt(ind) == s.charAt(ind + i); i++) {\\n            count += solve(ind + 1 + i, s, key);\\n            count %= mod;\\n        }\\n        return  count;\\n    }\\n}\\n```\\n\\nMemoization(Top-Down)-->>\\n\\n```\\nclass Solution {\\n    int mod = (1000000007);\\n    public int countTexts(String pressedKeys) {\\n         int[] key = new int[] {0,0,3,3,3,3,3,4,3,4};\\n         int n = pressedKeys.length();\\n         int[] dp = new int[n];\\n        Arrays.fill(dp,-1);\\n         return solve(0,pressedKeys,key,dp);\\n    }\\n    public int solve(int ind , String s ,int[] key,int[]dp){\\n        if(ind==s.length()){\\n            return 1;\\n        }\\n        if(dp[ind]!=-1) return dp[ind];\\n        int count = 0;\\n        int num = s.charAt(ind)-\\'0\\';\\n        int rep = key[num];\\n        for(int i =0;i<rep && ind+i<s.length() && s.charAt(ind)==s.charAt(ind+i);i++){\\n            count += solve(ind+1+i,s,key,dp);\\n            count %= mod;\\n        }\\n        return dp[ind] = count;\\n    }\\n}\\n```\\n\\nTabulation(Bottom up)-->>\\n```\\nclass Solution {\\n    int mod = (1000000007);\\n\\n    public int countTexts(String pressedKeys) {\\n        int[] key = new int[] { 0, 0, 3, 3, 3, 3, 3, 4, 3, 4 };\\n        int n = pressedKeys.length();\\n        int[] dp = new int[n + 1];\\n        dp[n] = 1;\\n\\n        for (int ind = n - 1; ind >= 0; ind--) {\\n            int count = 0;\\n            int num = pressedKeys.charAt(ind) - \\'0\\';\\n            int rep = key[num];\\n            for (int i = 0; i < rep && ind + i < pressedKeys.length() && pressedKeys.charAt(ind) == pressedKeys.charAt(ind + i); i++) {\\n                count += dp[ind+i+1];\\n                count %= mod;\\n            }\\n             dp[ind] = count;\\n        }\\n        return dp[0];\\n    }\\n}\\n```\\n\\nDo Upvote if you find these solution Helpful.",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int mod = (1000000007);\\n\\n    public int countTexts(String pressedKeys) {\\n        int[] key = new int[] { 0, 0, 3, 3, 3, 3, 3, 4, 3, 4 };\\n        int n = pressedKeys.length();\\n        return solve(0,pressedKeys,key);\\n    }\\n\\n    public int solve(int ind, String s, int[] key) {\\n        if (ind == s.length()) {\\n            return 1;\\n        }\\n        int count = 0;\\n        int num = s.charAt(ind) - \\'0\\';\\n        int rep = key[num];\\n        for (int i = 0; i < rep && ind + i < s.length() && s.charAt(ind) == s.charAt(ind + i); i++) {\\n            count += solve(ind + 1 + i, s, key);\\n            count %= mod;\\n        }\\n        return  count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int mod = (1000000007);\\n    public int countTexts(String pressedKeys) {\\n         int[] key = new int[] {0,0,3,3,3,3,3,4,3,4};\\n         int n = pressedKeys.length();\\n         int[] dp = new int[n];\\n        Arrays.fill(dp,-1);\\n         return solve(0,pressedKeys,key,dp);\\n    }\\n    public int solve(int ind , String s ,int[] key,int[]dp){\\n        if(ind==s.length()){\\n            return 1;\\n        }\\n        if(dp[ind]!=-1) return dp[ind];\\n        int count = 0;\\n        int num = s.charAt(ind)-\\'0\\';\\n        int rep = key[num];\\n        for(int i =0;i<rep && ind+i<s.length() && s.charAt(ind)==s.charAt(ind+i);i++){\\n            count += solve(ind+1+i,s,key,dp);\\n            count %= mod;\\n        }\\n        return dp[ind] = count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int mod = (1000000007);\\n\\n    public int countTexts(String pressedKeys) {\\n        int[] key = new int[] { 0, 0, 3, 3, 3, 3, 3, 4, 3, 4 };\\n        int n = pressedKeys.length();\\n        int[] dp = new int[n + 1];\\n        dp[n] = 1;\\n\\n        for (int ind = n - 1; ind >= 0; ind--) {\\n            int count = 0;\\n            int num = pressedKeys.charAt(ind) - \\'0\\';\\n            int rep = key[num];\\n            for (int i = 0; i < rep && ind + i < pressedKeys.length() && pressedKeys.charAt(ind) == pressedKeys.charAt(ind + i); i++) {\\n                count += dp[ind+i+1];\\n                count %= mod;\\n            }\\n             dp[ind] = count;\\n        }\\n        return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2109592,
                "title": "very-detailed-recursive-tree-diagram-with-decent-intuition-c-memorized-code",
                "content": "# Count Number of Texts\\n\\n***Intuition***\\n* As we know in feature phones, numbers (2, 3, 4, 5, 6, 8) have maximum 3 characters while (7 and 9) have 4 characters.\\n* So if we encountered same key press again in input then we have 2 choices either we can take it as single key press (take 1st letter of that pressed number) and move on or we can say that  a previously pressed number tapped again (if a same key pressed again then we take the next letter which is embedded to that number key).\\n***Example***\\n\\t* Let\\'s say we have input \"22223\"\\n       * if we consider every number was pressed once then the output word would be \"aaaad\".\\n       * if we consider that 2 was pressed twice at same time then the output word would be \"baac\".\\n       * if we say 2 pressed thrice then, we\\'ll get \"cab\" as the output\\n       * (**note**) This time we can\\'t take four 2s at same time because we know, we can only get a letter from number key 2 when it gets pressed once (a), twice(b) & thrice(c). Therefore the 4th keypress (2) considered as first tap & the keypress gives \\'a\\'.\\n  * **Please refer to the below recursive tree diagram for better understanding.**\\n<br>\\n![image](https://assets.leetcode.com/users/images/54f19f39-f2f0-463c-bec7-148f134327c0_1654338912.543673.png)\\n\\n***Please Upvote if you like the post*** \\u2B06\\uFE0F\\n\\n**Recursion [TLE]**\\n\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int solve(string &str, int idx) {\\n        if(idx == str.length()) return 1;\\n        int maxKeyPress = (str[idx] == \\'7\\' || str[idx] == \\'9\\') ? 4 : 3;\\n        long long currIndex = idx, pressFrequency = 1, ans = 0;\\n        while(pressFrequency <= maxKeyPress && str[currIndex] == str[idx]) {\\n            ++currIndex;\\n            ++pressFrequency;\\n            ans += solve(str, currIndex) % mod;\\n        }\\n        return ans%mod;\\n    }\\n    int countTexts(string pressedKeys) {\\n        return solve(pressedKeys, 0) % mod;\\n    }\\n};\\n```\\n\\n**Recursion + Memoization [#ACCEPTED]**\\n*TC : O(N) & SC: O(N), where N is input string length*\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[100005];\\n    int mod = 1e9+7;\\n    int solve(string &str, int idx) {\\n        if(idx == str.length()) return 1;\\n        if(dp[idx] != -1) return dp[idx];\\n        int maxKeyPress = (str[idx] == \\'7\\' || str[idx] == \\'9\\') ? 4 : 3;\\n        long long currIndex = idx, pressFrequency = 1, ans = 0;\\n        while(pressFrequency <= maxKeyPress && str[currIndex] == str[idx]) {\\n            ++currIndex;\\n            ++pressFrequency;\\n            ans += solve(str, currIndex) % mod;\\n        }\\n        return dp[idx] = ans%mod;\\n    }\\n    int countTexts(string pressedKeys) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(pressedKeys, 0) % mod;\\n    }\\n};\\n```\\n\\nThanks to [@aman-Raj](https://leetcode.com/aman-raj/) & [@anishakd](https://leetcode.com/anishakd/) for helping in recursive tree diagram \\u2764\\uFE0F.",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int solve(string &str, int idx) {\\n        if(idx == str.length()) return 1;\\n        int maxKeyPress = (str[idx] == \\'7\\' || str[idx] == \\'9\\') ? 4 : 3;\\n        long long currIndex = idx, pressFrequency = 1, ans = 0;\\n        while(pressFrequency <= maxKeyPress && str[currIndex] == str[idx]) {\\n            ++currIndex;\\n            ++pressFrequency;\\n            ans += solve(str, currIndex) % mod;\\n        }\\n        return ans%mod;\\n    }\\n    int countTexts(string pressedKeys) {\\n        return solve(pressedKeys, 0) % mod;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int dp[100005];\\n    int mod = 1e9+7;\\n    int solve(string &str, int idx) {\\n        if(idx == str.length()) return 1;\\n        if(dp[idx] != -1) return dp[idx];\\n        int maxKeyPress = (str[idx] == \\'7\\' || str[idx] == \\'9\\') ? 4 : 3;\\n        long long currIndex = idx, pressFrequency = 1, ans = 0;\\n        while(pressFrequency <= maxKeyPress && str[currIndex] == str[idx]) {\\n            ++currIndex;\\n            ++pressFrequency;\\n            ans += solve(str, currIndex) % mod;\\n        }\\n        return dp[idx] = ans%mod;\\n    }\\n    int countTexts(string pressedKeys) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(pressedKeys, 0) % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018336,
                "title": "python-dp-with-diagrams-for-beginners",
                "content": "I have created some diagrams to help learners better understand how the dp works.\\nWe create ```dp = [1] + [0] * len(pressedKeys)``` for dp[0] to become a \"base case\". \\nAt each continuous number, we append the appropriate letter to reach the \"required length\".\\nTake string \"222233\" as an example:\\n![image](https://assets.leetcode.com/users/images/67828b61-eb60-44cd-bbec-438a1f223934_1651988165.4311492.png)\\n\\n\\n\\nSame concept applies when moving to next different number:\\n![image](https://assets.leetcode.com/users/images/50a25151-b975-4404-83a9-4b6da3f8cba8_1652146323.6530101.png)\\n\\n\\n```\\nclass Solution(object):\\n    def countTexts(self, pressedKeys):\\n        \"\"\"\\n        :type pressedKeys: str\\n        :rtype: int\\n        \"\"\"\\n        dp = [1] + [0]*len(pressedKeys)\\n        mod = 10**9 + 7\\n        for i, n in enumerate(pressedKeys):\\n            dp[i+1] = dp[i]\\n            # check if is continous\\n            if i >= 1 and pressedKeys[i-1] == n:\\n                dp[i+1] += dp[i-1]\\n                dp[i+1] %= mod\\n                if i >= 2 and pressedKeys[i-2] == n:\\n                    dp[i+1] += dp[i-2]\\n                    dp[i+1] %= mod\\n                    # Special case for \\'7\\' and \\'9\\' that can have 4 characters combination\\n                    if i >= 3 and pressedKeys[i-3] == n and (n == \"7\" or n == \"9\"):\\n                        dp[i+1] += dp[i-3]\\n                        dp[i+1] %= mod\\n        return dp[-1]\\n```\\nCode can be further optimized.\\nInspired from https://leetcode.com/problems/count-number-of-texts/discuss/2017760/JavaPython-3-Time-O(n)-space-O(1)-1-pass-DP-codes .\\n\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```dp = [1] + [0] * len(pressedKeys)```\n```\\nclass Solution(object):\\n    def countTexts(self, pressedKeys):\\n        \"\"\"\\n        :type pressedKeys: str\\n        :rtype: int\\n        \"\"\"\\n        dp = [1] + [0]*len(pressedKeys)\\n        mod = 10**9 + 7\\n        for i, n in enumerate(pressedKeys):\\n            dp[i+1] = dp[i]\\n            # check if is continous\\n            if i >= 1 and pressedKeys[i-1] == n:\\n                dp[i+1] += dp[i-1]\\n                dp[i+1] %= mod\\n                if i >= 2 and pressedKeys[i-2] == n:\\n                    dp[i+1] += dp[i-2]\\n                    dp[i+1] %= mod\\n                    # Special case for \\'7\\' and \\'9\\' that can have 4 characters combination\\n                    if i >= 3 and pressedKeys[i-3] == n and (n == \"7\" or n == \"9\"):\\n                        dp[i+1] += dp[i-3]\\n                        dp[i+1] %= mod\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017760,
                "title": "java-python-3-1-pass-o-n-o-1-dp-codes-w-explanation-analysis-and-similar-problem",
                "content": "A Similar problem: \\n[91. Decode Ways](https://leetcode.com/problems/decode-ways/description/)\\n\\n----\\n\\n1. If the digit at index `i` was pressed just `1` times, then the corresponding solution is same as that of the subproblem of `i - 1`; e.g.,\\n\\n *   7   7   7  (7)\\n\\n2. If the digit at index `i` was acutally pressed `2` times, then the corresponding solution is same as that of the subproblem of `i - 2`; e.g.,\\n\\n*   7   7  (7   7)\\n\\n3.  If the digit at index `i` was acutally pressed `3` times, then the corresponding solution is same as that of the subproblem of `i - 3`; e.g.,\\n\\n *   7  (7   7   7)\\n\\n4.  If the digit at index `i` is `7` or `9` and was acutally pressed `4` times, then the corresponding solution is same as that of the subproblem of `i - 4`; e.g.,\\n\\n *  (7   7   7   7)\\n\\nCombine the above 4 cases, we can use `dp[i]` to indicate the solution of `pressedKeys.substring(0, i)`, and the general DP transition function is as follows:\\n```text\\ndp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3] + dp[i - 4]\\n```\\n\\n----\\n\\n```java\\n    private static final int MOD = 1_000_000_007;\\n    public int countTexts(String pressedKeys) {\\n        int n = pressedKeys.length();\\n        int[] dp = new int[n + 1];\\n        dp[0] = 1;\\n        for (int i = 1; i <= n; ++i) {\\n            char c = pressedKeys.charAt(i - 1);\\n            dp[i] = dp[i - 1];\\n            if (i >= 2) {\\n                if (c == pressedKeys.charAt(i - 2)) {\\n                    dp[i] = (dp[i] + dp[i - 2]) % MOD; \\n                    if (i >= 3 && c == pressedKeys.charAt(i - 3)) {\\n                        dp[i] = (dp[i] + dp[i - 3]) % MOD;\\n                        if ((c == \\'7\\' || c == \\'9\\') && i >= 4 && c == pressedKeys.charAt(i - 4)) {\\n                            dp[i] = (dp[i] + dp[i - 4]) % MOD;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n```\\n```python\\n    def countTexts(self, p: str) -> int:\\n        dp = [1] + [0] * len(p)\\n        for i, c in enumerate(p, 1):\\n            dp[i] = dp[i - 1]\\n            if i >= 2:    \\n                if c == p[i - 2]:\\n                    dp[i] += dp[i - 2]\\n                    if i >= 3 and c == p[i - 3]:\\n                        dp[i] += dp[i - 3]\\n                        if c in (\\'7\\', \\'9\\') and i >= 4 and c == p[i - 4]:\\n                            dp[i] += dp[i - 4]\\n            dp[i] %= 10 ** 9 + 7        \\n        return dp[len(p)]\\n```\\n**Analysis:**\\nTime & space: `O(n)`, where `n = pressedKeys.length()`.\\n\\n----\\n\\nAfter space optimization:\\n\\n```java\\n    private static final int MOD = 1_000_000_007;\\n    public int countTexts(String pressedKeys) {\\n        int n = pressedKeys.length();\\n        int[] dp = new int[5];\\n        dp[0] = 1;\\n        for (int i = 1; i <= n; ++i) {\\n            char c = pressedKeys.charAt(i - 1);\\n            int idx = i % 5;\\n            dp[idx] = dp[(i - 1) % 5];\\n            if (i >= 2) {\\n                if (c == pressedKeys.charAt(i - 2)) {\\n                    dp[idx] = (dp[idx] + dp[(i - 2) % 5]) % MOD; \\n                    if (i >= 3 && c == pressedKeys.charAt(i - 3)) {\\n                        dp[idx] = (dp[idx] + dp[(i - 3) % 5]) % MOD;\\n                        if ((c == \\'7\\' || c == \\'9\\') && i >= 4 && c == pressedKeys.charAt(i - 4)) {\\n                            dp[idx] = (dp[idx] + dp[(i - 4) % 5]) % MOD;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n % 5];\\n    }\\n```\\n```python\\n    def countTexts(self, pressedKeys: str) -> int:\\n        dp = [1] + [0] * 4\\n        for i, c in enumerate(pressedKeys, 1):\\n            dp[i % 5] = dp[(i - 1) % 5]\\n            if i >= 2:    \\n                if c == pressedKeys[i - 2]:\\n                    dp[i % 5] += dp[(i - 2) % 5]\\n                    if i >= 3 and c == pressedKeys[i - 3]:\\n                        dp[i % 5] += dp[(i - 3) % 5]\\n                        if c in (\\'7\\', \\'9\\') and i >= 4 and c == pressedKeys[i - 4]:\\n                            dp[i % 5] += dp[(i - 4) % 5]\\n            dp[i % 5] %= 10 ** 9 + 7        \\n        return dp[len(pressedKeys) % 5]\\n```\\n\\nSimplify the above codes further:\\n\\n```java\\n    private static final int MOD = 1_000_000_007;\\n    public int countTexts(String pressedKeys) {\\n        int n = pressedKeys.length();\\n        int[] dp = new int[5];\\n        dp[0] = 1;\\n        for (int i = 1; i <= n; ++i) {\\n            char c = pressedKeys.charAt(i - 1);\\n            int idx = i % 5, lowBound = Math.max(0, i - (c == \\'7\\' || c == \\'9\\' ? 4 : 3));\\n            dp[idx] = dp[(i - 1) % 5];\\n            for (int j = i - 2; j >= lowBound && c == pressedKeys.charAt(j); --j) {\\n                dp[idx] = (dp[idx] + dp[j % 5]) % MOD; \\n            }\\n        }\\n        return dp[n % 5];\\n    }\\n```\\n```python\\n    def countTexts(self, pressedKeys: str) -> int:\\n        dp = [1] + [0] * 4\\n        for i, c in enumerate(pressedKeys, 1):\\n            dp[i % 5] = dp[(i - 1) % 5]\\n            for j in range(i - 2, max(-1, i - 4 - (c in \\'79\\')), -1):\\n                if c == pressedKeys[j]:\\n                    dp[i % 5] += dp[j % 5]\\n                else:\\n                    break    \\n            dp[i % 5] %= 10 ** 9 + 7        \\n        return dp[len(pressedKeys) % 5]\\n```\\n**Analysis:**\\nTime: `O(n)`, space: `O(1)`, where `n = pressedKeys.length()`.",
                "solutionTags": [],
                "code": "```text\\ndp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3] + dp[i - 4]\\n```\n```java\\n    private static final int MOD = 1_000_000_007;\\n    public int countTexts(String pressedKeys) {\\n        int n = pressedKeys.length();\\n        int[] dp = new int[n + 1];\\n        dp[0] = 1;\\n        for (int i = 1; i <= n; ++i) {\\n            char c = pressedKeys.charAt(i - 1);\\n            dp[i] = dp[i - 1];\\n            if (i >= 2) {\\n                if (c == pressedKeys.charAt(i - 2)) {\\n                    dp[i] = (dp[i] + dp[i - 2]) % MOD; \\n                    if (i >= 3 && c == pressedKeys.charAt(i - 3)) {\\n                        dp[i] = (dp[i] + dp[i - 3]) % MOD;\\n                        if ((c == \\'7\\' || c == \\'9\\') && i >= 4 && c == pressedKeys.charAt(i - 4)) {\\n                            dp[i] = (dp[i] + dp[i - 4]) % MOD;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n```\n```python\\n    def countTexts(self, p: str) -> int:\\n        dp = [1] + [0] * len(p)\\n        for i, c in enumerate(p, 1):\\n            dp[i] = dp[i - 1]\\n            if i >= 2:    \\n                if c == p[i - 2]:\\n                    dp[i] += dp[i - 2]\\n                    if i >= 3 and c == p[i - 3]:\\n                        dp[i] += dp[i - 3]\\n                        if c in (\\'7\\', \\'9\\') and i >= 4 and c == p[i - 4]:\\n                            dp[i] += dp[i - 4]\\n            dp[i] %= 10 ** 9 + 7        \\n        return dp[len(p)]\\n```\n```java\\n    private static final int MOD = 1_000_000_007;\\n    public int countTexts(String pressedKeys) {\\n        int n = pressedKeys.length();\\n        int[] dp = new int[5];\\n        dp[0] = 1;\\n        for (int i = 1; i <= n; ++i) {\\n            char c = pressedKeys.charAt(i - 1);\\n            int idx = i % 5;\\n            dp[idx] = dp[(i - 1) % 5];\\n            if (i >= 2) {\\n                if (c == pressedKeys.charAt(i - 2)) {\\n                    dp[idx] = (dp[idx] + dp[(i - 2) % 5]) % MOD; \\n                    if (i >= 3 && c == pressedKeys.charAt(i - 3)) {\\n                        dp[idx] = (dp[idx] + dp[(i - 3) % 5]) % MOD;\\n                        if ((c == \\'7\\' || c == \\'9\\') && i >= 4 && c == pressedKeys.charAt(i - 4)) {\\n                            dp[idx] = (dp[idx] + dp[(i - 4) % 5]) % MOD;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n % 5];\\n    }\\n```\n```python\\n    def countTexts(self, pressedKeys: str) -> int:\\n        dp = [1] + [0] * 4\\n        for i, c in enumerate(pressedKeys, 1):\\n            dp[i % 5] = dp[(i - 1) % 5]\\n            if i >= 2:    \\n                if c == pressedKeys[i - 2]:\\n                    dp[i % 5] += dp[(i - 2) % 5]\\n                    if i >= 3 and c == pressedKeys[i - 3]:\\n                        dp[i % 5] += dp[(i - 3) % 5]\\n                        if c in (\\'7\\', \\'9\\') and i >= 4 and c == pressedKeys[i - 4]:\\n                            dp[i % 5] += dp[(i - 4) % 5]\\n            dp[i % 5] %= 10 ** 9 + 7        \\n        return dp[len(pressedKeys) % 5]\\n```\n```java\\n    private static final int MOD = 1_000_000_007;\\n    public int countTexts(String pressedKeys) {\\n        int n = pressedKeys.length();\\n        int[] dp = new int[5];\\n        dp[0] = 1;\\n        for (int i = 1; i <= n; ++i) {\\n            char c = pressedKeys.charAt(i - 1);\\n            int idx = i % 5, lowBound = Math.max(0, i - (c == \\'7\\' || c == \\'9\\' ? 4 : 3));\\n            dp[idx] = dp[(i - 1) % 5];\\n            for (int j = i - 2; j >= lowBound && c == pressedKeys.charAt(j); --j) {\\n                dp[idx] = (dp[idx] + dp[j % 5]) % MOD; \\n            }\\n        }\\n        return dp[n % 5];\\n    }\\n```\n```python\\n    def countTexts(self, pressedKeys: str) -> int:\\n        dp = [1] + [0] * 4\\n        for i, c in enumerate(pressedKeys, 1):\\n            dp[i % 5] = dp[(i - 1) % 5]\\n            for j in range(i - 2, max(-1, i - 4 - (c in \\'79\\')), -1):\\n                if c == pressedKeys[j]:\\n                    dp[i % 5] += dp[j % 5]\\n                else:\\n                    break    \\n            dp[i % 5] %= 10 ** 9 + 7        \\n        return dp[len(pressedKeys) % 5]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2017755,
                "title": "simple-memoization-technique-o-n",
                "content": "**Intuition:** If the pressedString is \"222\", there can 3 different keys pressed: \\'a\\'(\"2\"), \\'b\\'(\"22\") or \\'c\\'(\"222\"). So for every repeated keys, there can be multiple combinations of texts. We store the max repeatations of a particular key in keys array, and then try all recursive paths to get the count of several combinations of keys that can be formed starting from a particular index. As we try all recursive paths, so there has to be many repeated calculations, which can be mitigated by memoisation.\\n\\n```\\nCode:\\nclass Solution {\\npublic:\\n    static const int mod = 1e9+7;\\n    int dp[100001];\\n    static constexpr int keys[10] = {0,0,3,3,3,3,3,4,3,4};  // key \\'1\\' and \\'0\\' not to be used\\n    int countTexts(string pressedKeys) {\\n        memset(dp, -1, sizeof(dp));\\n        return getCounts(pressedKeys, 0);\\n    }\\n    \\n    int getCounts(string &pressed, int idx) {\\n        if(idx == pressed.length())\\n            return 1;\\n        if(dp[idx] != -1)\\n            return dp[idx];\\n        int digit = pressed[idx]-\\'0\\'; long counts = 0;\\n        for(int i = 0; i < keys[digit] && idx+i < pressed.length() && pressed[idx] == pressed[idx+i]; i++) {\\n            counts += getCounts(pressed, idx+i+1);\\n            counts %= mod;\\n        }\\n        return dp[idx] = counts;\\n    }\\n};\\n```\\nKindly upvote if helpful to keep me motivated ^-^. Also comment down for any doubts.\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nCode:\\nclass Solution {\\npublic:\\n    static const int mod = 1e9+7;\\n    int dp[100001];\\n    static constexpr int keys[10] = {0,0,3,3,3,3,3,4,3,4};  // key \\'1\\' and \\'0\\' not to be used\\n    int countTexts(string pressedKeys) {\\n        memset(dp, -1, sizeof(dp));\\n        return getCounts(pressedKeys, 0);\\n    }\\n    \\n    int getCounts(string &pressed, int idx) {\\n        if(idx == pressed.length())\\n            return 1;\\n        if(dp[idx] != -1)\\n            return dp[idx];\\n        int digit = pressed[idx]-\\'0\\'; long counts = 0;\\n        for(int i = 0; i < keys[digit] && idx+i < pressed.length() && pressed[idx] == pressed[idx+i]; i++) {\\n            counts += getCounts(pressed, idx+i+1);\\n            counts %= mod;\\n        }\\n        return dp[idx] = counts;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017730,
                "title": "cpp-short-and-simple-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int func(string &s,int i,int n,vector<int> &dp){\\n        if(i>=n)return 1;\\n        if(dp[i]!=-1)return dp[i];\\n        int ans=0;\\n        if(i+1<n && s[i]==s[i+1]){\\n            ans+=func(s,i+2,n,dp);\\n            ans=ans%mod;\\n            if(i+2<n && s[i]==s[i+2]){\\n                ans+=func(s,i+3,n,dp);\\n                ans=ans%mod;\\n                if(i+3<n && s[i]==s[i+3] && (s[i]==\\'9\\' || s[i]==\\'7\\'))ans+=func(s,i+4,n,dp);\\n                ans=ans%mod;\\n            }\\n        }\\n        ans+=func(s,i+1,n,dp);\\n        ans=ans%mod;\\n        return dp[i]=ans;\\n    }\\n    int countTexts(string s) {\\n        int n=s.length();\\n        vector<int> dp(n+1,-1);\\n        return func(s,0,n,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int func(string &s,int i,int n,vector<int> &dp){\\n        if(i>=n)return 1;\\n        if(dp[i]!=-1)return dp[i];\\n        int ans=0;\\n        if(i+1<n && s[i]==s[i+1]){\\n            ans+=func(s,i+2,n,dp);\\n            ans=ans%mod;\\n            if(i+2<n && s[i]==s[i+2]){\\n                ans+=func(s,i+3,n,dp);\\n                ans=ans%mod;\\n                if(i+3<n && s[i]==s[i+3] && (s[i]==\\'9\\' || s[i]==\\'7\\'))ans+=func(s,i+4,n,dp);\\n                ans=ans%mod;\\n            }\\n        }\\n        ans+=func(s,i+1,n,dp);\\n        ans=ans%mod;\\n        return dp[i]=ans;\\n    }\\n    int countTexts(string s) {\\n        int n=s.length();\\n        vector<int> dp(n+1,-1);\\n        return func(s,0,n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018250,
                "title": "c-solution-dp-bottom-up-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int countTexts(string s) {\\n        int n = s.size();\\n        int mod = 1e9 + 7;\\n        vector<int> dp(n + 1);\\n        dp[0] = 1;\\n        for (int i = 0; i < n; i++)\\n        {\\n            dp[i + 1] = dp[i];\\n            if (i > 0 and s[i] == s[i - 1])\\n            {\\n                dp[i + 1] = (dp[i + 1] + dp[i - 1]) % mod;\\n                if (i > 1 and s[i] == s[i - 2])\\n                {\\n                    dp[i + 1] = (dp[i + 1] + dp[i - 2]) % mod;\\n                    if (i > 2 and s[i] == s[i - 3] and (s[i] == \\'7\\' or s[i] == \\'9\\'))\\n                        dp[i + 1] = (dp[i + 1] + dp[i - 3]) % mod;\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countTexts(string s) {\\n        int n = s.size();\\n        int mod = 1e9 + 7;\\n        vector<int> dp(n + 1);\\n        dp[0] = 1;\\n        for (int i = 0; i < n; i++)\\n        {\\n            dp[i + 1] = dp[i];\\n            if (i > 0 and s[i] == s[i - 1])\\n            {\\n                dp[i + 1] = (dp[i + 1] + dp[i - 1]) % mod;\\n                if (i > 1 and s[i] == s[i - 2])\\n                {\\n                    dp[i + 1] = (dp[i + 1] + dp[i - 2]) % mod;\\n                    if (i > 2 and s[i] == s[i - 3] and (s[i] == \\'7\\' or s[i] == \\'9\\'))\\n                        dp[i + 1] = (dp[i + 1] + dp[i - 3]) % mod;\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2021877,
                "title": "c-dp-solution-o-n",
                "content": "Runtime: 32 ms, faster than 100.00% of C++ online submissions for Count Number of Texts.\\nMemory Usage: 19.3 MB, less than 40.00% of C++ online submissions for Count Number of Texts.\\n\\n\\n```\\nWe can calculate the letter combination count of each digit type for different length using DP.\\n\\nLetter combinations for digit 2,3,4,5,6,8 is same for length  1 to N as they all have 3 letters in their button\\n\\nBase case combinations: Length 1 to 3\\n\\nLength 1 => [2] => \\'a\\' => 1\\nLength 2 => [2,2] => \\'aa\\', \\'b\\' => 2\\nLength 3 =>  [2,2,2] => \\'aaa\\', \\'ab\\', \\'ba\\', \\'c\\' => 4\\n\\nNow for Length > 3 we can get combination count from previous length combinations\\nLength 4 => [2,2,2,2] => \\'aaaa\\', \\'aab\\', \\'aba\\', \\'ac\\' , \\'baa\\' , \\'bb\\', \\'ca\\'  => 7\\n\\nLet first letter as \\'a\\', which has length 1 => [2]\\nThen total letter combination of length 4 with first letter \\'a\\' is DP[4-1] = DP[3] =>  \\'aaaa\\', \\'aab\\', \\'aba\\', \\'ac\\' => 4\\n\\nLet first letter as \\'b\\', which has length 2 => [2,2]\\nThen total letter combination of length 4 with first letter \\'b\\' is DP[4-2] = DP[2] =>  \\'baa\\' , \\'bb\\' => 2\\n\\nLet first letter as \\'c\\', which has length 3 => [2,2,2]\\nThen total letter combination of length 4 with first letter \\'c\\' is DP[4-3] = DP[1] =>  \\'ca\\' => 1\\n\\nSo, total letter combination of Length 4 => DP[4-1] + DP[4-2] + DP[4-3] = 4 + 2 + 1 = 7 \\n\\nDP equation: DP[N] => DP[N-1] + DP[N-2] + DP[N-3]\\n\\nLetter combinations for digit 7 and 9 is same for length  0 to N as they all have 4 letters in their button\\n\\nBase case combinations: Length 1 to 4\\n\\nLength 1 => [7] => \\'p\\' => 1\\nLength 2 => [7,7] => \\'pp\\' or \\'q\\' => 2\\nLength 3 =>  [7,7,7] => \\'ppp\\', \\'pq\\', \\'qp\\', \\'r\\' => 4\\nLength 4 => [7,7,7,7] => \\'pppp\\', \\'ppq\\', \\'pqp\\', \\'pr\\', \\'qq\\', \\'qpp\\', \\'rp\\', \\'s\\' => 8\\n\\nSimilary as above, DP equation: DP[N] => DP[N-1] + DP[N-2] + DP[N-3] + DP[N-4]\\n\\nFirst we get the max frequency of each digit and their frequency chunks.\\nThen we generate letter combinations for 0 to max frequency of each digit in DP\\nThen we multiply the DP[X] of frequency chunks X of each digit as their letter combinations are independent.\\n```\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int countTexts(string pressed) {\\n        \\n        int MOD = 1000000007;\\n        int pl = pressed.length();\\n        \\n        // base case combinations for 2-9 digits of length 0 to 4\\n        vector<vector<int>>preDP = {{0,1,2,4},{0,1,2,4,8}};\\n            \\n        // store max freq of each digit and freq chunks\\n        int maxFreq[10] = {};\\n        vector<int>freq[10];\\n        \\n        int curr = -1;\\n        int count = 0;\\n        \\n        for(int i=0;i<pl;i++)\\n        {\\n            if(pressed[i]-\\'0\\' == curr)\\n            {\\n                count++;\\n                maxFreq[curr] = max(maxFreq[curr],count);\\n                freq[curr].back()++;\\n            }\\n            else\\n            {\\n                curr = pressed[i]-\\'0\\';\\n                count = 1;\\n                maxFreq[curr] = max(maxFreq[curr],count);\\n                freq[curr].push_back(count);\\n            }\\n        }\\n        \\n        vector<long long>dp(pl+1);\\n        unsigned long long totalCount = 1L;\\n        int type;\\n        for(int i=0;i<10;i++)\\n        {\\n            if(maxFreq[i]==0)continue;\\n            \\n            // get digit type\\n            type = (i==7 || i==9) ? 1 : 0;\\n            \\n            // store the base case combinations for length 0 to 4\\n            for(int j=0;j<=maxFreq[i] && j<=3+type;j++)\\n                dp[j] = preDP[type][j];\\n            \\n            // store combinations for length 5 to max freq of current digit \\n            for(int j=4+type;j<=maxFreq[i];j++)\\n                dp[j] = (dp[j-1]  + dp[j-2] + dp[j-3] + (type ? dp[j-4] : 0) + MOD)%MOD;\\n            \\n            // get the digit freq chunk multiplications as they are independent\\n            for(int j=0;j<freq[i].size();j++)\\n                totalCount = (totalCount%MOD * dp[freq[i][j]]%MOD) %MOD ;  \\n        }\\n        \\n        return (int)totalCount;\\n    }\\n};\\n```\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Combinatorics"
                ],
                "code": "```\\nWe can calculate the letter combination count of each digit type for different length using DP.\\n\\nLetter combinations for digit 2,3,4,5,6,8 is same for length  1 to N as they all have 3 letters in their button\\n\\nBase case combinations: Length 1 to 3\\n\\nLength 1 => [2] => \\'a\\' => 1\\nLength 2 => [2,2] => \\'aa\\', \\'b\\' => 2\\nLength 3 =>  [2,2,2] => \\'aaa\\', \\'ab\\', \\'ba\\', \\'c\\' => 4\\n\\nNow for Length > 3 we can get combination count from previous length combinations\\nLength 4 => [2,2,2,2] => \\'aaaa\\', \\'aab\\', \\'aba\\', \\'ac\\' , \\'baa\\' , \\'bb\\', \\'ca\\'  => 7\\n\\nLet first letter as \\'a\\', which has length 1 => [2]\\nThen total letter combination of length 4 with first letter \\'a\\' is DP[4-1] = DP[3] =>  \\'aaaa\\', \\'aab\\', \\'aba\\', \\'ac\\' => 4\\n\\nLet first letter as \\'b\\', which has length 2 => [2,2]\\nThen total letter combination of length 4 with first letter \\'b\\' is DP[4-2] = DP[2] =>  \\'baa\\' , \\'bb\\' => 2\\n\\nLet first letter as \\'c\\', which has length 3 => [2,2,2]\\nThen total letter combination of length 4 with first letter \\'c\\' is DP[4-3] = DP[1] =>  \\'ca\\' => 1\\n\\nSo, total letter combination of Length 4 => DP[4-1] + DP[4-2] + DP[4-3] = 4 + 2 + 1 = 7 \\n\\nDP equation: DP[N] => DP[N-1] + DP[N-2] + DP[N-3]\\n\\nLetter combinations for digit 7 and 9 is same for length  0 to N as they all have 4 letters in their button\\n\\nBase case combinations: Length 1 to 4\\n\\nLength 1 => [7] => \\'p\\' => 1\\nLength 2 => [7,7] => \\'pp\\' or \\'q\\' => 2\\nLength 3 =>  [7,7,7] => \\'ppp\\', \\'pq\\', \\'qp\\', \\'r\\' => 4\\nLength 4 => [7,7,7,7] => \\'pppp\\', \\'ppq\\', \\'pqp\\', \\'pr\\', \\'qq\\', \\'qpp\\', \\'rp\\', \\'s\\' => 8\\n\\nSimilary as above, DP equation: DP[N] => DP[N-1] + DP[N-2] + DP[N-3] + DP[N-4]\\n\\nFirst we get the max frequency of each digit and their frequency chunks.\\nThen we generate letter combinations for 0 to max frequency of each digit in DP\\nThen we multiply the DP[X] of frequency chunks X of each digit as their letter combinations are independent.\\n```\n```\\nclass Solution {\\npublic:\\n    int countTexts(string pressed) {\\n        \\n        int MOD = 1000000007;\\n        int pl = pressed.length();\\n        \\n        // base case combinations for 2-9 digits of length 0 to 4\\n        vector<vector<int>>preDP = {{0,1,2,4},{0,1,2,4,8}};\\n            \\n        // store max freq of each digit and freq chunks\\n        int maxFreq[10] = {};\\n        vector<int>freq[10];\\n        \\n        int curr = -1;\\n        int count = 0;\\n        \\n        for(int i=0;i<pl;i++)\\n        {\\n            if(pressed[i]-\\'0\\' == curr)\\n            {\\n                count++;\\n                maxFreq[curr] = max(maxFreq[curr],count);\\n                freq[curr].back()++;\\n            }\\n            else\\n            {\\n                curr = pressed[i]-\\'0\\';\\n                count = 1;\\n                maxFreq[curr] = max(maxFreq[curr],count);\\n                freq[curr].push_back(count);\\n            }\\n        }\\n        \\n        vector<long long>dp(pl+1);\\n        unsigned long long totalCount = 1L;\\n        int type;\\n        for(int i=0;i<10;i++)\\n        {\\n            if(maxFreq[i]==0)continue;\\n            \\n            // get digit type\\n            type = (i==7 || i==9) ? 1 : 0;\\n            \\n            // store the base case combinations for length 0 to 4\\n            for(int j=0;j<=maxFreq[i] && j<=3+type;j++)\\n                dp[j] = preDP[type][j];\\n            \\n            // store combinations for length 5 to max freq of current digit \\n            for(int j=4+type;j<=maxFreq[i];j++)\\n                dp[j] = (dp[j-1]  + dp[j-2] + dp[j-3] + (type ? dp[j-4] : 0) + MOD)%MOD;\\n            \\n            // get the digit freq chunk multiplications as they are independent\\n            for(int j=0;j<freq[i].size();j++)\\n                totalCount = (totalCount%MOD * dp[freq[i][j]]%MOD) %MOD ;  \\n        }\\n        \\n        return (int)totalCount;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2021692,
                "title": "c-dp-o-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int M=1e9+7;\\n    int countTexts(string s) {\\n        int n=s.size();\\n        vector<long long> dp(n+1);\\n        dp[0]=1;\\n        for(int i=1;i<=n;i++){\\n            //firstly if character is same or different then copy last value.\\n            dp[i]=dp[i-1];\\n            //if last two characters are same then also last that value.\\n            if((i-2)>=0 && s[i-1]==s[i-2])\\n                dp[i]=(dp[i]+dp[i-2])%M;\\n            else\\n                continue;\\n            //if last 3 characters are same then also add that value.\\n            if((i-3)>=0 && s[i-1]==s[i-3])\\n                dp[i]=(dp[i]+dp[i-3])%M;\\n            else\\n                continue;\\n            //if we have 7 or 9 as characters we have to also check for 4th character.\\n            if((s[i-1]==\\'7\\' || s[i-1]==\\'9\\') && (i-4)>=0 && s[i-1]==s[i-4])\\n                dp[i]=(dp[i]+dp[i-4])%M;\\n        }\\n        return dp[n]%M;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int M=1e9+7;\\n    int countTexts(string s) {\\n        int n=s.size();\\n        vector<long long> dp(n+1);\\n        dp[0]=1;\\n        for(int i=1;i<=n;i++){\\n            //firstly if character is same or different then copy last value.\\n            dp[i]=dp[i-1];\\n            //if last two characters are same then also last that value.\\n            if((i-2)>=0 && s[i-1]==s[i-2])\\n                dp[i]=(dp[i]+dp[i-2])%M;\\n            else\\n                continue;\\n            //if last 3 characters are same then also add that value.\\n            if((i-3)>=0 && s[i-1]==s[i-3])\\n                dp[i]=(dp[i]+dp[i-3])%M;\\n            else\\n                continue;\\n            //if we have 7 or 9 as characters we have to also check for 4th character.\\n            if((s[i-1]==\\'7\\' || s[i-1]==\\'9\\') && (i-4)>=0 && s[i-1]==s[i-4])\\n                dp[i]=(dp[i]+dp[i-4])%M;\\n        }\\n        return dp[n]%M;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2019195,
                "title": "easy-memoization-o-n-time-c-with-explanation-with-comments",
                "content": "The simplest way to cache sub problems is to break this problem to :\\ntotal ways=No of ways to have one alphabet * number of ways of rest of the string.\\nWe dont have length of rest of the remaining string constant...like 6+rest, 66+rest\\' map to \\'m\\'+rest  and \\'n\\'+rest\\' respectively.\\nSo we iterate  ```No of ways to to have one alphabet```  and add  ``` number of ways of rest of the string```   in each iteration.\\n```\\nclass Solution {\\npublic:\\n    const int M=1000000007;\\n    vector<int>dp;\\n    int count(string &s,int i)\\n    {\\n        if(i==s.size())return 1;\\n        if(dp[i]!=-1)return dp[i];\\n        int no=3;//number of characters in the button\\n        if(s[i]==\\'7\\'||s[i]==\\'9\\')no=4;\\n        int ans=0,len=0;\\n        for(int j=i;j<i+no&&j<s.size();j++) //looping over possible alphabets out of the consecutively same  button press.\\n        {\\n            if(s[j]==s[i])ans=(ans+count(s,j+1))%M;//adding number of ways to have the rest of the string\\n                else break;\\n        }\\n        return dp[i]=ans;\\n        \\n    }\\n    int countTexts(string s) {\\n        dp.resize(s.size(),-1);\\n        return count(s,0);\\n    }\\n};\\n```\\nPlease upvote if you find the solution helping.",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```No of ways to to have one alphabet```\n``` number of ways of rest of the string```\n```\\nclass Solution {\\npublic:\\n    const int M=1000000007;\\n    vector<int>dp;\\n    int count(string &s,int i)\\n    {\\n        if(i==s.size())return 1;\\n        if(dp[i]!=-1)return dp[i];\\n        int no=3;//number of characters in the button\\n        if(s[i]==\\'7\\'||s[i]==\\'9\\')no=4;\\n        int ans=0,len=0;\\n        for(int j=i;j<i+no&&j<s.size();j++) //looping over possible alphabets out of the consecutively same  button press.\\n        {\\n            if(s[j]==s[i])ans=(ans+count(s,j+1))%M;//adding number of ways to have the rest of the string\\n                else break;\\n        }\\n        return dp[i]=ans;\\n        \\n    }\\n    int countTexts(string s) {\\n        dp.resize(s.size(),-1);\\n        return count(s,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018536,
                "title": "c-for-everyone-who-are-scared-of-dp-like-me",
                "content": "* So I experimented with `2`, `22`, `222` and realised that for `2222` the answer is the sum of previous 3 and this goes on.\\n* Now after doing this I was stuck thinking all the numbers have 3 letters but for `7` and `9`, the story is different since they have 4 letters.\\n* So I experimented **again** with `9`, `99`, `999`, `9999` and realised that for `99999` the answer is the sum of previous 4 and this goes on.\\n* And Boom **AC**.\\n\\n`//Experiment part`\\nWhy we do `dp[n] = dp[n-1] + dp[n-2] + dp[n-3]` ?\\nBecause we have 3 options,\\nLets take example of `22222`.\\n\\n`22222` = `2|2222` + `22|222` + `222|22`.\\nBasically we select the first (1-3) numbers and rest are already calculated.\\n**Note:** we can\\'t have a combination like this `2222|2` since four 2\\'s don\\'t make any combination(in case of 2 but in case of 7 and 9 its does and therefore the summation goes till `dp[n-4]` there).\\n\\n```\\nconst int mod = 1e9 + 7;\\nconst int mxx = 1e5 + 1;\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<int> a, b;\\n    \\n    Solution()\\n    {\\n        a.resize(mxx, 0);\\n        a[1] = 1;\\n        a[2] = 2;\\n        a[3] = 4;\\n        \\n        for(int i=4; i<=1e5; i++)\\n        {\\n            a[i] = ((a[i-1] + a[i-2]) % mod + a[i-3]) % mod;\\n        }\\n        \\n        b.resize(mxx, 0);\\n        b[1] = 1;\\n        b[2] = 2;\\n        b[3] = 4;\\n        b[4] = 8;\\n        \\n        for(int i=5; i<=1e5; i++)\\n        {\\n            b[i] = ((((b[i-1] + b[i-2]) % mod + b[i-3]) % mod) + b[i-4]) % mod;\\n        }\\n    }\\n    \\n    int countTexts(string s) {\\n        int n = s.size();\\n        int ans = 1;\\n        \\n        int cnt = 1;\\n        int i = 0;\\n        while(i+1 < n)\\n        {\\n            while(i+1 < n && s[i] == s[i+1]) \\n            {\\n                cnt++;\\n                i++;\\n            }\\n            // cout << a[cnt] << \" \";\\n            if(s[i] != \\'7\\' && s[i] != \\'9\\')\\n                ans = ((ll)ans * (ll)a[cnt]) % mod;\\n            else\\n                ans = ((ll)ans * (ll)b[cnt]) % mod;\\n            \\n            cnt = 1;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nActually the `experimented` part is something which is really hard for me explain. Do some experiment on your own and maybe it will click.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nconst int mod = 1e9 + 7;\\nconst int mxx = 1e5 + 1;\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<int> a, b;\\n    \\n    Solution()\\n    {\\n        a.resize(mxx, 0);\\n        a[1] = 1;\\n        a[2] = 2;\\n        a[3] = 4;\\n        \\n        for(int i=4; i<=1e5; i++)\\n        {\\n            a[i] = ((a[i-1] + a[i-2]) % mod + a[i-3]) % mod;\\n        }\\n        \\n        b.resize(mxx, 0);\\n        b[1] = 1;\\n        b[2] = 2;\\n        b[3] = 4;\\n        b[4] = 8;\\n        \\n        for(int i=5; i<=1e5; i++)\\n        {\\n            b[i] = ((((b[i-1] + b[i-2]) % mod + b[i-3]) % mod) + b[i-4]) % mod;\\n        }\\n    }\\n    \\n    int countTexts(string s) {\\n        int n = s.size();\\n        int ans = 1;\\n        \\n        int cnt = 1;\\n        int i = 0;\\n        while(i+1 < n)\\n        {\\n            while(i+1 < n && s[i] == s[i+1]) \\n            {\\n                cnt++;\\n                i++;\\n            }\\n            // cout << a[cnt] << \" \";\\n            if(s[i] != \\'7\\' && s[i] != \\'9\\')\\n                ans = ((ll)ans * (ll)a[cnt]) % mod;\\n            else\\n                ans = ((ll)ans * (ll)b[cnt]) % mod;\\n            \\n            cnt = 1;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2017834,
                "title": "python3-group-by-group",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/9aa0edb0815f3e0a75a47808e1690ca424f169e5) for solutions of weekly 292. \\n\\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        MOD = 1_000_000_007 \\n        \\n        @cache \\n        def fn(n, k): \\n            \"\"\"Return number of possible text of n repeated k times.\"\"\"\\n            if n < 0: return 0\\n            if n == 0: return 1\\n            ans = 0\\n            for x in range(1, k+1): ans = (ans + fn(n-x, k)) % MOD\\n            return ans \\n        \\n        ans = 1\\n        for key, grp in groupby(pressedKeys): \\n            if key in \"79\": k = 4\\n            else: k = 3\\n            ans = (ans * fn(len(list(grp)), k)) % MOD \\n        return ans \\n```\\n\\nAdded a shorter implementation \\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        dp = [0] * (len(pressedKeys)+1)\\n        dp[0] = 1\\n        for i, ch in enumerate(pressedKeys):\\n            dp[i+1] = dp[i]\\n            if i and pressedKeys[i-1] == ch: \\n                dp[i+1] += dp[i-1]\\n                if i >= 2 and pressedKeys[i-2] == ch: \\n                    dp[i+1] += dp[i-2]\\n                    if i >= 3 and pressedKeys[i-3] == ch and ch in \"79\": dp[i+1] += dp[i-3]\\n            dp[i+1] %= 1_000_000_007\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        MOD = 1_000_000_007 \\n        \\n        @cache \\n        def fn(n, k): \\n            \"\"\"Return number of possible text of n repeated k times.\"\"\"\\n            if n < 0: return 0\\n            if n == 0: return 1\\n            ans = 0\\n            for x in range(1, k+1): ans = (ans + fn(n-x, k)) % MOD\\n            return ans \\n        \\n        ans = 1\\n        for key, grp in groupby(pressedKeys): \\n            if key in \"79\": k = 4\\n            else: k = 3\\n            ans = (ans * fn(len(list(grp)), k)) % MOD \\n        return ans \\n```\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        dp = [0] * (len(pressedKeys)+1)\\n        dp[0] = 1\\n        for i, ch in enumerate(pressedKeys):\\n            dp[i+1] = dp[i]\\n            if i and pressedKeys[i-1] == ch: \\n                dp[i+1] += dp[i-1]\\n                if i >= 2 and pressedKeys[i-2] == ch: \\n                    dp[i+1] += dp[i-2]\\n                    if i >= 3 and pressedKeys[i-3] == ch and ch in \"79\": dp[i+1] += dp[i-3]\\n            dp[i+1] %= 1_000_000_007\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018347,
                "title": "python-top-down-dp-time-o-4-n-easy-understanding",
                "content": "The result is solely impacted by the following four digits at index i.\\nNote that using MOD everywhere can save you a lot of time!\\n\\nTime: O(4*n)\\n\\n``` py\\nclass Solution:\\n    def countTexts(self, A: str) -> int:\\n        mp = set([\"2\", \"22\", \"222\",\\n                  \"3\", \"33\", \"333\",\\n                  \\'4\\', \\'44\\', \\'444\\',\\n                  \\'5\\', \\'55\\', \\'555\\',\\n                  \\'6\\', \\'66\\', \\'666\\',\\n                  \\'7\\', \\'77\\', \\'777\\', \\'7777\\', \\n                  \\'8\\', \\'88\\', \\'888\\', \\n                  \\'9\\', \\'99\\', \\'999\\', \\'9999\\'])\\n        MOD = 10**9+7\\n        \\n        @cache\\n        def dp(i):\\n            if i>=len(A): return 1\\n            ans = 0\\n            if i+1<=len(A) and A[i:i+1] in mp: ans += dp(i+1)%MOD\\n            if i+2<=len(A) and A[i:i+2] in mp: ans += dp(i+2)%MOD\\n            if i+3<=len(A) and A[i:i+3] in mp: ans += dp(i+3)%MOD\\n            if i+4<=len(A) and A[i:i+4] in mp: ans += dp(i+4)%MOD\\n            return ans%MOD\\n        \\n        return dp(0)%MOD\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "``` py\\nclass Solution:\\n    def countTexts(self, A: str) -> int:\\n        mp = set([\"2\", \"22\", \"222\",\\n                  \"3\", \"33\", \"333\",\\n                  \\'4\\', \\'44\\', \\'444\\',\\n                  \\'5\\', \\'55\\', \\'555\\',\\n                  \\'6\\', \\'66\\', \\'666\\',\\n                  \\'7\\', \\'77\\', \\'777\\', \\'7777\\', \\n                  \\'8\\', \\'88\\', \\'888\\', \\n                  \\'9\\', \\'99\\', \\'999\\', \\'9999\\'])\\n        MOD = 10**9+7\\n        \\n        @cache\\n        def dp(i):\\n            if i>=len(A): return 1\\n            ans = 0\\n            if i+1<=len(A) and A[i:i+1] in mp: ans += dp(i+1)%MOD\\n            if i+2<=len(A) and A[i:i+2] in mp: ans += dp(i+2)%MOD\\n            if i+3<=len(A) and A[i:i+3] in mp: ans += dp(i+3)%MOD\\n            if i+4<=len(A) and A[i:i+4] in mp: ans += dp(i+4)%MOD\\n            return ans%MOD\\n        \\n        return dp(0)%MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3786290,
                "title": "recursion-memoization-c-with-explanation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**If a substring contains the same characters (\\'22...\\', \\'9999......\\', \\'5555......\\',..............) How many text are possible by this substring**................................\\uD83E\\uDD14\\n\\n**Think about the above statement and try to write the code...........**\\n\\nhere the approach is simple that we are counting the possible text for a substring that has the same characters and multiplying all the results to get all the possible text.\\n\\n\\n```\\nFor example:- p = \\'222544\\'\\nsubstring with same characters = \\'222\\', \\'5\\', \\'44\\'\\n\\'222\\' Possible texts:- \\'a\\', \\'ba\\', \\'ab\\', \\'c\\'(4)\\n\\'5\\' Possible texts:- \\'j\\'(1)\\n\\'44\\' Possible texts:- \\'gg\\',\\'h\\'(2)\\n\\nNumber of all possible texts = 4 * 1 * 2 = 8\\n```\\n**Note:-**\\nHere you can see that after enumerating the possible text for a substring I removed all the entries from dp as the previous entry of the same character became invalid so I did that.\\n\\n```\\nFor example:- p = \\'222322\\'\\nHere we can see that \\'2\\' appears in two substrings:-\\n          str1 = \\'222\\' and str2 = \\'22\\'\\n\\nWhen enumerating possible text for str-2, all previous entries\\nstr-1 became invalid so we need to remove them.\\n```\\n# Complexity\\n- Time complexity:O(N*log(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    map<pair<int,char>,int> dp;\\n    int mod = 1e9+7;\\n    long long solve(char c,long long n,long long i)\\n    {\\n        if(i>n) return 0;\\n        if(i>=n-1) return 1;\\n        if(dp.find({i,c})!=dp.end()) return dp[{i,c}];\\n        long long c1 = solve(c,n,i+1);\\n        long long c2 = solve(c,n,i+2);\\n        long long c3 = solve(c,n,i+3);\\n        long long c4 = solve(c,n,i+4);\\n\\n        if(c==\\'7\\' || c==\\'9\\')\\n        return dp[{i,c}] = (c1+c2+c3+c4)%mod;\\n        \\n        return dp[{i,c}] = (c1+c2+c3)%mod;\\n    }\\n    int countTexts(string p) {\\n       long long count = 1,ans = 1;\\n       for(int i = 1;i<p.size();i++)\\n       {\\n           if(p[i]==p[i-1]) count++;\\n           if(p[i]!=p[i-1] || i==p.size()-1)\\n           {\\n               int x = solve(p[i-1],count,0)%mod;\\n               dp.clear();\\n               ans  = ((ans%mod)*(x%mod))%mod;\\n               count = 1;\\n           }\\n       }\\n       return ans%mod;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/347a58e4-fc48-4a72-a4dc-b53ecd812bfa_1689747372.1231217.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nFor example:- p = \\'222544\\'\\nsubstring with same characters = \\'222\\', \\'5\\', \\'44\\'\\n\\'222\\' Possible texts:- \\'a\\', \\'ba\\', \\'ab\\', \\'c\\'(4)\\n\\'5\\' Possible texts:- \\'j\\'(1)\\n\\'44\\' Possible texts:- \\'gg\\',\\'h\\'(2)\\n\\nNumber of all possible texts = 4 * 1 * 2 = 8\\n```\n```\\nFor example:- p = \\'222322\\'\\nHere we can see that \\'2\\' appears in two substrings:-\\n          str1 = \\'222\\' and str2 = \\'22\\'\\n\\nWhen enumerating possible text for str-2, all previous entries\\nstr-1 became invalid so we need to remove them.\\n```\n```\\nclass Solution {\\npublic:\\n    map<pair<int,char>,int> dp;\\n    int mod = 1e9+7;\\n    long long solve(char c,long long n,long long i)\\n    {\\n        if(i>n) return 0;\\n        if(i>=n-1) return 1;\\n        if(dp.find({i,c})!=dp.end()) return dp[{i,c}];\\n        long long c1 = solve(c,n,i+1);\\n        long long c2 = solve(c,n,i+2);\\n        long long c3 = solve(c,n,i+3);\\n        long long c4 = solve(c,n,i+4);\\n\\n        if(c==\\'7\\' || c==\\'9\\')\\n        return dp[{i,c}] = (c1+c2+c3+c4)%mod;\\n        \\n        return dp[{i,c}] = (c1+c2+c3)%mod;\\n    }\\n    int countTexts(string p) {\\n       long long count = 1,ans = 1;\\n       for(int i = 1;i<p.size();i++)\\n       {\\n           if(p[i]==p[i-1]) count++;\\n           if(p[i]!=p[i-1] || i==p.size()-1)\\n           {\\n               int x = solve(p[i-1],count,0)%mod;\\n               dp.clear();\\n               ans  = ((ans%mod)*(x%mod))%mod;\\n               count = 1;\\n           }\\n       }\\n       return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024229,
                "title": "c-o-n-solution-with-explanation",
                "content": "At any point you have couple of things to do and that is you can choose current character \\n\\n1. As a single character so the answer will be what was at i-1 index because you\\'re adding current character as single character \\n\\n2. Taking current character with last so i-2 will be the added to the answer\\n3. Taking till i-2 character so i-3 will be added to answer\\n4. In case of 7, 9 Taking i-3 character so i-4 will be added to the answer\\n\\nHere is an example to that\\n\\nsuppose we have 222\\n\\nfor i = 0 we can only get \\na\\n\\nfor i = 1 we can get\\naa b\\n\\nfor i = 2 we can get\\n\\n(First taking current character as single)\\naa-a (2-2-2)\\nb-a (22-2)\\n\\n(Taking current with last)\\na-b (2-22)\\n\\nTaking till i-2\\nc (222)\\n\\nIn the solution we\\'ll first calculate the combinations\\n\\n\\n```\\n#define mod 1000000007\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int countTexts(string s) {\\n        \\n        int n = s.size();\\n        \\n        if(n<3){\\n            return n;\\n        }\\n        \\n        ll ans = 1;\\n        vector<ll> dp1(n+1,0);\\n        vector<ll> dp2(n+1,0);\\n        \\n        dp1[0] = 1;\\n        dp1[1] = 1;\\n        dp1[2] = 2;\\n        \\n        dp2[0] = 1;\\n        dp2[1] = 1;\\n        dp2[2] = 2;\\n        dp2[3] = 4;\\n        \\n        for(int i = 3 ; i <= n ; i++)    \\n            dp1[i] = (dp1[i-1] + dp1[i-2] + dp1[i-3])%mod;\\n        \\n        for(int i = 4 ; i <= n ; i++)    //for 7 & 9\\n            dp2[i] = (dp2[i-1] + dp2[i-2] + dp2[i-3] + dp2[i-4])%mod;\\n        \\n        int i = 0;\\n        \\n        int start = -1;\\n        \\n        while(i<n-1){\\n            \\n            while(i<n-1 && s[i]==s[i+1])//finding the length same consecutive characters\\n                i++;\\n            \\n            int len = i-start;\\n            \\n            if(s[i]==\\'7\\' || s[i]==\\'9\\')\\n                ans = (ans*dp2[len])%mod; //multiplying because for 2 different consecutive characters we can\\'t add for ex if at first place we have 2 options and for place two also 2 option then if we combine we\\'ll have 4 options in total for better understanding see example 1 of the question\\n            else\\n                ans = (ans*dp1[len])%mod;\\n            \\n            start = i;\\n            \\n            i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define mod 1000000007\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int countTexts(string s) {\\n        \\n        int n = s.size();\\n        \\n        if(n<3){\\n            return n;\\n        }\\n        \\n        ll ans = 1;\\n        vector<ll> dp1(n+1,0);\\n        vector<ll> dp2(n+1,0);\\n        \\n        dp1[0] = 1;\\n        dp1[1] = 1;\\n        dp1[2] = 2;\\n        \\n        dp2[0] = 1;\\n        dp2[1] = 1;\\n        dp2[2] = 2;\\n        dp2[3] = 4;\\n        \\n        for(int i = 3 ; i <= n ; i++)    \\n            dp1[i] = (dp1[i-1] + dp1[i-2] + dp1[i-3])%mod;\\n        \\n        for(int i = 4 ; i <= n ; i++)    //for 7 & 9\\n            dp2[i] = (dp2[i-1] + dp2[i-2] + dp2[i-3] + dp2[i-4])%mod;\\n        \\n        int i = 0;\\n        \\n        int start = -1;\\n        \\n        while(i<n-1){\\n            \\n            while(i<n-1 && s[i]==s[i+1])//finding the length same consecutive characters\\n                i++;\\n            \\n            int len = i-start;\\n            \\n            if(s[i]==\\'7\\' || s[i]==\\'9\\')\\n                ans = (ans*dp2[len])%mod; //multiplying because for 2 different consecutive characters we can\\'t add for ex if at first place we have 2 options and for place two also 2 option then if we combine we\\'ll have 4 options in total for better understanding see example 1 of the question\\n            else\\n                ans = (ans*dp1[len])%mod;\\n            \\n            start = i;\\n            \\n            i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2374298,
                "title": "python-sliding-window-o-1-space",
                "content": "```\\nfrom collections import deque\\n\\n\\nclass Solution:\\n    \\n    def countTexts(self, pressed_keys: str) -> int:\\n        \\n        key_letters = {\\n            \"2\": 3,\\n            \"3\": 3,\\n            \"4\": 3,\\n            \"5\": 3,\\n            \"6\": 3,\\n            \"7\": 4,\\n            \"8\": 3,\\n            \"9\": 4,\\n        }\\n        \\n        ans = 1\\n        current_count = 1\\n        prev_key = \"\" \\n        previous = deque([]) \\n        \\n        for pressed_key in pressed_keys:\\n            \\n            if pressed_key != prev_key:\\n                ans = (ans * current_count) % (10**9 + 7)\\n                previous = deque([1])\\n                current_count = 1 \\n                prev_key = pressed_key\\n            \\n            current_count = sum(previous) \\n            \\n            if len(previous) == key_letters[pressed_key]:\\n                previous.popleft()\\n                \\n            previous.append(current_count)\\n             \\n        ans = (ans * current_count) % (10**9 + 7)\\n        \\n        return ans\\n    \\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\n\\n\\nclass Solution:\\n    \\n    def countTexts(self, pressed_keys: str) -> int:\\n        \\n        key_letters = {\\n            \"2\": 3,\\n            \"3\": 3,\\n            \"4\": 3,\\n            \"5\": 3,\\n            \"6\": 3,\\n            \"7\": 4,\\n            \"8\": 3,\\n            \"9\": 4,\\n        }\\n        \\n        ans = 1\\n        current_count = 1\\n        prev_key = \"\" \\n        previous = deque([]) \\n        \\n        for pressed_key in pressed_keys:\\n            \\n            if pressed_key != prev_key:\\n                ans = (ans * current_count) % (10**9 + 7)\\n                previous = deque([1])\\n                current_count = 1 \\n                prev_key = pressed_key\\n            \\n            current_count = sum(previous) \\n            \\n            if len(previous) == key_letters[pressed_key]:\\n                previous.popleft()\\n                \\n            previous.append(current_count)\\n             \\n        ans = (ans * current_count) % (10**9 + 7)\\n        \\n        return ans\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2126835,
                "title": "javascript-solution-dp",
                "content": "```\\nvar countTexts = function(pressedKeys) {\\n    const MOD = 1e9 + 7;\\n    const n = pressedKeys.length;\\n    const dp = new Array(n + 1).fill(0);\\n    \\n    dp[0] = 1;\\n    \\n    let lastChar = \"\";\\n    let repeatCount = 0;\\n    \\n    for (let i = 1; i <= n; ++i) {\\n        const currChar = pressedKeys[i - 1];\\n        \\n        if (currChar != lastChar) repeatCount = 0;\\n        \\n        lastChar = currChar;\\n        repeatCount += 1;\\n        \\n        dp[i] = (dp[i] + dp[i - 1]) % MOD;\\n        \\n        if (i >= 2 && repeatCount >= 2) dp[i] = (dp[i] + dp[i - 2]) % MOD;\\n        if (i >= 3 && repeatCount >= 3) dp[i] = (dp[i] + dp[i - 3]) % MOD;\\n        if ((currChar == \"7\"  || currChar == \"9\") && i >= 4 && repeatCount >= 4) dp[i] = (dp[i] + dp[i - 4]) % MOD;\\n     }\\n    \\n    return dp[n];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar countTexts = function(pressedKeys) {\\n    const MOD = 1e9 + 7;\\n    const n = pressedKeys.length;\\n    const dp = new Array(n + 1).fill(0);\\n    \\n    dp[0] = 1;\\n    \\n    let lastChar = \"\";\\n    let repeatCount = 0;\\n    \\n    for (let i = 1; i <= n; ++i) {\\n        const currChar = pressedKeys[i - 1];\\n        \\n        if (currChar != lastChar) repeatCount = 0;\\n        \\n        lastChar = currChar;\\n        repeatCount += 1;\\n        \\n        dp[i] = (dp[i] + dp[i - 1]) % MOD;\\n        \\n        if (i >= 2 && repeatCount >= 2) dp[i] = (dp[i] + dp[i - 2]) % MOD;\\n        if (i >= 3 && repeatCount >= 3) dp[i] = (dp[i] + dp[i - 3]) % MOD;\\n        if ((currChar == \"7\"  || currChar == \"9\") && i >= 4 && repeatCount >= 4) dp[i] = (dp[i] + dp[i - 4]) % MOD;\\n     }\\n    \\n    return dp[n];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2020148,
                "title": "10-line-dp-python-o-n-o-1-beat-100-100-a-easy-bottom-up",
                "content": "```\\nclass Solution(object):\\n    def countTexts(self, keys):\\n        dic = {\\'2\\': 3, \\'3\\': 3, \\'4\\':3, \\'5\\':3, \\'6\\':3, \\'7\\':4, \\'8\\': 3, \\'9\\':4 } # dictionary!\\n        \\n        # e.g  dp means all possibilities ending now. 4 status totaly dp2 means we quickly press same num for 2 times. (33)-->e\\n        dp1, dp2, dp3, dp4 = 1, 0, 0, 0   # assuming we passed first key, dp1 is 1\\n\\t\\t\\n        for i in range(1, len(keys)):\\n            if keys[i] == keys[i-1]: # if same with before, this is how we inherit\\n                dp1, dp2, dp3, dp4 = (dp1 + dp2 + dp3 + dp4) % (10**9+7), dp1, dp2, 0 if dic[keys[i]] == 3 else dp3\\n            else: # and when not same, this is how we inherit\\n                dp1, dp2, dp3, dp4 = (dp1 + dp2 + dp3 + dp4) % (10**9+7), 0, 0, 0\\n\\t\\t\\t\\t\\n        return (dp1 + dp2 + dp3 + dp4) % (10**9+7)\\n\\t\\t\\n\\t\\t\\nActually the status is pretty clear. There are 3-4 status when ending at each index among the keys, and status transfer is also clear to see. \\n```\\n\\n\\n\\n\\n```\\n#Also here\\'s top-down dp ( = dfs + memo). Same time complexity, O(N) space. \\nclass Solution:\\n    def countTexts(self, keys: str) -> int:\\n        \\n        dic = {\\'2\\': 3, \\'3\\': 3, \\'4\\':3, \\'5\\':3, \\'6\\':3, \\'7\\':4, \\'8\\': 3, \\'9\\':4 }\\n\\n        @lru_cache(None)\\n        def dp(i, acc):\\n            if i == 0:\\n                if acc == 1:\\n                    return 1\\n                return 0\\n\\n            if acc == 1:\\n                return sum([ dp(i-1, k) for k in range(1, dic[keys[i-1]] +1) ]) % (10**9+7)\\n            \\n            if keys[i] == keys[i-1]:\\n                return dp(i-1, acc-1)\\n            \\n            return 0\\n        \\n        return sum([ dp(len(keys)-1, k) for k in range(1, dic[keys[-1]]+1) ]) % (10**9+7)\\n    ```\\n\\t\\n\\n\\t",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def countTexts(self, keys):\\n        dic = {\\'2\\': 3, \\'3\\': 3, \\'4\\':3, \\'5\\':3, \\'6\\':3, \\'7\\':4, \\'8\\': 3, \\'9\\':4 } # dictionary!\\n        \\n        # e.g  dp means all possibilities ending now. 4 status totaly dp2 means we quickly press same num for 2 times. (33)-->e\\n        dp1, dp2, dp3, dp4 = 1, 0, 0, 0   # assuming we passed first key, dp1 is 1\\n\\t\\t\\n        for i in range(1, len(keys)):\\n            if keys[i] == keys[i-1]: # if same with before, this is how we inherit\\n                dp1, dp2, dp3, dp4 = (dp1 + dp2 + dp3 + dp4) % (10**9+7), dp1, dp2, 0 if dic[keys[i]] == 3 else dp3\\n            else: # and when not same, this is how we inherit\\n                dp1, dp2, dp3, dp4 = (dp1 + dp2 + dp3 + dp4) % (10**9+7), 0, 0, 0\\n\\t\\t\\t\\t\\n        return (dp1 + dp2 + dp3 + dp4) % (10**9+7)\\n\\t\\t\\n\\t\\t\\nActually the status is pretty clear. There are 3-4 status when ending at each index among the keys, and status transfer is also clear to see. \\n```\n```\\n#Also here\\'s top-down dp ( = dfs + memo). Same time complexity, O(N) space. \\nclass Solution:\\n    def countTexts(self, keys: str) -> int:\\n        \\n        dic = {\\'2\\': 3, \\'3\\': 3, \\'4\\':3, \\'5\\':3, \\'6\\':3, \\'7\\':4, \\'8\\': 3, \\'9\\':4 }\\n\\n        @lru_cache(None)\\n        def dp(i, acc):\\n            if i == 0:\\n                if acc == 1:\\n                    return 1\\n                return 0\\n\\n            if acc == 1:\\n                return sum([ dp(i-1, k) for k in range(1, dic[keys[i-1]] +1) ]) % (10**9+7)\\n            \\n            if keys[i] == keys[i-1]:\\n                return dp(i-1, acc-1)\\n            \\n            return 0\\n        \\n        return sum([ dp(len(keys)-1, k) for k in range(1, dic[keys[-1]]+1) ]) % (10**9+7)\\n    ```",
                "codeTag": "Java"
            },
            {
                "id": 2019026,
                "title": "javascript-coin-change-dp-113ms",
                "content": "```\\nconst mod = 1e9 + 7;\\nconst cal = (c) => c == \\'7\\' || c == \\'9\\' ? 4 : 3\\n\\nconst countTexts = (s) => {\\n    let n = s.length;\\n    let dp = Array(n + 1).fill(0);\\n    dp[0] = 1;\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 1; j <= cal(s[i]); j++) {\\n            let len = i - j + 1;\\n            if (len < 0 || s[i] != s[len]) break;\\n            dp[i + 1] += dp[i + 1 - j];\\n        }\\n        dp[i + 1] %= mod;\\n    }\\n    return dp[n];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nconst mod = 1e9 + 7;\\nconst cal = (c) => c == \\'7\\' || c == \\'9\\' ? 4 : 3\\n\\nconst countTexts = (s) => {\\n    let n = s.length;\\n    let dp = Array(n + 1).fill(0);\\n    dp[0] = 1;\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 1; j <= cal(s[i]); j++) {\\n            let len = i - j + 1;\\n            if (len < 0 || s[i] != s[len]) break;\\n            dp[i + 1] += dp[i + 1 - j];\\n        }\\n        dp[i + 1] %= mod;\\n    }\\n    return dp[n];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2018146,
                "title": "c-top-down-recursive-and-memoization-solution",
                "content": "```\\nclass Solution \\n{\\n    public:\\n    int dp[100001][5];\\n    long long d=1000000007;\\n    int get(int n,int k)\\n    {\\n        if(n<0) return 0; // not valid\\n        if(n==0) return 1; // valid\\n        if(dp[n][k]!=-1) return dp[n][k];\\n\\n        long long result=0;\\n        for(int i=1;i<=k;i++) result=(result+get(n-i,k))%d; // i pressed counts are used\\n        dp[n][k]=result;\\n        return result;\\n    }\\n    int countTexts(string pressedKeys) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        long long result=1,a[10],n=pressedKeys.length(),c=1;\\n\\n        for(int i=0;i<10;i++) a[i]=3; // a[i] is the number of available alphabets for a given digit i\\n        a[7]=4;\\n        a[9]=4;\\n        pressedKeys+=\"0\"; // add a never-appeared digit at the end to make the below code concise\\n        \\n        for(int i=1;i<n+1;i++)\\n        {\\n            if(pressedKeys[i]==pressedKeys[i-1]) c++; // same digits\\n            else result=(result*get(c,a[pressedKeys[i-1]-\\'0\\']))%d, c=1; // find a different digit, so process the previous same digits\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    int dp[100001][5];\\n    long long d=1000000007;\\n    int get(int n,int k)\\n    {\\n        if(n<0) return 0; // not valid\\n        if(n==0) return 1; // valid\\n        if(dp[n][k]!=-1) return dp[n][k];\\n\\n        long long result=0;\\n        for(int i=1;i<=k;i++) result=(result+get(n-i,k))%d; // i pressed counts are used\\n        dp[n][k]=result;\\n        return result;\\n    }\\n    int countTexts(string pressedKeys) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        long long result=1,a[10],n=pressedKeys.length(),c=1;\\n\\n        for(int i=0;i<10;i++) a[i]=3; // a[i] is the number of available alphabets for a given digit i\\n        a[7]=4;\\n        a[9]=4;\\n        pressedKeys+=\"0\"; // add a never-appeared digit at the end to make the below code concise\\n        \\n        for(int i=1;i<n+1;i++)\\n        {\\n            if(pressedKeys[i]==pressedKeys[i-1]) c++; // same digits\\n            else result=(result*get(c,a[pressedKeys[i-1]-\\'0\\']))%d, c=1; // find a different digit, so process the previous same digits\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2731706,
                "title": "c-easy-recursion-dp",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int dp[100005];\\n    int mod = 1e9+7;\\n    int solve(string &str, int idx) {\\n        if(idx == str.length()) return 1;\\n        if(dp[idx] != -1) return dp[idx];\\n        int maxKeyPress = (str[idx] == \\'7\\' || str[idx] == \\'9\\') ? 4 : 3;\\n        long long currIndex = idx, pressFrequency = 1, ans = 0;\\n        while(pressFrequency <= maxKeyPress && str[currIndex] == str[idx]) {\\n            ++currIndex;\\n            ++pressFrequency;\\n            ans += solve(str, currIndex) % mod;\\n        }\\n        return dp[idx] = ans%mod;\\n    }\\n    int countTexts(string pressedKeys) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(pressedKeys, 0) % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int dp[100005];\\n    int mod = 1e9+7;\\n    int solve(string &str, int idx) {\\n        if(idx == str.length()) return 1;\\n        if(dp[idx] != -1) return dp[idx];\\n        int maxKeyPress = (str[idx] == \\'7\\' || str[idx] == \\'9\\') ? 4 : 3;\\n        long long currIndex = idx, pressFrequency = 1, ans = 0;\\n        while(pressFrequency <= maxKeyPress && str[currIndex] == str[idx]) {\\n            ++currIndex;\\n            ++pressFrequency;\\n            ans += solve(str, currIndex) % mod;\\n        }\\n        return dp[idx] = ans%mod;\\n    }\\n    int countTexts(string pressedKeys) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(pressedKeys, 0) % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524389,
                "title": "easy-to-understand-solution-using-combinations-and-dp",
                "content": "The approach is like, first of all we will find the number of texts possible for each substring containing same numbers. Then finally multiply all the values possible number of texts for each substring to  get total number of texts possible  for entire string. \\nHope you Like it!\\n\\n\\n```\\n\\nint countTexts(string s) {\\n        \\n        int n = s.size();\\n        int md  = 1e9+7;\\n        \\n        vector<long long> dp(n,0);\\n        dp[0]=1;\\n        int cnt = 1;\\n        \\n        long long ans = 1;\\n        \\n        for(int i=1;i<n;i++){\\n            \\n            if(s[i]==s[i-1]){\\n                cnt++;\\n                if(s[i] == \\'7\\' || s[i] == \\'9\\'){\\n                    if(cnt<=4){\\n                        dp[i] = 1;\\n                    }\\n                    \\n                        int k = min( cnt-1,4);\\n                        \\n                        while(k){\\n                            dp[i]+= dp[i-k];\\n                            dp[i] %= md;\\n                            k--;\\n                        }\\n                    \\n                }else {\\n                    \\n                       if(cnt<=3){\\n                        dp[i] = 1;}\\n                    \\n                        int k = min( cnt-1,3);\\n                        \\n                        while(k){\\n                            dp[i]+= dp[i-k];\\n                         dp[i] %= md;\\n\\n                            k--;\\n                        }\\n                }\\n            }else {\\n                //reseting the count for new substring with different values.\\n                cnt = 1;\\n                dp[i] = 1;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// adding answer to previous substring.\\n                ans = (ans*dp[i-1])%md;\\n                \\n            }\\n\\t}\\n\\n\\tans = (ans*dp[n-1])%md;\\n\\n\\treturn (int) ans;\\n}\\n\\n```",
                "solutionTags": [
                    "Combinatorics"
                ],
                "code": "```\\n\\nint countTexts(string s) {\\n        \\n        int n = s.size();\\n        int md  = 1e9+7;\\n        \\n        vector<long long> dp(n,0);\\n        dp[0]=1;\\n        int cnt = 1;\\n        \\n        long long ans = 1;\\n        \\n        for(int i=1;i<n;i++){\\n            \\n            if(s[i]==s[i-1]){\\n                cnt++;\\n                if(s[i] == \\'7\\' || s[i] == \\'9\\'){\\n                    if(cnt<=4){\\n                        dp[i] = 1;\\n                    }\\n                    \\n                        int k = min( cnt-1,4);\\n                        \\n                        while(k){\\n                            dp[i]+= dp[i-k];\\n                            dp[i] %= md;\\n                            k--;\\n                        }\\n                    \\n                }else {\\n                    \\n                       if(cnt<=3){\\n                        dp[i] = 1;}\\n                    \\n                        int k = min( cnt-1,3);\\n                        \\n                        while(k){\\n                            dp[i]+= dp[i-k];\\n                         dp[i] %= md;\\n\\n                            k--;\\n                        }\\n                }\\n            }else {\\n                //reseting the count for new substring with different values.\\n                cnt = 1;\\n                dp[i] = 1;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// adding answer to previous substring.\\n                ans = (ans*dp[i-1])%md;\\n                \\n            }\\n\\t}\\n\\n\\tans = (ans*dp[n-1])%md;\\n\\n\\treturn (int) ans;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2405125,
                "title": "c-linear-time-constant-space-solution",
                "content": "## Simple Inputs\\n\\n#### Example 1.1: \"23578\"\\n\\nQ: What if we don\\'t have repetitions in the input string?\\n\\nA: Our fingers just press each key once to produce the message.\\n\\n> The answer is 1\\n\\n#### Example 1.2: \"235782783578\"\\n\\nQ: What if we do have some same digit appear across the input string?\\n\\nA: As long as they are not back-to-back grouping with their own kinds,\\nour fingers still need to press each key once and move around for another.\\n\\n> The answer is still 1\\n\\n#### Short Summary\\n\\nIn examples 1.x, things are simple. \\nWe can safely assume \\n\\n> finger movement **must** occur between **all** adjacent keys\\n\\nand hence one-and-only-one message can be incurred from each of these input strings.\\n\\n## Fancy Inputs\\n\\nAs the problem suggest, we may have same digit in some groups of contiguous substring.\\n\\nWe somehow still want the observation in examples 1.x to happen here.\\nExcept that this time, we can only do \\n\\n> finger movement **may** occur between **some** adjacent keys\\n\\nConsidering this, we may want to cut `\"22233\"` into `\"222\"` and `\"33\"`.\\n\\n**Q: How exactly is `count(\"22233\")` and `count(\"222\")` and `count(\"33\")` are related?**\\n\\n#### Example 2: \"22233\"\\n\\nSince our finger shall jump between `2` and `3` at some point,\\nLet\\'s say we press `222` and form `ba`.\\n**Then we must break the continuity and switch keys** (from `2` to `3`).\\nNext, pressing `33` can give a `e`.\\nThe final message `bae` is then formed by concatenating the pre-chosen segments.\\n\\nMore precisely, \\neach of the possible outcome from `222` can be paired with an outcome from `33` \\nfor producing a possible message.\\n\\nThus, the Product Rule (from Discrete Maths) applies.\\n\\n```\\ncount(\"22233\")   =   count(\"222\")   \\xD7   count(\"33\")\\n```\\n\\n## Extract Subroutine\\n\\nWe can imagine how the product expands, when more **contiguous substrings of same character** present.\\n\\nSay we extract out a subroutine for solving contiguous substrings of this kind, \\n\\n```c++\\nint countSameTexts(char& cc, int& count);\\n```\\n\\nthen we can formulate our solver progam as below. \\n\\n```c++\\nclass Solution {\\npublic:\\n    long modulo = 1000000007;\\n    int countSameTexts(char& cc, int& count);\\n    int countTexts(string pressedKeys) {\\n        long res = 1;\\n        int count = 0;\\n        char current = pressedKeys[0];\\n        for (char& c: pressedKeys)\\n            /* Accumulate count for contiguous substrings of same character */\\n            if (current == c)\\n                count++;\\n            /* Update `res` by Product Rule and `modulo` during key-switch */\\n            else {\\n                res = (res * countSameTexts(current, count)) % modulo;\\n                current = c;\\n                count = 1; // Reset count\\n            }\\n        /* Update `res` one final time */\\n        return (res * countSameTexts(current, count)) % modulo;\\n    }\\n};\\n```\\n\\n## Construct Subroutine By Dynamic Programming\\n\\n### Case 1: 7, 9\\n\\n#### Arbitrary length n\\nFrom the given repetition rule, a string with length `n` can be formed by one of the following.\\n- character formed by subtring of length `1` + chracters from remaining substrings of length `(n - 1)`\\n- character formed by subtring of length `2` + chracters from remaining substrings of length `(n - 2)`\\n- character formed by subtring of length `3` + chracters from remaining substrings of length `(n - 3)`\\n- character formed by subtring of length `4` + chracters from remaining substrings of length `(n - 4)`\\n\\nSub-optimal property is obviously preserved, \\nsince any length of substring from the original string always contains the same character.\\n\\nThe above events are disjoint and exhaustive.\\nThus, the Sum Rule (from Discrete Maths) applies.\\n\\n```\\nCount_79(n)   =   Count_79(n - 1)   +   Count_79(n - 2)   +   Count_79(n - 3)   +   Count_79(n - 4)\\n```\\n\\n#### Base Case of length 1, 2, 3, 4\\n\\nFor `n = 1`, obviously `Count_79(2) = 1`.\\n\\nFor `n = 2`, we have `7, 7` or `77`. so `Count_79(2) = 2`.\\n\\nFor `n = 3`, we have `7, 7, 7` or `7, 77` or `77, 7` or `777`. so `Count_79(3) = 4`.\\n\\nFor `n = 4`, the count will involve\\n- 1 permutation involving `7`\\n- 3 permutation involving `7` and `77`\\n- 2 permutation involving `7` and `777`\\n- 1 permutation involving `77` and `77`\\n- 1 permutation involving `7777`\\nHence, `Count_79(4) = 8`.\\n\\n#### Complete Formula \\n\\nFrom base case and recursion, we can obtain the complete formula ... (1)\\n\\n```\\nCount_79(1)   =   1\\nCount_79(2)   =   2\\nCount_79(3)   =   4\\nCount_79(4)   =   8\\nCount_79(n)   =   Count_79(n - 1)   +   Count_79(n - 2)   +   Count_79(n - 3)   +   Count_79(n - 4)\\n```\\n\\n### Case 2: 2, 3, 4, 5, 6, 8\\n\\n#### Complete Formula \\n\\nFollow a similar analysis as above, we can have the below formula ... (2)\\n\\n(Can you deduce the details?)\\n\\n```\\nCount_234568(1)   =   1\\nCount_234568(2)   =   2\\nCount_234568(3)   =   4\\nCount_234568(n)   =   Count_234568(n - 1)   +   Count_234568(n - 2)   +   Count_234568(n - 3)\\n```\\n\\n### Code\\n\\nThe code can easily be written, with bottom-up DP.\\n\\n```c++\\nint Solution::countSameTexts(char& cc, int& count) {\\n    // Count for 7, 9\\n    if (cc == \\'7\\' || cc == \\'9\\') {\\n        if (count <= 4)\\n            return 1 << (count - 1);\\n        long a = 1 << 0;\\n        long b = 1 << 1;\\n        long c = 1 << 2;\\n        long d = 1 << 3;\\n        for (int i = 4; i < count; i++) {\\n            long new_a = b;\\n            long new_b = c;\\n            long new_c = d;\\n            long new_d = (a + b + c + d) % modulo;\\n            a = new_a;\\n            b = new_b;\\n            c = new_c;\\n            d = new_d;\\n        }\\n        return d;\\n    }\\n    // Count for 2, 3, 4, 5, 6, 8\\n    else {        \\n        if (count <= 3)\\n            return 1 << (count - 1);\\n        long a = 1 << 0;\\n        long b = 1 << 1;\\n        long c = 1 << 2;\\n        for (int i = 3; i < count; i++) {\\n            long new_a = b;\\n            long new_b = c;\\n            long new_c = (a + b + c) % modulo;\\n            a = new_a;\\n            b = new_b;\\n            c = new_c;\\n        }\\n        return c;\\n    }\\n}\\n```\\n\\n## Possible Optimization\\n\\nFormula in (1) and (2) can easily be speed-up to logarithmic cost, by (binary) exponetiation of matrix.\\nI invite readers to develop a fancy (or somewhat standard) program with this approach :)\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Counting"
                ],
                "code": "```\\ncount(\"22233\")   =   count(\"222\")   \\xD7   count(\"33\")\\n```\n```c++\\nint countSameTexts(char& cc, int& count);\\n```\n```c++\\nclass Solution {\\npublic:\\n    long modulo = 1000000007;\\n    int countSameTexts(char& cc, int& count);\\n    int countTexts(string pressedKeys) {\\n        long res = 1;\\n        int count = 0;\\n        char current = pressedKeys[0];\\n        for (char& c: pressedKeys)\\n            /* Accumulate count for contiguous substrings of same character */\\n            if (current == c)\\n                count++;\\n            /* Update `res` by Product Rule and `modulo` during key-switch */\\n            else {\\n                res = (res * countSameTexts(current, count)) % modulo;\\n                current = c;\\n                count = 1; // Reset count\\n            }\\n        /* Update `res` one final time */\\n        return (res * countSameTexts(current, count)) % modulo;\\n    }\\n};\\n```\n```\\nCount_79(n)   =   Count_79(n - 1)   +   Count_79(n - 2)   +   Count_79(n - 3)   +   Count_79(n - 4)\\n```\n```\\nCount_79(1)   =   1\\nCount_79(2)   =   2\\nCount_79(3)   =   4\\nCount_79(4)   =   8\\nCount_79(n)   =   Count_79(n - 1)   +   Count_79(n - 2)   +   Count_79(n - 3)   +   Count_79(n - 4)\\n```\n```\\nCount_234568(1)   =   1\\nCount_234568(2)   =   2\\nCount_234568(3)   =   4\\nCount_234568(n)   =   Count_234568(n - 1)   +   Count_234568(n - 2)   +   Count_234568(n - 3)\\n```\n```c++\\nint Solution::countSameTexts(char& cc, int& count) {\\n    // Count for 7, 9\\n    if (cc == \\'7\\' || cc == \\'9\\') {\\n        if (count <= 4)\\n            return 1 << (count - 1);\\n        long a = 1 << 0;\\n        long b = 1 << 1;\\n        long c = 1 << 2;\\n        long d = 1 << 3;\\n        for (int i = 4; i < count; i++) {\\n            long new_a = b;\\n            long new_b = c;\\n            long new_c = d;\\n            long new_d = (a + b + c + d) % modulo;\\n            a = new_a;\\n            b = new_b;\\n            c = new_c;\\n            d = new_d;\\n        }\\n        return d;\\n    }\\n    // Count for 2, 3, 4, 5, 6, 8\\n    else {        \\n        if (count <= 3)\\n            return 1 << (count - 1);\\n        long a = 1 << 0;\\n        long b = 1 << 1;\\n        long c = 1 << 2;\\n        for (int i = 3; i < count; i++) {\\n            long new_a = b;\\n            long new_b = c;\\n            long new_c = (a + b + c) % modulo;\\n            a = new_a;\\n            b = new_b;\\n            c = new_c;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2340071,
                "title": "c-dp-memorization-very-simple-code",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    int countTexts(string pressedKeys) {\\n        vector<int> dp(pressedKeys.size(),-1);\\n        return fun(dp,pressedKeys,0);\\n    }\\n    long fun(vector<int>& dp,string& s,int i)\\n    {\\n        if(i>=s.length())\\n            return 1;\\n        \\n        if(dp[i]!=-1)\\n            return dp[i];\\n        \\n        int n=temp(s[i])-1;\\n        long t=fun(dp,s,i+1)%mod;\\n        for(int j=i+1;j<s.length();j++)\\n        {\\n            if(s[j]==s[i] && n)\\n            {\\n                n--;\\n                t+=fun(dp,s,j+1)%mod;\\n            }\\n            else\\n                break;\\n        }\\n        return dp[i]=t%mod;\\n    }\\n    int temp(char c)\\n    {\\n        if(c==\\'7\\'|| c==\\'9\\')\\n            return 4;\\n        return 3;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    int countTexts(string pressedKeys) {\\n        vector<int> dp(pressedKeys.size(),-1);\\n        return fun(dp,pressedKeys,0);\\n    }\\n    long fun(vector<int>& dp,string& s,int i)\\n    {\\n        if(i>=s.length())\\n            return 1;\\n        \\n        if(dp[i]!=-1)\\n            return dp[i];\\n        \\n        int n=temp(s[i])-1;\\n        long t=fun(dp,s,i+1)%mod;\\n        for(int j=i+1;j<s.length();j++)\\n        {\\n            if(s[j]==s[i] && n)\\n            {\\n                n--;\\n                t+=fun(dp,s,j+1)%mod;\\n            }\\n            else\\n                break;\\n        }\\n        return dp[i]=t%mod;\\n    }\\n    int temp(char c)\\n    {\\n        if(c==\\'7\\'|| c==\\'9\\')\\n            return 4;\\n        return 3;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2166287,
                "title": "java-simple-solution",
                "content": "```\\nimport java.util.*;\\nclass Solution {\\n    \\n    int mod=(int)Math.pow(10,9)+7;\\n   // String[] keypad={\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n    int ans=0;\\n    public int countTexts(String pressedKeys) {\\n        \\n        int len=pressedKeys.length();\\n       int[] dp=new int[len+1];\\n        \\n        dp[0]=1;\\n        System.out.print(dp[0]+\" \");\\n        for(int i=1;i<len+1;i++){\\n            \\n            char ch=pressedKeys.charAt(i-1);\\n          \\n         \\n            \\n             dp[i]=(dp[i]%mod+dp[i-1]%mod)%mod;\\n            if(i-2>=0 && pressedKeys.charAt(i-2)==ch ){\\n                \\n                 dp[i]=(dp[i]%mod+dp[i-2]%mod)%mod;\\n                \\n                if(i-3>=0 &&  pressedKeys.charAt(i-3)==ch ){\\n                    \\n                    \\n                        dp[i]=(dp[i]%mod+dp[i-3]%mod)%mod;\\n                    \\n                    if((i-4>=0 && pressedKeys.charAt(i-4)==ch)&& (ch==\\'7\\' || ch==\\'9\\')  ){\\n                        dp[i]=(dp[i]%mod+dp[i-4]%mod)%mod;\\n                    }\\n                }\\n                \\n                \\n            }\\n            \\n            \\n           // System.out.print(dp[i]+\" \");\\n        }\\n         \\n        return dp[len];\\n    }\\n}\\n             \\n                   \\n```\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n    \\n    int mod=(int)Math.pow(10,9)+7;\\n   // String[] keypad={\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n    int ans=0;\\n    public int countTexts(String pressedKeys) {\\n        \\n        int len=pressedKeys.length();\\n       int[] dp=new int[len+1];\\n        \\n        dp[0]=1;\\n        System.out.print(dp[0]+\" \");\\n        for(int i=1;i<len+1;i++){\\n            \\n            char ch=pressedKeys.charAt(i-1);\\n          \\n         \\n            \\n             dp[i]=(dp[i]%mod+dp[i-1]%mod)%mod;\\n            if(i-2>=0 && pressedKeys.charAt(i-2)==ch ){\\n                \\n                 dp[i]=(dp[i]%mod+dp[i-2]%mod)%mod;\\n                \\n                if(i-3>=0 &&  pressedKeys.charAt(i-3)==ch ){\\n                    \\n                    \\n                        dp[i]=(dp[i]%mod+dp[i-3]%mod)%mod;\\n                    \\n                    if((i-4>=0 && pressedKeys.charAt(i-4)==ch)&& (ch==\\'7\\' || ch==\\'9\\')  ){\\n                        dp[i]=(dp[i]%mod+dp[i-4]%mod)%mod;\\n                    }\\n                }\\n                \\n                \\n            }\\n            \\n            \\n           // System.out.print(dp[i]+\" \");\\n        }\\n         \\n        return dp[len];\\n    }\\n}\\n             \\n                   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2164807,
                "title": "python-lru-cache",
                "content": "```\\nclass Solution:\\n    def countTexts(self, x: str) -> int:\\n        l=len(x)\\n        @lru_cache(None)\\n        def f(i):\\n            if i==l:return 1\\n            ans=0\\n            for j in range(i,i+(4 if x[i] in \\'97\\' else 3)):\\n                    if j<l and x[j]==x[i]:\\n                        ans+=f(j+1)\\n                    else:\\n                        break\\n            return ans%(10**9+7)\\n        return f(0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countTexts(self, x: str) -> int:\\n        l=len(x)\\n        @lru_cache(None)\\n        def f(i):\\n            if i==l:return 1\\n            ans=0\\n            for j in range(i,i+(4 if x[i] in \\'97\\' else 3)):\\n                    if j<l and x[j]==x[i]:\\n                        ans+=f(j+1)\\n                    else:\\n                        break\\n            return ans%(10**9+7)\\n        return f(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2033223,
                "title": "python-simple",
                "content": "Should be mostly self explanatory. \\n\\nLoop through the numbers, and when the number is the same as the last number, just keep a running total of one, two, three, and four in a row. (Of course four in a row only exists for 7 or 9). \\n\\nWhen we have a new number, we sum up one, two, three, and four, and multiply that by our answer (ans) to keep a running total in ans. And at this point one = 1, all others are reset to 0.\\n\\nSee the code below:\\n\\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        M = 10 ** 9 + 7\\n        ans = one = 1\\n        two = three = four = 0\\n        last = \\'\\'\\n        for x in pressedKeys:\\n            if x == last:\\n                one, two, three, four = one + two + three + four, one, two, three\\n                if x not in \\'79\\':\\n                    four = 0\\n            else:\\n                ans = ans * (one + two + three + four) % M\\n                one = 1\\n                two = three = four = 0\\n            last = x\\n        return ans * (one + two + three + four) % M\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        M = 10 ** 9 + 7\\n        ans = one = 1\\n        two = three = four = 0\\n        last = \\'\\'\\n        for x in pressedKeys:\\n            if x == last:\\n                one, two, three, four = one + two + three + four, one, two, three\\n                if x not in \\'79\\':\\n                    four = 0\\n            else:\\n                ans = ans * (one + two + three + four) % M\\n                one = 1\\n                two = three = four = 0\\n            last = x\\n        return ans * (one + two + three + four) % M\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2029686,
                "title": "c-dynamic-programming-solution",
                "content": "Key idea: total possible number of answer with a digit `d` at the position `i` = \\n(total possible number of answer ends  at the position `i-1` + interpret the last digit as one character if 1 consecutive digits) + \\n(total possible number of answer ends  at the position `i-2` + interpret the last two digits as one character if 2 consecutive digits) + \\n(total possible number of answer ends  at the position `i-3` + interpret the last three digits as one character if 3 consecutive digits) + \\n(total possible number of answer ends  at the position `i-4` + interpret the last four digits as one character if 4 consecutive digits) + \\n\\nOne character is composed of at most 4 digits, so we only have to look up at most 4 entries to fill in each entry of the memorization table.\\n\\n```\\nint keys[10] = {0, 0, 3, 3, 3, 3, 3, 4, 3, 4};\\nconst int mod = 1e9 + 7;\\n\\nclass Solution {\\npublic:\\n    int countTexts(string pressedKeys) {\\n        int n= pressedKeys.size();\\n        if (n == 0) return 0;\\n        int dp[n+1];\\n        memset(dp, 0, sizeof(dp));\\n        dp[0] = 1;\\n        \\n        for (int i = 1; i <= n; ++i) {\\n            char c = pressedKeys[i-1];\\n            for (int j = 0; j < keys[c-\\'0\\']; ++j) {\\n                if (i-j <= 0 || pressedKeys[i-j-1] != c) {break;}\\n                dp[i] = (dp[i] + dp[i-j-1]) % mod;\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```\\nSpace complexity: O(n)\\ntime complexity: O(n)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint keys[10] = {0, 0, 3, 3, 3, 3, 3, 4, 3, 4};\\nconst int mod = 1e9 + 7;\\n\\nclass Solution {\\npublic:\\n    int countTexts(string pressedKeys) {\\n        int n= pressedKeys.size();\\n        if (n == 0) return 0;\\n        int dp[n+1];\\n        memset(dp, 0, sizeof(dp));\\n        dp[0] = 1;\\n        \\n        for (int i = 1; i <= n; ++i) {\\n            char c = pressedKeys[i-1];\\n            for (int j = 0; j < keys[c-\\'0\\']; ++j) {\\n                if (i-j <= 0 || pressedKeys[i-j-1] != c) {break;}\\n                dp[i] = (dp[i] + dp[i-j-1]) % mod;\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2019598,
                "title": "memoization-to-tablulation-c",
                "content": "```\\nclass Solution {\\npublic:   \\n    int m=1e9+7;\\n    vector<int> arr={0,0,3,3,3,3,3,4,3,4}; \\n    int dp[100003];\\n    int solve(string &s,int i){\\n        if(i==s.length()) return 1;\\n        if(dp[i]!=-1) return dp[i];\\n        long long ans=0;\\n        int j=0; \\n        ans=(ans%m+solve(s,i+1)%m)%m; \\n        for(j=i+1;j<s.length()&&j<i+arr[s[i]-\\'0\\'];j++){ \\n            if(s[j]!=s[j-1]) break;\\n            ans=(ans%m+solve(s,j+1)%m)%m;\\n        } \\n        return dp[i]=ans;\\n    }\\n    int countTexts(string s) {  \\n        memset(dp,-1,sizeof dp);\\n      return solve(s,0);\\n    }\\n};\\n``` \\n**CONVERTING IT TO TABULATION (credit-striver)** \\nfollowing steps involve in coverting memoization into tabulation\\n1.Declare same size storage and intialise base case.\\n2.Observe changing paremeter (i)  i->0,1,2,3,4,5 \\n3.write down the loop of changing parameter in reverse order.\\n4.Copy the recusion. \\n\\n```\\nclass Solution {\\npublic:    \\n    //tabulation\\n    int m=1e9+7;\\n    vector<int> arr={0,0,3,3,3,3,3,4,3,4}; \\n    int countTexts(string s) {  \\n      vector<int> dp(s.length()+1);\\n      dp[s.length()]=1; //step1\\n      for(int i=s.length()-1;i>=0;i--){ //step 2 and 3 \\n\\t  //step 4\\n        long long ans=0;\\n        int j=0; \\n        ans=(ans%m+dp[i+1]%m)%m; \\n        for(j=i+1;j<s.length()&&j<i+arr[s[i]-\\'0\\'];j++){ \\n            if(s[j]!=s[j-1]) break;\\n            ans=(ans%m+dp[j+1]%m)%m;\\n        } \\n        dp[i]=ans;\\n      }\\n      return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:   \\n    int m=1e9+7;\\n    vector<int> arr={0,0,3,3,3,3,3,4,3,4}; \\n    int dp[100003];\\n    int solve(string &s,int i){\\n        if(i==s.length()) return 1;\\n        if(dp[i]!=-1) return dp[i];\\n        long long ans=0;\\n        int j=0; \\n        ans=(ans%m+solve(s,i+1)%m)%m; \\n        for(j=i+1;j<s.length()&&j<i+arr[s[i]-\\'0\\'];j++){ \\n            if(s[j]!=s[j-1]) break;\\n            ans=(ans%m+solve(s,j+1)%m)%m;\\n        } \\n        return dp[i]=ans;\\n    }\\n    int countTexts(string s) {  \\n        memset(dp,-1,sizeof dp);\\n      return solve(s,0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:    \\n    //tabulation\\n    int m=1e9+7;\\n    vector<int> arr={0,0,3,3,3,3,3,4,3,4}; \\n    int countTexts(string s) {  \\n      vector<int> dp(s.length()+1);\\n      dp[s.length()]=1; //step1\\n      for(int i=s.length()-1;i>=0;i--){ //step 2 and 3 \\n\\t  //step 4\\n        long long ans=0;\\n        int j=0; \\n        ans=(ans%m+dp[i+1]%m)%m; \\n        for(j=i+1;j<s.length()&&j<i+arr[s[i]-\\'0\\'];j++){ \\n            if(s[j]!=s[j-1]) break;\\n            ans=(ans%m+dp[j+1]%m)%m;\\n        } \\n        dp[i]=ans;\\n      }\\n      return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018609,
                "title": "python-recursion-memoization",
                "content": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        keysMap={\"2\":3,\"3\":3,\"4\":3,\"5\":3,\"6\":3,\"7\":4,\"8\":3,\"9\":4}\\n        seen={}\\n        @lru_cache(10)\\n        def find_(ind):\\n            if ind>=len(pressedKeys):\\n                return 1\\n            ans=0\\n            for i in range(keysMap[pressedKeys[ind]]):\\n                if ind+i >= len(pressedKeys) or pressedKeys[ind+i]!=pressedKeys[ind]:\\n                    break\\n                ans+=find_(ind+i+1)\\n            return ans\\n        return find_(0)%1000000007\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        keysMap={\"2\":3,\"3\":3,\"4\":3,\"5\":3,\"6\":3,\"7\":4,\"8\":3,\"9\":4}\\n        seen={}\\n        @lru_cache(10)\\n        def find_(ind):\\n            if ind>=len(pressedKeys):\\n                return 1\\n            ans=0\\n            for i in range(keysMap[pressedKeys[ind]]):\\n                if ind+i >= len(pressedKeys) or pressedKeys[ind+i]!=pressedKeys[ind]:\\n                    break\\n                ans+=find_(ind+i+1)\\n            return ans\\n        return find_(0)%1000000007\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018479,
                "title": "java-memo-explained-o-n",
                "content": "```\\nclass Solution {\\n    public int countTexts(String pressedKeys) {\\n        int[] memo=new int[pressedKeys.length()];\\n        \\n        return dfs(pressedKeys,memo,0);\\n    }\\n    \\n    public int dfs(String pk,int[] memo,int index){\\n        if(index==pk.length())  //if end of string is reached that is one permutation\\n            return 1;\\n        \\n        if(memo[index]!=0)      //if countof permutations for that index is already calculated\\n            return memo[index];\\n        \\n        int count=0;\\n        for(int i=0;i<4;i++){   //max we need to go four index forward\\n            //for only button 7 and 9 we have 4 charcters\\n            if(pk.charAt(index)!=\\'7\\' && pk.charAt(index)!=\\'9\\' && i==3)  \\n                break;\\n            \\n            if(index+i>=pk.length())    //if end index goes out of bounds\\n                break;\\n              \\n            if(i!=0){  \\n                //if adjacent characters are not same\\n                if(pk.charAt(index+i)!=pk.charAt(index+i-1))    \\n                    break;\\n            }\\n            \\n            count+=dfs(pk,memo,index+i+1);  //recursive call for remaining string\\n            count%=1000000007;\\n                \\n        }\\n        \\n        memo[index]=count;  //store the calculated value for this index\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int countTexts(String pressedKeys) {\\n        int[] memo=new int[pressedKeys.length()];\\n        \\n        return dfs(pressedKeys,memo,0);\\n    }\\n    \\n    public int dfs(String pk,int[] memo,int index){\\n        if(index==pk.length())  //if end of string is reached that is one permutation\\n            return 1;\\n        \\n        if(memo[index]!=0)      //if countof permutations for that index is already calculated\\n            return memo[index];\\n        \\n        int count=0;\\n        for(int i=0;i<4;i++){   //max we need to go four index forward\\n            //for only button 7 and 9 we have 4 charcters\\n            if(pk.charAt(index)!=\\'7\\' && pk.charAt(index)!=\\'9\\' && i==3)  \\n                break;\\n            \\n            if(index+i>=pk.length())    //if end index goes out of bounds\\n                break;\\n              \\n            if(i!=0){  \\n                //if adjacent characters are not same\\n                if(pk.charAt(index+i)!=pk.charAt(index+i-1))    \\n                    break;\\n            }\\n            \\n            count+=dfs(pk,memo,index+i+1);  //recursive call for remaining string\\n            count%=1000000007;\\n                \\n        }\\n        \\n        memo[index]=count;  //store the calculated value for this index\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017949,
                "title": "python-single-pass-dp-o-n-time-o-1-space",
                "content": "**Building our Intuition:**\\nLet us imagine pressedKeys is \"2222\".\\n\\nThe only way to interpret \"2\" is:\\n[\"a\"]\\n\\nThere are two ways we interpret \"22\":\\n[\"aa\", \"b\"]\\n\\nFour ways we interpret \"222\":\\n[\"aaa\", \"ba\", \"ab\", \"c\"]\\n\\n7 ways we interpret \"2222\":\\n[\"aaaa\", \"baa\", \"aba\", \"ca\", \"aab\", \"bb\", \"ac\"]\\n\\nIn each state we can see that to get the ways a digit is interpretting as ending with \"a\", we need to combine all digits that ended previously with \"a\", \"b\", & \"c\". Then to get the ways the str can be interpretted as ending with \"b\", it would be the number of strings that ended with \"b\" in our previous digit. Similarly for \"c\" we need to get the number of ways the previous str ended with \"b\".\\n\\n**So how do we calculate one state from another?**\\nSo for the digit \"2\" in every subsequent digit of \"2\" to get the new combinations we just check how many previous digits ended with \"a\", \"b\", & \"c\". Same idea goes for every other digit except for \"7\" and \"9\" in which case there are 4 transitions, so we need to account and check for one more digit.\\n\\nWhen we see a new digit, i.e. if after seeing \"222\" we then encounter a \"3\", then we reset our states to be all 0, and make our first state to be the combination of all the previous state endings. Meaning if we had \"222\" then the possible combinations we have is [\"aaa\", \"ba\", \"ab\", \"c\"], however whenever we encounter a \"3\", then they all must end with \"d\", and as such we now get [\"aaad\", \"bad\", \"abd\", \"cd\"]. Which then is repersented as [4, 0, 0], meaning we have 4 digits that end with \"d\", and 0 digits that end \"e\" & \"f\".\\n\\n\\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        if not pressedKeys:\\n            return 0\\n        \\n        MOD = 10 ** 9 + 7\\n        chars_in_digit = {\\'2\\': 3, \\'3\\': 3, \\'4\\': 3, \\'5\\': 3, \\'6\\': 3, \\'7\\': 4, \\'8\\': 3, \\'9\\': 4}\\n        \\n        prev_states = [1]\\n        prev_digit = None\\n        \\n        for digit in pressedKeys:\\n            total = sum(prev_states) % MOD\\n            \\n            if digit != prev_digit:\\n                prev_states = [total] + [0] * (chars_in_digit[digit] - 1)\\n            else:\\n                prev_states = [total] + prev_states[:chars_in_digit[digit] - 1]\\n                \\n            prev_digit = digit\\n        \\n        return sum(prev_states) % MOD\\n```\\n\\n**TC: O(N)** -> Since all new list creations and tallying of states in each char has an upperbound of 4\\n**SC: O(1)** -> Since prev_states has a max length of 4, and other variables are constant",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        if not pressedKeys:\\n            return 0\\n        \\n        MOD = 10 ** 9 + 7\\n        chars_in_digit = {\\'2\\': 3, \\'3\\': 3, \\'4\\': 3, \\'5\\': 3, \\'6\\': 3, \\'7\\': 4, \\'8\\': 3, \\'9\\': 4}\\n        \\n        prev_states = [1]\\n        prev_digit = None\\n        \\n        for digit in pressedKeys:\\n            total = sum(prev_states) % MOD\\n            \\n            if digit != prev_digit:\\n                prev_states = [total] + [0] * (chars_in_digit[digit] - 1)\\n            else:\\n                prev_states = [total] + prev_states[:chars_in_digit[digit] - 1]\\n                \\n            prev_digit = digit\\n        \\n        return sum(prev_states) % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3774780,
                "title": "my-dp-memoization-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n    just have special cycles for index+1,index+2 and index+3 elements.\\nIf they are equal like 222 or 7777 then we can take this in cosideration.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int size = 1e5+10;\\n    int dp[100000];\\n    int solve(int ind, string &str, vector<string>& nummap){\\n        \\n        if(str[ind] == \\'0\\' || str[ind]==\\'1\\') return 0;\\n        if(ind == str.size()) return 1;\\n\\n        if(dp[ind] != -1) return dp[ind];\\n\\n        long long int ans = 0;\\n\\n        if(ind<str.size()-1 && str[ind+1]==str[ind]){\\n            ans += solve(ind+2,str,nummap)%mod;\\n        }\\n\\n        if(ind<str.size()-2 && (str[ind]==str[ind+1] && str[ind+1]==str[ind+2])){\\n            ans += solve(ind+3,str,nummap)%mod;\\n        }\\n\\n        if(ind<str.size()-3 && (str[ind]==\\'7\\' || str[ind]==\\'9\\') &&( str[ind+1]==str[ind] && str[ind+2]==str[ind]  && str[ind+3]==str[ind])){\\n            ans += solve(ind+4,str,nummap)%mod;\\n        }\\n\\n        ans += solve(ind+1,str,nummap)%mod;\\n\\n        return dp[ind] = ans%mod;\\n\\n    }\\n\\n    int countTexts(string pressedKeys) {\\n        \\n        vector<string> nummap {\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,pressedKeys,nummap)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int size = 1e5+10;\\n    int dp[100000];\\n    int solve(int ind, string &str, vector<string>& nummap){\\n        \\n        if(str[ind] == \\'0\\' || str[ind]==\\'1\\') return 0;\\n        if(ind == str.size()) return 1;\\n\\n        if(dp[ind] != -1) return dp[ind];\\n\\n        long long int ans = 0;\\n\\n        if(ind<str.size()-1 && str[ind+1]==str[ind]){\\n            ans += solve(ind+2,str,nummap)%mod;\\n        }\\n\\n        if(ind<str.size()-2 && (str[ind]==str[ind+1] && str[ind+1]==str[ind+2])){\\n            ans += solve(ind+3,str,nummap)%mod;\\n        }\\n\\n        if(ind<str.size()-3 && (str[ind]==\\'7\\' || str[ind]==\\'9\\') &&( str[ind+1]==str[ind] && str[ind+2]==str[ind]  && str[ind+3]==str[ind])){\\n            ans += solve(ind+4,str,nummap)%mod;\\n        }\\n\\n        ans += solve(ind+1,str,nummap)%mod;\\n\\n        return dp[ind] = ans%mod;\\n\\n    }\\n\\n    int countTexts(string pressedKeys) {\\n        \\n        vector<string> nummap {\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,pressedKeys,nummap)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2677775,
                "title": "dp-based-simple-c-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    int count(string &ss,int s,vector<int>&dp,map<char,int>&m)\\n    {\\n        if(s>=ss.length())\\n        {\\n            return 1;\\n        }\\n        if(dp[s]!=-1)\\n            return dp[s];\\n        int ans=0;\\n        char ch=ss[s];\\n        int k=m[ch];\\n        int j=s;\\n        while(j<ss.length() and j-s<k and ss[j]==ss[s])\\n        {\\n            ans=(ans%mod+count(ss,j+1,dp,m)%mod)%mod;\\n            j++;\\n        }\\n        dp[s]=ans;\\n        return ans;\\n    }\\n    int countTexts(string s) {\\n        int n=s.length();\\n        vector<int>dp(n+1,-1);\\n        map<char,int>m;\\n        m[\\'2\\']=3;\\n        m[\\'3\\']=3;\\n        m[\\'4\\']=3;\\n        m[\\'5\\']=3;\\n        m[\\'6\\']=3;\\n        m[\\'7\\']=4;\\n        m[\\'8\\']=3;\\n        m[\\'9\\']=4;\\n        \\n        return count(s,0,dp,m);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    int count(string &ss,int s,vector<int>&dp,map<char,int>&m)\\n    {\\n        if(s>=ss.length())\\n        {\\n            return 1;\\n        }\\n        if(dp[s]!=-1)\\n            return dp[s];\\n        int ans=0;\\n        char ch=ss[s];\\n        int k=m[ch];\\n        int j=s;\\n        while(j<ss.length() and j-s<k and ss[j]==ss[s])\\n        {\\n            ans=(ans%mod+count(ss,j+1,dp,m)%mod)%mod;\\n            j++;\\n        }\\n        dp[s]=ans;\\n        return ans;\\n    }\\n    int countTexts(string s) {\\n        int n=s.length();\\n        vector<int>dp(n+1,-1);\\n        map<char,int>m;\\n        m[\\'2\\']=3;\\n        m[\\'3\\']=3;\\n        m[\\'4\\']=3;\\n        m[\\'5\\']=3;\\n        m[\\'6\\']=3;\\n        m[\\'7\\']=4;\\n        m[\\'8\\']=3;\\n        m[\\'9\\']=4;\\n        \\n        return count(s,0,dp,m);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2557916,
                "title": "c-easy-approach-dp-hahmap",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    map<pair<int,int>,int>mp;\\n    void create_map(){\\n        mp[{0,1}]=mp[{1,1}]=1;\\n        mp[{0,2}]=mp[{1,2}]=2;\\n        mp[{0,3}]=mp[{1,3}]=4;\\n        mp[{0,4}]=7;\\n        mp[{1,4}]=8;\\n    }    \\n    unsigned int getval(int num,int count){\\n        //base case\\n        if(mp.count({num,count}))\\n            return mp[{num,count}];\\n        \\n        return mp[{num,count}]=(\\n                getval(num,count-1)%mod +\\n                getval(num,count-2)%mod +\\n                getval(num,count-3)%mod +\\n                (num==1 ? getval(num,count-4) : 0)%mod\\n            )%mod;\\n    }\\n    int countTexts(string str) {\\n        create_map();\\n        str.push_back(\\'#\\');\\n        int n= str.size();\\n        long long  ans=1;\\n        int count=1;\\n        for(int i=0;i<n-1;i++){\\n            if(str[i]==str[i+1])\\n                count++;\\n            else{\\n                int num=str[i]-\\'0\\';\\n                long long  curr = getval(num==7 || num==9,count)%mod;\\n                count=1;\\n                ans=(ans *curr)%mod;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    map<pair<int,int>,int>mp;\\n    void create_map(){\\n        mp[{0,1}]=mp[{1,1}]=1;\\n        mp[{0,2}]=mp[{1,2}]=2;\\n        mp[{0,3}]=mp[{1,3}]=4;\\n        mp[{0,4}]=7;\\n        mp[{1,4}]=8;\\n    }    \\n    unsigned int getval(int num,int count){\\n        //base case\\n        if(mp.count({num,count}))\\n            return mp[{num,count}];\\n        \\n        return mp[{num,count}]=(\\n                getval(num,count-1)%mod +\\n                getval(num,count-2)%mod +\\n                getval(num,count-3)%mod +\\n                (num==1 ? getval(num,count-4) : 0)%mod\\n            )%mod;\\n    }\\n    int countTexts(string str) {\\n        create_map();\\n        str.push_back(\\'#\\');\\n        int n= str.size();\\n        long long  ans=1;\\n        int count=1;\\n        for(int i=0;i<n-1;i++){\\n            if(str[i]==str[i+1])\\n                count++;\\n            else{\\n                int num=str[i]-\\'0\\';\\n                long long  curr = getval(num==7 || num==9,count)%mod;\\n                count=1;\\n                ans=(ans *curr)%mod;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2515500,
                "title": "c-intutive",
                "content": "\\n\\n\\nclass Solution {\\npublic:\\n   \\n    int countTexts(string pK) \\n    {\\n        int mod = 1e9+7;\\n        \\n        vector<int> dp(pK.length()+1,1);\\n        \\n        \\n        for(int idx=pK.length()-1;idx>=0;idx--){\\n            dp[idx] = dp[idx+1]%mod;\\n        if(idx<pK.length()-1 and pK[idx+1]==pK[idx])\\n        {\\n        dp[idx]=(dp[idx]+dp[idx+2])%mod;\\n        if(idx<pK.length()-2 and pK[idx+1]==pK[idx+2]) dp[idx]=(dp[idx]+dp[idx+3])%mod;\\n        else continue;\\n        if(idx<pK.length()-3 and pK[idx+2]==pK[idx+3] and (pK[idx]==\\'7\\'||pK[idx]==\\'9\\'))                             {dp[idx]=(dp[idx]+dp[idx+4])%mod;}\\n        }\\n        }\\n         \\n        return dp[0]%mod;\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n   \\n    int countTexts(string pK) \\n    {\\n        int mod = 1e9+7;\\n        \\n        vector<int> dp(pK.length()+1,1);\\n        \\n        \\n        for(int idx=pK.length()-1;idx>=0;idx--){\\n            dp[idx] = dp[idx+1]%mod;\\n        if(idx<pK.length()-1 and pK[idx+1]==pK[idx])\\n        {\\n        dp[idx]=(dp[idx]+dp[idx+2])%mod;\\n        if(idx<pK.length()-2 and pK[idx+1]==pK[idx+2]) dp[idx]=(dp[idx]+dp[idx+3])%mod;\\n        else continue;\\n        if(idx<pK.length()-3 and pK[idx+2]==pK[idx+3] and (pK[idx]==\\'7\\'||pK[idx]==\\'9\\'))                             {dp[idx]=(dp[idx]+dp[idx+4])%mod;}",
                "codeTag": "Java"
            },
            {
                "id": 2457241,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countTexts(string pressedKeys) {\\n        std::vector<long> dp(pressedKeys.size(), 0);\\n        dp[0] = 1;\\n        for (int i = 1; i < pressedKeys.size(); ++i) {\\n            char ch = pressedKeys[i];\\n            int max_num = (ch == \\'7\\' || ch == \\'9\\') ? 4 : 3;\\n\\n            for (int j = 0; j < max_num; ++j) {\\n                if (i - j < 0 || pressedKeys[i - j] != ch) break;\\n                dp[i] += (i - j - 1 < 0) ? 1 : dp[i - j - 1];\\n            }\\n\\n            dp[i] %= modulo_;\\n        }\\n        \\n        return dp.back();\\n    }\\nprivate:\\n    int modulo_ = 1000000007;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countTexts(string pressedKeys) {\\n        std::vector<long> dp(pressedKeys.size(), 0);\\n        dp[0] = 1;\\n        for (int i = 1; i < pressedKeys.size(); ++i) {\\n            char ch = pressedKeys[i];\\n            int max_num = (ch == \\'7\\' || ch == \\'9\\') ? 4 : 3;\\n\\n            for (int j = 0; j < max_num; ++j) {\\n                if (i - j < 0 || pressedKeys[i - j] != ch) break;\\n                dp[i] += (i - j - 1 < 0) ? 1 : dp[i - j - 1];\\n            }\\n\\n            dp[i] %= modulo_;\\n        }\\n        \\n        return dp.back();\\n    }\\nprivate:\\n    int modulo_ = 1000000007;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260337,
                "title": "c-dp-solution-clean-and-easy-to-understand",
                "content": "class Solution {\\npublic:\\n\\n    int mod = 1e9+7;\\n \\n    int countTexts(string s) {\\n\\t\\n        int n = s.length();\\n        vector<int> dp(n+1,0);\\n        \\n        dp[0] = 1;\\n        int ans = 0;\\n        \\n        for(int i = 1; i < n+1; i++){\\n            \\n            dp[i] = (dp[i] + dp[i-1]) % mod;\\n            \\n            \\n            if(i > 1 && s[i-1] == s[i-2])\\n                dp[i] =(dp[i] + dp[i-2]) % mod;\\n            \\n            \\n            if(i > 2 && s[i-1] == s[i-2] && s[i-2] == s[i-3])\\n                dp[i] =(dp[i] + dp[i-3]) % mod;\\n            \\n            \\n            if(s[i-1] == \\'7\\' || s[i-1] == \\'9\\')\\n                if(i > 3 && s[i-1] == s[i-2] && s[i-1] == s[i-3] && s[i-1] == s[i-4])\\n                    dp[i] =(dp[i] + dp[i-4]) % mod;\\n            \\n        }\\n        \\n        return dp[n];\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int mod = 1e9+7;\\n \\n    int countTexts(string s) {\\n\\t\\n        int n = s.length();\\n        vector<int> dp(n+1,0);\\n        \\n        dp[0] = 1;\\n        int ans = 0;\\n        \\n        for(int i = 1; i < n+1; i++){\\n            \\n            dp[i] = (dp[i] + dp[i-1]) % mod;\\n            \\n            \\n            if(i > 1 && s[i-1] == s[i-2])\\n                dp[i] =(dp[i] + dp[i-2]) % mod;\\n            \\n            \\n            if(i > 2 && s[i-1] == s[i-2] && s[i-2] == s[i-3])\\n                dp[i] =(dp[i] + dp[i-3]) % mod;\\n            \\n            \\n            if(s[i-1] == \\'7\\' || s[i-1] == \\'9\\')\\n                if(i > 3 && s[i-1] == s[i-2] && s[i-1] == s[i-3] && s[i-1] == s[i-4])\\n                    dp[i] =(dp[i] + dp[i-4]) % mod;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2136393,
                "title": "c-easy-to-understand-simple-dp-recursion-memoization",
                "content": "```\\n#define ll long long int\\nll mod=1e9+7;\\nclass Solution {\\npublic:\\n    int solve(string &s,int i,int n,vector<int> &dp)\\n    {\\n        if(i>=n)\\n        {\\n            return 1;\\n        }\\n        if(dp[i]!=-1)\\n        {\\n            return dp[i];\\n        }\\n        ll ans=0;\\n        if(i+1<n&&s[i]==s[i+1])\\n        {\\n            ans+=solve(s,i+2,n,dp)%mod;\\n            if(i+2<n&&s[i]==s[i+2])\\n            {\\n                ans+=solve(s,i+3,n,dp)%mod;\\n                if(i+3<n&&s[i]==s[i+3]&&(s[i]==\\'9\\'||s[i]==\\'7\\'))\\n                {\\n                    ans+=solve(s,i+4,n,dp)%mod;\\n                }\\n            }\\n        }\\n        ans=(ans%mod+solve(s,i+1,n,dp)%mod)%mod;\\n        return dp[i]=ans%mod;\\n    }\\n    int countTexts(string s) {\\n        int n=s.size();\\n        vector<int> dp(n+1,-1);\\n        return solve(s,0,n,dp);\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\n#define ll long long int\\nll mod=1e9+7;\\nclass Solution {\\npublic:\\n    int solve(string &s,int i,int n,vector<int> &dp)\\n    {\\n        if(i>=n)\\n        {\\n            return 1;\\n        }\\n        if(dp[i]!=-1)\\n        {\\n            return dp[i];\\n        }\\n        ll ans=0;\\n        if(i+1<n&&s[i]==s[i+1])\\n        {\\n            ans+=solve(s,i+2,n,dp)%mod;\\n            if(i+2<n&&s[i]==s[i+2])\\n            {\\n                ans+=solve(s,i+3,n,dp)%mod;\\n                if(i+3<n&&s[i]==s[i+3]&&(s[i]==\\'9\\'||s[i]==\\'7\\'))\\n                {\\n                    ans+=solve(s,i+4,n,dp)%mod;\\n                }\\n            }\\n        }\\n        ans=(ans%mod+solve(s,i+1,n,dp)%mod)%mod;\\n        return dp[i]=ans%mod;\\n    }\\n    int countTexts(string s) {\\n        int n=s.size();\\n        vector<int> dp(n+1,-1);\\n        return solve(s,0,n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2135621,
                "title": "c-simple-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int countTexts(string &s) \\n    {\\n        int n=s.size();\\n        int dp[n];\\n        dp[0]=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            dp[i]=dp[i-1];\\n            if(s[i]==s[i-1])\\n                dp[i]=i>1?(dp[i]+dp[i-2]):(dp[i]+1);\\n            dp[i]%=mod;\\n            if(i>1 && s[i]==s[i-1] && s[i]==s[i-2])\\n                dp[i]=i>2?(dp[i]+dp[i-3]):(dp[i]+1);\\n            dp[i]%=mod;\\n            if(i>2 && (s[i]==\\'7\\' || s[i]==\\'9\\') && s[i]==s[i-1] && s[i]==s[i-2] && s[i]==s[i-3])\\n                dp[i]=i>3?(dp[i]+dp[i-4]):(dp[i]+1);\\n            dp[i]%=mod;\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int countTexts(string &s) \\n    {\\n        int n=s.size();\\n        int dp[n];\\n        dp[0]=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            dp[i]=dp[i-1];\\n            if(s[i]==s[i-1])\\n                dp[i]=i>1?(dp[i]+dp[i-2]):(dp[i]+1);\\n            dp[i]%=mod;\\n            if(i>1 && s[i]==s[i-1] && s[i]==s[i-2])\\n                dp[i]=i>2?(dp[i]+dp[i-3]):(dp[i]+1);\\n            dp[i]%=mod;\\n            if(i>2 && (s[i]==\\'7\\' || s[i]==\\'9\\') && s[i]==s[i-1] && s[i]==s[i-2] && s[i]==s[i-3])\\n                dp[i]=i>3?(dp[i]+dp[i-4]):(dp[i]+1);\\n            dp[i]%=mod;\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2119602,
                "title": "dp-python-3-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def countTexts(self, s: str) -> int:\\n        mod = 1000000007\\n        def rec2(n):\\n            if n==1:\\n                return 1\\n            if n==2:\\n                return 2\\n            if n==3:\\n                return 4\\n            if n==4:\\n                return 8\\n            dp = [0]*(n+1)\\n            dp[1]=1\\n            dp[2]=2\\n            dp[3] = 4\\n            dp[4] = 8\\n            for i in range(5,n+1):\\n                dp[i] = dp[i-1]+dp[i-2]+dp[i-3]+dp[i-4]\\n\\n            return dp[-1]\\n            \\n\\n        def rec(n):\\n            \\n            if n==1:\\n                return 1\\n            if n==2:\\n                return 2\\n            if n==3:\\n                return 4\\n            dp = [0]*(n+1)\\n            dp[1]=1\\n            dp[2]=2\\n            dp[3] = 4\\n            for i in range(4,n+1):\\n                dp[i] = dp[i-1]+dp[i-2]+dp[i-3]\\n\\n            return dp[-1]\\n        ans = 1\\n        cnt = 1\\n        for i in range(1,len(s)):\\n            if s[i]!=s[i-1]:\\n                if s[i-1] not in[\\'7\\',\\'9\\']:\\n                    ans*=(rec(cnt)%mod)\\n                else:\\n                    ans*=rec2(cnt)%mod\\n                cnt = 1\\n            else:\\n                cnt+=1\\n        ans = ans*rec(cnt) if s[-1] not in[\\'7\\',\\'9\\'] else ans*rec2(cnt)\\n        return ans%mod\\n\\t```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countTexts(self, s: str) -> int:\\n        mod = 1000000007\\n        def rec2(n):\\n            if n==1:\\n                return 1\\n            if n==2:\\n                return 2\\n            if n==3:\\n                return 4\\n            if n==4:\\n                return 8\\n            dp = [0]*(n+1)\\n            dp[1]=1\\n            dp[2]=2\\n            dp[3] = 4\\n            dp[4] = 8\\n            for i in range(5,n+1):\\n                dp[i] = dp[i-1]+dp[i-2]+dp[i-3]+dp[i-4]\\n\\n            return dp[-1]\\n            \\n\\n        def rec(n):\\n            \\n            if n==1:\\n                return 1\\n            if n==2:\\n                return 2\\n            if n==3:\\n                return 4\\n            dp = [0]*(n+1)\\n            dp[1]=1\\n            dp[2]=2\\n            dp[3] = 4\\n            for i in range(4,n+1):\\n                dp[i] = dp[i-1]+dp[i-2]+dp[i-3]\\n\\n            return dp[-1]\\n        ans = 1\\n        cnt = 1\\n        for i in range(1,len(s)):\\n            if s[i]!=s[i-1]:\\n                if s[i-1] not in[\\'7\\',\\'9\\']:\\n                    ans*=(rec(cnt)%mod)\\n                else:\\n                    ans*=rec2(cnt)%mod\\n                cnt = 1\\n            else:\\n                cnt+=1\\n        ans = ans*rec(cnt) if s[-1] not in[\\'7\\',\\'9\\'] else ans*rec2(cnt)\\n        return ans%mod\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2109394,
                "title": "c-top-down-dp-recursion-with-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int helper(string& s,int idx,vector<int>& dp){\\n        if(idx==s.size()){\\n            return 1;\\n        }\\n        if(dp[idx]!=-1){\\n            return dp[idx];\\n        }\\n        int n=s.size();\\n        int res=0;\\n        res+=helper(s,idx+1,dp);\\n        if(idx+1<n and s[idx+1]==s[idx]){\\n            res+=helper(s,idx+2,dp);\\n            res%=mod;\\n        }\\n        if(idx+2<n and s[idx+1]==s[idx] and s[idx+2]==s[idx]){\\n            res+=helper(s,idx+3,dp);\\n            res%=mod;\\n        }\\n        if((s[idx]==\\'7\\' or s[idx]==\\'9\\') and idx+3<n and s[idx+1]==s[idx] and s[idx+2]==s[idx] and s[idx+3]==s[idx]){\\n            res+=helper(s,idx+4,dp);\\n            res%=mod;\\n        }\\n        return dp[idx]=res;\\n    }\\n    int countTexts(string s) {\\n        vector<int> dp(s.size(),-1);\\n        return helper(s,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int helper(string& s,int idx,vector<int>& dp){\\n        if(idx==s.size()){\\n            return 1;\\n        }\\n        if(dp[idx]!=-1){\\n            return dp[idx];\\n        }\\n        int n=s.size();\\n        int res=0;\\n        res+=helper(s,idx+1,dp);\\n        if(idx+1<n and s[idx+1]==s[idx]){\\n            res+=helper(s,idx+2,dp);\\n            res%=mod;\\n        }\\n        if(idx+2<n and s[idx+1]==s[idx] and s[idx+2]==s[idx]){\\n            res+=helper(s,idx+3,dp);\\n            res%=mod;\\n        }\\n        if((s[idx]==\\'7\\' or s[idx]==\\'9\\') and idx+3<n and s[idx+1]==s[idx] and s[idx+2]==s[idx] and s[idx+3]==s[idx]){\\n            res+=helper(s,idx+4,dp);\\n            res%=mod;\\n        }\\n        return dp[idx]=res;\\n    }\\n    int countTexts(string s) {\\n        vector<int> dp(s.size(),-1);\\n        return helper(s,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2080203,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8 The ART of Dynamic Programming:](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master)\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n\\nPreprocess the input to find the length of each `run` of same consecutive characters, then recursively \"consume\" each `run`.  This recursive \"consuming\" of characters is similar to [91. Decode Ways](https://leetcode.com/problems/decode-ways/discuss/117143/The-ART-of-Dynamic-Programming).\\n\\n---\\n\\n**Note:** if this `run` concept doesn\\'t make sense, look at the supplemental solutions at the very bottom (they are verbosely how I started to solve this problem).\\n\\nWe can recursively consider \"consuming\":\\n\\na. one same consecutive character: `s[i]`\\nb. two same consecutive characters: `s[i], s[i + 1]`\\nc. three same consecutive characters: `s[i], s[i + 1], s[i + 2]`\\nd. four same consecutive characters: `s[i], s[i + 1], s[i + 2], s[i + 3]` \\uD83D\\uDC48 (this use case is only applicable for characters `\\'7\\'` and `\\'9\\'`)\\n\\n---\\n\\n**Kotlin Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\n    fun countTexts(s: String): Int {\\n        var N = s.length\\n        var run = IntArray(N) { 1 }\\n        for (i in N - 2 downTo(0))\\n            if (s[i] == s[i + 1])\\n                run[i] = Math.min(1 + run[i + 1], if (s[i] == \\'7\\' || s[i] == \\'9\\') 4 else 3)\\n        fun go(i: Int = 0): Int {\\n            if (i == N)\\n                return 1\\n            var cnt = 0\\n            for (k in 1..run[i])\\n                if (i + k <= N)\\n                    cnt += go(i + k)\\n            return cnt\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\n    fun countTexts(s: String, m: MutableMap<Int, Int> = mutableMapOf<Int, Int>()): Int {\\n        var N = s.length\\n        var run = IntArray(N) { 1 }\\n        for (i in N - 2 downTo(0))\\n            if (s[i] == s[i + 1])\\n                run[i] = Math.min(1 + run[i + 1], if (s[i] == \\'7\\' || s[i] == \\'9\\') 4 else 3)\\n        fun go(i: Int = 0): Int {\\n            if (i == N)\\n                return 1\\n            if (!m.contains(i)) {\\n                var cnt = 0\\n                for (k in 1..run[i])\\n                    if (i + k <= N)\\n                        cnt = (cnt + go(i + k)) % (1e9 + 7).toInt()\\n                m[i] = cnt\\n            }\\n            return m[i]!!\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\n    fun countTexts(s: String, m: MutableMap<Int, Int> = mutableMapOf<Int, Int>()): Int {\\n        var N = s.length\\n        var run = IntArray(N) { 1 }\\n        for (i in N - 2 downTo(0))\\n            if (s[i] == s[i + 1])\\n                run[i] = Math.min(1 + run[i + 1], if (s[i] == \\'7\\' || s[i] == \\'9\\') 4 else 3)\\n        var dp = IntArray(N + 1) { 0 }\\n        dp[N] = 1\\n        for (i in N - 1 downTo 0)\\n            for (k in 1..run[i])\\n                if (i + k <= N)\\n                    dp[i] = (dp[i] + dp[i + k]) % (1e9 + 7).toInt()\\n        return dp[0]\\n    }\\n}\\n```\\n\\n---\\n\\n**Javascript Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nlet countTexts = s => {\\n    let N = s.length;\\n    let run = Array(N).fill(1);\\n    for (let i = N - 1; 0 <= i; --i)\\n        if (s[i] == s[i + 1])\\n            run[i] = Math.min(1 + run[i + 1], s[i] == \\'7\\' || s[i] == \\'9\\' ? 4 : 3);\\n    let go = (i = 0, cnt = 0) => {\\n        if (i == N)\\n            return 1;\\n        for (let k = 1; k <= run[i]; ++k)\\n            if (i + k <= N)\\n                cnt += go(i + k);\\n        return cnt;\\n    };\\n    return go();\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nlet countTexts = (s, m = new Map()) => {\\n    let N = s.length;\\n    let run = Array(N).fill(1);\\n    for (let i = N - 1; 0 <= i; --i)\\n        if (s[i] == s[i + 1])\\n            run[i] = Math.min(1 + run[i + 1], s[i] == \\'7\\' || s[i] == \\'9\\' ? 4 : 3);\\n    let go = (i = 0, cnt = 0) => {\\n        if (i == N)\\n            return 1;\\n        if (!m.has(i)) {\\n            for (let k = 1; k <= run[i]; ++k)\\n                if (i + k <= N)\\n                    cnt = (cnt + go(i + k)) % Number(1e9 + 7);\\n            m.set(i, cnt);\\n        }\\n        return m.get(i);\\n    };\\n    return go();\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nlet countTexts = (s, m = new Map()) => {\\n    let N = s.length;\\n    let run = Array(N).fill(1);\\n    for (let i = N - 1; 0 <= i; --i)\\n        if (s[i] == s[i + 1])\\n            run[i] = Math.min(1 + run[i + 1], s[i] == \\'7\\' || s[i] == \\'9\\' ? 4 : 3);\\n    let dp = Array(N + 1).fill(0);\\n    dp[N] = 1;\\n    for (let i = N - 1; 0 <= i; --i)\\n        for (let k = 1; k <= run[i]; ++k)\\n            if (i + k <= N)\\n                dp[i] = (dp[i] + dp[i + k]) % Number(1e9 + 7);\\n    return dp[0];\\n};\\n```\\n\\n---\\n\\n**Python3 Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution:\\n    def countTexts(self, s: str) -> int:\\n        N = len(s)\\n        run = [1] * N\\n        for i in range(N - 2, -1, -1):\\n            if s[i] == s[i + 1]:\\n                run[i] = min(1 + run[i + 1], 4 if s[i] == \\'7\\' or s[i] == \\'9\\' else 3)\\n        def go(i = 0, cnt = 0):\\n            if i == N:\\n                return 1\\n            for k in range(1, run[i] + 1):\\n                if i + k <= N:\\n                    cnt = (cnt + go(i + k)) % int(1e9 + 7)\\n            return cnt\\n        return go()\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution:\\n    def countTexts(self, s: str) -> int:\\n        N = len(s)\\n        run = [1] * N\\n        for i in range(N - 2, -1, -1):\\n            if s[i] == s[i + 1]:\\n                run[i] = min(1 + run[i + 1], 4 if s[i] == \\'7\\' or s[i] == \\'9\\' else 3)\\n        @cache\\n        def go(i = 0, cnt = 0):\\n            if i == N:\\n                return 1\\n            for k in range(1, run[i] + 1):\\n                if i + k <= N:\\n                    cnt = (cnt + go(i + k)) % int(1e9 + 7)\\n            return cnt\\n        return go()\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution:\\n    def countTexts(self, s: str) -> int:\\n        N = len(s)\\n        run = [1] * N\\n        for i in range(N - 2, -1, -1):\\n            if s[i] == s[i + 1]:\\n                run[i] = min(1 + run[i + 1], 4 if s[i] == \\'7\\' or s[i] == \\'9\\' else 3)\\n        dp = [0] * (N + 1)\\n        dp[N] = 1\\n        for i in range(N - 1, -1, -1):\\n            for k in range(1, run[i] + 1):\\n                if i + k <= N:\\n                    dp[i] = (dp[i] + dp[i + k]) % int(1e9 + 7)\\n        return dp[0]\\n```\\n\\n---\\n\\n**C++ Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int)>;\\n    int countTexts(string s) {\\n        int N = s.size();\\n        VI run(N, 1);\\n        for (auto i{ N - 2 }; 0 <= i; --i)\\n            if (s[i] == s[i + 1])\\n                run[i] = min(1 + run[i + 1], s[i] == \\'7\\' || s[i] == \\'9\\' ? 4 : 3);\\n        fun go = [&](auto i) {\\n            if (i == N)\\n                return 1;\\n            auto cnt = 0;\\n            for (auto k{ 1 }; k <= run[i]; ++k)\\n                if (i + k <= N)\\n                    cnt = (cnt + go(i + k)) % int(1e9 + 7);\\n            return cnt;\\n        };\\n        return go(0);\\n    }\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int)>;\\n    using Map = unordered_map<int, int>;\\n    int countTexts(string s, Map m = {}) {\\n        int N = s.size();\\n        VI run(N, 1);\\n        for (auto i{ N - 2 }; 0 <= i; --i)\\n            if (s[i] == s[i + 1])\\n                run[i] = min(1 + run[i + 1], s[i] == \\'7\\' || s[i] == \\'9\\' ? 4 : 3);\\n        fun go = [&](auto i) {\\n            if (i == N)\\n                return 1;\\n            if (m.find(i) == m.end()) {\\n                auto cnt = 0;\\n                for (auto k{ 1 }; k <= run[i]; ++k)\\n                    if (i + k <= N)\\n                        cnt = (cnt + go(i + k)) % int(1e9 + 7);\\n                m[i] = cnt;\\n            }\\n            return m[i];\\n        };\\n        return go(0);\\n    }\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int)>;\\n    using Map = unordered_map<int, int>;\\n    int countTexts(string s, Map m = {}) {\\n        int N = s.size();\\n        VI run(N, 1);\\n        for (auto i{ N - 2 }; 0 <= i; --i)\\n            if (s[i] == s[i + 1])\\n                run[i] = min(1 + run[i + 1], s[i] == \\'7\\' || s[i] == \\'9\\' ? 4 : 3);\\n        VI dp(N + 1, 0);\\n        dp[N] = 1;\\n        for (auto i{ N - 1 }; 0 <= i; --i)\\n            for (auto k{ 1 }; k <= run[i]; ++k)\\n                if (i + k <= N)\\n                    dp[i] = (dp[i] + dp[i + k]) % int(1e9 + 7);\\n        return dp[0];\\n    }\\n};\\n```\\n\\n---\\n\\n**Supplemental Solutions:** the reason for the `run` preprocessing in the solutions above is because it simplifies this redundant and verbose code...\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nlet countTexts = s => {\\n    let N = s.length;\\n    let go = (i = 0) => {\\n        if (i == N)\\n            return 1;\\n        let a = go(i + 1),\\n            b = i + 1 < N && s[i] == s[i + 1] ? go(i + 2) : 0,\\n            c = i + 2 < N && s[i] == s[i + 1] && s[i + 1] == s[i + 2] ? go(i + 3) : 0,\\n            d = i + 3 < N && s[i] == s[i + 1] && s[i + 1] == s[i + 2] && s[i + 2] == s[i + 3] && (s[i] == \\'7\\' || s[i] == \\'9\\') ? go(i + 4) : 0;\\n        return (a + b + c + d) % Number(1e9 + 7);\\n    };\\n    return go();\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nlet countTexts = (s, m = new Map()) => {\\n    let N = s.length;\\n    let go = (i = 0) => {\\n        if (i == N)\\n            return 1;\\n        if (!m.has(i)) {\\n            let a = go(i + 1),\\n                b = i + 1 < N && s[i] == s[i + 1] ? go(i + 2) : 0,\\n                c = i + 2 < N && s[i] == s[i + 1] && s[i + 1] == s[i + 2] ? go(i + 3) : 0,\\n                d = i + 3 < N && s[i] == s[i + 1] && s[i + 1] == s[i + 2] && s[i + 2] == s[i + 3] && (s[i] == \\'7\\' || s[i] == \\'9\\') ? go(i + 4) : 0;\\n            m.set(i, (a + b + c + d) % Number(1e9 + 7));\\n        }\\n        return m.get(i);\\n    };\\n    return go();\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nlet countTexts = s => {\\n    let N = s.length;\\n    let dp = Array(N + 1).fill(0);\\n    dp[N] = 1;\\n    for (let i = N - 1; 0 <= i; --i) {\\n        let a = dp[i + 1],\\n            b = i + 1 < N && s[i] == s[i + 1] ? dp[i + 2] : 0,\\n            c = i + 2 < N && s[i] == s[i + 1] && s[i + 1] == s[i + 2] ? dp[i + 3] : 0,\\n            d = i + 3 < N && s[i] == s[i + 1] && s[i + 1] == s[i + 2] && s[i + 2] == s[i + 3] && (s[i] == \\'7\\' || s[i] == \\'9\\') ? dp[i + 4] : 0;\\n        dp[i] = (a + b + c + d) % Number(1e9 + 7);\\n    }\\n    return dp[0];\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun countTexts(s: String): Int {\\n        var N = s.length\\n        var run = IntArray(N) { 1 }\\n        for (i in N - 2 downTo(0))\\n            if (s[i] == s[i + 1])\\n                run[i] = Math.min(1 + run[i + 1], if (s[i] == \\'7\\' || s[i] == \\'9\\') 4 else 3)\\n        fun go(i: Int = 0): Int {\\n            if (i == N)\\n                return 1\\n            var cnt = 0\\n            for (k in 1..run[i])\\n                if (i + k <= N)\\n                    cnt += go(i + k)\\n            return cnt\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun countTexts(s: String, m: MutableMap<Int, Int> = mutableMapOf<Int, Int>()): Int {\\n        var N = s.length\\n        var run = IntArray(N) { 1 }\\n        for (i in N - 2 downTo(0))\\n            if (s[i] == s[i + 1])\\n                run[i] = Math.min(1 + run[i + 1], if (s[i] == \\'7\\' || s[i] == \\'9\\') 4 else 3)\\n        fun go(i: Int = 0): Int {\\n            if (i == N)\\n                return 1\\n            if (!m.contains(i)) {\\n                var cnt = 0\\n                for (k in 1..run[i])\\n                    if (i + k <= N)\\n                        cnt = (cnt + go(i + k)) % (1e9 + 7).toInt()\\n                m[i] = cnt\\n            }\\n            return m[i]!!\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun countTexts(s: String, m: MutableMap<Int, Int> = mutableMapOf<Int, Int>()): Int {\\n        var N = s.length\\n        var run = IntArray(N) { 1 }\\n        for (i in N - 2 downTo(0))\\n            if (s[i] == s[i + 1])\\n                run[i] = Math.min(1 + run[i + 1], if (s[i] == \\'7\\' || s[i] == \\'9\\') 4 else 3)\\n        var dp = IntArray(N + 1) { 0 }\\n        dp[N] = 1\\n        for (i in N - 1 downTo 0)\\n            for (k in 1..run[i])\\n                if (i + k <= N)\\n                    dp[i] = (dp[i] + dp[i + k]) % (1e9 + 7).toInt()\\n        return dp[0]\\n    }\\n}\\n```\n```\\nlet countTexts = s => {\\n    let N = s.length;\\n    let run = Array(N).fill(1);\\n    for (let i = N - 1; 0 <= i; --i)\\n        if (s[i] == s[i + 1])\\n            run[i] = Math.min(1 + run[i + 1], s[i] == \\'7\\' || s[i] == \\'9\\' ? 4 : 3);\\n    let go = (i = 0, cnt = 0) => {\\n        if (i == N)\\n            return 1;\\n        for (let k = 1; k <= run[i]; ++k)\\n            if (i + k <= N)\\n                cnt += go(i + k);\\n        return cnt;\\n    };\\n    return go();\\n};\\n```\n```\\nlet countTexts = (s, m = new Map()) => {\\n    let N = s.length;\\n    let run = Array(N).fill(1);\\n    for (let i = N - 1; 0 <= i; --i)\\n        if (s[i] == s[i + 1])\\n            run[i] = Math.min(1 + run[i + 1], s[i] == \\'7\\' || s[i] == \\'9\\' ? 4 : 3);\\n    let go = (i = 0, cnt = 0) => {\\n        if (i == N)\\n            return 1;\\n        if (!m.has(i)) {\\n            for (let k = 1; k <= run[i]; ++k)\\n                if (i + k <= N)\\n                    cnt = (cnt + go(i + k)) % Number(1e9 + 7);\\n            m.set(i, cnt);\\n        }\\n        return m.get(i);\\n    };\\n    return go();\\n};\\n```\n```\\nlet countTexts = (s, m = new Map()) => {\\n    let N = s.length;\\n    let run = Array(N).fill(1);\\n    for (let i = N - 1; 0 <= i; --i)\\n        if (s[i] == s[i + 1])\\n            run[i] = Math.min(1 + run[i + 1], s[i] == \\'7\\' || s[i] == \\'9\\' ? 4 : 3);\\n    let dp = Array(N + 1).fill(0);\\n    dp[N] = 1;\\n    for (let i = N - 1; 0 <= i; --i)\\n        for (let k = 1; k <= run[i]; ++k)\\n            if (i + k <= N)\\n                dp[i] = (dp[i] + dp[i + k]) % Number(1e9 + 7);\\n    return dp[0];\\n};\\n```\n```\\nclass Solution:\\n    def countTexts(self, s: str) -> int:\\n        N = len(s)\\n        run = [1] * N\\n        for i in range(N - 2, -1, -1):\\n            if s[i] == s[i + 1]:\\n                run[i] = min(1 + run[i + 1], 4 if s[i] == \\'7\\' or s[i] == \\'9\\' else 3)\\n        def go(i = 0, cnt = 0):\\n            if i == N:\\n                return 1\\n            for k in range(1, run[i] + 1):\\n                if i + k <= N:\\n                    cnt = (cnt + go(i + k)) % int(1e9 + 7)\\n            return cnt\\n        return go()\\n```\n```\\nclass Solution:\\n    def countTexts(self, s: str) -> int:\\n        N = len(s)\\n        run = [1] * N\\n        for i in range(N - 2, -1, -1):\\n            if s[i] == s[i + 1]:\\n                run[i] = min(1 + run[i + 1], 4 if s[i] == \\'7\\' or s[i] == \\'9\\' else 3)\\n        @cache\\n        def go(i = 0, cnt = 0):\\n            if i == N:\\n                return 1\\n            for k in range(1, run[i] + 1):\\n                if i + k <= N:\\n                    cnt = (cnt + go(i + k)) % int(1e9 + 7)\\n            return cnt\\n        return go()\\n```\n```\\nclass Solution:\\n    def countTexts(self, s: str) -> int:\\n        N = len(s)\\n        run = [1] * N\\n        for i in range(N - 2, -1, -1):\\n            if s[i] == s[i + 1]:\\n                run[i] = min(1 + run[i + 1], 4 if s[i] == \\'7\\' or s[i] == \\'9\\' else 3)\\n        dp = [0] * (N + 1)\\n        dp[N] = 1\\n        for i in range(N - 1, -1, -1):\\n            for k in range(1, run[i] + 1):\\n                if i + k <= N:\\n                    dp[i] = (dp[i] + dp[i + k]) % int(1e9 + 7)\\n        return dp[0]\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int)>;\\n    int countTexts(string s) {\\n        int N = s.size();\\n        VI run(N, 1);\\n        for (auto i{ N - 2 }; 0 <= i; --i)\\n            if (s[i] == s[i + 1])\\n                run[i] = min(1 + run[i + 1], s[i] == \\'7\\' || s[i] == \\'9\\' ? 4 : 3);\\n        fun go = [&](auto i) {\\n            if (i == N)\\n                return 1;\\n            auto cnt = 0;\\n            for (auto k{ 1 }; k <= run[i]; ++k)\\n                if (i + k <= N)\\n                    cnt = (cnt + go(i + k)) % int(1e9 + 7);\\n            return cnt;\\n        };\\n        return go(0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int)>;\\n    using Map = unordered_map<int, int>;\\n    int countTexts(string s, Map m = {}) {\\n        int N = s.size();\\n        VI run(N, 1);\\n        for (auto i{ N - 2 }; 0 <= i; --i)\\n            if (s[i] == s[i + 1])\\n                run[i] = min(1 + run[i + 1], s[i] == \\'7\\' || s[i] == \\'9\\' ? 4 : 3);\\n        fun go = [&](auto i) {\\n            if (i == N)\\n                return 1;\\n            if (m.find(i) == m.end()) {\\n                auto cnt = 0;\\n                for (auto k{ 1 }; k <= run[i]; ++k)\\n                    if (i + k <= N)\\n                        cnt = (cnt + go(i + k)) % int(1e9 + 7);\\n                m[i] = cnt;\\n            }\\n            return m[i];\\n        };\\n        return go(0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int)>;\\n    using Map = unordered_map<int, int>;\\n    int countTexts(string s, Map m = {}) {\\n        int N = s.size();\\n        VI run(N, 1);\\n        for (auto i{ N - 2 }; 0 <= i; --i)\\n            if (s[i] == s[i + 1])\\n                run[i] = min(1 + run[i + 1], s[i] == \\'7\\' || s[i] == \\'9\\' ? 4 : 3);\\n        VI dp(N + 1, 0);\\n        dp[N] = 1;\\n        for (auto i{ N - 1 }; 0 <= i; --i)\\n            for (auto k{ 1 }; k <= run[i]; ++k)\\n                if (i + k <= N)\\n                    dp[i] = (dp[i] + dp[i + k]) % int(1e9 + 7);\\n        return dp[0];\\n    }\\n};\\n```\n```\\nlet countTexts = s => {\\n    let N = s.length;\\n    let go = (i = 0) => {\\n        if (i == N)\\n            return 1;\\n        let a = go(i + 1),\\n            b = i + 1 < N && s[i] == s[i + 1] ? go(i + 2) : 0,\\n            c = i + 2 < N && s[i] == s[i + 1] && s[i + 1] == s[i + 2] ? go(i + 3) : 0,\\n            d = i + 3 < N && s[i] == s[i + 1] && s[i + 1] == s[i + 2] && s[i + 2] == s[i + 3] && (s[i] == \\'7\\' || s[i] == \\'9\\') ? go(i + 4) : 0;\\n        return (a + b + c + d) % Number(1e9 + 7);\\n    };\\n    return go();\\n};\\n```\n```\\nlet countTexts = (s, m = new Map()) => {\\n    let N = s.length;\\n    let go = (i = 0) => {\\n        if (i == N)\\n            return 1;\\n        if (!m.has(i)) {\\n            let a = go(i + 1),\\n                b = i + 1 < N && s[i] == s[i + 1] ? go(i + 2) : 0,\\n                c = i + 2 < N && s[i] == s[i + 1] && s[i + 1] == s[i + 2] ? go(i + 3) : 0,\\n                d = i + 3 < N && s[i] == s[i + 1] && s[i + 1] == s[i + 2] && s[i + 2] == s[i + 3] && (s[i] == \\'7\\' || s[i] == \\'9\\') ? go(i + 4) : 0;\\n            m.set(i, (a + b + c + d) % Number(1e9 + 7));\\n        }\\n        return m.get(i);\\n    };\\n    return go();\\n};\\n```\n```\\nlet countTexts = s => {\\n    let N = s.length;\\n    let dp = Array(N + 1).fill(0);\\n    dp[N] = 1;\\n    for (let i = N - 1; 0 <= i; --i) {\\n        let a = dp[i + 1],\\n            b = i + 1 < N && s[i] == s[i + 1] ? dp[i + 2] : 0,\\n            c = i + 2 < N && s[i] == s[i + 1] && s[i + 1] == s[i + 2] ? dp[i + 3] : 0,\\n            d = i + 3 < N && s[i] == s[i + 1] && s[i + 1] == s[i + 2] && s[i + 2] == s[i + 3] && (s[i] == \\'7\\' || s[i] == \\'9\\') ? dp[i + 4] : 0;\\n        dp[i] = (a + b + c + d) % Number(1e9 + 7);\\n    }\\n    return dp[0];\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2037505,
                "title": "c-dp-solution",
                "content": "\\'\\'\\'\\n\\n    int countTexts(string pressedKeys) {\\n        int n = pressedKeys.length();\\n        vector<long long> dp(n+1);\\n        dp[0]=1;\\n        int cnt;\\n        for(int i=0;i<pressedKeys.size();i++)\\n        {\\n            int j=i;\\n            if(pressedKeys[i]==\\'7\\' || pressedKeys[i]==\\'9\\')\\n            {\\n                cnt=4;\\n            }\\n            else\\n            {\\n                cnt=3;\\n            }\\n            while(j>=0 && cnt>0 && pressedKeys[j]==pressedKeys[i])\\n            {\\n                dp[i+1] = (dp[i+1] + dp[j])%1000000007;\\n                j--;\\n                cnt--;\\n            }\\n        }\\n        \\n        return dp[n];    \\n    }\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "\\'\\'\\'\\n\\n    int countTexts(string pressedKeys) {\\n        int n = pressedKeys.length();\\n        vector<long long> dp(n+1);\\n        dp[0]=1;\\n        int cnt;\\n        for(int i=0;i<pressedKeys.size();i++)\\n        {\\n            int j=i;\\n            if(pressedKeys[i]==\\'7\\' || pressedKeys[i]==\\'9\\')\\n            {\\n                cnt=4;\\n            }\\n            else\\n            {\\n                cnt=3;\\n            }\\n            while(j>=0 && cnt>0 && pressedKeys[j]==pressedKeys[i])\\n            {\\n                dp[i+1] = (dp[i+1] + dp[j])%1000000007;\\n                j--;\\n                cnt--;\\n            }\\n        }\\n        \\n        return dp[n];    \\n    }\\n\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2037028,
                "title": "go-dp",
                "content": "```\\nfunc countTexts(pressedKeys string) int {\\n    pressedKeysLen := len(pressedKeys)\\n    dp := make([]int, pressedKeysLen + 1)\\n    dp[0] = 1\\n    dp[1] = 1\\n    modulo := int(1e9+7)\\n    for i := 1; i < pressedKeysLen; i++ {\\n        dp[i + 1] = dp[i]\\n        if i >= 1 && pressedKeys[i] == pressedKeys[i - 1] {\\n            dp[i + 1] = dp[i] + dp[i - 1]\\n            if i >= 2 && pressedKeys[i] == pressedKeys[i - 2] {\\n                dp[i + 1] = dp[i] + dp[i - 1] + dp[i - 2]\\n                if i >= 3 && (string(pressedKeys[i]) == \"7\" || string(pressedKeys[i]) == \"9\") {\\n                    if pressedKeys[i] == pressedKeys[i - 3] {\\n                        dp[i + 1] = dp[i] + dp[i - 1] + dp[i - 2] + dp[i - 3]\\n                    }\\n                }\\n            }\\n        }\\n        dp[i + 1] %= modulo\\n    }\\n    return dp[pressedKeysLen] \\n}",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunc countTexts(pressedKeys string) int {\\n    pressedKeysLen := len(pressedKeys)\\n    dp := make([]int, pressedKeysLen + 1)\\n    dp[0] = 1\\n    dp[1] = 1\\n    modulo := int(1e9+7)\\n    for i := 1; i < pressedKeysLen; i++ {\\n        dp[i + 1] = dp[i]\\n        if i >= 1 && pressedKeys[i] == pressedKeys[i - 1] {\\n            dp[i + 1] = dp[i] + dp[i - 1]\\n            if i >= 2 && pressedKeys[i] == pressedKeys[i - 2] {\\n                dp[i + 1] = dp[i] + dp[i - 1] + dp[i - 2]\\n                if i >= 3 && (string(pressedKeys[i]) == \"7\" || string(pressedKeys[i]) == \"9\") {\\n                    if pressedKeys[i] == pressedKeys[i - 3] {\\n                        dp[i + 1] = dp[i] + dp[i - 1] + dp[i - 2] + dp[i - 3]\\n                    }\\n                }\\n            }\\n        }\\n        dp[i + 1] %= modulo\\n    }\\n    return dp[pressedKeysLen] \\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2033632,
                "title": "easy-understanding-code-in-python-with-16-lines",
                "content": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        MOD = 10 ** 9 + 7\\n        dp = [1] + [0] * len(pressedKeys)\\n        prev, c = None, 0\\n        for i, key in enumerate(pressedKeys):\\n            if key == prev:\\n                digits = 4 if prev in \\'79\\' else 3\\n                start = i + 1 - min(digits, c + 1) # c + 1 because in 22233 case, when we look at the last 3, we need to look at the combinations at last \\'2\\' and first \\'3\\' so look back c + 1\\n                dp[i+1] = sum(dp[start : i + 1]) % MOD  # i + 1 because we have a table of len + 1. and we are filling at i + 1 index.\\n                c += 1\\n            else:\\n                dp[i+1] = dp[i] % MOD\\n                c = 1\\n            prev = key\\n        return dp[-1] % MOD\\n```\\nFirst post, hope you enjoy it.\\n\\n\\n\\n\\nI would also like to share a ugly but efficient code with a very simple idea(beats 97.71%):\\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        MOD = 10 ** 9 + 7\\n        chr3 = []\\n        chr4 = []\\n        prev = pressedKeys[0]\\n        c = 1\\n        \\n        for key in pressedKeys[1:]:\\n            if key == prev:\\n                c += 1\\n            else:\\n                if prev in {\\'7\\', \\'9\\'}:\\n                    chr4.append(c)\\n                else:\\n                    chr3.append(c)\\n                c = 1\\n            prev = key\\n        if prev in {\\'7\\', \\'9\\'}:\\n            chr4.append(c)\\n        else:\\n            chr3.append(c)\\n        \\n        def getCounts(num, digits):\\n            dp = [1] + [0] * num\\n            for i in range(1, num + 1):\\n                start = i - digits\\n                dp[i] = sum(dp[start if start >=0 else 0 : i])%MOD\\n            return dp\\n        \\n        res = 1\\n        if chr3:\\n            max_counts3 = max(chr3)\\n            dp_3digs = getCounts(max_counts3, 3)\\n            for count in chr3:\\n                res *= dp_3digs[count]%MOD\\n        if chr4:\\n            max_counts4 = max(chr4)\\n            dp_4digs = getCounts(max_counts4, 4)\\n            for count in chr4:\\n                res *= dp_4digs[count]%MOD\\n        MOD = 10**9+7\\n        return res%MOD\\n```\\nThe code looks long, but the main idea is simple.\\nIf we have 22222223333444, we find it\\'s seven \\'2\\', four \\'3\\', three \\'4\\'.\\nWe simply return the combinations with 7 repeating numbers x 4 repeating numbers x 3 repeating numbers, without considering what\\'s the number.\\nThen construct a dp table with the longest repeating int size, which is 7 here.\\nwe return dp[7] * dp[3] * dp[4] and only generate a dp table of size 7!\\n\\nIf we have 7 or 9, simply construct another dp table and others remains the same.\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        MOD = 10 ** 9 + 7\\n        dp = [1] + [0] * len(pressedKeys)\\n        prev, c = None, 0\\n        for i, key in enumerate(pressedKeys):\\n            if key == prev:\\n                digits = 4 if prev in \\'79\\' else 3\\n                start = i + 1 - min(digits, c + 1) # c + 1 because in 22233 case, when we look at the last 3, we need to look at the combinations at last \\'2\\' and first \\'3\\' so look back c + 1\\n                dp[i+1] = sum(dp[start : i + 1]) % MOD  # i + 1 because we have a table of len + 1. and we are filling at i + 1 index.\\n                c += 1\\n            else:\\n                dp[i+1] = dp[i] % MOD\\n                c = 1\\n            prev = key\\n        return dp[-1] % MOD\\n```\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        MOD = 10 ** 9 + 7\\n        chr3 = []\\n        chr4 = []\\n        prev = pressedKeys[0]\\n        c = 1\\n        \\n        for key in pressedKeys[1:]:\\n            if key == prev:\\n                c += 1\\n            else:\\n                if prev in {\\'7\\', \\'9\\'}:\\n                    chr4.append(c)\\n                else:\\n                    chr3.append(c)\\n                c = 1\\n            prev = key\\n        if prev in {\\'7\\', \\'9\\'}:\\n            chr4.append(c)\\n        else:\\n            chr3.append(c)\\n        \\n        def getCounts(num, digits):\\n            dp = [1] + [0] * num\\n            for i in range(1, num + 1):\\n                start = i - digits\\n                dp[i] = sum(dp[start if start >=0 else 0 : i])%MOD\\n            return dp\\n        \\n        res = 1\\n        if chr3:\\n            max_counts3 = max(chr3)\\n            dp_3digs = getCounts(max_counts3, 3)\\n            for count in chr3:\\n                res *= dp_3digs[count]%MOD\\n        if chr4:\\n            max_counts4 = max(chr4)\\n            dp_4digs = getCounts(max_counts4, 4)\\n            for count in chr4:\\n                res *= dp_4digs[count]%MOD\\n        MOD = 10**9+7\\n        return res%MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2031394,
                "title": "java-dp-simple",
                "content": "```\\n\\tpublic int countTexts(String pk) {\\n        long[] _3digits = new long[]{1, 2, 4, 7};\\n        long[] _4digits = new long[]{1, 2, 4, 8};\\n        int n = pk.length();\\n        char ch = pk.charAt(0);\\n        int count = 1;\\n        long res = 1;\\n        long[] toAdd = (ch == \\'7\\' || ch == \\'9\\')? _4digits : _3digits;\\n        List<Long> freq = Arrays.stream(toAdd).boxed().collect(Collectors.toList());\\n        int modulo = 1000000007;\\n        \\n        for(int i=1; i<n; i++) {\\n            if (pk.charAt(i) == ch) {\\n                count++;\\n                if (count > 4) {\\n                    long newCount = (freq.get(count - 2) + freq.get(count - 3) + freq.get(count - 4)) % modulo;\\n                    newCount = (ch == \\'7\\' || ch == \\'9\\')? (newCount + freq.get(count - 5))%modulo : newCount;\\n                    freq.add(newCount);\\n                }\\n            }else{\\n                res = (res * freq.get(count - 1)) % modulo;\\n                \\n                ch = pk.charAt(i);\\n                toAdd = (ch == \\'7\\' || ch == \\'9\\')? _4digits : _3digits;\\n                freq = Arrays.stream(toAdd).boxed().collect(Collectors.toList());\\n                count = 1;\\n            }\\n        }\\n        \\n        res = (res * freq.get(count - 1)) % modulo;\\n        return (int) res;\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\tpublic int countTexts(String pk) {\\n        long[] _3digits = new long[]{1, 2, 4, 7};\\n        long[] _4digits = new long[]{1, 2, 4, 8};\\n        int n = pk.length();\\n        char ch = pk.charAt(0);\\n        int count = 1;\\n        long res = 1;\\n        long[] toAdd = (ch == \\'7\\' || ch == \\'9\\')? _4digits : _3digits;\\n        List<Long> freq = Arrays.stream(toAdd).boxed().collect(Collectors.toList());\\n        int modulo = 1000000007;\\n        \\n        for(int i=1; i<n; i++) {\\n            if (pk.charAt(i) == ch) {\\n                count++;\\n                if (count > 4) {\\n                    long newCount = (freq.get(count - 2) + freq.get(count - 3) + freq.get(count - 4)) % modulo;\\n                    newCount = (ch == \\'7\\' || ch == \\'9\\')? (newCount + freq.get(count - 5))%modulo : newCount;\\n                    freq.add(newCount);\\n                }\\n            }else{\\n                res = (res * freq.get(count - 1)) % modulo;\\n                \\n                ch = pk.charAt(i);\\n                toAdd = (ch == \\'7\\' || ch == \\'9\\')? _4digits : _3digits;\\n                freq = Arrays.stream(toAdd).boxed().collect(Collectors.toList());\\n                count = 1;\\n            }\\n        }\\n        \\n        res = (res * freq.get(count - 1)) % modulo;\\n        return (int) res;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2026751,
                "title": "java-tabulation",
                "content": "```\\nclass Solution {\\n    public static int[] press = {0, 0, 3, 3, 3, 3, 3, 4, 3, 4};\\n    int mod = 1000000007;\\n    public int countTexts(String pressedKeys) {\\n        int[] dp = new int[pressedKeys.length()];\\n        dp[0] = 1;\\n        int freq = 1;\\n        \\n        for(int i=1;i<pressedKeys.length();i++){\\n            char ch = pressedKeys.charAt(i);\\n            if(i==0 || ch!=pressedKeys.charAt(i-1)){\\n                freq = 1;\\n            } else {\\n                freq++;\\n            }\\n            \\n            for(int j=1;j<=Math.min(freq, press[ch-\\'0\\']);j++){\\n                dp[i] += ( (i - j == -1) ? 1 : dp[i - j] );\\n                dp[i] %= mod;\\n            }\\n        }\\n        \\n        return dp[dp.length-1];\\n    }\\n}\\n```\\n\\n# Notes :- \\n\\n1. freq denotes the possible amount of times a key can be pressed. For instance, in the message \"222\", the third \\'2\\' can either be pressed once to type \\'a\\', or twice to type \\'b\\' or thrice simultaneously to type \\'c\\'. \\n2. Math.min(freq, press[ch-\\'0\\']) is necessary. For instance, in the message \"2222\", there is no mapping for all 2\\'s being pressed simultaneously. The 4rth 2 was either pressed once to type \\'a\\', or twice alongwith 3rd \\'2\\' to type \\'b\\' or thrice alongwith 2nd and 3rd \\'2\\' to type \\'c\\'. The \\'min\\' part will ensure that the simultaneous presses of a digit doesn\\'t exceed the allowed maximum simultaneous press for that digit.\\n3. The ( i - j == -1) part only makes sense if first 2 digits are the same, just to escape from \"Array Out Of Bounds Exception\".\\n\\n* Time Complexity :- O(4*N) => O(N)\\n* Space Complexity :- O(N)\\n\\nHope you found the solution and the notes insightful !",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public static int[] press = {0, 0, 3, 3, 3, 3, 3, 4, 3, 4};\\n    int mod = 1000000007;\\n    public int countTexts(String pressedKeys) {\\n        int[] dp = new int[pressedKeys.length()];\\n        dp[0] = 1;\\n        int freq = 1;\\n        \\n        for(int i=1;i<pressedKeys.length();i++){\\n            char ch = pressedKeys.charAt(i);\\n            if(i==0 || ch!=pressedKeys.charAt(i-1)){\\n                freq = 1;\\n            } else {\\n                freq++;\\n            }\\n            \\n            for(int j=1;j<=Math.min(freq, press[ch-\\'0\\']);j++){\\n                dp[i] += ( (i - j == -1) ? 1 : dp[i - j] );\\n                dp[i] %= mod;\\n            }\\n        }\\n        \\n        return dp[dp.length-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2022776,
                "title": "java-dp",
                "content": "```\\nclass Solution {\\n    Long[][] mem = null;\\n    public int countTexts(String p) {\\n        mem = new Long[p.length()+1][10];\\n        Stack<int[]> arr = new Stack();\\n        for(int i=0; i<p.length(); i++) {\\n            if (arr.size() == 0 || arr.peek()[0] != (p.charAt(i)-\\'0\\')) {\\n                arr.push(new int[]{p.charAt(i)-\\'0\\', 1});\\n            } else {\\n                arr.peek()[1]++;\\n            }\\n        }\\n        \\n        ArrayList<int[]> list = new ArrayList(arr);\\n        long prod = 1;\\n        for(int[] x: list) {\\n            prod *= dp(x[1], x[0])%1000000007;\\n            prod = prod % 1000000007;\\n        }\\n        return (int)(prod%1000000007);\\n    }\\n    \\n    long dp(int c, int l) {\\n        int[] let = new int[]{0,0,3,3,3,3,3,4,3,4};\\n        if (c <= 0) return 1;\\n        if (mem[c][l] != null) return mem[c][l];\\n        long ans = 0;\\n        for(int i=1; i<=let[l]; i++) {\\n            if (c >=i) ans += dp(c-i, l)%1000000007;\\n            ans = ans%1000000007;\\n        }\\n        mem[c][l] = ans;\\n        return ans;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    Long[][] mem = null;\\n    public int countTexts(String p) {\\n        mem = new Long[p.length()+1][10];\\n        Stack<int[]> arr = new Stack();\\n        for(int i=0; i<p.length(); i++) {\\n            if (arr.size() == 0 || arr.peek()[0] != (p.charAt(i)-\\'0\\')) {\\n                arr.push(new int[]{p.charAt(i)-\\'0\\', 1});\\n            } else {\\n                arr.peek()[1]++;\\n            }\\n        }\\n        \\n        ArrayList<int[]> list = new ArrayList(arr);\\n        long prod = 1;\\n        for(int[] x: list) {\\n            prod *= dp(x[1], x[0])%1000000007;\\n            prod = prod % 1000000007;\\n        }\\n        return (int)(prod%1000000007);\\n    }\\n    \\n    long dp(int c, int l) {\\n        int[] let = new int[]{0,0,3,3,3,3,3,4,3,4};\\n        if (c <= 0) return 1;\\n        if (mem[c][l] != null) return mem[c][l];\\n        long ans = 0;\\n        for(int i=1; i<=let[l]; i++) {\\n            if (c >=i) ans += dp(c-i, l)%1000000007;\\n            ans = ans%1000000007;\\n        }\\n        mem[c][l] = ans;\\n        return ans;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2021727,
                "title": "java-dp",
                "content": "```\\nclass Solution {\\n    private static final int MOD = 1_000_000_007;\\n    \\n    public int countTexts(String passedKeys) {\\n        int[] dp = new int[passedKeys.length()+1];\\n        dp[0] = 1;\\n        \\n        for(int i=1; i<=passedKeys.length(); i++){\\n            char c = passedKeys.charAt(i-1);\\n            \\n            dp[i] += dp[i-1];\\n            if(i >= 2 && passedKeys.charAt(i-1) == passedKeys.charAt(i-2)){\\n                dp[i] = (dp[i] + dp[i-2])%MOD;\\n            }\\n            \\n            if(i >= 3 && passedKeys.charAt(i-1) == passedKeys.charAt(i-2) && passedKeys.charAt(i-2) == passedKeys.charAt(i-3)){\\n                dp[i] = (dp[i] + dp[i-3])%MOD;\\n            }\\n            \\n            if(c == \\'7\\' || c == \\'9\\'){\\n                if(i >= 4 && passedKeys.charAt(i-1) == passedKeys.charAt(i-2) && passedKeys.charAt(i-2) == passedKeys.charAt(i-3)\\n                         && passedKeys.charAt(i-3) == passedKeys.charAt(i-4)\\n                  ){\\n                    dp[i] = (dp[i] + dp[i-4])%MOD;\\n                }   \\n            }\\n        }\\n        \\n        return (int)(dp[passedKeys.length()]%MOD);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static final int MOD = 1_000_000_007;\\n    \\n    public int countTexts(String passedKeys) {\\n        int[] dp = new int[passedKeys.length()+1];\\n        dp[0] = 1;\\n        \\n        for(int i=1; i<=passedKeys.length(); i++){\\n            char c = passedKeys.charAt(i-1);\\n            \\n            dp[i] += dp[i-1];\\n            if(i >= 2 && passedKeys.charAt(i-1) == passedKeys.charAt(i-2)){\\n                dp[i] = (dp[i] + dp[i-2])%MOD;\\n            }\\n            \\n            if(i >= 3 && passedKeys.charAt(i-1) == passedKeys.charAt(i-2) && passedKeys.charAt(i-2) == passedKeys.charAt(i-3)){\\n                dp[i] = (dp[i] + dp[i-3])%MOD;\\n            }\\n            \\n            if(c == \\'7\\' || c == \\'9\\'){\\n                if(i >= 4 && passedKeys.charAt(i-1) == passedKeys.charAt(i-2) && passedKeys.charAt(i-2) == passedKeys.charAt(i-3)\\n                         && passedKeys.charAt(i-3) == passedKeys.charAt(i-4)\\n                  ){\\n                    dp[i] = (dp[i] + dp[i-4])%MOD;\\n                }   \\n            }\\n        }\\n        \\n        return (int)(dp[passedKeys.length()]%MOD);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2019838,
                "title": "python-dfs-with-memoization-groupby-o-n-easy-to-read",
                "content": "```\\nfrom functools import lru_cache\\nfrom itertools import groupby\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        d = [0, 0, 3, 3, 3, 3, 3, 4, 3, 4]\\n        M = 10**9+7\\n        @lru_cache(None)\\n        def dfs(i, k):\\n            if i == 0: return 1\\n            if i < 0: return 0\\n            res = 0\\n            for j in range(1,k+1):\\n                res = (res + dfs(i-j, k))%M\\n            return res\\n        groups = [(int(k),len(list(v))) for k, v in groupby(pressedKeys)]\\n        res = 1\\n        for k, l in groups:\\n            res = (res*dfs(l, d[k]))%M\\n        return res",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nfrom functools import lru_cache\\nfrom itertools import groupby\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        d = [0, 0, 3, 3, 3, 3, 3, 4, 3, 4]\\n        M = 10**9+7\\n        @lru_cache(None)\\n        def dfs(i, k):\\n            if i == 0: return 1\\n            if i < 0: return 0\\n            res = 0\\n            for j in range(1,k+1):\\n                res = (res + dfs(i-j, k))%M\\n            return res\\n        groups = [(int(k),len(list(v))) for k, v in groupby(pressedKeys)]\\n        res = 1\\n        for k, l in groups:\\n            res = (res*dfs(l, d[k]))%M\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2019618,
                "title": "python-3-dp-bottom-up",
                "content": "Take 22223 for an example. \\n\\n2: `a`\\n2+2: 1st `a` plus another `a` gives `aa`, and connecting two 2s gives `b`. Total number of interpretations doubled.\\n22+2: `aa` and `b` from previous index appending another `a` gives `aaa` and `ba`; connecting the last 2 with the 2nd gives `ab`; and connecting all 3 2s gives `c`. Total number of interpretations doubled.\\n222+2: since `maximum connectable` 2s == 3, the additional interpretations it brings are:\\n\\t\\tinterpreations for 2 + 222 (`c`)\\n\\t\\tinterpretations for 22 + 22 (`b`)\\n\\t\\tinterpretations for 222 + 2 (`a`)\\n2222+3: 3 is a different digit to 2, it does not change the number of interpretations.\\n\\nFor digits 7 and 9, `maximum connectable` == 4.\\n\\nState transition:\\n```\\nif digit[i] != digit[i-1]:\\n\\tdp[i] = dp[i - 1]\\nelse:\\n\\tif connected <= max_connectable:\\n\\t\\tdp[i] = dp[i - 1] * 2\\n\\telse:\\n\\t\\tdp[i] += dp[i - j] for j in range(1 to max_connectable inclusively)\\n```\\n\\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        n = len(pressedKeys)\\n        mod = 1_000_000_007\\n        \\n        dp = [0] * n\\n        dp[0] = 1\\n        cnt = 1\\n        \\n        for i in range(1, n):\\n            if pressedKeys[i] != pressedKeys[i - 1]:\\n                dp[i] = dp[i - 1]\\n                cnt = 1\\n            else:\\n                cnt += 1\\n                if pressedKeys[i] != \\'7\\' and pressedKeys[i] != \\'9\\':\\n                    if cnt <= 3:\\n                        dp[i] = dp[i - 1] * 2 % mod\\n                    else:\\n                        dp[i] = (dp[i - 1] + dp[i - 2] + dp[i - 3]) % mod\\n                else:\\n                    if cnt <= 4:\\n                        dp[i] = dp[i - 1] * 2 % mod\\n                    else:\\n                        dp[i] = (dp[i - 1] + dp[i - 2] + dp[i - 3] + dp[i - 4]) % mod\\n        return dp[-1]\\n```\\n\\nA prefix sum can provide minor acceleration.\\n\\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        n = len(pressedKeys)\\n        mod = 1_000_000_007\\n        \\n        dp = [0] * n\\n        dp[0] = 1\\n        cnt = 1\\n        _sum = 1\\n        \\n        for i in range(1, n):\\n            if pressedKeys[i] != pressedKeys[i - 1]:\\n                dp[i] = dp[i - 1]\\n                cnt = 1\\n                _sum = dp[i]\\n            else:\\n                cnt += 1\\n                if pressedKeys[i] != \\'7\\' and pressedKeys[i] != \\'9\\':\\n                    if cnt <= 3:\\n                        dp[i] = dp[i - 1] * 2 % mod\\n                        _sum += dp[i]\\n                    else:\\n                        dp[i] = _sum % mod\\n                        _sum = _sum + dp[i] - dp[i - 3]\\n                else:\\n                    if cnt <= 4:\\n                        dp[i] = dp[i - 1] * 2 % mod\\n                        if cnt < 4:\\n                            _sum += dp[i]\\n                        else:\\n                            _sum = _sum + dp[i] - dp[i - 3]\\n                    else:\\n                        dp[i] = (_sum + dp[i - 4]) % mod\\n                        _sum = _sum + dp[i] - dp[i - 3]\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nif digit[i] != digit[i-1]:\\n\\tdp[i] = dp[i - 1]\\nelse:\\n\\tif connected <= max_connectable:\\n\\t\\tdp[i] = dp[i - 1] * 2\\n\\telse:\\n\\t\\tdp[i] += dp[i - j] for j in range(1 to max_connectable inclusively)\\n```\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        n = len(pressedKeys)\\n        mod = 1_000_000_007\\n        \\n        dp = [0] * n\\n        dp[0] = 1\\n        cnt = 1\\n        \\n        for i in range(1, n):\\n            if pressedKeys[i] != pressedKeys[i - 1]:\\n                dp[i] = dp[i - 1]\\n                cnt = 1\\n            else:\\n                cnt += 1\\n                if pressedKeys[i] != \\'7\\' and pressedKeys[i] != \\'9\\':\\n                    if cnt <= 3:\\n                        dp[i] = dp[i - 1] * 2 % mod\\n                    else:\\n                        dp[i] = (dp[i - 1] + dp[i - 2] + dp[i - 3]) % mod\\n                else:\\n                    if cnt <= 4:\\n                        dp[i] = dp[i - 1] * 2 % mod\\n                    else:\\n                        dp[i] = (dp[i - 1] + dp[i - 2] + dp[i - 3] + dp[i - 4]) % mod\\n        return dp[-1]\\n```\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        n = len(pressedKeys)\\n        mod = 1_000_000_007\\n        \\n        dp = [0] * n\\n        dp[0] = 1\\n        cnt = 1\\n        _sum = 1\\n        \\n        for i in range(1, n):\\n            if pressedKeys[i] != pressedKeys[i - 1]:\\n                dp[i] = dp[i - 1]\\n                cnt = 1\\n                _sum = dp[i]\\n            else:\\n                cnt += 1\\n                if pressedKeys[i] != \\'7\\' and pressedKeys[i] != \\'9\\':\\n                    if cnt <= 3:\\n                        dp[i] = dp[i - 1] * 2 % mod\\n                        _sum += dp[i]\\n                    else:\\n                        dp[i] = _sum % mod\\n                        _sum = _sum + dp[i] - dp[i - 3]\\n                else:\\n                    if cnt <= 4:\\n                        dp[i] = dp[i - 1] * 2 % mod\\n                        if cnt < 4:\\n                            _sum += dp[i]\\n                        else:\\n                            _sum = _sum + dp[i] - dp[i - 3]\\n                    else:\\n                        dp[i] = (_sum + dp[i - 4]) % mod\\n                        _sum = _sum + dp[i] - dp[i - 3]\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2019523,
                "title": "dynamic-programming-memoization-java",
                "content": "```\\nclass Solution {\\n    int mod=1000000007;\\n    HashMap<Integer,Integer>map;\\n    public int countTexts(String pressedKeys) {\\n        HashSet<String>set=new HashSet<>();\\n        set.add(\"2\");\\n        set.add(\"22\");\\n        set.add(\"222\");\\n        set.add(\"3\");\\n        set.add(\"33\");\\n        set.add(\"333\");\\n        set.add(\"4\");\\n        set.add(\"44\");\\n        set.add(\"444\");\\n        \\n        set.add(\"5\");\\n        set.add(\"55\");\\n        set.add(\"555\");\\n        set.add(\"6\");\\n        set.add(\"66\");\\n        set.add(\"666\");\\n        set.add(\"7\");\\n        set.add(\"77\");\\n        set.add(\"7777\");\\n        set.add(\"777\");\\n        set.add(\"8\");\\n        set.add(\"88\");\\n        set.add(\"888\");\\n        set.add(\"9\");\\n        set.add(\"99\");\\n        set.add(\"9999\");\\n        set.add(\"999\");\\n        \\n        map=new HashMap<>();\\n        return solver(pressedKeys,set,pressedKeys.length(),0);\\n        \\n    }\\n    \\n    public int solver(String str, HashSet<String>set, int n,int i){\\n        \\n        \\n        if(i==n){\\n            map.put(n,1);\\n            return 1;\\n        }\\n        if(map.containsKey(i)){\\n            return map.get(i);\\n        }\\n        int ans=0;\\n        \\n        for(int j=i+1;j<=n;j++){\\n            String pre=str.substring(i,j);\\n         //   String ros=j==n?\"\":str.substring(j);\\n            if(set.contains(pre)){\\n                if(map.containsKey(j)){\\n                    ans+=map.get(j);\\n                }else{\\n                    ans+=solver(str,set,n,j);\\n                }\\n                \\n                ans%=mod;\\n            }else{\\n                break;\\n            }\\n        }\\n        \\n        map.put(i,ans);\\n        return ans;\\n    }\\n}```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int mod=1000000007;\\n    HashMap<Integer,Integer>map;\\n    public int countTexts(String pressedKeys) {\\n        HashSet<String>set=new HashSet<>();\\n        set.add(\"2\");\\n        set.add(\"22\");\\n        set.add(\"222\");\\n        set.add(\"3\");\\n        set.add(\"33\");\\n        set.add(\"333\");\\n        set.add(\"4\");\\n        set.add(\"44\");\\n        set.add(\"444\");\\n        \\n        set.add(\"5\");\\n        set.add(\"55\");\\n        set.add(\"555\");\\n        set.add(\"6\");\\n        set.add(\"66\");\\n        set.add(\"666\");\\n        set.add(\"7\");\\n        set.add(\"77\");\\n        set.add(\"7777\");\\n        set.add(\"777\");\\n        set.add(\"8\");\\n        set.add(\"88\");\\n        set.add(\"888\");\\n        set.add(\"9\");\\n        set.add(\"99\");\\n        set.add(\"9999\");\\n        set.add(\"999\");\\n        \\n        map=new HashMap<>();\\n        return solver(pressedKeys,set,pressedKeys.length(),0);\\n        \\n    }\\n    \\n    public int solver(String str, HashSet<String>set, int n,int i){\\n        \\n        \\n        if(i==n){\\n            map.put(n,1);\\n            return 1;\\n        }\\n        if(map.containsKey(i)){\\n            return map.get(i);\\n        }\\n        int ans=0;\\n        \\n        for(int j=i+1;j<=n;j++){\\n            String pre=str.substring(i,j);\\n         //   String ros=j==n?\"\":str.substring(j);\\n            if(set.contains(pre)){\\n                if(map.containsKey(j)){\\n                    ans+=map.get(j);\\n                }else{\\n                    ans+=solver(str,set,n,j);\\n                }\\n                \\n                ans%=mod;\\n            }else{\\n                break;\\n            }\\n        }\\n        \\n        map.put(i,ans);\\n        return ans;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 2019257,
                "title": "easy-solution-dp-dynamic-prorgramming-c-explanation-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int countTexts(string s) {\\n        int n=s.length();\\n        int mod=int(1e9)+7;\\n        vector<int>dp(n,0);\\n        unordered_set<string>um;\\n        for(int i=2;i<=9;i++){\\n            string temp=to_string(i);\\n            string cur=temp;\\n            um.insert(cur);\\n            cur+=temp;\\n            um.insert(cur);\\n            cur+=temp;\\n            um.insert(cur);\\n        }\\n        um.insert(\"7777\");\\n        um.insert(\"9999\");\\n        \\n        dp[0]=1;\\n        if(n==1) return dp[0];\\n        string cur=s.substr(0,2);\\n        dp[1]=1;\\n        if(um.find(cur)!=um.end()) dp[1]++;\\n        if(n==2) return dp[1];\\n        cur=s.substr(0,3);            \\n        if(um.find(cur)!=um.end()) dp[2]++;\\n        cur=s.substr(1,2);\\n        if(um.find(cur)!=um.end()) dp[2]+=dp[0];\\n        dp[2]+=dp[1];\\n\\n        for(int i=3;i<n;i++){\\n            dp[i]=dp[i-1]%mod;\\n            string cur1=s.substr(i-2,3);\\n            if(um.find(cur1)!=um.end()) dp[i]=(dp[i-3]%mod+dp[i]%mod)%mod;\\n            cur1=s.substr(i-1,2);\\n            if(um.find(cur1)!=um.end()) dp[i]=(dp[i-2]%mod+dp[i]%mod)%mod;\\n            if(s[i]==\\'7\\' || s[i]==\\'9\\'){\\n                cur1=s.substr(i-3,4);\\n                if(um.find(cur1)!=um.end()){\\n                    if(i==3) dp[i]++;\\n                    else dp[i]=(dp[i-4]%mod+dp[i]%mod)%mod;\\n                } \\n            }\\n        }\\n        \\n        return dp[n-1]%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countTexts(string s) {\\n        int n=s.length();\\n        int mod=int(1e9)+7;\\n        vector<int>dp(n,0);\\n        unordered_set<string>um;\\n        for(int i=2;i<=9;i++){\\n            string temp=to_string(i);\\n            string cur=temp;\\n            um.insert(cur);\\n            cur+=temp;\\n            um.insert(cur);\\n            cur+=temp;\\n            um.insert(cur);\\n        }\\n        um.insert(\"7777\");\\n        um.insert(\"9999\");\\n        \\n        dp[0]=1;\\n        if(n==1) return dp[0];\\n        string cur=s.substr(0,2);\\n        dp[1]=1;\\n        if(um.find(cur)!=um.end()) dp[1]++;\\n        if(n==2) return dp[1];\\n        cur=s.substr(0,3);            \\n        if(um.find(cur)!=um.end()) dp[2]++;\\n        cur=s.substr(1,2);\\n        if(um.find(cur)!=um.end()) dp[2]+=dp[0];\\n        dp[2]+=dp[1];\\n\\n        for(int i=3;i<n;i++){\\n            dp[i]=dp[i-1]%mod;\\n            string cur1=s.substr(i-2,3);\\n            if(um.find(cur1)!=um.end()) dp[i]=(dp[i-3]%mod+dp[i]%mod)%mod;\\n            cur1=s.substr(i-1,2);\\n            if(um.find(cur1)!=um.end()) dp[i]=(dp[i-2]%mod+dp[i]%mod)%mod;\\n            if(s[i]==\\'7\\' || s[i]==\\'9\\'){\\n                cur1=s.substr(i-3,4);\\n                if(um.find(cur1)!=um.end()){\\n                    if(i==3) dp[i]++;\\n                    else dp[i]=(dp[i-4]%mod+dp[i]%mod)%mod;\\n                } \\n            }\\n        }\\n        \\n        return dp[n-1]%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2019221,
                "title": "easy-to-understand-important-concept-involved",
                "content": "Take a test case like [1,1,1,1,1,1], here we have 6 (1) . Now think properly of what we have to do :\\n\\n[1,1,1,1,1,1]-->[a,a,a,a,a] , [a,b,a,a], [a,b,b] etc;\\n\\nIf we closely look its just like :\\n\\n6=1+1+1+1+1+1  => a+a+a+a+a+a\\n6=1+2+1+1 =>a+b+a+a\\n6=1+3+1=>a+c+a\\n\\n6=1+4 NOT VALID || We can only go upto 3 as given in ques (3presses);\\n\\nDoesn\\'t this look similar to COIN-CHANGE Problem , But HERE IS A CATCH , here we have to compute all the PERMUTATIONS unlike COIN CHANGE where we calculated unique PERMUTATION.\\n\\nYou can take help from here regarding Permutation Thing : https://leetcode.com/problems/combination-sum-iv/discuss/1986766/did-u-missed-this-concept-permutations-vs-unique-permutations\\n\\nSolution is as Follows:\\n\\nclass Solution { \\npublic:\\n    \\n    int COINCHANGE(int sum,int k){\\n        int mod=1e9+7;\\n        vector<int>coin={1,2,3};\\n        if(k==7 || k==9){   //since we can press 4 times there\\n            coin.push_back(4);\\n        }\\n        int n=coin.size();\\n        vector<vector<int>>dp(n+1,vector<int>(sum+1,0));\\n        \\n        for(int i=0;i<=sum;i++){\\n            dp[0][i]=0;\\n        }\\n        for(int i=0;i<=n;i++){\\n            dp[i][0]=1;\\n        }\\n        \\n        for(int k=1;k<=sum;k++){\\n            for(int i=1;i<=n;i++){\\n                if(k-coin[i-1]>=0){\\n                    dp[i][k]=(dp[i-1][k]%mod+dp[n][k-coin[i-1]]%mod)%mod;\\n                }\\n                else{\\n                    dp[i][k]=dp[i-1][k]%mod;\\n                }\\n            }\\n        }\\n        return dp[n][sum];\\n    }\\n    int countTexts(string s) {\\n        \\n        int cnt=0;\\n        long long ans=1;\\n        int mod=1e9+7;\\n        s+=\\'$\\';\\n        for(int i=1;i<s.size();i++){\\n            if(s[i]==s[i-1]){\\n                cnt++;\\n            }\\n            else{\\n                int k=s[i-1]-\\'0\\';\\n                ans=((ans%mod)*1LL*(COINCHANGE(cnt+1,k))%mod)%mod;  //Multiplication is done to have all the combinations\\n                ans=ans%mod;\\n                cnt=0;\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n };\\n \\n If it is still unclear, please let me know how can I help.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution { \\npublic:\\n    \\n    int COINCHANGE(int sum,int k){\\n        int mod=1e9+7;\\n        vector<int>coin={1,2,3}",
                "codeTag": "Java"
            },
            {
                "id": 2019187,
                "title": "solution-t-o-n-s-o-1-explain-with-schematic",
                "content": "![image](https://assets.leetcode.com/users/images/f6c8d425-39ab-404f-8de8-3090d74572ea_1652003566.5879638.png)\\ndp[] is the possibilities of text combination.\\nfrom the example, you can understand that \\ndp[i+1]+=dp[i]; // it always can be a letter alone and do not forget the dp[-1] should set to 1\\n- dp[i-1],dp[i-2] //if it can combine with the former pressed\\n- dp[i-3] //if this number is 7 or 9 \\n\\nthe Mod operation should be executed whenever it is added, cause the number will be very large at late stage. \\nP.S\\uFF1AIf the number is less than MOD, it will not be affected.\\n\\n```\\n\\tprivate static final int MOD = 1_000_000_007;\\n    public int countTexts(String pressedKeys) {\\n        //the last we need is i-4, so 5 is enough.\\n        int[] textPossibility = new int[5]; \\n        char[] chars = pressedKeys.toCharArray();\\n        int n = pressedKeys.length();\\n        textPossibility[0]=1;\\n        for(int i=0;i<n;i++){\\n            char c = pressedKeys.charAt(i);\\n            int index = (i+1)%5;\\n            //suppose the letter is the 1 time pressed\\n            textPossibility[index] = textPossibility[i%5]; \\n            if(i>0 && c==pressedKeys.charAt(i-1)){\\n                textPossibility[index]+= textPossibility[(i-1)%5];\\n                textPossibility[index] %= MOD;\\n                if(i>1 && c==pressedKeys.charAt(i-2)){\\n                    textPossibility[index]+= textPossibility[(i-2)%5];\\n                    textPossibility[index] %= MOD;\\n                    if((c==\\'7\\'||c==\\'9\\') && i>2 && c==pressedKeys.charAt(i-3)){\\n                        textPossibility[index]+= textPossibility[(i-3)%5];\\n                        textPossibility[index] %= MOD;\\n                    }\\n                }\\n            }\\n        }\\n        return textPossibility[n%5];\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\tprivate static final int MOD = 1_000_000_007;\\n    public int countTexts(String pressedKeys) {\\n        //the last we need is i-4, so 5 is enough.\\n        int[] textPossibility = new int[5]; \\n        char[] chars = pressedKeys.toCharArray();\\n        int n = pressedKeys.length();\\n        textPossibility[0]=1;\\n        for(int i=0;i<n;i++){\\n            char c = pressedKeys.charAt(i);\\n            int index = (i+1)%5;\\n            //suppose the letter is the 1 time pressed\\n            textPossibility[index] = textPossibility[i%5]; \\n            if(i>0 && c==pressedKeys.charAt(i-1)){\\n                textPossibility[index]+= textPossibility[(i-1)%5];\\n                textPossibility[index] %= MOD;\\n                if(i>1 && c==pressedKeys.charAt(i-2)){\\n                    textPossibility[index]+= textPossibility[(i-2)%5];\\n                    textPossibility[index] %= MOD;\\n                    if((c==\\'7\\'||c==\\'9\\') && i>2 && c==pressedKeys.charAt(i-3)){\\n                        textPossibility[index]+= textPossibility[(i-3)%5];\\n                        textPossibility[index] %= MOD;\\n                    }\\n                }\\n            }\\n        }\\n        return textPossibility[n%5];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2018770,
                "title": "easy-dp-solution-java",
                "content": "```\\n    public int countTexts(String s) {\\n        int n =s.length();\\n        long dp [] =new long[n+1];\\n        dp[0]=1;\\n        int mod = 1000000007;\\n        for(int i=1;i<=n;i++)\\n        {\\n            char ch = s.charAt(i-1);\\n        \\n               dp[i]= (dp[i] + dp[i-1]) % mod;     \\n                   \\n                if((i-2)>=0 && s.charAt(i-2)==ch) dp[i] = (dp[i] + dp[i-2]) % mod;\\n                else continue;\\n                \\n                if((i-3)>=0 && s.charAt(i-3)==ch) dp[i]= ( dp[i]+dp[i-3] )  % mod;\\n                else continue; \\n                \\n                if( (ch==\\'7\\' || ch==\\'9\\') && (i-4)>=0 && s.charAt(i-4)==ch) dp[i] = (dp[i]+dp[i-4] )  % mod;     \\n            \\n        }\\n        \\n        return (int)(dp[n] % mod);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int countTexts(String s) {\\n        int n =s.length();\\n        long dp [] =new long[n+1];\\n        dp[0]=1;\\n        int mod = 1000000007;\\n        for(int i=1;i<=n;i++)\\n        {\\n            char ch = s.charAt(i-1);\\n        \\n               dp[i]= (dp[i] + dp[i-1]) % mod;     \\n                   \\n                if((i-2)>=0 && s.charAt(i-2)==ch) dp[i] = (dp[i] + dp[i-2]) % mod;\\n                else continue;\\n                \\n                if((i-3)>=0 && s.charAt(i-3)==ch) dp[i]= ( dp[i]+dp[i-3] )  % mod;\\n                else continue; \\n                \\n                if( (ch==\\'7\\' || ch==\\'9\\') && (i-4)>=0 && s.charAt(i-4)==ch) dp[i] = (dp[i]+dp[i-4] )  % mod;     \\n            \\n        }\\n        \\n        return (int)(dp[n] % mod);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2018522,
                "title": "java-memoziation-based-solution",
                "content": "```\\nclass Solution {\\n    Integer[] cache;\\n    int mod = (int)Math.pow(10,9) + 7;\\n    public int countTexts(String pressedKeys) {\\n        cache = new Integer[pressedKeys.length()];\\n        return helper(pressedKeys, 0);\\n    }\\n    \\n    int helper(String cur, int pos) {\\n        if (pos >= cur.length()) {\\n            return 1;\\n        }\\n        \\n        if (cache[pos] != null) {\\n            return cache[pos];\\n        }\\n        int count = 0;\\n        for (int i = pos; i < cur.length() && i < pos + 4; i++) {\\n            if (cur.charAt(i) == cur.charAt(pos)) {\\n                count++;\\n            } else {\\n                break;\\n            }\\n        }\\n        \\n        if (cur.charAt(pos) == \\'7\\' || cur.charAt(pos) == \\'9\\') {\\n    \\n            count = count > 4 ? 4 : count;\\n        } else {\\n            count = count > 3 ? 3 : count;\\n        }\\n        \\n        int res = 0;\\n        \\n\\n        for (int i = pos; i < cur.length() && i < pos + count; i++) {\\n            res += helper(cur, i+1);\\n            res = res % mod;\\n        }\\n        return cache[pos] = res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Integer[] cache;\\n    int mod = (int)Math.pow(10,9) + 7;\\n    public int countTexts(String pressedKeys) {\\n        cache = new Integer[pressedKeys.length()];\\n        return helper(pressedKeys, 0);\\n    }\\n    \\n    int helper(String cur, int pos) {\\n        if (pos >= cur.length()) {\\n            return 1;\\n        }\\n        \\n        if (cache[pos] != null) {\\n            return cache[pos];\\n        }\\n        int count = 0;\\n        for (int i = pos; i < cur.length() && i < pos + 4; i++) {\\n            if (cur.charAt(i) == cur.charAt(pos)) {\\n                count++;\\n            } else {\\n                break;\\n            }\\n        }\\n        \\n        if (cur.charAt(pos) == \\'7\\' || cur.charAt(pos) == \\'9\\') {\\n    \\n            count = count > 4 ? 4 : count;\\n        } else {\\n            count = count > 3 ? 3 : count;\\n        }\\n        \\n        int res = 0;\\n        \\n\\n        for (int i = pos; i < cur.length() && i < pos + count; i++) {\\n            res += helper(cur, i+1);\\n            res = res % mod;\\n        }\\n        return cache[pos] = res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018437,
                "title": "dp-tabulation-observation",
                "content": "**PLEASE UPVOTE IF U FIND MY SOLUTION HELPFUL**\\n\\n```\\n#define ll long long\\nclass Solution \\n{\\n    const int M=1e9+7;\\npublic:\\n    int countTexts(string pK) \\n    {\\n        vector<pair<char,int>>v;\\n        int len=pK.length();\\n        \\n        int maxx=0;\\n        bool has_7OR9=0;//optimisation\\n        for(int i=0;i<len;)\\n        {\\n            char ch=pK[i];\\n            int c=0;\\n            while(i<len&&pK[i]==ch)\\n            {\\n                c++;\\n                i++;\\n            }\\n            maxx=max(maxx,c);\\n            if(ch==\\'7\\'||ch==\\'9\\')\\n                has_7OR9=1;\\n            v.push_back({ch,c});\\n        }\\n        \\n        \\n        maxx=max(4,maxx);\\n        vector<ll>dp1(maxx+1,0);//storing characters other than 7 and 9\\n        vector<ll>dp2(maxx+1,0);//storing characters 7 and 9\\n        dp1[1]=1,dp1[2]=2,dp1[3]=4;\\n        dp2[1]=1,dp2[2]=2,dp2[3]=4,dp2[4]=8;\\n        \\n        for(int i=4;i<=maxx;i++)\\n        {\\n            dp1[i]=(dp1[i-1]+dp1[i-2]+dp1[i-3])%M;\\n        }\\n        \\n        //not necessary but okie \\n        if(has_7OR9)\\n        {\\n           for(int i=5;i<=maxx;i++)\\n        {\\n            dp2[i]=(dp2[i-1]%M+dp2[i-2]%M+dp2[i-3]%M+dp2[i-4]%M)%M;\\n        }  \\n        }\\n       \\n        ll res=1;\\n        for(auto [ch,c]:v)\\n        {\\n        if(ch==\\'7\\'||ch==\\'9\\')\\n        {\\n              res=(res*(dp2[c])%M)%M;\\n        }\\n        else\\n        {\\n              res=(res*(dp1[c])%M)%M;\\n        }\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n#define ll long long\\nclass Solution \\n{\\n    const int M=1e9+7;\\npublic:\\n    int countTexts(string pK) \\n    {\\n        vector<pair<char,int>>v;\\n        int len=pK.length();\\n        \\n        int maxx=0;\\n        bool has_7OR9=0;//optimisation\\n        for(int i=0;i<len;)\\n        {\\n            char ch=pK[i];\\n            int c=0;\\n            while(i<len&&pK[i]==ch)\\n            {\\n                c++;\\n                i++;\\n            }\\n            maxx=max(maxx,c);\\n            if(ch==\\'7\\'||ch==\\'9\\')\\n                has_7OR9=1;\\n            v.push_back({ch,c});\\n        }\\n        \\n        \\n        maxx=max(4,maxx);\\n        vector<ll>dp1(maxx+1,0);//storing characters other than 7 and 9\\n        vector<ll>dp2(maxx+1,0);//storing characters 7 and 9\\n        dp1[1]=1,dp1[2]=2,dp1[3]=4;\\n        dp2[1]=1,dp2[2]=2,dp2[3]=4,dp2[4]=8;\\n        \\n        for(int i=4;i<=maxx;i++)\\n        {\\n            dp1[i]=(dp1[i-1]+dp1[i-2]+dp1[i-3])%M;\\n        }\\n        \\n        //not necessary but okie \\n        if(has_7OR9)\\n        {\\n           for(int i=5;i<=maxx;i++)\\n        {\\n            dp2[i]=(dp2[i-1]%M+dp2[i-2]%M+dp2[i-3]%M+dp2[i-4]%M)%M;\\n        }  \\n        }\\n       \\n        ll res=1;\\n        for(auto [ch,c]:v)\\n        {\\n        if(ch==\\'7\\'||ch==\\'9\\')\\n        {\\n              res=(res*(dp2[c])%M)%M;\\n        }\\n        else\\n        {\\n              res=(res*(dp1[c])%M)%M;\\n        }\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018404,
                "title": "simple-dp-solution-java-34ms-beats-100",
                "content": "We count consecutive repeating digits. For n repeating digits we count the number of ways to convert them into characters using DP.\\nFor digits 7 and 9 there are 4 characters corresponding to them. Their ways of converting n digits is as follows:\\nways[1]=1\\nways[2]=2\\nways[3]=4\\nways[4]=8\\n.\\n.\\n.\\nways[n]=ways[n-1]+ways[n-2]+ways[n-3]+ways[n-4]\\nFor digits other than 7 or 9, there are 3 characters corresponding to them. There ways of converting n repetitive digits is:\\nways[1]=1\\nways[2]=2\\nways[3]=4\\n.\\n.\\n.\\nways[n]=ways[n-1]+ways[n-2]+ways[n-3]\\nThe above formulas can be found out by taking some examples.\\n\\n```\\nclass Solution {\\n    public int countTexts(String pressedKeys) {\\n        int count=1;\\n        long total=1;\\n        for(int i=1;i<pressedKeys.length();i++)\\n        {\\n            if(pressedKeys.charAt(i)!=pressedKeys.charAt(i-1))\\n            {\\n                if(pressedKeys.charAt(i-1)==\\'7\\'||pressedKeys.charAt(i-1)==\\'9\\')\\n                    total=(total*count7or9(count))%1000000007;\\n                else\\n                    total=(total*countOthers(count)%1000000007);\\n                count=1;\\n            }\\n            else\\n                count++;\\n        }\\n        if(pressedKeys.charAt(pressedKeys.length()-1)==\\'7\\'||pressedKeys.charAt(pressedKeys.length()-1)==\\'9\\')\\n            total=(total*count7or9(count))%1000000007;\\n        else\\n            total=(total*countOthers(count)%1000000007);\\n        return (int)total;\\n    }\\n    public long count7or9(int count)\\n    {\\n        long[] ways=new long[count+1];\\n        if(count==1)\\n            return 1;\\n        else if(count==2)\\n            return 2;\\n        else if(count==3)\\n            return 4;\\n        else if(count==4)\\n            return 8;\\n        ways[1]=1;\\n        ways[2]=2;\\n        ways[3]=4;\\n        ways[4]=8;\\n        for(int i=5;i<=count;i++)\\n        {\\n            ways[i]=(ways[i-1]+ways[i-2]+ways[i-3]+ways[i-4])%1000000007;\\n        }\\n        return ways[count];\\n    }\\n    public long countOthers(int count)\\n    {\\n        long[] ways=new long[count+1];\\n        if(count==1)\\n            return 1;\\n        else if(count==2)\\n            return 2;\\n        else if(count==3)\\n            return 4;\\n        ways[1]=1;\\n        ways[2]=2;\\n        ways[3]=4;\\n        for(int i=4;i<=count;i++)\\n        {\\n            ways[i]=(ways[i-1]+ways[i-2]+ways[i-3])%1000000007;\\n        }\\n        return ways[count];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int countTexts(String pressedKeys) {\\n        int count=1;\\n        long total=1;\\n        for(int i=1;i<pressedKeys.length();i++)\\n        {\\n            if(pressedKeys.charAt(i)!=pressedKeys.charAt(i-1))\\n            {\\n                if(pressedKeys.charAt(i-1)==\\'7\\'||pressedKeys.charAt(i-1)==\\'9\\')\\n                    total=(total*count7or9(count))%1000000007;\\n                else\\n                    total=(total*countOthers(count)%1000000007);\\n                count=1;\\n            }\\n            else\\n                count++;\\n        }\\n        if(pressedKeys.charAt(pressedKeys.length()-1)==\\'7\\'||pressedKeys.charAt(pressedKeys.length()-1)==\\'9\\')\\n            total=(total*count7or9(count))%1000000007;\\n        else\\n            total=(total*countOthers(count)%1000000007);\\n        return (int)total;\\n    }\\n    public long count7or9(int count)\\n    {\\n        long[] ways=new long[count+1];\\n        if(count==1)\\n            return 1;\\n        else if(count==2)\\n            return 2;\\n        else if(count==3)\\n            return 4;\\n        else if(count==4)\\n            return 8;\\n        ways[1]=1;\\n        ways[2]=2;\\n        ways[3]=4;\\n        ways[4]=8;\\n        for(int i=5;i<=count;i++)\\n        {\\n            ways[i]=(ways[i-1]+ways[i-2]+ways[i-3]+ways[i-4])%1000000007;\\n        }\\n        return ways[count];\\n    }\\n    public long countOthers(int count)\\n    {\\n        long[] ways=new long[count+1];\\n        if(count==1)\\n            return 1;\\n        else if(count==2)\\n            return 2;\\n        else if(count==3)\\n            return 4;\\n        ways[1]=1;\\n        ways[2]=2;\\n        ways[3]=4;\\n        for(int i=4;i<=count;i++)\\n        {\\n            ways[i]=(ways[i-1]+ways[i-2]+ways[i-3])%1000000007;\\n        }\\n        return ways[count];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018217,
                "title": "java-o-n-time-o-1-space-with-comments-image-explanation-circular-array",
                "content": "```\\nclass Solution {\\n    static int mod = 1000000007;\\n    public int countTexts(String pK) {\\n        int n = pK.length();\\n        int[] dp = new int[5];\\n        // 1 represents number is present previously, unique digit.\\n        Arrays.fill(dp,1);\\n        for(int i=n-1;i>=0;i--){\\n            dp[i%5] = 0;\\n            // Range till which dp needs to filled, i.e., \\n\\t\\t\\t// For every i we can add dp[i-1],dp[i-2],dp[i-3] to dp[i] and if pK[i] is either 7 or 9 then we can add dp[i-4] also. \\t\\t\\n\\t\\t\\tint max;\\n            if(pK.charAt(i)==\\'7\\' || pK.charAt(i)==\\'9\\') max = i+4;\\n            else max = i+3;\\n\\t\\t\\t// If max goes beyond length then iterate till n. \\n            if(max>n) max=n;\\n            for(int j =i;j<max && pK.charAt(i)==pK.charAt(j);j++){\\n\\t\\t\\t // Since array is circular for dp[i], dp[i-1],dp[i-2],dp[i-3] will be dp[i+2],dp[i+3],dp[i+4], hence j+1 while adding.\\n                dp[i%5] = (dp[i%5] + dp[(j+1)%5])%mod;\\n            }\\n        }\\n        return dp[0];\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/895ac456-577d-40fc-bcc1-35b83aa8f813_1651985770.7568316.png)\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static int mod = 1000000007;\\n    public int countTexts(String pK) {\\n        int n = pK.length();\\n        int[] dp = new int[5];\\n        // 1 represents number is present previously, unique digit.\\n        Arrays.fill(dp,1);\\n        for(int i=n-1;i>=0;i--){\\n            dp[i%5] = 0;\\n            // Range till which dp needs to filled, i.e., \\n\\t\\t\\t// For every i we can add dp[i-1],dp[i-2],dp[i-3] to dp[i] and if pK[i] is either 7 or 9 then we can add dp[i-4] also. \\t\\t\\n\\t\\t\\tint max;\\n            if(pK.charAt(i)==\\'7\\' || pK.charAt(i)==\\'9\\') max = i+4;\\n            else max = i+3;\\n\\t\\t\\t// If max goes beyond length then iterate till n. \\n            if(max>n) max=n;\\n            for(int j =i;j<max && pK.charAt(i)==pK.charAt(j);j++){\\n\\t\\t\\t // Since array is circular for dp[i], dp[i-1],dp[i-2],dp[i-3] will be dp[i+2],dp[i+3],dp[i+4], hence j+1 while adding.\\n                dp[i%5] = (dp[i%5] + dp[(j+1)%5])%mod;\\n            }\\n        }\\n        return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018212,
                "title": "python-top-down-dp",
                "content": "\\tclass Solution:\\n\\t\\tdef countTexts(self, pressedKeys: str) -> int:\\n\\t\\t\\tmod = 10 ** 9 + 7\\n\\t\\t\\t@cache\\n\\t\\t\\tdef dfs(i):\\n\\t\\t\\t\\tif i == 0:\\n\\t\\t\\t\\t\\treturn 1\\n\\t\\t\\t\\tcnt = dfs(i - 1)\\n\\t\\t\\t\\tif i >= 2 and pressedKeys[i - 1] == pressedKeys[i - 2]:\\n\\t\\t\\t\\t\\tcnt += dfs(i - 2)\\n\\t\\t\\t\\tif i >= 3 and pressedKeys[i - 3:i] == pressedKeys[i - 3] * 3:\\n\\t\\t\\t\\t\\tcnt += dfs(i - 3)\\n\\t\\t\\t\\tif pressedKeys[i - 1] == \"7\" or pressedKeys[i - 1] == \"9\":\\n\\t\\t\\t\\t\\tif i >= 4 and pressedKeys[i - 4:i] == pressedKeys[i - 4] * 4:\\n\\t\\t\\t\\t\\t\\tcnt += dfs(i - 4)\\n\\t\\t\\t\\treturn cnt % mod\\n\\t\\t\\treturn dfs(len(pressedKeys)) % mod",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef countTexts(self, pressedKeys: str) -> int:\\n\\t\\t\\tmod = 10 ** 9 + 7\\n\\t\\t\\t@cache\\n\\t\\t\\tdef dfs(i):\\n\\t\\t\\t\\tif i == 0:\\n\\t\\t\\t\\t\\treturn 1\\n\\t\\t\\t\\tcnt = dfs(i - 1)\\n\\t\\t\\t\\tif i >= 2 and pressedKeys[i - 1] == pressedKeys[i - 2]:\\n\\t\\t\\t\\t\\tcnt += dfs(i - 2)\\n\\t\\t\\t\\tif i >= 3 and pressedKeys[i - 3:i] == pressedKeys[i - 3] * 3:\\n\\t\\t\\t\\t\\tcnt += dfs(i - 3)\\n\\t\\t\\t\\tif pressedKeys[i - 1] == \"7\" or pressedKeys[i - 1] == \"9\":\\n\\t\\t\\t\\t\\tif i >= 4 and pressedKeys[i - 4:i] == pressedKeys[i - 4] * 4:\\n\\t\\t\\t\\t\\t\\tcnt += dfs(i - 4)\\n\\t\\t\\t\\treturn cnt % mod\\n\\t\\t\\treturn dfs(len(pressedKeys)) % mod",
                "codeTag": "Java"
            },
            {
                "id": 2018036,
                "title": "o-n-with-detail-explanation-for-dp",
                "content": "\\n\\n![image](https://assets.leetcode.com/users/images/a30713df-3f1e-4b26-96c5-8c5194e5d738_1651983880.0719159.png)\\n\\n\\n**only digit 7 and 9 has 4 consecutive press \\nwhich we need to characters from i-3 , i-2, i-1 and i\\nrest will be maximum 3 index characters from i-2,i-1 and i**\\n\\n\\n\\n```\\nlong M=(long)(1e9)+7;\\n    String[] PAD=new String[]{\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n    public int countTexts(String s) {        \\n        int n=s.length();\\n        long[] res = new long[n];\\n        res[0]=1;        \\n        \\n        for(int i=1;i<n;i++){\\n             res[i]=res[i-1];             \\n             res[i]%=M;\\n            \\n             if(i-1>=0 && s.charAt(i-1)==s.charAt(i)){\\n                 res[i]+=i-2<0?1:res[i-2];            \\n                 res[i]%=M;\\n             }\\n                        \\n             if(i-2>=0 && s.charAt(i-2)==s.charAt(i-1) && s.charAt(i-1)==s.charAt(i)){\\n                 res[i]+=i-3<0?1:res[i-3];                   \\n                 res[i]%=M;\\n             }            \\n            \\n            if(i-3>=0 && (s.charAt(i)==\\'7\\'||s.charAt(i)==\\'9\\') && s.charAt(i-3)==s.charAt(i-2) &&s.charAt(i-2)==s.charAt(i-1) && s.charAt(i-1)==s.charAt(i)){\\n                res[i]+=i-4<0?1:res[i-4];\\n                res[i]%=M;\\n            }            \\n        }        \\n        return (int)res[n-1];\\n        \\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\nlong M=(long)(1e9)+7;\\n    String[] PAD=new String[]{\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n    public int countTexts(String s) {        \\n        int n=s.length();\\n        long[] res = new long[n];\\n        res[0]=1;        \\n        \\n        for(int i=1;i<n;i++){\\n             res[i]=res[i-1];             \\n             res[i]%=M;\\n            \\n             if(i-1>=0 && s.charAt(i-1)==s.charAt(i)){\\n                 res[i]+=i-2<0?1:res[i-2];            \\n                 res[i]%=M;\\n             }\\n                        \\n             if(i-2>=0 && s.charAt(i-2)==s.charAt(i-1) && s.charAt(i-1)==s.charAt(i)){\\n                 res[i]+=i-3<0?1:res[i-3];                   \\n                 res[i]%=M;\\n             }            \\n            \\n            if(i-3>=0 && (s.charAt(i)==\\'7\\'||s.charAt(i)==\\'9\\') && s.charAt(i-3)==s.charAt(i-2) &&s.charAt(i-2)==s.charAt(i-1) && s.charAt(i-1)==s.charAt(i)){\\n                res[i]+=i-4<0?1:res[i-4];\\n                res[i]%=M;\\n            }            \\n        }        \\n        return (int)res[n-1];\\n        \\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2018024,
                "title": "c-recursive-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    #define LL long long\\n    const LL MOD = 1000000000 + 7;\\n    \\n    LL dp[100001][5];\\n    \\n    LL ans_me(int ix, int jump) {\\n        if (ix == 0) return 1;\\n        LL &ret = dp[ix][jump];\\n        if (ret != -1) return ret;\\n        ret = 0;\\n        for (int i = 1; i <= jump; i++) {\\n            if (ix - i >= 0) {\\n                ret = (ret + ans_me(ix - i, jump)) % MOD;\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n    \\n    int map_to_dig[10];\\n    \\n    int countTexts(string pressedKeys) {\\n        memset(dp, -1, sizeof dp);\\n        for (int i = 2; i < 10; i++) map_to_dig[i] = 3;\\n        map_to_dig[7] = map_to_dig[9] = 4;\\n        LL res = 1;\\n        for (int i = 0; i < pressedKeys.size(); i++) {\\n            int ix = i;\\n            while(ix < pressedKeys.size() && pressedKeys[i] == pressedKeys[ix]) {\\n                ix++;\\n            }\\n            int typ = map_to_dig[ pressedKeys[i] - \\'0\\' ];\\n            res = (res * ans_me(ix - i, typ)) % MOD;\\n            i = ix - 1;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define LL long long\\n    const LL MOD = 1000000000 + 7;\\n    \\n    LL dp[100001][5];\\n    \\n    LL ans_me(int ix, int jump) {\\n        if (ix == 0) return 1;\\n        LL &ret = dp[ix][jump];\\n        if (ret != -1) return ret;\\n        ret = 0;\\n        for (int i = 1; i <= jump; i++) {\\n            if (ix - i >= 0) {\\n                ret = (ret + ans_me(ix - i, jump)) % MOD;\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n    \\n    int map_to_dig[10];\\n    \\n    int countTexts(string pressedKeys) {\\n        memset(dp, -1, sizeof dp);\\n        for (int i = 2; i < 10; i++) map_to_dig[i] = 3;\\n        map_to_dig[7] = map_to_dig[9] = 4;\\n        LL res = 1;\\n        for (int i = 0; i < pressedKeys.size(); i++) {\\n            int ix = i;\\n            while(ix < pressedKeys.size() && pressedKeys[i] == pressedKeys[ix]) {\\n                ix++;\\n            }\\n            int typ = map_to_dig[ pressedKeys[i] - \\'0\\' ];\\n            res = (res * ans_me(ix - i, typ)) % MOD;\\n            i = ix - 1;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017980,
                "title": "easy-java-dp-solution-similar-to-decode-ways-memoization",
                "content": "Consider taking a hashmap to store the characters corresponding to number of keypresses. Say if we press 3 twice, we store e in the hashmap as 33 => \\'e\\'.  Now we have put all the possible characters in the hashmap. \\n\\nWe now solve the problem like we did in [Decode Ways I](https://leetcode.com/problems/decode-ways/) and maintain the count, before storing the count in the DP make sure to take mod of the answer by 10^9 + 7.\\n\\n```\\nclass Solution {\\n    \\n        int mod = (int)1e9 + 7;\\n    public int countTexts(String keys, int idx, HashMap<Integer, Character> map, int[] dp) {\\n        \\n        \\n        if(idx >= keys.length()) {\\n            return 1;\\n        }   \\n        \\n        if(dp[idx] != -1) {\\n            return dp[idx];\\n        }\\n        \\n        int count = 0;\\n        char ch = keys.charAt(idx);\\n        \\n        if(ch != \\'0\\' || ch != \\'1\\') {\\n            count = (count + countTexts(keys, idx + 1, map, dp)) % mod;\\n        }\\n        \\n        if(idx < keys.length() - 1) {\\n            int num = (ch - \\'0\\') * 10 + (keys.charAt(idx + 1) - \\'0\\');\\n            if(map.containsKey(num)) {\\n                count = (count + countTexts(keys, idx + 2, map, dp)) % mod;\\n            }\\n        }\\n        \\n        if(idx < keys.length() - 2) {\\n            int num = (ch - \\'0\\') * 100 + (keys.charAt(idx + 1) - \\'0\\') * 10 + (keys.charAt(idx + 2) - \\'0\\');\\n            if(map.containsKey(num)) {\\n                count = (count + countTexts(keys, idx + 3, map, dp)) % mod;\\n            }\\n        }\\n        \\n        if(idx < keys.length() - 3) {\\n            int num = (ch - \\'0\\') * 1000 + (keys.charAt(idx + 1) - \\'0\\') * 100 + (keys.charAt(idx + 2) - \\'0\\') * 10 + (keys.charAt(idx + 3) - \\'0\\');\\n            if(map.containsKey(num)) {\\n                count = (count + countTexts(keys, idx + 4, map, dp)) % mod;\\n            }\\n        }\\n        \\n        return dp[idx] = count % mod;\\n    }\\n    \\n    public int countTexts(String pressedKeys) {\\n        \\n        HashMap<Integer, Character> map = new HashMap<>();\\n        map.put(2, \\'a\\');\\n        map.put(22, \\'b\\');\\n        map.put(222, \\'c\\');\\n        map.put(3, \\'d\\');\\n        map.put(33, \\'e\\');\\n        map.put(333, \\'f\\');\\n        map.put(4, \\'g\\');\\n        map.put(44, \\'h\\');\\n        map.put(444, \\'i\\');\\n        map.put(5, \\'j\\');\\n        map.put(55, \\'k\\');\\n        map.put(555, \\'l\\');\\n        map.put(6, \\'m\\');\\n        map.put(66, \\'n\\');\\n        map.put(666, \\'o\\');\\n        map.put(7, \\'p\\');\\n        map.put(77, \\'q\\');\\n        map.put(777, \\'r\\');\\n        map.put(7777, \\'s\\');\\n        map.put(8, \\'t\\');\\n        map.put(88, \\'u\\');\\n        map.put(888, \\'v\\');\\n        map.put(9, \\'w\\');\\n        map.put(99, \\'x\\');\\n        map.put(999, \\'y\\');\\n        map.put(9999, \\'z\\');\\n        \\n        int[] dp = new int[pressedKeys.length() + 1];\\n        Arrays.fill(dp, -1);\\n        return countTexts(pressedKeys, 0, map, dp);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    \\n        int mod = (int)1e9 + 7;\\n    public int countTexts(String keys, int idx, HashMap<Integer, Character> map, int[] dp) {\\n        \\n        \\n        if(idx >= keys.length()) {\\n            return 1;\\n        }   \\n        \\n        if(dp[idx] != -1) {\\n            return dp[idx];\\n        }\\n        \\n        int count = 0;\\n        char ch = keys.charAt(idx);\\n        \\n        if(ch != \\'0\\' || ch != \\'1\\') {\\n            count = (count + countTexts(keys, idx + 1, map, dp)) % mod;\\n        }\\n        \\n        if(idx < keys.length() - 1) {\\n            int num = (ch - \\'0\\') * 10 + (keys.charAt(idx + 1) - \\'0\\');\\n            if(map.containsKey(num)) {\\n                count = (count + countTexts(keys, idx + 2, map, dp)) % mod;\\n            }\\n        }\\n        \\n        if(idx < keys.length() - 2) {\\n            int num = (ch - \\'0\\') * 100 + (keys.charAt(idx + 1) - \\'0\\') * 10 + (keys.charAt(idx + 2) - \\'0\\');\\n            if(map.containsKey(num)) {\\n                count = (count + countTexts(keys, idx + 3, map, dp)) % mod;\\n            }\\n        }\\n        \\n        if(idx < keys.length() - 3) {\\n            int num = (ch - \\'0\\') * 1000 + (keys.charAt(idx + 1) - \\'0\\') * 100 + (keys.charAt(idx + 2) - \\'0\\') * 10 + (keys.charAt(idx + 3) - \\'0\\');\\n            if(map.containsKey(num)) {\\n                count = (count + countTexts(keys, idx + 4, map, dp)) % mod;\\n            }\\n        }\\n        \\n        return dp[idx] = count % mod;\\n    }\\n    \\n    public int countTexts(String pressedKeys) {\\n        \\n        HashMap<Integer, Character> map = new HashMap<>();\\n        map.put(2, \\'a\\');\\n        map.put(22, \\'b\\');\\n        map.put(222, \\'c\\');\\n        map.put(3, \\'d\\');\\n        map.put(33, \\'e\\');\\n        map.put(333, \\'f\\');\\n        map.put(4, \\'g\\');\\n        map.put(44, \\'h\\');\\n        map.put(444, \\'i\\');\\n        map.put(5, \\'j\\');\\n        map.put(55, \\'k\\');\\n        map.put(555, \\'l\\');\\n        map.put(6, \\'m\\');\\n        map.put(66, \\'n\\');\\n        map.put(666, \\'o\\');\\n        map.put(7, \\'p\\');\\n        map.put(77, \\'q\\');\\n        map.put(777, \\'r\\');\\n        map.put(7777, \\'s\\');\\n        map.put(8, \\'t\\');\\n        map.put(88, \\'u\\');\\n        map.put(888, \\'v\\');\\n        map.put(9, \\'w\\');\\n        map.put(99, \\'x\\');\\n        map.put(999, \\'y\\');\\n        map.put(9999, \\'z\\');\\n        \\n        int[] dp = new int[pressedKeys.length() + 1];\\n        Arrays.fill(dp, -1);\\n        return countTexts(pressedKeys, 0, map, dp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017961,
                "title": "memo-dp-easy-to-understand",
                "content": "intution->we have to count how much combinations are possible from a number\\neg abc->2,22,222\\nif (2222)->not valid;break\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    int mod = 1000000007;\\n    map<int,int> index;\\n    vector<string>mp{\"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n    map<int,int> dp;\\n    int solve(string &s, int i){\\n        if (i>=s.size()){\\n            return 1;\\n        }\\n        if (dp.find(i)!=dp.end()){\\n            return dp[i];\\n        }\\n        int ways= 0;\\n        int sz = index[s[i]-\\'0\\'];\\n        int count = 0;\\n        for (int j =i; j<s.size(); j++){\\n            count++;\\n            if (s[i]==s[j] && count<=sz){\\n                ways+=solve(s,j+1);\\n            }\\n            else{\\n                break;\\n            }\\n            \\n            ways%=mod;\\n        }\\n         return dp[i] = ways%mod;\\n        \\n    }\\n    int countTexts(string s) {\\n        int count = 0;\\n        for (auto it:mp){\\n            string temp = it;\\n            count++;\\n            for (int i =0; i<temp.size(); i++){\\n                index[count] = temp.size();\\n            }\\n        }\\n        \\n        return solve(s,0);\\n        \\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    int mod = 1000000007;\\n    map<int,int> index;\\n    vector<string>mp{\"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\\n    map<int,int> dp;\\n    int solve(string &s, int i){\\n        if (i>=s.size()){\\n            return 1;\\n        }\\n        if (dp.find(i)!=dp.end()){\\n            return dp[i];\\n        }\\n        int ways= 0;\\n        int sz = index[s[i]-\\'0\\'];\\n        int count = 0;\\n        for (int j =i; j<s.size(); j++){\\n            count++;\\n            if (s[i]==s[j] && count<=sz){\\n                ways+=solve(s,j+1);\\n            }\\n            else{\\n                break;\\n            }\\n            \\n            ways%=mod;\\n        }\\n         return dp[i] = ways%mod;\\n        \\n    }\\n    int countTexts(string s) {\\n        int count = 0;\\n        for (auto it:mp){\\n            string temp = it;\\n            count++;\\n            for (int i =0; i<temp.size(); i++){\\n                index[count] = temp.size();\\n            }\\n        }\\n        \\n        return solve(s,0);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017930,
                "title": "c-recursive-o-n-solution",
                "content": "```\\nclass Solution {\\n    \\n    #define ll long long \\n    int mod = 1000000007 ;\\n    \\n    int go( string &A , int i , ll t[] )\\n    {\\n        int N = A.size();\\n        if(t[i] != -1 ) return t[i] ;\\n        \\n        ll res = go( A , i+1 , t )%mod ;  // default case \\n        \\n        if( i+1 < N && A[i+1] == A[i] )\\n            res += go( A , i+2 , t );  // two consecutive can be grouped \\n        \\n        res %= mod ;\\n        \\n        if( i+2 < N && A[i+1] == A[i] && A[i+2] == A[i] )\\n            res += go( A , i+3 , t ); // three consecutive can be grouped \\n        \\n        res %= mod ;\\n        \\n        if( A[i] == \\'7\\' || A[i] == \\'9\\' ) // special cases \\n        {\\n            if( i+3 < N && A[i+1] == A[i] && A[i+2] == A[i] && A[i+3] == A[i] )\\n                res += go( A , i+4 , t ); // 4 consecutive can be grouped \\n        }\\n        \\n        return t[i] = res%mod ;\\n    }\\n    \\npublic:\\n    int countTexts(string A ) {\\n        \\n        int N = A.size();\\n        ll t[N+1];\\n        memset( t , -1 , sizeof t );\\n        t[N] = 1 ;\\n        \\n        return go( A , 0 , t )%mod ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    \\n    #define ll long long \\n    int mod = 1000000007 ;\\n    \\n    int go( string &A , int i , ll t[] )\\n    {\\n        int N = A.size();\\n        if(t[i] != -1 ) return t[i] ;\\n        \\n        ll res = go( A , i+1 , t )%mod ;  // default case \\n        \\n        if( i+1 < N && A[i+1] == A[i] )\\n            res += go( A , i+2 , t );  // two consecutive can be grouped \\n        \\n        res %= mod ;\\n        \\n        if( i+2 < N && A[i+1] == A[i] && A[i+2] == A[i] )\\n            res += go( A , i+3 , t ); // three consecutive can be grouped \\n        \\n        res %= mod ;\\n        \\n        if( A[i] == \\'7\\' || A[i] == \\'9\\' ) // special cases \\n        {\\n            if( i+3 < N && A[i+1] == A[i] && A[i+2] == A[i] && A[i+3] == A[i] )\\n                res += go( A , i+4 , t ); // 4 consecutive can be grouped \\n        }\\n        \\n        return t[i] = res%mod ;\\n    }\\n    \\npublic:\\n    int countTexts(string A ) {\\n        \\n        int N = A.size();\\n        ll t[N+1];\\n        memset( t , -1 , sizeof t );\\n        t[N] = 1 ;\\n        \\n        return go( A , 0 , t )%mod ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017868,
                "title": "updated-can-someone-please-explain-how-to-make-it-memory-efficient",
                "content": "update: found my mistake , i missed an &  with the string due to which it was copied again and again with every recursion \\uD83E\\uDD72. \\n```\\nclass Solution {\\npublic:\\n    int dp(int i,string pk,vector<int> &lim,vector<int> &v)\\n    {if(i==pk.size()){return 1;}\\n     if(v[i]!=-1){return v[i];}\\n        int ways=0,cnt=0;\\n        for(int j=i;j<pk.size();j++)\\n        {cnt++;\\n            \\n            ways=(ways+dp(j+1,pk,lim,v))%1000000007;\\n            if(pk[j]!=pk[j+1]||cnt>=lim[pk[j]-\\'0\\']){break;}\\n        }\\n     return v[i]=ways;\\n    }\\n    int countTexts(string pressedKeys) {\\n        vector<int> lim(10,3);lim[7]++;lim[9]++;\\n        vector<int> v(pressedKeys.size(),-1);\\n        return dp(0,pressedKeys,lim,v);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp(int i,string pk,vector<int> &lim,vector<int> &v)\\n    {if(i==pk.size()){return 1;}\\n     if(v[i]!=-1){return v[i];}\\n        int ways=0,cnt=0;\\n        for(int j=i;j<pk.size();j++)\\n        {cnt++;\\n            \\n            ways=(ways+dp(j+1,pk,lim,v))%1000000007;\\n            if(pk[j]!=pk[j+1]||cnt>=lim[pk[j]-\\'0\\']){break;}\\n        }\\n     return v[i]=ways;\\n    }\\n    int countTexts(string pressedKeys) {\\n        vector<int> lim(10,3);lim[7]++;lim[9]++;\\n        vector<int> v(pressedKeys.size(),-1);\\n        return dp(0,pressedKeys,lim,v);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017769,
                "title": "java-count-dp-bottom-up",
                "content": "1, count the numbers in the given string, \\npressedKeys 22235555\\ncompressed  3 of 2s ; 1 of 3s, 4 of 5s\\n\\n2, calculate 2 dp arrays for the number with 3 possible letters and 4 possible letters till the maximum \\ndp3[m] is the possible ways of keys for m same numbers (which has 3 letters on the button)\\ndp4[m] is the possible ways of keys for m same numbers (which has 4 letters on the button)\\n\\ndp3: 0,1,2,4,7,...\\ndp4: 1,1,2,4,8,...\\n\\n3, multiply the possibilitis to get the result.\\n\\n\\n```\\nclass Solution {\\n    private int MOD = 1000000007;\\n    public int countTexts(String pressedKeys) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        int maxLen = 0;\\n        char prevCh = \\'a\\';\\n        int curLen = 0;\\n        for(int i=0;i<pressedKeys.length();i++){\\n            if(pressedKeys.charAt(i) == prevCh){\\n                curLen++;\\n                maxLen = Math.max(maxLen,curLen);\\n            }else{\\n                if(curLen >0){\\n                    list.add(Arrays.asList(curLen,prevCh-\\'0\\'));\\n                }\\n                curLen = 1;\\n                prevCh = pressedKeys.charAt(i);\\n            }\\n        }\\n        list.add(Arrays.asList(curLen,prevCh-\\'0\\'));\\n        \\n       // System.out.println(list);        \\n        \\n        long[] dp3 = new long[Math.max(maxLen+1,5)];\\n        long[] dp4 = new long[Math.max(maxLen+1,5)];             \\n        \\n        dp3[1] = 1;\\n        dp3[2] = 2;\\n        dp3[3] = 4;\\n        \\n        dp4[0] = 1;\\n        dp4[1] = 1;\\n        dp4[2] = 2;\\n        dp4[3] = 4;\\n\\n        for(int i=4;i<dp3.length;i++){            \\n            dp3[i] = ((long)dp3[i-1]+dp3[i-2]+dp3[i-3])%MOD;\\n            dp4[i] = ((long)dp4[i-1]+dp4[i-2]+dp4[i-3]+dp4[i-4])%MOD;\\n        }\\n        \\n        //System.out.println(Arrays.toString(dp3));\\n        //System.out.println(Arrays.toString(dp4));\\n        \\n        long ret = 1;\\n        for(List<Integer> num:list){\\n            long nextVal = 1;\\n            if(num.get(1)==7 || num.get(1)==9){\\n                nextVal = dp4[num.get(0)];\\n            }else            {\\n                nextVal = dp3[num.get(0)];\\n            }\\n            ret =  (ret*nextVal)%MOD;\\n        }\\n        \\n        return (int)ret;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int MOD = 1000000007;\\n    public int countTexts(String pressedKeys) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        int maxLen = 0;\\n        char prevCh = \\'a\\';\\n        int curLen = 0;\\n        for(int i=0;i<pressedKeys.length();i++){\\n            if(pressedKeys.charAt(i) == prevCh){\\n                curLen++;\\n                maxLen = Math.max(maxLen,curLen);\\n            }else{\\n                if(curLen >0){\\n                    list.add(Arrays.asList(curLen,prevCh-\\'0\\'));\\n                }\\n                curLen = 1;\\n                prevCh = pressedKeys.charAt(i);\\n            }\\n        }\\n        list.add(Arrays.asList(curLen,prevCh-\\'0\\'));\\n        \\n       // System.out.println(list);        \\n        \\n        long[] dp3 = new long[Math.max(maxLen+1,5)];\\n        long[] dp4 = new long[Math.max(maxLen+1,5)];             \\n        \\n        dp3[1] = 1;\\n        dp3[2] = 2;\\n        dp3[3] = 4;\\n        \\n        dp4[0] = 1;\\n        dp4[1] = 1;\\n        dp4[2] = 2;\\n        dp4[3] = 4;\\n\\n        for(int i=4;i<dp3.length;i++){            \\n            dp3[i] = ((long)dp3[i-1]+dp3[i-2]+dp3[i-3])%MOD;\\n            dp4[i] = ((long)dp4[i-1]+dp4[i-2]+dp4[i-3]+dp4[i-4])%MOD;\\n        }\\n        \\n        //System.out.println(Arrays.toString(dp3));\\n        //System.out.println(Arrays.toString(dp4));\\n        \\n        long ret = 1;\\n        for(List<Integer> num:list){\\n            long nextVal = 1;\\n            if(num.get(1)==7 || num.get(1)==9){\\n                nextVal = dp4[num.get(0)];\\n            }else            {\\n                nextVal = dp3[num.get(0)];\\n            }\\n            ret =  (ret*nextVal)%MOD;\\n        }\\n        \\n        return (int)ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017767,
                "title": "java-dp",
                "content": "```\\nclass Solution {\\n    public int countTexts(String pressedKeys) {\\n        int n=pressedKeys.length();\\n        \\n        long [] dp = new long[n+1];\\n        dp[0]=1;\\n        dp[1]=1;\\n        \\n        for(int i=1;i<n;i++){\\n            char ch=pressedKeys.charAt(i);\\n            int j=i;\\n            if(ch!=\\'7\\' && ch!=\\'9\\'){\\n                while(j>0 && j>=i-2 && pressedKeys.charAt(j-1)==ch){\\n                    dp[i+1] += dp[j]%1000000007;\\n                    j--;\\n                }\\n                if(j!=i-3){\\n                    dp[i+1]+=dp[j]%1000000007;\\n                }\\n            }else{\\n                while(j>0 && j>=i-3 && pressedKeys.charAt(j-1)==ch){\\n                    dp[i+1] += dp[j]%1000000007;\\n                    j--;\\n                }\\n                if(j!=i-4){\\n                    dp[i+1]+=dp[j]%1000000007;\\n                }\\n            }\\n        }\\n        return (int) (dp[n]%1000000007);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int countTexts(String pressedKeys) {\\n        int n=pressedKeys.length();\\n        \\n        long [] dp = new long[n+1];\\n        dp[0]=1;\\n        dp[1]=1;\\n        \\n        for(int i=1;i<n;i++){\\n            char ch=pressedKeys.charAt(i);\\n            int j=i;\\n            if(ch!=\\'7\\' && ch!=\\'9\\'){\\n                while(j>0 && j>=i-2 && pressedKeys.charAt(j-1)==ch){\\n                    dp[i+1] += dp[j]%1000000007;\\n                    j--;\\n                }\\n                if(j!=i-3){\\n                    dp[i+1]+=dp[j]%1000000007;\\n                }\\n            }else{\\n                while(j>0 && j>=i-3 && pressedKeys.charAt(j-1)==ch){\\n                    dp[i+1] += dp[j]%1000000007;\\n                    j--;\\n                }\\n                if(j!=i-4){\\n                    dp[i+1]+=dp[j]%1000000007;\\n                }\\n            }\\n        }\\n        return (int) (dp[n]%1000000007);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017766,
                "title": "c-dp-o-n-solution",
                "content": "```\\nlong long mod=1000000007;\\n    \\n    long long ans[100001];\\n    \\n    long long solve(string &s,int i)\\n    {\\n        if(i==s.size())\\n        {\\n            return 1;\\n        }\\n        \\n        if(ans[i]!=-1)\\n        {\\n            return ans[i];\\n        }\\n        \\n        long long cnt=0;\\n        \\n        if(s[i]==\\'9\\'||s[i]==\\'7\\')\\n        {\\n            char c=s[i];\\n            \\n            for(int j=i;j<i+4;j++)\\n            {\\n                if(s[j]==c)\\n                {\\n                    cnt=(cnt+solve(s,j+1))%mod;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            char c=s[i];\\n            \\n            for(int j=i;j<i+3;j++)\\n            {\\n                if(s[j]==c)\\n                {\\n                    cnt=(cnt+solve(s,j+1))%mod;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n        }\\n        ans[i]=cnt%mod;\\n        return ans[i];\\n    }\\n    int countTexts(string pressedKeys) \\n    {\\n        memset(ans,-1,sizeof(ans));\\n        \\n        long long fans=solve(pressedKeys,0);\\n        return fans;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nlong long mod=1000000007;\\n    \\n    long long ans[100001];\\n    \\n    long long solve(string &s,int i)\\n    {\\n        if(i==s.size())\\n        {\\n            return 1;\\n        }\\n        \\n        if(ans[i]!=-1)\\n        {\\n            return ans[i];\\n        }\\n        \\n        long long cnt=0;\\n        \\n        if(s[i]==\\'9\\'||s[i]==\\'7\\')\\n        {\\n            char c=s[i];\\n            \\n            for(int j=i;j<i+4;j++)\\n            {\\n                if(s[j]==c)\\n                {\\n                    cnt=(cnt+solve(s,j+1))%mod;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            char c=s[i];\\n            \\n            for(int j=i;j<i+3;j++)\\n            {\\n                if(s[j]==c)\\n                {\\n                    cnt=(cnt+solve(s,j+1))%mod;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n        }\\n        ans[i]=cnt%mod;\\n        return ans[i];\\n    }\\n    int countTexts(string pressedKeys) \\n    {\\n        memset(ans,-1,sizeof(ans));\\n        \\n        long long fans=solve(pressedKeys,0);\\n        return fans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 4084399,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string>v={\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\\n                    \"tuv\",\"wxyz\"};\\n    vector<int>dp;\\n    const int mod=1e9+7;\\n    int countTexts(string s) {\\n        dp.resize(s.length(),-1);\\n        return fun(s,0);\\n    }\\n    int fun(string &s,int idx)\\n    {\\n        if(idx==s.length())\\n        {\\n            return 1;\\n        }\\n        if(dp[idx]!=-1)\\n        {\\n            return dp[idx];\\n        }\\n        // cout<<idx<<endl;\\n        int num=s[idx]-\\'0\\';\\n        int count=0;\\n        for(int i=0;i<v[num].length();i++)\\n        {\\n            if((idx+i)<s.length() and s[idx]==s[idx+i])\\n            {\\n                count+=fun(s,idx+i+1);\\n                count=count%mod;\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        return dp[idx]=count%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string>v={\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\\n                    \"tuv\",\"wxyz\"};\\n    vector<int>dp;\\n    const int mod=1e9+7;\\n    int countTexts(string s) {\\n        dp.resize(s.length(),-1);\\n        return fun(s,0);\\n    }\\n    int fun(string &s,int idx)\\n    {\\n        if(idx==s.length())\\n        {\\n            return 1;\\n        }\\n        if(dp[idx]!=-1)\\n        {\\n            return dp[idx];\\n        }\\n        // cout<<idx<<endl;\\n        int num=s[idx]-\\'0\\';\\n        int count=0;\\n        for(int i=0;i<v[num].length();i++)\\n        {\\n            if((idx+i)<s.length() and s[idx]==s[idx+i])\\n            {\\n                count+=fun(s,idx+i+1);\\n                count=count%mod;\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        return dp[idx]=count%mod;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4067699,
                "title": "c-beats-93-using-combination-sum-iv",
                "content": "![Sighhhhhhhhhhhh 2023-09-20 at 17.39.06.png](https://assets.leetcode.com/users/images/785614dc-1c1f-4df9-815a-15654ac45cba_1695199155.8621168.png)\\n\\nThis problem can use the same algorithm from [377. Combination Sum IV](https://leetcode.com/problems/combination-sum-iv/).\\n\\nEg if there is a string of three 4s, \"444\"\\nThen we need to know how many ways she could have pressed them\\neg (1,1,1) or (1,2) or (2,1) or (3)\\nThis is Combination Sum IV.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static const int MOD = 1e9 + 7;\\n\\n    // September 20 2023\\n    int countTexts(const string& pressedKeys) {\\n        unsigned long long total = 1;\\n        for (int i = 0; i < pressedKeys.length(); i++) {\\n            char c = pressedKeys[i];\\n            int j = i + 1;\\n            while (j < pressedKeys.length() && c == pressedKeys[j]) j++;\\n            int numLetters = (c == \\'7\\' || c == \\'9\\') ? 4 : 3;\\n            total *= (combinationSum4(numLetters, j - i) % MOD);\\n            total %= MOD;\\n            i = j - 1;\\n        }\\n        return total;\\n    }\\nprivate:\\n    // numLetters = 4 for 7 or 9, 3 otherwise\\n    unsigned long long combinationSum4(const int numLetters, const int target) {\\n        unsigned long long dp[target + 1];\\n        memset(dp, 0, sizeof(dp));\\n        dp[target] = 1;\\n        for (int i = target - 1; i >= 0; i--) {\\n            for (int j = 1; j <= numLetters; j++) { // can press 1,2,3, or 4 times\\n                if (j + i <= target) {\\n                    dp[i] += dp[j + i] % MOD;\\n                }\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static const int MOD = 1e9 + 7;\\n\\n    // September 20 2023\\n    int countTexts(const string& pressedKeys) {\\n        unsigned long long total = 1;\\n        for (int i = 0; i < pressedKeys.length(); i++) {\\n            char c = pressedKeys[i];\\n            int j = i + 1;\\n            while (j < pressedKeys.length() && c == pressedKeys[j]) j++;\\n            int numLetters = (c == \\'7\\' || c == \\'9\\') ? 4 : 3;\\n            total *= (combinationSum4(numLetters, j - i) % MOD);\\n            total %= MOD;\\n            i = j - 1;\\n        }\\n        return total;\\n    }\\nprivate:\\n    // numLetters = 4 for 7 or 9, 3 otherwise\\n    unsigned long long combinationSum4(const int numLetters, const int target) {\\n        unsigned long long dp[target + 1];\\n        memset(dp, 0, sizeof(dp));\\n        dp[target] = 1;\\n        for (int i = target - 1; i >= 0; i--) {\\n            for (int j = 1; j <= numLetters; j++) { // can press 1,2,3, or 4 times\\n                if (j + i <= target) {\\n                    dp[i] += dp[j + i] % MOD;\\n                }\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4067382,
                "title": "ruby-solution-inspired-by-owen1605",
                "content": "# Intuition\\nAll credits to https://leetcode.com/problems/count-number-of-texts/solutions/2018336/python-dp-with-diagrams-for-beginners/\\nRewrite in Ruby to help ruby devs read the code easier\\n\\n\\n# Code\\n```\\n# @param {String} pressed_keys\\n# @return {Integer}\\ndef count_texts(pressed_keys) # \"22233\"\\n    dp = [1] + Array.new(pressed_keys.size, 0) # [1, 0, 0, 0, 0, 0]\\n\\n    pressed_keys.chars.each_with_index do |key, i|\\n        dp[i + 1] = dp[i]\\n\\n        # index 0 [1, 1, 0, 0, 0, 0]\\n        # index 1 [1, 1, 1, 0, 0, 0]\\n        # index 2 [1, 1, 2, 2, 0, 0]\\n        # 3   [1, 1, 2, 4, 4, 0]\\n        # 4   [1, 1, 2, 4, 4, 4]\\n\\n        # check if the current number is the same as previous one, eg: 22 \\n        if i >= 1 && pressed_keys[i - 1] == key\\n            dp[i + 1] += dp[i -1]\\n\\n            if i >= 2 && pressed_keys[i - 2] == key\\n                dp[i + 1] += dp[i - 2]\\n\\n                # 7 and 9 can have 4 possible letters\\n                if i >= 3 && pressed_keys[i-3] == key && [\"9\", \"7\"].include?(key)\\n                    dp[i+1] += dp[i-3]\\n                end\\n            end    \\n        end\\n\\n        dp[i+1] %= 10**9 + 7    \\n    end\\n\\n    dp[-1]\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {String} pressed_keys\\n# @return {Integer}\\ndef count_texts(pressed_keys) # \"22233\"\\n    dp = [1] + Array.new(pressed_keys.size, 0) # [1, 0, 0, 0, 0, 0]\\n\\n    pressed_keys.chars.each_with_index do |key, i|\\n        dp[i + 1] = dp[i]\\n\\n        # index 0 [1, 1, 0, 0, 0, 0]\\n        # index 1 [1, 1, 1, 0, 0, 0]\\n        # index 2 [1, 1, 2, 2, 0, 0]\\n        # 3   [1, 1, 2, 4, 4, 0]\\n        # 4   [1, 1, 2, 4, 4, 4]\\n\\n        # check if the current number is the same as previous one, eg: 22 \\n        if i >= 1 && pressed_keys[i - 1] == key\\n            dp[i + 1] += dp[i -1]\\n\\n            if i >= 2 && pressed_keys[i - 2] == key\\n                dp[i + 1] += dp[i - 2]\\n\\n                # 7 and 9 can have 4 possible letters\\n                if i >= 3 && pressed_keys[i-3] == key && [\"9\", \"7\"].include?(key)\\n                    dp[i+1] += dp[i-3]\\n                end\\n            end    \\n        end\\n\\n        dp[i+1] %= 10**9 + 7    \\n    end\\n\\n    dp[-1]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4046080,
                "title": "python-dp-o-n-o-1-memory-100-runtime-91-4",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing \"dp[e] = dp[e-1] << 1\" and optimizing space complexity.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**O(n)**\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**O(1)**\\n# Code\\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        dp = [1,0,0,0,0]\\n        mod = 10**9 + 7\\n        count = 1\\n        for i in range(1,len(pressedKeys)):\\n            e = i%5\\n            if pressedKeys[i] != pressedKeys[i-1]:\\n                dp[e] = dp[e-1] % mod\\n                count = 1\\n            else:\\n                count += 1\\n                if count <= 3 and pressedKeys[i] in \"234568\" or count <= 4 and pressedKeys[i] in \"79\":\\n                    dp[e] = (dp[e-1] <<1 ) % mod\\n                else:\\n                    dp[e] = (dp[e-1] + dp[e-2] + dp[e-3]) % mod\\n                    if pressedKeys[i] in \"79\":\\n                        dp[e] = (dp[e] + dp[e-4]) % mod\\n        \\n        return dp[(len(pressedKeys)-1) % 5]\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        dp = [1,0,0,0,0]\\n        mod = 10**9 + 7\\n        count = 1\\n        for i in range(1,len(pressedKeys)):\\n            e = i%5\\n            if pressedKeys[i] != pressedKeys[i-1]:\\n                dp[e] = dp[e-1] % mod\\n                count = 1\\n            else:\\n                count += 1\\n                if count <= 3 and pressedKeys[i] in \"234568\" or count <= 4 and pressedKeys[i] in \"79\":\\n                    dp[e] = (dp[e-1] <<1 ) % mod\\n                else:\\n                    dp[e] = (dp[e-1] + dp[e-2] + dp[e-3]) % mod\\n                    if pressedKeys[i] in \"79\":\\n                        dp[e] = (dp[e] + dp[e-4]) % mod\\n        \\n        return dp[(len(pressedKeys)-1) % 5]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984152,
                "title": "python-2-liner",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n`F(a,b)` function recursively counts number of alternatives when you pressed a number that includes `b` character `a` times. \\n`K` list holds number of characters in every number from 2 to 9. \\nWe return multiplication of number of alternatives for every number group in `P` string with using `groupby`. \\n\\n# Code\\n```\\nclass Solution:\\n    def countTexts(self, P, m = 10**9+7, K = [0,0,3,3,3,3,3,4,3,4], c = cache):\\n        F = c(lambda a,b:1 if a<2 else sum(F(a-i,b) for i in range(1,min(a+1,b+1))) % m)\\n        return prod(F(len(list(v)),K[int(k)]) for k,v in groupby(P)) % m\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countTexts(self, P, m = 10**9+7, K = [0,0,3,3,3,3,3,4,3,4], c = cache):\\n        F = c(lambda a,b:1 if a<2 else sum(F(a-i,b) for i in range(1,min(a+1,b+1))) % m)\\n        return prod(F(len(list(v)),K[int(k)]) for k,v in groupby(P)) % m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951663,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int countTexts(string s) \\n    {\\n        int ct;\\n        ct=1;\\n\\n        long long ans;\\n        ans=1;\\n\\n        vector<long long> count1(s.size()+3);\\n        count1[1]=1;\\n        count1[2]=2;\\n        count1[3]=4;\\n\\n        vector<long long> count2(s.size()+4);\\n        count2[1]=1;\\n        count2[2]=2;\\n        count2[3]=4;\\n        count2[4]=8;\\n\\n        for(int i=4;i<=s.size();i++)\\n        {\\n            count1[i]=count1[i-1]+count1[i-2]+count1[i-3];\\n            count1[i]%=1000000007;\\n        }\\n\\n        for(int i=5;i<=s.size();i++)\\n        {\\n            count2[i]=count2[i-1]+count2[i-2]+count2[i-3]+count2[i-4];\\n            count2[i]%=1000000007;\\n        }\\n\\n        for(int i=0;i<s.size()-1;i++)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                ct++;\\n            }\\n\\n            else\\n            {\\n                if(s[i]==\\'7\\' || s[i]==\\'9\\')\\n                {\\n                    ans*=count2[ct];\\n                }\\n\\n                else\\n                {\\n                    ans*=count1[ct];\\n                }\\n\\n                ans%=1000000007;\\n                ct=1;\\n            }\\n        }\\n\\n        if(s[s.size()-1]==\\'7\\' || s[s.size()-1]==\\'9\\')\\n        {\\n            ans*=count2[ct];\\n        }\\n\\n        else\\n        {\\n            ans*=count1[ct];\\n        }\\n\\n        ans%=1000000007;\\n        return ans;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int countTexts(string s) \\n    {\\n        int ct;\\n        ct=1;\\n\\n        long long ans;\\n        ans=1;\\n\\n        vector<long long> count1(s.size()+3);\\n        count1[1]=1;\\n        count1[2]=2;\\n        count1[3]=4;\\n\\n        vector<long long> count2(s.size()+4);\\n        count2[1]=1;\\n        count2[2]=2;\\n        count2[3]=4;\\n        count2[4]=8;\\n\\n        for(int i=4;i<=s.size();i++)\\n        {\\n            count1[i]=count1[i-1]+count1[i-2]+count1[i-3];\\n            count1[i]%=1000000007;\\n        }\\n\\n        for(int i=5;i<=s.size();i++)\\n        {\\n            count2[i]=count2[i-1]+count2[i-2]+count2[i-3]+count2[i-4];\\n            count2[i]%=1000000007;\\n        }\\n\\n        for(int i=0;i<s.size()-1;i++)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                ct++;\\n            }\\n\\n            else\\n            {\\n                if(s[i]==\\'7\\' || s[i]==\\'9\\')\\n                {\\n                    ans*=count2[ct];\\n                }\\n\\n                else\\n                {\\n                    ans*=count1[ct];\\n                }\\n\\n                ans%=1000000007;\\n                ct=1;\\n            }\\n        }\\n\\n        if(s[s.size()-1]==\\'7\\' || s[s.size()-1]==\\'9\\')\\n        {\\n            ans*=count2[ct];\\n        }\\n\\n        else\\n        {\\n            ans*=count1[ct];\\n        }\\n\\n        ans%=1000000007;\\n        return ans;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949119,
                "title": "iterative-dynamic-programming-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n  int countTexts(string s) {\\n    int n = s.size();\\n    vector<int> dp(n + 1);\\n    dp[0] = 1;\\n    const int mod = 1000000007;\\n    for(int i = 0; i < n; i++)  {\\n      if(s[i] == \\'7\\' || s[i] == \\'9\\')  {\\n        for(int j = 1; j < 5; j++)  {\\n          if(i + j <= n && s[i] == s[i + j - 1])  {\\n            (dp[i + j] += dp[i]) %= mod;\\n          } else  {\\n            break;\\n          }\\n        }\\n      } else  {\\n        for(int j = 1; j < 4; j++)  {\\n          if(i + j <= n && s[i] == s[i + j - 1])  {\\n            (dp[i + j] += dp[i]) %= mod;\\n          } else  {\\n            break;\\n          }\\n        }\\n      }\\n    }\\n    return dp[n];\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int countTexts(string s) {\\n    int n = s.size();\\n    vector<int> dp(n + 1);\\n    dp[0] = 1;\\n    const int mod = 1000000007;\\n    for(int i = 0; i < n; i++)  {\\n      if(s[i] == \\'7\\' || s[i] == \\'9\\')  {\\n        for(int j = 1; j < 5; j++)  {\\n          if(i + j <= n && s[i] == s[i + j - 1])  {\\n            (dp[i + j] += dp[i]) %= mod;\\n          } else  {\\n            break;\\n          }\\n        }\\n      } else  {\\n        for(int j = 1; j < 4; j++)  {\\n          if(i + j <= n && s[i] == s[i + j - 1])  {\\n            (dp[i + j] += dp[i]) %= mod;\\n          } else  {\\n            break;\\n          }\\n        }\\n      }\\n    }\\n    return dp[n];\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941922,
                "title": "c-dp-more-readable-class",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countTexts(string pressedKeys) {\\n        _keys = pressedKeys;\\n        for (int i = 0; i < (int) _keys.size(); i ++) {\\n            countTextsInternal(i);\\n        }\\n        return _result.back() % maxVal;\\n    }\\nprivate:\\n    const int maxVal = 1000000007;\\n    const int maxDeq = 4;\\n    deque<int> _result;\\n    int _deqStartIndex {0};\\n    string _keys;\\n\\n    void countTextsInternal(const int index) {\\n        const int startIndex = _keys.size() - index - 1; // string\\'s start index\\n        const int maxSeq = maxSequence(_keys[startIndex]);\\n        int seq = 1;\\n\\n        for (int i = 1; i < maxSeq && (index - i >= 0); i ++) {\\n            if (_keys[i + startIndex] == _keys[startIndex]) {\\n                seq ++;\\n            } else {\\n                break;\\n            }\\n        }\\n\\n        int count = 0; \\n        if (index == 0) {\\n            count = 1;\\n        } else if (seq == 1) {\\n            count = getPrevResult(index - 1);\\n        } else {\\n            for (int i = 0; i < seq; i ++) {\\n                count += getPrevResult(index - i - 1);\\n                if (count > maxVal) {\\n                    count -= maxVal;\\n                }\\n            }\\n        }\\n\\n        setCurrentResult(count);\\n    }\\n\\n    void setCurrentResult(int value) {\\n        _result.push_back(value);\\n        if (_result.size() > maxDeq) {\\n            _result.pop_front();\\n            _deqStartIndex++;\\n        }\\n    }\\n\\n    int getPrevResult(int index) {\\n        if (index < 0) {\\n            return 1; // it\\'s the case itself\\n        }\\n        return _result[index - _deqStartIndex];\\n    }\\n\\n    int maxSequence(char c) {\\n\\n        switch (c) {\\n            case \\'8\\' :\\n            case \\'6\\' :\\n            case \\'5\\' :\\n            case \\'4\\' :\\n            case \\'3\\' :\\n            case \\'2\\' : return 3;\\n            case \\'9\\' :\\n            case \\'7\\' : return 4;\\n        }\\n        printf(\"Unrecognised digit [%c] (%d)\\\\n\", c, c);\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countTexts(string pressedKeys) {\\n        _keys = pressedKeys;\\n        for (int i = 0; i < (int) _keys.size(); i ++) {\\n            countTextsInternal(i);\\n        }\\n        return _result.back() % maxVal;\\n    }\\nprivate:\\n    const int maxVal = 1000000007;\\n    const int maxDeq = 4;\\n    deque<int> _result;\\n    int _deqStartIndex {0};\\n    string _keys;\\n\\n    void countTextsInternal(const int index) {\\n        const int startIndex = _keys.size() - index - 1; // string\\'s start index\\n        const int maxSeq = maxSequence(_keys[startIndex]);\\n        int seq = 1;\\n\\n        for (int i = 1; i < maxSeq && (index - i >= 0); i ++) {\\n            if (_keys[i + startIndex] == _keys[startIndex]) {\\n                seq ++;\\n            } else {\\n                break;\\n            }\\n        }\\n\\n        int count = 0; \\n        if (index == 0) {\\n            count = 1;\\n        } else if (seq == 1) {\\n            count = getPrevResult(index - 1);\\n        } else {\\n            for (int i = 0; i < seq; i ++) {\\n                count += getPrevResult(index - i - 1);\\n                if (count > maxVal) {\\n                    count -= maxVal;\\n                }\\n            }\\n        }\\n\\n        setCurrentResult(count);\\n    }\\n\\n    void setCurrentResult(int value) {\\n        _result.push_back(value);\\n        if (_result.size() > maxDeq) {\\n            _result.pop_front();\\n            _deqStartIndex++;\\n        }\\n    }\\n\\n    int getPrevResult(int index) {\\n        if (index < 0) {\\n            return 1; // it\\'s the case itself\\n        }\\n        return _result[index - _deqStartIndex];\\n    }\\n\\n    int maxSequence(char c) {\\n\\n        switch (c) {\\n            case \\'8\\' :\\n            case \\'6\\' :\\n            case \\'5\\' :\\n            case \\'4\\' :\\n            case \\'3\\' :\\n            case \\'2\\' : return 3;\\n            case \\'9\\' :\\n            case \\'7\\' : return 4;\\n        }\\n        printf(\"Unrecognised digit [%c] (%d)\\\\n\", c, c);\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873773,
                "title": "python-dp",
                "content": "# Intuition\\n- We cant count the ways using permutations and combinations if you think about it, we will need the ones that come next\\n- Hence recursion and DP\\n- Choose Each possibility and add it up\\n\\n# Approach\\n- Count possibilities using recursion\\n\\n# Complexity\\n- Time complexity:\\n- O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        @cache\\n        def solve(index):\\n            if index >= len(pressedKeys):\\n                return 1\\n            else:\\n                i = index\\n                total = 0\\n                counter = 0\\n                while i<len(pressedKeys) and pressedKeys[i] == pressedKeys[index] and ((counter < 3 and pressedKeys[index] !=\\'7\\' and pressedKeys[index] !=\\'9\\') or (counter < 4 and (pressedKeys[index] ==\\'7\\' or pressedKeys[index] ==\\'9\\'))) :\\n                    total+=solve(i+1)\\n                    counter+=1\\n                    i+=1\\n                return total%((10**9)+7)\\n        return solve(0)\\n        # return 2\\n                \\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        @cache\\n        def solve(index):\\n            if index >= len(pressedKeys):\\n                return 1\\n            else:\\n                i = index\\n                total = 0\\n                counter = 0\\n                while i<len(pressedKeys) and pressedKeys[i] == pressedKeys[index] and ((counter < 3 and pressedKeys[index] !=\\'7\\' and pressedKeys[index] !=\\'9\\') or (counter < 4 and (pressedKeys[index] ==\\'7\\' or pressedKeys[index] ==\\'9\\'))) :\\n                    total+=solve(i+1)\\n                    counter+=1\\n                    i+=1\\n                return total%((10**9)+7)\\n        return solve(0)\\n        # return 2\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864462,
                "title": "python-easy-to-read-and-understand-dp",
                "content": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        n = len(pressedKeys)\\n        t = [0]*(n+1)\\n        t[0] = 1\\n        \\n        for i in range(1, n+1):\\n            t[i] = t[i-1]\\n            if i-2 >= 0 and pressedKeys[i-1] == pressedKeys[i-2]:\\n                t[i] += t[i-2]\\n            if i-3 >= 0 and pressedKeys[i-1] == pressedKeys[i-2] == pressedKeys[i-3]:\\n                t[i] += t[i-3]\\n            if pressedKeys[i-1] == \\'7\\' or pressedKeys[i-1] == \\'9\\':\\n                if i-4 >= 0 and pressedKeys[i-1] == pressedKeys[i-2] == pressedKeys[i-3] == pressedKeys[i-4]:\\n                    t[i] += t[i-4]\\n        \\n        return t[n]%(10**9 + 7)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        n = len(pressedKeys)\\n        t = [0]*(n+1)\\n        t[0] = 1\\n        \\n        for i in range(1, n+1):\\n            t[i] = t[i-1]\\n            if i-2 >= 0 and pressedKeys[i-1] == pressedKeys[i-2]:\\n                t[i] += t[i-2]\\n            if i-3 >= 0 and pressedKeys[i-1] == pressedKeys[i-2] == pressedKeys[i-3]:\\n                t[i] += t[i-3]\\n            if pressedKeys[i-1] == \\'7\\' or pressedKeys[i-1] == \\'9\\':\\n                if i-4 >= 0 and pressedKeys[i-1] == pressedKeys[i-2] == pressedKeys[i-3] == pressedKeys[i-4]:\\n                    t[i] += t[i-4]\\n        \\n        return t[n]%(10**9 + 7)",
                "codeTag": "Java"
            },
            {
                "id": 3863369,
                "title": "best-dp-question-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int mod = 1e9 + 7;\\n    int f(int ind,string &s,vector<int>&dp){\\n        if(ind == s.size())return 1;\\n\\n        if(dp[ind]!=-1)return dp[ind]%mod;\\n\\n\\n        int ans1 = 0;\\n        int ans2 = 0;\\n        int ans3 = 0;\\n        int ans4 = 0;\\n        ans1 = f(ind+1,s,dp);\\n        if(ind+1<s.size() && s[ind] == s[ind+1]){\\n            ans2+=f(ind+2,s,dp);\\n        }\\n        if(ind+2<s.size() && s[ind] == s[ind+1] && s[ind+1] == s[ind+2]){\\n            ans3+=f(ind+3,s,dp);\\n        }\\n        if(ind+3<s.size() && s[ind] == s[ind+1] && s[ind+1] == s[ind+2] && s[ind+2] == s[ind+3] \\n         && (s[ind] == \\'7\\' || s[ind] == \\'9\\'))ans4+=f(ind+4,s,dp);\\n\\n        return dp[ind] = (((ans1+ans2)%mod+ans3)%mod + ans4)%mod;\\n    }\\npublic:\\n    int countTexts(string pressedKeys) {\\n        int n = pressedKeys.size();\\n        vector<int> dp(n,-1);\\n        return f(0,pressedKeys,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int mod = 1e9 + 7;\\n    int f(int ind,string &s,vector<int>&dp){\\n        if(ind == s.size())return 1;\\n\\n        if(dp[ind]!=-1)return dp[ind]%mod;\\n\\n\\n        int ans1 = 0;\\n        int ans2 = 0;\\n        int ans3 = 0;\\n        int ans4 = 0;\\n        ans1 = f(ind+1,s,dp);\\n        if(ind+1<s.size() && s[ind] == s[ind+1]){\\n            ans2+=f(ind+2,s,dp);\\n        }\\n        if(ind+2<s.size() && s[ind] == s[ind+1] && s[ind+1] == s[ind+2]){\\n            ans3+=f(ind+3,s,dp);\\n        }\\n        if(ind+3<s.size() && s[ind] == s[ind+1] && s[ind+1] == s[ind+2] && s[ind+2] == s[ind+3] \\n         && (s[ind] == \\'7\\' || s[ind] == \\'9\\'))ans4+=f(ind+4,s,dp);\\n\\n        return dp[ind] = (((ans1+ans2)%mod+ans3)%mod + ans4)%mod;\\n    }\\npublic:\\n    int countTexts(string pressedKeys) {\\n        int n = pressedKeys.size();\\n        vector<int> dp(n,-1);\\n        return f(0,pressedKeys,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861489,
                "title": "tabulation-java-bottom-up-explanation-in-comments-line-wise",
                "content": "COMMENTED PRECISELY\\n\\n# Code TABULATION (BOTTOM UP )\\n```\\nclass Solution {\\n    int mod = (1000000007);\\n    public int countTexts(String pressedKeys) {\\n\\n        int [] key = new int[] { 0 , 0 , 3 , 3 , 3 , 3 , 3  , 4 , 3 , 4 }; //number of alphabets available at any pressed digit \\n\\n        int n = pressedKeys.length();\\n\\n        int [] dp = new int [n+1];  // n + 1 bcz dp[n] = 1 is set to be one to include \"\" case which returns 1 possible message is sent .. \\n        //forming condition for memoization\\n\\n        dp[n] = 1; // note n index is the not the part of string ..\\n        //string has length n , means n-1 is the last index of string \\n\\n\\n        for(int ind = n - 1 ; ind >= 0 ; ind--){\\n\\n            int count = 0 ;\\n            int num = pressedKeys.charAt(ind) - \\'0\\'; // retreiving the number pressed from the inout string \\n\\n            int rep =  key[num]; // getting the number of alphabets \\n            //that are stored along the digit at the phone dial pad \\n\\n            for(int i = 0 ; i < rep && ind + i < pressedKeys.length() && pressedKeys.charAt(ind) == pressedKeys.charAt(ind + i ) ; i++){\\n             // the for loop condition \\n             // preesedKeys.charAt(ind) == pressedKeys.charAt(ind + i) and i = 0 for the start ..so compares itself to itself only  in 1st iteration \\n\\n             \\n\\n                count += dp[ind + i + 1];\\n                count %= mod;\\n\\n                // for eg  n = 7  and \"3334444\"\\n                //dp[] of size 7+1 is initialized\\n\\n                // dp[7] = 1 \\n                // dp[6] = dp[7] = 1\\n\\n                // dp[5] = dp[6] + dp[7] = 1 + 1 = 2\\n                //dp[4] = dp[7] + dp[6] + dp[5] = 1 + 1 + 2 = 4 \\n            }\\n\\n            dp[ind] = count;\\n        }\\n         return dp[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int mod = (1000000007);\\n    public int countTexts(String pressedKeys) {\\n\\n        int [] key = new int[] { 0 , 0 , 3 , 3 , 3 , 3 , 3  , 4 , 3 , 4 }; //number of alphabets available at any pressed digit \\n\\n        int n = pressedKeys.length();\\n\\n        int [] dp = new int [n+1];  // n + 1 bcz dp[n] = 1 is set to be one to include \"\" case which returns 1 possible message is sent .. \\n        //forming condition for memoization\\n\\n        dp[n] = 1; // note n index is the not the part of string ..\\n        //string has length n , means n-1 is the last index of string \\n\\n\\n        for(int ind = n - 1 ; ind >= 0 ; ind--){\\n\\n            int count = 0 ;\\n            int num = pressedKeys.charAt(ind) - \\'0\\'; // retreiving the number pressed from the inout string \\n\\n            int rep =  key[num]; // getting the number of alphabets \\n            //that are stored along the digit at the phone dial pad \\n\\n            for(int i = 0 ; i < rep && ind + i < pressedKeys.length() && pressedKeys.charAt(ind) == pressedKeys.charAt(ind + i ) ; i++){\\n             // the for loop condition \\n             // preesedKeys.charAt(ind) == pressedKeys.charAt(ind + i) and i = 0 for the start ..so compares itself to itself only  in 1st iteration \\n\\n             \\n\\n                count += dp[ind + i + 1];\\n                count %= mod;\\n\\n                // for eg  n = 7  and \"3334444\"\\n                //dp[] of size 7+1 is initialized\\n\\n                // dp[7] = 1 \\n                // dp[6] = dp[7] = 1\\n\\n                // dp[5] = dp[6] + dp[7] = 1 + 1 = 2\\n                //dp[4] = dp[7] + dp[6] + dp[5] = 1 + 1 + 2 = 4 \\n            }\\n\\n            dp[ind] = count;\\n        }\\n         return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3857665,
                "title": "used-brute-force-and-memoized-it-but-gives-mle-can-help-me-to-optimize-it-please",
                "content": "```\\nclass Solution:\\n    def isValidKey(self, key, mp):\\n        length = len(key)\\n        stk = []\\n        stk.append(key[0])\\n        for i in key[1:]:\\n            if(stk[-1] == i):\\n                continue\\n            else:\\n                stk.append(i)\\n        if(len(stk) > 1):\\n            return False\\n        key = stk[0]\\n        if(length > mp[key]):\\n            return False\\n        return True\\n    \\n    def helper(self, pressedKeys, mp, dp):\\n        if( not pressedKeys):\\n            return 1\\n        if pressedKeys in dp:\\n            return dp[pressedKeys]\\n        res = 0\\n        for i in range(0, len(pressedKeys)):\\n            ch = pressedKeys[:i+1]\\n            if(self.isValidKey(ch, mp)):\\n                res += self.helper(pressedKeys[i+1:], mp, dp) % 1000000007\\n            else:\\n                break\\n        dp[pressedKeys] = res % 1000000007\\n        return dp[pressedKeys]\\n    \\n    def countTexts(self, pressedKeys: str) -> int:\\n        mp = {\\'2\\' : 3,\\n             \\'3\\' : 3, \\n             \\'4\\' : 3, \\n             \\'5\\' : 3, \\n             \\'6\\' : 3, \\n             \\'7\\' : 4,\\n             \\'8\\' : 3,\\n             \\'9\\' : 4}\\n        dp = {}\\n        return self.helper(pressedKeys, mp, dp) % 1000000007\\n                \\n        \\n        \\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def isValidKey(self, key, mp):\\n        length = len(key)\\n        stk = []\\n        stk.append(key[0])\\n        for i in key[1:]:\\n            if(stk[-1] == i):\\n                continue\\n            else:\\n                stk.append(i)\\n        if(len(stk) > 1):\\n            return False\\n        key = stk[0]\\n        if(length > mp[key]):\\n            return False\\n        return True\\n    \\n    def helper(self, pressedKeys, mp, dp):\\n        if( not pressedKeys):\\n            return 1\\n        if pressedKeys in dp:\\n            return dp[pressedKeys]\\n        res = 0\\n        for i in range(0, len(pressedKeys)):\\n            ch = pressedKeys[:i+1]\\n            if(self.isValidKey(ch, mp)):\\n                res += self.helper(pressedKeys[i+1:], mp, dp) % 1000000007\\n            else:\\n                break\\n        dp[pressedKeys] = res % 1000000007\\n        return dp[pressedKeys]\\n    \\n    def countTexts(self, pressedKeys: str) -> int:\\n        mp = {\\'2\\' : 3,\\n             \\'3\\' : 3, \\n             \\'4\\' : 3, \\n             \\'5\\' : 3, \\n             \\'6\\' : 3, \\n             \\'7\\' : 4,\\n             \\'8\\' : 3,\\n             \\'9\\' : 4}",
                "codeTag": "Java"
            },
            {
                "id": 3857007,
                "title": "dp-faster-than-99-22-optimized-solution",
                "content": "![Screenshot 2023-08-02 100332.png](https://assets.leetcode.com/users/images/2b3c8307-b6f2-47f7-9001-08cf5692b6c7_1691049413.8140266.png)\\n\\n# Intuition\\nIf continuous occurence for 2,3,4,5,6,8 is till 3 we can use $$dp[i] = dp[i-1]<<1 $$ and same for 7,9 until continuous occurence of 4. Using a variable while iterating to keep count of same numbers occuring together.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countTexts(self, k: str) -> int:\\n        n = len(k)\\n        dp = [0 for _ in range(n)]\\n        dp[0] = 1\\n        mod = 10 ** 9 + 7\\n        count = 1\\n        for i in range(1, n):\\n            if k[i-1]!=k[i]:\\n                dp[i] = dp[i-1]\\n                count = 1\\n            else:\\n                count+=1\\n                if count <=3 and k[i] in \"234568\" or  count <= 4 and k[i] in \"79\":\\n                    dp[i] = (dp[i-1]<<1)%mod\\n                else:\\n                    dp[i] = (dp[i-1] + dp[i-2] + dp[i-3])%mod\\n                    if k[i] in \"79\":\\n                        dp[i] = (dp[i] + dp[i-4])%mod\\n        return dp[-1]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countTexts(self, k: str) -> int:\\n        n = len(k)\\n        dp = [0 for _ in range(n)]\\n        dp[0] = 1\\n        mod = 10 ** 9 + 7\\n        count = 1\\n        for i in range(1, n):\\n            if k[i-1]!=k[i]:\\n                dp[i] = dp[i-1]\\n                count = 1\\n            else:\\n                count+=1\\n                if count <=3 and k[i] in \"234568\" or  count <= 4 and k[i] in \"79\":\\n                    dp[i] = (dp[i-1]<<1)%mod\\n                else:\\n                    dp[i] = (dp[i-1] + dp[i-2] + dp[i-3])%mod\\n                    if k[i] in \"79\":\\n                        dp[i] = (dp[i] + dp[i-4])%mod\\n        return dp[-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3856389,
                "title": "c-dp",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int countTexts(string s) {\\n        int n = s.size();\\n        vector<long long> dp(n+1);\\n        dp[0] = 1;\\n        for(int i=1;i<=n;i++)\\n        {\\n            dp[i] = dp[i-1];\\n            if(i-2>=0 && s[i-1]==s[i-2])\\n            dp[i]+=dp[i-2];\\n            if(i-3>=0 && s[i-1]==s[i-2] && s[i-1]==s[i-3])\\n            dp[i]+=dp[i-3];\\n            if((s[i-1]==\\'7\\' || s[i-1]==\\'9\\') && i-4>=0 && s[i-1]==s[i-2] && s[i-1]==s[i-3] && s[i-1]==s[i-4])\\n            dp[i]+=dp[i-4];\\n            dp[i]%=mod;\\n        }\\n        return dp[n]%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int countTexts(string s) {\\n        int n = s.size();\\n        vector<long long> dp(n+1);\\n        dp[0] = 1;\\n        for(int i=1;i<=n;i++)\\n        {\\n            dp[i] = dp[i-1];\\n            if(i-2>=0 && s[i-1]==s[i-2])\\n            dp[i]+=dp[i-2];\\n            if(i-3>=0 && s[i-1]==s[i-2] && s[i-1]==s[i-3])\\n            dp[i]+=dp[i-3];\\n            if((s[i-1]==\\'7\\' || s[i-1]==\\'9\\') && i-4>=0 && s[i-1]==s[i-2] && s[i-1]==s[i-3] && s[i-1]==s[i-4])\\n            dp[i]+=dp[i-4];\\n            dp[i]%=mod;\\n        }\\n        return dp[n]%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3829619,
                "title": "o-n-1d-dp-top-down-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    vector<long long> dp;\\n    long long solve(string& pressedKeys,int i){\\n        if(i==pressedKeys.size()) return 1;\\n        if(dp[i]!=-1) return dp[i];\\n        long long totalWays=0;\\n        int j=i;\\n        while(j<pressedKeys.size() && pressedKeys[i]==pressedKeys[j]){\\n            if(j-i==3 && (pressedKeys[i]!=\\'7\\' && pressedKeys[i]!=\\'9\\')){\\n                break;\\n            }else if(j-i==4) break;\\n            totalWays+=solve(pressedKeys,j+1);\\n            totalWays%=mod;\\n            j++;\\n        }\\n        return dp[i]=totalWays%mod;\\n    }\\n    int countTexts(string pressedKeys) {\\n        dp.resize(pressedKeys.size(),-1);\\n        return solve(pressedKeys,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    vector<long long> dp;\\n    long long solve(string& pressedKeys,int i){\\n        if(i==pressedKeys.size()) return 1;\\n        if(dp[i]!=-1) return dp[i];\\n        long long totalWays=0;\\n        int j=i;\\n        while(j<pressedKeys.size() && pressedKeys[i]==pressedKeys[j]){\\n            if(j-i==3 && (pressedKeys[i]!=\\'7\\' && pressedKeys[i]!=\\'9\\')){\\n                break;\\n            }else if(j-i==4) break;\\n            totalWays+=solve(pressedKeys,j+1);\\n            totalWays%=mod;\\n            j++;\\n        }\\n        return dp[i]=totalWays%mod;\\n    }\\n    int countTexts(string pressedKeys) {\\n        dp.resize(pressedKeys.size(),-1);\\n        return solve(pressedKeys,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821220,
                "title": "python-single-pass-o-n-solution-with-o-1-space",
                "content": "```\\nclass Solution:\\n    # Time: O(N), Space: O(1)\\n    def countTexts(self, pressedKeys: str) -> int:\\n        \\n        # we can identify the groups of similar digits and then for each group we find the number of ways and finally multiply\\n        # the ways of each group together to find the answer\\n        # Example: 22233\\n        # in this example there are two groups 222 and 33\\n        # 222 can be split in 4 ways => 2 2 2, 22 2, 2 22, 222\\n        # 33 can be split in 2 ways => 3 3, 33 \\n        # so total ways are 4*2 = 8\\n        \\n        # Example 2: 2222\\n        # there is only one group\\n        # ways = 2 2 2 2, 22 2 2, 222 2, 2 2 22, 2 22 2, 2 222, 22 22\\n        # not that 2222 is not valid in this case as 2 can only be pressed max 3 times so we cannot take more than 3 2\\'s\\n        # as one unit\\n        \\n        # now we try to find the pattern here\\n        # for single 2 there is 1 way\\n        # for two 2\\'s there are 1*2=2 ways => 2 2, 22\\n        # for three 2\\'s there are 2*2=4 ways\\n        # for four ways there are 4*2-1=7 ways\\n        # for each next length the number of ways are increasing by a factor of 2\\n        # but for lengths larger than 3 it is not increasing by a factor of 2 as at max we can take 3 digits as one unit\\n        # so for each length larger than 3 we subtract the ways at cur_length - 3 from current length ways\\n        \\n        # Look at the below example \\n        # the combinations for the lengths from 1 to 14\\n        # length = 1,2,3,4,5 ,6 ,7 ,8 ,9  ,10 ,11 ,12 ,13  ,14\\n        # ways   = 1,2,4,7,13,24,44,81,149,274,504,927,1705,3136\\n        # now we can find some pattern in this series\\n        # we keep the first 3 elements in an array as we know the combinations for 3 digits. so for 3 \\n        # letter digits we store 1,2,4,7 and for 4 letter digits we store 1,2,4,8,15 \\n        # now to calculate the combinations for all lengths above 4 we use the formula ways[i-1]*2-ways[i-3]\\n        # as for 3 letter digits we cannot use more than 3 digits as one unit so we need to subtract the\\n        # combinations we had at length i-3\\n        # we do the same for four length digits but for four length digits we subtract i-4\\n        \\n        # to save the space we do not need to store every length in an array of length N, as each length is \\n        # depenedent on last 4 lengths only so we can use an array of length 4 to optimize space to O(1)\\n        \\n        \\n        three_letter_digits = set([\\'2\\',\\'3\\',\\'4\\',\\'5\\',\\'6\\',\\'8\\'])\\n        four_letter_digits = set([\\'7\\',\\'9\\'])\\n        \\n        three_letters_dp, four_letters_dp = [1,2,4,7], [1,2,4,8,15]\\n        cur_group_length = 1\\n        total_combinations = prev_group_combinations = 1\\n        \\n        for i in range(1, len(pressedKeys)):\\n            char = pressedKeys[i]\\n            if char != pressedKeys[i-1]:\\n                # new group started so we reset all variables\\n                total_combinations *= prev_group_combinations\\n                cur_group_length = 1\\n                prev_group_combinations = 1\\n                three_letters_dp, four_letters_dp = [1,2,4,7], [1,2,4,8,15]\\n            else:\\n                cur_group_length += 1\\n                index = (cur_group_length-1)%4 if char in three_letter_digits else (cur_group_length-1)%5\\n                if char in three_letter_digits and cur_group_length > 4:\\n                    last_length_combs = max(three_letters_dp)\\n                    three_letters_dp[index] = last_length_combs*2 - three_letters_dp[index]\\n                elif char in four_letter_digits and cur_group_length > 5:\\n                    last_length_combs = max(four_letters_dp)\\n                    four_letters_dp[index] = last_length_combs*2 - four_letters_dp[index]\\n                \\n                prev_group_combinations = three_letters_dp[index] if char in three_letter_digits else four_letters_dp[index]\\n        \\n        total_combinations *= prev_group_combinations\\n        \\n        return total_combinations % (pow(10,9) + 7)\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # Time: O(N), Space: O(1)\\n    def countTexts(self, pressedKeys: str) -> int:\\n        \\n        # we can identify the groups of similar digits and then for each group we find the number of ways and finally multiply\\n        # the ways of each group together to find the answer\\n        # Example: 22233\\n        # in this example there are two groups 222 and 33\\n        # 222 can be split in 4 ways => 2 2 2, 22 2, 2 22, 222\\n        # 33 can be split in 2 ways => 3 3, 33 \\n        # so total ways are 4*2 = 8\\n        \\n        # Example 2: 2222\\n        # there is only one group\\n        # ways = 2 2 2 2, 22 2 2, 222 2, 2 2 22, 2 22 2, 2 222, 22 22\\n        # not that 2222 is not valid in this case as 2 can only be pressed max 3 times so we cannot take more than 3 2\\'s\\n        # as one unit\\n        \\n        # now we try to find the pattern here\\n        # for single 2 there is 1 way\\n        # for two 2\\'s there are 1*2=2 ways => 2 2, 22\\n        # for three 2\\'s there are 2*2=4 ways\\n        # for four ways there are 4*2-1=7 ways\\n        # for each next length the number of ways are increasing by a factor of 2\\n        # but for lengths larger than 3 it is not increasing by a factor of 2 as at max we can take 3 digits as one unit\\n        # so for each length larger than 3 we subtract the ways at cur_length - 3 from current length ways\\n        \\n        # Look at the below example \\n        # the combinations for the lengths from 1 to 14\\n        # length = 1,2,3,4,5 ,6 ,7 ,8 ,9  ,10 ,11 ,12 ,13  ,14\\n        # ways   = 1,2,4,7,13,24,44,81,149,274,504,927,1705,3136\\n        # now we can find some pattern in this series\\n        # we keep the first 3 elements in an array as we know the combinations for 3 digits. so for 3 \\n        # letter digits we store 1,2,4,7 and for 4 letter digits we store 1,2,4,8,15 \\n        # now to calculate the combinations for all lengths above 4 we use the formula ways[i-1]*2-ways[i-3]\\n        # as for 3 letter digits we cannot use more than 3 digits as one unit so we need to subtract the\\n        # combinations we had at length i-3\\n        # we do the same for four length digits but for four length digits we subtract i-4\\n        \\n        # to save the space we do not need to store every length in an array of length N, as each length is \\n        # depenedent on last 4 lengths only so we can use an array of length 4 to optimize space to O(1)\\n        \\n        \\n        three_letter_digits = set([\\'2\\',\\'3\\',\\'4\\',\\'5\\',\\'6\\',\\'8\\'])\\n        four_letter_digits = set([\\'7\\',\\'9\\'])\\n        \\n        three_letters_dp, four_letters_dp = [1,2,4,7], [1,2,4,8,15]\\n        cur_group_length = 1\\n        total_combinations = prev_group_combinations = 1\\n        \\n        for i in range(1, len(pressedKeys)):\\n            char = pressedKeys[i]\\n            if char != pressedKeys[i-1]:\\n                # new group started so we reset all variables\\n                total_combinations *= prev_group_combinations\\n                cur_group_length = 1\\n                prev_group_combinations = 1\\n                three_letters_dp, four_letters_dp = [1,2,4,7], [1,2,4,8,15]\\n            else:\\n                cur_group_length += 1\\n                index = (cur_group_length-1)%4 if char in three_letter_digits else (cur_group_length-1)%5\\n                if char in three_letter_digits and cur_group_length > 4:\\n                    last_length_combs = max(three_letters_dp)\\n                    three_letters_dp[index] = last_length_combs*2 - three_letters_dp[index]\\n                elif char in four_letter_digits and cur_group_length > 5:\\n                    last_length_combs = max(four_letters_dp)\\n                    four_letters_dp[index] = last_length_combs*2 - four_letters_dp[index]\\n                \\n                prev_group_combinations = three_letters_dp[index] if char in three_letter_digits else four_letters_dp[index]\\n        \\n        total_combinations *= prev_group_combinations\\n        \\n        return total_combinations % (pow(10,9) + 7)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807863,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> dp3;\\n    vector<int> dp4;\\n    long long mod;\\n    vector<int> available;\\n    long long getCount(int available, int n, vector<int> &dp) {\\n        if (dp[n]) return dp[n];\\n        long long answer = 0; \\n        for (int i = 1; i <= available; ++i) {\\n            if (n - i >= 0)answer += getCount(available, n - i, dp);\\n        }\\n        answer %= mod;\\n        dp[n] = answer;\\n        return answer;\\n    }\\n    int countTexts(string pressedKeys) {\\n        \\n        long long answer = 1;\\n        int size = std::max(int(pressedKeys.size() + 1),10);\\n        dp3.resize(size, 0);\\n        dp4.resize(size, 0);\\n        mod = 1E9 + 7;\\n        available = {0, 0, 3, 3, 3, 3, 3, 4, 3, 4};\\n\\n        dp3[0] = dp4[0] = 1;\\n        dp3[1] = dp4[1] = 1;\\n        dp3[2] = dp4[2] = 2;\\n        dp3[3] = dp4[3] = 4;\\n        dp3[4] = 7;\\n        dp4[4] = 8;\\n\\n        char ch = pressedKeys[0];\\n        int count = 0;\\n        for (char x : pressedKeys) {\\n            if (x == ch) ++count;\\n            else {\\n                int number = ch - \\'0\\';\\n                if (number == 7 || number == 9) answer *= getCount(available[number], count, dp4);\\n                else answer *= getCount(available[number], count, dp3);\\n                answer %= mod;\\n                count = 1;\\n                ch = x;\\n            }\\n        }\\n        int number = ch - \\'0\\';\\n        if (number == 7 || number == 9) answer *= getCount(available[number], count, dp4);\\n        else answer *= getCount(available[number], count, dp3);\\n        answer %= mod;\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> dp3;\\n    vector<int> dp4;\\n    long long mod;\\n    vector<int> available;\\n    long long getCount(int available, int n, vector<int> &dp) {\\n        if (dp[n]) return dp[n];\\n        long long answer = 0; \\n        for (int i = 1; i <= available; ++i) {\\n            if (n - i >= 0)answer += getCount(available, n - i, dp);\\n        }\\n        answer %= mod;\\n        dp[n] = answer;\\n        return answer;\\n    }\\n    int countTexts(string pressedKeys) {\\n        \\n        long long answer = 1;\\n        int size = std::max(int(pressedKeys.size() + 1),10);\\n        dp3.resize(size, 0);\\n        dp4.resize(size, 0);\\n        mod = 1E9 + 7;\\n        available = {0, 0, 3, 3, 3, 3, 3, 4, 3, 4};\\n\\n        dp3[0] = dp4[0] = 1;\\n        dp3[1] = dp4[1] = 1;\\n        dp3[2] = dp4[2] = 2;\\n        dp3[3] = dp4[3] = 4;\\n        dp3[4] = 7;\\n        dp4[4] = 8;\\n\\n        char ch = pressedKeys[0];\\n        int count = 0;\\n        for (char x : pressedKeys) {\\n            if (x == ch) ++count;\\n            else {\\n                int number = ch - \\'0\\';\\n                if (number == 7 || number == 9) answer *= getCount(available[number], count, dp4);\\n                else answer *= getCount(available[number], count, dp3);\\n                answer %= mod;\\n                count = 1;\\n                ch = x;\\n            }\\n        }\\n        int number = ch - \\'0\\';\\n        if (number == 7 || number == 9) answer *= getCount(available[number], count, dp4);\\n        else answer *= getCount(available[number], count, dp3);\\n        answer %= mod;\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793062,
                "title": "recursive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int func(string &s, int i, int n, vector<int> &dp){\\n        if(i>=n) return 1;\\n        if(dp[i]!=-1) return dp[i];\\n        int ans=0;\\n        if(i+1<n && s[i]==s[i+1]){\\n            ans+=func(s,i+2,n,dp);\\n            ans=ans%mod;\\n            if(i+2<n && s[i]==s[i+2]){\\n                ans+=func(s,i+3,n,dp);\\n                ans=ans%mod;\\n                if(i+3<n && s[i]==s[i+3] && (s[i]==\\'9\\' || s[i]==\\'7\\')){\\n                    ans+=func(s,i+4,n,dp);\\n                    ans=ans%mod;\\n                }\\n            }\\n        }\\n        ans+=func(s,i+1,n,dp);\\n        ans=ans%mod;\\n        return dp[i]=ans;\\n    }\\n    int countTexts(string s) {\\n        int n=s.size();\\n        vector<int> dp(n+1,-1);\\n        return func(s,0,n,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int func(string &s, int i, int n, vector<int> &dp){\\n        if(i>=n) return 1;\\n        if(dp[i]!=-1) return dp[i];\\n        int ans=0;\\n        if(i+1<n && s[i]==s[i+1]){\\n            ans+=func(s,i+2,n,dp);\\n            ans=ans%mod;\\n            if(i+2<n && s[i]==s[i+2]){\\n                ans+=func(s,i+3,n,dp);\\n                ans=ans%mod;\\n                if(i+3<n && s[i]==s[i+3] && (s[i]==\\'9\\' || s[i]==\\'7\\')){\\n                    ans+=func(s,i+4,n,dp);\\n                    ans=ans%mod;\\n                }\\n            }\\n        }\\n        ans+=func(s,i+1,n,dp);\\n        ans=ans%mod;\\n        return dp[i]=ans;\\n    }\\n    int countTexts(string s) {\\n        int n=s.size();\\n        vector<int> dp(n+1,-1);\\n        return func(s,0,n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3780208,
                "title": "c-o-n-faster-than-100-solutions-simple-dp-single-pass-solution-7ms",
                "content": "```\\nint val[10] = {0, 0, 3, 3, 3, 3, 3, 4, 3, 4};\\nvector<long long> th((int)1e5+1), f((int)1e5+2);\\nint mod = 1e9+7;\\nconst int fast = [](){\\n    th[0] = 1;\\n    th[1] = 1;\\n    th[2] = 2;\\n    \\n    f[0] = 1;\\n    f[1] = 1;\\n    f[2] = 2;\\n    f[3] = 4;\\n    \\n    for(int i=3;i<th.size();i++)\\n    {\\n        th[i] = (th[i-1]+th[i-2]+th[i-3])%mod;\\n        f[i+1] = (f[i] + f[i-1]+f[i-2]+f[i-3])%mod;\\n    }\\n    \\n    ios_base::sync_with_stdio(false);\\n    cin.tie(NULL);\\n    \\n    return 0;\\n}();\\nclass Solution {\\npublic:\\n    int countTexts(string pressedKeys) {\\n        int ans = 1;\\n        \\n        for(int i=0;i<pressedKeys.length();i++)\\n        {\\n            int j = i+1;\\n            for(;j<pressedKeys.size();j++)\\n            {\\n                if(pressedKeys[j]!=pressedKeys[i])break;\\n            }\\n            \\n            ans = (1LL*ans*((val[pressedKeys[i]-\\'0\\']==3)?th[j-i]:f[j-i]))%mod;\\n            i = j-1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\tWe first stored the number of alphabets on that are possible for each each number, e.g. 3 characters (a,b,c) are possible using 2 and 4 characters (p,q,r,s) are possible using number 7.\\n\\t\\n\\tThen I make the arrays th (for numbers which can produce 3 characters) and f (for 4 characters).\\n\\nThese arrays store the number of ways to make a string if there are contiguous numbers which are same.\\n\\nFor e.g. if 2 comes 5 times conitnuosly, and we know two can make 3 characters:\\n\\twe simply use th[5].\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint val[10] = {0, 0, 3, 3, 3, 3, 3, 4, 3, 4};\\nvector<long long> th((int)1e5+1), f((int)1e5+2);\\nint mod = 1e9+7;\\nconst int fast = [](){\\n    th[0] = 1;\\n    th[1] = 1;\\n    th[2] = 2;\\n    \\n    f[0] = 1;\\n    f[1] = 1;\\n    f[2] = 2;\\n    f[3] = 4;\\n    \\n    for(int i=3;i<th.size();i++)\\n    {\\n        th[i] = (th[i-1]+th[i-2]+th[i-3])%mod;\\n        f[i+1] = (f[i] + f[i-1]+f[i-2]+f[i-3])%mod;\\n    }\\n    \\n    ios_base::sync_with_stdio(false);\\n    cin.tie(NULL);\\n    \\n    return 0;\\n}();\\nclass Solution {\\npublic:\\n    int countTexts(string pressedKeys) {\\n        int ans = 1;\\n        \\n        for(int i=0;i<pressedKeys.length();i++)\\n        {\\n            int j = i+1;\\n            for(;j<pressedKeys.size();j++)\\n            {\\n                if(pressedKeys[j]!=pressedKeys[i])break;\\n            }\\n            \\n            ans = (1LL*ans*((val[pressedKeys[i]-\\'0\\']==3)?th[j-i]:f[j-i]))%mod;\\n            i = j-1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3770330,
                "title": "cpp-2-dp-approaches-recursion-with-memoization-memoization-o-4-n-solution",
                "content": "* ### Recursion With Memoization Approach\\n```\\nclass Solution {\\npublic:\\n    int mod = (int)(1e9+7);\\n    int solve(int i,string &s, vector<int> &dp){\\n        int n = s.size();\\n        if(i>=n) return 1;\\n        if(dp[i]!=-1) return dp[i];\\n        int tot = (s[i]==\\'7\\'||s[i]==\\'9\\')?4:3;\\n        int take=0;\\n        for(int k=0;k<tot;k++){\\n            if(i+k<n and s[i+k]==s[i]) take = (take%mod + solve(i+k+1,s,dp)%mod)%mod;\\n            else break;\\n        }\\n        \\n        return dp[i] = take%mod;\\n    }\\n    int countTexts(string pressedKeys) {\\n        vector<int> dp(pressedKeys.size()+1,-1);\\n        return solve(0,pressedKeys,dp);\\n    }\\n};\\n```\\n* ### Tabulation Approach\\n```\\nclass Solution {\\npublic:\\n    int mod = (int)(1e9+7);\\n    int countTexts(string s) {\\n        int n = s.size();\\n        vector<int> dp(s.size()+1,0);\\n        dp[n]=1;\\n        \\n        for(int i=n-1;i>=0;i--){\\n            int tot = (s[i]==\\'7\\'||s[i]==\\'9\\')?4:3;\\n            int take=0;\\n            for(int k=0;k<tot;k++){\\n                if(i+k<n and s[i+k]==s[i]) take = (take%mod + dp[i+k+1]%mod)%mod;\\n                else break;\\n            }\\n\\n            dp[i] = take%mod;\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = (int)(1e9+7);\\n    int solve(int i,string &s, vector<int> &dp){\\n        int n = s.size();\\n        if(i>=n) return 1;\\n        if(dp[i]!=-1) return dp[i];\\n        int tot = (s[i]==\\'7\\'||s[i]==\\'9\\')?4:3;\\n        int take=0;\\n        for(int k=0;k<tot;k++){\\n            if(i+k<n and s[i+k]==s[i]) take = (take%mod + solve(i+k+1,s,dp)%mod)%mod;\\n            else break;\\n        }\\n        \\n        return dp[i] = take%mod;\\n    }\\n    int countTexts(string pressedKeys) {\\n        vector<int> dp(pressedKeys.size()+1,-1);\\n        return solve(0,pressedKeys,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int mod = (int)(1e9+7);\\n    int countTexts(string s) {\\n        int n = s.size();\\n        vector<int> dp(s.size()+1,0);\\n        dp[n]=1;\\n        \\n        for(int i=n-1;i>=0;i--){\\n            int tot = (s[i]==\\'7\\'||s[i]==\\'9\\')?4:3;\\n            int take=0;\\n            for(int k=0;k<tot;k++){\\n                if(i+k<n and s[i+k]==s[i]) take = (take%mod + dp[i+k+1]%mod)%mod;\\n                else break;\\n            }\\n\\n            dp[i] = take%mod;\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3756626,
                "title": "java-dp-31ms-beats-91",
                "content": "# Approach\\n1. Use an  int[] values to store the values/count of texts that can be formed backwords. values[n -1] = 1;\\n2. Look at each number: \\n    - key 4 can form 3 sequences: pressed once, twice, three times\\n    - key 9 can form 4 sequences: pressed once, twice, three, four times.\\n3. Create a simple mapping for max number of presses for each number: 3 -> 2, 9 > 3 means that digit 3 can take up at most 2 other chars at its right (current, next and next so an offset of 2) \\n4. Let\\'s look at the exmple 333 : values[0,0,1] (values[n-1] = 1 as last digit can form just 1 single number:itself)\\n    - i = 1: 33: \\n    - we can have one sequence of 1 press (d), thus the word is dd\\n    - we can have one sequence of 2 presses: (e) thus the word is e\\n    so values is [0,2,1]\\n    - i = 0: 333\\n    - if we press 3 once, then we form the text/word count given by values[1] = 2\\n    - if we press two times we form the text/word count given by values[2] = 1  \\n    - if we press it 3 times, we form the text f, thus just 1 word\\n    - total = 2+1+1 = 4;            \\n5. Starting from index i = n-2 to 0\\n    - loop with j from current index and stop when j reaches the max number of allowed keys for that number OR > n\\n    - sum up the indices/values represented by values[i+j+1] for each loop of j,\\n    - set values[i] = that sum.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private static final int[] maxKeys = {0,0,2,2,2,2,2,3,2,3};\\n    public int countTexts(String pressedKeys) {\\n        char[] chars = pressedKeys.toCharArray();\\n        int[] values = new int[chars.length];\\n        values[chars.length - 1] = 1;\\n        int sum;\\n        int digit, j;\\n        for (int i = chars.length - 2; i >= 0; i--) {\\n            sum = 0;\\n            j = 0;\\n            digit = chars[i] - \\'0\\';\\n            for (; j <= maxKeys[digit] && i + j < chars.length && chars[i] == chars[i + j]; j++) {\\n                sum = (sum + (i + j + 1 > chars.length - 1 ? 1 : values[i + j + 1])) % 1_000_000_007;\\n            }\\n            values[i] = sum;\\n        }\\n        return values[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private static final int[] maxKeys = {0,0,2,2,2,2,2,3,2,3};\\n    public int countTexts(String pressedKeys) {\\n        char[] chars = pressedKeys.toCharArray();\\n        int[] values = new int[chars.length];\\n        values[chars.length - 1] = 1;\\n        int sum;\\n        int digit, j;\\n        for (int i = chars.length - 2; i >= 0; i--) {\\n            sum = 0;\\n            j = 0;\\n            digit = chars[i] - \\'0\\';\\n            for (; j <= maxKeys[digit] && i + j < chars.length && chars[i] == chars[i + j]; j++) {\\n                sum = (sum + (i + j + 1 > chars.length - 1 ? 1 : values[i + j + 1])) % 1_000_000_007;\\n            }\\n            values[i] = sum;\\n        }\\n        return values[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709203,
                "title": "simple-dp-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int dp[100000];\\n    int solve(int index,string &str){\\n        if(index>=str.size())\\n            return 1;\\n        \\n        if(dp[index]!=-1)\\n            return dp[index];\\n        int ans=0;\\n        if(str[index]==\\'9\\'||str[index]==\\'7\\'){\\n            for(int i=index;i<str.size()&&i<index+4;i++){\\n                if(str[i]!=str[index])\\n                    break;\\n                else\\n                    ans=(ans%mod+solve(i+1,str)%mod)%mod;\\n            }\\n        }\\n        \\n        else{\\n            \\n             for(int i=index;i<str.size()&&i<index+3;i++){\\n                if(str[i]!=str[index])\\n                    break;\\n                else\\n                    ans=(ans%mod+solve(i+1,str)%mod)%mod;\\n            }\\n        }\\n        \\n        \\n        return dp[index]=ans;\\n            \\n        }\\n    \\n    int countTexts(string pressedKeys) {\\n        memset(dp,-1,sizeof(dp));\\n        \\n        return solve(0,pressedKeys);\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int dp[100000];\\n    int solve(int index,string &str){\\n        if(index>=str.size())\\n            return 1;\\n        \\n        if(dp[index]!=-1)\\n            return dp[index];\\n        int ans=0;\\n        if(str[index]==\\'9\\'||str[index]==\\'7\\'){\\n            for(int i=index;i<str.size()&&i<index+4;i++){\\n                if(str[i]!=str[index])\\n                    break;\\n                else\\n                    ans=(ans%mod+solve(i+1,str)%mod)%mod;\\n            }\\n        }\\n        \\n        else{\\n            \\n             for(int i=index;i<str.size()&&i<index+3;i++){\\n                if(str[i]!=str[index])\\n                    break;\\n                else\\n                    ans=(ans%mod+solve(i+1,str)%mod)%mod;\\n            }\\n        }\\n        \\n        \\n        return dp[index]=ans;\\n            \\n        }\\n    \\n    int countTexts(string pressedKeys) {\\n        memset(dp,-1,sizeof(dp));\\n        \\n        return solve(0,pressedKeys);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696036,
                "title": "easy-accepted-c-recursive-and-memoized-solution-similar-to-phone-keypad-problem",
                "content": "# Intuition\\nRecursion and Memoization\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    \\n    int solve(string &s,int idx,vector<string> &phone,vector<int> &dp){\\n        if(idx==s.length()){\\n            return 1;\\n        }\\n        if(dp[idx]!=-1){\\n            return dp[idx];\\n        }\\n        string mapped=phone[s[idx]-\\'0\\'];\\n        int len=mapped.length();\\n\\n        int instance=0;\\n\\n        int index=idx;\\n\\n        while(index<s.length() && s[index]==s[idx]){\\n            instance++;\\n            if(instance==len){\\n                break;\\n            }\\n            index++;\\n        }\\n\\n        int mini=min(instance,len);\\n\\n        int ans=0;\\n\\n        for(int i=1;i<=mini && i+idx<=s.length();i++){\\n            ans+=solve(s,idx+i,phone,dp)%mod;\\n            ans=ans%mod;\\n        }\\n\\n        return dp[idx]=ans%mod;\\n\\n    }\\n\\n    int countTexts(string pressedKeys) {\\n        vector<string> phone={\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        int n=pressedKeys.length();\\n        vector<int> dp(n+1,-1);\\n        return solve(pressedKeys,0,phone,dp)%mod;\\n    }\\n};\\n\\n// \"2 2 2 3 3 \" \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    \\n    int solve(string &s,int idx,vector<string> &phone,vector<int> &dp){\\n        if(idx==s.length()){\\n            return 1;\\n        }\\n        if(dp[idx]!=-1){\\n            return dp[idx];\\n        }\\n        string mapped=phone[s[idx]-\\'0\\'];\\n        int len=mapped.length();\\n\\n        int instance=0;\\n\\n        int index=idx;\\n\\n        while(index<s.length() && s[index]==s[idx]){\\n            instance++;\\n            if(instance==len){\\n                break;\\n            }\\n            index++;\\n        }\\n\\n        int mini=min(instance,len);\\n\\n        int ans=0;\\n\\n        for(int i=1;i<=mini && i+idx<=s.length();i++){\\n            ans+=solve(s,idx+i,phone,dp)%mod;\\n            ans=ans%mod;\\n        }\\n\\n        return dp[idx]=ans%mod;\\n\\n    }\\n\\n    int countTexts(string pressedKeys) {\\n        vector<string> phone={\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\\n        int n=pressedKeys.length();\\n        vector<int> dp(n+1,-1);\\n        return solve(pressedKeys,0,phone,dp)%mod;\\n    }\\n};\\n\\n// \"2 2 2 3 3 \" \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676641,
                "title": "c-solution-using-dp-easy-to-understand",
                "content": "\\n```\\npublic class Solution {\\n    public int CountTexts(string s) {\\n        int mod = ((int)1e9) + 7;\\n        int[] dp = new int[s.Length + 1];\\n        Array.Fill(dp,-1);\\n        int solve(int idx){\\n            if(idx >= s.Length) return 1;\\n            if(dp[idx] != -1) return dp[idx];\\n            int options = (s[idx] == \\'7\\' || s[idx] == \\'9\\') ? 4 : 3;\\n            \\n            int right = idx;\\n            while(right < s.Length && (right - idx) < options && s[right] == s[idx])\\n                right++;\\n\\n            long res = 0;\\n            for (int j = idx + 1; j <= right; j++) res += (solve(j) % mod);\\n            return dp[idx] = ((int)(res % mod));\\n        }\\n        return solve(0) % mod;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic class Solution {\\n    public int CountTexts(string s) {\\n        int mod = ((int)1e9) + 7;\\n        int[] dp = new int[s.Length + 1];\\n        Array.Fill(dp,-1);\\n        int solve(int idx){\\n            if(idx >= s.Length) return 1;\\n            if(dp[idx] != -1) return dp[idx];\\n            int options = (s[idx] == \\'7\\' || s[idx] == \\'9\\') ? 4 : 3;\\n            \\n            int right = idx;\\n            while(right < s.Length && (right - idx) < options && s[right] == s[idx])\\n                right++;\\n\\n            long res = 0;\\n            for (int j = idx + 1; j <= right; j++) res += (solve(j) % mod);\\n            return dp[idx] = ((int)(res % mod));\\n        }\\n        return solve(0) % mod;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3671545,
                "title": "pyhton3-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        dp = [0]*len(pressedKeys)\\n        spes = set({\\'7\\', \\'9\\'})\\n        dp[0] = 1\\n\\n        mod = 10**9+7\\n\\n        cnt = 1\\n        for i in range(1 , len(pressedKeys)):\\n    \\n            if pressedKeys[i] not in spes:\\n                if pressedKeys[i]== pressedKeys[i-1]:\\n                    if cnt < 3:\\n                        dp[i]= 2*dp[i-1]\\n                        cnt+=1\\n                    else:\\n                        dp[i]= dp[i-1] + dp[i-2] + dp[i-3]\\n                \\n                else:\\n                    dp[i] = dp[i-1]\\n                    cnt = 1\\n            \\n            else:\\n                if pressedKeys[i-1] == pressedKeys[i]:\\n                    if cnt<4:\\n                        dp[i] = dp[i-1]*2\\n                        cnt += 1\\n                    else:\\n                        dp[i]= dp[i-1] + dp[i-2] + dp[i-3] + dp[i-4]\\n                \\n                else:\\n                    dp[i] = dp[i-1]\\n                    cnt = 1\\n            \\n            \\n            dp[i] = dp[i]%mod\\n    \\n    \\n        return(dp[-1])\\n        \\n        \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        dp = [0]*len(pressedKeys)\\n        spes = set({\\'7\\', \\'9\\'})\\n        dp[0] = 1\\n\\n        mod = 10**9+7\\n\\n        cnt = 1\\n        for i in range(1 , len(pressedKeys)):\\n    \\n            if pressedKeys[i] not in spes:\\n                if pressedKeys[i]== pressedKeys[i-1]:\\n                    if cnt < 3:\\n                        dp[i]= 2*dp[i-1]\\n                        cnt+=1\\n                    else:\\n                        dp[i]= dp[i-1] + dp[i-2] + dp[i-3]\\n                \\n                else:\\n                    dp[i] = dp[i-1]\\n                    cnt = 1\\n            \\n            else:\\n                if pressedKeys[i-1] == pressedKeys[i]:\\n                    if cnt<4:\\n                        dp[i] = dp[i-1]*2\\n                        cnt += 1\\n                    else:\\n                        dp[i]= dp[i-1] + dp[i-2] + dp[i-3] + dp[i-4]\\n                \\n                else:\\n                    dp[i] = dp[i-1]\\n                    cnt = 1\\n            \\n            \\n            dp[i] = dp[i]%mod\\n    \\n    \\n        return(dp[-1])\\n        \\n        \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3657619,
                "title": "simple-memoization",
                "content": "```\\nclass Solution {\\nint solve(int index, string &s){\\n    if(index==s.size()) return 1;\\n    int count=0;\\n    int limit=3;\\n    if(dp[index]!=-1) return dp[index];\\n    if(s[index]-\\'0\\'==7 || s[index]-\\'0\\'==9) limit++;\\n\\t\\n    for(int i=index;i<s.size() && i-index+1<=limit;i++){ // (i-index+1) sets the limit for the length of the consecutive same letters\\n        if(s[i]==s[index]){\\n            count=(count+solve(i+1,s))%mod;\\n        }\\n        else break;\\n    }\\n    return dp[index]= count%mod;\\n}\\n    \\n    \\npublic:\\n    vector<int> dp;\\n    int mod=1e9+7;\\n    int countTexts(string s) {\\n        dp.resize(s.size()+1,-1);\\n        return solve(0,s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nint solve(int index, string &s){\\n    if(index==s.size()) return 1;\\n    int count=0;\\n    int limit=3;\\n    if(dp[index]!=-1) return dp[index];\\n    if(s[index]-\\'0\\'==7 || s[index]-\\'0\\'==9) limit++;\\n\\t\\n    for(int i=index;i<s.size() && i-index+1<=limit;i++){ // (i-index+1) sets the limit for the length of the consecutive same letters\\n        if(s[i]==s[index]){\\n            count=(count+solve(i+1,s))%mod;\\n        }\\n        else break;\\n    }\\n    return dp[index]= count%mod;\\n}\\n    \\n    \\npublic:\\n    vector<int> dp;\\n    int mod=1e9+7;\\n    int countTexts(string s) {\\n        dp.resize(s.size()+1,-1);\\n        return solve(0,s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3599494,
                "title": "dp-solutions",
                "content": "\\n\\n# Code\\n```\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    /* Top Down */\\n    /* int solve(int ind, string &s, vector<int> &dp) {\\n        if(ind == s.size()) return 1;\\n\\n        if(dp[ind] != -1) return dp[ind];\\n\\n        int maxPress = (s[ind] == \\'7\\' or s[ind] == \\'9\\') ? 4 : 3;\\n        int pressed = 1, count = 0, curr = ind;\\n        while(pressed <= maxPress and s[curr] == s[ind]) {\\n            pressed++;\\n            curr++;\\n            count = (count + solve(curr, s, dp)) % mod;\\n        }\\n\\n        return dp[ind] = count % mod;\\n    }\\n\\n    int countTexts(string pressedKeys) {\\n        int n = pressedKeys.size();\\n        vector<int> dp(n + 1, -1);\\n        return solve(0, pressedKeys, dp) % mod;\\n    } */\\n\\n    /* Bottom Up */\\n    int countTexts(string pressedKeys) {\\n        int n = pressedKeys.size();\\n        vector<int> dp(n + 1);\\n        dp[n] = 1;\\n        for(int i = n - 1; i >= 0; i--) {\\n            int maxPress = pressedKeys[i] == \\'7\\' or pressedKeys[i] == \\'9\\' ? 4 : 3;\\n            int pressed = 1, curr = i, count = 0;\\n\\n            while(pressed <= maxPress and pressedKeys[curr] == pressedKeys[i]) {\\n                pressed++;\\n                curr++;\\n                count = (count + dp[curr]) % mod;\\n            }\\n\\n            dp[i] = count % mod;\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    /* Top Down */\\n    /* int solve(int ind, string &s, vector<int> &dp) {\\n        if(ind == s.size()) return 1;\\n\\n        if(dp[ind] != -1) return dp[ind];\\n\\n        int maxPress = (s[ind] == \\'7\\' or s[ind] == \\'9\\') ? 4 : 3;\\n        int pressed = 1, count = 0, curr = ind;\\n        while(pressed <= maxPress and s[curr] == s[ind]) {\\n            pressed++;\\n            curr++;\\n            count = (count + solve(curr, s, dp)) % mod;\\n        }\\n\\n        return dp[ind] = count % mod;\\n    }\\n\\n    int countTexts(string pressedKeys) {\\n        int n = pressedKeys.size();\\n        vector<int> dp(n + 1, -1);\\n        return solve(0, pressedKeys, dp) % mod;\\n    } */\\n\\n    /* Bottom Up */\\n    int countTexts(string pressedKeys) {\\n        int n = pressedKeys.size();\\n        vector<int> dp(n + 1);\\n        dp[n] = 1;\\n        for(int i = n - 1; i >= 0; i--) {\\n            int maxPress = pressedKeys[i] == \\'7\\' or pressedKeys[i] == \\'9\\' ? 4 : 3;\\n            int pressed = 1, curr = i, count = 0;\\n\\n            while(pressed <= maxPress and pressedKeys[curr] == pressedKeys[i]) {\\n                pressed++;\\n                curr++;\\n                count = (count + dp[curr]) % mod;\\n            }\\n\\n            dp[i] = count % mod;\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555360,
                "title": "c-recursion-memoization-tabulation-bottom-up-dp",
                "content": "we are finding every pattern possible like for example when \\na person pressed 333\\n\\nthen the total number of patters we can take ot perceive this is,\\n\\n3,3,3\\n3,33\\n33,3\\n333\\n\\nthat is 4.\\n\\nthis is what is carried out for each char in our string.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int ans(int ind,string s,vector<int> &keys,vector<int>&dp){\\n        if(ind==s.length())return 1;\\n        if(dp[ind]!=-1)return dp[ind];\\n        int count=0;\\n        int num=s[ind]-\\'0\\';\\n        int res=keys[num];\\n\\n        for(int i=0;i<res && ind+i<s.length() && s[ind+i]==s[ind];i++){\\n            count+=ans(ind+1+i,s,keys,dp);\\n            count%=mod;\\n        }\\n        return dp[ind]=count;\\n    }\\n    int countTexts(string pressedKeys) {\\n        vector<int> keys={0,0,3,3,3,3,3,4,3,4};\\n        \\n        int n=pressedKeys.size();\\n        vector<int> dp(n+1,0);\\n        string s=pressedKeys;\\n        dp[n]=1;\\n        for(int ind=n-1;ind>=0;ind--){\\n            int count=0;\\n            int num=s[ind]-\\'0\\';\\n            int res=keys[num];\\n\\n            for(int i=0;i<res && ind+i<s.length() && s[ind+i]==s[ind];i++){\\n                count+=dp[ind+1+i];\\n                count%=mod;\\n            }\\n                dp[ind]=count;\\n            }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int ans(int ind,string s,vector<int> &keys,vector<int>&dp){\\n        if(ind==s.length())return 1;\\n        if(dp[ind]!=-1)return dp[ind];\\n        int count=0;\\n        int num=s[ind]-\\'0\\';\\n        int res=keys[num];\\n\\n        for(int i=0;i<res && ind+i<s.length() && s[ind+i]==s[ind];i++){\\n            count+=ans(ind+1+i,s,keys,dp);\\n            count%=mod;\\n        }\\n        return dp[ind]=count;\\n    }\\n    int countTexts(string pressedKeys) {\\n        vector<int> keys={0,0,3,3,3,3,3,4,3,4};\\n        \\n        int n=pressedKeys.size();\\n        vector<int> dp(n+1,0);\\n        string s=pressedKeys;\\n        dp[n]=1;\\n        for(int ind=n-1;ind>=0;ind--){\\n            int count=0;\\n            int num=s[ind]-\\'0\\';\\n            int res=keys[num];\\n\\n            for(int i=0;i<res && ind+i<s.length() && s[ind+i]==s[ind];i++){\\n                count+=dp[ind+1+i];\\n                count%=mod;\\n            }\\n                dp[ind]=count;\\n            }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3552473,
                "title": "simple-dart-solution",
                "content": "\\n# Approach\\nMy first solution used recursion, but no matter how I did it I would always get a stack overflow error due to too much reucrsion so I made this solution using tabulation.\\n\\n# Code\\n```\\nclass Solution {\\n  int mod = 1000000007;\\n\\n  int countTexts(String pressedKeys) {\\n    List<int> key = [0, 0, 3, 3, 3, 3, 3, 4, 3, 4];\\n    int n = pressedKeys.length;\\n    List<int> dp = List<int>.filled(n + 1, 0);\\n    dp[n] = 1;\\n\\n    for (int ind = n - 1; ind >= 0; ind--) {\\n      int count = 0;\\n      int num = pressedKeys.codeUnitAt(ind) - \\'0\\'.codeUnitAt(0);\\n      int rep = key[num];\\n      for (int i = 0; i < rep && ind + i < pressedKeys.length && pressedKeys[ind] == pressedKeys[ind + i]; i++) {\\n        count += dp[ind + i + 1];\\n        count %= mod;\\n      }\\n      dp[ind] = count;\\n    }\\n    return dp[0];\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int mod = 1000000007;\\n\\n  int countTexts(String pressedKeys) {\\n    List<int> key = [0, 0, 3, 3, 3, 3, 3, 4, 3, 4];\\n    int n = pressedKeys.length;\\n    List<int> dp = List<int>.filled(n + 1, 0);\\n    dp[n] = 1;\\n\\n    for (int ind = n - 1; ind >= 0; ind--) {\\n      int count = 0;\\n      int num = pressedKeys.codeUnitAt(ind) - \\'0\\'.codeUnitAt(0);\\n      int rep = key[num];\\n      for (int i = 0; i < rep && ind + i < pressedKeys.length && pressedKeys[ind] == pressedKeys[ind + i]; i++) {\\n        count += dp[ind + i + 1];\\n        count %= mod;\\n      }\\n      dp[ind] = count;\\n    }\\n    return dp[0];\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520900,
                "title": "dp-memoization-java-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    long mod = (long)1e9+7;\\n    long[] dp = new long[100001];\\n    public long helper(String s,int idx,long[] dp){\\n        if(idx>=s.length()) return 1;\\n        if(dp[idx]!=-1) return dp[idx];\\n        long ans = 0;\\n            ans += (helper(s,idx+1,dp)%mod);\\n            if(idx+1<s.length() && s.charAt(idx)==s.charAt(idx+1)) ans += (helper(s,idx+2,dp)%mod);\\n            if(idx+2<s.length() && s.charAt(idx)==s.charAt(idx+1) && s.charAt(idx+2)==s.charAt(idx+1)) ans += (helper(s,idx+3,dp)%mod);\\n            if(s.charAt(idx)==\\'7\\' || s.charAt(idx)==\\'9\\'){\\n    if(idx+3<s.length() && s.charAt(idx)==s.charAt(idx+1) && s.charAt(idx+2)==s.charAt(idx+1) && s.charAt(idx+2)==s.charAt(idx+3)) ans += (helper(s,idx+4,dp)%mod);\\n            }\\n        ans %= mod;\\n        return dp[idx]=ans;\\n    }\\n    public int countTexts(String pressedKeys) {\\n        Arrays.fill(dp,-1);\\n        return (int)helper(pressedKeys,0,dp);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "String",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    long mod = (long)1e9+7;\\n    long[] dp = new long[100001];\\n    public long helper(String s,int idx,long[] dp){\\n        if(idx>=s.length()) return 1;\\n        if(dp[idx]!=-1) return dp[idx];\\n        long ans = 0;\\n            ans += (helper(s,idx+1,dp)%mod);\\n            if(idx+1<s.length() && s.charAt(idx)==s.charAt(idx+1)) ans += (helper(s,idx+2,dp)%mod);\\n            if(idx+2<s.length() && s.charAt(idx)==s.charAt(idx+1) && s.charAt(idx+2)==s.charAt(idx+1)) ans += (helper(s,idx+3,dp)%mod);\\n            if(s.charAt(idx)==\\'7\\' || s.charAt(idx)==\\'9\\'){\\n    if(idx+3<s.length() && s.charAt(idx)==s.charAt(idx+1) && s.charAt(idx+2)==s.charAt(idx+1) && s.charAt(idx+2)==s.charAt(idx+3)) ans += (helper(s,idx+4,dp)%mod);\\n            }\\n        ans %= mod;\\n        return dp[idx]=ans;\\n    }\\n    public int countTexts(String pressedKeys) {\\n        Arrays.fill(dp,-1);\\n        return (int)helper(pressedKeys,0,dp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436420,
                "title": "o-n-solution-beats-100-time",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def countTexts(self, pressedKeys):\\n        \"\"\"\\n        :type pressedKeys: str\\n        :rtype: int\\n        \"\"\"\\n        frequency_map = self.get_frequency_map(pressedKeys)\\n        tribo_max, quadro_max = self.get_max_tribo_an_quadro(frequency_map)\\n        tribos = self.get_all_tribos(tribo_max+1)\\n        quadros = self.get_all_quadros(quadro_max+1)\\n        combinations = self.get_all_combinations(tribos, quadros, frequency_map)\\n        return combinations\\n    \\n    def get_frequency_map(self, pressedKeys):\\n        frequency_map = []\\n        index = 0\\n        while index < len(pressedKeys):\\n            curr_char = pressedKeys[index]\\n            curr_count = 0\\n            while index < len(pressedKeys) and pressedKeys[index] == curr_char:\\n                curr_count+=1\\n                index+=1\\n            frequency_map.append([ord(curr_char)-ord(\\'0\\'), curr_count])\\n        \\n        return frequency_map\\n    \\n    def get_max_tribo_an_quadro(self, frequency_map):\\n        tribo_max = 3\\n        quadro_max = 4\\n        for key, freq in frequency_map:\\n            if key in [2,3,4,5,6,8]:\\n                tribo_max = max(tribo_max, freq)\\n            else:\\n               quadro_max = max(quadro_max, freq)\\n        return tribo_max, quadro_max\\n    \\n    def get_all_tribos(self, n):\\n        tribos = [0]*n\\n        tribos[0]=1\\n        tribos[1]=1\\n        tribos[2]=2\\n        for index in range(3, n):\\n            tribos[index] = self.add_all([tribos[index - 1],tribos[index - 2],tribos[index - 3]])\\n        return tribos\\n    \\n    def get_all_quadros(self, n):\\n        quadros=[0]*n\\n        quadros[0]=1\\n        quadros[1]=1\\n        quadros[2]=2\\n        quadros[3]=4\\n        for index in range(4, n):\\n            quadros[index] = self.add_all([quadros[index - 1],quadros[index - 2],quadros[index - 3],quadros[index - 4]])\\n        return quadros\\n    \\n    def get_all_combinations(self, tribos, quadros, frequency_map):\\n        combinations = 1\\n        for key, freq in frequency_map:\\n            if key in [2,3,4,5,6,8]:\\n                count = tribos[freq]\\n            else:\\n                count = quadros[freq]\\n            combinations = (combinations * count)%(1000000007)\\n        return combinations\\n\\n    \\n    def add_all(self, numbers):\\n        result = 0\\n        for num in numbers:\\n            result = (result + num)%(1000000007)\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def countTexts(self, pressedKeys):\\n        \"\"\"\\n        :type pressedKeys: str\\n        :rtype: int\\n        \"\"\"\\n        frequency_map = self.get_frequency_map(pressedKeys)\\n        tribo_max, quadro_max = self.get_max_tribo_an_quadro(frequency_map)\\n        tribos = self.get_all_tribos(tribo_max+1)\\n        quadros = self.get_all_quadros(quadro_max+1)\\n        combinations = self.get_all_combinations(tribos, quadros, frequency_map)\\n        return combinations\\n    \\n    def get_frequency_map(self, pressedKeys):\\n        frequency_map = []\\n        index = 0\\n        while index < len(pressedKeys):\\n            curr_char = pressedKeys[index]\\n            curr_count = 0\\n            while index < len(pressedKeys) and pressedKeys[index] == curr_char:\\n                curr_count+=1\\n                index+=1\\n            frequency_map.append([ord(curr_char)-ord(\\'0\\'), curr_count])\\n        \\n        return frequency_map\\n    \\n    def get_max_tribo_an_quadro(self, frequency_map):\\n        tribo_max = 3\\n        quadro_max = 4\\n        for key, freq in frequency_map:\\n            if key in [2,3,4,5,6,8]:\\n                tribo_max = max(tribo_max, freq)\\n            else:\\n               quadro_max = max(quadro_max, freq)\\n        return tribo_max, quadro_max\\n    \\n    def get_all_tribos(self, n):\\n        tribos = [0]*n\\n        tribos[0]=1\\n        tribos[1]=1\\n        tribos[2]=2\\n        for index in range(3, n):\\n            tribos[index] = self.add_all([tribos[index - 1],tribos[index - 2],tribos[index - 3]])\\n        return tribos\\n    \\n    def get_all_quadros(self, n):\\n        quadros=[0]*n\\n        quadros[0]=1\\n        quadros[1]=1\\n        quadros[2]=2\\n        quadros[3]=4\\n        for index in range(4, n):\\n            quadros[index] = self.add_all([quadros[index - 1],quadros[index - 2],quadros[index - 3],quadros[index - 4]])\\n        return quadros\\n    \\n    def get_all_combinations(self, tribos, quadros, frequency_map):\\n        combinations = 1\\n        for key, freq in frequency_map:\\n            if key in [2,3,4,5,6,8]:\\n                count = tribos[freq]\\n            else:\\n                count = quadros[freq]\\n            combinations = (combinations * count)%(1000000007)\\n        return combinations\\n\\n    \\n    def add_all(self, numbers):\\n        result = 0\\n        for num in numbers:\\n            result = (result + num)%(1000000007)\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395306,
                "title": "python-easy-dp",
                "content": "\\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        mod, i, res = 10**9 + 7, 0, 1\\n        def solveDp(n: int, x: int):\\n            nonlocal mod\\n            dp = [0 for _ in range(n + 1)]\\n            dp[0] = 1\\n            for i in range(1, n + 1):\\n                for j in range(x):\\n                    if i - j - 1 >= 0:\\n                        dp[i] = (dp[i] + dp[i - j - 1])%mod\\n            return dp[-1]\\n        mp = {\\'2\\': 3, \\'3\\':3, \\'4\\': 3, \\'5\\': 3, \\'6\\': 3, \\'7\\': 4, \\'8\\': 3, \\'9\\': 4}\\n        while i < len(pressedKeys):\\n            j = i + 1\\n            while j < len(pressedKeys) and pressedKeys[i] == pressedKeys[j]: j+=1\\n            res = (res * (solveDp(j - i, mp[pressedKeys[i]])))%mod\\n            i = j\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        mod, i, res = 10**9 + 7, 0, 1\\n        def solveDp(n: int, x: int):\\n            nonlocal mod\\n            dp = [0 for _ in range(n + 1)]\\n            dp[0] = 1\\n            for i in range(1, n + 1):\\n                for j in range(x):\\n                    if i - j - 1 >= 0:\\n                        dp[i] = (dp[i] + dp[i - j - 1])%mod\\n            return dp[-1]\\n        mp = {\\'2\\': 3, \\'3\\':3, \\'4\\': 3, \\'5\\': 3, \\'6\\': 3, \\'7\\': 4, \\'8\\': 3, \\'9\\': 4}\\n        while i < len(pressedKeys):\\n            j = i + 1\\n            while j < len(pressedKeys) and pressedKeys[i] == pressedKeys[j]: j+=1\\n            res = (res * (solveDp(j - i, mp[pressedKeys[i]])))%mod\\n            i = j\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3389029,
                "title": "simple-memoization-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>dp;\\n    long long mod = 1e9+7;\\n    int f(string &s,int ind,int n){\\n\\n        if(ind==n){\\n            return 1;\\n        }\\n\\n        if(ind>n) return 0;\\n\\n        if(dp[ind]!=-1) return dp[ind]%mod;\\n\\n        if(s[ind]==\\'7\\' or s[ind]==\\'9\\'){\\n            long long ans = 0;\\n            for(int i = ind;i<ind+4;i++){\\n                if(s[ind]==s[i]){\\n                    ans = ans + f(s,i+1,n);\\n                    ans = ans % mod;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            return dp[ind] = ans%mod;\\n        }\\n\\n        else{\\n            long long ans = 0;\\n            for(int i = ind;i<ind+3;i++){\\n                if(s[ind]==s[i]){\\n                    ans = ans + f(s,i+1,n);\\n                    ans = ans % mod;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            return dp[ind] = ans%mod;\\n        }\\n\\n    }\\n\\n    int countTexts(string s) {\\n        dp.resize(s.size()+1,-1);\\n        return f(s,0,s.size())%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>dp;\\n    long long mod = 1e9+7;\\n    int f(string &s,int ind,int n){\\n\\n        if(ind==n){\\n            return 1;\\n        }\\n\\n        if(ind>n) return 0;\\n\\n        if(dp[ind]!=-1) return dp[ind]%mod;\\n\\n        if(s[ind]==\\'7\\' or s[ind]==\\'9\\'){\\n            long long ans = 0;\\n            for(int i = ind;i<ind+4;i++){\\n                if(s[ind]==s[i]){\\n                    ans = ans + f(s,i+1,n);\\n                    ans = ans % mod;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            return dp[ind] = ans%mod;\\n        }\\n\\n        else{\\n            long long ans = 0;\\n            for(int i = ind;i<ind+3;i++){\\n                if(s[ind]==s[i]){\\n                    ans = ans + f(s,i+1,n);\\n                    ans = ans % mod;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            return dp[ind] = ans%mod;\\n        }\\n\\n    }\\n\\n    int countTexts(string s) {\\n        dp.resize(s.size()+1,-1);\\n        return f(s,0,s.size())%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3385783,
                "title": "python-dp",
                "content": "```\\nimport math\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        DP = [0] * (len(pressedKeys)+1)\\n        DP[0] = 1\\n        for i in range(1, len(DP)):\\n            DP[i] = DP[i-1]\\n            if i > 1 and pressedKeys[i-1] == pressedKeys[i-2]:\\n                DP[i] += DP[i-2]\\n                DP[i] %= (10**9 + 7)\\n                if i > 2 and pressedKeys[i-1] == pressedKeys[i-3]:\\n                    DP[i] += DP[i-3]                     \\n                    DP[i] %= (10**9 + 7)     \\n                    if i > 3 and pressedKeys[i-1] in [\\'7\\', \\'9\\'] and pressedKeys[i-1] == pressedKeys[i-4]:\\n                        DP[i] += DP[i-4]\\n                        DP[i] %= (10**9 + 7)\\n        return DP[-1]\\n\\n\"\"\"\\n# Memoization and combinatorics\\n\\nimport math\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        d = {\\'2\\':3,\\'3\\':3,\\'4\\':3,\\'5\\':3,\\'6\\':3,\\'7\\':4,\\'8\\':3,\\'9\\':4}\\n    \\n        cache = dict()\\n        def cache_count(v, i):\\n            if i < 0:\\n                return 0\\n            if i == 0:\\n                return 1\\n\\n            if (v, i) in cache:\\n                return cache[(v, i)]\\n            \\n            cache[(v, i)] = sum(cache_count(v, i-j) for j in range(1, v+1))\\n            return cache[(v, i)]\\n\\n        t = 1\\n\\n        c = pressedKeys[0]\\n        l = 1\\n        for k in pressedKeys[1:]:\\n            if k == c:\\n                l += 1\\n            else:     \\n                t *= cache_count(d[c],l)\\n                t %= (10**9 + 7)\\n                l = 1\\n                c = k\\n        t *= cache_count(d[c],l)\\n        t %= (10**9 + 7)\\n        return t\\n\"\"\"\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        DP = [0] * (len(pressedKeys)+1)\\n        DP[0] = 1\\n        for i in range(1, len(DP)):\\n            DP[i] = DP[i-1]\\n            if i > 1 and pressedKeys[i-1] == pressedKeys[i-2]:\\n                DP[i] += DP[i-2]\\n                DP[i] %= (10**9 + 7)\\n                if i > 2 and pressedKeys[i-1] == pressedKeys[i-3]:\\n                    DP[i] += DP[i-3]                     \\n                    DP[i] %= (10**9 + 7)     \\n                    if i > 3 and pressedKeys[i-1] in [\\'7\\', \\'9\\'] and pressedKeys[i-1] == pressedKeys[i-4]:\\n                        DP[i] += DP[i-4]\\n                        DP[i] %= (10**9 + 7)\\n        return DP[-1]\\n\\n\"\"\"\\n# Memoization and combinatorics\\n\\nimport math\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        d = {\\'2\\':3,\\'3\\':3,\\'4\\':3,\\'5\\':3,\\'6\\':3,\\'7\\':4,\\'8\\':3,\\'9\\':4}\\n    \\n        cache = dict()\\n        def cache_count(v, i):\\n            if i < 0:\\n                return 0\\n            if i == 0:\\n                return 1\\n\\n            if (v, i) in cache:\\n                return cache[(v, i)]\\n            \\n            cache[(v, i)] = sum(cache_count(v, i-j) for j in range(1, v+1))\\n            return cache[(v, i)]\\n\\n        t = 1\\n\\n        c = pressedKeys[0]\\n        l = 1\\n        for k in pressedKeys[1:]:\\n            if k == c:\\n                l += 1\\n            else:     \\n                t *= cache_count(d[c],l)\\n                t %= (10**9 + 7)\\n                l = 1\\n                c = k\\n        t *= cache_count(d[c],l)\\n        t %= (10**9 + 7)\\n        return t\\n\"\"\"\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3374672,
                "title": "pam-parar",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} pressedKeys\\n * @return {number}\\n */\\nfunction countTexts (pressedKeys) {\\n   const strLength = pressedKeys.length;\\n   const bigInt = 10 ** 9 + 7;\\n   const fibonacci = new Array(strLength + 1).fill(0);\\n   fibonacci[0] = 1;\\n   \\n   let last = 0;\\n   let count = 0;\\n   \\n   for (let i = 1; i <= strLength; ++i) {\\n      const currient = pressedKeys[i - 1];\\n      \\n      if (currient !== last) count = 0;\\n      \\n      last = currient;\\n      count += 1;\\n      \\n      fibonacci[i] = (fibonacci[i] + fibonacci[i - 1]) % bigInt;\\n      \\n      if (i >= 2 && count >= 2) fibonacci[i] = (fibonacci[i] + fibonacci[i - 2]) % bigInt;\\n      if (i >= 3 && count >= 3) fibonacci[i] = (fibonacci[i] + fibonacci[i - 3]) % bigInt;\\n      if ((currient == \"7\"  || currient == \"9\") && i >= 4 && count >= 4) \\n      fibonacci[i] = (fibonacci[i] + fibonacci[i - 4]) % bigInt;\\n   }\\n\\n   return fibonacci[strLength];\\n   \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} pressedKeys\\n * @return {number}\\n */\\nfunction countTexts (pressedKeys) {\\n   const strLength = pressedKeys.length;\\n   const bigInt = 10 ** 9 + 7;\\n   const fibonacci = new Array(strLength + 1).fill(0);\\n   fibonacci[0] = 1;\\n   \\n   let last = 0;\\n   let count = 0;\\n   \\n   for (let i = 1; i <= strLength; ++i) {\\n      const currient = pressedKeys[i - 1];\\n      \\n      if (currient !== last) count = 0;\\n      \\n      last = currient;\\n      count += 1;\\n      \\n      fibonacci[i] = (fibonacci[i] + fibonacci[i - 1]) % bigInt;\\n      \\n      if (i >= 2 && count >= 2) fibonacci[i] = (fibonacci[i] + fibonacci[i - 2]) % bigInt;\\n      if (i >= 3 && count >= 3) fibonacci[i] = (fibonacci[i] + fibonacci[i - 3]) % bigInt;\\n      if ((currient == \"7\"  || currient == \"9\") && i >= 4 && count >= 4) \\n      fibonacci[i] = (fibonacci[i] + fibonacci[i - 4]) % bigInt;\\n   }\\n\\n   return fibonacci[strLength];\\n   \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3373550,
                "title": "a-brute-weird-solution-c-memoization",
                "content": "```\\nclass Solution\\n{\\n    const int M = 1e9 + 7;\\n    long long help(string &s, int cur, map<string, char> &mp, vector<int> &dp)\\n    {\\n        if (cur >= s.length()) return 1;\\n\\n        long long one = 0, two = 0, three = 0, four = 0;\\n\\n        if (dp[cur] != -1) return dp[cur];\\n\\n        if (cur < s.length())\\n        {\\n            string temp;\\n            temp.push_back(s[cur]);\\n            if (mp.find(temp) != mp.end())\\n            {\\n                one = help(s, cur + 1, mp, dp) % M;\\n            }\\n        }\\n        if (cur + 1 < s.length())\\n        {\\n            string temp;\\n            temp.push_back(s[cur]);\\n            temp.push_back(s[cur + 1]);\\n\\n            if (mp.find(temp) != mp.end())\\n            {\\n                two = help(s, cur + 2, mp, dp) % M;\\n            }\\n        }\\n        if (cur + 2 < s.length())\\n        {\\n            string temp;\\n            temp.push_back(s[cur]);\\n            temp.push_back(s[cur + 1]);\\n            temp.push_back(s[cur + 2]);\\n\\n            if (mp.find(temp) != mp.end())\\n            {\\n                three = help(s, cur + 3, mp, dp) % M;\\n            }\\n        }\\n        if (cur + 3 < s.length())\\n        {\\n            string temp;\\n            temp.push_back(s[cur]);\\n            temp.push_back(s[cur + 1]);\\n            temp.push_back(s[cur + 2]);\\n            temp.push_back(s[cur + 3]);\\n\\n            if (mp.find(temp) != mp.end())\\n            {\\n                four = help(s, cur + 4, mp, dp) % M;\\n            }\\n        }\\n        return dp[cur] = (one + two + three + four) % M;\\n    }\\n\\n    public:\\n        int countTexts(string s)\\n        {\\n            map<string, char> mp;\\n            mp[\"2\"] = \\'a\\';\\n            mp[\"22\"] = \\'b\\';\\n            mp[\"222\"] = \\'c\\';\\n            mp[\"3\"] = \\'d\\';\\n            mp[\"33\"] = \\'e\\';\\n            mp[\"333\"] = \\'f\\';\\n            mp[\"4\"] = \\'g\\';\\n            mp[\"44\"] = \\'h\\';\\n            mp[\"444\"] = \\'i\\';\\n            mp[\"5\"] = \\'j\\';\\n            mp[\"55\"] = \\'k\\';\\n            mp[\"555\"] = \\'l\\';\\n            mp[\"6\"] = \\'m\\';\\n            mp[\"66\"] = \\'n\\';\\n            mp[\"666\"] = \\'o\\';\\n            mp[\"7\"] = \\'p\\';\\n            mp[\"77\"] = \\'q\\';\\n            mp[\"777\"] = \\'r\\';\\n            mp[\"7777\"] = \\'s\\';\\n            mp[\"8\"] = \\'t\\';\\n            mp[\"88\"] = \\'u\\';\\n            mp[\"888\"] = \\'v\\';\\n            mp[\"9\"] = \\'w\\';\\n            mp[\"99\"] = \\'x\\';\\n            mp[\"999\"] = \\'y\\';\\n            mp[\"9999\"] = \\'z\\';\\n\\n            int n = s.length();\\n            vector<int> dp(n, -1);\\n            return help(s, 0, mp, dp);\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution\\n{\\n    const int M = 1e9 + 7;\\n    long long help(string &s, int cur, map<string, char> &mp, vector<int> &dp)\\n    {\\n        if (cur >= s.length()) return 1;\\n\\n        long long one = 0, two = 0, three = 0, four = 0;\\n\\n        if (dp[cur] != -1) return dp[cur];\\n\\n        if (cur < s.length())\\n        {\\n            string temp;\\n            temp.push_back(s[cur]);\\n            if (mp.find(temp) != mp.end())\\n            {\\n                one = help(s, cur + 1, mp, dp) % M;\\n            }\\n        }\\n        if (cur + 1 < s.length())\\n        {\\n            string temp;\\n            temp.push_back(s[cur]);\\n            temp.push_back(s[cur + 1]);\\n\\n            if (mp.find(temp) != mp.end())\\n            {\\n                two = help(s, cur + 2, mp, dp) % M;\\n            }\\n        }\\n        if (cur + 2 < s.length())\\n        {\\n            string temp;\\n            temp.push_back(s[cur]);\\n            temp.push_back(s[cur + 1]);\\n            temp.push_back(s[cur + 2]);\\n\\n            if (mp.find(temp) != mp.end())\\n            {\\n                three = help(s, cur + 3, mp, dp) % M;\\n            }\\n        }\\n        if (cur + 3 < s.length())\\n        {\\n            string temp;\\n            temp.push_back(s[cur]);\\n            temp.push_back(s[cur + 1]);\\n            temp.push_back(s[cur + 2]);\\n            temp.push_back(s[cur + 3]);\\n\\n            if (mp.find(temp) != mp.end())\\n            {\\n                four = help(s, cur + 4, mp, dp) % M;\\n            }\\n        }\\n        return dp[cur] = (one + two + three + four) % M;\\n    }\\n\\n    public:\\n        int countTexts(string s)\\n        {\\n            map<string, char> mp;\\n            mp[\"2\"] = \\'a\\';\\n            mp[\"22\"] = \\'b\\';\\n            mp[\"222\"] = \\'c\\';\\n            mp[\"3\"] = \\'d\\';\\n            mp[\"33\"] = \\'e\\';\\n            mp[\"333\"] = \\'f\\';\\n            mp[\"4\"] = \\'g\\';\\n            mp[\"44\"] = \\'h\\';\\n            mp[\"444\"] = \\'i\\';\\n            mp[\"5\"] = \\'j\\';\\n            mp[\"55\"] = \\'k\\';\\n            mp[\"555\"] = \\'l\\';\\n            mp[\"6\"] = \\'m\\';\\n            mp[\"66\"] = \\'n\\';\\n            mp[\"666\"] = \\'o\\';\\n            mp[\"7\"] = \\'p\\';\\n            mp[\"77\"] = \\'q\\';\\n            mp[\"777\"] = \\'r\\';\\n            mp[\"7777\"] = \\'s\\';\\n            mp[\"8\"] = \\'t\\';\\n            mp[\"88\"] = \\'u\\';\\n            mp[\"888\"] = \\'v\\';\\n            mp[\"9\"] = \\'w\\';\\n            mp[\"99\"] = \\'x\\';\\n            mp[\"999\"] = \\'y\\';\\n            mp[\"9999\"] = \\'z\\';\\n\\n            int n = s.length();\\n            vector<int> dp(n, -1);\\n            return help(s, 0, mp, dp);\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345505,
                "title": "c-golang-dp",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\n    const int mod = 1e9 + 7; \\npublic:\\n    int countTexts(string pressedKeys) {\\n        int j, n = pressedKeys.size();\\n        vector<int> DP(n, 1);\\n        long long ans = 1;\\n        for(int i = 0; i < n; i = j) {\\n            for(j = i + 1; j < n && pressedKeys[j] == pressedKeys[i]; j++) {\\n                if(j - i == 1) {\\n                    DP[j] = 2; continue;\\n                } else if(j - i == 2) {\\n                    DP[j] = 4; continue;\\n                }\\n                DP[j] = ((DP[j - 1] + DP[j - 2]) % mod + DP[j - 3]) % mod;\\n                if(pressedKeys[i] == \\'7\\' || pressedKeys[i] == \\'9\\') {\\n                    if(j - i == 3) {\\n                        DP[j] = 8; continue;\\n                    }\\n                    DP[j] = (DP[j] + DP[j - 4]) % mod;\\n                }\\n            }\\n            ans = (ans * DP[j - 1]) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nconst mod int = 1e9 + 7\\nfunc countTexts(pressedKeys string) int {\\n    var j, n int = 1, len(pressedKeys)\\n    DP := make([]int, n)\\n    var ans int = 1\\n    for i := 0; i < n; i = j {\\n        DP[i] = 1\\n        for j = i + 1; j < n && pressedKeys[j] == pressedKeys[i]; j++ {\\n            if j - i == 1 {\\n                DP[j] = 2\\n                continue\\n            } else if j - i == 2 {\\n                DP[j] = 4 \\n                continue\\n            }\\n            DP[j] = ((DP[j - 1] + DP[j - 2]) % mod + DP[j - 3]) % mod\\n            if pressedKeys[i] == \\'7\\' || pressedKeys[i] == \\'9\\' {\\n                if j - i == 3 {\\n                    DP[j] = 8\\n                    continue\\n                }\\n                DP[j] = (DP[j] + DP[j - 4]) % mod\\n            }\\n        }\\n        ans = (ans * DP[j - 1]) % mod\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Math",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\n// C++\\nclass Solution {\\n    const int mod = 1e9 + 7; \\npublic:\\n    int countTexts(string pressedKeys) {\\n        int j, n = pressedKeys.size();\\n        vector<int> DP(n, 1);\\n        long long ans = 1;\\n        for(int i = 0; i < n; i = j) {\\n            for(j = i + 1; j < n && pressedKeys[j] == pressedKeys[i]; j++) {\\n                if(j - i == 1) {\\n                    DP[j] = 2; continue;\\n                } else if(j - i == 2) {\\n                    DP[j] = 4; continue;\\n                }\\n                DP[j] = ((DP[j - 1] + DP[j - 2]) % mod + DP[j - 3]) % mod;\\n                if(pressedKeys[i] == \\'7\\' || pressedKeys[i] == \\'9\\') {\\n                    if(j - i == 3) {\\n                        DP[j] = 8; continue;\\n                    }\\n                    DP[j] = (DP[j] + DP[j - 4]) % mod;\\n                }\\n            }\\n            ans = (ans * DP[j - 1]) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nconst mod int = 1e9 + 7\\nfunc countTexts(pressedKeys string) int {\\n    var j, n int = 1, len(pressedKeys)\\n    DP := make([]int, n)\\n    var ans int = 1\\n    for i := 0; i < n; i = j {\\n        DP[i] = 1\\n        for j = i + 1; j < n && pressedKeys[j] == pressedKeys[i]; j++ {\\n            if j - i == 1 {\\n                DP[j] = 2\\n                continue\\n            } else if j - i == 2 {\\n                DP[j] = 4 \\n                continue\\n            }\\n            DP[j] = ((DP[j - 1] + DP[j - 2]) % mod + DP[j - 3]) % mod\\n            if pressedKeys[i] == \\'7\\' || pressedKeys[i] == \\'9\\' {\\n                if j - i == 3 {\\n                    DP[j] = 8\\n                    continue\\n                }\\n                DP[j] = (DP[j] + DP[j - 4]) % mod\\n            }\\n        }\\n        ans = (ans * DP[j - 1]) % mod\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3333515,
                "title": "easy-dp-approach-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)+extra stack space\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int solve(string &s,int index,vector<int> &dp)\\n    {\\n        if(index>=s.length()){\\n            return 1;\\n        }\\n        if(dp[index]!=-1){\\n            return dp[index];\\n        }\\n        long long ans=0;\\n        //case 1\\n        ans=ans+solve(s,index+1,dp);\\n\\n        //case 2\\n        if(index+1<s.length()){\\n            if(s[index]==s[index+1]){\\n                ans=ans+solve(s,index+2,dp);\\n            }\\n        }\\n\\n        //case 3\\n        if(index+2<s.length()){\\n            if((s[index]==s[index+1])&&(s[index]==s[index+2])){\\n                ans=ans+solve(s,index+3,dp);\\n            }\\n        }\\n\\n        //case 4\\n        if(index+3<s.length() &&(s[index]==\\'7\\' || s[index]==\\'9\\')){\\n            if((s[index]==s[index+1])&&(s[index]==s[index+2])&&(s[index]==s[index+3])){\\n                ans=ans+solve(s,index+4,dp);\\n            }\\n        }\\n        return dp[index]=ans%mod;\\n    }\\n    int countTexts(string s) \\n    {\\n        int n=s.length();\\n        vector<int> dp(n+1,-1);\\n        return solve(s,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int solve(string &s,int index,vector<int> &dp)\\n    {\\n        if(index>=s.length()){\\n            return 1;\\n        }\\n        if(dp[index]!=-1){\\n            return dp[index];\\n        }\\n        long long ans=0;\\n        //case 1\\n        ans=ans+solve(s,index+1,dp);\\n\\n        //case 2\\n        if(index+1<s.length()){\\n            if(s[index]==s[index+1]){\\n                ans=ans+solve(s,index+2,dp);\\n            }\\n        }\\n\\n        //case 3\\n        if(index+2<s.length()){\\n            if((s[index]==s[index+1])&&(s[index]==s[index+2])){\\n                ans=ans+solve(s,index+3,dp);\\n            }\\n        }\\n\\n        //case 4\\n        if(index+3<s.length() &&(s[index]==\\'7\\' || s[index]==\\'9\\')){\\n            if((s[index]==s[index+1])&&(s[index]==s[index+2])&&(s[index]==s[index+3])){\\n                ans=ans+solve(s,index+4,dp);\\n            }\\n        }\\n        return dp[index]=ans%mod;\\n    }\\n    int countTexts(string s) \\n    {\\n        int n=s.length();\\n        vector<int> dp(n+1,-1);\\n        return solve(s,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268843,
                "title": "c-easy-solution-using-dp-and-memoization",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //using dp and memoization\\n    //partition and not partition variation\\n    //TC=O(N)\\n    //SC=O(N)+O(stack space)\\n    int mod=1e9+7;\\n    int find(int i,int c,string& s,vector<vector<int>>& dp,int n){\\n        if(i==n){\\n            return 1;\\n        }\\n        if(dp[i][c]!=-1){\\n            return dp[i][c]%mod;\\n        }\\n        int ways=0;\\n        if((s[i]==\\'9\\'||s[i]==\\'7\\') && c+1<=4){\\n            ways=(ways+find(i+1,0,s,dp,n))%mod;\\n        }\\n        if(s[i]!=\\'9\\' && s[i]!=\\'7\\' && c+1<=3){\\n            ways=(ways+find(i+1,0,s,dp,n))%mod;\\n        }\\n        if(i+1<n && (s[i]==\\'9\\'||s[i]==\\'7\\') && c+1<=4 && s[i]==s[i+1]){\\n            ways=(ways+find(i+1,c+1,s,dp,n))%mod;\\n        }\\n        if(i+1<n && s[i]!=\\'9\\' && s[i]!=\\'7\\' && c+1<=3 && s[i]==s[i+1]){\\n            ways=(ways+find(i+1,c+1,s,dp,n))%mod;\\n        }\\n        return dp[i][c]=ways%mod;\\n    }\\n    int countTexts(string pressedKeys) {\\n        int n=pressedKeys.size();\\n        vector<vector<int>> dp(n,vector<int>(6,-1));\\n        return find(0,0,pressedKeys,dp,n);\\n    }\\n};\\n```\\n# AUTHOR: JAYESH BADGUJAR\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //using dp and memoization\\n    //partition and not partition variation\\n    //TC=O(N)\\n    //SC=O(N)+O(stack space)\\n    int mod=1e9+7;\\n    int find(int i,int c,string& s,vector<vector<int>>& dp,int n){\\n        if(i==n){\\n            return 1;\\n        }\\n        if(dp[i][c]!=-1){\\n            return dp[i][c]%mod;\\n        }\\n        int ways=0;\\n        if((s[i]==\\'9\\'||s[i]==\\'7\\') && c+1<=4){\\n            ways=(ways+find(i+1,0,s,dp,n))%mod;\\n        }\\n        if(s[i]!=\\'9\\' && s[i]!=\\'7\\' && c+1<=3){\\n            ways=(ways+find(i+1,0,s,dp,n))%mod;\\n        }\\n        if(i+1<n && (s[i]==\\'9\\'||s[i]==\\'7\\') && c+1<=4 && s[i]==s[i+1]){\\n            ways=(ways+find(i+1,c+1,s,dp,n))%mod;\\n        }\\n        if(i+1<n && s[i]!=\\'9\\' && s[i]!=\\'7\\' && c+1<=3 && s[i]==s[i+1]){\\n            ways=(ways+find(i+1,c+1,s,dp,n))%mod;\\n        }\\n        return dp[i][c]=ways%mod;\\n    }\\n    int countTexts(string pressedKeys) {\\n        int n=pressedKeys.size();\\n        vector<vector<int>> dp(n,vector<int>(6,-1));\\n        return find(0,0,pressedKeys,dp,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3262905,
                "title": "recursion-memoization-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int mod=1e9+7;\\n    int dp[100005][5];\\n    int f(int count, int maxGrouping)\\n    {\\n        if(count==0) return 1;\\n        if(count<0) return 0;\\n        if(dp[count][maxGrouping]!=-1) return dp[count][maxGrouping];\\n        int ans=0;\\n        for(int x=1; x<=min(count,maxGrouping); x++)\\n        {\\n            ans=(ans%mod+f(count-x,maxGrouping)%mod)%mod;\\n        }\\n        return dp[count][maxGrouping]=ans%mod;\\n    }\\n    int countTexts(string pressedKeys) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        map<int,int> m;\\n        int ans=1;\\n        m[2]=3; m[3]=3; m[4]=3; m[5]=3; m[6]=3; m[7]=4; m[8]=3; m[9]=4;\\n        int n=pressedKeys.size();\\n        for(int x=0; x<n; x++)\\n        {\\n            int i=x+1;\\n            int count=1;\\n            while(i<n && pressedKeys[x]==pressedKeys[i])\\n            {\\n                i++; count++;\\n            }\\n            ans=((long long)ans%mod*f(count,m[pressedKeys[x]-48])%mod)%mod;\\n            x=i-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int mod=1e9+7;\\n    int dp[100005][5];\\n    int f(int count, int maxGrouping)\\n    {\\n        if(count==0) return 1;\\n        if(count<0) return 0;\\n        if(dp[count][maxGrouping]!=-1) return dp[count][maxGrouping];\\n        int ans=0;\\n        for(int x=1; x<=min(count,maxGrouping); x++)\\n        {\\n            ans=(ans%mod+f(count-x,maxGrouping)%mod)%mod;\\n        }\\n        return dp[count][maxGrouping]=ans%mod;\\n    }\\n    int countTexts(string pressedKeys) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        map<int,int> m;\\n        int ans=1;\\n        m[2]=3; m[3]=3; m[4]=3; m[5]=3; m[6]=3; m[7]=4; m[8]=3; m[9]=4;\\n        int n=pressedKeys.size();\\n        for(int x=0; x<n; x++)\\n        {\\n            int i=x+1;\\n            int count=1;\\n            while(i<n && pressedKeys[x]==pressedKeys[i])\\n            {\\n                i++; count++;\\n            }\\n            ans=((long long)ans%mod*f(count,m[pressedKeys[x]-48])%mod)%mod;\\n            x=i-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3210334,
                "title": "c-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const unsigned int M = pow(10,9)+7; \\n    void dpf(string& pressedKeys, int curr, vector<int>& dp){\\n        char t = pressedKeys[curr];\\n        int num;\\n        if(t==\\'7\\'|| t==\\'9\\') num = 4;\\n        else num=3; \\n        for(int i = curr; i<dp.size() && i-curr<num && pressedKeys[i]==t; i++){\\n            if(i+1<dp.size()) dp[curr] = (dp[curr]+dp[i+1])%M; \\n            else dp[curr] = (dp[curr]+1)%M; \\n        }\\n    }\\n    int countTexts(string pressedKeys) {\\n        //dp   \\n        int len = pressedKeys.length(); \\n        vector<int> dp(len, 0);\\n        dp[len-1] = 1; \\n        for(int i = len-2; i >=0; i--)\\n            dpf(pressedKeys, i, dp); \\n        return dp[0]; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const unsigned int M = pow(10,9)+7; \\n    void dpf(string& pressedKeys, int curr, vector<int>& dp){\\n        char t = pressedKeys[curr];\\n        int num;\\n        if(t==\\'7\\'|| t==\\'9\\') num = 4;\\n        else num=3; \\n        for(int i = curr; i<dp.size() && i-curr<num && pressedKeys[i]==t; i++){\\n            if(i+1<dp.size()) dp[curr] = (dp[curr]+dp[i+1])%M; \\n            else dp[curr] = (dp[curr]+1)%M; \\n        }\\n    }\\n    int countTexts(string pressedKeys) {\\n        //dp   \\n        int len = pressedKeys.length(); \\n        vector<int> dp(len, 0);\\n        dp[len-1] = 1; \\n        for(int i = len-2; i >=0; i--)\\n            dpf(pressedKeys, i, dp); \\n        return dp[0]; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173333,
                "title": "bottom-up-dp-python-o-n-image-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWith each new press is a potential double, triple, quad grouping (aka potential letter) that could be appended. \\n\\nLook back at the previous DP solution ***before that grouping (or letter) was considered*** and add to current DP[i].\\n![image.png](https://assets.leetcode.com/users/images/a8eb9f79-7d9e-4f10-88f4-be58d63eb63f_1676143680.0307488.png)\\n\\nie. \\n   7777\\n\\n   When adding that i=3 char 7, we open the possibility to append the following (4) letters to the path:\\n   - Adding P (+7) to series: DP[i-1] \\n   - Adding Q (+77) to series: DP[i-2]\\n   - Adding R (+777) to series: DP[i-3]\\n   - Adding S (+7777) to series: DP[i-4]\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBuilding up the solution (tabulation), we\\'ll consider any potential letters formed when adding the latest button press.\\n\\nThe subproblem we\\'ll choose is this:\\n\\n> DP[i] = number of pathways up to AND including the i-th button press\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) - run through array once\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) - storing DP state \\n# Code\\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n\\n\\n        s = pressedKeys\\n\\n        n = len(pressedKeys)\\n        \\n        DP = [0] * (n+1)\\n        if n ==1 :\\n            return 1\\n\\n        DP[0] = 1\\n        offset = 1 # offset b/c DP[i] refers to s[i-1]\\n        for i in range(1,len(DP)):\\n            # single unique character press\\n            DP[i] = DP[i-1]\\n                    \\n            # char double press\\n            if s[i-offset] == s[i-offset-1]:\\n                DP[i] += DP[i-2]\\n                DP[i] = (DP[i] % (10**9 + 7))\\n            # triple press\\n            if i> 2 and s[i-offset]== s[i-offset-1] and s[i-offset-1] == s[i-offset-2]:\\n                DP[i] += DP[i-3]\\n                DP[i] = (DP[i] % (10**9 + 7))\\n            # quad press of the button\\n            if i>3 and (s[i-offset] == \"7\" or s[i-offset]==\"9\") and s[i-offset]== s[i-offset-1] and s[i-offset-1] == s[i-offset-2] and s[i-offset-2] == s[i-offset-3]:\\n                DP[i] += DP[i-4] \\n                DP[i] = (DP[i] % (10**9 + 7))\\n\\n        print(DP)\\n\\n        return DP[n] % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n\\n\\n        s = pressedKeys\\n\\n        n = len(pressedKeys)\\n        \\n        DP = [0] * (n+1)\\n        if n ==1 :\\n            return 1\\n\\n        DP[0] = 1\\n        offset = 1 # offset b/c DP[i] refers to s[i-1]\\n        for i in range(1,len(DP)):\\n            # single unique character press\\n            DP[i] = DP[i-1]\\n                    \\n            # char double press\\n            if s[i-offset] == s[i-offset-1]:\\n                DP[i] += DP[i-2]\\n                DP[i] = (DP[i] % (10**9 + 7))\\n            # triple press\\n            if i> 2 and s[i-offset]== s[i-offset-1] and s[i-offset-1] == s[i-offset-2]:\\n                DP[i] += DP[i-3]\\n                DP[i] = (DP[i] % (10**9 + 7))\\n            # quad press of the button\\n            if i>3 and (s[i-offset] == \"7\" or s[i-offset]==\"9\") and s[i-offset]== s[i-offset-1] and s[i-offset-1] == s[i-offset-2] and s[i-offset-2] == s[i-offset-3]:\\n                DP[i] += DP[i-4] \\n                DP[i] = (DP[i] % (10**9 + 7))\\n\\n        print(DP)\\n\\n        return DP[n] % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141053,
                "title": "tribonacci-and-quad-fibonacci-python-solution",
                "content": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        res = 1\\n        \\n        @cache\\n        def dp3(i):\\n            prev_1, prev_2, curr = 0, 0, 1\\n            \\n            for _ in range(i):\\n                prev_1, prev_2, curr = prev_2, curr, curr+prev_1+prev_2\\n                \\n            return curr\\n        \\n        @cache\\n        def dp4(i):\\n            prev_1, prev_2, prev_3, curr = 0, 0, 0, 1\\n            \\n            for _ in range(i):\\n                prev_1, prev_2, prev_3, curr = prev_2, prev_3, curr, prev_1 + prev_2 + prev_3 + curr\\n                \\n            return curr\\n                \\n        for k,v in groupby(pressedKeys):\\n            if k == \\'7\\' or k == \\'9\\': \\n                res *= dp4(sum(1 for _ in v))\\n            else:\\n                res *= dp3(sum(1 for _ in v))\\n            \\n        return res%(1000000007)        \\n ```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        res = 1\\n        \\n        @cache\\n        def dp3(i):\\n            prev_1, prev_2, curr = 0, 0, 1\\n            \\n            for _ in range(i):\\n                prev_1, prev_2, curr = prev_2, curr, curr+prev_1+prev_2\\n                \\n            return curr\\n        \\n        @cache\\n        def dp4(i):\\n            prev_1, prev_2, prev_3, curr = 0, 0, 0, 1\\n            \\n            for _ in range(i):\\n                prev_1, prev_2, prev_3, curr = prev_2, prev_3, curr, prev_1 + prev_2 + prev_3 + curr\\n                \\n            return curr\\n                \\n        for k,v in groupby(pressedKeys):\\n            if k == \\'7\\' or k == \\'9\\': \\n                res *= dp4(sum(1 for _ in v))\\n            else:\\n                res *= dp3(sum(1 for _ in v))\\n            \\n        return res%(1000000007)        \\n ```",
                "codeTag": "Java"
            },
            {
                "id": 3130372,
                "title": "based-on-climbing-stairs-dp-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n   long  climbingStairs3(int n){\\n       if(n == 0) return 0;\\n       if(n == 1) return 1;\\n       if(n == 2) return 2;\\n       if(n == 3) return 4;\\n       long  dp[n];\\n       dp[0] = 1;\\n       dp[1] = 2;\\n       dp[2] = 4;\\n       for(int i=3; i<n; i++){\\n           dp[i] = (dp[i-1] % 1000000007) + (dp[i-2] % 1000000007) + (dp[i-3] % 1000000007);\\n       }\\n       return dp[n-1] % 1000000007;\\n   }\\n   long  climbingStairs4(int n){\\n       if(n==0) return 0;\\n       if(n == 1) return 1;\\n       if(n == 2) return 2;\\n       if(n == 3) return 4;\\n       if(n == 4) return 8;\\n       long  dp[n];\\n       dp[0] = 1;\\n       dp[1] = 2;\\n       dp[2] = 4;\\n       dp[3] = 8;\\n       for(int i=4; i<n; i++){\\n           dp[i] = (dp[i-1] % 1000000007)  + (dp[i-2] % 1000000007) + (dp[i-3] % 1000000007) + (dp[i-4] % 1000000007 );\\n       }\\n       return dp[n-1] % 1000000007;\\n   }\\n    int countTexts(string pressedKeys) {\\n        if(pressedKeys.size() == 0) return 0;\\n        if(pressedKeys.size() == 1) return 1;\\n        unordered_map<char, vector<int>> m;\\n        int counter = 0;\\n        int prev = pressedKeys[0];\\n        for(int i=0; i<pressedKeys.size(); i++){\\n            while(pressedKeys[i] == prev){\\n                counter++;\\n                i++;\\n            }\\n            m[prev].push_back(counter);\\n            prev = pressedKeys[i];\\n            counter = 0;\\n            i--;\\n        }\\n        \\n        long  ans = 1;\\n\\n        for(int i=0; i<pressedKeys.size(); i++){\\n            if(m[pressedKeys[i]].size() > 0){\\n                for(int j=0; j<m[pressedKeys[i]].size(); j++){\\n                if(pressedKeys[i] == \\'9\\' || pressedKeys[i] == \\'7\\')\\n                ans = ans*climbingStairs4(m[pressedKeys[i]][j]);\\n                else\\n                 ans = ans*climbingStairs3(m[pressedKeys[i]][j]);\\n                 ans = ans%1000000007;\\n            }\\n                \\n                m.erase(pressedKeys[i]);\\n            }\\n        }\\n        /*for(int i=0; i<pressedKeys.size(); i++){\\n            if(map[pressedKeys[i]] > 0){\\n                if(pressedKeys[i] == \\'9\\' || pressedKeys[i] == \\'7\\')\\n                ans = ans*climbingStairs4(map[pressedKeys[i]]);\\n                else\\n                 ans = ans*climbingStairs3(map[pressedKeys[i]]);\\n                ans = ans%1000000007;\\n                map[pressedKeys[i]] = 0;\\n            }\\n        }*/\\n        return ans % 1000000007;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n   long  climbingStairs3(int n){\\n       if(n == 0) return 0;\\n       if(n == 1) return 1;\\n       if(n == 2) return 2;\\n       if(n == 3) return 4;\\n       long  dp[n];\\n       dp[0] = 1;\\n       dp[1] = 2;\\n       dp[2] = 4;\\n       for(int i=3; i<n; i++){\\n           dp[i] = (dp[i-1] % 1000000007) + (dp[i-2] % 1000000007) + (dp[i-3] % 1000000007);\\n       }\\n       return dp[n-1] % 1000000007;\\n   }\\n   long  climbingStairs4(int n){\\n       if(n==0) return 0;\\n       if(n == 1) return 1;\\n       if(n == 2) return 2;\\n       if(n == 3) return 4;\\n       if(n == 4) return 8;\\n       long  dp[n];\\n       dp[0] = 1;\\n       dp[1] = 2;\\n       dp[2] = 4;\\n       dp[3] = 8;\\n       for(int i=4; i<n; i++){\\n           dp[i] = (dp[i-1] % 1000000007)  + (dp[i-2] % 1000000007) + (dp[i-3] % 1000000007) + (dp[i-4] % 1000000007 );\\n       }\\n       return dp[n-1] % 1000000007;\\n   }\\n    int countTexts(string pressedKeys) {\\n        if(pressedKeys.size() == 0) return 0;\\n        if(pressedKeys.size() == 1) return 1;\\n        unordered_map<char, vector<int>> m;\\n        int counter = 0;\\n        int prev = pressedKeys[0];\\n        for(int i=0; i<pressedKeys.size(); i++){\\n            while(pressedKeys[i] == prev){\\n                counter++;\\n                i++;\\n            }\\n            m[prev].push_back(counter);\\n            prev = pressedKeys[i];\\n            counter = 0;\\n            i--;\\n        }\\n        \\n        long  ans = 1;\\n\\n        for(int i=0; i<pressedKeys.size(); i++){\\n            if(m[pressedKeys[i]].size() > 0){\\n                for(int j=0; j<m[pressedKeys[i]].size(); j++){\\n                if(pressedKeys[i] == \\'9\\' || pressedKeys[i] == \\'7\\')\\n                ans = ans*climbingStairs4(m[pressedKeys[i]][j]);\\n                else\\n                 ans = ans*climbingStairs3(m[pressedKeys[i]][j]);\\n                 ans = ans%1000000007;\\n            }\\n                \\n                m.erase(pressedKeys[i]);\\n            }\\n        }\\n        /*for(int i=0; i<pressedKeys.size(); i++){\\n            if(map[pressedKeys[i]] > 0){\\n                if(pressedKeys[i] == \\'9\\' || pressedKeys[i] == \\'7\\')\\n                ans = ans*climbingStairs4(map[pressedKeys[i]]);\\n                else\\n                 ans = ans*climbingStairs3(map[pressedKeys[i]]);\\n                ans = ans%1000000007;\\n                map[pressedKeys[i]] = 0;\\n            }\\n        }*/\\n        return ans % 1000000007;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3126727,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countTexts(string pressedKeys) {\\n        int n=pressedKeys.size();\\n        int mod=1e9+7;\\n        vector<int>dp(n+1);\\n        dp[0]=1;\\n        for (int i=1;i<=n;i++)\\n        {\\n            char ch=pressedKeys[i-1];\\n            dp[i]=dp[i-1];\\n            if (i>=2 && pressedKeys[i-2]==ch)\\n            dp[i]=(dp[i-2]+dp[i])%mod;\\n            else continue;\\n            if (i>=3 && pressedKeys[i-3]==ch)\\n            dp[i]=(dp[i]+dp[i-3])%mod;\\n            else continue;\\n            if (ch==\\'7\\' || ch==\\'9\\')\\n            {\\n                if (i>=4 && ch==pressedKeys[i-4]) dp[i]=(dp[i]+dp[i-4])%mod;\\n            }\\n        }\\n        return (dp[n])%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countTexts(string pressedKeys) {\\n        int n=pressedKeys.size();\\n        int mod=1e9+7;\\n        vector<int>dp(n+1);\\n        dp[0]=1;\\n        for (int i=1;i<=n;i++)\\n        {\\n            char ch=pressedKeys[i-1];\\n            dp[i]=dp[i-1];\\n            if (i>=2 && pressedKeys[i-2]==ch)\\n            dp[i]=(dp[i-2]+dp[i])%mod;\\n            else continue;\\n            if (i>=3 && pressedKeys[i-3]==ch)\\n            dp[i]=(dp[i]+dp[i-3])%mod;\\n            else continue;\\n            if (ch==\\'7\\' || ch==\\'9\\')\\n            {\\n                if (i>=4 && ch==pressedKeys[i-4]) dp[i]=(dp[i]+dp[i-4])%mod;\\n            }\\n        }\\n        return (dp[n])%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056386,
                "title": "python-dynamic-programming",
                "content": "\\tclass Solution(object):\\n\\t\\tdef countTexts(self, pressedKeys):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type pressedKeys: str\\n\\t\\t\\t:rtype: int\\n\\t\\t\\t\"\"\"\\n\\n\\t\\t\\tL = len(pressedKeys)\\n\\n\\t\\t\\ti, j = 0, 0\\n\\t\\t\\tCount = []\\n\\t\\t\\tMax_len = 0\\n\\t\\t\\twhile j < L and i < L:\\n\\t\\t\\t\\twhile j < L and pressedKeys[i] == pressedKeys[j]:\\n\\t\\t\\t\\t\\tj += 1\\n\\t\\t\\t\\tCount.append( [pressedKeys[i],j-i])\\n\\t\\t\\t\\tMax_len = max(Max_len, j-i)\\n\\t\\t\\t\\ti = j\\n\\n\\t\\t\\tN = Max_len\\n\\t\\t\\tf = [1 for i in range(N+1)]\\n\\t\\t\\tg = [1 for i in range(N+1)]\\n\\n\\t\\t\\tif N >=2: \\n\\t\\t\\t\\tf[2], g[2] = 2, 2 \\n\\t\\t\\tif N >= 3:\\n\\t\\t\\t\\tg[3] = 4\\n\\n\\t\\t\\tfor i in range(3, N+1):\\n\\t\\t\\t\\tf[i] =  (f[i-1] + f[i-2] + f[i-3])% (10**9 + 7)\\n\\n\\t\\t\\tfor i in range(4, N+1):\\n\\t\\t\\t\\tg[i] =  (g[i-1] + g[i-2] + g[i-3] + g[i-4]) % (10**9 + 7) \\n\\n\\n\\t\\t\\tres = 1\\n\\t\\t\\tfor x in Count:\\n\\t\\t\\t\\tif int(x[0]) == 7 or int(x[0]) == 9:\\n\\t\\t\\t\\t\\tres *= g[x[1]]\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tres *= f[x[1]]\\n\\n\\t\\t\\treturn res % (10**9 + 7)\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "\\tclass Solution(object):\\n\\t\\tdef countTexts(self, pressedKeys):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type pressedKeys: str\\n\\t\\t\\t:rtype: int\\n\\t\\t\\t\"\"\"\\n\\n\\t\\t\\tL = len(pressedKeys)\\n\\n\\t\\t\\ti, j = 0, 0\\n\\t\\t\\tCount = []\\n\\t\\t\\tMax_len = 0\\n\\t\\t\\twhile j < L and i < L:\\n\\t\\t\\t\\twhile j < L and pressedKeys[i] == pressedKeys[j]:\\n\\t\\t\\t\\t\\tj += 1\\n\\t\\t\\t\\tCount.append( [pressedKeys[i],j-i])\\n\\t\\t\\t\\tMax_len = max(Max_len, j-i)\\n\\t\\t\\t\\ti = j\\n\\n\\t\\t\\tN = Max_len\\n\\t\\t\\tf = [1 for i in range(N+1)]\\n\\t\\t\\tg = [1 for i in range(N+1)]\\n\\n\\t\\t\\tif N >=2: \\n\\t\\t\\t\\tf[2], g[2] = 2, 2 \\n\\t\\t\\tif N >= 3:\\n\\t\\t\\t\\tg[3] = 4\\n\\n\\t\\t\\tfor i in range(3, N+1):\\n\\t\\t\\t\\tf[i] =  (f[i-1] + f[i-2] + f[i-3])% (10**9 + 7)\\n\\n\\t\\t\\tfor i in range(4, N+1):\\n\\t\\t\\t\\tg[i] =  (g[i-1] + g[i-2] + g[i-3] + g[i-4]) % (10**9 + 7) \\n\\n\\n\\t\\t\\tres = 1\\n\\t\\t\\tfor x in Count:\\n\\t\\t\\t\\tif int(x[0]) == 7 or int(x[0]) == 9:\\n\\t\\t\\t\\t\\tres *= g[x[1]]\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tres *= f[x[1]]\\n\\n\\t\\t\\treturn res % (10**9 + 7)\\n",
                "codeTag": "Java"
            },
            {
                "id": 3054007,
                "title": "c",
                "content": "```\\nint countTexts(char * pressedKeys){\\n    int mod = 1e9 + 7 ;\\n    int n = strlen(pressedKeys) ;\\n    long long * dp = malloc((n+1) * sizeof(long long)) ;\\n    dp[n] = 1;\\n    bool* hash = calloc(100000, sizeof(bool)) ;\\n    int trip[] = {2, 3, 4, 5, 6, 8};\\n    int four[] = {7, 9} ;\\n    for(int i = 0; i < 6; i++){\\n        int d = trip[i] ;\\n        int val = 0;\\n        for(int j = 0; j < 3; j++){\\n            val = val * 10 + d;\\n            hash[val] = true ;\\n        }\\n    }\\n    \\n    for(int i = 0; i < 2; i++){\\n        int d = four[i] ;\\n        int val = 0;\\n        for(int j = 0; j < 4; j++){\\n            val = val * 10 + d;\\n            hash[val] = true ;\\n        }\\n    }\\n\\n    dp[n] = 1;\\n    dp[n-1] = 1;\\n    pressedKeys[n] = \\'0\\' ;\\n    for(int i = n-2 ; i >= 0 ; i--){\\n        int val = pressedKeys[i] - \\'0\\' ;\\n        dp[i] = 0;\\n        int k = 1 ;\\n        while( hash[val] ){\\n            dp[i] = (dp[i] + dp[i+k]) % mod;\\n            val = val* 10 + pressedKeys[i+k] - \\'0\\' ;\\n            k++;  \\n        }\\n    }\\n    pressedKeys[n] = \\'\\\\0\\' ;  //rollback\\n    int ans =  dp[0];\\n    free(hash) ;\\n    free(dp) ;\\n    return ans;\\n }\\n```",
                "solutionTags": [],
                "code": "```\\nint countTexts(char * pressedKeys){\\n    int mod = 1e9 + 7 ;\\n    int n = strlen(pressedKeys) ;\\n    long long * dp = malloc((n+1) * sizeof(long long)) ;\\n    dp[n] = 1;\\n    bool* hash = calloc(100000, sizeof(bool)) ;\\n    int trip[] = {2, 3, 4, 5, 6, 8};\\n    int four[] = {7, 9} ;\\n    for(int i = 0; i < 6; i++){\\n        int d = trip[i] ;\\n        int val = 0;\\n        for(int j = 0; j < 3; j++){\\n            val = val * 10 + d;\\n            hash[val] = true ;\\n        }\\n    }\\n    \\n    for(int i = 0; i < 2; i++){\\n        int d = four[i] ;\\n        int val = 0;\\n        for(int j = 0; j < 4; j++){\\n            val = val * 10 + d;\\n            hash[val] = true ;\\n        }\\n    }\\n\\n    dp[n] = 1;\\n    dp[n-1] = 1;\\n    pressedKeys[n] = \\'0\\' ;\\n    for(int i = n-2 ; i >= 0 ; i--){\\n        int val = pressedKeys[i] - \\'0\\' ;\\n        dp[i] = 0;\\n        int k = 1 ;\\n        while( hash[val] ){\\n            dp[i] = (dp[i] + dp[i+k]) % mod;\\n            val = val* 10 + pressedKeys[i+k] - \\'0\\' ;\\n            k++;  \\n        }\\n    }\\n    pressedKeys[n] = \\'\\\\0\\' ;  //rollback\\n    int ans =  dp[0];\\n    free(hash) ;\\n    free(dp) ;\\n    return ans;\\n }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2974724,
                "title": "python3-java-top-down-dp",
                "content": "Intuition is we can combine upto limit character together where limit is 4 for digit -> (7,9) and 3 for other digits and check for each combination , if string is 222, then you possible combination will be \\n(2,2,2) -> a,a,a\\n(2,22)  -> a,b\\n(22,2)  -> b,a\\n(222)  ->  c\\n```\\nPython3\\n\\nclass Solution:\\n    def countTexts(self, A: str) -> int:\\n        mod = 1_00_00_00_007\\n        n = len(A)\\n        dp = [-1 for i in range(n)]\\n        def dfs(ind):\\n            if ind == n:\\n                return 1\\n            if dp[ind] != -1:\\n                return dp[ind]\\n            limit = 4 if A[ind] == \\'7\\' or A[ind] == \\'9\\' else 3\\n            val = 0\\n            for i in range(1,limit + 1):\\n                if ind + i <= n and A[ind + i - 1] == A[ind]:\\n                    val = val % mod + dfs(ind + i) % mod\\n                else:\\n                    break\\n            dp[ind] = val\\n            return dp[ind]\\n        return dfs(0) % mod\\n```\\n```\\nJava\\n\\nclass Solution {\\n    int dfs(int ind,int n,int[] dp,char[] A,int mod){\\n        if (ind == n){\\n            return 1;\\n        }\\n        if(dp[ind] != -1){\\n            return dp[ind];\\n        }\\n        int limit = A[ind] == \\'7\\' || A[ind] ==\\'9\\' ? 4 : 3;\\n        int val = 0;\\n        for(int i = 1 ; i <= limit ; i++){\\n            if(ind + i <= n && A[ind + i - 1] == A[ind]){\\n                val = val % mod + dfs(ind + i,n,dp,A,mod) % mod;\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        return dp[ind] = val;\\n    }\\n    public int countTexts(String A) {\\n        char[] arr = A.toCharArray();\\n        int n = arr.length;\\n        int[] dp = new int[n];\\n        Arrays.fill(dp,-1);\\n        int mod = 1_00_00_00_007;\\n        return dfs(0,n,dp,arr,mod) % mod;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nPython3\\n\\nclass Solution:\\n    def countTexts(self, A: str) -> int:\\n        mod = 1_00_00_00_007\\n        n = len(A)\\n        dp = [-1 for i in range(n)]\\n        def dfs(ind):\\n            if ind == n:\\n                return 1\\n            if dp[ind] != -1:\\n                return dp[ind]\\n            limit = 4 if A[ind] == \\'7\\' or A[ind] == \\'9\\' else 3\\n            val = 0\\n            for i in range(1,limit + 1):\\n                if ind + i <= n and A[ind + i - 1] == A[ind]:\\n                    val = val % mod + dfs(ind + i) % mod\\n                else:\\n                    break\\n            dp[ind] = val\\n            return dp[ind]\\n        return dfs(0) % mod\\n```\n```\\nJava\\n\\nclass Solution {\\n    int dfs(int ind,int n,int[] dp,char[] A,int mod){\\n        if (ind == n){\\n            return 1;\\n        }\\n        if(dp[ind] != -1){\\n            return dp[ind];\\n        }\\n        int limit = A[ind] == \\'7\\' || A[ind] ==\\'9\\' ? 4 : 3;\\n        int val = 0;\\n        for(int i = 1 ; i <= limit ; i++){\\n            if(ind + i <= n && A[ind + i - 1] == A[ind]){\\n                val = val % mod + dfs(ind + i,n,dp,A,mod) % mod;\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        return dp[ind] = val;\\n    }\\n    public int countTexts(String A) {\\n        char[] arr = A.toCharArray();\\n        int n = arr.length;\\n        int[] dp = new int[n];\\n        Arrays.fill(dp,-1);\\n        int mod = 1_00_00_00_007;\\n        return dfs(0,n,dp,arr,mod) % mod;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2912092,
                "title": "java-dynamic-programming-top-down-dp-recursion-memization-faster",
                "content": "```\\nclass Solution {\\n\\n    int MOD = 1000000007;\\n    String key;\\n    Integer[] dp;\\n    int[] count;\\n\\t\\n    private int solve(int i) {\\n\\t\\n        if(i >= key.length())\\n            return 1;\\n        \\n        if(dp[i] != null) \\n            return dp[i];\\n       \\n        char first = key.charAt(i);\\n        int res = 0, cnt = 1, mxCnt = count[first - \\'0\\'], j = i;\\n        \\n        while(i < key.length() && key.charAt(i) == first && cnt <= mxCnt) {\\n            res = (((res%MOD) + (solve(i+1)%MOD)) % MOD);\\n            i++; cnt++;\\n        }\\n\\t\\t\\n        return dp[j] = res;\\n    }\\n\\t\\n    public int countTexts(String pressedKeys) {\\n\\t\\n        this.key = pressedKeys;\\n        this.count = new int[]{0,0,3,3,3,3,3,4,3,4};\\n        this.dp = new Integer[pressedKeys.length()+1];\\n        return solve(0);\\n\\t\\t\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n\\n    int MOD = 1000000007;\\n    String key;\\n    Integer[] dp;\\n    int[] count;\\n\\t\\n    private int solve(int i) {\\n\\t\\n        if(i >= key.length())\\n            return 1;\\n        \\n        if(dp[i] != null) \\n            return dp[i];\\n       \\n        char first = key.charAt(i);\\n        int res = 0, cnt = 1, mxCnt = count[first - \\'0\\'], j = i;\\n        \\n        while(i < key.length() && key.charAt(i) == first && cnt <= mxCnt) {\\n            res = (((res%MOD) + (solve(i+1)%MOD)) % MOD);\\n            i++; cnt++;\\n        }\\n\\t\\t\\n        return dp[j] = res;\\n    }\\n\\t\\n    public int countTexts(String pressedKeys) {\\n\\t\\n        this.key = pressedKeys;\\n        this.count = new int[]{0,0,3,3,3,3,3,4,3,4};\\n        this.dp = new Integer[pressedKeys.length()+1];\\n        return solve(0);\\n\\t\\t\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2877811,
                "title": "easy-and-clean-2-approaches-from-recursion-to-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int mod = (int)(Math.pow(10,9)+7);\\n    public int countTexts(String pressedKeys) {\\n        //Way 1 Recursion\\n        int [] dp = new int[pressedKeys.length()];\\n        Arrays.fill(dp, -1);\\n        return GetCT(pressedKeys, 0, dp);\\n        //Way 2\\n        int [] dp = new int[pressedKeys.length()+1];\\n        dp[0] = 1;\\n        for(int i = 1; i <= pressedKeys.length();i++)\\n        {\\n            dp[i] = dp[i-1] % mod;\\n            if(i > 1 && pressedKeys.charAt(i-1) == pressedKeys.charAt(i-2))\\n            {\\n                dp[i] = (dp[i] + dp[i-2] % mod)%mod;\\n                if(i > 2 && pressedKeys.charAt(i-1) == pressedKeys.charAt(i-3))\\n                {\\n                    dp[i] = (dp[i] + dp[i-3] % mod)%mod;\\n                    if(i > 3  && (pressedKeys.charAt(i-1) == \\'7\\' \\n                     || pressedKeys.charAt(i-1) == \\'9\\') \\n                    && pressedKeys.charAt(i-1) == pressedKeys.charAt(i-4))\\n                        dp[i] = (dp[i] + dp[i-4] % mod)%mod;\\n                }\\n            }\\n        }\\n        return dp[pressedKeys.length()];\\n    }\\n\\n    public int GetCT(String s, int idx, int [] dp)\\n    {\\n        if(idx == s.length())\\n        return 1;\\n\\n        if(dp[idx] != -1)\\n        return dp[idx];\\n\\n        int maxPKeys = (s.charAt(idx) == \\'7\\' || s.charAt(idx) == \\'9\\') ? 4 : 3;\\n        int ans = 0;\\n        int pressedKey = 1;\\n        int curIdx = idx;\\n        while(curIdx < s.length() && pressedKey <= maxPKeys && \\n        s.charAt(curIdx) == s.charAt(idx))\\n        {\\n            curIdx++;\\n            pressedKey++;\\n            ans = (ans + GetCT(s, curIdx, dp)%mod)%mod;\\n        }\\n        return dp[idx] = ans%mod;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int mod = (int)(Math.pow(10,9)+7);\\n    public int countTexts(String pressedKeys) {\\n        //Way 1 Recursion\\n        int [] dp = new int[pressedKeys.length()];\\n        Arrays.fill(dp, -1);\\n        return GetCT(pressedKeys, 0, dp);\\n        //Way 2\\n        int [] dp = new int[pressedKeys.length()+1];\\n        dp[0] = 1;\\n        for(int i = 1; i <= pressedKeys.length();i++)\\n        {\\n            dp[i] = dp[i-1] % mod;\\n            if(i > 1 && pressedKeys.charAt(i-1) == pressedKeys.charAt(i-2))\\n            {\\n                dp[i] = (dp[i] + dp[i-2] % mod)%mod;\\n                if(i > 2 && pressedKeys.charAt(i-1) == pressedKeys.charAt(i-3))\\n                {\\n                    dp[i] = (dp[i] + dp[i-3] % mod)%mod;\\n                    if(i > 3  && (pressedKeys.charAt(i-1) == \\'7\\' \\n                     || pressedKeys.charAt(i-1) == \\'9\\') \\n                    && pressedKeys.charAt(i-1) == pressedKeys.charAt(i-4))\\n                        dp[i] = (dp[i] + dp[i-4] % mod)%mod;\\n                }\\n            }\\n        }\\n        return dp[pressedKeys.length()];\\n    }\\n\\n    public int GetCT(String s, int idx, int [] dp)\\n    {\\n        if(idx == s.length())\\n        return 1;\\n\\n        if(dp[idx] != -1)\\n        return dp[idx];\\n\\n        int maxPKeys = (s.charAt(idx) == \\'7\\' || s.charAt(idx) == \\'9\\') ? 4 : 3;\\n        int ans = 0;\\n        int pressedKey = 1;\\n        int curIdx = idx;\\n        while(curIdx < s.length() && pressedKey <= maxPKeys && \\n        s.charAt(curIdx) == s.charAt(idx))\\n        {\\n            curIdx++;\\n            pressedKey++;\\n            ans = (ans + GetCT(s, curIdx, dp)%mod)%mod;\\n        }\\n        return dp[idx] = ans%mod;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2877317,
                "title": "easy-python-recursion-memoization-top-down-approach",
                "content": "**leetcode 2266 : Count Number of Texts\\nEasy Understanding\\nDp Recursion with Memoization\\nTop down Approach**\\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        dic = {\\n            \\'2\\': \\'abc\\',\\n            \\'3\\': \\'def\\',\\n            \\'4\\': \\'gfi\\',\\n            \\'5\\': \\'jkl\\',\\n            \\'6\\': \\'mno\\',\\n            \\'7\\': \\'pqrs\\',\\n            \\'8\\': \\'tuv\\',\\n            \\'9\\': \\'wxyz\\',\\n        }\\n        s = pressedKeys\\n        mod = (10**9)+7\\n        \\n        def f(i):\\n            if i == len(s):\\n                return 1\\n            ## optimization \\n            ## if i already found in dp \\n            ## then return dp[i] \\n            if i in dp:\\n                return dp[i]\\n            total = 0\\n            ## current index in s is i \\n            ## so current digit is s[i]\\n            ## letters of that digit is dic[s[i]]\\n\\n            for j in range(len(dic[s[i]])):\\n                k = i + j + 1\\n                ## k is the position where next iteration will be called\\n                ## k must be next position of i, k==i+1\\n                if k > len(s) or s[k-1] != s[i] :\\n                    break\\n                ## optimization \\n                if k in dp:\\n                    total += dp[k]\\n                else:\\n                    total += f(k)\\n            ## keep a copy of the result of i in dp\\n            dp[i] = total % mod\\n            return dp[i]\\n        dp = {}\\n        return f(0)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        dic = {\\n            \\'2\\': \\'abc\\',\\n            \\'3\\': \\'def\\',\\n            \\'4\\': \\'gfi\\',\\n            \\'5\\': \\'jkl\\',\\n            \\'6\\': \\'mno\\',\\n            \\'7\\': \\'pqrs\\',\\n            \\'8\\': \\'tuv\\',\\n            \\'9\\': \\'wxyz\\',\\n        }\\n        s = pressedKeys\\n        mod = (10**9)+7\\n        \\n        def f(i):\\n            if i == len(s):\\n                return 1\\n            ## optimization \\n            ## if i already found in dp \\n            ## then return dp[i] \\n            if i in dp:\\n                return dp[i]\\n            total = 0\\n            ## current index in s is i \\n            ## so current digit is s[i]\\n            ## letters of that digit is dic[s[i]]\\n\\n            for j in range(len(dic[s[i]])):\\n                k = i + j + 1\\n                ## k is the position where next iteration will be called\\n                ## k must be next position of i, k==i+1\\n                if k > len(s) or s[k-1] != s[i] :\\n                    break\\n                ## optimization \\n                if k in dp:\\n                    total += dp[k]\\n                else:\\n                    total += f(k)\\n            ## keep a copy of the result of i in dp\\n            dp[i] = total % mod\\n            return dp[i]\\n        dp = {}\\n        return f(0)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2869579,
                "title": "c-dp-memoization-recursion-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    int mod=1e9+7;\\n    long solve(string &s,int idx)\\n    {\\n        if(idx>=s.size())\\n            return 1;\\n        if(dp[idx]!=-1)\\n            return dp[idx];\\n        int maxpress=(s[idx]==\\'7\\'||s[idx]==\\'9\\')?4:3;\\n        int curr_idx=idx,press=1;\\n        long ans=0;\\n        while(press<=maxpress&&s[curr_idx]==s[idx])\\n        {\\n            press++;\\n            curr_idx++;\\n            ans+=(solve(s,curr_idx))%mod;\\n        }\\n        return dp[idx]=ans%mod;\\n    }\\n    int countTexts(string pressedKeys) \\n    {\\n        int n=pressedKeys.size();\\n        dp.resize(n+1,-1);\\n        return solve(pressedKeys,0);\\n        \\n        \\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> dp;\\n    int mod=1e9+7;\\n    long solve(string &s,int idx)\\n    {\\n        if(idx>=s.size())\\n            return 1;\\n        if(dp[idx]!=-1)\\n            return dp[idx];\\n        int maxpress=(s[idx]==\\'7\\'||s[idx]==\\'9\\')?4:3;\\n        int curr_idx=idx,press=1;\\n        long ans=0;\\n        while(press<=maxpress&&s[curr_idx]==s[idx])\\n        {\\n            press++;\\n            curr_idx++;\\n            ans+=(solve(s,curr_idx))%mod;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2841733,
                "title": "python3-dp",
                "content": "class Solution:\\n\\n    def countTexts(self, pressedKeys: str) -> int:\\n        N = len(pressedKeys) + 1\\n        MOD = 10**9+7\\n        dp = [0]*N\\n        dp[0] = 1\\n    \\n        for i in range(1,N):\\n            currChar = pressedKeys[i-1]\\n            dp[i] = dp[i-1]\\n            if i>=2 and currChar ==  pressedKeys[i-2]:\\n                dp[i] = (dp[i]+dp[i-2])%MOD\\n            else:\\n                continue\\n            if i>=3 and currChar ==  pressedKeys[i-3]:\\n                dp[i] = (dp[i]+dp[i-3])%MOD\\n            else:\\n                continue\\n            \\n            if i>=4 and currChar in \"79\" and currChar ==  pressedKeys[i-4]:\\n                dp[i] = (dp[i]+dp[i-4])%MOD\\n                \\n        return dp[-1]",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def countTexts(self, pressedKeys: str) -> int:\\n        N = len(pressedKeys) + 1\\n        MOD = 10**9+7\\n        dp = [0]*N\\n        dp[0] = 1\\n    \\n        for i in range(1,N):\\n            currChar = pressedKeys[i-1]\\n            dp[i] = dp[i-1]\\n            if i>=2 and currChar ==  pressedKeys[i-2]:\\n                dp[i] = (dp[i]+dp[i-2])%MOD\\n            else:\\n                continue\\n            if i>=3 and currChar ==  pressedKeys[i-3]:\\n                dp[i] = (dp[i]+dp[i-3])%MOD\\n            else:\\n                continue\\n            \\n            if i>=4 and currChar in \"79\" and currChar ==  pressedKeys[i-4]:\\n                dp[i] = (dp[i]+dp[i-4])%MOD\\n                \\n        return dp[-1]",
                "codeTag": "Java"
            },
            {
                "id": 2840945,
                "title": "python-cached-recursive-dp-approach",
                "content": "```python\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        \\n        # dp(n, lmt): possibilities pressing a number of lmt charaters n times\\n        @cache\\n        def dp(n, lmt):\\n            if n == 0:\\n                return 1\\n            ans = 0\\n            for i in range(max(0, n - lmt), n):\\n                ans += dp(i, lmt)\\n            return ans % int(1e9 + 7)\\n        \\n        i, j = 0, 0\\n        s = pressedKeys + \"-\"\\n        ans = 1\\n        while j < len(s) - 1:\\n            j += 1\\n            if s[j] != s[i]:\\n                ans *= dp(j - i, 4 if s[i] == \\'7\\' or s[i] == \\'9\\' else 3)\\n                ans %= int(1e9 + 7)\\n                i = j\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```python\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        \\n        # dp(n, lmt): possibilities pressing a number of lmt charaters n times\\n        @cache\\n        def dp(n, lmt):\\n            if n == 0:\\n                return 1\\n            ans = 0\\n            for i in range(max(0, n - lmt), n):\\n                ans += dp(i, lmt)\\n            return ans % int(1e9 + 7)\\n        \\n        i, j = 0, 0\\n        s = pressedKeys + \"-\"\\n        ans = 1\\n        while j < len(s) - 1:\\n            j += 1\\n            if s[j] != s[i]:\\n                ans *= dp(j - i, 4 if s[i] == \\'7\\' or s[i] == \\'9\\' else 3)\\n                ans %= int(1e9 + 7)\\n                i = j\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831929,
                "title": "java-top-down-dp-memoization",
                "content": "class Solution {\\n\\n    int res=0;\\n    int mod = 1000000007;\\n    Map<Integer,Integer> mp=new HashMap<Integer,Integer>();\\n    Map<Integer,Integer> cache=new HashMap<Integer,Integer>();\\n    \\n    public int recur(String keys,int index){\\n        if(index==keys.length()){\\n            return 1;\\n        }\\n        if(cache.containsKey(index)){\\n            return cache.get(index);\\n        }\\n        char x = keys.charAt(index);\\n        int mappingSize = mp.get(x-\\'0\\');\\n        int i=index;\\n        int sum=0;\\n        while(i<keys.length() && keys.charAt(i)==x && i-index<mappingSize){\\n            int count=0;\\n            count=recur(keys,i+1);\\n            sum=(sum+count)%mod;\\n            i++;\\n        }\\n        \\n        cache.put(index,sum);\\n        return sum;\\n        \\n    }\\n    public int countTexts(String pressedKeys) {\\n        mp.put(2,3);\\n        mp.put(3,3);\\n        mp.put(4,3);\\n        mp.put(5,3);\\n        mp.put(6,3);\\n        mp.put(7,4);\\n        mp.put(8,3);\\n        mp.put(9,4);\\n        return recur(pressedKeys,0);  \\n    }\\n}",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "class Solution {\\n\\n    int res=0;\\n    int mod = 1000000007;\\n    Map<Integer,Integer> mp=new HashMap<Integer,Integer>();\\n    Map<Integer,Integer> cache=new HashMap<Integer,Integer>();\\n    \\n    public int recur(String keys,int index){\\n        if(index==keys.length()){\\n            return 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2828735,
                "title": "video-walkthrough-python-easy-five-line-solution",
                "content": "[Click Here For Video Walkthrough](https://youtu.be/n82BgEqSCkg)\\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        count, char,lastFour = 0, -1, [1,1,1,1]\\n        for key in pressedKeys:\\n            count, char =  min(count * int(char == key) + 1, 3 + int(char==\\'7\\' or char==\\'9\\')), key\\n            lastFour = [sum(lastFour[:count]) % (10 ** 9 + 7)] + lastFour[:-1]\\n        return lastFour[0] % (10 ** 9 + 7)\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        count, char,lastFour = 0, -1, [1,1,1,1]\\n        for key in pressedKeys:\\n            count, char =  min(count * int(char == key) + 1, 3 + int(char==\\'7\\' or char==\\'9\\')), key\\n            lastFour = [sum(lastFour[:count]) % (10 ** 9 + 7)] + lastFour[:-1]\\n        return lastFour[0] % (10 ** 9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2827628,
                "title": "simple-easy-to-understand-solution-c-hashing-dp-o-n-o-n",
                "content": "\\'\\'\\'\\n unordered_map< int , int >mp1 , mp2 ;\\n    \\n   int solve( pair< int  , char  >p )\\n    {\\n           int a = p.first ;\\n           char b = p.second ;\\n       \\n           int mod = pow( 10 , 9 ) + 7 ;\\n       \\n           int arr[a+1] ;\\n       \\n       \\n          if( b == \\'7\\' || b == \\'9\\' )\\n          {\\n              if( mp1.find(a) != mp1.end() )  return mp1[a] ;\\n              \\n              if( a  <= 2  )  return a ;\\n              if( a == 3 )  return 4 ;\\n              if( a == 4 )  return 8 ;\\n              \\n              arr[1] = 1 ;\\n              arr[2] = 2 ;\\n              arr[3] = 4 ;\\n              arr[4] = 8 ;\\n              \\n              for( int i = 5 ; i <= a ; i++ )\\n              {\\n                  arr[i] = ( (arr[i-1] + arr[i-2])%mod  + (arr[i-3] + arr[i-4] )%mod )%mod ;\\n              }\\n              \\n              mp1[a] = arr[a] ;\\n              \\n          }\\n          else{\\n              \\n             if( mp2.find(a) != mp2.end() )  return mp2[a] ;\\n              \\n              if( a  <= 2  )  return a ;\\n              if( a == 3 )  return 4 ;\\n             \\n              \\n              arr[1] = 1 ;\\n              arr[2] = 2 ;\\n              arr[3] = 4 ;\\n             \\n              \\n              for( int i = 4 ; i <= a ; i++ )\\n              {\\n                  arr[i] = ( (arr[i-1] + arr[i-2])%mod  +  arr[i-3] )%mod ;\\n              }\\n              \\n              mp2[a] = arr[a] ; \\n          }\\n       \\n          return arr[a] ;\\n    }\\n    int countTexts(string pk ) {\\n        \\n         if( pk == \"\")\\n        {\\n            return 0 ;\\n        }\\n        \\n        \\n        vector< pair<int , char >>mp ;\\n       \\n        string temp = \"\" ;\\n        \\n        int n = pk.size()  ;\\n        \\n            temp += pk[0] ;\\n                \\n            \\n        \\n        for( int i = 1 ; i < n ; i++ )\\n        {\\n            \\n            \\n            if( pk[i] == pk[i-1] )\\n            {\\n                temp += pk[i] ;\\n            }\\n            else{\\n                \\n                mp.push_back({ temp.size() , temp[0] }) ;\\n                // cout<<temp.size()<<\" \"<<temp[0]<<endl ;\\n                temp = pk[i] ;\\n            }\\n        }\\n        \\n        if( !temp.empty())\\n        {\\n            mp.push_back({ temp.size() , temp[0] }) ;\\n        }\\n        \\n        long long int ans = 1 ;\\n        \\n        int mod = pow( 10 , 9 ) + 7 ;\\n        \\n        for( int i = 0 ; i < mp.size() ; i++ )\\n        {\\n            ans = (ans*solve(mp[i]))%mod ;\\n        }\\n        \\n        return ans%mod ;\\n    }\\n\\t\\'\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n unordered_map< int , int >mp1 , mp2 ;\\n    \\n   int solve( pair< int  , char  >p )\\n    {\\n           int a = p.first ;\\n           char b = p.second ;\\n       \\n           int mod = pow( 10 , 9 ) + 7 ;\\n       \\n           int arr[a+1] ;\\n       \\n       \\n          if( b == \\'7\\' || b == \\'9\\' )\\n          {\\n              if( mp1.find(a) != mp1.end() )  return mp1[a] ;\\n              \\n              if( a  <= 2  )  return a ;\\n              if( a == 3 )  return 4 ;\\n              if( a == 4 )  return 8 ;\\n              \\n              arr[1] = 1 ;\\n              arr[2] = 2 ;\\n              arr[3] = 4 ;\\n              arr[4] = 8 ;\\n              \\n              for( int i = 5 ; i <= a ; i++ )\\n              {\\n                  arr[i] = ( (arr[i-1] + arr[i-2])%mod  + (arr[i-3] + arr[i-4] )%mod )%mod ;\\n              }\\n              \\n              mp1[a] = arr[a] ;\\n              \\n          }\\n          else{\\n              \\n             if( mp2.find(a) != mp2.end() )  return mp2[a] ;\\n              \\n              if( a  <= 2  )  return a ;\\n              if( a == 3 )  return 4 ;\\n             \\n              \\n              arr[1] = 1 ;\\n              arr[2] = 2 ;\\n              arr[3] = 4 ;\\n             \\n              \\n              for( int i = 4 ; i <= a ; i++ )\\n              {\\n                  arr[i] = ( (arr[i-1] + arr[i-2])%mod  +  arr[i-3] )%mod ;\\n              }\\n              \\n              mp2[a] = arr[a] ; \\n          }\\n       \\n          return arr[a] ;\\n    }\\n    int countTexts(string pk ) {\\n        \\n         if( pk == \"\")\\n        {\\n            return 0 ;\\n        }\\n        \\n        \\n        vector< pair<int , char >>mp ;\\n       \\n        string temp = \"\" ;\\n        \\n        int n = pk.size()  ;\\n        \\n            temp += pk[0] ;\\n                \\n            \\n        \\n        for( int i = 1 ; i < n ; i++ )\\n        {\\n            \\n            \\n            if( pk[i] == pk[i-1] )\\n            {\\n                temp += pk[i] ;\\n            }\\n            else{\\n                \\n                mp.push_back({ temp.size() , temp[0] }) ;\\n                // cout<<temp.size()<<\" \"<<temp[0]<<endl ;\\n                temp = pk[i] ;\\n            }\\n        }\\n        \\n        if( !temp.empty())\\n        {\\n            mp.push_back({ temp.size() , temp[0] }) ;\\n        }\\n        \\n        long long int ans = 1 ;\\n        \\n        int mod = pow( 10 , 9 ) + 7 ;\\n        \\n        for( int i = 0 ; i < mp.size() ; i++ )\\n        {\\n            ans = (ans*solve(mp[i]))%mod ;\\n        }\\n        \\n        return ans%mod ;\\n    }\\n\\t\\'\\'\\'\\'",
                "codeTag": "C++"
            },
            {
                "id": 2819325,
                "title": "faster-than-97-96-solution-without-dp",
                "content": "```\\n    int modNum = 1e9 + 7;\\n\\n\\tint countTexts(string pressedKeys)\\n\\t{\\n\\t\\tlong long sum = 1;\\n\\t\\tint lenSame = 1;\\n\\t\\tfor (int i = 1; i < pressedKeys.length(); i++)\\n\\t\\t{\\n\\t\\t\\tif (pressedKeys[i] == pressedKeys[i - 1])\\n\\t\\t\\t{\\n\\t\\t\\t\\tlenSame++;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tsum *= multiThem(pressedKeys[i - 1], lenSame) ;\\n\\t\\t\\t\\tsum %= modNum;\\n\\t\\t\\t\\tlenSame = 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tsum *= multiThem(pressedKeys[pressedKeys.length() - 1], lenSame);\\n\\t\\tsum %= modNum;\\n\\t\\treturn sum;\\n\\t}\\n\\n\\tint multiThem(char key, int len)\\n\\t{\\n\\t\\tint sum = 1;\\n\\t\\tif (len == 2)\\n\\t\\t\\tsum *= 2;\\n\\t\\telse if (len == 3)\\n\\t\\t\\tsum *= 4;\\n\\t\\telse if (len > 3)\\n\\t\\t\\tsum *= sumPossiblity(key, len);\\n\\n\\t\\treturn sum;\\n\\t}\\n\\n\\tint sumPossiblity(char key, int len)\\n\\t{\\n\\t\\tint *index = new int[len + 1];\\n\\t\\tindex[0] = 1;\\n\\t\\tindex[1] = 1;\\n\\t\\tindex[2] = 2;\\n\\t\\tindex[3] = 4;\\n\\t\\tfor (int i = 4; i <= len; i++)\\n\\t\\t{\\n\\t\\t\\tlong long x = index[i - 1];\\n\\t\\t\\tx += index[i - 2];\\n\\t\\t\\tx += index[i - 3];\\n\\t\\t\\t\\n\\t\\t\\tif (key == \\'7\\' || key == \\'9\\')\\n\\t\\t\\t{\\n\\t\\t\\t\\tx += index[i - 4];\\n\\t\\t\\t}\\n\\t\\t\\tx %= modNum;\\n\\t\\t\\tindex[i] = x;\\n\\t\\t}\\n\\n\\t\\tint sum = index[len];\\n\\t\\tdelete[] index;\\n\\t\\treturn sum;\\n\\t}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int modNum = 1e9 + 7;\\n\\n\\tint countTexts(string pressedKeys)\\n\\t{\\n\\t\\tlong long sum = 1;\\n\\t\\tint lenSame = 1;\\n\\t\\tfor (int i = 1; i < pressedKeys.length(); i++)\\n\\t\\t{\\n\\t\\t\\tif (pressedKeys[i] == pressedKeys[i - 1])\\n\\t\\t\\t{\\n\\t\\t\\t\\tlenSame++;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tsum *= multiThem(pressedKeys[i - 1], lenSame) ;\\n\\t\\t\\t\\tsum %= modNum;\\n\\t\\t\\t\\tlenSame = 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tsum *= multiThem(pressedKeys[pressedKeys.length() - 1], lenSame);\\n\\t\\tsum %= modNum;\\n\\t\\treturn sum;\\n\\t}\\n\\n\\tint multiThem(char key, int len)\\n\\t{\\n\\t\\tint sum = 1;\\n\\t\\tif (len == 2)\\n\\t\\t\\tsum *= 2;\\n\\t\\telse if (len == 3)\\n\\t\\t\\tsum *= 4;\\n\\t\\telse if (len > 3)\\n\\t\\t\\tsum *= sumPossiblity(key, len);\\n\\n\\t\\treturn sum;\\n\\t}\\n\\n\\tint sumPossiblity(char key, int len)\\n\\t{\\n\\t\\tint *index = new int[len + 1];\\n\\t\\tindex[0] = 1;\\n\\t\\tindex[1] = 1;\\n\\t\\tindex[2] = 2;\\n\\t\\tindex[3] = 4;\\n\\t\\tfor (int i = 4; i <= len; i++)\\n\\t\\t{\\n\\t\\t\\tlong long x = index[i - 1];\\n\\t\\t\\tx += index[i - 2];\\n\\t\\t\\tx += index[i - 3];\\n\\t\\t\\t\\n\\t\\t\\tif (key == \\'7\\' || key == \\'9\\')\\n\\t\\t\\t{\\n\\t\\t\\t\\tx += index[i - 4];\\n\\t\\t\\t}\\n\\t\\t\\tx %= modNum;\\n\\t\\t\\tindex[i] = x;\\n\\t\\t}\\n\\n\\t\\tint sum = index[len];\\n\\t\\tdelete[] index;\\n\\t\\treturn sum;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2797745,
                "title": "python-simple-dynamic-programming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countTexts(self, pressedKeys):\\n        n = len(pressedKeys)\\n\\n        dp = [0]*(n+1)\\n\\n        dp[0], dp[1] = 1, 1\\n\\n        for i in range(2,n+1):\\n            dp[i] += dp[i-1]\\n\\n            if i > 1 and pressedKeys[i-1] == pressedKeys[i-2]:\\n                dp[i] += dp[i-2]\\n\\n            if i > 2 and pressedKeys[i-1] == pressedKeys[i-2] == pressedKeys[i-3]:\\n                dp[i] += dp[i-3]\\n\\n            if pressedKeys[i-1] == \"7\" or pressedKeys[i-1] == \"9\":\\n                if i > 3 and pressedKeys[i-1] == pressedKeys[i-2] == pressedKeys[i-3] == pressedKeys[i-4]:\\n                    dp[i] += dp[i-4]\\n\\n        return dp[-1]%(10**9+7)\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys):\\n        n = len(pressedKeys)\\n\\n        dp = [0]*(n+1)\\n\\n        dp[0], dp[1] = 1, 1\\n\\n        for i in range(2,n+1):\\n            dp[i] += dp[i-1]\\n\\n            if i > 1 and pressedKeys[i-1] == pressedKeys[i-2]:\\n                dp[i] += dp[i-2]\\n\\n            if i > 2 and pressedKeys[i-1] == pressedKeys[i-2] == pressedKeys[i-3]:\\n                dp[i] += dp[i-3]\\n\\n            if pressedKeys[i-1] == \"7\" or pressedKeys[i-1] == \"9\":\\n                if i > 3 and pressedKeys[i-1] == pressedKeys[i-2] == pressedKeys[i-3] == pressedKeys[i-4]:\\n                    dp[i] += dp[i-4]\\n\\n        return dp[-1]%(10**9+7)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792224,
                "title": "java-easy-to-understand-code",
                "content": "```\\nchar[] arr;\\nint brr[], dp[], mod = 1_000_000_007;\\n\\npublic int countTexts(String pressedKeys){\\n\\tarr = pressedKeys.toCharArray();\\n\\tdp = new int[arr.length + 1];\\n\\tbrr = new int[] { 0, 0, 3, 3, 3, 3, 3, 4, 3, 4 };\\n\\tdp[0] = 1;\\n\\tfor(int i = 1; i <= arr.length; i++){\\n\\n\\t\\tint freq = brr[arr[i - 1] - \\'0\\'], count = 0;\\n\\t\\tfor (int j = 0; i - j - 1 >= 0 && j < freq && arr[i - 1] == arr[i - j - 1]; j++) {\\n\\t\\t\\tcount = (count % mod + dp[i - j - 1] % mod) % mod;\\n\\t\\t}\\n\\t\\tdp[i] = count;\\n\\t}\\n\\treturn dp[arr.length];\\n}",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nchar[] arr;\\nint brr[], dp[], mod = 1_000_000_007;\\n\\npublic int countTexts(String pressedKeys){\\n\\tarr = pressedKeys.toCharArray();\\n\\tdp = new int[arr.length + 1];\\n\\tbrr = new int[] { 0, 0, 3, 3, 3, 3, 3, 4, 3, 4 };\\n\\tdp[0] = 1;\\n\\tfor(int i = 1; i <= arr.length; i++){\\n\\n\\t\\tint freq = brr[arr[i - 1] - \\'0\\'], count = 0;\\n\\t\\tfor (int j = 0; i - j - 1 >= 0 && j < freq && arr[i - 1] == arr[i - j - 1]; j++) {\\n\\t\\t\\tcount = (count % mod + dp[i - j - 1] % mod) % mod;\\n\\t\\t}\\n\\t\\tdp[i] = count;\\n\\t}\\n\\treturn dp[arr.length];\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2737477,
                "title": "c-o-n-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int countTexts(string pressedKeys) {\\n        pressedKeys += \\'*\\';\\n        long long res = 1, mod = 1e9+7;\\n        vector<int> vNumChar = {1,0,3,3,3,3,3,4,3,4};\\n        char pre = \\'0\\';\\n        int len = 0;\\n        for(auto c:pressedKeys){\\n            if(c != pre){\\n                res = count(len, vNumChar[pre-\\'0\\']) % mod * res % mod;\\n                pre = c;\\n                len = 1;\\n            }\\n            else{\\n                len++;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    int count(int n, int numChar){\\n        const long long mod = 1e9+7;\\n        vector<long long> dp(n+1, 0);\\n        dp[0] = 1;\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<=numChar;j++){\\n                if(i+1-j >= 0) dp[i+1] += dp[i+1-j];\\n            }\\n            dp[i+1] %= mod;\\n        }\\n        return dp.back();\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int countTexts(string pressedKeys) {\\n        pressedKeys += \\'*\\';\\n        long long res = 1, mod = 1e9+7;\\n        vector<int> vNumChar = {1,0,3,3,3,3,3,4,3,4}",
                "codeTag": "Java"
            },
            {
                "id": 2717929,
                "title": "c-concise-intuitive-easy-to-understand-dynamic-programming-solution-o-n",
                "content": "My personal struggle has always been, my brain looping in cataclysms of understanding \\'# of ways\\', so I often get the tansition from one state to another wrong.\\nI do things like initialising dp tables with 1 or adding 1 while transitioning which is clearly wrong. \\n\\nFor example in for input 2223 transitioning from \"222\"-> \"2223\" will not resullt in increase in the # of ways.\\nAlso it is important to understand the base condition dp[0] = 1;\\nBasically dp[n] denotes the number of ways of decoding the test of length n, the number of ways of decoding an empty message is 1.\\n\\n```\\nint countTexts(string pk) {\\n        int n = pk.size(), m = 1e9 + 7, k;\\n        vector<int> dp(n + 1, 0);\\n        dp[0] = 1;\\n        for (int i = 0; i < n; i++) {\\n            k = (pk[i] == \\'7\\' || pk[i] == \\'9\\') ? 4 : 3;\\n            for (int j = 0; j < k && i - j >= 0 && pk[i] == pk[i - j]; j++) \\n                dp[i + 1] = (dp[i + 1] + dp[i - j]) % m;\\n        }\\n        return dp[n];\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nint countTexts(string pk) {\\n        int n = pk.size(), m = 1e9 + 7, k;\\n        vector<int> dp(n + 1, 0);\\n        dp[0] = 1;\\n        for (int i = 0; i < n; i++) {\\n            k = (pk[i] == \\'7\\' || pk[i] == \\'9\\') ? 4 : 3;\\n            for (int j = 0; j < k && i - j >= 0 && pk[i] == pk[i - j]; j++) \\n                dp[i + 1] = (dp[i + 1] + dp[i - j]) % m;\\n        }\\n        return dp[n];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2692639,
                "title": "java-o-n-memoization-easy-intiution-faster",
                "content": "\\tpublic int mod = 1000000007;\\n    public int[] dp;\\n   \\n    public int countTexts(String s) {\\n        int n = s.length();\\n        dp = new int[n+1];\\n        dp[n]=1;\\n        for(int index=n-1; index>=0; index--){\\n            char ch = s.charAt(index);\\n            int keylen=(ch==\\'7\\' || ch==\\'9\\')?4:3;\\n            for(int i=1; i<=keylen; i++){\\n                if(index+i > n) break;\\n                if(ch!=s.charAt(index+i-1)) break;\\n\\n                dp[index] += dp[index+i];\\n                dp[index] = dp[index]%mod;\\n            }\\n        }\\n        return dp[0];\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "\\tpublic int mod = 1000000007;\\n    public int[] dp;\\n   \\n    public int countTexts(String s) {\\n        int n = s.length();\\n        dp = new int[n+1];\\n        dp[n]=1;\\n        for(int index=n-1; index>=0; index--){\\n            char ch = s.charAt(index);\\n            int keylen=(ch==\\'7\\' || ch==\\'9\\')?4:3;\\n            for(int i=1; i<=keylen; i++){\\n                if(index+i > n) break;\\n                if(ch!=s.charAt(index+i-1)) break;\\n\\n                dp[index] += dp[index+i];\\n                dp[index] = dp[index]%mod;\\n            }\\n        }\\n        return dp[0];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2679674,
                "title": "python-short-solution",
                "content": "```\\ndef countTexts(self, strs: str) -> int:\\n\\tmod = 10**9+7\\n\\t\\n\\t@lru_cache(None)\\n\\tdef dfs(x, k):\\n\\t\\tif x==0:\\n\\t\\t\\treturn 1\\n\\t\\treturn sum(dfs(x-i, k) for i in range(1, min(x, k)+1))%mod\\n\\n\\td = {str(c):3 for c in range(2, 10)}\\n\\td[\\'7\\'], d[\\'9\\'] = 4, 4\\n\\treturn reduce(mul, [dfs(len(list(g)), d[k]) for k, g in groupby(strs)])%mod    \\n```",
                "solutionTags": [],
                "code": "```\\ndef countTexts(self, strs: str) -> int:\\n\\tmod = 10**9+7\\n\\t\\n\\t@lru_cache(None)\\n\\tdef dfs(x, k):\\n\\t\\tif x==0:\\n\\t\\t\\treturn 1\\n\\t\\treturn sum(dfs(x-i, k) for i in range(1, min(x, k)+1))%mod\\n\\n\\td = {str(c):3 for c in range(2, 10)}\\n\\td[\\'7\\'], d[\\'9\\'] = 4, 4\\n\\treturn reduce(mul, [dfs(len(list(g)), d[k]) for k, g in groupby(strs)])%mod    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2672218,
                "title": "python-easiest-memoization",
                "content": "```\\nclass Solution(object):\\n    def countTexts(self, pressed):\\n        def dfs(i,s):\\n            if i in dp:\\n                return dp[i]\\n            if i>=len(s):\\n                return 1\\n            count = 0\\n            n = 3\\n            if s[i] == \\'7\\' or s[i] == \\'9\\':\\n                n = 4\\n            # number of times we can press the buttons \\n            for k in range(1, n+1):\\n                if i+k<=len(s):\\n                    count+= dfs(i+k,s)\\n            dp[i] = count\\n            return dp[i]\\n        ans = 1\\n        i= 0\\n        j = 0\\n        while j<len(pressed):\\n            while j<len(pressed) and pressed[i] == pressed[j]:\\n                j+=1\\n            s = pressed[i:j]\\n            dp = {}\\n            ans *= dfs(0,s)\\n            i = j\\n        return ans%(10**9+7)\\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution(object):\\n    def countTexts(self, pressed):\\n        def dfs(i,s):\\n            if i in dp:\\n                return dp[i]\\n            if i>=len(s):\\n                return 1\\n            count = 0\\n            n = 3\\n            if s[i] == \\'7\\' or s[i] == \\'9\\':\\n                n = 4\\n            # number of times we can press the buttons \\n            for k in range(1, n+1):\\n                if i+k<=len(s):\\n                    count+= dfs(i+k,s)\\n            dp[i] = count\\n            return dp[i]\\n        ans = 1\\n        i= 0\\n        j = 0\\n        while j<len(pressed):\\n            while j<len(pressed) and pressed[i] == pressed[j]:\\n                j+=1\\n            s = pressed[i:j]\\n            dp = {}\\n            ans *= dfs(0,s)\\n            i = j\\n        return ans%(10**9+7)\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2664936,
                "title": "c-easy-recursive-and-memoized-code-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    int MOD = 1e9 + 7;\\n    int countTexts(string keys) {\\n        dp.resize(keys.size(), -1);\\n        \\n        return recurse(keys, 0);\\n    }\\n    int recurse(string &keys, int ind){\\n        if(ind >= keys.size()){\\n            return 1;\\n        }\\n        if(dp[ind] != -1){\\n            return dp[ind] % MOD;\\n        }\\n        \\n        long long ans = 0;\\n        \\n        //take one char at a time\\n        ans += recurse(keys, ind + 1);\\n            \\n        if(ind + 1 < keys.size() and keys[ind] == keys[ind + 1]){\\n            //take two char at a time if they\\'re identical\\n            ans += recurse(keys, ind + 2);\\n\\n            if(ind + 2 < keys.size() and keys[ind] == keys[ind + 2]){\\n                //take three char at a time if they\\'re identical\\n                ans += recurse(keys, ind + 3);\\n                \\n                //take four char at a time if they\\'re identical and they\\'re either 7 or 9\\n                if(ind + 3 < keys.size() and keys[ind] == keys[ind + 3] and \\n                  (keys[ind + 3] == \\'7\\' or keys[ind + 3] == \\'9\\')){\\n                    \\n                    ans += recurse(keys, ind + 4);\\n                }\\n            }\\n        }\\n        return dp[ind] = ans % MOD;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    int MOD = 1e9 + 7;\\n    int countTexts(string keys) {\\n        dp.resize(keys.size(), -1);\\n        \\n        return recurse(keys, 0);\\n    }\\n    int recurse(string &keys, int ind){\\n        if(ind >= keys.size()){\\n            return 1;\\n        }\\n        if(dp[ind] != -1){\\n            return dp[ind] % MOD;\\n        }\\n        \\n        long long ans = 0;\\n        \\n        //take one char at a time\\n        ans += recurse(keys, ind + 1);\\n            \\n        if(ind + 1 < keys.size() and keys[ind] == keys[ind + 1]){\\n            //take two char at a time if they\\'re identical\\n            ans += recurse(keys, ind + 2);\\n\\n            if(ind + 2 < keys.size() and keys[ind] == keys[ind + 2]){\\n                //take three char at a time if they\\'re identical\\n                ans += recurse(keys, ind + 3);\\n                \\n                //take four char at a time if they\\'re identical and they\\'re either 7 or 9\\n                if(ind + 3 < keys.size() and keys[ind] == keys[ind + 3] and \\n                  (keys[ind + 3] == \\'7\\' or keys[ind + 3] == \\'9\\')){\\n                    \\n                    ans += recurse(keys, ind + 4);\\n                }\\n            }\\n        }\\n        return dp[ind] = ans % MOD;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2661593,
                "title": "python-using-groupby",
                "content": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        MOD = 10 ** 9 + 7\\n        \\n        @cache\\n        def dfs(cur: int, options: int) -> int:\\n            if cur < 0:\\n                return 0\\n            if cur == 0:\\n                return 1\\n            \\n            res = 0\\n            for ind in range(1, options + 1):\\n                res += dfs(cur - ind, options)\\n            return res % MOD\\n        \\n        res = 1\\n        \\n        for key, curgroup in groupby(pressedKeys):\\n            options = 4 if key in \"79\" else 3\\n            res *= dfs(len(list(curgroup)), options)\\n            res %= MOD\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        MOD = 10 ** 9 + 7\\n        \\n        @cache\\n        def dfs(cur: int, options: int) -> int:\\n            if cur < 0:\\n                return 0\\n            if cur == 0:\\n                return 1\\n            \\n            res = 0\\n            for ind in range(1, options + 1):\\n                res += dfs(cur - ind, options)\\n            return res % MOD\\n        \\n        res = 1\\n        \\n        for key, curgroup in groupby(pressedKeys):\\n            options = 4 if key in \"79\" else 3\\n            res *= dfs(len(list(curgroup)), options)\\n            res %= MOD\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2654278,
                "title": "python-solution-dynamic-programming-faster-than-96-time-o-n-space-o-n",
                "content": "\\tclass Solution:\\n\\t\\tdef countTexts(self, pressedKeys: str) -> int:\\n\\t\\t\\tpressedKeys_len = len(pressedKeys)\\n\\t\\t\\tif pressedKeys_len == 0: \\n\\t\\t\\t\\treturn 0 \\n\\t\\t\\telif pressedKeys_len == 1: \\n\\t\\t\\t\\treturn 1 \\n\\t\\t\\tif \\'0\\' in pressedKeys or \\'1\\' in pressedKeys: \\n\\t\\t\\t\\treturn False\\n\\t\\t\\tqueue = list()\\n\\t\\t\\tcontinue_count = 1\\n\\t\\t\\tprev_num_of_text = pressedKeys[0]\\n\\t\\t\\ti = 1\\n\\t\\t\\tmax_continue_count = 1\\n\\t\\t\\twhile i<pressedKeys_len:\\n\\t\\t\\t\\tcurr_num_of_text = pressedKeys[i]\\n\\t\\t\\t\\tif curr_num_of_text == prev_num_of_text: \\n\\t\\t\\t\\t\\tcontinue_count += 1                \\n\\t\\t\\t\\telif curr_num_of_text != prev_num_of_text: \\n\\t\\t\\t\\t\\tqueue.append([prev_num_of_text, continue_count])\\n\\t\\t\\t\\t\\tif max_continue_count<continue_count: \\n\\t\\t\\t\\t\\t\\tmax_continue_count = continue_count\\n\\t\\t\\t\\t\\tcontinue_count = 1\\n\\t\\t\\t\\tprev_num_of_text = curr_num_of_text\\n\\t\\t\\t\\ti += 1 \\n\\t\\t\\tqueue.append((prev_num_of_text, continue_count))\\n\\t\\t\\tif max_continue_count<continue_count: \\n\\t\\t\\t\\tmax_continue_count = continue_count\\n\\t\\t\\t# print(queue)\\n\\t\\t\\tdp3 = [0 for _ in range(1+max_continue_count)]\\n\\t\\t\\tdp3[1] = 1 \\n\\t\\t\\tfor i in range(2, 1+max_continue_count): \\n\\t\\t\\t\\tif i==2:\\n\\t\\t\\t\\t\\tdp3[i] = (dp3[i-1] + 1) % (10**9 + 7)\\n\\t\\t\\t\\telif i==3: \\n\\t\\t\\t\\t\\tdp3[i] = (dp3[i-1] + dp3[i-2] + 1) % (10**9 + 7)\\n\\t\\t\\t\\telif i>=4: \\n\\t\\t\\t\\t\\tdp3[i] = (dp3[i-1] + dp3[i-2] + dp3[i-3]) % (10**9 + 7)  \\n\\n\\t\\t\\tdp4 = [0 for _ in range(1+max_continue_count)]         \\n\\t\\t\\tdp4[1] = 1         \\n\\t\\t\\tfor i in range(2, 1+max_continue_count): \\n\\t\\t\\t\\tif i==2:\\n\\t\\t\\t\\t\\tdp4[i] = (dp4[i-1] + 1) % (10**9 + 7)\\n\\t\\t\\t\\telif i==3: \\n\\t\\t\\t\\t\\tdp4[i] = (dp4[i-1] + dp4[i-2] + 1) % (10**9 + 7)\\n\\t\\t\\t\\telif i==4: \\n\\t\\t\\t\\t\\tdp4[i] = (dp4[i-1] + dp4[i-2] + dp4[i-3] + 1) % (10**9 + 7)                \\n\\t\\t\\t\\telif i>=5: \\n\\t\\t\\t\\t\\tdp4[i] = (dp4[i-1] + dp4[i-2] + dp4[i-3] + dp4[i-4]) % (10**9 + 7)                  \\n\\t\\t\\tres = 1 \\n\\t\\t\\titems_num = len(queue)\\n\\t\\t\\tfor i in range(items_num): \\n\\t\\t\\t\\tcurr_item = queue[i]\\n\\t\\t\\t\\tdigit_num, curr_continue_num_count = curr_item \\n\\t\\t\\t\\t# print(curr_item, digit_num, curr_continue_num_count)\\n\\t\\t\\t\\tif digit_num in \\'234568\\': \\n\\t\\t\\t\\t\\tres *= dp3[curr_continue_num_count] % (10**9 + 7) \\n\\t\\t\\t\\telif digit_num in \\'79\\':  \\n\\t\\t\\t\\t\\tres *= dp4[curr_continue_num_count] % (10**9 + 7) \\n\\t\\t\\treturn res % (10**9 + 7)",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef countTexts(self, pressedKeys: str) -> int:\\n\\t\\t\\tpressedKeys_len = len(pressedKeys)\\n\\t\\t\\tif pressedKeys_len == 0: \\n\\t\\t\\t\\treturn 0 \\n\\t\\t\\telif pressedKeys_len == 1: \\n\\t\\t\\t\\treturn 1 \\n\\t\\t\\tif \\'0\\' in pressedKeys or \\'1\\' in pressedKeys: \\n\\t\\t\\t\\treturn False\\n\\t\\t\\tqueue = list()\\n\\t\\t\\tcontinue_count = 1\\n\\t\\t\\tprev_num_of_text = pressedKeys[0]\\n\\t\\t\\ti = 1\\n\\t\\t\\tmax_continue_count = 1\\n\\t\\t\\twhile i<pressedKeys_len:\\n\\t\\t\\t\\tcurr_num_of_text = pressedKeys[i]\\n\\t\\t\\t\\tif curr_num_of_text == prev_num_of_text: \\n\\t\\t\\t\\t\\tcontinue_count += 1                \\n\\t\\t\\t\\telif curr_num_of_text != prev_num_of_text: \\n\\t\\t\\t\\t\\tqueue.append([prev_num_of_text, continue_count])\\n\\t\\t\\t\\t\\tif max_continue_count<continue_count: \\n\\t\\t\\t\\t\\t\\tmax_continue_count = continue_count\\n\\t\\t\\t\\t\\tcontinue_count = 1\\n\\t\\t\\t\\tprev_num_of_text = curr_num_of_text\\n\\t\\t\\t\\ti += 1 \\n\\t\\t\\tqueue.append((prev_num_of_text, continue_count))\\n\\t\\t\\tif max_continue_count<continue_count: \\n\\t\\t\\t\\tmax_continue_count = continue_count\\n\\t\\t\\t# print(queue)\\n\\t\\t\\tdp3 = [0 for _ in range(1+max_continue_count)]\\n\\t\\t\\tdp3[1] = 1 \\n\\t\\t\\tfor i in range(2, 1+max_continue_count): \\n\\t\\t\\t\\tif i==2:\\n\\t\\t\\t\\t\\tdp3[i] = (dp3[i-1] + 1) % (10**9 + 7)\\n\\t\\t\\t\\telif i==3: \\n\\t\\t\\t\\t\\tdp3[i] = (dp3[i-1] + dp3[i-2] + 1) % (10**9 + 7)\\n\\t\\t\\t\\telif i>=4: \\n\\t\\t\\t\\t\\tdp3[i] = (dp3[i-1] + dp3[i-2] + dp3[i-3]) % (10**9 + 7)  \\n\\n\\t\\t\\tdp4 = [0 for _ in range(1+max_continue_count)]         \\n\\t\\t\\tdp4[1] = 1         \\n\\t\\t\\tfor i in range(2, 1+max_continue_count): \\n\\t\\t\\t\\tif i==2:\\n\\t\\t\\t\\t\\tdp4[i] = (dp4[i-1] + 1) % (10**9 + 7)\\n\\t\\t\\t\\telif i==3: \\n\\t\\t\\t\\t\\tdp4[i] = (dp4[i-1] + dp4[i-2] + 1) % (10**9 + 7)\\n\\t\\t\\t\\telif i==4: \\n\\t\\t\\t\\t\\tdp4[i] = (dp4[i-1] + dp4[i-2] + dp4[i-3] + 1) % (10**9 + 7)                \\n\\t\\t\\t\\telif i>=5: \\n\\t\\t\\t\\t\\tdp4[i] = (dp4[i-1] + dp4[i-2] + dp4[i-3] + dp4[i-4]) % (10**9 + 7)                  \\n\\t\\t\\tres = 1 \\n\\t\\t\\titems_num = len(queue)\\n\\t\\t\\tfor i in range(items_num): \\n\\t\\t\\t\\tcurr_item = queue[i]\\n\\t\\t\\t\\tdigit_num, curr_continue_num_count = curr_item \\n\\t\\t\\t\\t# print(curr_item, digit_num, curr_continue_num_count)\\n\\t\\t\\t\\tif digit_num in \\'234568\\': \\n\\t\\t\\t\\t\\tres *= dp3[curr_continue_num_count] % (10**9 + 7) \\n\\t\\t\\t\\telif digit_num in \\'79\\':  \\n\\t\\t\\t\\t\\tres *= dp4[curr_continue_num_count] % (10**9 + 7) \\n\\t\\t\\treturn res % (10**9 + 7)",
                "codeTag": "Java"
            },
            {
                "id": 2651611,
                "title": "c-dp-single-pass",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSingle pass using dynamic programming similar to decode ways question\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countTexts(string pressedKeys) {\\n        \\n        int n = pressedKeys.length();\\n        // int* dp = new int[n];\\n        vector<long> dp(n);\\n        \\n        dp[0] = 1;\\n        int mod  = pow(10, 9) + 7;\\n\\n        for(int i=1; i<n; i++){\\n            dp[i] = dp[i-1];\\n            char ch = pressedKeys.at(i);\\n\\n            if((i>=1) && ch == pressedKeys.at(i-1)) dp[i]= i>=2 ?(dp[i] + dp[i-2]) % mod: dp[i] + 1;\\n            else continue;\\n\\n            if((i>=2) && ch == pressedKeys.at(i-2)) dp[i]= i>=3 ? (dp[i] + dp[i-3]) % mod: dp[i] + 1;\\n            else continue;\\n\\n            if((i>=3) && (ch == \\'7\\' || ch == \\'9\\') && ch == pressedKeys.at(i-3)) \\n            dp[i]= i>=4 ? (dp[i] + dp[i-4]) % mod : dp[i] + 1;\\n        }\\n       \\n        return (int)dp[n-1] % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countTexts(string pressedKeys) {\\n        \\n        int n = pressedKeys.length();\\n        // int* dp = new int[n];\\n        vector<long> dp(n);\\n        \\n        dp[0] = 1;\\n        int mod  = pow(10, 9) + 7;\\n\\n        for(int i=1; i<n; i++){\\n            dp[i] = dp[i-1];\\n            char ch = pressedKeys.at(i);\\n\\n            if((i>=1) && ch == pressedKeys.at(i-1)) dp[i]= i>=2 ?(dp[i] + dp[i-2]) % mod: dp[i] + 1;\\n            else continue;\\n\\n            if((i>=2) && ch == pressedKeys.at(i-2)) dp[i]= i>=3 ? (dp[i] + dp[i-3]) % mod: dp[i] + 1;\\n            else continue;\\n\\n            if((i>=3) && (ch == \\'7\\' || ch == \\'9\\') && ch == pressedKeys.at(i-3)) \\n            dp[i]= i>=4 ? (dp[i] + dp[i-4]) % mod : dp[i] + 1;\\n        }\\n       \\n        return (int)dp[n-1] % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2650844,
                "title": "python-easy-to-understand-solution-with-memoization",
                "content": "```python\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        d = {\\n            \\'2\\': \\'abc\\',\\n            \\'3\\': \\'def\\',\\n            \\'4\\': \\'gfi\\',\\n            \\'5\\': \\'jkl\\',\\n            \\'6\\': \\'mno\\',\\n            \\'7\\': \\'pqrs\\',\\n            \\'8\\': \\'tuv\\',\\n            \\'9\\': \\'wxyz\\',\\n        }\\n\\n        @cache\\n        def dfs(i):\\n            if i == len(pressedKeys):\\n                return 1\\n \\n            total = 0\\n    \\n            for j in range(len(d[pressedKeys[i]])):\\n                k = i + j + 1 \\n\\n                if k > len(pressedKeys) or pressedKeys[i] != pressedKeys[k - 1]:\\n                    break\\n\\n                total += dfs(k)\\n\\n            return total % (10**9 + 7)\\n\\n        return dfs(0) \\n```",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```python\\nclass Solution:\\n    def countTexts(self, pressedKeys: str) -> int:\\n        d = {\\n            \\'2\\': \\'abc\\',\\n            \\'3\\': \\'def\\',\\n            \\'4\\': \\'gfi\\',\\n            \\'5\\': \\'jkl\\',\\n            \\'6\\': \\'mno\\',\\n            \\'7\\': \\'pqrs\\',\\n            \\'8\\': \\'tuv\\',\\n            \\'9\\': \\'wxyz\\',\\n        }\\n\\n        @cache\\n        def dfs(i):\\n            if i == len(pressedKeys):\\n                return 1\\n \\n            total = 0\\n    \\n            for j in range(len(d[pressedKeys[i]])):\\n                k = i + j + 1 \\n\\n                if k > len(pressedKeys) or pressedKeys[i] != pressedKeys[k - 1]:\\n                    break\\n\\n                total += dfs(k)\\n\\n            return total % (10**9 + 7)\\n\\n        return dfs(0) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649367,
                "title": "java-recursion",
                "content": "\\tclass Solution {\\n    int mod=(int)1e9+7;\\n    public int countTexts(String pk) {\\n        HashMap<String,Character>hm=new HashMap<>();\\n        \\n        hm.put(\"2\", \\'a\\'); hm.put(\"22\",\\'b\\'); hm.put(\"222\",\\'c\\');\\n        hm.put(\"3\",\\'d\\'); hm.put(\"33\",\\'e\\'); hm.put(\"333\",\\'f\\');\\n        hm.put(\"4\",\\'g\\'); hm.put(\"44\",\\'h\\'); hm.put(\"444\",\\'i\\');\\n        hm.put(\"5\",\\'j\\'); hm.put(\"55\",\\'k\\'); hm.put(\"555\",\\'l\\');\\n        hm.put(\"6\",\\'m\\'); hm.put(\"66\",\\'n\\'); hm.put(\"666\",\\'o\\');\\n        hm.put(\"7\",\\'p\\'); hm.put(\"77\",\\'q\\'); hm.put(\"777\",\\'r\\'); hm.put(\"7777\",\\'s\\');\\n        hm.put(\"8\",\\'t\\'); hm.put(\"88\",\\'u\\'); hm.put(\"888\",\\'v\\');\\n        hm.put(\"9\",\\'w\\'); hm.put(\"99\",\\'x\\'); hm.put(\"999\",\\'y\\');\\n        hm.put(\"9999\",\\'z\\');\\n        int []dp=new int[pk.length()+1]; Arrays.fill(dp,-1);\\n        return call(0, pk, hm,dp);\\n    }\\n    \\n    public int call(int i, String s, HashMap<String, Character>hm, int[]dp)\\n    {\\n        if(i==s.length()) return 1;\\n        if(dp[i]!=-1) return dp[i];\\n        int ans=0;\\n        for(int j=i+1;j<=s.length()&&j<=i+4 ;j++)\\n        {\\n            if(hm.containsKey(s.substring(i,j)))\\n            {\\n                ans=(ans+call(j, s, hm,dp)%mod)%mod;\\n            }\\n        }\\n        return dp[i]=ans%mod;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    int mod=(int)1e9+7;\\n    public int countTexts(String pk) {\\n        HashMap<String,Character>hm=new HashMap<>();\\n        \\n        hm.put(\"2\", \\'a\\'); hm.put(\"22\",\\'b\\'); hm.put(\"222\",\\'c\\');\\n        hm.put(\"3\",\\'d\\'); hm.put(\"33\",\\'e\\'); hm.put(\"333\",\\'f\\');\\n        hm.put(\"4\",\\'g\\'); hm.put(\"44\",\\'h\\'); hm.put(\"444\",\\'i\\');\\n        hm.put(\"5\",\\'j\\'); hm.put(\"55\",\\'k\\'); hm.put(\"555\",\\'l\\');\\n        hm.put(\"6\",\\'m\\'); hm.put(\"66\",\\'n\\'); hm.put(\"666\",\\'o\\');\\n        hm.put(\"7\",\\'p\\'); hm.put(\"77\",\\'q\\'); hm.put(\"777\",\\'r\\'); hm.put(\"7777\",\\'s\\');\\n        hm.put(\"8\",\\'t\\'); hm.put(\"88\",\\'u\\'); hm.put(\"888\",\\'v\\');\\n        hm.put(\"9\",\\'w\\'); hm.put(\"99\",\\'x\\'); hm.put(\"999\",\\'y\\');\\n        hm.put(\"9999\",\\'z\\');\\n        int []dp=new int[pk.length()+1]; Arrays.fill(dp,-1);\\n        return call(0, pk, hm,dp);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2648290,
                "title": "java-clean-dp-solution-for-both-topdown-and-bottom-up-beat-88",
                "content": "1. top-down + memorization (beat 18%)\\n2. bottom-up (beat 88%)\\n```\\nclass Solution {\\n    int[] dp, count;\\n    int mod = 100_000_000_7;\\n    public int countTextsTD(String pressedKeys) {\\n        //need store max length of repeat number that can form a char.    \\n        if(pressedKeys == null || pressedKeys.isEmpty()) return 0;\\n        int n = pressedKeys.length();\\n        count = new int[] {0,0,3,3,3,3,3,4,3,4};\\n        dp = new int[n];        \\n        Arrays.fill(dp, -1);\\n        return dp(pressedKeys, 0, n);\\n    }\\n    //calculated reversely, start from [idx...n] can form how many \\n    private int dp(String s, int idx, int n) {\\n        if(idx == n) return 1;\\n        if(dp[idx] != -1) return dp[idx];\\n        \\n        int res = 0;\\n        char c = s.charAt(idx);\\n        int len = count[c-\\'0\\'];\\n        \\n        for(int i = 0; i < len && idx + i < n && s.charAt(idx + i) == s.charAt(idx); i++) {\\n            // i start with 0, will consider number idx do not combine with previous char.\\n            // i > 1 means, it can be combined with previous number to form a char.\\n            res += dp(s, idx + i + 1, n);\\n            res %= mod;\\n        }\\n        return dp[idx] = res;    \\n    }\\n    \\n    public int countTexts(String s) {\\n        int n = s.length();\\n        int[] dp = new int[n + 1];\\n        dp[0] = 1;\\n        for(int i = 1; i <= n; i++) {\\n            dp[i] = dp[i-1] % mod;\\n            if(i > 1 && s.charAt(i-1) == s.charAt(i-2)) {\\n                dp[i] += dp[i-2];\\n                dp[i] %= mod;\\n                if(i > 2 && s.charAt(i-1) == s.charAt(i-3)) {\\n                    dp[i] += dp[i-3];\\n                    dp[i] %= mod;\\n                    if(i > 3 && (s.charAt(i-1) == \\'7\\' || s.charAt(i-1) == \\'9\\') && s.charAt(i-1) == s.charAt(i-4)) {\\n                        dp[i] += dp[i-4];\\n                        dp[i] %= mod;\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int[] dp, count;\\n    int mod = 100_000_000_7;\\n    public int countTextsTD(String pressedKeys) {\\n        //need store max length of repeat number that can form a char.    \\n        if(pressedKeys == null || pressedKeys.isEmpty()) return 0;\\n        int n = pressedKeys.length();\\n        count = new int[] {0,0,3,3,3,3,3,4,3,4};\\n        dp = new int[n];        \\n        Arrays.fill(dp, -1);\\n        return dp(pressedKeys, 0, n);\\n    }\\n    //calculated reversely, start from [idx...n] can form how many \\n    private int dp(String s, int idx, int n) {\\n        if(idx == n) return 1;\\n        if(dp[idx] != -1) return dp[idx];\\n        \\n        int res = 0;\\n        char c = s.charAt(idx);\\n        int len = count[c-\\'0\\'];\\n        \\n        for(int i = 0; i < len && idx + i < n && s.charAt(idx + i) == s.charAt(idx); i++) {\\n            // i start with 0, will consider number idx do not combine with previous char.\\n            // i > 1 means, it can be combined with previous number to form a char.\\n            res += dp(s, idx + i + 1, n);\\n            res %= mod;\\n        }\\n        return dp[idx] = res;    \\n    }\\n    \\n    public int countTexts(String s) {\\n        int n = s.length();\\n        int[] dp = new int[n + 1];\\n        dp[0] = 1;\\n        for(int i = 1; i <= n; i++) {\\n            dp[i] = dp[i-1] % mod;\\n            if(i > 1 && s.charAt(i-1) == s.charAt(i-2)) {\\n                dp[i] += dp[i-2];\\n                dp[i] %= mod;\\n                if(i > 2 && s.charAt(i-1) == s.charAt(i-3)) {\\n                    dp[i] += dp[i-3];\\n                    dp[i] %= mod;\\n                    if(i > 3 && (s.charAt(i-1) == \\'7\\' || s.charAt(i-1) == \\'9\\') && s.charAt(i-1) == s.charAt(i-4)) {\\n                        dp[i] += dp[i-4];\\n                        dp[i] %= mod;\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647673,
                "title": "dp-linear",
                "content": "class Solution {\\npublic:\\n    \\n    vector <int> sf;\\n    int mod = 1e9+7;\\n    \\n    int dp[100009];\\n    \\n    int rec(int i,int n,string& s){\\n        \\n        if(i>n)return 0;\\n        if(i==n)return 1;\\n        \\n        if(dp[i]!=-1)return dp[i];\\n        \\n        int ans=0;\\n        \\n        bool flag = (s[i]==\\'2\\') || (s[i]==\\'3\\') || (s[i]==\\'4\\') || (s[i]==\\'5\\') || (s[i]==\\'6\\') || (s[i]==\\'8\\');\\n        \\n        if(flag){\\n            int x = sf[i];\\n            for(int j=1;j<=min(x,3);j++){\\n                ans += rec(i+j,n,s);\\n                ans %= mod;\\n            }\\n        }\\n        \\n        else{\\n                int x = sf[i];\\n            for(int j=1;j<=min(x,4);j++){\\n                ans += rec(i+j,n,s);\\n                ans %= mod;\\n            }  \\n        }\\n        return dp[i]=ans; \\n    }\\n    \\n    int countTexts(string s) {\\n        int n = s.size();\\n        sf = vector <int> (n,0);\\n        sf[n-1]=1;\\n        for(int i=n-2;i>=0;i--){\\n            if(s[i]==s[i+1])sf[i]=sf[i+1]+1;\\n            else sf[i]=1;\\n        }\\n        memset(dp,-1,sizeof(dp));\\n       int ans = rec(0,n,s);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    vector <int> sf;\\n    int mod = 1e9+7;\\n    \\n    int dp[100009];\\n    \\n    int rec(int i,int n,string& s){\\n        \\n        if(i>n)return 0;\\n        if(i==n)return 1;\\n        \\n        if(dp[i]!=-1)return dp[i];\\n        \\n        int ans=0;\\n        \\n        bool flag = (s[i]==\\'2\\') || (s[i]==\\'3\\') || (s[i]==\\'4\\') || (s[i]==\\'5\\') || (s[i]==\\'6\\') || (s[i]==\\'8\\');\\n        \\n        if(flag){\\n            int x = sf[i];\\n            for(int j=1;j<=min(x,3);j++){\\n                ans += rec(i+j,n,s);\\n                ans %= mod;\\n            }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1576725,
                "content": [
                    {
                        "username": "snady",
                        "content": "the descrpition says \"Since the answer may be very large, return it modulo 10^9 + 7.\"\\nfellow python users might think to just return the answer % 10^9 + 7 at the end but this produces an incorrect result, the count should be modded at each iteration... \\n\\nI think the wording of the problem could be improved, unless I\\'m the only one who made this error \\uD83D\\uDE05"
                    },
                    {
                        "username": "joyparikh",
                        "content": "It is a well known result that (a+b)%c = (a%c + b%c)%c. So if you took mod only at the end, or you took mod at intermediate steps and then at the end should give the same result"
                    },
                    {
                        "username": "VehicleOfPuzzle",
                        "content": "I\\'m not sure what solution approach you\\'d be using such that modulo at the end would be an incorrect result. It may lead to very large intermediate calculations but the end result should be the same."
                    },
                    {
                        "username": "lolipop_",
                        "content": "When I run one of the testcases containing a large number of 3s as one of my trial test case, it works. But the same testcase fails when I submit the solution"
                    }
                ]
            },
            {
                "id": 1829036,
                "content": [
                    {
                        "username": "snady",
                        "content": "the descrpition says \"Since the answer may be very large, return it modulo 10^9 + 7.\"\\nfellow python users might think to just return the answer % 10^9 + 7 at the end but this produces an incorrect result, the count should be modded at each iteration... \\n\\nI think the wording of the problem could be improved, unless I\\'m the only one who made this error \\uD83D\\uDE05"
                    },
                    {
                        "username": "joyparikh",
                        "content": "It is a well known result that (a+b)%c = (a%c + b%c)%c. So if you took mod only at the end, or you took mod at intermediate steps and then at the end should give the same result"
                    },
                    {
                        "username": "VehicleOfPuzzle",
                        "content": "I\\'m not sure what solution approach you\\'d be using such that modulo at the end would be an incorrect result. It may lead to very large intermediate calculations but the end result should be the same."
                    },
                    {
                        "username": "lolipop_",
                        "content": "When I run one of the testcases containing a large number of 3s as one of my trial test case, it works. But the same testcase fails when I submit the solution"
                    }
                ]
            }
        ]
    },
    {
        "title": "Steps to Make Array Non-decreasing",
        "question_content": "<p>You are given a <strong>0-indexed</strong> integer array <code>nums</code>. In one step, <strong>remove</strong> all elements <code>nums[i]</code> where <code>nums[i - 1] &gt; nums[i]</code> for all <code>0 &lt; i &lt; nums.length</code>.</p>\n\n<p>Return <em>the number of steps performed until </em><code>nums</code><em> becomes a <strong>non-decreasing</strong> array</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [5,3,4,4,7,3,6,11,8,5,11]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The following are the steps performed:\n- Step 1: [5,<strong><u>3</u></strong>,4,4,7,<u><strong>3</strong></u>,6,11,<u><strong>8</strong></u>,<u><strong>5</strong></u>,11] becomes [5,4,4,7,6,11,11]\n- Step 2: [5,<u><strong>4</strong></u>,4,7,<u><strong>6</strong></u>,11,11] becomes [5,4,7,11,11]\n- Step 3: [5,<u><strong>4</strong></u>,7,11,11] becomes [5,7,11,11]\n[5,7,11,11] is a non-decreasing array. Therefore, we return 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [4,5,7,7,13]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> nums is already a non-decreasing array. Therefore, we return 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 2085864,
                "title": "java-c-python-stack-dp-explanation-poem",
                "content": "# **Intuition**\\nIterating the input `A` backward,\\nthen for each `A[i]`, find how many round it can eat on its right.\\n<br>\\n\\n# **Explanation**\\n`dp[i]` means the number of element `A[i]` can eat on its right.\\nMore precisely, the number of rounds for an element `A[i]`,\\nto completely eat whatever it can eat on the right of `A[i]`,\\nif it is possible.\\n\\nIterative input array `A` reversely,\\nIf `A[i]` is bigger the last element `A[j]` of stack,\\nthis means `A[i]` can eat that element,\\nThen update `dp[i]` to be max of `dp[i] + 1` and `dp[j]`.\\n<br>\\n# **Example**\\nTake example of `[10, 1, 2, 9, 1, 2, 3, 4]`\\n10 can eat 1,2 in 2 rounds\\n9 can eat 1,2,3,4 in 4 rounds\\n\\n\"max(++dp[i], dp[stack[j--]]);\"\\nIn this example\\n`dp[i] = 2`,\\n`++dp[i] = 3`\\n`dp[stack[j--] = 4`\\nfinally we got the max rounds `4`.\\n<br>\\n\\n# **Poem**\\nTo understand this process better with a famous Chinese poem:\\n\\n\\u957F\\u6C5F\\u540E\\u6D6A\\u63A8\\u524D\\u6D6A\\uFF0C\\n\\u524D\\u6D6A\\u6B7B\\u5728\\u6C99\\u6EE9\\u4E0A\\u3002\\n\\u540E\\u6D6A\\u7EE7\\u7EED\\u5F80\\u524D\\u63A8\\uFF0C\\n\\u8FD8\\u662F\\u6B7B\\u5728\\u6C99\\u6EE9\\u4E0A\\u3002\\n\\nThe back waves push the front waves,\\nthe front waves die on the beach.\\nThe back waves continue to push forward,\\nstill die on the beach.\\n<br>\\n\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(n)`\\n<br>\\n\\n**Java**\\nUse int array to simulate stack.\\n```java\\n    public int totalSteps(int[] A) {\\n        int n = A.length, res = 0, j = -1;\\n        int dp[] = new int[n], stack[] = new int[n];\\n        for (int i = n - 1; i >= 0; --i) {\\n            while (j >= 0 && A[i] > A[stack[j]]) {\\n                dp[i] = Math.max(++dp[i], dp[stack[j--]]);\\n                res = Math.max(res, dp[i]);\\n            }\\n            stack[++j] = i;\\n        }\\n        return res;\\n    }\\n```\\n**C++**\\n```cpp\\n    int totalSteps(vector<int>& A) {\\n        int n = A.size(), res = 0;\\n        vector<int> stack, dp(n);\\n        for (int i = n - 1; i >= 0; --i) {\\n            while (!stack.empty() && A[i] > A[stack.back()]) {\\n                dp[i] = max(++dp[i], dp[stack.back()]);\\n                stack.pop_back();\\n                res = max(res, dp[i]);\\n            }\\n            stack.push_back(i);\\n        }\\n        return res;\\n    }\\n```\\n**C++**\\nUse int array to simulate stack.\\n```cpp\\n    int totalSteps(vector<int>& A) {\\n        int n = A.size(), res = 0, j = -1;\\n        vector<int> stack(n), dp(n);\\n        for (int i = n - 1; i >= 0; --i) {\\n            while (j >= 0 && A[i] > A[stack[j]]) {\\n                dp[i] = max(++dp[i], dp[stack[j--]]);\\n                res = max(res, dp[i]);\\n            }\\n            stack[++j] = i;\\n        }\\n        return res;\\n    }\\n```\\n**Python**\\n```py\\n    def totalSteps(self, A: List[int]) -> int:\\n        n = len(A)\\n        dp = [0] * n\\n        stack = []\\n        for i in range(n-1, -1, -1):\\n            while stack and A[i] > A[stack[-1]]:\\n                dp[i] = max(dp[i] + 1, dp[stack.pop()])\\n            stack.append(i)\\n        return max(dp)\\n```\\n<br>\\n\\n\\n# **Solution 2: Iterating Forward**\\nWe can solve it by iterating it forward.\\nFor each `A[i]`, we need to find how many round it takes to eat `A[i]`.\\nThis is how I resovled it firstly.\\n\\nTime `O(n)`\\nSpace `O(n)`\\n\\n\\n**Python**\\n```py\\n    def totalSteps(self, A: List[int]) -> int:\\n        dp = [0] * len(A)\\n        stack = []\\n        for i, a in enumerate(A):\\n            cur = 0\\n            while stack and a >= A[stack[-1]]:\\n                cur = max(cur, dp[stack.pop()])\\n            if stack:\\n                dp[i] = cur + 1\\n            stack.append(i)\\n        return max(dp)\\n```\\n<br>\\n\\n\\n# More Good Stack Problems\\nHere are some problems that impressed me.\\nGood luck and have fun.\\n\\n- 2289. [Steps to Make Array Non-decreasing](https://leetcode.com/problems/steps-to-make-array-non-decreasing/discuss/2085864/)\\n- 2281. [Sum of Total Strength of Wizards](https://leetcode.com/problems/sum-of-total-strength-of-wizards/discuss/2061985/python-solution-on/1405190)\\n- 1776. [Car Fleet II](https://leetcode.com/problems/car-fleet-ii/discuss/1085987/javacpython-on-stack-solution/)\\n- 1673. [Find the Most Competitive Subsequence](https://leetcode.com/problems/find-the-most-competitive-subsequence/discuss/952786/javacpython-one-pass-stack-solution/776191 )\\n- 1671. [Minimum Number of Removals to Make Mountain Array](https://leetcode.com/problems/minimum-number-of-removals-to-make-mountain-array/discuss/952136/Python-LIS-O(nlogn))\\n- 1475. [Final Prices With a Special Discount in a Shop](https://leetcode.com/problems/final-prices-with-a-special-discount-in-a-shop/discuss/685390/javacpython-stack-one-pass/809992)\\n- 1425. [Constrained Subsequence Sum](https://leetcode.com/problems/constrained-subsequence-sum/discuss/597751/JavaC++Python-O(N)-Decreasing-Deque)\\n- 1130. [Minimum Cost Tree From Leaf Values](https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space)\\n- 907. [Sum of Subarray Minimums](https://leetcode.com/problems/sum-of-subarray-minimums/discuss/170750/C++JavaPython-Stack-Solution)\\n- 901. [Online Stock Span](https://leetcode.com/problems/online-stock-span/discuss/168311/C++JavaPython-O(1))\\n- 856. [Score of Parentheses](https://leetcode.com/problems/score-of-parentheses/discuss/141777/C++JavaPython-O(1)-Space)\\n- 503. [Next Greater Element II](https://leetcode.com/problems/next-greater-element-ii/discuss/98270/JavaC++Python-Loop-Twice)\\n- 496. Next Greater Element I\\n- 84. Largest Rectangle in Histogram\\n- 42. Trapping Rain Water\\n<br>\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int totalSteps(int[] A) {\\n        int n = A.length, res = 0, j = -1;\\n        int dp[] = new int[n], stack[] = new int[n];\\n        for (int i = n - 1; i >= 0; --i) {\\n            while (j >= 0 && A[i] > A[stack[j]]) {\\n                dp[i] = Math.max(++dp[i], dp[stack[j--]]);\\n                res = Math.max(res, dp[i]);\\n            }\\n            stack[++j] = i;\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int totalSteps(vector<int>& A) {\\n        int n = A.size(), res = 0;\\n        vector<int> stack, dp(n);\\n        for (int i = n - 1; i >= 0; --i) {\\n            while (!stack.empty() && A[i] > A[stack.back()]) {\\n                dp[i] = max(++dp[i], dp[stack.back()]);\\n                stack.pop_back();\\n                res = max(res, dp[i]);\\n            }\\n            stack.push_back(i);\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int totalSteps(vector<int>& A) {\\n        int n = A.size(), res = 0, j = -1;\\n        vector<int> stack(n), dp(n);\\n        for (int i = n - 1; i >= 0; --i) {\\n            while (j >= 0 && A[i] > A[stack[j]]) {\\n                dp[i] = max(++dp[i], dp[stack[j--]]);\\n                res = max(res, dp[i]);\\n            }\\n            stack[++j] = i;\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def totalSteps(self, A: List[int]) -> int:\\n        n = len(A)\\n        dp = [0] * n\\n        stack = []\\n        for i in range(n-1, -1, -1):\\n            while stack and A[i] > A[stack[-1]]:\\n                dp[i] = max(dp[i] + 1, dp[stack.pop()])\\n            stack.append(i)\\n        return max(dp)\\n```\n```py\\n    def totalSteps(self, A: List[int]) -> int:\\n        dp = [0] * len(A)\\n        stack = []\\n        for i, a in enumerate(A):\\n            cur = 0\\n            while stack and a >= A[stack[-1]]:\\n                cur = max(cur, dp[stack.pop()])\\n            if stack:\\n                dp[i] = cur + 1\\n            stack.append(i)\\n        return max(dp)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2085967,
                "title": "python-explanation-with-pictures-stack",
                "content": "Let\\'s start with an example, I use blocks of different height to represent the values:\\n- The 1st number is always here since there is no larger number on its left.\\n- The 2nd number will be removed \\'by\\' the first number in the first step.\\n- The 3rd number will be removed \\'by\\' the second number in the first step.\\n- The 4th number will be removed \\'by\\' the 2nd number, **after** the first step when the 3rd block is removed. Thus the step for the 4th number is `step_for_the_3rd_number + 1 = 2`.\\n\\n\\n![image](https://assets.leetcode.com/users/images/0d9d8d5e-2115-46c4-98c0-fb0d3bac3d12_1653798218.5610669.png)\\n\\nTherefore, for a number `A[i]`, assume the first larger number on its left is `A[lft]`. `A[i]` can only be removed **after** all the numbers within `(lft, i)` are removed, and its step equals the largest step within `(lft, i)` plus 1.\\n\\nThus we can maintain a monotonic decreasing stack, and traverse the array from left to right. For each newly added number `A[i]`, (recall the example at the begining) we need to:\\n>remove the top number from stack that is no larger than `A[i]`, and record the maximum step number from these popped numbers. \\n>\\nUntil we find the first number that is larger than `A[i]`, meaning `A[i]` will be removed \\'by\\' this number in some step, and this step number equals the maximum step number we removed plus 1.\\n\\n- In the picture below, for the number in cyan, we popped the number to be removed in step `2` and step `3`, thus the cyan number will be removed in step `3 + 1`.\\n\\n![image](https://assets.leetcode.com/users/images/b900917d-5720-4a68-8b43-0f70c2210a6e_1653798222.1953542.png)\\n\\n- If we removed every number from stack, meaning the current number `A[i]` is the largest number so far and it will never be removed, thus its step number is `0`. \\n\\n![image](https://assets.leetcode.com/users/images/dd9cc664-2cb6-414f-b8ed-18fe219fae9e_1653798225.6963656.png)\\n\\n\\n\\n\\nThe final walkthrough, the numbers in the stack after each step are colored in dark:\\n\\n![image](https://assets.leetcode.com/users/images/a08cd076-8ca7-4059-a3f1-fc130745676c_1653798229.5009136.png)\\n\\n\\n**python**\\n```\\ndef totalSteps(self, A: List[int]) -> int:    \\n        st = [[A[0], 0]]\\n        ans = 0\\n        \\n        for a in A[1:]:\\n            t = 0\\n            while st and st[-1][0] <= a:\\n                t = max(t, st[-1][1])\\n                st.pop()\\n            if st: \\n                t += 1\\n            else:\\n                t = 0\\n            ans = max(ans, t)\\n            st.append([a, t])\\n            \\n        return ans\\n```\\n\\nYou might notice \\n\\n",
                "solutionTags": [],
                "code": "```\\ndef totalSteps(self, A: List[int]) -> int:    \\n        st = [[A[0], 0]]\\n        ans = 0\\n        \\n        for a in A[1:]:\\n            t = 0\\n            while st and st[-1][0] <= a:\\n                t = max(t, st[-1][1])\\n                st.pop()\\n            if st: \\n                t += 1\\n            else:\\n                t = 0\\n            ans = max(ans, t)\\n            st.append([a, t])\\n            \\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2085653,
                "title": "python3-stack",
                "content": "Consider the list in reversed direction. We record each element and the number of remove operations needed to execute after this element. When we push a new element, compare it with the top element. If it is larger, then we need to perform a remove operation.\\nCode:\\n```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        ans = 0\\n        nums.reverse()\\n        lst = [[nums[0], 0]]\\n        for i in range(1, len(nums)):\\n            cnt = 0\\n            while lst and lst[-1][0] < nums[i]:\\n                cnt = max(cnt + 1, lst[-1][1])\\n                lst.pop()\\n            lst.append([nums[i], cnt])\\n            ans = max(ans, cnt)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        ans = 0\\n        nums.reverse()\\n        lst = [[nums[0], 0]]\\n        for i in range(1, len(nums)):\\n            cnt = 0\\n            while lst and lst[-1][0] < nums[i]:\\n                cnt = max(cnt + 1, lst[-1][1])\\n                lst.pop()\\n            lst.append([nums[i], cnt])\\n            ans = max(ans, cnt)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2115834,
                "title": "monostack-with-counter",
                "content": "I think that it\\'s a very challenging problem. We need to use two techniques - monostrack and DP - to solve it.\\n\\nThe idea is to go right to left, and build a decreasing strack. When we remove elements from the stack, we count how many elements we removed in `cnt`. Then, we store that count along with the element on the stack. That way, for each element in the stack, we know how many operations are needed to remove all smaller elements after it.\\n\\nIn the example below, we pop 4 smaller elements from the stack before inserting `nums[7]`. We store `nums[7]` in the stack along with the number of popped elements (`4`).\\n\\nNow, the important part. Before inserting `nums[4]`, we pop `nums[5]`, `nums[6]`, and also `nums[7]`. The counter for `nums[7]` is 4 (elements popped for `nums[7]`). So, we need to 4 operations to remove elements `[5..11]`:\\n- `nums[7]` removes `[8, 9]` in two operations, while `nums[4]` removes `[5, 6]`.\\n- `nums[4]` removes `nums[7]` and `nums[7]` removes `[10]` in one operation.\\n- `nums[4]` removes `[11]`.\\n\\nFinally, `nums[4]` removes `nums[12]`  and `nums[13]`, and the total number of operations is 6. Following this logic, we see that the number of operations for `nums[0]` is 7.\\n\\n![image](https://assets.leetcode.com/users/images/323054ae-6c89-480e-8f62-fee3fb84810c_1654498119.7348688.png)\\n\\n**C++**\\n```cpp\\nint totalSteps(vector<int>& nums) {\\n    vector<array<int, 2>> st;\\n    for (int i = nums.size() - 1; i >= 0; --i) {\\n        int cnt = 0;\\n        while (!st.empty() && st.back()[1] < nums[i]) {\\n            cnt = max(cnt + 1, st.back()[0]);\\n            st.pop_back();\\n        }\\n        st.push_back({cnt, nums[i]});\\n    }\\n    return (*max_element(begin(st), end(st)))[0];\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint totalSteps(vector<int>& nums) {\\n    vector<array<int, 2>> st;\\n    for (int i = nums.size() - 1; i >= 0; --i) {\\n        int cnt = 0;\\n        while (!st.empty() && st.back()[1] < nums[i]) {\\n            cnt = max(cnt + 1, st.back()[0]);\\n            st.pop_back();\\n        }\\n        st.push_back({cnt, nums[i]});\\n    }\\n    return (*max_element(begin(st), end(st)))[0];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2086003,
                "title": "no-dp-no-stack-directly-simulate-o-n-log-n",
                "content": "I saw many solutions using stack and dp, which is probably a better solution than mine.\\nHowever, I\\'d like to share an easier solution which requires much less thinking.\\n\\nNotice that the number of deletions is bounded by N. Even if it takes N rounds to reach the end, the total amount of deletions cannot be worse than O(N). \\n\\nLet us use an ordered map to track the relative ordering of the numbers. The key is their original index, and the value is their original value.\\n\\nTo initialize the map, we can populate it with (index, element) key-value pairs. At the same time, we keep track of which indices we need to delete in the first round in an array called `del`.\\n\\nThen, we loop until there is nothing left to delete.\\nIn a single round of deletions, we can remove all the elements in `del`. This will change the \"next\" element of ONLY the one before it in the relative ordering. So, we then consider all the elements whose \"next\" value has changed, and we add new deletions as necessary. \\n\\nAgain, the total amount of deletions is fixed, so no matter how many rounds there are, the complexity will be at worst O(N log N). The ordered map lets us find the \"next\" and \"previous\" elements in log N time, and helps us maintain the relative ordering while we simulate the deletions.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    using pi = pair<int, int>;\\n    int totalSteps(vector<int>& nums) {\\n        int N = nums.size();\\n        map<int, int> mp;\\n        vector<pi> del;    // stores pairs of (previous id, toDelete id)\\n        for (int i = 0; i < N; ++i) {\\n            mp[i] = nums[i];\\n            if (i+1 < N && nums[i] > nums[i+1])\\n                del.emplace_back(i, i+1);\\n        }\\n\\n        int ans = 0;  // number of rounds\\n        while (!del.empty()) {\\n            ++ans;\\n            vector<pi> nxt;  // pairs to delete in the next round\\n            for (auto [i,j] : del) mp.erase(j);   // first, get rid of the required deletions\\n            for (auto [i,j] : del) {\\n                auto it = mp.find(i);\\n                if ( it == end(mp) || next(it) == end(mp) )   // if it\\'s not in the map anymore,\\n                    continue;                   // OR if it\\'s the last element, skip it\\n                auto itn = next(it);            // now compare against next element in the ordering\\n                if (it->second > itn->second)   \\n                    nxt.emplace_back(it->first, itn->first);  // add the (current id, toDelete id)\\n            }\\n            swap(nxt, del);  // nxt is the new del\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    using pi = pair<int, int>;\\n    int totalSteps(vector<int>& nums) {\\n        int N = nums.size();\\n        map<int, int> mp;\\n        vector<pi> del;    // stores pairs of (previous id, toDelete id)\\n        for (int i = 0; i < N; ++i) {\\n            mp[i] = nums[i];\\n            if (i+1 < N && nums[i] > nums[i+1])\\n                del.emplace_back(i, i+1);\\n        }\\n\\n        int ans = 0;  // number of rounds\\n        while (!del.empty()) {\\n            ++ans;\\n            vector<pi> nxt;  // pairs to delete in the next round\\n            for (auto [i,j] : del) mp.erase(j);   // first, get rid of the required deletions\\n            for (auto [i,j] : del) {\\n                auto it = mp.find(i);\\n                if ( it == end(mp) || next(it) == end(mp) )   // if it\\'s not in the map anymore,\\n                    continue;                   // OR if it\\'s the last element, skip it\\n                auto itn = next(it);            // now compare against next element in the ordering\\n                if (it->second > itn->second)   \\n                    nxt.emplace_back(it->first, itn->first);  // add the (current id, toDelete id)\\n            }\\n            swap(nxt, del);  // nxt is the new del\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2090668,
                "title": "explained-solution-for-mere-mortals-100-faster",
                "content": "FIrst rephrase the problem.\\nBig eats small.\\nWhat is maximum number of right elements an element can eat.\\nTake a example [15,14,13]\\nIt seems 15 can eat 2 elements, but 14 will eat 13 while 15 is eating 14.\\nHence answer is 1\\nTake another example [16,15,13,14]\\nWhile 16 is eating 15, 15 will eat 13 and 14 will be left to be eaten by 16.\\nHence answer is 2.\\nTake another example [16,4,5,6,13,12]\\nWhile 16 will eat 4,5 and 6, 13 would have already eaten 12, hence answer is 4.\\n\\nWe maintain a stack which stores elements in decreasing order from back.\\nWHY? Because if some biggger number comes, it will eat smaller ones and we will do some calculations there.\\nWHAT calculations? If current element is bigger than top of stack, what does it mean?\\nIt can eat it, so what will be answer? Max of number of elements already eaten by current element + 1 and max elements that top of stack can eat if current element doesn\\'t eat it.\\n\\nRead that element lots of times, it\\'s hard to understand.\\n```                maxEat[i] = max(maxEat[i]+1, maxEat[s.top()]);```\\nHere I was struggling to understand\\nIf bigger element has already eaten 3 elements and now is going to eat\\nsmaller element which has already eaten 4 elements\\nWhy answer won\\'t be 3+4?\\nBecause everyone is eating simultaneuosly, while bigger was eating other 3 elements\\nsmaller was eating other three too, then what\\'s left now for bigger element is only smaller element, not the elements smaller than smaller element.\\n\\nBelow is my code:\\n\\n```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        vector<int> maxEat(nums.size()); \\n        stack<int> st;\\n        int steps = 0; \\n        for(int i = nums.size()-1 ; i>=0 ; i--){\\n            while(!st.empty() && nums[i] > nums[s.top()]){\\n                maxEat[i] = max(maxEat[i]+1, maxEat[s.top()]);\\n\\t\\t\\t\\tst.pop();\\n            }\\n            st.push(i);\\n            steps = max(steps, maxEat[i]);\\n        }\\n        return steps;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```                maxEat[i] = max(maxEat[i]+1, maxEat[s.top()]);```",
                "codeTag": "Unknown"
            },
            {
                "id": 2290383,
                "title": "detailed-intuitive-explanation",
                "content": "Don\\'t think of any algo or data structure at first, let\\'s build the solution from scratch \\uD83D\\uDE0E\\n\\nlet\\'s see few test cases\\n\\n[10, 4, 5, 6]\\n\\nlet\\'s go from left to right\\nas 10 > 4 so in round 1, 4 will be removed,\\n10>5, remove 5 in round 2\\n10>6, remove 6 in round 3\\n\\nSo using just above test case while going left to right you can observe 1 thing\\n   1) As 10 was greater than 4,5,6 so it will remove everyone who is lesser than 10 to it\\'s right\\n   \\n\\uD835\\uDDDC\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDEF\\uD835\\uDDFC\\uD835\\uDE03\\uD835\\uDDF2 \\uD835\\uDDFC\\uD835\\uDDEF\\uD835\\uDE00\\uD835\\uDDF2\\uD835\\uDDFF\\uD835\\uDE03\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF6\\uD835\\uDDFC\\uD835\\uDDFB \\uD835\\uDE03\\uD835\\uDDEE\\uD835\\uDDF9\\uD835\\uDDF6\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDFC\\uD835\\uDDFF \\uD835\\uDDEE\\uD835\\uDDF9\\uD835\\uDDF9 \\uD835\\uDE01\\uD835\\uDDF2\\uD835\\uDE00\\uD835\\uDE01 \\uD835\\uDDF0\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDDF2\\uD835\\uDE00 ?\\n\\n let\\'s see 1 more test case\\n\\n[10, 4, 5, 6, 3, 4]\\n\\nAs per our initial observation, 10 is greater than all 5 elements so it should remove all 5 and thus our answer should be 5 (\\uD835\\uDDF6\\uD835\\uDE00 \\uD835\\uDDF6\\uD835\\uDE01 \\uD835\\uDE01\\uD835\\uDDFF\\uD835\\uDE02\\uD835\\uDDF2 ??)\\n\\nremember the condition -> \\uD835\\uDDF6\\uD835\\uDDF3(\\uD835\\uDDFB\\uD835\\uDE02\\uD835\\uDDFA\\uD835\\uDE00[\\uD835\\uDDF6-\\uD835\\uDFED] > \\uD835\\uDDFB\\uD835\\uDE02\\uD835\\uDDFA\\uD835\\uDE00[\\uD835\\uDDF6]) \\uD835\\uDDFF\\uD835\\uDDF2\\uD835\\uDDFA\\uD835\\uDDFC\\uD835\\uDE03\\uD835\\uDDF2 \\uD835\\uDDFB\\uD835\\uDE02\\uD835\\uDDFA\\uD835\\uDE00[\\uD835\\uDDF6]\\n\\nSee the 4th element (6) as 6 > 3 & 6 > 4,\\nso 6 would remove both 3 & 4 in 2 rounds, 10 should remove 4,5,6 in 3 rounds so total 3 rounds are required\\n\\nNow what can we conclude from above test case ??\\n   1) Instead of going from l to r, we would go r to l (else we would get higher no. of rounds)\\n\\n[10, 4, 5, 6, 3, 4]\\n\\nlets start from rightmost element , we encounter 3,4 then 6\\nWhen we get 6 which is greater than 3,4 & will remove them thus 3,4 should be removed(popped) which also tells us to use \\n\\uD835\\uDE00\\uD835\\uDE01\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDF1\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDEE \\uD835\\uDE00\\uD835\\uDE01\\uD835\\uDDFF\\uD835\\uDE02\\uD835\\uDDF0\\uD835\\uDE01\\uD835\\uDE02\\uD835\\uDDFF\\uD835\\uDDF2\\n\\nSo what all we got till now\\n\\t 1) Start from right\\n\\t 2) Use stack\\n\\t 3) For every nums[i] count all the elements less than it & remove these elements\\n\\t 4) Finally push nums[i]\\n\\nHere comes an \\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDF4\\uD835\\uDDF2 \\uD835\\uDDF0\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDDF2\\uD83D\\uDE0E\\n\\nnums[]                              = [10, 6, 4, 5, 8]\\n\\ngoing r to l\\n6 removes 4,5 in 2 rounds (mark this point) \\u26A0\\nnow, 10 will remove 6 & 8, so it\\'s should take 2 rounds right ???\\n\\nsee below array configuration till we reach 6 (r to l)\\n\\nnums[]                              = [10, 6, 4, 5, 8]\\ncountRemovedByNum[i] =  [ -, 2, 0, 0, 0]\\n\\nwhen you are at 10 (it removes 6 in 1st round while 6 removed 4,5 in 2 round, so overall we took 2 rounds to remove [6,4,5] so in 3rd round 8 will be removed) (i know it\\'s a bit confusing \\uD83D\\uDE05 but read it few times)\\n\\nSo in above test case when 10 removed 6 (r to l in stack) total rounds for 10 should be 2 not 1 (2 because 6 removed 4,5 in 2 rounds), so when 10 removes 8 we do round + 1 i.e. 2+1 = 3 (our answer)\\n\\nFinally using above test case we improvise our previous observations as\\n\\t1) Start from right\\n\\t 2) Use stack (insert pair<int, int> of num[i], cnt of rounds )\\n\\t 3) For every nums[i] count all the elements less than it & remove these elements\\n\\t 4) Finally push nums[i]\\n\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        \\n        stack<pair<int, int>> stk;\\n        \\n        int cnt = 0;\\n        int res = 0;\\n        \\n        for(int i = nums.size() - 1;i >= 0;i--) {\\n        \\n            cnt = 0;\\n            \\n            while(!stk.empty() && nums[i] > stk.top().first) {\\n                cnt = max(cnt+1, stk.top().second);\\n                stk.pop();\\n            }\\n            res = max(res, cnt);\\n            stk.push({nums[i], cnt});\\n            \\n        }\\n        return res;\\n    }\\n};\\n\\nps-> do upvote if you like the explanation & plss ignore typos (if any)\\n",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        \\n        stack<pair<int, int>> stk;\\n        \\n        int cnt = 0;\\n        int res = 0;\\n        \\n        for(int i = nums.size() - 1;i >= 0;i--) {\\n        \\n            cnt = 0;\\n            \\n            while(!stk.empty() && nums[i] > stk.top().first) {\\n                cnt = max(cnt+1, stk.top().second);\\n                stk.pop();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2085764,
                "title": "c-easy-o-n-with-monotonic-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) \\n    {\\n        int n=nums.size(),i,ans=0,cnt,prev;\\n        stack <pair<int,int>> st;\\n        st.push({nums[n-1],0});\\n        for(i=n-2;i>=0;i--)\\n        {\\n            cnt=0;\\n            while(!st.empty() && nums[i]>st.top().first)\\n            {\\n                cnt=max(cnt+1,st.top().second);\\n                st.pop();\\n            }\\n            ans=max(ans,cnt);\\n            st.push({nums[i],cnt});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) \\n    {\\n        int n=nums.size(),i,ans=0,cnt,prev;\\n        stack <pair<int,int>> st;\\n        st.push({nums[n-1],0});\\n        for(i=n-2;i>=0;i--)\\n        {\\n            cnt=0;\\n            while(!st.empty() && nums[i]>st.top().first)\\n            {\\n                cnt=max(cnt+1,st.top().second);\\n                st.pop();\\n            }\\n            ans=max(ans,cnt);\\n            st.push({nums[i],cnt});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085808,
                "title": "java-mono-stack-o-n",
                "content": "traverse from back. If number in stack less than current number, count into removal steps. If removal steps in stack great than current count, that difference need be added to current count as that stack number already removal by current number before it removal rest of other numbers.\\n```\\n    public int totalSteps(int[] nums) {\\n        int ans = 0;\\n        Stack<int[]> stack = new Stack<int[]>();\\n        for(int i = nums.length-1; i >= 0; i--) {\\n            if(stack.isEmpty() || stack.peek()[0] >= nums[i]) {\\n                stack.push(new int[]{nums[i], 0});\\n            }else{\\n                int count = 0;\\n                while(!stack.isEmpty() && stack.peek()[0] < nums[i]) {\\n                    count++;\\n                    int[] item = stack.pop();\\n                    if(count < item[1]) count += (item[1] - count);\\n                }\\n                stack.push(new int[]{nums[i], count});\\n                ans = Math.max(ans, count);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int totalSteps(int[] nums) {\\n        int ans = 0;\\n        Stack<int[]> stack = new Stack<int[]>();\\n        for(int i = nums.length-1; i >= 0; i--) {\\n            if(stack.isEmpty() || stack.peek()[0] >= nums[i]) {\\n                stack.push(new int[]{nums[i], 0});\\n            }else{\\n                int count = 0;\\n                while(!stack.isEmpty() && stack.peek()[0] < nums[i]) {\\n                    count++;\\n                    int[] item = stack.pop();\\n                    if(count < item[1]) count += (item[1] - count);\\n                }\\n                stack.push(new int[]{nums[i], count});\\n                ans = Math.max(ans, count);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2086026,
                "title": "o-n-simulation-no-stack-with-commented-python-code",
                "content": "We literally just simulate the process of numbers \"eating\" smaller numbers to the right. \\nWe maintain a list of numbers that are still active(still eating)\\nEvery time a number eats the number to its right, it jumps to that index. So if index 5 eats index 6, this number jumps to index 6.\\n\\nThe difficult part to get is that what if the number at index 6 is at say index 8 ? We jump index 5 to index 8, ie index[index[6]]\\nthis makes sure that index 5 doesnt re-eat the numbers that 6 ate, and also index 5 can continue eating from where index 6 left off.\\n\\nThe time complexity is O(n) as every number gets eaten only once\\n\\nlmk if this explanation is not clear, i will re-write it\\n\\n```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        \\n        # length of the array\\n        n = len(nums)\\n        \\n        # current index of each element in the simulation\\n        index = [i for i in range(n)]\\n        \\n        # number of elements swallowed by the number at index i\\n        count = [0 for i in range(n)]\\n        \\n        # list of all actively swallowing indices\\n        active = [i for i in reversed(range(n))]\\n        \\n        while(len(active) > 0):\\n            new_active = []\\n            for i in active:\\n                num = nums[i]\\n                cur_index = index[i]\\n                \\n                # either this index has reached the end of the array or has encountered a larger element\\n                if cur_index == n - 1 or nums[cur_index + 1] >= num:\\n                    continue\\n                \\n                # this element has just swallowed, it\\'s still active\\n                new_active.append(i)\\n                \\n                # IMPORTANT\\n                # jump this numbers index to the index of who he just swallowed\\n                index[i] = index[cur_index + 1]\\n                count[i] += 1\\n                \\n            # update the list of active indices\\n            active = new_active\\n        \\n        # return the max number of swallows\\n        return max(count)\\n```",
                "solutionTags": [
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        \\n        # length of the array\\n        n = len(nums)\\n        \\n        # current index of each element in the simulation\\n        index = [i for i in range(n)]\\n        \\n        # number of elements swallowed by the number at index i\\n        count = [0 for i in range(n)]\\n        \\n        # list of all actively swallowing indices\\n        active = [i for i in reversed(range(n))]\\n        \\n        while(len(active) > 0):\\n            new_active = []\\n            for i in active:\\n                num = nums[i]\\n                cur_index = index[i]\\n                \\n                # either this index has reached the end of the array or has encountered a larger element\\n                if cur_index == n - 1 or nums[cur_index + 1] >= num:\\n                    continue\\n                \\n                # this element has just swallowed, it\\'s still active\\n                new_active.append(i)\\n                \\n                # IMPORTANT\\n                # jump this numbers index to the index of who he just swallowed\\n                index[i] = index[cur_index + 1]\\n                count[i] += 1\\n                \\n            # update the list of active indices\\n            active = new_active\\n        \\n        # return the max number of swallows\\n        return max(count)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424650,
                "title": "best-solution-explain-in-c-dry-run",
                "content": "lets take example as \\n[ 14 , 2 , 6 , 8 , 10 , 15 , 4 , 9 , 10 , 6 , 10 , 10 , 12 , 9 , 1 ] \\n\\nnow lets see a intution first  \\n\\na = 14             ans = 0 [  already decreasing ]\\n\\na =  14 , 2       ans = 1   [ remove 2] \\n\\na = 14 , 2 , 6   ans = 2  [ remove 2 , 6] \\n\\na = 14 , 2 , 6 , 8   ans = 3  [ remove  2 , 6 , 8 ] \\n\\na = 14 , 2 , 6 , 8 , 10  ans = 4 [ remove 2 , 6 , 8 , 10 ] \\n\\na = 14 , 2, 6 , 8 , 10 , 15   ans = 4  [ remove 2 , 6 , 8 , 10 ]   => 14 15    [ non - decreasing ] \\n\\na = 14 , 2 , 6 , 8 , 10 , 15 , 4   ans = 4    \\n\\nnow here we can see that we can parallely kill 4 in our first step  of killing 2  \\n\\nbasically , \\n\\n![image](https://assets.leetcode.com/users/images/a94601dc-0223-44bd-8e21-7a12ee9bfaab_1660480151.7467067.png)\\n\\nso clearly our ans = 4 in this case as well \\n\\nlets continue \\n\\na = 14, 2 ,6 , 8 , 10 , 15 , 4  , 9   ans = 4  \\nas 4 , 9  will be removed along with 2 , 6 and then 8 , 10  will be removed  \\n\\na = 14 , 2 , 6 , 8 , 10 , 15 , 4 , 9 , 10    ans =  4 \\nas 4 ,9 , 10 will be simulatenously removed along with 2 , 6 , 8  and then  10  will be removed  \\n\\nnow  lets add upto 3 more values \\n\\n\\na =  14 , 2 , 6, 8 , 10 , 15 , 4 , 9 , 10 , 6 , 10 , 10 , 10 \\n\\n![image](https://assets.leetcode.com/users/images/372ca49b-2a0d-4158-b298-7d6ab0bba9da_1660480403.3717368.png)\\n\\nnow here simulatenosuly 2  , 4 , 6 will be removed and then we can see that \\nbefore 15 we have to remove 3 more elements and after 15 we have to removed 5 more elements \\n\\n\\nso hopefully the intution is build  -> basically we will see like this whenever we find at index i \\nsuch that a[i - 1 ] > a[i]  we start deleting it parallely and we find the region where max deletion happens and that becomes our ans \\n\\n\\nnow so we can see that we need to know the next greater element here and as well as we have to know the result from the previous situation \\n\\nso we introduce dp in our ans now  \\n\\nwe create a dp table and at each state we store the answer for the remaning values to the right \\n\\n![image](https://assets.leetcode.com/users/images/78019bbc-eccb-487b-816b-994f0a673fde_1660480824.4858902.png)\\n\\nnow lets start our iteration one by one  \\n\\n\\nhere  number of elements (n ) = 15 \\n\\nso we start  our loop from behind and maintain a stack to find the next greater element [you should be aware about next greater element , otherwise you wont get a feel of what is happening next ] \\n\\n\\n![image](https://assets.leetcode.com/users/images/81c15022-175e-4c1c-8e07-28d05de31fa3_1660481004.4170446.png)\\nhere is our solution  which we will dry run now  \\n\\n\\n# i = 14 \\nstack  =  [  14 ] \\n\\n\\n\\n\\ndp table \\n\\n![image](https://assets.leetcode.com/users/images/680de1d3-d462-418a-a65f-d83a9c6d013d_1660481104.849981.png)\\n\\n\\n\\n\\n# i = 13  \\n\\n9 > 1  so we will enter into our condition  \\n\\ns.top = 14 \\n\\nhere we basically want to delete our next element and compare it with the ans for that element \\n\\n\\nso  dp[13] = max( dp[13] + 1 , dp[ 14] ) ;\\n\\nand we removed 14 from stack and push 13  now \\n\\nstack =  [ 13] \\n\\ndp table \\n![image](https://assets.leetcode.com/users/images/d6fb2dbb-9cc1-4187-bc59-e61943955fa2_1660481220.6860945.png)\\n\\n \\n# i = 12   \\nnow 12 > 9    \\nso we again move into the condition \\nand same we compare our ans for the element at top and our ans with our index + 1  for deleting the top element \\n\\nso dp[12] = max(dp[12] + 1 , dp[13]  \\n\\nnow at dp[13] = 1 \\nand dp[12] + 1  = 1 \\nso dp[12]  = 1  \\nand remove  13 \\n\\ndp table \\n![image](https://assets.leetcode.com/users/images/baf28c6b-d21d-487c-b54d-5268f4a30cf0_1660481355.0549781.png)\\n\\n# i = 11 \\n\\n10 < 12 \\nso push it  \\n\\nstack =  [ 11 , 12 ] \\n\\n\\n# i = 10  \\n10 ! > 10 \\n\\nso push it  \\n\\n\\nstack =   [10 , 11 , 12 ] \\n\\n\\n# i =  9 \\n\\n9 < 10 \\npush it  \\n\\nstack = [ 9 , 10 , 11 , 12 ] \\n\\n# i = 8 \\n \\n10 > 6 \\n\\nwe enter into the conditon st.top = 9 \\n\\ndp[8] = max(dp[8] + 1 , dp[9]) \\n\\ndp[8] = 1 \\n\\nremove  9  from the stack and push 8 \\n\\nstack  = [ 8 , 10 , 11 , 12]  \\n\\ndp table \\n\\n![image](https://assets.leetcode.com/users/images/2f91aa0b-edf8-402a-b4ab-6f37c15323d1_1660481819.2037504.png)\\n\\n\\n# i = 7 \\n\\n9 < 10 \\n\\npush 7  \\n\\nstack = [ 7 , 8  , 10 , 11 , 12 ] \\n\\n# i = 6   \\n\\n4 < 9 \\n\\npush 6 \\n\\nstack =  [ 6 , 7 , 8 , 10 , 11 , 12 ] \\n\\ndp table \\n\\n![image](https://assets.leetcode.com/users/images/44be38f2-6f15-49f0-8c28-4f1b03a89f99_1660481964.5189054.png)\\n\\n\\n# i = 5 [very important part now ]\\n\\nnow  15 > 4  \\n\\ncondition is ok  \\n\\ndp[5]  = max(dp[5] + 1 , dp[6]) \\n\\ndp[5] = 1  \\n\\nremove 6 \\n\\nstack = [ 7 ,  8 , 10 , 11 , 12] \\ndp table  \\n\\n\\n![image](https://assets.leetcode.com/users/images/c897ecf8-4b0f-4999-9377-cc566d2bd4c4_1660482012.5437205.png)\\n\\n\\n\\n\\n15 > 9  \\n\\ncondition ok  \\n\\ndp[5] = max(dp[5] + 1 , dp[7]) \\n\\ndp[5] = max( 2 , 0) \\n\\ndp[5] = 2 \\n\\n\\nremove 7  from stack  \\n\\n\\nstack =  [ 8 , 10 , 11 , 12 ] \\n\\ndp table  \\n\\n![image](https://assets.leetcode.com/users/images/c4aaf549-59e0-4f79-a5c4-cb28f8b5abda_1660482116.5252256.png)\\n\\n\\n15 > 10  \\nconditon ok again  \\n\\ndp[5] = max(dp[5] + 1 , dp[8]);\\n\\ndp[5]  = max ( 3 , 1 ) \\n\\ndp[5] = 3  \\n\\nremove 8 from stack \\n\\nstack = [10 , 11 , 12 ] \\n\\ndp table \\n![image](https://assets.leetcode.com/users/images/61eb09c0-17f8-4556-8801-fe496228c22e_1660482228.8710887.png)\\n\\n15 > 10   \\n\\nconditon ok again  \\n\\ndp[5] = max(dp[5] + 1 , dp[10]) ; =  max( 4 , 1 ) = 4 \\n\\n\\nremove 10  from stack \\n\\nstack =  [ 11,  12 ] \\n\\ndp table  \\n\\n![image](https://assets.leetcode.com/users/images/89d17b1c-4cb1-4e9e-b552-17546898ebb3_1660482560.42895.png)\\n\\n\\n15 > 10  \\n\\nconditon ok \\n\\ndp[5] = max(dp[5] + 1 , dp[11]) =  max( 5, 1 )  = 5 \\n\\ndp[5] = 5  \\n\\nremove 11 from stack  \\nstack =  [12 ]  \\ndp table \\n![image](https://assets.leetcode.com/users/images/b9529cd8-7285-47df-a6f9-81b28d057ade_1660482620.131915.png)\\n\\n\\n15  > 12   \\ncondition ok  \\n\\ndp[5] = max(dp[5] + 1 , dp[12]) =  6  \\n\\ndp[5] = 6 \\n\\nremove 12 from stack    and add 5   \\n\\nstack =  [5] \\n\\ndp table  \\n![image](https://assets.leetcode.com/users/images/6e25146d-32a8-4375-97e5-cf029cc56027_1660482711.8644836.png)\\n\\n\\n# i = 4  \\n\\n10 < 15  \\n\\npush  into stack  \\nstack = [4  , 5 ] \\n\\n# i = 3 \\n8 < 10 \\n\\npush into stack  = [ 3 , 4 , 5]  \\n\\n\\n# i = 2 \\n\\n6 < 8 \\npush into stack    =  [ 2 , 3 , 4 , 5 ] \\n\\n# i = 1  \\n\\n2 < 6  \\npush into stack  =  [ 1 , 2 , 3 , 4 , 5 ] \\n\\n\\n# i = 0     \\n\\n14 >  2 \\nconditon ok  \\ndp[0] = max(dp[0] + 1 , dp[1] ) \\n\\npop 1 from stack   stack =  [  2,  3 , 4 , 5 ]  \\n\\nsimilary 14 > 6 , 14 > 8 , 14 > 10  \\n\\nwill give dp[0] =  1 + 1 + 1 +1   = 4 \\n\\nand finally our solution ends at 15  \\nand loop breaks  \\n\\n\\nfinal dp  table  : \\n\\n![image](https://assets.leetcode.com/users/images/2dfec10e-9041-4d88-bb0c-022e635a3ccb_1660482933.3569784.png)\\n\\n\\nour ans = max of dp  table = 6   which is our ans  \\n\\n\\nverification : \\n\\n![image](https://assets.leetcode.com/users/images/3812492e-b1eb-42b6-a083-c1dd7983d378_1660483204.8307915.png)\\n\\n\\n\\nhence this solution is done now  !   \\n\\n\\nthis took a lot of efffort if you find it useful please share your thoughts   \\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Stack",
                    "Queue"
                ],
                "code": "lets take example as \\n[ 14 , 2 , 6 , 8 , 10 , 15 , 4 , 9 , 10 , 6 , 10 , 10 , 12 , 9 , 1 ] \\n\\nnow lets see a intution first  \\n\\na = 14             ans = 0 [  already decreasing ]\\n\\na =  14 , 2       ans = 1   [ remove 2] \\n\\na = 14 , 2 , 6   ans = 2  [ remove 2 , 6] \\n\\na = 14 , 2 , 6 , 8   ans = 3  [ remove  2 , 6 , 8 ] \\n\\na = 14 , 2 , 6 , 8 , 10  ans = 4 [ remove 2 , 6 , 8 , 10 ] \\n\\na = 14 , 2, 6 , 8 , 10 , 15   ans = 4  [ remove 2 , 6 , 8 , 10 ]   => 14 15    [ non - decreasing ] \\n\\na = 14 , 2 , 6 , 8 , 10 , 15 , 4   ans = 4    \\n\\nnow here we can see that we can parallely kill 4 in our first step  of killing 2  \\n\\nbasically , \\n\\n![image](https://assets.leetcode.com/users/images/a94601dc-0223-44bd-8e21-7a12ee9bfaab_1660480151.7467067.png)\\n\\nso clearly our ans = 4 in this case as well \\n\\nlets continue \\n\\na = 14, 2 ,6 , 8 , 10 , 15 , 4  , 9   ans = 4  \\nas 4 , 9  will be removed along with 2 , 6 and then 8 , 10  will be removed  \\n\\na = 14 , 2 , 6 , 8 , 10 , 15 , 4 , 9 , 10    ans =  4 \\nas 4 ,9 , 10 will be simulatenously removed along with 2 , 6 , 8  and then  10  will be removed  \\n\\nnow  lets add upto 3 more values \\n\\n\\na =  14 , 2 , 6, 8 , 10 , 15 , 4 , 9 , 10 , 6 , 10 , 10 , 10 \\n\\n![image](https://assets.leetcode.com/users/images/372ca49b-2a0d-4158-b298-7d6ab0bba9da_1660480403.3717368.png)\\n\\nnow here simulatenosuly 2  , 4 , 6 will be removed and then we can see that \\nbefore 15 we have to remove 3 more elements and after 15 we have to removed 5 more elements \\n\\n\\nso hopefully the intution is build  -> basically we will see like this whenever we find at index i \\nsuch that a[i - 1 ] > a[i]  we start deleting it parallely and we find the region where max deletion happens and that becomes our ans \\n\\n\\nnow so we can see that we need to know the next greater element here and as well as we have to know the result from the previous situation \\n\\nso we introduce dp in our ans now  \\n\\nwe create a dp table and at each state we store the answer for the remaning values to the right \\n\\n![image](https://assets.leetcode.com/users/images/78019bbc-eccb-487b-816b-994f0a673fde_1660480824.4858902.png)\\n\\nnow lets start our iteration one by one  \\n\\n\\nhere  number of elements (n ) = 15 \\n\\nso we start  our loop from behind and maintain a stack to find the next greater element [you should be aware about next greater element , otherwise you wont get a feel of what is happening next ] \\n\\n\\n![image](https://assets.leetcode.com/users/images/81c15022-175e-4c1c-8e07-28d05de31fa3_1660481004.4170446.png)\\nhere is our solution  which we will dry run now  \\n\\n\\n# i = 14 \\nstack  =  [  14 ] \\n\\n\\n\\n\\ndp table \\n\\n![image](https://assets.leetcode.com/users/images/680de1d3-d462-418a-a65f-d83a9c6d013d_1660481104.849981.png)\\n\\n\\n\\n\\n# i = 13  \\n\\n9 > 1  so we will enter into our condition  \\n\\ns.top = 14 \\n\\nhere we basically want to delete our next element and compare it with the ans for that element \\n\\n\\nso  dp[13] = max( dp[13] + 1 , dp[ 14] ) ;\\n\\nand we removed 14 from stack and push 13  now \\n\\nstack =  [ 13] \\n\\ndp table \\n![image](https://assets.leetcode.com/users/images/d6fb2dbb-9cc1-4187-bc59-e61943955fa2_1660481220.6860945.png)\\n\\n \\n# i = 12   \\nnow 12 > 9    \\nso we again move into the condition \\nand same we compare our ans for the element at top and our ans with our index + 1  for deleting the top element \\n\\nso dp[12] = max(dp[12] + 1 , dp[13]  \\n\\nnow at dp[13] = 1 \\nand dp[12] + 1  = 1 \\nso dp[12]  = 1  \\nand remove  13 \\n\\ndp table \\n![image](https://assets.leetcode.com/users/images/baf28c6b-d21d-487c-b54d-5268f4a30cf0_1660481355.0549781.png)\\n\\n# i = 11 \\n\\n10 < 12 \\nso push it  \\n\\nstack =  [ 11 , 12 ] \\n\\n\\n# i = 10  \\n10 ! > 10 \\n\\nso push it  \\n\\n\\nstack =   [10 , 11 , 12 ] \\n\\n\\n# i =  9 \\n\\n9 < 10 \\npush it  \\n\\nstack = [ 9 , 10 , 11 , 12 ] \\n\\n# i = 8 \\n \\n10 > 6 \\n\\nwe enter into the conditon st.top = 9 \\n\\ndp[8] = max(dp[8] + 1 , dp[9]) \\n\\ndp[8] = 1 \\n\\nremove  9  from the stack and push 8 \\n\\nstack  = [ 8 , 10 , 11 , 12]  \\n\\ndp table \\n\\n![image](https://assets.leetcode.com/users/images/2f91aa0b-edf8-402a-b4ab-6f37c15323d1_1660481819.2037504.png)\\n\\n\\n# i = 7 \\n\\n9 < 10 \\n\\npush 7  \\n\\nstack = [ 7 , 8  , 10 , 11 , 12 ] \\n\\n# i = 6   \\n\\n4 < 9 \\n\\npush 6 \\n\\nstack =  [ 6 , 7 , 8 , 10 , 11 , 12 ] \\n\\ndp table \\n\\n![image](https://assets.leetcode.com/users/images/44be38f2-6f15-49f0-8c28-4f1b03a89f99_1660481964.5189054.png)\\n\\n\\n# i = 5 [very important part now ]\\n\\nnow  15 > 4  \\n\\ncondition is ok  \\n\\ndp[5]  = max(dp[5] + 1 , dp[6]) \\n\\ndp[5] = 1  \\n\\nremove 6 \\n\\nstack = [ 7 ,  8 , 10 , 11 , 12] \\ndp table  \\n\\n\\n![image](https://assets.leetcode.com/users/images/c897ecf8-4b0f-4999-9377-cc566d2bd4c4_1660482012.5437205.png)\\n\\n\\n\\n\\n15 > 9  \\n\\ncondition ok  \\n\\ndp[5] = max(dp[5] + 1 , dp[7]) \\n\\ndp[5] = max( 2 , 0) \\n\\ndp[5] = 2 \\n\\n\\nremove 7  from stack  \\n\\n\\nstack =  [ 8 , 10 , 11 , 12 ] \\n\\ndp table  \\n\\n![image](https://assets.leetcode.com/users/images/c4aaf549-59e0-4f79-a5c4-cb28f8b5abda_1660482116.5252256.png)\\n\\n\\n15 > 10  \\nconditon ok again  \\n\\ndp[5] = max(dp[5] + 1 , dp[8]);\\n\\ndp[5]  = max ( 3 , 1 ) \\n\\ndp[5] = 3  \\n\\nremove 8 from stack \\n\\nstack = [10 , 11 , 12 ] \\n\\ndp table \\n![image](https://assets.leetcode.com/users/images/61eb09c0-17f8-4556-8801-fe496228c22e_1660482228.8710887.png)\\n\\n15 > 10   \\n\\nconditon ok again  \\n\\ndp[5] = max(dp[5] + 1 , dp[10]) ; =  max( 4 , 1 ) = 4 \\n\\n\\nremove 10  from stack \\n\\nstack =  [ 11,  12 ] \\n\\ndp table  \\n\\n![image](https://assets.leetcode.com/users/images/89d17b1c-4cb1-4e9e-b552-17546898ebb3_1660482560.42895.png)\\n\\n\\n15 > 10  \\n\\nconditon ok \\n\\ndp[5] = max(dp[5] + 1 , dp[11]) =  max( 5, 1 )  = 5 \\n\\ndp[5] = 5  \\n\\nremove 11 from stack  \\nstack =  [12 ]  \\ndp table \\n![image](https://assets.leetcode.com/users/images/b9529cd8-7285-47df-a6f9-81b28d057ade_1660482620.131915.png)\\n\\n\\n15  > 12   \\ncondition ok  \\n\\ndp[5] = max(dp[5] + 1 , dp[12]) =  6  \\n\\ndp[5] = 6 \\n\\nremove 12 from stack    and add 5   \\n\\nstack =  [5] \\n\\ndp table  \\n![image](https://assets.leetcode.com/users/images/6e25146d-32a8-4375-97e5-cf029cc56027_1660482711.8644836.png)\\n\\n\\n# i = 4  \\n\\n10 < 15  \\n\\npush  into stack  \\nstack = [4  , 5 ] \\n\\n# i = 3 \\n8 < 10 \\n\\npush into stack  = [ 3 , 4 , 5]  \\n\\n\\n# i = 2 \\n\\n6 < 8 \\npush into stack    =  [ 2 , 3 , 4 , 5 ] \\n\\n# i = 1  \\n\\n2 < 6  \\npush into stack  =  [ 1 , 2 , 3 , 4 , 5 ] \\n\\n\\n# i = 0     \\n\\n14 >  2 \\nconditon ok  \\ndp[0] = max(dp[0] + 1 , dp[1] ) \\n\\npop 1 from stack   stack =  [  2,  3 , 4 , 5 ]  \\n\\nsimilary 14 > 6 , 14 > 8 , 14 > 10  \\n\\nwill give dp[0] =  1 + 1 + 1 +1   = 4 \\n\\nand finally our solution ends at 15  \\nand loop breaks  \\n\\n\\nfinal dp  table  : \\n\\n![image](https://assets.leetcode.com/users/images/2dfec10e-9041-4d88-bb0c-022e635a3ccb_1660482933.3569784.png)\\n\\n\\nour ans = max of dp  table = 6   which is our ans  \\n\\n\\nverification : \\n\\n![image](https://assets.leetcode.com/users/images/3812492e-b1eb-42b6-a083-c1dd7983d378_1660483204.8307915.png)\\n\\n\\n\\nhence this solution is done now  !   \\n\\n\\nthis took a lot of efffort if you find it useful please share your thoughts   \\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2085666,
                "title": "python3-increasing-stack",
                "content": "Reverse scan from right to left, maintain an increasing stack.\\nFor i<j and nums[i]>nums[j], the number of rounds for nums[i] to remove nums[j] is:\\n    1. If nums[j] takes 3 rounds to remove all smaller numbers on its right, then it will also take nums[i] same 3 rounds to remove nums[j], not 1 round. \\n    2. If nums[j] has nothing to remove on its right side, then nums[i] will take at least 1 round to remove nums[j].\\n\\n```\\n    def totalSteps(self, nums: List[int]) -> int:\\n        res,stack = 0, []\\n        for i in range(len(nums)-1,-1,-1):\\n            cur = 0\\n            while stack and nums[stack[-1][0]]<nums[i]:\\n                _,v = stack.pop()\\n                cur=max(cur+1,v)\\n            res = max(res,cur)\\n            stack.append([i,cur])\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    def totalSteps(self, nums: List[int]) -> int:\\n        res,stack = 0, []\\n        for i in range(len(nums)-1,-1,-1):\\n            cur = 0\\n            while stack and nums[stack[-1][0]]<nums[i]:\\n                _,v = stack.pop()\\n                cur=max(cur+1,v)\\n            res = max(res,cur)\\n            stack.append([i,cur])\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2086927,
                "title": "java-o-n-easy-understanding-just-simulate-by-double-linked-list",
                "content": "the key point of this question is that we can find the numbers need remove in next round from the previous round. The reason is that the numbers need remove in next round must be adjacent to some deleted number in current round.For example, [ 5, 2, 3, 4,], the first round we delete 2, the second round we delete 3, and 2 and 3 must be adjacent.\\nso we just need to do two things:\\n1.scan the numbers which need to delete in first step.\\n2.we delete the numbers.\\n3.then we check each deleted number\\'s next number whether it\\'s satisfied to delete in the next round.\\n3.repeat 2 and 3 until we can\\'t find new numbers to delete.\\nNoticing that we don\\'t scan the whole array so the complexity is NOT o(n2).   \\nThe tricky part is if we use array to store numbers, we can\\'t visit previous number of 3 by one step after we delete 2...So vey naturally\\uFF0C we can use linkedList to solve this problem.\\nSince we visit evey number which need delete only twice, so the whole time complexity is O(n)\\n```\\nclass Solution {\\n    class LinkedNode {\\n        LinkedNode pre, next;\\n        int val;\\n        boolean isDel;\\n        LinkedNode(int v){\\n            val = v;\\n        }\\n        void del() {\\n            if (this.pre != null)\\n                this.pre.next = this.next;\\n            if (this.next != null)\\n                this.next.pre = this.pre;\\n            this.isDel = true;\\n        }\\n        void add(LinkedNode node) {\\n            node.next = this.next;\\n            node.pre = this;\\n            if (this.next != null)\\n                this.next.pre = node;\\n            this.next = node;\\n        }\\n    }\\n    \\n    public int totalSteps(int[] nums) {\\n        int ans = 0;\\n        LinkedNode head = new LinkedNode(-1);\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            head.add(new LinkedNode(nums[i]));\\n        }\\n        List<LinkedNode> delList = new ArrayList<>();\\n        LinkedNode tmp = head.next, pre = head; \\n        while (tmp != null) {\\n            if (pre.val > tmp.val) {\\n                delList.add(tmp);\\n            }\\n            pre = tmp;\\n            tmp = tmp.next;\\n        }\\n        while (!delList.isEmpty()) {\\n            delList = remove(delList);\\n            ans++;\\n        }\\n        return ans;\\n    }\\n    \\n    List<LinkedNode> remove(List<LinkedNode> del) {\\n        for (LinkedNode node : del) {\\n            node.del();\\n        }\\n        List<LinkedNode> nextDel = new ArrayList<>();\\n        for (LinkedNode node : del) {\\n            if (node.next != null && !node.next.isDel && node.next.val < node.next.pre.val) {\\n                nextDel.add(node.next);\\n            }\\n        }\\n        return nextDel;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class LinkedNode {\\n        LinkedNode pre, next;\\n        int val;\\n        boolean isDel;\\n        LinkedNode(int v){\\n            val = v;\\n        }\\n        void del() {\\n            if (this.pre != null)\\n                this.pre.next = this.next;\\n            if (this.next != null)\\n                this.next.pre = this.pre;\\n            this.isDel = true;\\n        }\\n        void add(LinkedNode node) {\\n            node.next = this.next;\\n            node.pre = this;\\n            if (this.next != null)\\n                this.next.pre = node;\\n            this.next = node;\\n        }\\n    }\\n    \\n    public int totalSteps(int[] nums) {\\n        int ans = 0;\\n        LinkedNode head = new LinkedNode(-1);\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            head.add(new LinkedNode(nums[i]));\\n        }\\n        List<LinkedNode> delList = new ArrayList<>();\\n        LinkedNode tmp = head.next, pre = head; \\n        while (tmp != null) {\\n            if (pre.val > tmp.val) {\\n                delList.add(tmp);\\n            }\\n            pre = tmp;\\n            tmp = tmp.next;\\n        }\\n        while (!delList.isEmpty()) {\\n            delList = remove(delList);\\n            ans++;\\n        }\\n        return ans;\\n    }\\n    \\n    List<LinkedNode> remove(List<LinkedNode> del) {\\n        for (LinkedNode node : del) {\\n            node.del();\\n        }\\n        List<LinkedNode> nextDel = new ArrayList<>();\\n        for (LinkedNode node : del) {\\n            if (node.next != null && !node.next.isDel && node.next.val < node.next.pre.val) {\\n                nextDel.add(node.next);\\n            }\\n        }\\n        return nextDel;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086010,
                "title": "c-100-efficient",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        vector<int> a(nums.size()); \\n        stack<int> s;\\n        int steps = 0; \\n        for(int i = nums.size()-1;i>=0;i--){\\n            while(!s.empty() && nums[i]>nums[s.top()]){\\n                a[i] = max(a[i]+1, a[s.top()]); s.pop();\\n            }\\n            s.push(i);\\n            steps = max(steps, a[i]);\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        vector<int> a(nums.size()); \\n        stack<int> s;\\n        int steps = 0; \\n        for(int i = nums.size()-1;i>=0;i--){\\n            while(!s.empty() && nums[i]>nums[s.top()]){\\n                a[i] = max(a[i]+1, a[s.top()]); s.pop();\\n            }\\n            s.push(i);\\n            steps = max(steps, a[i]);\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085731,
                "title": "simple-stack-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<pair<int, int>> s;\\n        s.push({0, -1});\\n        int ans = -1, n = nums.size();\\n        \\n        for(int i = 1; i < n; i++) {\\n            int curr = 1;\\n            \\n            while(s.size()) {\\n                if(nums[i] >= nums[s.top().first]) {\\n                    curr = max(curr, s.top().second + 1);\\n                    s.pop();\\n                }\\n                else break;\\n            }\\n            \\n            if(!s.size()) curr = -1;\\n            ans = max(ans, curr);\\n            s.push({i, curr});\\n        }\\n        \\n        return ans < 0 ? 0: ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<pair<int, int>> s;\\n        s.push({0, -1});\\n        int ans = -1, n = nums.size();\\n        \\n        for(int i = 1; i < n; i++) {\\n            int curr = 1;\\n            \\n            while(s.size()) {\\n                if(nums[i] >= nums[s.top().first]) {\\n                    curr = max(curr, s.top().second + 1);\\n                    s.pop();\\n                }\\n                else break;\\n            }\\n            \\n            if(!s.size()) curr = -1;\\n            ans = max(ans, curr);\\n            s.push({i, curr});\\n        }\\n        \\n        return ans < 0 ? 0: ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2091886,
                "title": "easy-python-monotonic-stack",
                "content": "For every number ```num[i]``` in the array, we have to remove every number ```num[j]```, such that ```num[i] > num[j] and i < j```.  So the answer is simply the maximum number of steps we need to perform in the array, where one step is removal of one number after ```num[i]``` \\n\\nFor ```[5,3,6,2]```, we can see that \\nfor 5, we have to remove ```3``` => 1 step. \\nFor 6 we have to remove ```2``` => 1 step\\nSo the answer is 1\\n\\nNow, if we consider ```[10,1,2,3,4,5,6,1,2,3]```,\\nfor 10, we have to remove ```1, 2, 3, 4, 5, 6``` => 6 steps\\nand for 6, we have to remove ```1, 2, 3``` => 3 steps\\nSo the answer is 6\\n\\nWe maintain a monotonic stack which stores the numbers and the step number for the particular number.\\n```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        st = []\\n        ans = 0\\n        for i in nums:\\n            t = 0\\n            while st and st[-1][0] <= i:\\n                t = max(t, st.pop()[1])\\n            x = 0 \\n            if st: \\n                x = t+1 \\n            st.append([i, x])\\n            ans = max(ans, x)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Monotonic Stack"
                ],
                "code": "```num[i]```\n```num[j]```\n```num[i] > num[j] and i < j```\n```num[i]```\n```[5,3,6,2]```\n```3```\n```2```\n```[10,1,2,3,4,5,6,1,2,3]```\n```1, 2, 3, 4, 5, 6```\n```1, 2, 3```\n```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        st = []\\n        ans = 0\\n        for i in nums:\\n            t = 0\\n            while st and st[-1][0] <= i:\\n                t = max(t, st.pop()[1])\\n            x = 0 \\n            if st: \\n                x = t+1 \\n            st.append([i, x])\\n            ans = max(ans, x)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085833,
                "title": "java-monotonic-stack-o-n",
                "content": "The second parameter of the stack element represents how many steps to make array non-decreasing\\n\\n\\tpublic int totalSteps(int[] nums) {\\n        LinkedList<int[]> stack = new LinkedList<>();\\n        int max = 0;\\n        for(int num : nums) {\\n            int score = 0;\\n            while(stack.size() > 0 && stack.getLast()[0] <= num) {\\n                score = Math.max(score, stack.removeLast()[1]);\\n            }\\n            stack.add(new int[]{num, stack.size() == 0 ? 0 : score+1});\\n            max = Math.max(max, stack.getLast()[1]);\\n        }\\n        return max;\\n    }",
                "solutionTags": [
                    "Java",
                    "Monotonic Stack"
                ],
                "code": "The second parameter of the stack element represents how many steps to make array non-decreasing\\n\\n\\tpublic int totalSteps(int[] nums) {\\n        LinkedList<int[]> stack = new LinkedList<>();\\n        int max = 0;\\n        for(int num : nums) {\\n            int score = 0;\\n            while(stack.size() > 0 && stack.getLast()[0] <= num) {\\n                score = Math.max(score, stack.removeLast()[1]);\\n            }\\n            stack.add(new int[]{num, stack.size() == 0 ? 0 : score+1});\\n            max = Math.max(max, stack.getLast()[1]);\\n        }\\n        return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2086077,
                "title": "c-bfs-accepted-solution",
                "content": "I was not able to get it AC during the contest but continued with my BFS approach and finally made it. \\nFirst of all I created 3 vectors. \\n* dist[i] : gives me the number of elements that needs to be removed for ith element\\n* index[i] : gives me the index of element that needs to removed for the ith element\\n* vis[i] : used for checking if ith element is removed or not.\\n\\nWe will be pushing a pair of index {i,j} inside the queue where nums[i] > nums[j]. \\nWe will be starting from backwards (think intuitively). \\nInitially each index[i] = i+1 , since it will only forward us to the next index. \\n\\n```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int n = nums.size(); \\n        int ans = 0 ;\\n        vector<int>dist(n,0); \\n        vector<int>index(n,0);\\n        for(int i = 0 ; i < n ; i++){\\n            index[i] = i+1 ;\\n        }\\n        \\n        vector<int>vis(n,0); \\n        queue<pair<int,int>>q; \\n        for(int i = n-1 ; i > 0 ; i--){\\n            if(nums[i-1] > nums[i]){\\n                q.push({i-1,i});\\n            }\\n        }\\n        \\n        while(!q.empty()){\\n            auto f = q.front(); \\n            q.pop();\\n            \\n            int x = f.first  ; \\n            int y = f.second ; \\n            \\n            if(y == n){\\n                continue ;\\n            }\\n            if(vis[x]){\\n                continue ; \\n            }\\n\\t\\t\\t\\n\\t\\t\\t//index[y] gives us the next element that needs to be deleted.\\n            if(nums[x] > nums[y] && index[y] > y){\\n                vis[y] = 1 ;\\n                dist[f.first] += 1 ; \\n                index[f.first] = index[y];\\n                q.push({f.first,index[y]}); \\n            }\\n        }\\n        \\n        for(int i = 0 ; i < n ; i++) ans = max(ans , dist[i]);\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int n = nums.size(); \\n        int ans = 0 ;\\n        vector<int>dist(n,0); \\n        vector<int>index(n,0);\\n        for(int i = 0 ; i < n ; i++){\\n            index[i] = i+1 ;\\n        }\\n        \\n        vector<int>vis(n,0); \\n        queue<pair<int,int>>q; \\n        for(int i = n-1 ; i > 0 ; i--){\\n            if(nums[i-1] > nums[i]){\\n                q.push({i-1,i});\\n            }\\n        }\\n        \\n        while(!q.empty()){\\n            auto f = q.front(); \\n            q.pop();\\n            \\n            int x = f.first  ; \\n            int y = f.second ; \\n            \\n            if(y == n){\\n                continue ;\\n            }\\n            if(vis[x]){\\n                continue ; \\n            }\\n\\t\\t\\t\\n\\t\\t\\t//index[y] gives us the next element that needs to be deleted.\\n            if(nums[x] > nums[y] && index[y] > y){\\n                vis[y] = 1 ;\\n                dist[f.first] += 1 ; \\n                index[f.first] = index[y];\\n                q.push({f.first,index[y]}); \\n            }\\n        }\\n        \\n        for(int i = 0 ; i < n ; i++) ans = max(ans , dist[i]);\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2097856,
                "title": "c-2-approaches-single-monotonic-stack-or-monotonic-stack-with-dp-example-explained",
                "content": "Intuition :\\nAn element will eat all its smaller elements till next greater element unless it is itself get eated by some element on its left. Example-\\n[7 **[14 4]** 14 **[13 2 6]** 13]\\n13 can eat 2 and 6 but will only be able to eat 2 as it will be eaten by 14\\n[7 |**[14 4]**| **[14 [13 2]] 6 |** 13]\\nlater 14 will eat 6\\n[7 14 **[14 6]** 13]\\n[7 14 **[14 13]**]\\n\\n1. Using monotonic  stack and traversing from end (n-1 to 0)\\n\\n```\\nint totalSteps(vector<int>& nums) {\\n\\t\\tint n=nums.size();\\n        stack<pair<int,int>> st;\\n        int count=0;\\n        int ans=0;\\n        for(int i=n-1;i>=0;i--){\\n            while(st.size()&&nums[i]>nums[st.top().first]){\\n                count=max(count+1,st.top().second);\\n                st.pop();\\n            }\\n            st.push({i,count});\\n            ans=max(ans,count);\\n            count=0;\\n        }\\n        return ans;\\n\\t}\\n```\\n2. Using dynamic programming (dp array->eat[]) with motonic  stack\\n```\\nint totalSteps(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> eat(n);\\n        stack<int> st;\\n        int count=0;\\n        int ans=0;\\n        for(int i=n-1;i>=0;i--){\\n            // cout<<\"i=\"<<i<<\"---\";\\n            while(st.size()&&nums[i]>nums[st.top()]){\\n                //cout<<count<<\",\"<<eat[st.top()]<<\"; \";\\n                count=max(count+1,eat[st.top()]);\\n                st.pop();\\n            }\\n            eat[i]=count;\\n            st.push(i);\\n            ans=max(ans,count);\\n            count=0;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Monotonic Stack"
                ],
                "code": "```\\nint totalSteps(vector<int>& nums) {\\n\\t\\tint n=nums.size();\\n        stack<pair<int,int>> st;\\n        int count=0;\\n        int ans=0;\\n        for(int i=n-1;i>=0;i--){\\n            while(st.size()&&nums[i]>nums[st.top().first]){\\n                count=max(count+1,st.top().second);\\n                st.pop();\\n            }\\n            st.push({i,count});\\n            ans=max(ans,count);\\n            count=0;\\n        }\\n        return ans;\\n\\t}\\n```\n```\\nint totalSteps(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> eat(n);\\n        stack<int> st;\\n        int count=0;\\n        int ans=0;\\n        for(int i=n-1;i>=0;i--){\\n            // cout<<\"i=\"<<i<<\"---\";\\n            while(st.size()&&nums[i]>nums[st.top()]){\\n                //cout<<count<<\",\"<<eat[st.top()]<<\"; \";\\n                count=max(count+1,eat[st.top()]);\\n                st.pop();\\n            }\\n            eat[i]=count;\\n            st.push(i);\\n            ans=max(ans,count);\\n            count=0;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2087720,
                "title": "super-clean-explanation-of-pro-coders-approaches-examples-include",
                "content": "Consider the given testcase:\\n[5,3,4,4,7,3,6,11,8,5,11]\\nAs per qns we can\\'t delete the first element (In one step, remove all elements nums[i] where nums[i - 1] > nums[i] for all 0 < i < nums.length.)\\nso \\'5\\' is inevitable,\\nnow we have to remove elements less than 5 untill we meet other element right to \\'5\\' greater than \\'5\\'.\\nwe end up at  \\'7\\' so far we delete \"3\" nums.\\nuntill \\'11\\'  we delete \"2\" nums.\\nuntill next \\'11\\'  we delete \"2\" nums.\\nso answer would be max deletions taken place Therefore, ans=3\\n********************* BUT WAIT ******************\\nif we consider :\\n[14,1,2,3,4,5,6,1,2,3,4]\\nwe would get ans=10(Which is WRONG!!!)\\nBecause,\\nwe could delete nums 1 2 3 4 5 6 wrt \\'14\\' and other 1 2 3 4 nums wrt \\'6\\'\\nThen answer would be 6 actually.\\nSO WHAT TO DO !!!\\nlets see,\\nif we iterate the array from end which is right to left.\\nnow lets do the same but in other way\\nlets take a stack contains elements of form [nums[i],deletions_it_can_do]\\nso when we iterate it from right we find 4 we append [4,0] to stack\\nnext we find \\'3\\' which is smaller than \\'4\\' we continue \\n...\\nwe\\'ll reach \\'6\\' there are 4 nums right to it so we append [6,4]\\neach time ans would be max(ans,stack[i][1])\\nsimillarly we reach \\'14\\' we append [14,5]\\nso ans=5!!\\n(With this we predict the deletions we should make at max as we would have done 10 before wrt 14 but now we know that 6 helps us with few(4) parallel deletions so ans=5.)\\n(See code explanation below for complete explanation.)\\n\\n\\n**CODE:**\\n```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        ans = 0\\n        nums.reverse()\\n        lst = [[nums[0], 0]]\\n        for i in range(1, len(nums)):\\n            cnt = 0\\n            while lst and lst[-1][0] < nums[i]:\\n                cnt = max(cnt + 1, lst[-1][1])\\n                print(lst)\\n                lst.pop()\\n            lst.append([nums[i], cnt])\\n            ans = max(ans, cnt)\\n        return ans\\n```\\n**STACK STATUS AT EACH ELEMENT:**\\n\\n4\\ninitial [[4, 0]]\\n3\\ninitial [[4, 0]]\\n2\\ninitial [[4, 0], [3, 0]]\\n1\\ninitial [[4, 0], [3, 0], [2, 0]]\\n6\\ninitial [[4, 0], [3, 0], [2, 0], [1, 0]]\\n[[4, 0], [3, 0], [2, 0], [1, 0]]\\n[[4, 0], [3, 0], [2, 0]]\\n[[4, 0], [3, 0]]\\n[[4, 0]]\\n5\\ninitial [[6, 4]]\\n4\\ninitial [[6, 4], [5, 0]]\\n3\\ninitial [[6, 4], [5, 0], [4, 0]]\\n2\\ninitial [[6, 4], [5, 0], [4, 0], [3, 0]]\\n14\\ninitial [[6, 4], [5, 0], [4, 0], [3, 0], [2, 0]]\\n[[6, 4], [5, 0], [4, 0], [3, 0], [2, 0]]\\n[[6, 4], [5, 0], [4, 0], [3, 0]]\\n[[6, 4], [5, 0], [4, 0]]\\n[[6, 4], [5, 0]]\\n[[6, 4]]\\nFinal stack [[14, 5]]\\n\\n\\n**CODE EXPLANATION:(DRY RUN)**\\nNow we are aware of the approach,code but how does it work.Let\\'s see.\\nWe initailly we have a stack containing  first ele of nums \\'4\\' and deletions \\'0\\' after reversing array.\\nAs we go on we find that the condition of the while loop is False untill we find a number greater than cur num.\\nAt 6;\\nThe while loop condition in True.\\nthat is 6>1 \\nStack Status: [[4, 0], [3, 0], [2, 0], [1, 0]]\\n`cnt = max(cnt + 1, lst[-1][1]`)\\nHere we see cnt =0 and `lst[-1][1]` intially\\nbut cnt is updated to cnt+1 in max function \\nit gets updated to 4 and stack gets empty and loop breaks \\nwe append `[[6, 4]]` to stack \\nNOTE: stack contains final non-decreaing array.\\nfor each iterations of for loop we update ans \\n`ans = max(ans, cnt)`\\nAt 11;\\nStack status : [[6, 4], [5, 0], [4, 0], [3, 0], [2, 0]]\\nnow we repeat same process we get [[14, 5]]\\nwe get 5 deletions cause `cnt = max(cnt + 1, lst[-1][1])`\\nHere is the catch its not added up its maximized \\nThats why we use stacks to get O(n) complexity.\\nHence we get desired answer!!\\nThank You if u read whole thing !!!\\nPlease Comment your insghts !!\\n(I couldn\\'t go through this again please ignore typos if any )\\n",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        ans = 0\\n        nums.reverse()\\n        lst = [[nums[0], 0]]\\n        for i in range(1, len(nums)):\\n            cnt = 0\\n            while lst and lst[-1][0] < nums[i]:\\n                cnt = max(cnt + 1, lst[-1][1])\\n                print(lst)\\n                lst.pop()\\n            lst.append([nums[i], cnt])\\n            ans = max(ans, cnt)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086693,
                "title": "vedio-explanation-with-intuition",
                "content": "[Video Link](https://www.youtube.com/watch?v=XirZ8GtWxWA)",
                "solutionTags": [
                    "Stack"
                ],
                "code": "[Video Link](https://www.youtube.com/watch?v=XirZ8GtWxWA)",
                "codeTag": "Unknown"
            },
            {
                "id": 2127138,
                "title": "c-easy-code-explaination",
                "content": "\\n\\t\\tint totalSteps(vector<int>& A) {\\n\\t\\t\\t\\tint n = A.size(), steps = 0;\\n\\t\\t\\t\\tvector<int> dp(n);\\n\\t\\t\\t\\tstack<int> stack;\\n        \\n        for (int i=n-1 ; i>=0 ; i--) {\\n            while(!stack.empty() && A[i] > A[stack.top()]) {\\n                dp[i] = max(++dp[i], dp[stack.top()]);\\n                stack.pop();\\n                steps = max(steps, dp[i]);\\n            }\\n            stack.push(i);\\n        }\\n        \\n        return steps;\\n    }",
                "solutionTags": [],
                "code": "\\n\\t\\tint totalSteps(vector<int>& A) {\\n\\t\\t\\t\\tint n = A.size(), steps = 0;\\n\\t\\t\\t\\tvector<int> dp(n);\\n\\t\\t\\t\\tstack<int> stack;\\n        \\n        for (int i=n-1 ; i>=0 ; i--) {\\n            while(!stack.empty() && A[i] > A[stack.top()]) {\\n                dp[i] = max(++dp[i], dp[stack.top()]);\\n                stack.pop();\\n                steps = max(steps, dp[i]);\\n            }\\n            stack.push(i);\\n        }\\n        \\n        return steps;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2110632,
                "title": "c-solution-using-monotonic-stack-optimal-solution",
                "content": "```\\n/*  Approach -> using monotonic stack\\n    Time Complexity  -> O(n)\\n    Space Complexity -> O(n)    */\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<pair<int,int>> st;\\n        int n=nums.size();\\n        int ans=0;\\n        \\n        st.push({nums[n-1],0});\\n        \\n        for(int i=n-2;i>=0;i--){\\n            int cnt=0;\\n            while(!st.empty() && nums[i]>st.top().first) {\\n                cnt=max(cnt+1,st.top().second);\\n                st.pop();\\n            }\\n            ans=max(ans,cnt);\\n            st.push({nums[i],cnt});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\n/*  Approach -> using monotonic stack\\n    Time Complexity  -> O(n)\\n    Space Complexity -> O(n)    */\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<pair<int,int>> st;\\n        int n=nums.size();\\n        int ans=0;\\n        \\n        st.push({nums[n-1],0});\\n        \\n        for(int i=n-2;i>=0;i--){\\n            int cnt=0;\\n            while(!st.empty() && nums[i]>st.top().first) {\\n                cnt=max(cnt+1,st.top().second);\\n                st.pop();\\n            }\\n            ans=max(ans,cnt);\\n            st.push({nums[i],cnt});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2100060,
                "title": "easy-python-linked-list-simulation-solution",
                "content": "**Walkthrough**\\nThis is def not as elegant as the DP solution. But personally I find it easier to understand and a little bit more intuitive. What it is is recognizing the fact that linked list can help us for this problem because we keep deleting adjacent elements. \\n\\nThere are mostly 3 steps:\\n1. Convert the array list to a singly linked list\\n2. Get all peaks, where a peak is defined as any point in nums such that nums[i] > nums[i+1].\\n3. This is the simulation step. We keep deleting adjacent numbers to the peaks as long as they are smaller than the peaks, until no such peak exist any more. \\n\\n\\tNote that here we traverse backwards and that\\'s because in situation like [6,5,4] it can actually be deleted in one iteration if we traverse backwards. But if we traverse forward, 6 would delete 5 and 5 hasn\\'t had to chance to delete 4 yet, therefore yielding incorrect result. \\n\\n**Code**\\n```\\nclass Node:\\n    def __init__(self, val):\\n        self.val = val\\n        self.next = None\\n\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        head = Node(-1)\\n        curr = head\\n        \\n        # 1. Convert the list to a singly linked list\\n        for num in nums:\\n            curr.next = Node(num)\\n            curr = curr.next\\n            \\n        # 2. Get all the peaks, where a peak is defined if nums[i] > nums[i+1]\\n        curr = head\\n        peaks = []\\n        \\n        while curr.next:\\n            if curr.val > curr.next.val:\\n                peaks.append(curr)\\n            curr = curr.next\\n        \\n        # 3. Simulation. Keep getting rid of the peaks until there\\'s no more. \\n        steps = 0\\n        while peaks:  \\n            nextPeaks = []\\n            \\n            for node in reversed(peaks):\\n                if node.next and node.val > node.next.val:\\n                    node.next = node.next.next\\n                    nextPeaks.append(node)\\n            \\n            if not nextPeaks:\\n                return steps\\n            \\n            peaks = list(reversed(nextPeaks))\\n            steps += 1\\n        return steps\\n```\\t\\t\\n\\n**Time/Space Complexity**\\n\\n* Time: O(N), as each number can at be deleted once at most \\n* Space: O(N), we use linear space to convert the array list to a linked list\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Simulation"
                ],
                "code": "```\\nclass Node:\\n    def __init__(self, val):\\n        self.val = val\\n        self.next = None\\n\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        head = Node(-1)\\n        curr = head\\n        \\n        # 1. Convert the list to a singly linked list\\n        for num in nums:\\n            curr.next = Node(num)\\n            curr = curr.next\\n            \\n        # 2. Get all the peaks, where a peak is defined if nums[i] > nums[i+1]\\n        curr = head\\n        peaks = []\\n        \\n        while curr.next:\\n            if curr.val > curr.next.val:\\n                peaks.append(curr)\\n            curr = curr.next\\n        \\n        # 3. Simulation. Keep getting rid of the peaks until there\\'s no more. \\n        steps = 0\\n        while peaks:  \\n            nextPeaks = []\\n            \\n            for node in reversed(peaks):\\n                if node.next and node.val > node.next.val:\\n                    node.next = node.next.next\\n                    nextPeaks.append(node)\\n            \\n            if not nextPeaks:\\n                return steps\\n            \\n            peaks = list(reversed(nextPeaks))\\n            steps += 1\\n        return steps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2087738,
                "title": "java-clean-code-with-comments",
                "content": "```\\n** Note: - This is the brute force solution hacing TC = O(n2) that gives TLE.\\n\\n    public int totalSteps(int[] nums) {\\n        int ts = 0;\\n\\n        List<Integer> nl = Arrays.stream(nums).boxed().collect(Collectors.toList());\\n        List<Integer> ul = new ArrayList<>();\\n        int prev = -1;\\n        while (true) {\\n            boolean changed = false;\\n            for (int num : nl) {\\n                if (prev == -1) prev = num;\\n                else if (num >= prev) ul.add(num);\\n                else {\\n                    changed = true;\\n                }\\n            }\\n            System.out.println(Arrays.toString(ul.toArray()));\\n            nl.clear();\\n            nl.addAll(ul);\\n            ul.clear();\\n            if (changed) ts++;\\n            if (!changed) break;\\n        }\\n\\n        return ts;\\n    }\\n\\n** Optimised Solution:- \\nTC = O(nk) where k is contant factor\\n\\nAlgorithm :-\\n- The Idea is to calculate distance between the closest left strictly greater element for every index i\\n- Return maximum of distance (As distance refers to numbers of steps needed to remove that element )\\n\\n\\n    public int totalSteps(int[] nums) {\\n        int ans = 0;\\n        Stack<int[]> stk = new Stack<>();\\n\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            if (stk.isEmpty() || stk.peek()[0] >= nums[i]) {\\n                stk.push(new int[]{nums[i], 0});\\n            } else {\\n                int count = 0;\\n                while (!stk.isEmpty() && stk.peek()[0] < nums[i]) {\\n                    count++;\\n                    int[] item = stk.pop();\\n                    if (item[1] > count) count = item[1];\\n                }\\n                stk.push(new int[]{nums[i], count});\\n                ans = Math.max(ans, count);\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n** Note: - This is the brute force solution hacing TC = O(n2) that gives TLE.\\n\\n    public int totalSteps(int[] nums) {\\n        int ts = 0;\\n\\n        List<Integer> nl = Arrays.stream(nums).boxed().collect(Collectors.toList());\\n        List<Integer> ul = new ArrayList<>();\\n        int prev = -1;\\n        while (true) {\\n            boolean changed = false;\\n            for (int num : nl) {\\n                if (prev == -1) prev = num;\\n                else if (num >= prev) ul.add(num);\\n                else {\\n                    changed = true;\\n                }\\n            }\\n            System.out.println(Arrays.toString(ul.toArray()));\\n            nl.clear();\\n            nl.addAll(ul);\\n            ul.clear();\\n            if (changed) ts++;\\n            if (!changed) break;\\n        }\\n\\n        return ts;\\n    }\\n\\n** Optimised Solution:- \\nTC = O(nk) where k is contant factor\\n\\nAlgorithm :-\\n- The Idea is to calculate distance between the closest left strictly greater element for every index i\\n- Return maximum of distance (As distance refers to numbers of steps needed to remove that element )\\n\\n\\n    public int totalSteps(int[] nums) {\\n        int ans = 0;\\n        Stack<int[]> stk = new Stack<>();\\n\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            if (stk.isEmpty() || stk.peek()[0] >= nums[i]) {\\n                stk.push(new int[]{nums[i], 0});\\n            } else {\\n                int count = 0;\\n                while (!stk.isEmpty() && stk.peek()[0] < nums[i]) {\\n                    count++;\\n                    int[] item = stk.pop();\\n                    if (item[1] > count) count = item[1];\\n                }\\n                stk.push(new int[]{nums[i], count});\\n                ans = Math.max(ans, count);\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2086750,
                "title": "java-monostack-9-2-ac-wow",
                "content": "oh wow, this question currently has a 9.2% passed rate and only 356 users got an AC during this contest. \\n\\nI feel like monostack questions tend to be a bit more unintuitive, but once we get the intuition, it is quite simple!\\n\\nIf we maintain a monostack and scan the array from right to left, pop element off when `nums[i] > nums[stack.peek()]`, then inituitively speaking, there are two possibilities for the count for `num[i]`: \\n1. Inherit the count from whatever it popped (maybe +1?)\\n\\n2. add 1 to its current count\\n\\nWhen we think a little deeper, we find that we are not supposed to +1 for case 1 because both numbers get deleted at the same time.  \\nAlso, we are supposed to take the maximum of both cases.\\n\\nSolved all 4 Qs on my own this time but didn\\'t participate in contest, so :( \\n\\n\\n\\n```Java\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        int ans = 0;\\n        int[] dp = new int[nums.length];\\n        for (int i = nums.length - 1; i >= 0; i--){\\n            int cur = 0;\\n            while(!stack.isEmpty() && nums[i] > nums[stack.peek()]){\\n                cur = Math.max(cur + 1, dp[stack.pop()]);\\n            }\\n            stack.push(i);\\n            dp[i] = cur;\\n            ans = Math.max(cur, ans);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Monotonic Stack"
                ],
                "code": "```Java\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        int ans = 0;\\n        int[] dp = new int[nums.length];\\n        for (int i = nums.length - 1; i >= 0; i--){\\n            int cur = 0;\\n            while(!stack.isEmpty() && nums[i] > nums[stack.peek()]){\\n                cur = Math.max(cur + 1, dp[stack.pop()]);\\n            }\\n            stack.push(i);\\n            dp[i] = cur;\\n            ans = Math.max(cur, ans);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3881965,
                "title": "monotonic-stack-very-easy-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse a **monotonic increasing stack** to count the number of steps. The approach is very simple, just count a **continuous number of operations** to build up the **stack in increasing order**.\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int totalSteps(vector<int>& arr) {\\n\\n      int n = arr.size();\\n      stack<pair<int,int>> st;\\n      int ans = -1;\\n       for(int i = n-1;i>=0;i--)\\n       {\\n           int cnt = 0;\\n           while(!st.empty() && st.top().first < arr[i])\\n           {\\n               cnt = max(cnt+1,st.top().second);\\n               st.pop();   \\n           }\\n           ans = max(ans,cnt);\\n           st.push({arr[i],cnt});\\n       }\\n\\n       return ans;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/e3fbe3dc-a29d-4917-985a-96953bfb5397_1691502089.0189996.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int totalSteps(vector<int>& arr) {\\n\\n      int n = arr.size();\\n      stack<pair<int,int>> st;\\n      int ans = -1;\\n       for(int i = n-1;i>=0;i--)\\n       {\\n           int cnt = 0;\\n           while(!st.empty() && st.top().first < arr[i])\\n           {\\n               cnt = max(cnt+1,st.top().second);\\n               st.pop();   \\n           }\\n           ans = max(ans,cnt);\\n           st.push({arr[i],cnt});\\n       }\\n\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422708,
                "title": "python-using-a-stack",
                "content": "First, let\\'s take a look at an example.\\n\\n\\tnums = [5,3,4,4]\\n\\t\\n\\t- Step 1: [5,3,4,4] becomes [5,4,4]\\n\\t- Step 2: [5,4,4] becomes [5,4]\\n\\t- Step 3: [5,4] becomes [5]\\n\\t\\n\\tHere, we have to perform three steps to make the array non-decreasing (increasing).\\n\\t\\n\\tNow, ofcourse it is not a good idea to keep looping again and again until we are sure that array is now non-decreasing.\\n\\t\\n\\tSo, how can we quickly figure out, what is the number of steps required for this array to become non-decreasing.\\n\\t\\n\\tIt seems like we are simply counting how many smaller elements on right are there.\\n\\t\\n\\tBUT THERE IS A CATCH THAT I WILL DISCUSS IN LATER PART.\\n\\t\\n\\tFor example, for \"5\" at index = 0, we have to remove \"3\", \"4\" and \"4\". So there are \"3\" elements we have to remove for this \"5\".\\n\\n\\tSo, the steps = 3.\\n\\t\\n\\tIt also makes sense since in one step, we can only remove one element such that it is smaller than previous. So here,\\n\\t\\n\\tIn one step, we first remove \"3\". Then in second step, we remove \"4\" And finally, we remove the other \"4\".\\n\\n\\t\\nRemember I said there is a catch in the above approach.\\n\\nBased on the above approach, it makes sense to simply loop from left to right and see how many smaller elements are there on right of an element, right? But will it give us the right output?\\n\\n\\tTake this example ->  [5,3,4,3]\\n\\t\\n\\tAs per our logic, we will remove all the smaller elements on right of \"5\" and so it takes 3 steps.\\n\\t\\n\\tBut just think about it. Before \"5\" removes the last \"3\", won\\'t \"4\" already remove it?\\n\\t\\n\\tThe problem statement says in one step, all those elements will be removed that have a greater element on their left.\\n\\t\\n\\tAnd so, in Step 1, we will remove the \"3\" on right of \"5\" and also the \"3\" on right of \"4\", leaving us with [5,4]\\n\\t\\n\\tAnd in Step 2, we will remove the \"4\" and so output is 2 steps.\\n\\t\\nAnd that\\'s the whole idea of using the stack and looping from right to left. Such that, before we reach \"5\", we have already calculated how many elements \"4\" will remove and that will represent how many steps it would take.\\n\\nFinally, to summarize the solution, let\\'s take an example.\\n\\n\\tnums  = [7,14,4,14,13,2,6,13]\\n\\t\\n\\t\\n\\tWe loop from right to left.\\n\\t\\n\\tFirst, we have \"13\". We removed 0 elements. Stack = [(13,0)]\\n\\t\\n\\tNext, we have \"6\". Again, 0 elements removed since we don\\'t have smaller element on top of stack.\\n\\tAnd same story with \"2\".\\n\\t\\n\\tStack = [(13,0), (6,0), (2,0)]\\n\\t\\n\\tNext up, we have \"13\". Here, we see that stack has two smaller elements on top. \\n\\tSo, before pushing \"13\" we have to remove these two elements.\\n\\t\\n\\tSince for \"6\" and \"2\", the count of \"0\", it means we haven\\'t yet performed any step at all.\\n\\t\\n\\tSo, we perform our first step only when we reach \"13\". We will remove \"2\" first. \\n\\tstepCount += 1\\n\\t\\n\\tThen we will remove \"6\".\\n\\tstepCount += 1\\n\\t\\n\\tHence, for \"13\", we removed \"2\" elements and that took \"2\" steps. \\n\\t\\n\\tStack = [(13,0), (13,2)]\\n\\t\\n\\tNext, we have \"14\". Here, we see that top of stack has \"13\" and we are already at step 2 at this point since \"13\" removed \"2\" elements.\\n\\t\\n\\tSo, when \"14\" removed the topmost \"13\", it makes sense that it did that in at least the step 2 (or above).\\n\\t\\n\\tThat\\'s the reason why in the code we did stepCount = max(stepCount + 1, stack[-1][1])\\n\\t\\n\\tBecause if we had just done stepCount += 1, then for \"14\", \\n\\tit would\\'ve meant that one element removed and hence only one step performed.\\n\\tAnd we would\\'ve lost the actual steps performed so far, which is \"2\".\\n\\t\\n\\tSo, the idea is to keep track of maximum steps performed at any point we remove any element.\\n\\tBecause it makes sense that if we removed some elements already and \"x\" steps have been taken,\\n\\tthen if we remove another, then it is either the \"x\"th step itself or the \"x + 1\"th step.\\n\\t\\n\\tSo, at this point, we remove (13,2) from stack and right now, stepCount = 2\\n\\t\\n\\tThen we remove the next \"13\" and this one took another step. So stepCount = 3\\n\\t\\n\\tHence, Stack = [(14,3)] and so far, steps = 3\\n\\t\\n\\tSimilarly, we keep going and eventually, we will find that the maximum value for steps will be \"3\".\\n\\t\\nHence, nums  = [7,14,4,14,13,2,6,13] is converted to a non-decreasing array in 3 steps.\\n\\t\\n\\t\\n```\\ndef totalSteps(self, nums: List[int]) -> int:\\n        # Length of the input list\\n        n = len(nums)\\n        \\n        # Steps\\n        steps = 0\\n        \\n        # Stack\\n        stack = []\\n        \\n        # Loop in reverse\\n        for i in range(n - 1, -1, -1):\\n            # How many elements were removed for this particular element to push to stack\\n            # That represents the number of steps performed\\n            stepCount = 0\\n            \\n            # Remove all the elements on top of stack that are smaller\\n            while stack and stack[-1][0] < nums[i]:\\n                # We want to keep track of what is the maximum stepCount so far\\n                # That\\'s why, we want the maximum value here\\n                stepCount = max(stepCount + 1, stack[-1][1])\\n                stack.pop()\\n                \\n            # Push the current element to stack along with the step count\\n            stack.append([nums[i], stepCount])\\n            \\n            # Update the steps performed\\n            steps = max(steps, stepCount)\\n        \\n        return steps\\n```\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\ndef totalSteps(self, nums: List[int]) -> int:\\n        # Length of the input list\\n        n = len(nums)\\n        \\n        # Steps\\n        steps = 0\\n        \\n        # Stack\\n        stack = []\\n        \\n        # Loop in reverse\\n        for i in range(n - 1, -1, -1):\\n            # How many elements were removed for this particular element to push to stack\\n            # That represents the number of steps performed\\n            stepCount = 0\\n            \\n            # Remove all the elements on top of stack that are smaller\\n            while stack and stack[-1][0] < nums[i]:\\n                # We want to keep track of what is the maximum stepCount so far\\n                # That\\'s why, we want the maximum value here\\n                stepCount = max(stepCount + 1, stack[-1][1])\\n                stack.pop()\\n                \\n            # Push the current element to stack along with the step count\\n            stack.append([nums[i], stepCount])\\n            \\n            # Update the steps performed\\n            steps = max(steps, stepCount)\\n        \\n        return steps\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2896423,
                "title": "python3-easiest-solution-beats-90",
                "content": "# Code\\n```\\nclass Solution:\\n    def totalSteps(self, A: List[int]) -> int:      \\n        st = [[A[0], 0]]\\n        ans = 0\\n        \\n        for a in A[1:]:\\n            t = 0\\n            while st and st[-1][0] <= a:\\n                t = max(t, st[-1][1])\\n                st.pop()\\n            if st: \\n                t += 1\\n            else:\\n                t = 0\\n            ans = max(ans, t)\\n            st.append([a, t])\\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def totalSteps(self, A: List[int]) -> int:      \\n        st = [[A[0], 0]]\\n        ans = 0\\n        \\n        for a in A[1:]:\\n            t = 0\\n            while st and st[-1][0] <= a:\\n                t = max(t, st[-1][1])\\n                st.pop()\\n            if st: \\n                t += 1\\n            else:\\n                t = 0\\n            ans = max(ans, t)\\n            st.append([a, t])\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735172,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& A) {\\n        int n = A.size(), res = 0;\\n        vector<int> stack, dp(n);\\n        for (int i = n - 1; i >= 0; --i) {\\n            while (!stack.empty() && A[i] > A[stack.back()]) {\\n                dp[i] = max(++dp[i], dp[stack.back()]);\\n                stack.pop_back();\\n                res = max(res, dp[i]);\\n            }\\n            stack.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& A) {\\n        int n = A.size(), res = 0;\\n        vector<int> stack, dp(n);\\n        for (int i = n - 1; i >= 0; --i) {\\n            while (!stack.empty() && A[i] > A[stack.back()]) {\\n                dp[i] = max(++dp[i], dp[stack.back()]);\\n                stack.pop_back();\\n                res = max(res, dp[i]);\\n            }\\n            stack.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2298418,
                "title": "java-solution-o-n-time-o-n-space",
                "content": "```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        Stack st = new Stack<Integer>();\\n        st.push(0);\\n        int steps=0;\\n        int step_arr[] = new int[nums.length]; \\n        for(int i=1;i<nums.length;i++){\\n            int max_steps = 0;\\n            while(!st.empty() && nums[i]>=nums[(Integer)st.peek()]){\\n                max_steps=Math.max(max_steps,step_arr[(Integer)st.peek()]);\\n                st.pop();\\n            }\\n            if(!st.empty() && nums[i]<nums[(Integer)st.peek()]){\\n                    step_arr[i]=1+max_steps;\\n            }\\n            steps = Math.max(steps,step_arr[i]);\\n            st.push(i);\\n        }\\n        return steps;\\n    }\\n}\\n\\n/*\\n1. The stack helps us to figure out for each element, which is the first strictly greater element present to the left of it.\\n2. It is because of this element that the current element will be removed.\\n3. Once that is figured out we need to figure how many steps have passed when both these elements become adjacent to each other. In order to figure that out, whenever we perform the popping operation on stack we maintain a variable to record the max. steps that have passed in order for all intermedate elements to get removed,so that the current element and the strictly greater element have become adjacent. \\n4. The number of steps reqd. for this element to get removed would be one greater than the max. of all the intermediate elements\\' steps.\\n5. Maintain all the steps in an array called `step_arr`. Max of all the steps would be the answer.\\n6. Do comment or upvote if you stumble upon this discussion_thread. \\n\\n*/\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        Stack st = new Stack<Integer>();\\n        st.push(0);\\n        int steps=0;\\n        int step_arr[] = new int[nums.length]; \\n        for(int i=1;i<nums.length;i++){\\n            int max_steps = 0;\\n            while(!st.empty() && nums[i]>=nums[(Integer)st.peek()]){\\n                max_steps=Math.max(max_steps,step_arr[(Integer)st.peek()]);\\n                st.pop();\\n            }\\n            if(!st.empty() && nums[i]<nums[(Integer)st.peek()]){\\n                    step_arr[i]=1+max_steps;\\n            }\\n            steps = Math.max(steps,step_arr[i]);\\n            st.push(i);\\n        }\\n        return steps;\\n    }\\n}\\n\\n/*\\n1. The stack helps us to figure out for each element, which is the first strictly greater element present to the left of it.\\n2. It is because of this element that the current element will be removed.\\n3. Once that is figured out we need to figure how many steps have passed when both these elements become adjacent to each other. In order to figure that out, whenever we perform the popping operation on stack we maintain a variable to record the max. steps that have passed in order for all intermedate elements to get removed,so that the current element and the strictly greater element have become adjacent. \\n4. The number of steps reqd. for this element to get removed would be one greater than the max. of all the intermediate elements\\' steps.\\n5. Maintain all the steps in an array called `step_arr`. Max of all the steps would be the answer.\\n6. Do comment or upvote if you stumble upon this discussion_thread. \\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2100584,
                "title": "sollution-in-o-n-time-complexoty",
                "content": "/*\\n\\n1. Suppose the (ith) element takes count[i] stpes to get removed from the array , the minimum value of count[i] is 0; which means that there is no gretar element \\n   on its left.\\n\\n2. The element will get removed from the array if there is greater element than that element on left.\\n\\n3. The element will be removed by its greater element present on its left.\\n\\n4. suppose the element A[i] , has A[j] element which is greater than A[i];\\n\\n5. The rounds taken by element A[i] to get removed from the array is maximum number of rounds taken by element from [ (j+1 , i-1) ] + 1  \\n\\n*/\\n\\nclass Solution {\\npublic:\\n    int solve(vector<int>& v , int n)\\n    {\\n        stack<pair<int,int>> st;\\n        int ans = 0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(st.size() == 0)\\n            {\\n                st.push({v[i] , 0});\\n            }\\n            else\\n            {\\n                int curr_ans = 0;\\n                \\n                while(st.size() > 0 && st.top().first <= v[i])\\n                {\\n                    curr_ans = max(curr_ans , st.top().second);\\n                    st.pop();\\n                }\\n                \\n                if(st.size() == 0) curr_ans = 0;\\n                else curr_ans = curr_ans + 1;\\n                \\n                ans = max(ans , curr_ans);\\n                \\n                st.push({v[i] , curr_ans});\\n            }\\n        }\\n        return ans;\\n    }\\n    int totalSteps(vector<int>& nums) \\n    {\\n        int ans = solve(nums , nums.size());\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    int solve(vector<int>& v , int n)\\n    {\\n        stack<pair<int,int>> st;\\n        int ans = 0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(st.size() == 0)\\n            {\\n                st.push({v[i] , 0}",
                "codeTag": "Java"
            },
            {
                "id": 2100083,
                "title": "javascript-solution-stack-dp",
                "content": "```\\nvar totalSteps = function(nums) {\\n\\tlet stack = [],\\n\\t\\tdp = new Array(nums.length).fill(0),\\n\\t\\tmax = 0\\n\\n\\tfor (let i = nums.length - 1; i >= 0; i--) {\\n\\t\\twhile (stack.length > 0 && nums[i] > nums[stack[stack.length - 1]]) {\\n\\t\\t\\tdp[i] = Math.max(++dp[i], dp[stack.pop()])\\n\\t\\t\\tmax = Math.max(dp[i], max)\\n\\t\\t}\\n\\t\\tstack.push(i)\\n\\t}\\n\\treturn max\\n};\\n```\\nComplement Lee\\'s solution in javascript",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar totalSteps = function(nums) {\\n\\tlet stack = [],\\n\\t\\tdp = new Array(nums.length).fill(0),\\n\\t\\tmax = 0\\n\\n\\tfor (let i = nums.length - 1; i >= 0; i--) {\\n\\t\\twhile (stack.length > 0 && nums[i] > nums[stack[stack.length - 1]]) {\\n\\t\\t\\tdp[i] = Math.max(++dp[i], dp[stack.pop()])\\n\\t\\t\\tmax = Math.max(dp[i], max)\\n\\t\\t}\\n\\t\\tstack.push(i)\\n\\t}\\n\\treturn max\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2098159,
                "title": "python-stack-non-increasing-stack-no-dp-record-steps-before-removing-elements",
                "content": "I know, the highest upvoted solution uses DP. However, the DP solution is not intuitive to me, as DP[i] is not the steps to remove element at index i, but the steps to remove all  smaller elements behind element i in the non-incresing stack. It is hard to come up with such definition of DP. \\n\\nMy solution follows a simple intuition. When a new element is about to be appended to the stack, if it leads to existing elments right before element i in the stack being removed, record the steps to remove elements right before element i in the stack ; Update the steps when a new element is about to be appended to the non-increasing stack, choose the max. \\n\\n```Python\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        res, stack = 0, list()\\n        stack.append([nums[-1],0])\\n        for i in range(len(nums)-2, -1,-1):              \\n            cnt = 0\\n            while stack and nums[i] > stack[-1][0]:\\n                val, step = stack.pop()\\n                cnt = max(cnt, step)\\n                cnt += 1\\n            res = max(res, cnt)\\n            if stack: \\n                stack[-1][1]  = max(cnt, stack[-1][1])\\n            stack.append([nums[i],0])\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```Python\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        res, stack = 0, list()\\n        stack.append([nums[-1],0])\\n        for i in range(len(nums)-2, -1,-1):              \\n            cnt = 0\\n            while stack and nums[i] > stack[-1][0]:\\n                val, step = stack.pop()\\n                cnt = max(cnt, step)\\n                cnt += 1\\n            res = max(res, cnt)\\n            if stack: \\n                stack[-1][1]  = max(cnt, stack[-1][1])\\n            stack.append([nums[i],0])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2090753,
                "title": "c-monotonic-stack-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        //monotonic stack\\n        int n = nums.size();\\n        int ans = 0;\\n        int cnt = 0;\\n        stack<pair<int, int>> st;\\n        st.push({nums[n-1], 0});\\n        for(int i= n-2; i>=0; i--){\\n            cnt = 0;\\n            while(!st.empty() && nums[i]>st.top().first){\\n                cnt = max(cnt+1, st.top().second);\\n                st.pop();\\n            }\\n            \\n            ans = max(ans, cnt);\\n            st.push({nums[i], cnt});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        //monotonic stack\\n        int n = nums.size();\\n        int ans = 0;\\n        int cnt = 0;\\n        stack<pair<int, int>> st;\\n        st.push({nums[n-1], 0});\\n        for(int i= n-2; i>=0; i--){\\n            cnt = 0;\\n            while(!st.empty() && nums[i]>st.top().first){\\n                cnt = max(cnt+1, st.top().second);\\n                st.pop();\\n            }\\n            \\n            ans = max(ans, cnt);\\n            st.push({nums[i], cnt});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2088220,
                "title": "python-monotonic-stack-o-n-100",
                "content": "```\\n\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        nums.reverse()\\n        monostack=[[0,0]]\\n        #monotonicstack [lastIndex, numberOfDeletion]\\n        res=0\\n        print(nums)\\n        for index in range(1,len(nums)):\\n            #Deletion count for cur index is 0.\\n            cnt=0\\n            #keep deleting value if incoming value is greater than current top of stack\\n            while monostack and nums[monostack[-1][0]]<nums[index]:\\n                num,delcnt=monostack.pop()\\n                #ensure you carry forward your deletion from previous streak\\n                cnt=max(cnt+1,delcnt)\\n                res=max(res,cnt)\\n            monostack.append([index,cnt])\\n        return res\\n\\t``",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        nums.reverse()\\n        monostack=[[0,0]]\\n        #monotonicstack [lastIndex, numberOfDeletion]\\n        res=0\\n        print(nums)\\n        for index in range(1,len(nums)):\\n            #Deletion count for cur index is 0.\\n            cnt=0\\n            #keep deleting value if incoming value is greater than current top of stack\\n            while monostack and nums[monostack[-1][0]]<nums[index]:\\n                num,delcnt=monostack.pop()\\n                #ensure you carry forward your deletion from previous streak\\n                cnt=max(cnt+1,delcnt)\\n                res=max(res,cnt)\\n            monostack.append([index,cnt])\\n        return res\\n\\t``",
                "codeTag": "Java"
            },
            {
                "id": 2087410,
                "title": "java-100-stack",
                "content": "```\\nclass Solution {\\n    \\n    \\n    \\n    public int totalSteps(int[] nums) {\\n        \\n        int n = nums.length;\\n        int ans = 0;\\n        \\n        Stack<Pair<Integer,Integer>> st = new Stack();\\n        \\n        st.push(new Pair(nums[n-1],0));\\n        \\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            int count = 0;\\n            \\n            while(!st.isEmpty() && nums[i] > st.peek().getKey())\\n            {\\n                count = Math.max(count+1 , st.peek().getValue() );\\n                st.pop();\\n            }\\n            \\n            ans = Math.max(ans , count);\\n            st.push(new Pair(nums[i],count));\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    \\n    \\n    \\n    public int totalSteps(int[] nums) {\\n        \\n        int n = nums.length;\\n        int ans = 0;\\n        \\n        Stack<Pair<Integer,Integer>> st = new Stack();\\n        \\n        st.push(new Pair(nums[n-1],0));\\n        \\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            int count = 0;\\n            \\n            while(!st.isEmpty() && nums[i] > st.peek().getKey())\\n            {\\n                count = Math.max(count+1 , st.peek().getValue() );\\n                st.pop();\\n            }\\n            \\n            ans = Math.max(ans , count);\\n            st.push(new Pair(nums[i],count));\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086826,
                "title": "c-easy-to-understand-monotonic-stack-approach-with-explanation",
                "content": "**We need to form a non-decreasing sequence. so, we need to remove all the values which makes our sequence decreasing in nature. Thus we use monotonic stack to find the count of numbers after a particular index which are needed to be removed to make the sequence non-decreasing. And we need to find the maximum of all of those counts because the number of steps to be stimulated to get the required ans would be obtained by doing the removal procedure for that many number of times.**\\n```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int n=nums.size();\\n        stack<pair<int,int> > st;\\n        st.push({nums[n-1],0});\\n        int res=0;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            int count=0;\\n            while(!st.empty()&&st.top().first<nums[i])\\n            {\\n                count=max(count+1,st.top().second);\\n                st.pop();\\n            }\\n            res=max(res,count);\\n            st.push({nums[i],count});\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int n=nums.size();\\n        stack<pair<int,int> > st;\\n        st.push({nums[n-1],0});\\n        int res=0;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            int count=0;\\n            while(!st.empty()&&st.top().first<nums[i])\\n            {\\n                count=max(count+1,st.top().second);\\n                st.pop();\\n            }\\n            res=max(res,count);\\n            st.push({nums[i],count});\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085918,
                "title": "c-easy-stack",
                "content": "class Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        vector<int>v(n);\\n        stack<int>st;\\n        int ans=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(!st.empty() && nums[i]>nums[st.top()])\\n            {\\n                v[i]=max(v[i]+1,v[st.top()]);\\n                st.pop();\\n            }\\n            st.push(i);\\n            ans=max(ans,v[i]);\\n        }\\n        //for(auto it:a)\\n            //cout<<it<<\" \";\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        vector<int>v(n);\\n        stack<int>st;\\n        int ans=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(!st.empty() && nums[i]>nums[st.top()])\\n            {\\n                v[i]=max(v[i]+1,v[st.top()]);\\n                st.pop();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2085763,
                "title": "c-monotonic-stack-segment-tree-explained",
                "content": "For each index i , we will first find the index having value greater than the current value of nums[i]. We will remove current element with this index but for that we have to remove the elements in between them, so for that we can create a segment tree and take maximum of all the values between those index.\\n\\nMax value+1 will be the step at which we can remove this element and we will update the segment tree accordingly.\\n\\n```\\nclass Solution\\n{\\npublic:\\n    const int N = 1e5 + 5;\\n    struct tree\\n    {\\n        int t[400020];\\n        // Dont use build tree better use point update\\n\\n        void update(int v, int tl, int tr, int pos, int val)\\n        {\\n            if (tl == tr)\\n            {\\n                t[v] = val;\\n                return;\\n            }\\n            int mid = (tl + tr) / 2;\\n            if (pos <= mid)\\n                update(2 * v, tl, mid, pos, val);\\n            else\\n                update(2 * v + 1, mid + 1, tr, pos, val);\\n            t[v] = max(t[2 * v], t[2 * v + 1]);\\n        }\\n\\n        int query(int v, int tl, int tr, int l, int r)\\n        {\\n            if (tr < l || tl > r)\\n                return 0;\\n            if (l <= tl && tr <= r)\\n                return t[v];\\n            int mid = (tl + tr) / 2;\\n            return max(query(2 * v, tl, mid, l, r), query(2 * v + 1, mid + 1, tr, l, r));\\n        }\\n        void clr(int n)\\n        {\\n            for (int i = 0; i < 4 * n + 5; i++)\\n                t[i] = 0;\\n        }\\n    };\\n    int totalSteps(vector<int> &nums)\\n    {\\n        tree seg;\\n\\n        int n = nums.size();\\n        seg.clr(n + 1);\\n        int dp[n];\\n        memset(dp, 0, sizeof(dp));\\n        stack<int> stk;\\n        stk.push(0);\\n        seg.update(1, 0, n, 0, 0);\\n        int ans = 0;\\n        for (int i = 1; i < n; i++)\\n        {\\n            while (stk.size() && nums[stk.top()] <= nums[i])\\n                stk.pop();\\n            if (stk.size())\\n            {\\n                int mn = seg.query(1, 0, n, stk.top() + 1, i);\\n                dp[i] = mn + 1;\\n                seg.update(1, 0, n, i, dp[i]);\\n            }\\n            stk.push(i);\\n            ans = max(ans, dp[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Tree",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    const int N = 1e5 + 5;\\n    struct tree\\n    {\\n        int t[400020];\\n        // Dont use build tree better use point update\\n\\n        void update(int v, int tl, int tr, int pos, int val)\\n        {\\n            if (tl == tr)\\n            {\\n                t[v] = val;\\n                return;\\n            }\\n            int mid = (tl + tr) / 2;\\n            if (pos <= mid)\\n                update(2 * v, tl, mid, pos, val);\\n            else\\n                update(2 * v + 1, mid + 1, tr, pos, val);\\n            t[v] = max(t[2 * v], t[2 * v + 1]);\\n        }\\n\\n        int query(int v, int tl, int tr, int l, int r)\\n        {\\n            if (tr < l || tl > r)\\n                return 0;\\n            if (l <= tl && tr <= r)\\n                return t[v];\\n            int mid = (tl + tr) / 2;\\n            return max(query(2 * v, tl, mid, l, r), query(2 * v + 1, mid + 1, tr, l, r));\\n        }\\n        void clr(int n)\\n        {\\n            for (int i = 0; i < 4 * n + 5; i++)\\n                t[i] = 0;\\n        }\\n    };\\n    int totalSteps(vector<int> &nums)\\n    {\\n        tree seg;\\n\\n        int n = nums.size();\\n        seg.clr(n + 1);\\n        int dp[n];\\n        memset(dp, 0, sizeof(dp));\\n        stack<int> stk;\\n        stk.push(0);\\n        seg.update(1, 0, n, 0, 0);\\n        int ans = 0;\\n        for (int i = 1; i < n; i++)\\n        {\\n            while (stk.size() && nums[stk.top()] <= nums[i])\\n                stk.pop();\\n            if (stk.size())\\n            {\\n                int mn = seg.query(1, 0, n, stk.top() + 1, i);\\n                dp[i] = mn + 1;\\n                seg.update(1, 0, n, i, dp[i]);\\n            }\\n            stk.push(i);\\n            ans = max(ans, dp[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677450,
                "title": "stack-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<pair<int,int>>st;\\n        int n=nums.size();\\n        int ans=0;\\n        st.push({nums[n-1],0});\\n       for(int i=n-2;i>=0;i--){\\n            int cnt=0;\\n            while(!st.empty() && st.top().first<nums[i]){\\n                \\n                cnt=max(cnt+1,st.top().second);\\n                st.pop();\\n            }\\n            ans=max(cnt,ans);\\n            st.push({nums[i],cnt});\\n       } \\n\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<pair<int,int>>st;\\n        int n=nums.size();\\n        int ans=0;\\n        st.push({nums[n-1],0});\\n       for(int i=n-2;i>=0;i--){\\n            int cnt=0;\\n            while(!st.empty() && st.top().first<nums[i]){\\n                \\n                cnt=max(cnt+1,st.top().second);\\n                st.pop();\\n            }\\n            ans=max(cnt,ans);\\n            st.push({nums[i],cnt});\\n       } \\n\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511494,
                "title": "efficient-algorithm-for-making-an-array-non-decreasing-with-step-by-step-visualization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem asks us to find the minimum number of steps required to make the input array non-decreasing. One way to approach this problem is to keep track of the elements in the array that need to be removed in order to make it non-decreasing.\\n\\nTo make the given array non-decreasing, we need to remove the elements that violate the non-decreasing condition. The idea is to make the smallest possible modifications to the array to make it non-decreasing. Therefore, we can choose to remove the elements that are smaller than the previous element and make them equal to the previous element. This way, we only need to modify the array elements that violate the non-decreasing condition. We can count the number of modifications made to the array to make it non-decreasing, which gives us the number of steps required to solve the problem.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo implement the above intuition, we can iterate over the input array and check if the current element is smaller than the previous element. If it is smaller, we remove the current element and make it equal to the previous element. We also update the steps count by the difference between the previous element and the current element. At the end of the loop, we would have made all necessary modifications to the array to make it non-decreasing. The steps count gives us the number of modifications made to the array to achieve this condition. We return this count as the final result.\\n\\n\\nWe can use a stack to keep track of the elements in the array that need to be removed. We iterate through the input array and for each element, we check if it is greater than or equal to the top element of the stack. If it is, we pop elements from the stack until we find an element that is greater than the current element or until the stack is empty. We then update a variable temp with the maximum value of the second element of the tuples in the stack. If the stack is not empty, we increment temp by 1. Otherwise, we set temp to 0. We then update a variable steps with the maximum value of steps and temp. Finally, we append a tuple containing the current element and temp to the stack.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity: The time complexity of our approach is O(n), where n is the length of the input array. We are iterating over the input array only once, and the time taken to modify an element is constant. Therefore, the overall time complexity of our approach is linear.\\n\\nTime complexity: O(n)\\n\\nThe time complexity of this solution is linear because we iterate through the input array once and for each element, we perform a constant number of operations.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity: The space complexity of our approach is O(1), as we are not using any extra data structures to store the intermediate results. We are modifying the input array in-place, so there is no extra space used apart from the input array itself. Therefore, the space complexity of our approach is constant.\\n\\n\\nSpace complexity: O(n)\\n\\nThe space complexity of this solution is linear because we use a stack to keep track of the elements in the array that need to be removed.\\n\\n\\n![download.png](https://assets.leetcode.com/users/images/94e3429f-e8b7-4f5f-b761-ed907c2a835b_1683789403.5844448.png)\\n\\n\\n\\n\\n\\n# Code\\n```C++ []\\n\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<pair<int, int>> stack;\\n        stack.push({nums[0], 0});\\n        int steps = 0;\\n        for (int i = 1; i < nums.size(); i++) {\\n            int temp = 0;\\n            while (!stack.empty() && stack.top().first <= nums[i]) {\\n                temp = max(temp, stack.top().second);\\n                stack.pop();\\n            }\\n            if (!stack.empty()) {\\n                temp += 1;\\n            } else {\\n                temp = 0;\\n            }\\n            steps = max(steps, temp);\\n            stack.push({nums[i], temp});\\n        }\\n        return steps;\\n    }\\n};\\n\\n```\\n```python []\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        stack = [[nums[0], 0]]\\n        steps = 0\\n        for num in nums[1:]:\\n            temp = 0\\n            while stack and stack[-1][0] <= num:\\n                temp = max(temp, stack[-1][1])\\n                stack.pop()\\n            if stack:\\n                temp += 1\\n            else:\\n                temp = 0\\n            steps = max(steps, temp)\\n            stack.append([num, temp])\\n        return steps\\n\\n```\\n```java []\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        Stack<int[]> stack = new Stack<>();\\n        stack.push(new int[]{nums[0], 0});\\n        int steps = 0;\\n        for (int i = 1; i < nums.length; i++) {\\n            int temp = 0;\\n            while (!stack.isEmpty() && stack.peek()[0] <= nums[i]) {\\n                temp = Math.max(temp, stack.peek()[1]);\\n                stack.pop();\\n            }\\n            if (!stack.isEmpty()) {\\n                temp += 1;\\n            } else {\\n                temp = 0;\\n            }\\n            steps = Math.max(steps, temp);\\n            stack.push(new int[]{nums[i], temp});\\n        }\\n        return steps;\\n    }\\n}\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```C++ []\\n\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<pair<int, int>> stack;\\n        stack.push({nums[0], 0});\\n        int steps = 0;\\n        for (int i = 1; i < nums.size(); i++) {\\n            int temp = 0;\\n            while (!stack.empty() && stack.top().first <= nums[i]) {\\n                temp = max(temp, stack.top().second);\\n                stack.pop();\\n            }\\n            if (!stack.empty()) {\\n                temp += 1;\\n            } else {\\n                temp = 0;\\n            }\\n            steps = max(steps, temp);\\n            stack.push({nums[i], temp});\\n        }\\n        return steps;\\n    }\\n};\\n\\n```\n```python []\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        stack = [[nums[0], 0]]\\n        steps = 0\\n        for num in nums[1:]:\\n            temp = 0\\n            while stack and stack[-1][0] <= num:\\n                temp = max(temp, stack[-1][1])\\n                stack.pop()\\n            if stack:\\n                temp += 1\\n            else:\\n                temp = 0\\n            steps = max(steps, temp)\\n            stack.append([num, temp])\\n        return steps\\n\\n```\n```java []\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        Stack<int[]> stack = new Stack<>();\\n        stack.push(new int[]{nums[0], 0});\\n        int steps = 0;\\n        for (int i = 1; i < nums.length; i++) {\\n            int temp = 0;\\n            while (!stack.isEmpty() && stack.peek()[0] <= nums[i]) {\\n                temp = Math.max(temp, stack.peek()[1]);\\n                stack.pop();\\n            }\\n            if (!stack.isEmpty()) {\\n                temp += 1;\\n            } else {\\n                temp = 0;\\n            }\\n            steps = Math.max(steps, temp);\\n            stack.push(new int[]{nums[i], temp});\\n        }\\n        return steps;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3246670,
                "title": "c-solution-o-n",
                "content": "# Complexity\\n- Time complexity:\\n   O(n)\\n\\n- Space complexity:\\n  O(n) --- (using stack)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n         int n = nums.size();\\n         int result = 0;\\n         stack<pair<int , int>> st;\\n         st.push({nums[n-1] , 0});\\n         for(int i = n - 2 ; i>=0 ; i--){\\n             int count = 0;\\n             while(st.size() && st.top().first < nums[i]){\\n                 int node = st.top().first;\\n                 int ways = st.top().second;\\n\\n                 st.pop();\\n\\n                 if(ways <= count)count++;\\n                 else count = ways;\\n             }\\n            //  result = max(result , count);\\n             st.push({nums[i] , count});\\n         }\\n         while(st.size()){\\n             result = max(result , st.top().second);\\n             st.pop();\\n         }\\n         return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n         int n = nums.size();\\n         int result = 0;\\n         stack<pair<int , int>> st;\\n         st.push({nums[n-1] , 0});\\n         for(int i = n - 2 ; i>=0 ; i--){\\n             int count = 0;\\n             while(st.size() && st.top().first < nums[i]){\\n                 int node = st.top().first;\\n                 int ways = st.top().second;\\n\\n                 st.pop();\\n\\n                 if(ways <= count)count++;\\n                 else count = ways;\\n             }\\n            //  result = max(result , count);\\n             st.push({nums[i] , count});\\n         }\\n         while(st.size()){\\n             result = max(result , st.top().second);\\n             st.pop();\\n         }\\n         return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3140147,
                "title": "stack-with-intuition-and-intuition-explanation",
                "content": "# Intuition\\nSince the current element will be removed when there is an element greater than it, we should process from backward to the front. Since the stack can help you determine where the nearest element that is greater than the current element (739. Daily Temperatures) is on the left or right side, we should use the stack!\\n\\nThe key to this concept is to know in which round(s) the following element will be removed for each element. Then find the maximum of those rounds.\\n\\n# Approach\\nTo find the round(s) that will be removed from each element, the first step is to determine the nearest element on the left side that is greater than it and find the difference between the indexes. For example, in 5 3 2 1, you can see that 3, 2, and 1 will be removed at the first round since each of them on the left has the greater element and the difference between the indexes is \"1.\"\\n\\nIf we apply the same approach to Example 5 (3, 4, 4, 7), we can see that the maximum round is 3 because the element at index 3 is 3 units away from the first index (3-0 = 3).\\n\\nThis approach seems nice, but the only problem here is that sometimes the leftmost greater element may come closer than it should be in some rounds! For example, in 7 14 4 14 13 2 6 13, the most left element that is greater than the last element is 14, which is on the third index, and the difference index between them is 4, but in the first round, the index numbers 2, 4, and 5 are removed, so it now becomes [7, 14, 14, 6, 13], and the difference between the index of the last element and its most left greatest element is now 2, (4-2 = 2), indicating that it is closer than it should be. So this approach will fail, but we should figure out how many rounds the left element can survive.\\n\\nSo we should record some data, which is what round(s) their left-side element will be removed, and now when we want to remove some elements, we will use this record to determine what round the left-side element can survive to determine the current element. To explain in words is cumbersome, so please look at the code.\\n\\n# Complexity\\n- Time complexity:\\n$$\\u0398(n)$$\\n\\n- Space complexity:\\n$$\\u0398(n)$$\\n\\n# Code\\n```\\n#include<iostream>\\n#include<vector>\\n#include<stack>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        const int N = (int)nums.size();\\n        if(N == 1) return 0;\\n\\n        int maxround = 0;\\n        // stack will keep the index of the element.\\n        stack<int> stack{};\\n        vector<int> records(N);\\n\\n        for(int i = N-1; i >= 0;--i){\\n            while(!stack.empty() && nums[stack.top()] < nums[i]){\\n                // Since it found the most left element that is greather than the current element\\n                // The current round is the maximum round(s) record that the currently removed element knows + 1.\\n                int current = records[stack.top()] + 1;\\n                maxround = max(maxround,current);\\n                stack.pop();\\n                // So we inform the maximum round that this element can survive to the next element after that.\\xA0\\n                // When it is removed, it will know what the maximum is by determining the maximum record that we saved.\\n                if(!stack.empty()) \\n                    records[stack.top()] = max(records[stack.top()],current);\\n            }\\n            stack.push(i);\\n        }\\n\\n        return maxround;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include<iostream>\\n#include<vector>\\n#include<stack>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        const int N = (int)nums.size();\\n        if(N == 1) return 0;\\n\\n        int maxround = 0;\\n        // stack will keep the index of the element.\\n        stack<int> stack{};\\n        vector<int> records(N);\\n\\n        for(int i = N-1; i >= 0;--i){\\n            while(!stack.empty() && nums[stack.top()] < nums[i]){\\n                // Since it found the most left element that is greather than the current element\\n                // The current round is the maximum round(s) record that the currently removed element knows + 1.\\n                int current = records[stack.top()] + 1;\\n                maxround = max(maxround,current);\\n                stack.pop();\\n                // So we inform the maximum round that this element can survive to the next element after that.\\xA0\\n                // When it is removed, it will know what the maximum is by determining the maximum record that we saved.\\n                if(!stack.empty()) \\n                    records[stack.top()] = max(records[stack.top()],current);\\n            }\\n            stack.push(i);\\n        }\\n\\n        return maxround;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2697579,
                "title": "java-solution-explanation",
                "content": "```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        int n = nums.length;\\n        //Stack of pairs consists of nums value and count\\n        Stack<Pair<Integer,Integer>> stack = new Stack();\\n        \\n        //Push the last element of nums in to stack\\n        stack.push(new Pair<>(nums[n-1],0));\\n        \\n        int ans = 0;\\n        \\n        //traverse from right left of nums\\n        for(int i = n-2;i>=0;i--){\\n            \\n            int count = 0;\\n            \\n            while(!stack.isEmpty() && nums[i]>stack.peek().getKey()){\\n                \\n//Count determines max how many times the condition nums[i-1]>nums[i] is encountured\\n                count = Math.max(count+1,stack.peek().getValue());\\n                \\n    //After that remove the top pair from the stack\\n                stack.pop();\\n            }\\n            \\n            //The maximum steps depends on the maximum count in each step\\n            //So, make sure to calculate maximum of count\\'s\\n            ans  = Math.max(ans,count);\\n            \\n            //Add next element of the nums in to stack with present count\\n            stack.push(new Pair(nums[i],count));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        int n = nums.length;\\n        //Stack of pairs consists of nums value and count\\n        Stack<Pair<Integer,Integer>> stack = new Stack();\\n        \\n        //Push the last element of nums in to stack\\n        stack.push(new Pair<>(nums[n-1],0));\\n        \\n        int ans = 0;\\n        \\n        //traverse from right left of nums\\n        for(int i = n-2;i>=0;i--){\\n            \\n            int count = 0;\\n            \\n            while(!stack.isEmpty() && nums[i]>stack.peek().getKey()){\\n                \\n//Count determines max how many times the condition nums[i-1]>nums[i] is encountured\\n                count = Math.max(count+1,stack.peek().getValue());\\n                \\n    //After that remove the top pair from the stack\\n                stack.pop();\\n            }\\n            \\n            //The maximum steps depends on the maximum count in each step\\n            //So, make sure to calculate maximum of count\\'s\\n            ans  = Math.max(ans,count);\\n            \\n            //Add next element of the nums in to stack with present count\\n            stack.push(new Pair(nums[i],count));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2571209,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\nint totalSteps(vector& nums) {\\nint n=nums.size(); //Taking the size of the array\\nstack<pair<int,int>>st; //making a stack of pair type to hold the key value pair\\n//in key placeholder I will store the element and in value placeholder I will hold the number of rounds.\\nint ans=0;\\nst.push({nums[n-1],0}); //storing the first element from right\\nfor(int i=n-2;i>=0;i--) //start to iterate from the second last element\\n{\\nint count=0;\\nwhile(!st.empty() and nums[i]>st.top().first) //if the element pushed at the top of the stack is greater than the element which was previously at the top then we will remove the previous element and increase the count against the number of elements which is popped out\\n{\\ncount=max(count+1,st.top().second);\\nst.pop();\\n\\n        }\\n        \\n        ans=max(ans,count);\\n        st.push({nums[i],count});  //else simply push the element\\n    }\\n    return ans;\\n}\\n};\\n``",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\nint totalSteps(vector& nums) {\\nint n=nums.size(); //Taking the size of the array\\nstack<pair<int,int>>st; //making a stack of pair type to hold the key value pair\\n//in key placeholder I will store the element and in value placeholder I will hold the number of rounds.\\nint ans=0;\\nst.push({nums[n-1],0}",
                "codeTag": "Java"
            },
            {
                "id": 2516529,
                "title": "java-stack-time-o-n-space-o-n",
                "content": "```Java\\nclass Solution {\\n/*\\n\\t[6,4,3,2,5,14,15,2,11,5,13,15]\\n\\t 6,        14,15,          15 \\n\\n\\t the process of delete 4,3,2,5\\n\\t stack: []\\n\\t detele 4\\n\\t stack: [4, 1]   // [value, deleteCount]\\n\\t delete 3\\n\\t stack: [4, 1], [3, 1]\\n\\t delete 2\\n\\t stack: [4, 1], [3, 1], [2, 1]\\n\\t detele 5, \\n\\t 5 is greater or equal to 2, pop [2, 1], max = Math(max, 1 + 1) = 2;\\n\\t 5 is greater or equal to 3, pop [3, 1], max = Math(max, 1 + 1) = 2;\\n\\t 5 is greater or equal to 3, pop [4, 1], max = Math(max, 1 + 1) = 2;\\n\\t push [5, 2]\\n\\t stack: [5, 2]\\n\\n\\t the process of delete 2, 11, 5, 13\\n\\t delete 2\\n\\t stack: [2, 1]\\n\\t detete 11\\n\\t stack: [11, 2]\\n\\t delete 5\\n\\t stack:[11, 2], [5, 1]\\n\\t delete 13\\n\\t stack:[13, 3]\\n*/\\n\\n\\tpublic int totalSteps(int[] nums) {\\n\\t\\tint res = 0;\\n\\t\\tint n = nums.length;\\n\\n\\t\\tStack<int[]> stack = new Stack<>(); // int[]{value, deleteCount}\\n\\t\\tint maxValue = nums[0];\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tif (nums[i] >= maxValue) {\\n\\t\\t\\t\\tmaxValue = nums[i];\\n\\t\\t\\t\\tstack = new Stack<>();\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tint max = 1;\\n\\t\\t\\twhile (!stack.empty() && stack.peek()[0] <= nums[i]) {\\n\\t\\t\\t\\tmax = Math.max(max, 1 + stack.pop()[1]);\\n\\t\\t\\t}\\n\\t\\t\\tres = Math.max(res, max);\\n\\t\\t\\tstack.push(new int[]{nums[i], max});\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```Java\\nclass Solution {\\n/*\\n\\t[6,4,3,2,5,14,15,2,11,5,13,15]\\n\\t 6,        14,15,          15 \\n\\n\\t the process of delete 4,3,2,5\\n\\t stack: []\\n\\t detele 4\\n\\t stack: [4, 1]   // [value, deleteCount]\\n\\t delete 3\\n\\t stack: [4, 1], [3, 1]\\n\\t delete 2\\n\\t stack: [4, 1], [3, 1], [2, 1]\\n\\t detele 5, \\n\\t 5 is greater or equal to 2, pop [2, 1], max = Math(max, 1 + 1) = 2;\\n\\t 5 is greater or equal to 3, pop [3, 1], max = Math(max, 1 + 1) = 2;\\n\\t 5 is greater or equal to 3, pop [4, 1], max = Math(max, 1 + 1) = 2;\\n\\t push [5, 2]\\n\\t stack: [5, 2]\\n\\n\\t the process of delete 2, 11, 5, 13\\n\\t delete 2\\n\\t stack: [2, 1]\\n\\t detete 11\\n\\t stack: [11, 2]\\n\\t delete 5\\n\\t stack:[11, 2], [5, 1]\\n\\t delete 13\\n\\t stack:[13, 3]\\n*/\\n\\n\\tpublic int totalSteps(int[] nums) {\\n\\t\\tint res = 0;\\n\\t\\tint n = nums.length;\\n\\n\\t\\tStack<int[]> stack = new Stack<>(); // int[]{value, deleteCount}\\n\\t\\tint maxValue = nums[0];\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tif (nums[i] >= maxValue) {\\n\\t\\t\\t\\tmaxValue = nums[i];\\n\\t\\t\\t\\tstack = new Stack<>();\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tint max = 1;\\n\\t\\t\\twhile (!stack.empty() && stack.peek()[0] <= nums[i]) {\\n\\t\\t\\t\\tmax = Math.max(max, 1 + stack.pop()[1]);\\n\\t\\t\\t}\\n\\t\\t\\tres = Math.max(res, max);\\n\\t\\t\\tstack.push(new int[]{nums[i], max});\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2328058,
                "title": "c-easy-solution-using-stack",
                "content": "**Please Upvote**\\n```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int ans=0;\\n        \\n        stack<pair<int,int>>s;\\n        \\n        for(int i=nums.size()-1;i>=0;i--){\\n            if(s.empty())s.push({nums[i],0});\\n            \\n            else{\\n                int a=0;\\n                while(!s.empty() && s.top().first<nums[i]){\\n                    a=max(a+1,s.top().second);\\n                    s.pop();\\n                }\\n                s.push({nums[i],a});\\n                ans=max(ans,a);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int ans=0;\\n        \\n        stack<pair<int,int>>s;\\n        \\n        for(int i=nums.size()-1;i>=0;i--){\\n            if(s.empty())s.push({nums[i],0}",
                "codeTag": "Java"
            },
            {
                "id": 2232808,
                "title": "c-stack-o-n-easy-code-for-beginners",
                "content": "```\\nint totalSteps(vector<int>& nums) {\\n        int n = nums.size();\\n        stack<pair<int, int> > stk;\\n        int ans = 0;\\n        //first: number itself\\n        //second: the step in which it will get deleted\\n        //first element will never get deleted so its second param is 0\\n        stk.push({nums[0], 0});\\n        for (int i = 1; i < n; i++) {\\n            int mx = 0;\\n            while (!stk.empty() && stk.top().first <= nums[i]) {\\n                mx = max(mx, stk.top().second);\\n                stk.pop();\\n            }\\n            if (stk.empty()) {\\n                stk.push({nums[i], 0});\\n                continue;\\n            } else {\\n                stk.push({nums[i], mx + 1});\\n            }\\n            ans = max(ans, mx + 1);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nint totalSteps(vector<int>& nums) {\\n        int n = nums.size();\\n        stack<pair<int, int> > stk;\\n        int ans = 0;\\n        //first: number itself\\n        //second: the step in which it will get deleted\\n        //first element will never get deleted so its second param is 0\\n        stk.push({nums[0], 0});\\n        for (int i = 1; i < n; i++) {\\n            int mx = 0;\\n            while (!stk.empty() && stk.top().first <= nums[i]) {\\n                mx = max(mx, stk.top().second);\\n                stk.pop();\\n            }\\n            if (stk.empty()) {\\n                stk.push({nums[i], 0});\\n                continue;\\n            } else {\\n                stk.push({nums[i], mx + 1});\\n            }\\n            ans = max(ans, mx + 1);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2202868,
                "title": "c-stack-pair-great-question",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<pair<int, int>> st;\\n        st.push({nums[0], 0});\\n        int n = nums.size();\\n        int ans = 0;\\n        \\n        for(int i = 1; i < n; i++) {\\n            int cnt = 0;\\n            while(!st.empty() && st.top().first <= nums[i]) {\\n                cnt = max(cnt, st.top().second); // max of steps to remove (=)smaller elements before nums[i]\\n                st.pop();\\n            }\\n            \\n            if(st.empty()) { // no smaller element before nums[i], or nums[i] is largest element encountered so far\\n                cnt = 0;\\n            } else {\\n                cnt = cnt + 1; // there is a larger element somewhere before nums[i]\\n            }\\n            ans = max(ans, cnt);\\n            st.push({nums[i], cnt});\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<pair<int, int>> st;\\n        st.push({nums[0], 0});\\n        int n = nums.size();\\n        int ans = 0;\\n        \\n        for(int i = 1; i < n; i++) {\\n            int cnt = 0;\\n            while(!st.empty() && st.top().first <= nums[i]) {\\n                cnt = max(cnt, st.top().second); // max of steps to remove (=)smaller elements before nums[i]\\n                st.pop();\\n            }\\n            \\n            if(st.empty()) { // no smaller element before nums[i], or nums[i] is largest element encountered so far\\n                cnt = 0;\\n            } else {\\n                cnt = cnt + 1; // there is a larger element somewhere before nums[i]\\n            }\\n            ans = max(ans, cnt);\\n            st.push({nums[i], cnt});\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2114786,
                "title": "python-simple-stack-solution",
                "content": "\\n    def totalSteps(self, nums):\\n        n = len(nums)\\n        \\n        dp, stack = [0]*n, []\\n        \\n        for i in range(n-1, -1, -1):\\n            while stack and nums[i] > nums[stack[-1]]:\\n                dp[i] = max(dp[i] + 1, dp[stack.pop()])\\n            stack.append(i)\\n            \\n        return max(dp)",
                "solutionTags": [],
                "code": "\\n    def totalSteps(self, nums):\\n        n = len(nums)\\n        \\n        dp, stack = [0]*n, []\\n        \\n        for i in range(n-1, -1, -1):\\n            while stack and nums[i] > nums[stack[-1]]:\\n                dp[i] = max(dp[i] + 1, dp[stack.pop()])\\n            stack.append(i)\\n            \\n        return max(dp)",
                "codeTag": "Python3"
            },
            {
                "id": 2113732,
                "title": "c-dp-stacks",
                "content": "The bruteforce approach would be to create a buffer array and push all the elements in it that satisfies the criteria to not be deleted, i.e. ```A[i-1] <= A[i]```\\nAnd after one traversal, swap the buffer array with the original array.\\nThese steps would be repeated until all elements in the array are in non-decreasing order.\\nBut this approach would throw TLE for ```n > 10^4```\\n\\nOptimal approach.\\nFor every element ```i```, we can find the number of consecutive elements less than it on the right side and save it in ```dp[i]```.\\nThen we can get the max steps as the max of all the ```dp[i]```.\\n\\n**Time Complexity:** ```O(n)```\\n\\n**Code:**\\n```\\n    int totalSteps(vector<int>& A) {\\n        int n = A.size(), steps = 0;\\n        vector<int> dp(n);\\n        stack<int> stack;\\n        \\n        for (int i=n-1 ; i>=0 ; i--) {\\n            while(!stack.empty() && A[i] > A[stack.top()]) {\\n                dp[i] = max(++dp[i], dp[stack.top()]);\\n                stack.pop();\\n                steps = max(steps, dp[i]);\\n            }\\n            stack.push(i);\\n        }\\n        \\n        return steps;\\n    }\\n```",
                "solutionTags": [],
                "code": "```A[i-1] <= A[i]```\n```n > 10^4```\n```i```\n```dp[i]```\n```dp[i]```\n```O(n)```\n```\\n    int totalSteps(vector<int>& A) {\\n        int n = A.size(), steps = 0;\\n        vector<int> dp(n);\\n        stack<int> stack;\\n        \\n        for (int i=n-1 ; i>=0 ; i--) {\\n            while(!stack.empty() && A[i] > A[stack.top()]) {\\n                dp[i] = max(++dp[i], dp[stack.top()]);\\n                stack.pop();\\n                steps = max(steps, dp[i]);\\n            }\\n            stack.push(i);\\n        }\\n        \\n        return steps;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2105211,
                "title": "c-element-which-finishes-last-monostack",
                "content": "* Solution Inspired By [Lee\\'s Post](https://leetcode.com/problems/steps-to-make-array-non-decreasing/discuss/2085864/JavaC%2B%2BPython-Stack-%2B-DP-%2B-Explanation-%2B-Poem)\\n* Element Which is greater than its immediate right element will eliminate the right element. (`ith` element gets deleted when `(i-1)th` element is greater).\\n* So , for all the indices `i` , where `nums[i-1]` `> nums[i]` , we have to find the index which will Keep on terminating the elements on its right for longer duration.\\n* For example, Consider the array [**2**,1,3,**4**,3,3,**5**,4,4,4], In This array Elements 2 , 4 and 5 (in Bold) are bigger than their just next right element. (i-1 > i)\\n* Each Element will simultaneously terminate elements on their immediate right, so that means, **2** will terminate -> 1 (in total 1 step) || **4** will terminate 3,3 (in total 2 steps-> in first steps 1st 3 get terminated and then in second steps 2nd 3 gets terminated) || **5** will terminate 4,4,4(in total 3 steps) , so the When all the elements simultaneously start terminating ,  the element which finishes last will yeild our steps (answer) . Here , answer will be 3 steps. \\n* Maintain a dp array and Start from the back of the array and Maintain elements  in decreasing order in stack , when a bigger elements is encountered , do calculations as mentioned below. dp[i] states the number of elements which the `ith` element can terminate to its right.\\n\\n```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n\\t   // i-1 terminates i\\n        stack<int> st ;\\n        vector<int> dp(nums.size(),0) ;\\n        int steps = 0 ;\\n        \\n        for(int i = nums.size() - 1 ; i >= 0 ; --i ){\\n            while(st.size() and nums[i] > nums[st.top()]){\\n                dp[i] = max(dp[i] + 1 , dp[st.top()]) ;\\n                st.pop() ;\\n            }\\n            steps = max(steps,dp[i]) ; //Elements which finishes last with max number of steps taken\\n            st.push(i) ;\\n        }\\n        \\n        return steps ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n\\t   // i-1 terminates i\\n        stack<int> st ;\\n        vector<int> dp(nums.size(),0) ;\\n        int steps = 0 ;\\n        \\n        for(int i = nums.size() - 1 ; i >= 0 ; --i ){\\n            while(st.size() and nums[i] > nums[st.top()]){\\n                dp[i] = max(dp[i] + 1 , dp[st.top()]) ;\\n                st.pop() ;\\n            }\\n            steps = max(steps,dp[i]) ; //Elements which finishes last with max number of steps taken\\n            st.push(i) ;\\n        }\\n        \\n        return steps ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2102500,
                "title": "simple-stack-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        reverse(nums.begin(), nums.end());\\n        vector<array<int, 2>> stk;\\n        int ans{0};\\n        for (int i : nums) {\\n            array<int, 2> p{i, 0};\\n            while(!stk.empty() && stk.back()[0] < p[0]) {\\n                p[1] = max(p[1] + 1, stk.back()[1]);\\n                stk.pop_back();\\n            }\\n            ans = max(ans, p[1]);\\n            stk.push_back(p);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        reverse(nums.begin(), nums.end());\\n        vector<array<int, 2>> stk;\\n        int ans{0};\\n        for (int i : nums) {\\n            array<int, 2> p{i, 0};\\n            while(!stk.empty() && stk.back()[0] < p[0]) {\\n                p[1] = max(p[1] + 1, stk.back()[1]);\\n                stk.pop_back();\\n            }\\n            ans = max(ans, p[1]);\\n            stk.push_back(p);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2100010,
                "title": "java-mono-stack",
                "content": "```\\npublic int totalSteps(int[] nums) {\\n\\t// mono-stack of peaks: [ peak value, length of non-decreasing streak leading to peak ]\\n\\tLinkedList<int[]> stack= new LinkedList<>();\\n\\tint ans= 0;\\n\\tfor(int i=1, streak= 0; i<nums.length; i++){\\n\\t\\tif(nums[i]<nums[i-1]){\\n\\t\\t\\tstack.addLast(new int[]{nums[i-1], streak});\\n\\t\\t\\tstreak= 1;\\n\\t\\t}else{\\n\\t\\t\\twhile(!stack.isEmpty() && nums[i]>=stack.peekLast()[0])\\n\\t\\t\\t\\tstreak= Math.max(streak, stack.removeLast()[1]);\\n\\t\\t\\tstreak= stack.isEmpty() ? 0 : streak+1;\\n\\t\\t}\\n\\t\\tans= Math.max(ans, streak);\\n\\t}\\n\\treturn ans;\\n}",
                "solutionTags": [],
                "code": "```\\npublic int totalSteps(int[] nums) {\\n\\t// mono-stack of peaks: [ peak value, length of non-decreasing streak leading to peak ]\\n\\tLinkedList<int[]> stack= new LinkedList<>();\\n\\tint ans= 0;\\n\\tfor(int i=1, streak= 0; i<nums.length; i++){\\n\\t\\tif(nums[i]<nums[i-1]){\\n\\t\\t\\tstack.addLast(new int[]{nums[i-1], streak});\\n\\t\\t\\tstreak= 1;\\n\\t\\t}else{\\n\\t\\t\\twhile(!stack.isEmpty() && nums[i]>=stack.peekLast()[0])\\n\\t\\t\\t\\tstreak= Math.max(streak, stack.removeLast()[1]);\\n\\t\\t\\tstreak= stack.isEmpty() ? 0 : streak+1;\\n\\t\\t}\\n\\t\\tans= Math.max(ans, streak);\\n\\t}\\n\\treturn ans;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2094970,
                "title": "c-doubly-linked-list-bfs-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        \\n        list<int> ls; //doubly linked list\\n        \\n        for (auto n : nums) ls.push_back(n);\\n        \\n        \\n        auto it = ls.begin();\\n        int prev = *it;\\n        \\n        it++;\\n        \\n        queue<list<int>::iterator> q;\\n        \\n        \\n        for (; it!=ls.end(); it++){\\n            \\n            if (prev > *it){\\n                //it needs to be removed\\n                q.push(it); //push the element to be removed in the queue\\n                *it = -*it; //mark this elemtn is in the queue\\n            }\\n            \\n            prev = abs(*it);\\n        }\\n        \\n        \\n        \\n        if (q.size() == 0) return 0;\\n        \\n        int steps = 0;\\n        \\n        while(q.size()>0){\\n            \\n            int size = q.size();\\n            \\n            steps++;\\n            \\n            while(size > 0){\\n                \\n                \\n                auto it = q.front();\\n                q.pop();\\n                \\n                auto pit = --it;\\n                \\n                it++;\\n                \\n                auto nit = ++it;\\n                \\n                it--;\\n                \\n                if (it != ls.begin() && nit != ls.end()){\\n                    \\n                    if (abs(*pit) > abs(*nit) && *nit > 0) {\\n                        \\n                        //nit needs to be removed in next round\\n                        \\n                        q.push(nit);\\n                        *nit = -*nit;\\n                    }\\n                }\\n                \\n                ls.erase(it);\\n                \\n                size--;\\n            }\\n        }\\n        \\n        return steps;\\n        \\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        \\n        list<int> ls; //doubly linked list\\n        \\n        for (auto n : nums) ls.push_back(n);\\n        \\n        \\n        auto it = ls.begin();\\n        int prev = *it;\\n        \\n        it++;\\n        \\n        queue<list<int>::iterator> q;\\n        \\n        \\n        for (; it!=ls.end(); it++){\\n            \\n            if (prev > *it){\\n                //it needs to be removed\\n                q.push(it); //push the element to be removed in the queue\\n                *it = -*it; //mark this elemtn is in the queue\\n            }\\n            \\n            prev = abs(*it);\\n        }\\n        \\n        \\n        \\n        if (q.size() == 0) return 0;\\n        \\n        int steps = 0;\\n        \\n        while(q.size()>0){\\n            \\n            int size = q.size();\\n            \\n            steps++;\\n            \\n            while(size > 0){\\n                \\n                \\n                auto it = q.front();\\n                q.pop();\\n                \\n                auto pit = --it;\\n                \\n                it++;\\n                \\n                auto nit = ++it;\\n                \\n                it--;\\n                \\n                if (it != ls.begin() && nit != ls.end()){\\n                    \\n                    if (abs(*pit) > abs(*nit) && *nit > 0) {\\n                        \\n                        //nit needs to be removed in next round\\n                        \\n                        q.push(nit);\\n                        *nit = -*nit;\\n                    }\\n                }\\n                \\n                ls.erase(it);\\n                \\n                size--;\\n            }\\n        }\\n        \\n        return steps;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2091919,
                "title": "c-o-n-solution-using-linked-list-by-simulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        list<int> inds;\\n        vector<int> tbdelete;\\n        vector<int> deleted(nums.size(), 0);\\n        vector<list<int>::iterator> its;\\n        for(int i = 0; i < nums.size(); i++) {\\n            inds.push_back(i);\\n            its.push_back(prev(inds.end()));\\n            if(i && nums[i] < nums[i-1]) tbdelete.push_back(i);\\n        }\\n        \\n        int res = 0;\\n        while(!tbdelete.empty()) {\\n            vector<int> nexttb;\\n            for(int i = tbdelete.size() - 1; i >= 0; i--) {\\n                if(deleted[tbdelete[i]]) continue;\\n                auto p = its[tbdelete[i]];\\n                auto nextp = next(p);\\n                bool ends = nextp == inds.end();\\n                while(p != inds.begin() && nums[*prev(p)] > nums[*p]) {\\n                    auto pre = prev(p);\\n                    deleted[*p] = 1;\\n                    inds.erase(p);\\n                    p = pre;                    \\n                }\\n                if(!ends && nextp != inds.begin() && nums[*nextp] < nums[*prev(nextp)]) {\\n                    nexttb.push_back(*nextp);\\n                }\\n            }\\n            tbdelete.swap(nexttb);\\n            reverse(tbdelete.begin(), tbdelete.end());\\n            res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        list<int> inds;\\n        vector<int> tbdelete;\\n        vector<int> deleted(nums.size(), 0);\\n        vector<list<int>::iterator> its;\\n        for(int i = 0; i < nums.size(); i++) {\\n            inds.push_back(i);\\n            its.push_back(prev(inds.end()));\\n            if(i && nums[i] < nums[i-1]) tbdelete.push_back(i);\\n        }\\n        \\n        int res = 0;\\n        while(!tbdelete.empty()) {\\n            vector<int> nexttb;\\n            for(int i = tbdelete.size() - 1; i >= 0; i--) {\\n                if(deleted[tbdelete[i]]) continue;\\n                auto p = its[tbdelete[i]];\\n                auto nextp = next(p);\\n                bool ends = nextp == inds.end();\\n                while(p != inds.begin() && nums[*prev(p)] > nums[*p]) {\\n                    auto pre = prev(p);\\n                    deleted[*p] = 1;\\n                    inds.erase(p);\\n                    p = pre;                    \\n                }\\n                if(!ends && nextp != inds.begin() && nums[*nextp] < nums[*prev(nextp)]) {\\n                    nexttb.push_back(*nextp);\\n                }\\n            }\\n            tbdelete.swap(nexttb);\\n            reverse(tbdelete.begin(), tbdelete.end());\\n            res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2089253,
                "title": "c-monotonic-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<pair<int,int>>st;\\n        int ans=0;\\n        for(int i=nums.size()-1;i>=0;--i){\\n            int c=0;\\n            while(!st.empty() && st.top().first<nums[i]){\\n                c=max(c+1,st.top().second);\\n                st.pop();\\n            }\\n            st.push({nums[i],c});\\n            ans=max(ans,c);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<pair<int,int>>st;\\n        int ans=0;\\n        for(int i=nums.size()-1;i>=0;--i){\\n            int c=0;\\n            while(!st.empty() && st.top().first<nums[i]){\\n                c=max(c+1,st.top().second);\\n                st.pop();\\n            }\\n            st.push({nums[i],c});\\n            ans=max(ans,c);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2088583,
                "title": "python-stack-with-thought-process-when-being-asked-during-interviews",
                "content": "### Stack\\nThe number `nums[i]` can be removed only if there is a number `nums[j]` such that `j < i and nums[j] > nums[i]`. So we can maintian a decreasing monotonic stack to get the closet greater number if there is. \\n\\nWith this stack, we can know by which number `nums[j]`, `nums[i]` can be removed. But we need to know what\\'s the order for `nums[i]` to remove. In order to remove `nums[i]`, all of elements between `nums[j:i + 1]` have to be removed first.\\n\\nThen we can remove `nums[i]` in the next round, so the number of round we can remove `nums[i]` equals to `max(round of nums[j: i+1]) + 1`, which can be calculated when the middle element is popped out from the stack.\\n\\nNote, if there is no number left in stack after popup, the current one is largest and no need to remove.\\n\\n```python\\ndef totalSteps(self, nums: List[int]) -> int:\\n\\tstack = []\\n\\trounds = [0] * len(nums)\\n\\tfor i, num in enumerate(nums):\\n\\t\\tr = 0\\n\\t\\twhile stack and nums[stack[-1]] <= num:\\n\\t\\t\\tindex = stack.pop()\\n\\t\\t\\tr = max(r, rounds[index])\\n\\t\\tif stack:\\n\\t\\t\\trounds[i] = r + 1\\n\\t\\tstack.append(i)     \\n\\treturn max(rounds)    \\n```\\n\\n*Time Complexity*= **O(N)**\\n*Space Complexity*= **O(N)**",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```python\\ndef totalSteps(self, nums: List[int]) -> int:\\n\\tstack = []\\n\\trounds = [0] * len(nums)\\n\\tfor i, num in enumerate(nums):\\n\\t\\tr = 0\\n\\t\\twhile stack and nums[stack[-1]] <= num:\\n\\t\\t\\tindex = stack.pop()\\n\\t\\t\\tr = max(r, rounds[index])\\n\\t\\tif stack:\\n\\t\\t\\trounds[i] = r + 1\\n\\t\\tstack.append(i)     \\n\\treturn max(rounds)    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2088235,
                "title": "stack-dp-time-o-n-space-o-n",
                "content": "\\n\\nint totalSteps(vector<int>& nums) {\\n        \\n        stack<pair<int,int>>st;\\n        \\n        \\n       int n=nums.size();\\n        \\n       \\n        \\n        vector<int>dp(n+1,0);\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(!st.empty() && nums[i]>st.top().first)\\n            {\\n                dp[i]=max(dp[i]+1,st.top().second);\\n                st.pop();\\n            }\\n            \\n            \\n            st.push({nums[i],dp[i]});\\n        }\\n    \\n        int ans=0;\\n        \\n        for(int i=0;i<n;i++){ ans=max(ans,dp[i]);}\\n        \\n        return ans;\\n        \\n    }",
                "solutionTags": [
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "\\n\\nint totalSteps(vector<int>& nums) {\\n        \\n        stack<pair<int,int>>st;\\n        \\n        \\n       int n=nums.size();\\n        \\n       \\n        \\n        vector<int>dp(n+1,0);\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(!st.empty() && nums[i]>st.top().first)\\n            {\\n                dp[i]=max(dp[i]+1,st.top().second);\\n                st.pop();\\n            }\\n            \\n            \\n            st.push({nums[i],dp[i]});\\n        }\\n    \\n        int ans=0;\\n        \\n        for(int i=0;i<n;i++){ ans=max(ans,dp[i]);}\\n        \\n        return ans;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2086690,
                "title": "java-o-n-monotonic-stack",
                "content": "rounds[i] is the deletion round for nums[i], and nums[i] will be deleted if there is a nums[j] >= nums[i] and j < i. Starting from begining of array, we push element into decreasing monotonic stack.  \\n1. if new element can be added to stack directly without any popup, which means it is less than left neighbor in nums array ( top of stack ), and can be deleted in 1 round.\\n2. if new element is not on the bottom of stack ( which means there is still at least one element bigger than it, and it still need to be deleted), and need to popup several elements before we can add this new element, then it will take the maximum round of the popup element + 1 to delete it.\\n3. If new element is on the bottom of stack, then it is the highest value up to current index, and it will not be deleted ( round = 0 )\\nAfter all items be added to stack, find the maximum rounds[i] as the result.\\n```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        int n = nums.length, rounds[] = new int[n];\\n        Stack<Integer> stack = new Stack<>();\\n        for (int i = 0; i < n; i++) {\\n            int deleteRound = 1;\\n            while (!stack.isEmpty() && nums[i] >= nums[stack.peek()]) {\\n                deleteRound = Math.max(deleteRound, rounds[stack.pop()] + 1);\\n            }\\n            rounds[i] = stack.isEmpty() ? 0 : deleteRound;\\n            stack.push(i);\\n        }\\n        int result = 0;\\n        for (int i : rounds) {\\n            result = Math.max(result, i);\\n        }   \\n        return result;\\n    }\\n}",
                "solutionTags": [
                    "Monotonic Stack"
                ],
                "code": "class Solution {\\n    public int totalSteps(int[] nums) {\\n        int n = nums.length, rounds[] = new int[n];\\n        Stack<Integer> stack = new Stack<>();\\n        for (int i = 0; i < n; i++) {\\n            int deleteRound = 1;\\n            while (!stack.isEmpty() && nums[i] >= nums[stack.peek()]) {\\n                deleteRound = Math.max(deleteRound, rounds[stack.pop()] + 1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2086296,
                "title": "python-two-o-n-simulation-approach-1-union-find-2-double-ended-queue",
                "content": "# Simulation\\n\\nTo simulate this question, the goal is: we need some techniques that can find the removed points in next round without traversal whole array. Here are two ways to do it.\\n\\n## Union Find\\nIn union function, If we always point to the left/right side, we can easily find the leftmost/rightmost idx in a group. That means, \\n- in node deletion, we can do **union(leftmost idx in previous group, leftmost idx in current group)**\\n- to find nxt round removed candidates, check **(current unioned group, nxt group)**. To find the nxt group, we need to find the rightmost idx in current group and add it by 1 then we can go to the next group;\\n\\n```python\\nclass UF:\\n    def __init__(self, n):\\n        self.n = n\\n        self.parents1 = [i for i in range(n)] # to left\\n        self.parents2 = [i for i in range(n)] # to right\\n\\n        \\n    def find1(self, idx): \\n\\t    # find group root from parents1\\n        if self.parents1[idx] != idx:\\n            self.parents1[idx] = self.find1(self.parents1[idx])\\n        return self.parents1[idx]\\n    \\n    def find2(self, idx):\\n\\t    # find group root from parents2\\n        if self.parents2[idx] != idx:\\n            self.parents2[idx] = self.find2(self.parents2[idx])\\n        return self.parents2[idx]\\n    \\n    def union(self, idx1, idx2):\\n\\t    # in parents1, always point to the leftside\\n        p11 = self.find1(self.parents1[idx1])\\n        p12 = self.find1(self.parents1[idx2])\\n        self.parents1[p12] = p11\\n        \\n\\t\\t# in parents2, always point to the rightside\\n        p21 = self.find2(self.parents2[idx1])\\n        p22 = self.find2(self.parents2[idx2])\\n        self.parents2[p21] = p22\\n    \\n\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        nums = [-float(\\'inf\\')] + nums + [float(\\'inf\\')]\\n        n = len(nums)\\n        uf = UF(n)\\n        candidates = set()\\n        for i in range(1, n - 1):\\n            if nums[i] > nums[i + 1]:\\n                candidates.add(i + 1)\\n        \\n        res = 0\\n        while candidates:\\n            # print(candidates)\\n            res += 1\\n            for idx in candidates:\\n\\t\\t\\t    # to find the previous group, we need to find the leftmost idx in current group, then decrease it by 1\\n                lidx = uf.find1(idx)\\n                lidx = uf.find1(lidx - 1)\\n                uf.union(lidx, idx)\\n            \\n            nxt = set()\\n            for idx in candidates:\\n\\t\\t\\t    # to find the nxt group, we need to find the rightmost idx in current group, then add it by 1\\n                lidx = uf.find1(idx)\\n                ridx = uf.find2(idx)\\n                ridx = uf.find1(ridx + 1)\\n\\n                if nums[lidx] > nums[ridx]:\\n                    nxt.add(ridx)\\n            candidates = nxt\\n        \\n        \\n        return res\\n```\\n\\n\\n## Double Ended Queue\\n\\nIt\\'s similiar to the UF solution, we know the next round candidates will appear in the two sides of the current removed nodes.\\n\\n\\n```python\\nclass Node:\\n    def __init__(self, val, idx):\\n        self.pre = None\\n        self.nxt = None\\n        self.val = val\\n        self.idx = idx\\n\\n\\nclass Dequeue:\\n    def __init__(self, nums):\\n        self.nums = [-float(\\'inf\\')] + nums + [float(\\'inf\\')]\\n        self.first = Node(-float(\\'inf\\'), -1)\\n        self.last = Node(float(\\'inf\\'), len(nums))\\n        self.n = len(self.nums)\\n        self.idx2node = {}\\n        self.candidates = set()\\n        self.alive = set([i for i in range(self.n)])\\n\\n        cur = self.first\\n        for idx, x in enumerate(self.nums):\\n            node = Node(x, idx)\\n            self.idx2node[idx] = node\\n            self.connect(cur, node)\\n            if cur.val > node.val:\\n                self.candidates.add(idx)\\n            cur = node\\n        self.connect(cur, self.last)\\n        self.step = 0\\n        \\n        \\n    def remove(self, cur):\\n        lnode = cur.pre\\n        rnode = cur.nxt\\n        self.connect(lnode, rnode)\\n        self.alive -= {cur.idx}\\n        \\n    def connect(self, node1, node2):\\n        node1.nxt = node2\\n        node2.pre = node1\\n        \\n    def simulate(self):\\n        candidates = self.candidates\\n        while candidates:\\n            self.step += 1\\n            nxt = set()\\n            for idx in candidates:\\n                node = self.idx2node[idx]\\n                lidx = node.pre.idx\\n                self.remove(node)\\n                # need to check whether the left-node can merge with its right side in next round\\n                nxt.add(lidx)\\n                \\n            candidates = set()\\n            for idx in nxt:\\n                if idx not in self.alive:\\n                    # pass if the node has already removed from deque\\n                    continue\\n                node = self.idx2node[idx]\\n                ridx = node.nxt.idx\\n                if self.nums[idx] > self.nums[ridx]:\\n                    candidates.add(ridx)\\n\\n        return self.step\\n\\n\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        dequeue = Dequeue(nums)\\n        return dequeue.simulate()\\n        \\n        \\n            \\n```\\n",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```python\\nclass UF:\\n    def __init__(self, n):\\n        self.n = n\\n        self.parents1 = [i for i in range(n)] # to left\\n        self.parents2 = [i for i in range(n)] # to right\\n\\n        \\n    def find1(self, idx): \\n\\t    # find group root from parents1\\n        if self.parents1[idx] != idx:\\n            self.parents1[idx] = self.find1(self.parents1[idx])\\n        return self.parents1[idx]\\n    \\n    def find2(self, idx):\\n\\t    # find group root from parents2\\n        if self.parents2[idx] != idx:\\n            self.parents2[idx] = self.find2(self.parents2[idx])\\n        return self.parents2[idx]\\n    \\n    def union(self, idx1, idx2):\\n\\t    # in parents1, always point to the leftside\\n        p11 = self.find1(self.parents1[idx1])\\n        p12 = self.find1(self.parents1[idx2])\\n        self.parents1[p12] = p11\\n        \\n\\t\\t# in parents2, always point to the rightside\\n        p21 = self.find2(self.parents2[idx1])\\n        p22 = self.find2(self.parents2[idx2])\\n        self.parents2[p21] = p22\\n    \\n\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        nums = [-float(\\'inf\\')] + nums + [float(\\'inf\\')]\\n        n = len(nums)\\n        uf = UF(n)\\n        candidates = set()\\n        for i in range(1, n - 1):\\n            if nums[i] > nums[i + 1]:\\n                candidates.add(i + 1)\\n        \\n        res = 0\\n        while candidates:\\n            # print(candidates)\\n            res += 1\\n            for idx in candidates:\\n\\t\\t\\t    # to find the previous group, we need to find the leftmost idx in current group, then decrease it by 1\\n                lidx = uf.find1(idx)\\n                lidx = uf.find1(lidx - 1)\\n                uf.union(lidx, idx)\\n            \\n            nxt = set()\\n            for idx in candidates:\\n\\t\\t\\t    # to find the nxt group, we need to find the rightmost idx in current group, then add it by 1\\n                lidx = uf.find1(idx)\\n                ridx = uf.find2(idx)\\n                ridx = uf.find1(ridx + 1)\\n\\n                if nums[lidx] > nums[ridx]:\\n                    nxt.add(ridx)\\n            candidates = nxt\\n        \\n        \\n        return res\\n```\n```python\\nclass Node:\\n    def __init__(self, val, idx):\\n        self.pre = None\\n        self.nxt = None\\n        self.val = val\\n        self.idx = idx\\n\\n\\nclass Dequeue:\\n    def __init__(self, nums):\\n        self.nums = [-float(\\'inf\\')] + nums + [float(\\'inf\\')]\\n        self.first = Node(-float(\\'inf\\'), -1)\\n        self.last = Node(float(\\'inf\\'), len(nums))\\n        self.n = len(self.nums)\\n        self.idx2node = {}\\n        self.candidates = set()\\n        self.alive = set([i for i in range(self.n)])\\n\\n        cur = self.first\\n        for idx, x in enumerate(self.nums):\\n            node = Node(x, idx)\\n            self.idx2node[idx] = node\\n            self.connect(cur, node)\\n            if cur.val > node.val:\\n                self.candidates.add(idx)\\n            cur = node\\n        self.connect(cur, self.last)\\n        self.step = 0\\n        \\n        \\n    def remove(self, cur):\\n        lnode = cur.pre\\n        rnode = cur.nxt\\n        self.connect(lnode, rnode)\\n        self.alive -= {cur.idx}\\n        \\n    def connect(self, node1, node2):\\n        node1.nxt = node2\\n        node2.pre = node1\\n        \\n    def simulate(self):\\n        candidates = self.candidates\\n        while candidates:\\n            self.step += 1\\n            nxt = set()\\n            for idx in candidates:\\n                node = self.idx2node[idx]\\n                lidx = node.pre.idx\\n                self.remove(node)\\n                # need to check whether the left-node can merge with its right side in next round\\n                nxt.add(lidx)\\n                \\n            candidates = set()\\n            for idx in nxt:\\n                if idx not in self.alive:\\n                    # pass if the node has already removed from deque\\n                    continue\\n                node = self.idx2node[idx]\\n                ridx = node.nxt.idx\\n                if self.nums[idx] > self.nums[ridx]:\\n                    candidates.add(ridx)\\n\\n        return self.step\\n\\n\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        dequeue = Dequeue(nums)\\n        return dequeue.simulate()\\n        \\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086225,
                "title": "python-dedicated-to-all-the-leetcoders-who-tried-to-honestly-remove-items-step-by-step-like-i-did",
                "content": "![image](https://assets.leetcode.com/users/images/187ee552-b739-4376-b75a-15f5779ac3d8_1653802529.355901.jpeg)\\n\\n\\tclass Solution:\\n\\t\\tdef totalSteps(self, nums: List[int]) -> int:   \\n\\t\\t\\tstack = [[nums[0], 0]]\\n\\t\\t\\tres, i, l = 0, 1, len(nums)\\n\\n\\t\\t\\twhile i < l:\\n\\t\\t\\t\\tel, cur = nums[i], 0\\n\\n\\t\\t\\t\\twhile stack and stack[-1][0] <= el:\\n\\t\\t\\t\\t\\tcur = max(cur, stack[-1][1])\\n\\t\\t\\t\\t\\tstack.pop()\\n\\n\\t\\t\\t\\tif stack: \\n\\t\\t\\t\\t\\tcur += 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tcur = 0\\n\\n\\t\\t\\t\\tres = max(res, cur)\\n\\t\\t\\t\\tstack.append([el, cur])\\n\\n\\t\\t\\t\\ti += 1\\n\\n\\t\\t\\treturn res\\n\\t\\t\\t\\n\\t\\t\\t\\nJust take a look at my first version to see that your attempts weren\\'t so bad. I used damn BISECT to search for an index in a list consisting of indexes of items to be deleted\\uD83D\\uDE25\\n\\n\\tclass Solution:\\n\\t\\tdef totalSteps(self, nums: List[int]) -> int:\\n\\t\\t\\tl = len(nums)\\n\\t\\t\\tcounter =  0\\n\\n\\t\\t\\tdef checker(l):\\n\\t\\t\\t\\tdels = []\\n\\t\\t\\t\\ti = 1\\n\\t\\t\\t\\twhile i < l:\\n\\t\\t\\t\\t\\tif nums[i] < nums[i - 1]:\\n\\t\\t\\t\\t\\t\\tdels.append(i)\\n\\t\\t\\t\\t\\ti += 1\\n\\t\\t\\t\\treturn dels\\n\\n\\t\\t\\twhile True:\\n\\t\\t\\t\\tdels = checker(l)\\n\\t\\t\\t\\tif dels:\\n\\t\\t\\t\\t\\tcounter += 1\\n\\t\\t\\t\\t\\tll = len(dels)\\n\\t\\t\\t\\t\\tnew_nums = []\\n\\t\\t\\t\\t\\tprev_ind = 0\\n\\t\\t\\t\\t\\tfor i, el in enumerate(nums):\\n\\t\\t\\t\\t\\t\\tind = bisect_left(dels, i, prev_ind)\\n\\t\\t\\t\\t\\t\\tprev_ind = ind\\n\\t\\t\\t\\t\\t\\tif ind == ll:\\n\\t\\t\\t\\t\\t\\t\\tnew_nums.extend(nums[i:])\\n\\t\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\t\\tif dels[ind] != i:\\n\\t\\t\\t\\t\\t\\t\\tnew_nums.append(el)\\n\\t\\t\\t\\t\\tnums = new_nums\\n\\t\\t\\t\\t\\tl -= ll\\n\\t\\t\\t\\t\\tchecker(l)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn counter",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/187ee552-b739-4376-b75a-15f5779ac3d8_1653802529.355901.jpeg)\\n\\n\\tclass Solution:\\n\\t\\tdef totalSteps(self, nums: List[int]) -> int:   \\n\\t\\t\\tstack = [[nums[0], 0]]\\n\\t\\t\\tres, i, l = 0, 1, len(nums)\\n\\n\\t\\t\\twhile i < l:\\n\\t\\t\\t\\tel, cur = nums[i], 0\\n\\n\\t\\t\\t\\twhile stack and stack[-1][0] <= el:\\n\\t\\t\\t\\t\\tcur = max(cur, stack[-1][1])\\n\\t\\t\\t\\t\\tstack.pop()\\n\\n\\t\\t\\t\\tif stack: \\n\\t\\t\\t\\t\\tcur += 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tcur = 0\\n\\n\\t\\t\\t\\tres = max(res, cur)\\n\\t\\t\\t\\tstack.append([el, cur])\\n\\n\\t\\t\\t\\ti += 1\\n\\n\\t\\t\\treturn res\\n\\t\\t\\t\\n\\t\\t\\t\\nJust take a look at my first version to see that your attempts weren\\'t so bad. I used damn BISECT to search for an index in a list consisting of indexes of items to be deleted\\uD83D\\uDE25\\n\\n\\tclass Solution:\\n\\t\\tdef totalSteps(self, nums: List[int]) -> int:\\n\\t\\t\\tl = len(nums)\\n\\t\\t\\tcounter =  0\\n\\n\\t\\t\\tdef checker(l):\\n\\t\\t\\t\\tdels = []\\n\\t\\t\\t\\ti = 1\\n\\t\\t\\t\\twhile i < l:\\n\\t\\t\\t\\t\\tif nums[i] < nums[i - 1]:\\n\\t\\t\\t\\t\\t\\tdels.append(i)\\n\\t\\t\\t\\t\\ti += 1\\n\\t\\t\\t\\treturn dels\\n\\n\\t\\t\\twhile True:\\n\\t\\t\\t\\tdels = checker(l)\\n\\t\\t\\t\\tif dels:\\n\\t\\t\\t\\t\\tcounter += 1\\n\\t\\t\\t\\t\\tll = len(dels)\\n\\t\\t\\t\\t\\tnew_nums = []\\n\\t\\t\\t\\t\\tprev_ind = 0\\n\\t\\t\\t\\t\\tfor i, el in enumerate(nums):\\n\\t\\t\\t\\t\\t\\tind = bisect_left(dels, i, prev_ind)\\n\\t\\t\\t\\t\\t\\tprev_ind = ind\\n\\t\\t\\t\\t\\t\\tif ind == ll:\\n\\t\\t\\t\\t\\t\\t\\tnew_nums.extend(nums[i:])\\n\\t\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\t\\tif dels[ind] != i:\\n\\t\\t\\t\\t\\t\\t\\tnew_nums.append(el)\\n\\t\\t\\t\\t\\tnums = new_nums\\n\\t\\t\\t\\t\\tl -= ll\\n\\t\\t\\t\\t\\tchecker(l)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn counter",
                "codeTag": "Java"
            },
            {
                "id": 2086199,
                "title": "c-monotonic-stack-dp-memoization-solution-with-explanation-o-n-time-o-n-space",
                "content": "```\\nclass Solution {\\npublic:\\n    //INTUITION: For every element, we check on its right that how many elements can be dissolved using it. Maximum number of such elements found is our answer.\\n    \\n    //ALGO: We use a monotonic stack to check for such a decreasing sequence from right to left, because an element can only dissolve elements on their right smaller than itself.\\n    //And we keep storing the no. of elements possible to be dissolved for every index in a dp array\\n    //For this algo, we have to traverse from the right end to starting of the array.\\n    int totalSteps(vector<int>& nums) {\\n        stack<int> st;\\n        int ans = 0;\\n        vector<int> dp(nums.size(),0);\\n        for(int i = nums.size()-1; i>=0; --i)\\n        {\\n            while(!st.empty() && nums[i]>nums[st.top()])//will run till we have a increasing sequence from right to left (or decreasing sequence from left to right starting from index i) \\n            {\\n                ++dp[i]; //because there\\'s one element to its right side for sure that it can dissolve/eliminate\\n                dp[i] = max(dp[i], dp[st.top()]); //now we also have to check whether there is another smaller number on the right side of nums[i] that can dissolve/eliminate even more no. of elements than nums[i] itself\\n                st.pop(); \\n                ans = max(ans,dp[i]);\\n            }\\n            st.push(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //INTUITION: For every element, we check on its right that how many elements can be dissolved using it. Maximum number of such elements found is our answer.\\n    \\n    //ALGO: We use a monotonic stack to check for such a decreasing sequence from right to left, because an element can only dissolve elements on their right smaller than itself.\\n    //And we keep storing the no. of elements possible to be dissolved for every index in a dp array\\n    //For this algo, we have to traverse from the right end to starting of the array.\\n    int totalSteps(vector<int>& nums) {\\n        stack<int> st;\\n        int ans = 0;\\n        vector<int> dp(nums.size(),0);\\n        for(int i = nums.size()-1; i>=0; --i)\\n        {\\n            while(!st.empty() && nums[i]>nums[st.top()])//will run till we have a increasing sequence from right to left (or decreasing sequence from left to right starting from index i) \\n            {\\n                ++dp[i]; //because there\\'s one element to its right side for sure that it can dissolve/eliminate\\n                dp[i] = max(dp[i], dp[st.top()]); //now we also have to check whether there is another smaller number on the right side of nums[i] that can dissolve/eliminate even more no. of elements than nums[i] itself\\n                st.pop(); \\n                ans = max(ans,dp[i]);\\n            }\\n            st.push(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086171,
                "title": "javascript-monotonic-stack-dp-156ms",
                "content": "```\\nconst totalSteps = (a) => MonotonicStack(a);\\n\\nconst MonotonicStack = (a) => {\\n    let n = a.length, st = [], dp = Array(n).fill(0), res = 0;\\n    for (let i = n - 1; ~i; i--) {\\n        while (st.length && a[i] > a[st[st.length - 1]]) {\\n            let last = st.pop();\\n            dp[i] = Math.max(dp[i] + 1, dp[last]);\\n        }\\n        st.push(i);\\n        res = Math.max(res, dp[i]);\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Monotonic Stack"
                ],
                "code": "```\\nconst totalSteps = (a) => MonotonicStack(a);\\n\\nconst MonotonicStack = (a) => {\\n    let n = a.length, st = [], dp = Array(n).fill(0), res = 0;\\n    for (let i = n - 1; ~i; i--) {\\n        while (st.length && a[i] > a[st[st.length - 1]]) {\\n            let last = st.pop();\\n            dp[i] = Math.max(dp[i] + 1, dp[last]);\\n        }\\n        st.push(i);\\n        res = Math.max(res, dp[i]);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2086156,
                "title": "c-10-lines-stack-o-n-time-space",
                "content": "```\\npublic class Solution \\n{\\n    public int TotalSteps(int[] nums) \\n    {\\n        Stack<int> stack = new();\\n        int[] ans = new int[nums.Length];\\n        \\n        for (int i = 0; i < nums.Length; ++i) \\n        {\\n            int res = 0;\\n            while (stack.Any() && nums[stack.Peek()] <= nums[i]) res = Math.Max(ans[stack.Pop()], res);\\n            \\n            if (stack.Any()) ans[i] = res + 1;\\n            \\n            stack.Push(i);\\n        }\\n        return ans.Max();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int TotalSteps(int[] nums) \\n    {\\n        Stack<int> stack = new();\\n        int[] ans = new int[nums.Length];\\n        \\n        for (int i = 0; i < nums.Length; ++i) \\n        {\\n            int res = 0;\\n            while (stack.Any() && nums[stack.Peek()] <= nums[i]) res = Math.Max(ans[stack.Pop()], res);\\n            \\n            if (stack.Any()) ans[i] = res + 1;\\n            \\n            stack.Push(i);\\n        }\\n        return ans.Max();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086007,
                "title": "how-to-resolve-time-limit-exceeded",
                "content": "Straightforward idea without using stack. Anyway to optimize or do we have to go reverse order and use stack?\\nThanks.\\n```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        memo=[0]*len(nums)\\n        curr=nums[0]\\n        k=0\\n        for i in range(1,len(nums)):\\n            if nums[i]>=curr:\\n                curr=nums[i]\\n                k=i\\n                continue\\n\\n            if nums[i]<nums[i-1]:\\n                memo[i]=1\\n                continue\\n            j=i-2\\n            while j>=k:\\n                if nums[i]<nums[j]:\\n                    memo[i]=1+max(memo[j+1:i])\\n                    # print(memo)\\n                    break\\n                else:\\n                    j-=1                    \\n        return max(memo)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        memo=[0]*len(nums)\\n        curr=nums[0]\\n        k=0\\n        for i in range(1,len(nums)):\\n            if nums[i]>=curr:\\n                curr=nums[i]\\n                k=i\\n                continue\\n\\n            if nums[i]<nums[i-1]:\\n                memo[i]=1\\n                continue\\n            j=i-2\\n            while j>=k:\\n                if nums[i]<nums[j]:\\n                    memo[i]=1+max(memo[j+1:i])\\n                    # print(memo)\\n                    break\\n                else:\\n                    j-=1                    \\n        return max(memo)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085941,
                "title": "c-solution-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) \\n    {\\n        int answer=0;\\n        stack<pair<int,int>> st;\\n        st.push({nums[nums.size()-1],0});\\n        \\n        for(int i=nums.size()-2;i>=0;i--)\\n        {\\n            int count=0;\\n            while(!st.empty() && st.top().first<nums[i]) //if current element is greater  then the top of the stack(st.top().first) keep removing the top() element and simultaneously keep updating count\\n            {\\n                count=max(st.top().second,count+1);\\n                st.pop();\\n            }\\n            answer=max(answer,count);\\n            st.push({nums[i],count}); // push the new element in the stack\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) \\n    {\\n        int answer=0;\\n        stack<pair<int,int>> st;\\n        st.push({nums[nums.size()-1],0});\\n        \\n        for(int i=nums.size()-2;i>=0;i--)\\n        {\\n            int count=0;\\n            while(!st.empty() && st.top().first<nums[i]) //if current element is greater  then the top of the stack(st.top().first) keep removing the top() element and simultaneously keep updating count\\n            {\\n                count=max(st.top().second,count+1);\\n                st.pop();\\n            }\\n            answer=max(answer,count);\\n            st.push({nums[i],count}); // push the new element in the stack\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085912,
                "title": "12-lines-c-monotonic-stack",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint totalSteps(vector<int>& nums) {\\n\\t\\t\\tstack<int> st;\\n\\t\\t\\tvector<int> dp(nums.size(), 0);\\n\\t\\t\\tfor (int i = nums.size() - 1; i >= 0; i--) {\\n\\t\\t\\t\\twhile (!st.empty() && nums[st.top()] < nums[i]) {\\n\\t\\t\\t\\t\\tdp[i] = max(++dp[i], dp[st.top()]);\\n\\t\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tst.push(i);\\n\\t\\t\\t}\\n\\t\\t\\treturn *max_element(dp.begin(), dp.end());\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint totalSteps(vector<int>& nums) {\\n\\t\\t\\tstack<int> st;\\n\\t\\t\\tvector<int> dp(nums.size(), 0);\\n\\t\\t\\tfor (int i = nums.size() - 1; i >= 0; i--) {\\n\\t\\t\\t\\twhile (!st.empty() && nums[st.top()] < nums[i]) {\\n\\t\\t\\t\\t\\tdp[i] = max(++dp[i], dp[st.top()]);\\n\\t\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2085785,
                "title": "c-o-n-using-dp-stack",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        vector<int> dp(nums.size());\\n        stack<int> s;\\n        int r;\\n        for(int i = nums.size()-1;i>=0;i--){\\n            while(!s.empty() && nums[i]>nums[s.top()]){\\n                dp[i] = max(dp[i]+1, dp[s.top()]); s.pop();\\n            }\\n            s.push(i);\\n            r = max(r, dp[i]);\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        vector<int> dp(nums.size());\\n        stack<int> s;\\n        int r;\\n        for(int i = nums.size()-1;i>=0;i--){\\n            while(!s.empty() && nums[i]>nums[s.top()]){\\n                dp[i] = max(dp[i]+1, dp[s.top()]); s.pop();\\n            }\\n            s.push(i);\\n            r = max(r, dp[i]);\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085698,
                "title": "accepted-after-3-tries-the-code-seems-easy-though",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int n = nums.size(), ret = 0;\\n        vector<int> dp(n);\\n        stack<int> s;\\n        for(int i=n-1; i>=0; i--) {\\n            while(not s.empty() and nums[s.top()] < nums[i]) {\\n                ++dp[i];\\n                dp[i] = max(dp[i], dp[s.top()]);\\n                s.pop();\\n            }\\n            ret = max(ret, dp[i]);\\n            s.push(i);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int n = nums.size(), ret = 0;\\n        vector<int> dp(n);\\n        stack<int> s;\\n        for(int i=n-1; i>=0; i--) {\\n            while(not s.empty() and nums[s.top()] < nums[i]) {\\n                ++dp[i];\\n                dp[i] = max(dp[i], dp[s.top()]);\\n                s.pop();\\n            }\\n            ret = max(ret, dp[i]);\\n            s.push(i);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085662,
                "title": "c-stack-o-n-short-code-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& a) {\\n        int n = a.size();\\n        int ret = 0;\\n\\t\\t// Which round will the position i be removed, set a big value to represent never be removed.\\n        vector<int>f(n, n+n);\\n\\t\\t// Position stack.\\n        stack<int>st;\\n        st.push(0);\\n        for(int i = 1;i<n;i++){\\n            int ans = 1;\\n\\t\\t\\t// Find the previous position which value is bigger than current value, the round will be the max round of positions in the middle + 1.\\n            while((!st.empty())&&a[st.top()]<=a[i]){\\n                ans=max(ans, f[st.top()]+1);\\n                st.pop();\\n            }\\n            if(ans<n+n){\\n                ret=max(ret, ans);\\n            }\\n            f[i] = ans;\\n            st.push(i);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& a) {\\n        int n = a.size();\\n        int ret = 0;\\n\\t\\t// Which round will the position i be removed, set a big value to represent never be removed.\\n        vector<int>f(n, n+n);\\n\\t\\t// Position stack.\\n        stack<int>st;\\n        st.push(0);\\n        for(int i = 1;i<n;i++){\\n            int ans = 1;\\n\\t\\t\\t// Find the previous position which value is bigger than current value, the round will be the max round of positions in the middle + 1.\\n            while((!st.empty())&&a[st.top()]<=a[i]){\\n                ans=max(ans, f[st.top()]+1);\\n                st.pop();\\n            }\\n            if(ans<n+n){\\n                ret=max(ret, ans);\\n            }\\n            f[i] = ans;\\n            st.push(i);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4050943,
                "title": "monotonic-pair-stack-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(2n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<pair<int,int>>s;\\n        int maxo=0;\\n        \\n        for(int i=nums.size()-1;i>=0;i--){\\n            int count=0;\\n            if(!s.empty() && s.top().first<nums[i]){\\n                \\n                while(!s.empty() && s.top().first<nums[i]){\\n                    count++;\\n                    count=max(count,s.top().second);\\n                    s.pop();\\n                }\\n                \\n               \\n            }\\n            maxo=max(count,maxo);\\n            s.push({nums[i],count});\\n            \\n            \\n        }\\n        \\n\\n        return maxo;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<pair<int,int>>s;\\n        int maxo=0;\\n        \\n        for(int i=nums.size()-1;i>=0;i--){\\n            int count=0;\\n            if(!s.empty() && s.top().first<nums[i]){\\n                \\n                while(!s.empty() && s.top().first<nums[i]){\\n                    count++;\\n                    count=max(count,s.top().second);\\n                    s.pop();\\n                }\\n                \\n               \\n            }\\n            maxo=max(count,maxo);\\n            s.push({nums[i],count});\\n            \\n            \\n        }\\n        \\n\\n        return maxo;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999410,
                "title": "simulation-on-list-of-deques-just-careful-implementation",
                "content": "# Intuition\\nlist of deques\\n\\n```\\nclass Solution:\\n    def totalSteps(self, n: List[int]) -> int:\\n        p,s,o=10**10,[],0\\n        for v in n:\\n            if v<p:s.append(deque())\\n            s[-1].append(p:=v)\\n        while (q:=len(s)-1):\\n            o+=1\\n            for m in range(q,0,-1):\\n                (t:=s[m]).popleft()\\n                if not t or s[m-1][-1]<=t[0]:\\n                    del s[m]\\n                    s[m-1].extend(t)\\n        return o\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def totalSteps(self, n: List[int]) -> int:\\n        p,s,o=10**10,[],0\\n        for v in n:\\n            if v<p:s.append(deque())\\n            s[-1].append(p:=v)\\n        while (q:=len(s)-1):\\n            o+=1\\n            for m in range(q,0,-1):\\n                (t:=s[m]).popleft()\\n                if not t or s[m-1][-1]<=t[0]:\\n                    del s[m]\\n                    s[m-1].extend(t)\\n        return o\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994050,
                "title": "optimal-bruteforce-using-stack-cpp",
                "content": "# Intuition\\nThe problem asks us to find the number of steps required to make the given array non-decreasing. To achieve this, we need to remove elements from the array such that, after each removal, the remaining elements are in non-decreasing order. Our intuition is to iteratively remove elements from the array while maintaining this property until we can no longer remove any elements.\\n\\n# Approach - Brute Force\\nThe brute force approach involves repeatedly checking the array and removing elements if they violate the non-decreasing condition. This process continues until no more elements can be removed, and we keep count of the steps taken. We initialize a counter `cnt` to 0 and repeatedly perform the following steps:\\n\\n1. Initialize an index `i` to 1 and a flag to 0.\\n2. Initialize a variable `d` to the first element of the array.\\n3. While `i` is less than the length of the array:\\n   a. If `d` is greater than the element at index `i`, update `d` to the element at index `i`, remove the element at index `i`, and set the flag to 1.\\n   b. Otherwise, increment `i`.\\n4. If the flag remains 0 after going through the array, return `cnt` as the number of steps.\\n5. Otherwise, increment `cnt` and repeat the process.\\n\\n# Complexity\\n- Time complexity: The worst-case time complexity of this approach is O(n^2), where n is the length of the input array `nums`. This is because in the worst case, we might have to repeatedly traverse the entire array in each step.\\n- Space complexity: The space complexity is O(1) as we are not using any additional data structures.\\n\\n# Approach - Optimal\\nThe optimal approach involves using a stack to efficiently keep track of elements in the array and their counts. We iterate through the array from right to left and maintain a stack of pairs where each pair consists of an element and the count of elements removed before it.\\n\\n1. Initialize a stack `st` to store pairs of elements and counts.\\n2. Iterate through the elements of the array from right to left.\\n3. For each element, check the elements in the stack from the top while the element at the top of the stack is less than the current element. We update the count of removed elements and pop elements from the stack until the condition is met.\\n4. Update the maximum count of removed elements seen so far (`maxi`) with the maximum between the current count and the previous `maxi`.\\n5. Push the current element and its updated count into the stack.\\n6. After iterating through the entire array, return `maxi` as the number of steps.\\n\\n# Complexity\\n- Time complexity: The time complexity of this optimal approach is O(n), where n is the length of the input array `nums`. This is because we iterate through the array once, and the stack operations are constant time for each element.\\n- Space complexity: The space complexity is O(n) as the stack can store at most n elements in the worst case.\\n\\n# BRUTE FORCE\\n```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int cnt=0;\\n        while(true){\\n            int i=1,flag=0;\\n            int d=nums[0];\\n            while(i<nums.size()){\\n                if(d>nums[i]) d=nums[i],nums.erase(nums.begin()+i),flag=1;\\n                else d=nums[i],i++;\\n            }\\n            if(flag==0) return cnt;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n# OPTIMAL APPROACH\\n```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int n=nums.size(),maxi=0;\\n        stack<pair<int,int>>st;\\n        for(int i=n-1;i>=0;i--){\\n            int cnt=0;\\n            while(!st.empty() and st.top().first<nums[i]){\\n                cnt=max(st.top().second,cnt+1);\\n                st.pop();\\n            }\\n            maxi=max(maxi,cnt);\\n            st.push({nums[i],cnt});\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int cnt=0;\\n        while(true){\\n            int i=1,flag=0;\\n            int d=nums[0];\\n            while(i<nums.size()){\\n                if(d>nums[i]) d=nums[i],nums.erase(nums.begin()+i),flag=1;\\n                else d=nums[i],i++;\\n            }\\n            if(flag==0) return cnt;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int n=nums.size(),maxi=0;\\n        stack<pair<int,int>>st;\\n        for(int i=n-1;i>=0;i--){\\n            int cnt=0;\\n            while(!st.empty() and st.top().first<nums[i]){\\n                cnt=max(st.top().second,cnt+1);\\n                st.pop();\\n            }\\n            maxi=max(maxi,cnt);\\n            st.push({nums[i],cnt});\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979406,
                "title": "monotonic-stack",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<int> st;\\n        int ans = 0, max_size = 0;\\n        for (int i = nums.size() - 1; i >= 0; i--) {\\n            for (; !st.empty() && nums[st.top()] < nums[i]; st.pop());\\n            ans = max(ans, max_size - (int)st.size());\\n            st.push(i);\\n            max_size = max(max_size, (int)st.size());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<int> st;\\n        int ans = 0, max_size = 0;\\n        for (int i = nums.size() - 1; i >= 0; i--) {\\n            for (; !st.empty() && nums[st.top()] < nums[i]; st.pop());\\n            ans = max(ans, max_size - (int)st.size());\\n            st.push(i);\\n            max_size = max(max_size, (int)st.size());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971985,
                "title": "stack-based-step-counter-for-number-elimination",
                "content": "# Intuition\\nThe problem suggests using a monotonic stack approach to identify the first larger number to the left of every element. By iterating from left to right, the stack helps track numbers that can \\'eliminate\\' others. As numbers get \\'consumed\\' by larger ones, the steps array updates the elimination time for each. An inline_max lambda function optimizes the performance by bypassing the overhead of typical function calls. This concise method offers both elegance and efficiency in solving the problem.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom array import array\\n\\nclass Solution(object):\\n    def totalSteps(self, nums):\\n        n = len(nums)\\n        \\n        # Using array.array for possibly better memory usage\\n        stack = array(\\'i\\', [0] * n)\\n        steps = array(\\'i\\', [0] * n)\\n        \\n        top = -1\\n        get_num = nums.__getitem__\\n        get_step = steps.__getitem__\\n        get_stack = stack.__getitem__\\n        \\n        inline_max = lambda a, b: a if a > b else b\\n\\n        for i in xrange(n): \\n            num = get_num(i)\\n            max_step_of_popped = 0\\n\\n            while top >= 0 and get_num(get_stack(top)) <= num:\\n                max_step_of_popped = inline_max(max_step_of_popped, get_step(get_stack(top)))\\n                top -= 1\\n\\n            if top >= 0:\\n                steps[i] = max_step_of_popped + 1\\n\\n            top += 1\\n            stack[top] = i\\n\\n        return max(steps)\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom array import array\\n\\nclass Solution(object):\\n    def totalSteps(self, nums):\\n        n = len(nums)\\n        \\n        # Using array.array for possibly better memory usage\\n        stack = array(\\'i\\', [0] * n)\\n        steps = array(\\'i\\', [0] * n)\\n        \\n        top = -1\\n        get_num = nums.__getitem__\\n        get_step = steps.__getitem__\\n        get_stack = stack.__getitem__\\n        \\n        inline_max = lambda a, b: a if a > b else b\\n\\n        for i in xrange(n): \\n            num = get_num(i)\\n            max_step_of_popped = 0\\n\\n            while top >= 0 and get_num(get_stack(top)) <= num:\\n                max_step_of_popped = inline_max(max_step_of_popped, get_step(get_stack(top)))\\n                top -= 1\\n\\n            if top >= 0:\\n                steps[i] = max_step_of_popped + 1\\n\\n            top += 1\\n            stack[top] = i\\n\\n        return max(steps)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3964104,
                "title": "steps-to-make-array-non-decreasing",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- for each element in the array, we could consider all subsequent elements, calculating the steps needed to transform the subarray into a non-decreasing sequence.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Brute Approach:\\nIn the brute-force approach, for each element in the array, we could consider all subsequent elements, calculating the steps needed to transform the subarray into a non-decreasing sequence. This involves nested loops, resulting in O(n^2) time complexity.\\n\\n- Optimal Approach:\\nThe optimal approach utilizes a stack to efficiently process the array in reverse order. It iterates through elements, maintaining pairs of element and steps taken to create a non-decreasing sequence. It updates the step count for each element by considering the stack\\'s contents. This approach achieves linear time complexity of O(n), effectively determining the maximum steps required to transform the sequence into non-decreasing form.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- n\\n\\n# Code\\n\\n\\n```\\n/*class Solution {  // BRUTE FORCE \\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int n = nums.size();\\n        int totalSteps = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            int stepsNeeded = 0;\\n            for (int j = i + 1; j < n; j++) {\\n                if (nums[j] < nums[j - 1]) {\\n                    stepsNeeded++;\\n                }\\n            }\\n            totalSteps = max(totalSteps, stepsNeeded);\\n        }\\n        \\n        return totalSteps;\\n    }\\n};*/\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n\\n        stack<pair<int, int>> st;  // Initialize a stack to store pairs (element, steps)\\n        \\n        int ans = -1;  // Initialize the maximum step count as -1 (for comparison)\\n        for (int i = nums.size() - 1; i >= 0; i--) {\\n            int count = 0;  // Initialize the step count for the current element\\n            while (!st.empty() and st.top().first < nums[i]) {\\n                // While there are elements in the stack and the top element is larger\\n                // than the current element, indicating a need for adjustment\\n                count = max(count + 1, st.top().second); // Update the step count\\n                st.pop();  // Remove the element from the stack\\n            }\\n            ans = max(ans, count);  // Update the maximum step count seen so far\\n            st.push({nums[i], count});  // Push the current element and its step count onto the stack\\n        }\\n        \\n        return ans;  // Return the maximum step count required to make the sequence non-decreasing\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Stack"
                ],
                "code": "```\\n/*class Solution {  // BRUTE FORCE \\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int n = nums.size();\\n        int totalSteps = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            int stepsNeeded = 0;\\n            for (int j = i + 1; j < n; j++) {\\n                if (nums[j] < nums[j - 1]) {\\n                    stepsNeeded++;\\n                }\\n            }\\n            totalSteps = max(totalSteps, stepsNeeded);\\n        }\\n        \\n        return totalSteps;\\n    }\\n};*/\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n\\n        stack<pair<int, int>> st;  // Initialize a stack to store pairs (element, steps)\\n        \\n        int ans = -1;  // Initialize the maximum step count as -1 (for comparison)\\n        for (int i = nums.size() - 1; i >= 0; i--) {\\n            int count = 0;  // Initialize the step count for the current element\\n            while (!st.empty() and st.top().first < nums[i]) {\\n                // While there are elements in the stack and the top element is larger\\n                // than the current element, indicating a need for adjustment\\n                count = max(count + 1, st.top().second); // Update the step count\\n                st.pop();  // Remove the element from the stack\\n            }\\n            ans = max(ans, count);  // Update the maximum step count seen so far\\n            st.push({nums[i], count});  // Push the current element and its step count onto the stack\\n        }\\n        \\n        return ans;  // Return the maximum step count required to make the sequence non-decreasing\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864822,
                "title": "stack-dp",
                "content": "```\\nint totalSteps(vector<int>& n) \\n{ \\n\\tint out{INT_MIN};      \\n\\tstack<int> s;\\n\\tfor(int i(size(n)-1), d[100001]{}; i>=0; --i)\\n\\t{\\n\\t\\tfor( ; !empty(s) and n[s.top()]<n[i]; s.pop()) \\n\\t\\t\\td[i] = max(d[i]+1, d[s.top()]);    \\n\\t\\ts.push(i);\\n\\t\\tout = max(out, d[i]);\\n\\t}\\n\\treturn out;\\n}\\n```\\n||\\n```\\nint totalSteps(vector<int>& n) \\n{ \\n\\tint out{INT_MIN};      \\n\\tstack<pair<int, int>> s;\\n\\tfor(int i(size(n)-1); i>=0; --i)\\n\\t{\\n        int t{};\\n\\t\\tfor( ; !empty(s) and s.top().first<n[i]; s.pop()) \\n\\t\\t\\tt = max(t+1, s.top().second);    \\n\\t\\ts.push({n[i],t});\\n\\t\\tout = max(out, t);\\n\\t}\\n\\treturn out;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint totalSteps(vector<int>& n) \\n{ \\n\\tint out{INT_MIN};      \\n\\tstack<int> s;\\n\\tfor(int i(size(n)-1), d[100001]{}; i>=0; --i)\\n\\t{\\n\\t\\tfor( ; !empty(s) and n[s.top()]<n[i]; s.pop()) \\n\\t\\t\\td[i] = max(d[i]+1, d[s.top()]);    \\n\\t\\ts.push(i);\\n\\t\\tout = max(out, d[i]);\\n\\t}\\n\\treturn out;\\n}\\n```\n```\\nint totalSteps(vector<int>& n) \\n{ \\n\\tint out{INT_MIN};      \\n\\tstack<pair<int, int>> s;\\n\\tfor(int i(size(n)-1); i>=0; --i)\\n\\t{\\n        int t{};\\n\\t\\tfor( ; !empty(s) and s.top().first<n[i]; s.pop()) \\n\\t\\t\\tt = max(t+1, s.top().second);    \\n\\t\\ts.push({n[i],t});\\n\\t\\tout = max(out, t);\\n\\t}\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3857309,
                "title": "c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) \\n    {\\n        vector<int> v(nums.size()); \\n        stack<int> st;\\n        int ans = 0; \\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            while(!st.empty() && nums[i] > nums[st.top()])\\n            {\\n                v[i] = max(v[i]+1, v[st.top()]);\\n\\t\\t\\t\\tst.pop();\\n            }\\n            st.push(i);\\n            ans = max(ans, v[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) \\n    {\\n        vector<int> v(nums.size()); \\n        stack<int> st;\\n        int ans = 0; \\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            while(!st.empty() && nums[i] > nums[st.top()])\\n            {\\n                v[i] = max(v[i]+1, v[st.top()]);\\n\\t\\t\\t\\tst.pop();\\n            }\\n            st.push(i);\\n            ans = max(ans, v[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3834772,
                "title": "totalsteps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n       public static int totalSteps(int[] nums) {\\n        if (nums.length == 1)\\n            return 0;\\n        LinkedList<int[]> linkedList = new LinkedList<>();\\n        linkedList.add(new int[]{nums[0], 0});\\n        int max = 0;\\n        for (int i = 1; i < nums.length; i++) {\\n            int[] current = new int[]{nums[i], 1};\\n            while (true) {\\n                int[] last = linkedList.getLast();\\n                if (current[0] < last[0]) {\\n                    if (last[1] == current[1])\\n                        linkedList.removeLast();\\n                    linkedList.add(current);\\n                    break;\\n                } else {\\n                    current[1] = Math.max(current[1], last[1]) + 1;\\n                    linkedList.removeLast();\\n                    if (linkedList.size() == 0) {\\n                        current[1] = 0;\\n                        linkedList.add(current);\\n                        break;\\n                    }\\n                }\\n            }\\n            for (var array : linkedList)\\n                max = Math.max(max, array[1]);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n       public static int totalSteps(int[] nums) {\\n        if (nums.length == 1)\\n            return 0;\\n        LinkedList<int[]> linkedList = new LinkedList<>();\\n        linkedList.add(new int[]{nums[0], 0});\\n        int max = 0;\\n        for (int i = 1; i < nums.length; i++) {\\n            int[] current = new int[]{nums[i], 1};\\n            while (true) {\\n                int[] last = linkedList.getLast();\\n                if (current[0] < last[0]) {\\n                    if (last[1] == current[1])\\n                        linkedList.removeLast();\\n                    linkedList.add(current);\\n                    break;\\n                } else {\\n                    current[1] = Math.max(current[1], last[1]) + 1;\\n                    linkedList.removeLast();\\n                    if (linkedList.size() == 0) {\\n                        current[1] = 0;\\n                        linkedList.add(current);\\n                        break;\\n                    }\\n                }\\n            }\\n            for (var array : linkedList)\\n                max = Math.max(max, array[1]);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738546,
                "title": "monotonic-stack-based-approach-with-summarized-thought-process",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\n# This has been a tricky problem to solve.\\n# First we see if we can try to process the array from the right side, this would mean that\\n# when we are at a number and we see that it\\'s smaller than the previous number, we can try\\n# to delete the current number. However, deleting the current number removes context for the \\n# following number (if that\\'s smaller than the current number) because both the current and the\\n# following numbers can be deleted in the same step.\\n# So, we try to process the array from the right side. Whenever we see that the current number\\n# is greater than the number to its right, we can delete the number on the right, and record that\\n# it took 1 step to delete this number. The maximum number of steps that any number took to delete\\n# numbers to its right is what we\\'re looking for here. But we need to take into account that the \\n# number we are deleting could already have deleted some numbers. If the steps taken by that\\n# number are more than the steps I am taking to delete that number, the steps to delete that number\\n# should be the maximum of my steps and the steps it took for that number to delete numbers smaller\\n# than itself.\\nclass Solution:\\n  # If the current element is smaller than previous, we want to delete the current element\\n  # After the deletion if the new current element is smaller than previous, it shouldn\\'t be\\n  # deleted in the current step.\\n  def totalSteps(self, nums: List[int]) -> int:\\n    # stack stores tuples where the first element is the number itself and the second element\\n    # is the number of steps it has taken to delete the numbers smaller than itself.\\n    stack = []\\n    n = len(nums)\\n    max_steps = 0\\n\\n    # We process the array from the right end, and when we see smaller numbers to the right,\\n    # we can remove those numbers.\\n    for i in range(n-1, -1, -1):\\n\\n      my_steps_to_delete_smaller_numbers = 0\\n\\n      while stack and nums[i] > stack[-1][0]:\\n        removed_number, steps_taken_by_removed_number = stack.pop()\\n        my_steps_to_delete_smaller_numbers += 1\\n\\n        if steps_taken_by_removed_number > my_steps_to_delete_smaller_numbers:\\n          my_steps_to_delete_smaller_numbers = steps_taken_by_removed_number\\n\\n      stack.append((nums[i], my_steps_to_delete_smaller_numbers))\\n      max_steps = max(my_steps_to_delete_smaller_numbers, max_steps)\\n    \\n    return max_steps\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# This has been a tricky problem to solve.\\n# First we see if we can try to process the array from the right side, this would mean that\\n# when we are at a number and we see that it\\'s smaller than the previous number, we can try\\n# to delete the current number. However, deleting the current number removes context for the \\n# following number (if that\\'s smaller than the current number) because both the current and the\\n# following numbers can be deleted in the same step.\\n# So, we try to process the array from the right side. Whenever we see that the current number\\n# is greater than the number to its right, we can delete the number on the right, and record that\\n# it took 1 step to delete this number. The maximum number of steps that any number took to delete\\n# numbers to its right is what we\\'re looking for here. But we need to take into account that the \\n# number we are deleting could already have deleted some numbers. If the steps taken by that\\n# number are more than the steps I am taking to delete that number, the steps to delete that number\\n# should be the maximum of my steps and the steps it took for that number to delete numbers smaller\\n# than itself.\\nclass Solution:\\n  # If the current element is smaller than previous, we want to delete the current element\\n  # After the deletion if the new current element is smaller than previous, it shouldn\\'t be\\n  # deleted in the current step.\\n  def totalSteps(self, nums: List[int]) -> int:\\n    # stack stores tuples where the first element is the number itself and the second element\\n    # is the number of steps it has taken to delete the numbers smaller than itself.\\n    stack = []\\n    n = len(nums)\\n    max_steps = 0\\n\\n    # We process the array from the right end, and when we see smaller numbers to the right,\\n    # we can remove those numbers.\\n    for i in range(n-1, -1, -1):\\n\\n      my_steps_to_delete_smaller_numbers = 0\\n\\n      while stack and nums[i] > stack[-1][0]:\\n        removed_number, steps_taken_by_removed_number = stack.pop()\\n        my_steps_to_delete_smaller_numbers += 1\\n\\n        if steps_taken_by_removed_number > my_steps_to_delete_smaller_numbers:\\n          my_steps_to_delete_smaller_numbers = steps_taken_by_removed_number\\n\\n      stack.append((nums[i], my_steps_to_delete_smaller_numbers))\\n      max_steps = max(my_steps_to_delete_smaller_numbers, max_steps)\\n    \\n    return max_steps\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631347,
                "title": "py3-beats-100-time-easy-explanation-for-dp-index-stack",
                "content": "# Intuition\\nWe build a dynamic programming array. The index i of the array holds the minimum steps necessary to make the partial array `[i:n]` non decreasing.\\n\\n# Approach\\nBy walking backwards, we can simplify the problem into the following loop:\\n\\n1. For every Index `i` going from right to left:\\n   1. Look at every pre-compressed sub-array that starts at `j`. Take the next `j` from the stack:\\n      1. If `nums[j]` is smaller than or equal to `nums[i]`, break the loop and continue with the next `j`\\n      1. Otherwise: Pop j off the stack\\n      1. We compress the new sub-array, add `1` to `dp[i]`\\n      1. If the steps necessary to compress `j` (stored in `dp[j]`) are greater than `dp[i]`, set `dp[i]` to `dp[j]` instead.\\n   2. Add `i` to the stack of compressd sub-arrays (LIFO)\\n\\n## Some key insights to note:\\n- For every number $i$ on the stack, the numbers that are above it on the stack have to be $\\\\ge i$. This means the stack is sorted.\\n- For every outer loop index $i$, we don\\'t look at every $j$. We just look at $j$\\'s that are the leftmost index of an already compressed sub-array. Those $j$\\'s are local maxima.\\n- If we come across a new $i$ that\\'s larger than anything we\\'ve seen, it means we have to remove every single previous local maximum in order to still be non-decreasing. Effectively compressing every $j \\\\ge i$ into one new sub-array starting at $i$. The stack is left empty.\\n- If we come across an $i$ that\\'s somewhere in the middle of all $j$\\'s we\\'ve seen, it means we have to compress only the $j$\\'s that are smaller. That\\'s where the sorted stack really helps us out.\\n- If we come across an $i$ that\\'s lower or equal to everything we\\'ve seen, we do nothing. The array is already non-decreasing.\\n- Every compression adds at least $1$ to `dp[i]`. We also need to make sure that we don\\'t drop any steps that occured when compressing $j$. That\\'s where `if prev > dp[i]: dp[i] = prev` comes from.\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/b2201112-f6c1-4514-9c78-77ccee748de5_1686628111.405121.png)\\n\\n\\n# Code\\n\\n```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        n = len(nums)        \\n        stack = deque([])\\n        dp = [0] * n\\n        for i in range(n)[::-1]:\\n            v = nums[i]\\n            while stack and v > nums[stack[-1]]:\\n                j = stack.pop()\\n                prev = dp[j]\\n                dp[i] += 1\\n                if prev > dp[i]:\\n                    dp[i] = prev\\n            stack.append(i)\\n        return max(dp)\\n```\\n\\n## Minified in 6 Lines:\\n\\n```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        s, d, n = deque([]), [0] * len(nums), len(nums)\\n        for i, v in enumerate(reversed(nums)):\\n            while s and v > nums[n - s[-1] - 1]:\\n                d[i] = max(d[i] + 1, d[s.pop()])\\n            s.append(i)\\n        return max(d)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        n = len(nums)        \\n        stack = deque([])\\n        dp = [0] * n\\n        for i in range(n)[::-1]:\\n            v = nums[i]\\n            while stack and v > nums[stack[-1]]:\\n                j = stack.pop()\\n                prev = dp[j]\\n                dp[i] += 1\\n                if prev > dp[i]:\\n                    dp[i] = prev\\n            stack.append(i)\\n        return max(dp)\\n```\n```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        s, d, n = deque([]), [0] * len(nums), len(nums)\\n        for i, v in enumerate(reversed(nums)):\\n            while s and v > nums[n - s[-1] - 1]:\\n                d[i] = max(d[i] + 1, d[s.pop()])\\n            s.append(i)\\n        return max(d)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3505892,
                "title": "very-easy-fast-solution-simple-approach-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        \\n        int n = nums.length;\\n        int answer = 0;\\n\\n        Stack<Pair<Integer, Integer>> stack = new Stack<>();\\n        stack.push(new Pair<>(nums[n - 1], 0));\\n\\n        for(int i = n - 2; i >= 0; i--) {\\n            int count = 0;\\n            while(!stack.isEmpty() && nums[i] > stack.peek().getKey()) {\\n                count = Math.max(count + 1, stack.peek().getValue());\\n                stack.pop();\\n            }\\n            answer = Math.max(answer, count);\\n            stack.push(new Pair(nums[i], count));\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        \\n        int n = nums.length;\\n        int answer = 0;\\n\\n        Stack<Pair<Integer, Integer>> stack = new Stack<>();\\n        stack.push(new Pair<>(nums[n - 1], 0));\\n\\n        for(int i = n - 2; i >= 0; i--) {\\n            int count = 0;\\n            while(!stack.isEmpty() && nums[i] > stack.peek().getKey()) {\\n                count = Math.max(count + 1, stack.peek().getValue());\\n                stack.pop();\\n            }\\n            answer = Math.max(answer, count);\\n            stack.push(new Pair(nums[i], count));\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3505891,
                "title": "very-easy-fast-solution-simple-approach-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        \\n        int n = nums.length;\\n        int answer = 0;\\n\\n        Stack<Pair<Integer, Integer>> stack = new Stack<>();\\n        stack.push(new Pair<>(nums[n - 1], 0));\\n\\n        for(int i = n - 2; i >= 0; i--) {\\n            int count = 0;\\n            while(!stack.isEmpty() && nums[i] > stack.peek().getKey()) {\\n                count = Math.max(count + 1, stack.peek().getValue());\\n                stack.pop();\\n            }\\n            answer = Math.max(answer, count);\\n            stack.push(new Pair(nums[i], count));\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        \\n        int n = nums.length;\\n        int answer = 0;\\n\\n        Stack<Pair<Integer, Integer>> stack = new Stack<>();\\n        stack.push(new Pair<>(nums[n - 1], 0));\\n\\n        for(int i = n - 2; i >= 0; i--) {\\n            int count = 0;\\n            while(!stack.isEmpty() && nums[i] > stack.peek().getKey()) {\\n                count = Math.max(count + 1, stack.peek().getValue());\\n                stack.pop();\\n            }\\n            answer = Math.max(answer, count);\\n            stack.push(new Pair(nums[i], count));\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502059,
                "title": "shortest-c-solution-using-simple-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        vector<int> ans(nums.size()); \\n        stack<int> s;\\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            while(!s.empty() && nums[i]>nums[s.top()])\\n            {\\n                ans[i]=max(ans[i]+1, ans[s.top()]);\\n                s.pop();\\n            }\\n            s.push(i);\\n        }\\n        return *max_element(ans.begin(), ans.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        vector<int> ans(nums.size()); \\n        stack<int> s;\\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            while(!s.empty() && nums[i]>nums[s.top()])\\n            {\\n                ans[i]=max(ans[i]+1, ans[s.top()]);\\n                s.pop();\\n            }\\n            s.push(i);\\n        }\\n        return *max_element(ans.begin(), ans.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3386151,
                "title": "monotonic-stack-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        Stack<Integer> stack = new Stack();\\n        int[] dp = new int[nums.length];\\n       int res = 0;\\n      for(int i = nums.length-1;i>=0;i--){\\n            while (!stack.isEmpty() &&  nums[i] > nums[stack.peek()]){\\n                    dp[i] = Math.max(dp[i] + 1, dp[stack.pop()]);\\n                     res = Math.max(res, dp[i]);\\n            }\\n            stack.push(i);\\n      }\\n      return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        Stack<Integer> stack = new Stack();\\n        int[] dp = new int[nums.length];\\n       int res = 0;\\n      for(int i = nums.length-1;i>=0;i--){\\n            while (!stack.isEmpty() &&  nums[i] > nums[stack.peek()]){\\n                    dp[i] = Math.max(dp[i] + 1, dp[stack.pop()]);\\n                     res = Math.max(res, dp[i]);\\n            }\\n            stack.push(i);\\n      }\\n      return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3360285,
                "title": "monotonic-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        //Learn it\\n        int len=nums.length;\\n        int ans=0;\\n        Stack<Pair<Integer,Integer>> stk=new Stack<>();//Monotonic stack\\n        stk.push(new Pair<>(nums[len-1],0));\\n        for(int i=len-2;i>=0;i--){\\n            int count=0;\\n            while(!stk.isEmpty() && nums[i]>stk.peek().getKey()){\\n                count=Math.max(count+1,stk.peek().getValue());\\n                stk.pop();\\n            }\\n            ans=Math.max(count,ans);\\n            stk.push(new Pair<>(nums[i],count));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        //Learn it\\n        int len=nums.length;\\n        int ans=0;\\n        Stack<Pair<Integer,Integer>> stk=new Stack<>();//Monotonic stack\\n        stk.push(new Pair<>(nums[len-1],0));\\n        for(int i=len-2;i>=0;i--){\\n            int count=0;\\n            while(!stk.isEmpty() && nums[i]>stk.peek().getKey()){\\n                count=Math.max(count+1,stk.peek().getValue());\\n                stk.pop();\\n            }\\n            ans=Math.max(count,ans);\\n            stk.push(new Pair<>(nums[i],count));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3335664,
                "title": "c-clean-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<pair<int,int>> s;\\n        vector<int> dp(nums.size()+1,0);\\n        int c=0;\\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            int a=nums[i];\\n            int ct=0;\\n             while(s.size()>0 && a>s.top().first)\\n              {\\n                  dp[i]=max(dp[i]+1,dp[s.top().second]);\\n                  s.pop();\\n              }\\n            s.push({a,i});\\n        }\\n      for(auto j : dp)\\n      c=max(j,c);  \\n     return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<pair<int,int>> s;\\n        vector<int> dp(nums.size()+1,0);\\n        int c=0;\\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            int a=nums[i];\\n            int ct=0;\\n             while(s.size()>0 && a>s.top().first)\\n              {\\n                  dp[i]=max(dp[i]+1,dp[s.top().second]);\\n                  s.pop();\\n              }\\n            s.push({a,i});\\n        }\\n      for(auto j : dp)\\n      c=max(j,c);  \\n     return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327178,
                "title": "c-golang-monotonic-stack-dp",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> DP(n, 0);\\n        stack<int> Stack;\\n        int ans = 0;\\n        for(int i = nums.size() - 1; i >= 0; i--) {\\n            while(!Stack.empty() && nums[Stack.top()] < nums[i]) {\\n                DP[i] = max(DP[Stack.top()], DP[i] + 1);\\n                Stack.pop();\\n            }\\n            ans = max(ans, DP[i]);\\n            Stack.push(i);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc max(a, b int) int {\\n    if a > b {return a}\\n    return b\\n}\\n\\nfunc totalSteps(nums []int) int {\\n    n := len(nums)\\n    DP := make([]int, n)\\n    Stack := make([]int, 1e5)\\n    top := -1\\n    ans := 0\\n    for i := n - 1; i >= 0; i-- {\\n        for top != -1 && nums[Stack[top]] < nums[i] {\\n            DP[i] = max(DP[Stack[top]], DP[i] + 1)\\n            top--\\n        }\\n        ans = max(ans, DP[i])\\n        top++\\n        Stack[top] = i\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Dynamic Programming",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> DP(n, 0);\\n        stack<int> Stack;\\n        int ans = 0;\\n        for(int i = nums.size() - 1; i >= 0; i--) {\\n            while(!Stack.empty() && nums[Stack.top()] < nums[i]) {\\n                DP[i] = max(DP[Stack.top()], DP[i] + 1);\\n                Stack.pop();\\n            }\\n            ans = max(ans, DP[i]);\\n            Stack.push(i);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc max(a, b int) int {\\n    if a > b {return a}\\n    return b\\n}\\n\\nfunc totalSteps(nums []int) int {\\n    n := len(nums)\\n    DP := make([]int, n)\\n    Stack := make([]int, 1e5)\\n    top := -1\\n    ans := 0\\n    for i := n - 1; i >= 0; i-- {\\n        for top != -1 && nums[Stack[top]] < nums[i] {\\n            DP[i] = max(DP[Stack[top]], DP[i] + 1)\\n            top--\\n        }\\n        ans = max(ans, DP[i])\\n        top++\\n        Stack[top] = i\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3295891,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& A) {\\n        int n = A.size(), res = 0;\\n        vector<int> stack, dp(n);\\n        for (int i = n - 1; i >= 0; --i) {\\n            while (!stack.empty() && A[i] > A[stack.back()]) {\\n                dp[i] = max(++dp[i], dp[stack.back()]);\\n                stack.pop_back();\\n                res = max(res, dp[i]);\\n            }\\n            stack.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& A) {\\n        int n = A.size(), res = 0;\\n        vector<int> stack, dp(n);\\n        for (int i = n - 1; i >= 0; --i) {\\n            while (!stack.empty() && A[i] > A[stack.back()]) {\\n                dp[i] = max(++dp[i], dp[stack.back()]);\\n                stack.pop_back();\\n                res = max(res, dp[i]);\\n            }\\n            stack.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181253,
                "title": "java-code-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n      int ans = 0;\\n      Stack<Pair<Integer, Integer>> st = new Stack<>();\\n      st.push(new Pair<>(nums[nums.length-1], 0));\\n      for(int i=nums.length-2; i>=0; i--){\\n           int count = 0;\\n         while(st.size()>0 && nums[i]>st.peek().getKey()){\\n             count = Math.max(count+1, st.peek().getValue());\\n              st.pop();\\n          }\\n          ans = Math.max(ans, count);\\n          st.push(new Pair(nums[i], count));\\n         \\n      }\\n\\n      return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n      int ans = 0;\\n      Stack<Pair<Integer, Integer>> st = new Stack<>();\\n      st.push(new Pair<>(nums[nums.length-1], 0));\\n      for(int i=nums.length-2; i>=0; i--){\\n           int count = 0;\\n         while(st.size()>0 && nums[i]>st.peek().getKey()){\\n             count = Math.max(count+1, st.peek().getValue());\\n              st.pop();\\n          }\\n          ans = Math.max(ans, count);\\n          st.push(new Pair(nums[i], count));\\n         \\n      }\\n\\n      return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112888,
                "title": "simple-dp-java-solution",
                "content": "# Intuition\\n1. Find the first previous element just bigger than current.\\n2. Assign current element answer to max answer of elements between current element and the first previous element just bigger than current + 1.\\n3. Max of all the answers is your final answer.\\n\\n# Code\\n```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        Stack<Integer> s=new Stack<>();\\n        int dp[]=new int[nums.length],ans=0;\\n        for(int i=0;i<nums.length;i++){\\n            while(!s.isEmpty() && nums[s.peek()]<=nums[i]){\\n                dp[i]=Math.max(dp[i],dp[s.pop()]);\\n            }\\n            dp[i]=s.isEmpty()?0:dp[i]+1;\\n            s.add(i);\\n            ans=Math.max(ans,dp[i]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        Stack<Integer> s=new Stack<>();\\n        int dp[]=new int[nums.length],ans=0;\\n        for(int i=0;i<nums.length;i++){\\n            while(!s.isEmpty() && nums[s.peek()]<=nums[i]){\\n                dp[i]=Math.max(dp[i],dp[s.pop()]);\\n            }\\n            dp[i]=s.isEmpty()?0:dp[i]+1;\\n            s.add(i);\\n            ans=Math.max(ans,dp[i]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3110247,
                "title": "easy-python-solution-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        st = []\\n        n = len(nums)\\n        st.append((nums[n-1],0))\\n        stLen = 1\\n        ans = 0\\n        for i in range(n-2,-1,-1):\\n            count = 0\\n            while(st and st[stLen-1][0]<nums[i]):\\n                count = max(count+1,st[stLen-1][1])\\n                st.pop()\\n                stLen-=1\\n            ans = max(ans,count)\\n            st.append((nums[i],count))\\n            stLen+=1\\n        return ans\\n\\n        # st = []\\n        # cnt = 0\\n        # prevarrcnt = 0\\n        # cloneNums = nums\\n        # while(True):\\n        #     a = []\\n        #     prev = -1\\n        #     arrcnt = 1\\n        #     for i in nums:\\n        #         if prev == -1:\\n        #             st.append(i)\\n        #         elif prev <= i:\\n        #             arrcnt+=1\\n        #             st.append(i)\\n        #         prev = i\\n        #     nums = st\\n        #     st = []\\n        #     if arrcnt == prevarrcnt:\\n        #         break\\n        #     prevarrcnt = arrcnt\\n        #     cnt+=1\\n        # if len(cloneNums)==prevarrcnt:\\n        #     return 0\\n        # return cnt\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        st = []\\n        n = len(nums)\\n        st.append((nums[n-1],0))\\n        stLen = 1\\n        ans = 0\\n        for i in range(n-2,-1,-1):\\n            count = 0\\n            while(st and st[stLen-1][0]<nums[i]):\\n                count = max(count+1,st[stLen-1][1])\\n                st.pop()\\n                stLen-=1\\n            ans = max(ans,count)\\n            st.append((nums[i],count))\\n            stLen+=1\\n        return ans\\n\\n        # st = []\\n        # cnt = 0\\n        # prevarrcnt = 0\\n        # cloneNums = nums\\n        # while(True):\\n        #     a = []\\n        #     prev = -1\\n        #     arrcnt = 1\\n        #     for i in nums:\\n        #         if prev == -1:\\n        #             st.append(i)\\n        #         elif prev <= i:\\n        #             arrcnt+=1\\n        #             st.append(i)\\n        #         prev = i\\n        #     nums = st\\n        #     st = []\\n        #     if arrcnt == prevarrcnt:\\n        #         break\\n        #     prevarrcnt = arrcnt\\n        #     cnt+=1\\n        # if len(cloneNums)==prevarrcnt:\\n        #     return 0\\n        # return cnt\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109157,
                "title": "stack-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe elements which do not have previous greater element sustains at the end. Previous greater element calculations leads us to stack implementation.\\n\\n# Approach\\nTake a stack. The elements which are less than the top are pushed inside the stack with a counter as 0. Whereas if we encounter a more greater value than the current top then we simply pop the element from the stack. Also the counter will be maintained as **maximum** of stack top element counter or its orginal counter+1. The maximum is taken because here are operations can be done in *parallel*. So in a way it saves the total number of steps involved.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n      **due to stack implementation **\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> vect;\\n        stack<pair<int,int>> st;\\n        // int te = 0;\\n        // vect.push_back(te);\\n        for(int i=n-1 ; i>=0 ; i--){\\n            int steps = 0;\\n            while(!st.empty()){\\n                if(st.top().first>=nums[i]){\\n                    break;\\n                }\\n                steps = max(steps+1,st.top().second);\\n                st.pop();\\n            }\\n            st.push({nums[i],steps});\\n        }\\n        int maxi=0;\\n        while(!st.empty()){\\n            maxi = max(maxi,st.top().second);\\n            st.pop();\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> vect;\\n        stack<pair<int,int>> st;\\n        // int te = 0;\\n        // vect.push_back(te);\\n        for(int i=n-1 ; i>=0 ; i--){\\n            int steps = 0;\\n            while(!st.empty()){\\n                if(st.top().first>=nums[i]){\\n                    break;\\n                }\\n                steps = max(steps+1,st.top().second);\\n                st.pop();\\n            }\\n            st.push({nums[i],steps});\\n        }\\n        int maxi=0;\\n        while(!st.empty()){\\n            maxi = max(maxi,st.top().second);\\n            st.pop();\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3104113,
                "title": "rust-elixir-with-monotonic-stack",
                "content": "# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n# Rust\\n```rust\\nimpl Solution {\\n    pub fn total_steps(nums: Vec<i32>) -> i32 {\\n        let mut ans = 0;\\n        let mut count = 0;\\n        let mut stack = Vec::new();\\n        for &x in nums.iter().rev() {\\n            while !stack.is_empty() && *stack.last().unwrap() < x {\\n                stack.pop();\\n                count += 1;\\n            }\\n            ans = ans.max(count);\\n            stack.push(x);\\n            count = 0.max(count - 1);\\n        }\\n        ans\\n    }\\n}\\n```\\n# Elixir\\n```elixir\\ndefmodule Solution do\\n  @spec total_steps(nums :: [integer]) :: integer\\n  def total_steps(nums) do\\n    Enum.reverse(nums)\\n    |> solve([], 0, 0)\\n  end\\n  \\n  defp solve([], _, _, ans), do: ans\\n  defp solve([x | nums], [y | stack], count, ans) when x > y do\\n    solve([x | nums], stack, count + 1, ans)\\n  end\\n  defp solve([x | nums], stack, count, ans) do\\n    solve(nums, [x | stack], max(count - 1, 0), max(ans, count))\\n  end\\nend\\n```",
                "solutionTags": [
                    "Rust",
                    "Elixir",
                    "Monotonic Stack"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn total_steps(nums: Vec<i32>) -> i32 {\\n        let mut ans = 0;\\n        let mut count = 0;\\n        let mut stack = Vec::new();\\n        for &x in nums.iter().rev() {\\n            while !stack.is_empty() && *stack.last().unwrap() < x {\\n                stack.pop();\\n                count += 1;\\n            }\\n            ans = ans.max(count);\\n            stack.push(x);\\n            count = 0.max(count - 1);\\n        }\\n        ans\\n    }\\n}\\n```\n```elixir\\ndefmodule Solution do\\n  @spec total_steps(nums :: [integer]) :: integer\\n  def total_steps(nums) do\\n    Enum.reverse(nums)\\n    |> solve([], 0, 0)\\n  end\\n  \\n  defp solve([], _, _, ans), do: ans\\n  defp solve([x | nums], [y | stack], count, ans) when x > y do\\n    solve([x | nums], stack, count + 1, ans)\\n  end\\n  defp solve([x | nums], stack, count, ans) do\\n    solve(nums, [x | stack], max(count - 1, 0), max(ans, count))\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3066158,
                "title": "yet-another-python-solution",
                "content": "# Intuition\\nYet another nice problem from the leetcode.\\nSolution is rather obvious - iterate through array elements and get the max lifetime from all the decreasing elements.\\n\\n\\n# Approach\\nOne approach would be to use DP array to store N integers with the lifetime of all previous elements. for every next element - get the max from lifetime of precending elements that are less or equal, add 1 and store result as a lifetime of the current.\\n\\nAbove solution can be optimised by using stack since we do not need to scan local minimums in precending elements multiple times as a peak element would always have longer lifetime than its precending items with the lower value. \\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N) for the stack\\n\\n# Code\\n```\\nimport collections\\n\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        stack = collections.deque()\\n        ans = 0\\n        mx = nums[0]\\n        for n in nums:\\n            if n >= mx:\\n                stack.clear()\\n                mx = n\\n                continue\\n            lifetime = 0\\n            while stack and stack[-1][0] <= n:\\n                (v, t) = stack.pop()\\n                lifetime = max(lifetime, t)\\n            stack.append( (n, lifetime +1) )\\n            ans = max(ans, lifetime +1)\\n        return ans\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport collections\\n\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        stack = collections.deque()\\n        ans = 0\\n        mx = nums[0]\\n        for n in nums:\\n            if n >= mx:\\n                stack.clear()\\n                mx = n\\n                continue\\n            lifetime = 0\\n            while stack and stack[-1][0] <= n:\\n                (v, t) = stack.pop()\\n                lifetime = max(lifetime, t)\\n            stack.append( (n, lifetime +1) )\\n            ans = max(ans, lifetime +1)\\n        return ans\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2932794,
                "title": "can-anyone-pls-optimize-time-complexity-in-my-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n        class Solution {\\n        public:\\n\\n         bool check(stack<int>s,int &count){\\n             queue<int>p;\\n             while(!s.empty()){\\n                 p.push(s.top());\\n                 s.pop();\\n             }\\n             while(!p.empty()){\\n                 int y=p.front();\\n                 p.pop();\\n                 if(p.front()>y){\\n                    return false;\\n                }\\n            } return true;\\n         }\\n            int totalSteps(vector<int>& nums) {\\n             stack<int>s;\\n             stack<int>st;\\n             s.push(nums[0]);\\n             int count=0;\\n             for(int i=1;i<nums.size();i++){\\n                 int y=s.top();\\n             if(nums[i-1]<=nums[i]){\\n         s.push(nums[i]);\\n             }\\n                \\n             }\\n             if(s.size()==nums.size()){\\n                 return 0;\\n             }else{\\n                 count=1;\\n             }\\n             while(check(s,count)!=true){\\n         vector<int>v;\\n         while(!s.empty()){\\n             v.push_back(s.top());\\n             s.pop();\\n         }\\n         s.push(v[v.size()-1]);\\n         for(int i=v.size()-2;i>=0;i--){\\n             if(v[i+1]<=v[i]){\\n                 s.push(v[i]);\\n             }\\n         }\\n         count++;\\n             }\\n             return count;\\n        }\\n        };\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n        class Solution {\\n        public:\\n\\n         bool check(stack<int>s,int &count){\\n             queue<int>p;\\n             while(!s.empty()){\\n                 p.push(s.top());\\n                 s.pop();\\n             }\\n             while(!p.empty()){\\n                 int y=p.front();\\n                 p.pop();\\n                 if(p.front()>y){\\n                    return false;\\n                }\\n            } return true;\\n         }\\n            int totalSteps(vector<int>& nums) {\\n             stack<int>s;\\n             stack<int>st;\\n             s.push(nums[0]);\\n             int count=0;\\n             for(int i=1;i<nums.size();i++){\\n                 int y=s.top();\\n             if(nums[i-1]<=nums[i]){\\n         s.push(nums[i]);\\n             }\\n                \\n             }\\n             if(s.size()==nums.size()){\\n                 return 0;\\n             }else{\\n                 count=1;\\n             }\\n             while(check(s,count)!=true){\\n         vector<int>v;\\n         while(!s.empty()){\\n             v.push_back(s.top());\\n             s.pop();\\n         }\\n         s.push(v[v.size()-1]);\\n         for(int i=v.size()-2;i>=0;i--){\\n             if(v[i+1]<=v[i]){\\n                 s.push(v[i]);\\n             }\\n         }\\n         count++;\\n             }\\n             return count;\\n        }\\n        };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2849229,
                "title": "scala-functional-programming-some-extension",
                "content": "## 1. Mono-stack: O(N)\\nThe idea is, if an element `a` is removed in the `x`th step, then the first element in the right side of `a` which is no less than `a` will only be removed after the `x`th step. \\n```scala\\nimport scala.annotation.tailrec\\nobject Solution {\\n    def totalSteps(nums: Array[Int]): Int = {\\n        val huge = Int.MaxValue / 2    // step >= huge means an element will never be removed\\n        \\n\\t\\t@tailrec\\n        def helper(nums: List[Int], stack: List[(Int, Int)], res: Int): Int = nums match {\\n            case Nil => res\\n            case x::xs => {\\n                val (left, right) = stack.span(_._1 <= x)\\n\\t\\t\\t    // elements in @left is less or equal to x, delaying the removal of x like some \\'blockers\\'.\\n\\t\\t\\t\\t// We find out which blocker caused the longest delay and update the removal time of x by adding 1\\n                val step = if (left == Nil) 1 else left.map(_._2).max + 1\\n                helper(xs, (x, step)::right, res max (if (step >= huge) 0 else step))\\n            }\\n        }\\n        \\n\\t\\t// the first element will never be removed\\n        helper(nums.drop(1).toList, List((nums.head, huge)), 0)\\n    }\\n}\\n```\\n\\n## 2. Simulating the Removal Process: O(N^2)\\nThe brute force method takes n-squared time complexity. It would exceed time or memory limit.\\n```Scala\\nimport scala.annotation.tailrec\\nobject Solution {\\n    def totalSteps(nums: Array[Int]): Int = {\\n        @tailrec\\n        def doSteps(nums: Array[Int], accumu: Int): Int = if (nums sameElements nums.sorted) accumu else {\\n            doSteps((Int.MinValue +: nums).sliding(2).filter(x => x(0) <= x(1)).map(_(1)).toArray, 1 + accumu)\\n        }\\n        doSteps(nums, 0)\\n    }\\n}\\n```\\n## 3. Find the Result Array\\nWe can find the resulted array after all the removals by simply modifying the first Mono-stack method. All the elements with `step >= huge` will be remained in the final result. The time complexity is `O(N)`.\\n\\nThere\\'s also an interesting divide-and-conquer method to do that. we can obtain an `O(N Log(N))` time complexity to get the resulted array by doing so.\\n```Scala\\ndef doSteps(nums: Array[Int]): Array[Int] = if (nums.size <= 1) nums else {\\n\\tval mid = nums.size / 2;\\n\\tval (left, right) = (doSteps(nums.take(mid)), doSteps(nums.drop(mid)))\\n\\tleft ++ right.filter(_ >= left.last)\\n}\\n```",
                "solutionTags": [
                    "Scala",
                    "Stack"
                ],
                "code": "```scala\\nimport scala.annotation.tailrec\\nobject Solution {\\n    def totalSteps(nums: Array[Int]): Int = {\\n        val huge = Int.MaxValue / 2    // step >= huge means an element will never be removed\\n        \\n\\t\\t@tailrec\\n        def helper(nums: List[Int], stack: List[(Int, Int)], res: Int): Int = nums match {\\n            case Nil => res\\n            case x::xs => {\\n                val (left, right) = stack.span(_._1 <= x)\\n\\t\\t\\t    // elements in @left is less or equal to x, delaying the removal of x like some \\'blockers\\'.\\n\\t\\t\\t\\t// We find out which blocker caused the longest delay and update the removal time of x by adding 1\\n                val step = if (left == Nil) 1 else left.map(_._2).max + 1\\n                helper(xs, (x, step)::right, res max (if (step >= huge) 0 else step))\\n            }\\n        }\\n        \\n\\t\\t// the first element will never be removed\\n        helper(nums.drop(1).toList, List((nums.head, huge)), 0)\\n    }\\n}\\n```\n```Scala\\nimport scala.annotation.tailrec\\nobject Solution {\\n    def totalSteps(nums: Array[Int]): Int = {\\n        @tailrec\\n        def doSteps(nums: Array[Int], accumu: Int): Int = if (nums sameElements nums.sorted) accumu else {\\n            doSteps((Int.MinValue +: nums).sliding(2).filter(x => x(0) <= x(1)).map(_(1)).toArray, 1 + accumu)\\n        }\\n        doSteps(nums, 0)\\n    }\\n}\\n```\n```Scala\\ndef doSteps(nums: Array[Int]): Array[Int] = if (nums.size <= 1) nums else {\\n\\tval mid = nums.size / 2;\\n\\tval (left, right) = (doSteps(nums.take(mid)), doSteps(nums.drop(mid)))\\n\\tleft ++ right.filter(_ >= left.last)\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2800509,
                "title": "c-o-n-monostack",
                "content": "```\\nclass Solution {\\npublic:\\n    // monotonic stack\\n    int totalSteps(vector<int>& nums) {\\n        stack<pair<int,int>> st;\\n        int n = nums.size();\\n        for(int i=n-1;i>=0;i--){\\n            if(st.empty()){\\n                st.push({nums[i],0});\\n            }\\n            else{\\n                int ops = 0;\\n                while(!st.empty() && st.top().first<nums[i]){\\n                    if(st.top().second>ops){\\n                        ops= st.top().second;\\n                    }\\n                    else{\\n                        ops+=1;\\n                    }\\n                    st.pop();\\n                }\\n                st.push({nums[i],ops});\\n            }\\n        }\\n        int ans = 0;\\n        while(!st.empty()){\\n            ans = max(ans,st.top().second);\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // monotonic stack\\n    int totalSteps(vector<int>& nums) {\\n        stack<pair<int,int>> st;\\n        int n = nums.size();\\n        for(int i=n-1;i>=0;i--){\\n            if(st.empty()){\\n                st.push({nums[i],0});\\n            }\\n            else{\\n                int ops = 0;\\n                while(!st.empty() && st.top().first<nums[i]){\\n                    if(st.top().second>ops){\\n                        ops= st.top().second;\\n                    }\\n                    else{\\n                        ops+=1;\\n                    }\\n                    st.pop();\\n                }\\n                st.push({nums[i],ops});\\n            }\\n        }\\n        int ans = 0;\\n        while(!st.empty()){\\n            ans = max(ans,st.top().second);\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792994,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        ans = 0\\n        nums.reverse()\\n        list = [[nums[0], 0]]\\n        for i in range(1, len(nums)):\\n            count = 0\\n            while list and list[-1][0] < nums[i]:\\n                count = max(count + 1, list[-1][1])\\n                list.pop()\\n            list.append([nums[i], count])\\n            ans = max(ans, count)\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        ans = 0\\n        nums.reverse()\\n        list = [[nums[0], 0]]\\n        for i in range(1, len(nums)):\\n            count = 0\\n            while list and list[-1][0] < nums[i]:\\n                count = max(count + 1, list[-1][1])\\n                list.pop()\\n            list.append([nums[i], count])\\n            ans = max(ans, count)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2789100,
                "title": "typescript-solution-with-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nDP\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nfunction totalSteps(nums: number[]): number {\\n    let dp = new Array(nums.length).fill(0)\\n    let distances = new Array(nums.length).fill(0)\\n    let result = 0\\n    for(let i = dp.length - 2; i >= 0; i--) {\\n        for(let j = 1; i + j < nums.length; j++) {\\n            if(nums[i+j] >= nums[i]) {\\n                break\\n            } else {\\n                dp[i] += 1\\n                distances[i] += 1\\n                if(dp[i+j] === 0) {\\n                } else {\\n                    if(dp[i] < dp[i+j]) {\\n                        dp[i] = dp[i+j]\\n                    }\\n                    distances[i] += distances[i+j]\\n                    j += distances[i+j]\\n                }\\n                if(dp[i] > result) {\\n                    result = dp[i]\\n                }\\n            }\\n        }\\n    }\\n    return result\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction totalSteps(nums: number[]): number {\\n    let dp = new Array(nums.length).fill(0)\\n    let distances = new Array(nums.length).fill(0)\\n    let result = 0\\n    for(let i = dp.length - 2; i >= 0; i--) {\\n        for(let j = 1; i + j < nums.length; j++) {\\n            if(nums[i+j] >= nums[i]) {\\n                break\\n            } else {\\n                dp[i] += 1\\n                distances[i] += 1\\n                if(dp[i+j] === 0) {\\n                } else {\\n                    if(dp[i] < dp[i+j]) {\\n                        dp[i] = dp[i+j]\\n                    }\\n                    distances[i] += distances[i+j]\\n                    j += distances[i+j]\\n                }\\n                if(dp[i] > result) {\\n                    result = dp[i]\\n                }\\n            }\\n        }\\n    }\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2774102,
                "title": "java-javascript-python-solution-o-n-time-using-stack",
                "content": "**Java:**\\n```\\nimport java.util.Stack;\\n\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        int ans = 0;\\n        int n = nums.length;\\n        Stack<Integer[]> stack = new Stack<Integer[]>();\\n        stack.push(new Integer[] {nums[n-1], 0});\\n        \\n        for(int i = n-2; i >= 0; i--) {\\n            int count = 0;\\n            int max = 0;\\n            while(stack.size() > 0 && stack.peek()[0] < nums[i]) {\\n                Integer[] el = stack.pop();\\n                max = Math.max(max, el[1]);\\n                count++;\\n                count = Math.max(count, max);\\n            }\\n            stack.push(new Integer[]{nums[i], count});\\n            ans = Math.max(ans, count);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n**Javascript:**\\n```\\nconst totalSteps = function(nums) {\\n    const n = nums.length;\\n    const stack = [[nums[n-1],0]];\\n    let ans = 0;\\n    for(let i = n-2; i >= 0; i--) {\\n        let count = 0;\\n        let max = 0;\\n        while(stack.length && stack[stack.length-1][0] < nums[i]) {\\n            max = Math.max(max, stack.pop()[1]);\\n            count++;\\n            count = Math.max(count, max);\\n        }\\n        stack.push([nums[i], count]);\\n        ans = Math.max(ans, count);\\n    }\\n    return ans;\\n};\\n```\\n**Python:**\\n```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        n = len(nums);\\n        stack = [[nums[-1],0]];\\n        ans = 0;\\n        \\n        for i in range(n-2, -1, -1):\\n            count = 0;\\n            m = 0;\\n            while len(stack) > 0 and stack[-1][0] < nums[i]:\\n                m = max(m, stack.pop()[1]);\\n                count += 1;\\n                count = max(count, m);\\n            stack.append([nums[i], count]);\\n            ans = max(ans, count);\\n        \\n        return ans;\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript",
                    "Stack"
                ],
                "code": "```\\nimport java.util.Stack;\\n\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        int ans = 0;\\n        int n = nums.length;\\n        Stack<Integer[]> stack = new Stack<Integer[]>();\\n        stack.push(new Integer[] {nums[n-1], 0});\\n        \\n        for(int i = n-2; i >= 0; i--) {\\n            int count = 0;\\n            int max = 0;\\n            while(stack.size() > 0 && stack.peek()[0] < nums[i]) {\\n                Integer[] el = stack.pop();\\n                max = Math.max(max, el[1]);\\n                count++;\\n                count = Math.max(count, max);\\n            }\\n            stack.push(new Integer[]{nums[i], count});\\n            ans = Math.max(ans, count);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\n```\\nconst totalSteps = function(nums) {\\n    const n = nums.length;\\n    const stack = [[nums[n-1],0]];\\n    let ans = 0;\\n    for(let i = n-2; i >= 0; i--) {\\n        let count = 0;\\n        let max = 0;\\n        while(stack.length && stack[stack.length-1][0] < nums[i]) {\\n            max = Math.max(max, stack.pop()[1]);\\n            count++;\\n            count = Math.max(count, max);\\n        }\\n        stack.push([nums[i], count]);\\n        ans = Math.max(ans, count);\\n    }\\n    return ans;\\n};\\n```\n```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        n = len(nums);\\n        stack = [[nums[-1],0]];\\n        ans = 0;\\n        \\n        for i in range(n-2, -1, -1):\\n            count = 0;\\n            m = 0;\\n            while len(stack) > 0 and stack[-1][0] < nums[i]:\\n                m = max(m, stack.pop()[1]);\\n                count += 1;\\n                count = max(count, m);\\n            stack.append([nums[i], count]);\\n            ans = max(ans, count);\\n        \\n        return ans;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2681851,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        int n=nums.length;\\n        int ans=0;\\n\\n        Stack<Pair<Integer,Integer>> st=new Stack<>();\\n        st.push(new Pair<>(nums[n-1],0));\\n        for(int i=n-2;i>=0;i--){\\n            int count=0;\\n            while(!st.isEmpty() && nums[i]>st.peek().getKey()){\\n                count=Math.max(count+1,st.peek().getValue());\\n                st.pop();\\n                }\\n                ans=Math.max(ans,count);\\n                st.push(new Pair(nums[i],count));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        int n=nums.length;\\n        int ans=0;\\n\\n        Stack<Pair<Integer,Integer>> st=new Stack<>();\\n        st.push(new Pair<>(nums[n-1],0));\\n        for(int i=n-2;i>=0;i--){\\n            int count=0;\\n            while(!st.isEmpty() && nums[i]>st.peek().getKey()){\\n                count=Math.max(count+1,st.peek().getValue());\\n                st.pop();\\n                }\\n                ans=Math.max(ans,count);\\n                st.push(new Pair(nums[i],count));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630986,
                "title": "golang-solution-by-chris",
                "content": "In go playground, the output is correct.\\nBut in the leetcode, it outputs \"Unknown Error\".\\nWhy?\\n```\\nfunc totalSteps(nums []int) int {\\n\\tlenNums := len(nums)\\n\\tvar nums1, nums2, empty []int\\n\\tnums1 = nums\\n\\tended := 1\\n\\tfor i := 0; i < lenNums-1; i++ {\\n\\t\\tended = 0\\n\\t\\tnums2 = append(empty, nums[0])\\n\\t\\tfor index := 1; index < len(nums1); index++ {\\n\\t\\t\\tif nums1[index] >= nums1[index-1] {\\n\\t\\t\\t\\tnums2 = append(nums2, nums1[index])\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tended = 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif ended == 0 {\\n\\t\\t\\treturn i\\n\\t\\t}\\n\\t\\tnums1 = nums2\\n\\t}\\n\\treturn lenNums\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nfunc totalSteps(nums []int) int {\\n\\tlenNums := len(nums)\\n\\tvar nums1, nums2, empty []int\\n\\tnums1 = nums\\n\\tended := 1\\n\\tfor i := 0; i < lenNums-1; i++ {\\n\\t\\tended = 0\\n\\t\\tnums2 = append(empty, nums[0])\\n\\t\\tfor index := 1; index < len(nums1); index++ {\\n\\t\\t\\tif nums1[index] >= nums1[index-1] {\\n\\t\\t\\t\\tnums2 = append(nums2, nums1[index])\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tended = 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif ended == 0 {\\n\\t\\t\\treturn i\\n\\t\\t}\\n\\t\\tnums1 = nums2\\n\\t}\\n\\treturn lenNums\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2606587,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int n = nums.size(), ans = 0;\\n        stack<int> s;\\n        vector<int> dp(n+1, 0);\\n        for(int i = n-1; i >= 0; i--){\\n            while(!s.empty()){\\n                if(nums[s.top()] < nums[i]){\\n                    dp[i] = max(dp[i] + 1, dp[s.top()]);\\n                    s.pop();\\n                    ans = max(dp[i], ans);\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            s.push(i);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int n = nums.size(), ans = 0;\\n        stack<int> s;\\n        vector<int> dp(n+1, 0);\\n        for(int i = n-1; i >= 0; i--){\\n            while(!s.empty()){\\n                if(nums[s.top()] < nums[i]){\\n                    dp[i] = max(dp[i] + 1, dp[s.top()]);\\n                    s.pop();\\n                    ans = max(dp[i], ans);\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            s.push(i);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2603448,
                "title": "java-stack",
                "content": "```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        int cur_max = -1, answer = 0;\\n        ArrayDeque<Node> stack = new ArrayDeque<>();\\n        for(int num: nums){\\n            if(cur_max<=num){\\n                cur_max = num;\\n                stack = new ArrayDeque<>();\\n                stack.push(new Node(num,0,Integer.MAX_VALUE));\\n            }\\n            else{\\n                while(stack.peek().value<=num) stack.pop();\\n                Node parent = stack.pop();\\n                Node child = new Node(num,0,++parent.helped);\\n                answer = Math.max(answer,parent.helped);\\n                if(parent.helped<parent.rank) stack.push(parent);\\n                stack.push(child);\\n            }\\n        }\\n        return answer;\\n    }\\n}\\nclass Node{\\n    int value;\\n    int helped;\\n    int rank;\\n    \\n    public Node(int value, int helped, int rank){\\n        this.value = value;\\n        this.helped = helped;\\n        this.rank = rank;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        int cur_max = -1, answer = 0;\\n        ArrayDeque<Node> stack = new ArrayDeque<>();\\n        for(int num: nums){\\n            if(cur_max<=num){\\n                cur_max = num;\\n                stack = new ArrayDeque<>();\\n                stack.push(new Node(num,0,Integer.MAX_VALUE));\\n            }\\n            else{\\n                while(stack.peek().value<=num) stack.pop();\\n                Node parent = stack.pop();\\n                Node child = new Node(num,0,++parent.helped);\\n                answer = Math.max(answer,parent.helped);\\n                if(parent.helped<parent.rank) stack.push(parent);\\n                stack.push(child);\\n            }\\n        }\\n        return answer;\\n    }\\n}\\nclass Node{\\n    int value;\\n    int helped;\\n    int rank;\\n    \\n    public Node(int value, int helped, int rank){\\n        this.value = value;\\n        this.helped = helped;\\n        this.rank = rank;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2567529,
                "title": "bfs-with-updating-neighbours-o-n-python3",
                "content": "```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        l = [i-1 for i in range(n)]\\n        r = [i+1 for i in range(n)]\\n        q = []\\n        dist = dict()\\n        ans = 0\\n        for i in range(1, n):\\n            if nums[i] < nums[i-1]:\\n                q.append(i)\\n                dist[i] = 1\\n                ans = 1\\n        while len(q) != 0:\\n            u = q.pop(0)\\n            ans = max(ans, dist[u])\\n            if r[u] < n:\\n                l[r[u]] = l[u]\\n            if l[u] > -1:\\n                r[l[u]] = r[u]\\n            if r[u] not in dist and r[u] < n and nums[r[u]] < nums[l[u]]:\\n                dist[r[u]] = dist[u] + 1\\n                q.append(r[u])\\n        return ans\\n            \\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        l = [i-1 for i in range(n)]\\n        r = [i+1 for i in range(n)]\\n        q = []\\n        dist = dict()\\n        ans = 0\\n        for i in range(1, n):\\n            if nums[i] < nums[i-1]:\\n                q.append(i)\\n                dist[i] = 1\\n                ans = 1\\n        while len(q) != 0:\\n            u = q.pop(0)\\n            ans = max(ans, dist[u])\\n            if r[u] < n:\\n                l[r[u]] = l[u]\\n            if l[u] > -1:\\n                r[l[u]] = r[u]\\n            if r[u] not in dist and r[u] < n and nums[r[u]] < nums[l[u]]:\\n                dist[r[u]] = dist[u] + 1\\n                q.append(r[u])\\n        return ans\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2558597,
                "title": "dp-stack-histogram-problem",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> vec, dp(n, 0);\\n        \\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(!vec.empty() && nums[i]>nums[vec.back()])\\n            {\\n                dp[i] = max(dp[i]+1, dp[vec.back()]);\\n                vec.pop_back();\\n            }\\n            vec.push_back(i);\\n        }\\n        int cnt = 0;\\n        for(int i=0;i<dp.size();i++)\\n        {\\n            cnt = max(cnt, dp[i]);\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> vec, dp(n, 0);\\n        \\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            while(!vec.empty() && nums[i]>nums[vec.back()])\\n            {\\n                dp[i] = max(dp[i]+1, dp[vec.back()]);\\n                vec.pop_back();\\n            }\\n            vec.push_back(i);\\n        }\\n        int cnt = 0;\\n        for(int i=0;i<dp.size();i++)\\n        {\\n            cnt = max(cnt, dp[i]);\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2551810,
                "title": "golang-stack-solution",
                "content": "```\\nfunc totalSteps(nums []int) int {\\n    steps := 0\\n    ans := 0\\n\\t// [][index,steps]\\n    stack := [][2]int{}\\n    for i := len(nums)-1 ; i >= 0; i-- {\\n        // start new iteration\\n        steps = 0\\n        for len(stack) > 0 {\\n            item := stack[len(stack)-1]\\n            \\n            // check if number is greater than our last added item -> nums[i - 1] > nums[i]\\n            if nums[i] > item[0] {\\n                // increase steps by 1 and attempt max update\\n                steps = max(steps+1, item[1])          \\n                // pop off stack\\n                stack = stack[:len(stack)-1]\\n            } else {\\n                // number is good, break out\\n                break\\n            }\\n        }\\n        \\n        // attempt max answer update\\n        ans = max(ans, steps)\\n        \\n        // push item onto the stack\\n        stack = append(stack, [2]int{nums[i], steps})\\n        \\n    }\\n    return ans\\n}\\n\\nfunc max (a,b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc totalSteps(nums []int) int {\\n    steps := 0\\n    ans := 0\\n\\t// [][index,steps]\\n    stack := [][2]int{}\\n    for i := len(nums)-1 ; i >= 0; i-- {\\n        // start new iteration\\n        steps = 0\\n        for len(stack) > 0 {\\n            item := stack[len(stack)-1]\\n            \\n            // check if number is greater than our last added item -> nums[i - 1] > nums[i]\\n            if nums[i] > item[0] {\\n                // increase steps by 1 and attempt max update\\n                steps = max(steps+1, item[1])          \\n                // pop off stack\\n                stack = stack[:len(stack)-1]\\n            } else {\\n                // number is good, break out\\n                break\\n            }\\n        }\\n        \\n        // attempt max answer update\\n        ans = max(ans, steps)\\n        \\n        // push item onto the stack\\n        stack = append(stack, [2]int{nums[i], steps})\\n        \\n    }\\n    return ans\\n}\\n\\nfunc max (a,b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2533195,
                "title": "c-easy-solution-stack",
                "content": "```\\nclass Solution {\\npublic:\\n\\tint totalSteps(vector<int>& nums) {\\n\\t\\tint n = nums.size(), ans = 0;\\n\\t\\tstack<pair<int, int>> st;\\n\\t\\tst.push({nums[n- 1], 0});\\n\\t\\tfor (int i = n - 2; i >= 0; --i) {\\n\\t\\t\\tint ct = 0;\\n\\t\\t\\twhile (st.size() && st.top().first < nums[i]) {\\n\\t\\t\\t\\tct = max(ct + 1, st.top().second);\\n\\t\\t\\t\\tst.pop();\\n\\t\\t\\t}\\n\\t\\t\\tans = max(ans, ct);\\n\\t\\t\\tst.push({nums[i], ct});\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint totalSteps(vector<int>& nums) {\\n\\t\\tint n = nums.size(), ans = 0;\\n\\t\\tstack<pair<int, int>> st;\\n\\t\\tst.push({nums[n- 1], 0});\\n\\t\\tfor (int i = n - 2; i >= 0; --i) {\\n\\t\\t\\tint ct = 0;\\n\\t\\t\\twhile (st.size() && st.top().first < nums[i]) {\\n\\t\\t\\t\\tct = max(ct + 1, st.top().second);\\n\\t\\t\\t\\tst.pop();\\n\\t\\t\\t}\\n\\t\\t\\tans = max(ans, ct);\\n\\t\\t\\tst.push({nums[i], ct});\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2526961,
                "title": "java-crisp-monotonic-stack-solution",
                "content": "Code:\\n```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        int max = 0;\\n        // stack of [num, #steps this num responsible for]\\n        Deque<int[]> stack = new ArrayDeque<>();\\n        for(int i=nums.length - 1; i>=0; i--) {\\n            int num = nums[i];\\n            // steps = how many steps num responsible for\\n            int steps = 0;\\n            while(!stack.isEmpty() && num > stack.peekLast()[0]) {\\n                steps++; // takes 1 step for num to pop the top\\n                int poppedSteps = stack.removeLast()[1];\\n                // so num has popped STEPS steps so far and sees POPPEDSTEPS\\n                // if STEPS >= POPPEDSTEPS well nothing happens due to parallel nature\\n                // so what matters is of STEPS < POPPEDSTEPS. we can \"steal\" those already popped\\n                if (steps < poppedSteps) {\\n                    steps = poppedSteps;\\n                } \\n            }\\n            stack.addLast(new int[]{num, steps});\\n            max = Math.max(max, steps);\\n        }\\n        return max;\\n    }\\n}\\n```\\nHopefully code comments are self-explanatory.  I wasn\\'t able to solve this with forward iteration monostack after far too much thinking and a failed submission so as with many other difficult questions, tried iterating backwards and quickly arrived at my solution.\\n\\nSome nice test cases to work through are: ```[9,6,1,2,3]``` and ```[9,5,6,1,2,3]``` to see how the \"stealing\" that ```steps = poppedSteps``` works as that\\'s the trick behind my solution. Basically ```9``` \"steals\" ```6```\\'s 3 steps.\\nFor good measure you can also work through  ```[9,4,5,6,1,2,3]``` and ```[9,3,4,5,6,1,2,3]```.",
                "solutionTags": [
                    "Java",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        int max = 0;\\n        // stack of [num, #steps this num responsible for]\\n        Deque<int[]> stack = new ArrayDeque<>();\\n        for(int i=nums.length - 1; i>=0; i--) {\\n            int num = nums[i];\\n            // steps = how many steps num responsible for\\n            int steps = 0;\\n            while(!stack.isEmpty() && num > stack.peekLast()[0]) {\\n                steps++; // takes 1 step for num to pop the top\\n                int poppedSteps = stack.removeLast()[1];\\n                // so num has popped STEPS steps so far and sees POPPEDSTEPS\\n                // if STEPS >= POPPEDSTEPS well nothing happens due to parallel nature\\n                // so what matters is of STEPS < POPPEDSTEPS. we can \"steal\" those already popped\\n                if (steps < poppedSteps) {\\n                    steps = poppedSteps;\\n                } \\n            }\\n            stack.addLast(new int[]{num, steps});\\n            max = Math.max(max, steps);\\n        }\\n        return max;\\n    }\\n}\\n```\n```[9,6,1,2,3]```\n```[9,5,6,1,2,3]```\n```steps = poppedSteps```\n```9```\n```6```\n```[9,4,5,6,1,2,3]```\n```[9,3,4,5,6,1,2,3]```",
                "codeTag": "Java"
            },
            {
                "id": 2440631,
                "title": "python3-monotonic-stack",
                "content": "class Solution:\\n\\n    def totalSteps(self, nums: List[int]) -> int:\\n        res = 0\\n        length = len(nums)\\n        stack = [[nums[-1],0]]\\n        \\n        for i in reversed(range(length-1)):\\n            count = 0\\n            while stack and stack[-1][0]<nums[i]:\\n                count = max(1+count,stack.pop()[1])\\n            res = max(res,count)\\n            stack.append([nums[i],count])\\n        \\n        return res",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def totalSteps(self, nums: List[int]) -> int:\\n        res = 0\\n        length = len(nums)\\n        stack = [[nums[-1],0]]\\n        \\n        for i in reversed(range(length-1)):\\n            count = 0\\n            while stack and stack[-1][0]<nums[i]:\\n                count = max(1+count,stack.pop()[1])\\n            res = max(res,count)\\n            stack.append([nums[i],count])\\n        \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2435598,
                "title": "monotonic-stack-dp",
                "content": "Intution: find the element of the index which will destroy the element and find the longest survival in that range and add 1 to your current element if its destroyed by its neighbour element just put your element survival day as your previous 1.\\n```\\n int totalSteps(vector<int>& nums) {\\n        nums.push_back(INT_MAX);\\n        stack<pair<int,int>>st;\\n        st.push({nums[0],0});\\n        int ans=0;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n           if(nums[i]<st.top().first)\\n           {\\n               st.push({nums[i],1});\\n           }\\n            else{\\n                pair<int,int> a;\\n                int res=0;\\n            while(!st.empty() && nums[i]>=st.top().first)\\n            {\\n                a=st.top();\\n                ans=max(ans,a.second);\\n                res=max(res,a.second);\\n                st.pop();\\n            }\\n                if(st.empty())\\n                {\\n                  st.push({nums[i],0});  \\n                }\\n                else\\n                st.push({nums[i],res+1});\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\n int totalSteps(vector<int>& nums) {\\n        nums.push_back(INT_MAX);\\n        stack<pair<int,int>>st;\\n        st.push({nums[0],0});\\n        int ans=0;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n           if(nums[i]<st.top().first)\\n           {\\n               st.push({nums[i],1});\\n           }\\n            else{\\n                pair<int,int> a;\\n                int res=0;\\n            while(!st.empty() && nums[i]>=st.top().first)\\n            {\\n                a=st.top();\\n                ans=max(ans,a.second);\\n                res=max(res,a.second);\\n                st.pop();\\n            }\\n                if(st.empty())\\n                {\\n                  st.push({nums[i],0});  \\n                }\\n                else\\n                st.push({nums[i],res+1});\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2434807,
                "title": "c-dp-monotonic-stack-clean-code",
                "content": "class Solution {\\npublic:\\n\\n    int totalSteps(vector<int>& nums) {\\n        int n = nums.size(), ans = 0;\\n        vector<int> v, dp(n);\\n        \\n        for(int i = n-1; i >= 0; --i){\\n            while(!v.empty() and nums[i] > nums[v.back()]){\\n                dp[i] = max(++dp[i], dp[v.back()]);\\n                v.pop_back();\\n                ans = max(ans, dp[i]);\\n            }\\n            v.push_back(i);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n**Time: O(N), Space: O(N).\\nPLEASE UPVOTE IF HELPFUL!!!**\\n\\nFor doubt, comment below.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int totalSteps(vector<int>& nums) {\\n        int n = nums.size(), ans = 0;\\n        vector<int> v, dp(n);\\n        \\n        for(int i = n-1; i >= 0; --i){\\n            while(!v.empty() and nums[i] > nums[v.back()]){\\n                dp[i] = max(++dp[i], dp[v.back()]);\\n                v.pop_back();\\n                ans = max(ans, dp[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2388219,
                "title": "c-easy-commented-solution",
                "content": "class Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int n=nums.size(); //Taking the size of the array\\n        stack<pair<int,int>>st; //making a stack of pair type to hold the key value pair \\n\\t\\t//in key placeholder I will store the element and in value placeholder I will hold the number of rounds.\\n        int ans=0;\\n        st.push({nums[n-1],0});  //storing the first element from right\\n        for(int i=n-2;i>=0;i--) //start to iterate from the second last element\\n        {\\n            int count=0;\\n            while(!st.empty() and nums[i]>st.top().first) //if the element pushed at the top of the stack is greater than the element which was previously at the top then we will remove the previous element and increase the count against the number of elements which is popped out\\n            {\\n                count=max(count+1,st.top().second);\\n                st.pop();\\n                \\n            }\\n            \\n            ans=max(ans,count);\\n            st.push({nums[i],count});  //else simply push the element\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int n=nums.size(); //Taking the size of the array\\n        stack<pair<int,int>>st; //making a stack of pair type to hold the key value pair \\n\\t\\t//in key placeholder I will store the element and in value placeholder I will hold the number of rounds.\\n        int ans=0;\\n        st.push({nums[n-1],0}",
                "codeTag": "Java"
            },
            {
                "id": 2367656,
                "title": "c-forward-traversal",
                "content": "TBH this problem has been driving me nuts but I finally got an accepted solution based on the following thoughts.\\n\\nLooking at any sequence it will be made up of a **non-descending sequence** *A,B,C...*  intersperced with zero or more other sequences *a,b,c,d...* where all values are **strictly less-than** the previous item in the non-descending sequence. \\n\\nIf a,b,c,d... is **strictly decreasing** (ie a > b, b > c etc) the sequence will be consumed in **one step** each item by the preceeding one.\\n\\nIf a,b,c,d... is **non-decreasing** (ie a<= b, b <= c etc) the number of steps will be **exactly the number of items in the sequence**.\\n\\nOf course the norm is a mixture of subsequences and the head scratching begins... at least for me...\\n\\nMy intuition was it should be possible to forward traverse the main sequence with only a couple of variables for protection from the LeetCode orcs testcases. Specifically: one int to hold the `last_max` and another to hold its `last_step`. This is due to the following:\\n\\nOur subsequence is made up of \"runs\" of non-decreasing numbers **a<sub>1</sub>..a<sub>i</sub>, b<sub>1</sub>..b<sub>j</sub>, c<sub>1</sub>..c<sub>k</sub>** etc. They always commence with a value strictly less than the previous value but subsequent values may be >= the `last_max` - if this is the case that value say **b<sub>x</sub>** terminates the consumption of the \"b\" sequence and becomes the next item in the **a<sub>1</sub>..a<sub>i</sub>** sequence. Specifically **a<sub>i+1</sub>**\\n\\nAdditionally if the \"b\" sequence is longer than the \"a\" sequence its last value say **a<sub>i</sub>** is consumed at the same time as **b<sub>i</sub>** (and **c<sub>i</sub>**...) so **b<sub>i+1</sub>** becomes the `last_max` we care about and `i+1` its `last_step` even if **b<sub>i+1</sub>** is less than **a<sub>i</sub>**.\\n\\nHowever its \"elephants all the way down\" so when there are many subsequences each pair needs to be looked at as above and we need more than a single pair of variables to to keep track as multiple subsequences are exhausted or extended *in parallel*. In other words we need a `stack`\\n\\nThis is my solution - not as efficient as I would like but I\\'m just happy to get it accepted.\\n\\nAll the best!\\n\\n```\\nclass Solution {\\n    struct Pair {\\n        int num,step;\\n        Pair(int n) : num(n), step(1) {}\\n        bool operator <= (const Pair& p) { return num <= p.num || step < p.step; }  // close enough... \\n    };\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int steps=0, nmax=nums.size()?nums[0]:0;\\n        vector<Pair> save;\\n        \\n        for (int i=1; i<nums.size(); i++) {\\n\\t\\t\\tif (nmax <= nums[i]) {                  // next non-decreasing value?\\n                if (save.size()) save.clear();\\n                nmax = nums[i];\\n            }\\n            else {\\n                Pair p(nums[i]);\\n                while (save.size() && save.back() <= p) {\\n                    p.step = max(p.step,save.back().step+1);\\n                    save.pop_back();\\n                }\\n                save.emplace_back(p);\\n                steps = max(steps,p.step);\\n            }\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    struct Pair {\\n        int num,step;\\n        Pair(int n) : num(n), step(1) {}\\n        bool operator <= (const Pair& p) { return num <= p.num || step < p.step; }  // close enough... \\n    };\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int steps=0, nmax=nums.size()?nums[0]:0;\\n        vector<Pair> save;\\n        \\n        for (int i=1; i<nums.size(); i++) {\\n\\t\\t\\tif (nmax <= nums[i]) {                  // next non-decreasing value?\\n                if (save.size()) save.clear();\\n                nmax = nums[i];\\n            }\\n            else {\\n                Pair p(nums[i]);\\n                while (save.size() && save.back() <= p) {\\n                    p.step = max(p.step,save.back().step+1);\\n                    save.pop_back();\\n                }\\n                save.emplace_back(p);\\n                steps = max(steps,p.step);\\n            }\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2341808,
                "title": "python3-stack-dp",
                "content": "```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        dp=[0]*n\\n        stack=[]\\n        for i in range(n-1,-1,-1):\\n            while stack and nums[i]>nums[stack[-1]]:\\n                dp[i]=max(dp[i]+1,dp[stack[-1]])\\n                stack.pop()\\n            stack.append(i)\\n        return max(dp)\\n```\\nVideo Reference -> https://www.youtube.com/watch?v=XirZ8GtWxWA",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        dp=[0]*n\\n        stack=[]\\n        for i in range(n-1,-1,-1):\\n            while stack and nums[i]>nums[stack[-1]]:\\n                dp[i]=max(dp[i]+1,dp[stack[-1]])\\n                stack.pop()\\n            stack.append(i)\\n        return max(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2313932,
                "title": "python3-mono-stack",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/7a598e64fb507fc966a3025d8edd0c8e7caf0bec) for solutions of weekly 295. \\n\\n```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        ans = 0 \\n        stack = []\\n        for x in nums: \\n            val = 1\\n            while stack and stack[-1][0] <= x: val = max(val, stack.pop()[1]+1)\\n            if not stack: val = 0\\n            stack.append((x, val))\\n            ans = max(ans, val)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        ans = 0 \\n        stack = []\\n        for x in nums: \\n            val = 1\\n            while stack and stack[-1][0] <= x: val = max(val, stack.pop()[1]+1)\\n            if not stack: val = 0\\n            stack.append((x, val))\\n            ans = max(ans, val)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2238056,
                "title": "c-simple-clean-and-elegant",
                "content": "\\t\\tint totalSteps(vector<int>& nums) \\n    {   \\n        \\n        int n=nums.size();\\n      \\n        stack<pair<int,int>> st;\\n        \\n        int res=0;\\n        \\n        st.push({INT_MAX,0});\\n        \\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            int c=0;\\n            \\n            while(st.top().first<nums[i])\\n            {\\n                c+=max(0,st.top().second-c-1)+1;\\n                st.pop();\\n                 \\n            }\\n            \\n            res=max(res,c);\\n            \\n            st.push({nums[i],c});\\n        }\\n        \\n        return res;\\n    }",
                "solutionTags": [],
                "code": "\\t\\tint totalSteps(vector<int>& nums) \\n    {   \\n        \\n        int n=nums.size();\\n      \\n        stack<pair<int,int>> st;\\n        \\n        int res=0;\\n        \\n        st.push({INT_MAX,0});\\n        \\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            int c=0;\\n            \\n            while(st.top().first<nums[i])\\n            {\\n                c+=max(0,st.top().second-c-1)+1;\\n                st.pop();\\n                 \\n            }\\n            \\n            res=max(res,c);\\n            \\n            st.push({nums[i],c});\\n        }\\n        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2236324,
                "title": "java-monotonic-stack-solution",
                "content": "```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        int result = 0;\\n        Stack<int[]> stack = new Stack<>();\\n        for(int i=nums.length-1;i>=0;i--){\\n            if(stack.isEmpty())\\n                stack.push(new int[]{nums[i],0});\\n            else{\\n                int count = 0;\\n                while(!stack.isEmpty() && stack.peek()[0]<nums[i]){\\n                    count = Math.max(count+1,stack.peek()[1]);\\n                    stack.pop();\\n                }\\n                result = Math.max(count,result);\\n                stack.push(new int[]{nums[i],count});\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        int result = 0;\\n        Stack<int[]> stack = new Stack<>();\\n        for(int i=nums.length-1;i>=0;i--){\\n            if(stack.isEmpty())\\n                stack.push(new int[]{nums[i],0});\\n            else{\\n                int count = 0;\\n                while(!stack.isEmpty() && stack.peek()[0]<nums[i]){\\n                    count = Math.max(count+1,stack.peek()[1]);\\n                    stack.pop();\\n                }\\n                result = Math.max(count,result);\\n                stack.push(new int[]{nums[i],count});\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2213526,
                "title": "100-c-1-night-stack-pair",
                "content": "**1. PUSH IN STACK STRAIGHT AWAY IF LARGEST ELEMENT.\\n2. POP TILL GREATER ELEMENT NOT FOUND**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) \\n    {\\n        stack<pair<int,int>> st;\\n        st.push(make_pair(nums[0],0));\\n        \\n        int bg=nums[0];\\n        int ans=0;\\n        \\n        for(int i=1;i<nums.size();i=i+1)\\n        {\\n            int m = 0;\\n            \\n            if(nums[i]>bg)\\n            {\\n                 st.push(make_pair(nums[i],0));\\n                 bg=nums[i];\\n                 continue;\\n            } \\n            \\n            while(st.top().first<=nums[i])\\n            {\\n                if(st.top().first==nums[i] && st.top().second==0)\\n                {\\n                     m=-1;break;\\n                }\\n                m=max(st.top().second,m);\\n                st.pop();\\n            }\\n            \\n            st.push(make_pair(nums[i],m+1));\\n            ans=max(ans,m+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) \\n    {\\n        stack<pair<int,int>> st;\\n        st.push(make_pair(nums[0],0));\\n        \\n        int bg=nums[0];\\n        int ans=0;\\n        \\n        for(int i=1;i<nums.size();i=i+1)\\n        {\\n            int m = 0;\\n            \\n            if(nums[i]>bg)\\n            {\\n                 st.push(make_pair(nums[i],0));\\n                 bg=nums[i];\\n                 continue;\\n            } \\n            \\n            while(st.top().first<=nums[i])\\n            {\\n                if(st.top().first==nums[i] && st.top().second==0)\\n                {\\n                     m=-1;break;\\n                }\\n                m=max(st.top().second,m);\\n                st.pop();\\n            }\\n            \\n            st.push(make_pair(nums[i],m+1));\\n            ans=max(ans,m+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2211709,
                "title": "c-monotonic-stack-with-semantics-of-the-data-structure-used",
                "content": "[Self-Use]\\nTook me so long to understand this solution...\\nWe go in reverse order of nums, at each point, we try to figure out how many (**cnt**) rounds are needed  **till** the current element **x** has nothing left to the right to remove.\\ntop of the stack maintains the next greater element and it\\'s number of the same scemantics above (**topCount**).\\n\\nThe logic within the while loop tricked me for too long, - it can be explained like this.\\n\\n____________\\n```\\ncnt++; \\n```\\nwe need at least 1 more round to remove top, since top is smaller.\\n____________\\n____________\\n```\\nint topCount = st.top()[1]; st.pop();\\n```\\nrecords how many rounds needed to remove previous smaller element\\n__________________\\n```\\ncnt = max(topCount, cnt);\\n```\\nIf topCount < cnt, it is obvious that we need cnt number of operations to remove everything left to the right. For exmple [4,1,1,1,1], its obvious that when we get to 4, each time, cnt > topCount, so we just keep incrementing.\\n\\nIf topCount >= cnt, this means the top element itself will get removed be when we go beyond cnt operations.\\nFor example, [14, 13, 2, 6, 13], we\\'re at the point to add 14 to the stack.\\n14,? -> stack top[ (13,2) (13,0)\\nnow for 1st while loop of element 14, topCount=2, cnt = 1 \\nobserve that after operation1, we have [14 6 13], this means that 14 takes over 13\\'s topCount, and continues to remove elements after this point.\\n\\n_________________________\\n\\n```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int res = 0;\\n        stack<vector<int>> st;\\n        for (auto it = prev(nums.end()); it >= nums.begin(); it--) {\\n            int x = *it;\\n            int cnt = 0; //how many rounds needed to remove x\\n            while (!st.empty() && x > st.top()[0]) {\\n                cnt++;\\n                //rounds needed to remove top element\\n                int topCount = st.top()[1]; st.pop();\\n                cnt = max(topCount, cnt);\\n            }\\n            res = max(res, cnt);\\n            st.push({x, cnt});\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ncnt++; \\n```\n```\\nint topCount = st.top()[1]; st.pop();\\n```\n```\\ncnt = max(topCount, cnt);\\n```\n```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int res = 0;\\n        stack<vector<int>> st;\\n        for (auto it = prev(nums.end()); it >= nums.begin(); it--) {\\n            int x = *it;\\n            int cnt = 0; //how many rounds needed to remove x\\n            while (!st.empty() && x > st.top()[0]) {\\n                cnt++;\\n                //rounds needed to remove top element\\n                int topCount = st.top()[1]; st.pop();\\n                cnt = max(topCount, cnt);\\n            }\\n            res = max(res, cnt);\\n            st.push({x, cnt});\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2200571,
                "title": "c-96-faster",
                "content": "class Solution {\\npublic:\\n\\n\\t// firstly we found out the final sequence after the operations\\n\\t\\n\\t// and then stored their indexs in an array \\n\\t\\n\\t// now we know that between the indexes all elements would be removed\\n\\t\\n\\t// then we calculated the max length of the increasing sequence with the help of the stack\\n\\t//(in other words max count of the numbers which are to be deleted by a unique number)  \\n\\t//because in the range all  the elements would be deleted ( final stage) but there would be certain elements which would be deleted by the numbers in the range and some would be deleted by the border numbers i.e the indexes which we have passed\\n\\t\\n\\t// ** this length could not be found by lis(longest increasing subsequence) because lis would include that numbers also which are to be deleted by different  numbers\\n    int func(int st, int end, vector<int>& nums) \\n    {\\n        if(st>end)\\n            return 0;\\n        int ans=1;\\n        stack<int> ngr;\\n        for(int i=end; i>=st; i--)\\n        {\\n            while(!ngr.empty() && ngr.top()<nums[i])\\n                    ngr.pop();\\n            ngr.push(nums[i]);\\n            int sz = ngr.size();\\n            ans=max(ans,sz);            \\n        }\\n        return ans;\\n    }\\n    int totalSteps(vector<int>& nums) {\\n        int n = nums.size(),currmax=nums[0],res=0;\\n        vector<int> inds;\\n        inds.push_back(0);\\n        for(int i=1; i<n; i++)\\n        {\\n            if(currmax<=nums[i])\\n            {\\n                currmax=nums[i];\\n                inds.push_back(i);\\n            }\\n        }\\n        inds.push_back(n);\\n        for(int j=0; j<inds.size()-1; j++)\\n        res=max(res,func(inds[j]+1,inds[j+1]-1,nums));\\n            \\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "class Solution {\\npublic:\\n\\n\\t// firstly we found out the final sequence after the operations\\n\\t\\n\\t// and then stored their indexs in an array \\n\\t\\n\\t// now we know that between the indexes all elements would be removed\\n\\t\\n\\t// then we calculated the max length of the increasing sequence with the help of the stack\\n\\t//(in other words max count of the numbers which are to be deleted by a unique number)  \\n\\t//because in the range all  the elements would be deleted ( final stage) but there would be certain elements which would be deleted by the numbers in the range and some would be deleted by the border numbers i.e the indexes which we have passed\\n\\t\\n\\t// ** this length could not be found by lis(longest increasing subsequence) because lis would include that numbers also which are to be deleted by different  numbers\\n    int func(int st, int end, vector<int>& nums) \\n    {\\n        if(st>end)\\n            return 0;\\n        int ans=1;\\n        stack<int> ngr;\\n        for(int i=end; i>=st; i--)\\n        {\\n            while(!ngr.empty() && ngr.top()<nums[i])\\n                    ngr.pop();\\n            ngr.push(nums[i]);\\n            int sz = ngr.size();\\n            ans=max(ans,sz);            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2191943,
                "title": "c-bfs-list",
                "content": "```\\n/*\\n\\tidea borrowed from: https://github.com/wisdompeak/LeetCode/blob/master/Design/2289.Steps-to-Make-Array-Non-decreasing/2289.Steps-to-Make-Array-Non-decreasing_v1.cpp\\n*/\\nconst int N = 100010;\\nclass Solution {\\n    struct Node\\n    {\\n        Node(int v) : val(v) {}\\n        int val;\\n        Node* next = nullptr;\\n    };\\n    int ne[N], pre[N];\\n    bool del[N];\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        pre[0] = -1;\\n        ne[n-1] = n;\\n        \\n        for (int i = 0; i < n; ++ i) \\n        {\\n            if (i < n - 1) ne[i] = i + 1;   \\n            if (i) pre[i] = i - 1;\\n        }\\n\\n        queue<int> q;\\n        // for (int i = 1; i < n; ++ i) // wrong \\n        for (int i = n - 1; i >= 1; -- i)  // must going from right to left, because when we do push_back(ne[u]), we need to already know whether the next element is deleted or not in this round.\\n        {\\n            if (nums[i - 1] > nums[i])\\n                q.push(i);\\n        }\\n        int ans = 0;\\n        while (q.size())\\n        {   \\n            int len = q.size();\\n            vector<int> tmp;\\n            while (q.size())\\n            {\\n                int u = q.front(); q.pop(); \\n                //  (tmp.empty() || nums[ne[u]] != tmp.back()) this dedup is very clever\\n                if (ne[u] != n && (tmp.empty() || nums[ne[u]] != tmp.back())) tmp.push_back(ne[u]);\\n                if (pre[u] != -1) ne[pre[u]] = ne[u];\\n                if (ne[u] != n) pre[ne[u]] = pre[u];\\n                del[u] = true;\\n            }\\n            \\n            for (int i : tmp)\\n                if (!del[i] && pre[i] != -1 && nums[pre[i]] > nums[i]) q.push(i);\\n            \\n            \\n            ans ++ ;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n// [7,14,4,14,13,2,1,12,13]\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n\\tidea borrowed from: https://github.com/wisdompeak/LeetCode/blob/master/Design/2289.Steps-to-Make-Array-Non-decreasing/2289.Steps-to-Make-Array-Non-decreasing_v1.cpp\\n*/\\nconst int N = 100010;\\nclass Solution {\\n    struct Node\\n    {\\n        Node(int v) : val(v) {}\\n        int val;\\n        Node* next = nullptr;\\n    };\\n    int ne[N], pre[N];\\n    bool del[N];\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        pre[0] = -1;\\n        ne[n-1] = n;\\n        \\n        for (int i = 0; i < n; ++ i) \\n        {\\n            if (i < n - 1) ne[i] = i + 1;   \\n            if (i) pre[i] = i - 1;\\n        }\\n\\n        queue<int> q;\\n        // for (int i = 1; i < n; ++ i) // wrong \\n        for (int i = n - 1; i >= 1; -- i)  // must going from right to left, because when we do push_back(ne[u]), we need to already know whether the next element is deleted or not in this round.\\n        {\\n            if (nums[i - 1] > nums[i])\\n                q.push(i);\\n        }\\n        int ans = 0;\\n        while (q.size())\\n        {   \\n            int len = q.size();\\n            vector<int> tmp;\\n            while (q.size())\\n            {\\n                int u = q.front(); q.pop(); \\n                //  (tmp.empty() || nums[ne[u]] != tmp.back()) this dedup is very clever\\n                if (ne[u] != n && (tmp.empty() || nums[ne[u]] != tmp.back())) tmp.push_back(ne[u]);\\n                if (pre[u] != -1) ne[pre[u]] = ne[u];\\n                if (ne[u] != n) pre[ne[u]] = pre[u];\\n                del[u] = true;\\n            }\\n            \\n            for (int i : tmp)\\n                if (!del[i] && pre[i] != -1 && nums[pre[i]] > nums[i]) q.push(i);\\n            \\n            \\n            ans ++ ;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n// [7,14,4,14,13,2,1,12,13]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2189937,
                "title": "intuitions-and-proof-for-reducing-complexity-from-dp-o-n-2-to-o-n-stack-approach",
                "content": "Lets call the process of removing an element `i` with condition `num[i-1]  > nums[i]` consuming the `ith` element.\\nLet `steps[i]` be the step\\'s number at which `i` will get consumed if it is eligible for consumption. In this simulation process every eligible element will get consumed at some definite step, there will no min. or max. number of steps here.\\nNow the `ith` element can only be consumed either by the `i-1th` element or an element `j` which consumed the `i-1th` element or the element `k` which consumed the `jth` and so on.\\nLets call elements like `j,k...` the `parent(i-1)`.\\nLets call them the `consumerCandidates`.\\n\\nBasic intuition: Element `i` will get consumed only after all the elements between its consumer and it are consumed. Now the question is which elements are the candidates to be its consumer.\\n\\n**First intuition:**\\nThe `consumerCandidates` of `i` is \\n`{i-1}`  if `nums[i-1] > nums[i]`  \\notherwise, the elements in `consumerCandidates[i-1] which are > nums[i]` \\nAt the beginning of each iteration `consumerCandidates` stack represents the `consumerCandidates[i-1] + (i-1)th element` and at the end of this iteration, this stack represents `consumerCandidates[i] + (i)th element`\\n\\n**Second intuition:**\\nLet `aci` be the index of the element which actually consumes `i`\\nLet `ri` be the index of the right-most element greater than `nums[i]` in `consumerCandidates[i-1]`\\nNow, either `ri == aci` or `aci is parent(ri)`, which means either `ri consumed i` or `ri` was already consumed when `i` was consumed.\\n**Case 1**. If `ri consumed i`, then all the elements in `(ri, i)` were already consumed before that step, so\\n```\\nsteps[i] = {max(steps[k])  for k in consumerCandidates[i] intersection (ri, i)} + 1\\n```\\n**Case 2**. If `ri` was already consumed by the time `i` was consumed, then \\n```\\nThere was atleast one element still existing in (ri,i) at the time when all the elements in (aci, ri] were consumed otherwise ri would have been the one to consume i,\\nso the last element in (aci, i) before i is consumed still lies in (ri,i)\\nmax(steps[k]) for k in (aci, ri] < max(steps[p]) for p in (ri, i) \\n=> steps[i] = {max(steps[k]) for k in consumerCandidates[i-1] intersection (aci, i)} + 1 = {max(steps[k]) for k in consumerCandidates[i-1] intersection (ri, i)} + 1\\n```\\nIn both cases, \\n```\\nsteps[i] = {max(steps[k]) for k in consumerCandidates[i-1] intersection (ri, i)} + 1\\n```\\nmeaning we only need to check the elements between the `ith` and the last higher element(exclusive) and find the step at which the last of those element was consumed.\\n\\n\\n**Third intuition:**\\nInstead of maintaining and iterating through all `k in consumerCandidates[i-1] intersection (ri, i)} ` naively using an inner-loop for each `i` which will make the complexity `O(n^2)`, we can iterate through them using a stack to reduce it to `O(n)` because we only need a subset of values used by in the previous step and don\\'t need to reiterate over any seen value.\\n\\nThe final answer is the max `steps[i]` found.\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int n = nums.size();\\n        stack<int> consumerCandidates;\\n        vector<int> steps(n, 0); // the step at which the ith element will get consumed, will be 0 if it is never consumed.\\n        for (int i=0;i<n;i++) {\\n            int maxStepsBetweenConsumerAndI = 0; // number of steps it took for all the elements between i and the last element > ith element to get consumed \\n            while(!consumerCandidates.empty() && nums[consumerCandidates.top()] <= nums[i]) {\\n                maxStepsBetweenConsumerAndI = max(maxStepsBetweenConsumerAndI, steps[consumerCandidates.top()]);\\n                consumerCandidates.pop();\\n            }\\n            if (!consumerCandidates.empty()) { // does anyone remains to consume i\\n                steps[i] = maxStepsBetweenConsumerAndI + 1;  // steps to consume i are one plus the number of steps to consume everything between i and the last higer element\\n            }\\n            consumerCandidates.push(i);\\n        }\\n        \\n        return *max_element(steps.begin(), steps.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nsteps[i] = {max(steps[k])  for k in consumerCandidates[i] intersection (ri, i)} + 1\\n```\n```\\nThere was atleast one element still existing in (ri,i) at the time when all the elements in (aci, ri] were consumed otherwise ri would have been the one to consume i,\\nso the last element in (aci, i) before i is consumed still lies in (ri,i)\\nmax(steps[k]) for k in (aci, ri] < max(steps[p]) for p in (ri, i) \\n=> steps[i] = {max(steps[k]) for k in consumerCandidates[i-1] intersection (aci, i)} + 1 = {max(steps[k]) for k in consumerCandidates[i-1] intersection (ri, i)} + 1\\n```\n```\\nsteps[i] = {max(steps[k]) for k in consumerCandidates[i-1] intersection (ri, i)} + 1\\n```\n```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int n = nums.size();\\n        stack<int> consumerCandidates;\\n        vector<int> steps(n, 0); // the step at which the ith element will get consumed, will be 0 if it is never consumed.\\n        for (int i=0;i<n;i++) {\\n            int maxStepsBetweenConsumerAndI = 0; // number of steps it took for all the elements between i and the last element > ith element to get consumed \\n            while(!consumerCandidates.empty() && nums[consumerCandidates.top()] <= nums[i]) {\\n                maxStepsBetweenConsumerAndI = max(maxStepsBetweenConsumerAndI, steps[consumerCandidates.top()]);\\n                consumerCandidates.pop();\\n            }\\n            if (!consumerCandidates.empty()) { // does anyone remains to consume i\\n                steps[i] = maxStepsBetweenConsumerAndI + 1;  // steps to consume i are one plus the number of steps to consume everything between i and the last higer element\\n            }\\n            consumerCandidates.push(i);\\n        }\\n        \\n        return *max_element(steps.begin(), steps.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2182454,
                "title": "c-solution-using-stacks",
                "content": "Time complexity is O(n).\\n```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<pair<int,int>>st;\\n        int ans=0,n=nums.size()-1;\\n        st.push({nums[n--],0});\\n        while(n>=0){\\n            int c=0;\\n            while(!st.empty()&&nums[n]>st.top().first){\\n                c=max(c+1,st.top().second);\\n                st.pop();\\n            }\\n            ans=max(ans,c);\\n            st.push({nums[n--],c});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<pair<int,int>>st;\\n        int ans=0,n=nums.size()-1;\\n        st.push({nums[n--],0});\\n        while(n>=0){\\n            int c=0;\\n            while(!st.empty()&&nums[n]>st.top().first){\\n                c=max(c+1,st.top().second);\\n                st.pop();\\n            }\\n            ans=max(ans,c);\\n            st.push({nums[n--],c});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2177346,
                "title": "c-sol-using-monotonic-stack",
                "content": "\\t\\n\\t\\tint i=0;\\n        int n=a.size();\\n        vector<int> v(n);\\n        stack<int> s;\\n        for(i=0;i<n;i++)\\n        {\\n            int x=0;\\n            while(!s.empty() && a[s.top()]<=a[i])\\n            {\\n                if(v[s.top()]>x)\\n                    x=v[s.top()];\\n                s.pop();\\n            }\\n            if(s.empty())\\n                v[i]=0;\\n            else\\n                v[i]=x+1;\\n            s.push(i);\\n        }\\n        int m=0;\\n        for(i=0;i<n;i++)\\n        {\\n            if(v[i]>m)\\n                m=v[i];\\n        }\\n        return m;",
                "solutionTags": [],
                "code": "\\t\\n\\t\\tint i=0;\\n        int n=a.size();\\n        vector<int> v(n);\\n        stack<int> s;\\n        for(i=0;i<n;i++)\\n        {\\n            int x=0;\\n            while(!s.empty() && a[s.top()]<=a[i])\\n            {\\n                if(v[s.top()]>x)\\n                    x=v[s.top()];\\n                s.pop();\\n            }\\n            if(s.empty())\\n                v[i]=0;\\n            else\\n                v[i]=x+1;\\n            s.push(i);\\n        }\\n        int m=0;\\n        for(i=0;i<n;i++)\\n        {\\n            if(v[i]>m)\\n                m=v[i];\\n        }\\n        return m;",
                "codeTag": "Unknown"
            },
            {
                "id": 2163960,
                "title": "java-simple-monostack-o-n",
                "content": "```\\nclass Solution {\\n    \\n    public int totalSteps(int[] nums) {\\n        \\n        int n = nums.length, res = 0;\\n        final Deque<int[]> stack = new LinkedList<>();\\n        stack.push(new int[]{nums[n-1], 0});\\n        \\n        for (int i=n-2; i>=0; --i) {\\n            int count = 0;\\n            while (!stack.isEmpty() && stack.peek()[0] < nums[i]) {\\n                count = Math.max(count + 1, stack.pop()[1]);\\n            }\\n            stack.push(new int[]{nums[i], count});\\n            res = Math.max(res, count);\\n        }\\n        \\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Monotonic Stack"
                ],
                "code": "class Solution {\\n    \\n    public int totalSteps(int[] nums) {\\n        \\n        int n = nums.length, res = 0;\\n        final Deque<int[]> stack = new LinkedList<>();\\n        stack.push(new int[]{nums[n-1], 0}",
                "codeTag": "Java"
            },
            {
                "id": 2160169,
                "title": "java-long-but-intuitive-and-easy-to-understand-solution",
                "content": "2 observations:\\n1) the first number must be kept, so that basically means we start from the first number and scan backward and keep all numbers that are not smaller than the previous number. [5,3,4,4,7,3,6,11,8,5,11] -> [5,7,11,11]\\n2) then all numbers not in the final result ***must*** be removed. to do that we use a stack to keep only decreasing sequence.\\n\\nit\\'s not as simple as those very concise solution but easy to understand.\\n\\n```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        if (null==nums) {\\n            return -1;\\n        } else if (nums.length<=1) {\\n            return 0;\\n        }\\n        List<Integer> l=new ArrayList<Integer>();\\n        int prev=nums[0];\\n        l.add(0);\\n        for (int i=1;i<nums.length;i++) {\\n            if (prev<=nums[i]) {\\n                l.add(i);\\n                prev=nums[i];\\n            }\\n        }\\n        if (l.size()==nums.length) {\\n            return 0;\\n        }\\n        l.add(nums.length);\\n        int result=1;\\n        for (int i=1;i<l.size();i++) {\\n            Stack<int[]> s=new Stack<int[]>();\\n            for (int j=l.get(i-1)+1;j<l.get(i);j++) {\\n                if (s.isEmpty()) {\\n                    s.push(new int[]{nums[j],1});\\n                    continue;\\n                }\\n                int[] top=new int[2];\\n                top[1]=0;\\n                int localtop=0;\\n                while (!s.isEmpty()&&nums[j]>=s.peek()[0]) {\\n                    top=s.pop();\\n                    localtop=Math.max(top[1],localtop);\\n                }\\n                s.push(new int[]{nums[j],localtop+1});\\n                result=Math.max(localtop+1,result);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        if (null==nums) {\\n            return -1;\\n        } else if (nums.length<=1) {\\n            return 0;\\n        }\\n        List<Integer> l=new ArrayList<Integer>();\\n        int prev=nums[0];\\n        l.add(0);\\n        for (int i=1;i<nums.length;i++) {\\n            if (prev<=nums[i]) {\\n                l.add(i);\\n                prev=nums[i];\\n            }\\n        }\\n        if (l.size()==nums.length) {\\n            return 0;\\n        }\\n        l.add(nums.length);\\n        int result=1;\\n        for (int i=1;i<l.size();i++) {\\n            Stack<int[]> s=new Stack<int[]>();\\n            for (int j=l.get(i-1)+1;j<l.get(i);j++) {\\n                if (s.isEmpty()) {\\n                    s.push(new int[]{nums[j],1});\\n                    continue;\\n                }\\n                int[] top=new int[2];\\n                top[1]=0;\\n                int localtop=0;\\n                while (!s.isEmpty()&&nums[j]>=s.peek()[0]) {\\n                    top=s.pop();\\n                    localtop=Math.max(top[1],localtop);\\n                }\\n                s.push(new int[]{nums[j],localtop+1});\\n                result=Math.max(localtop+1,result);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2151244,
                "title": "java-solution-linkedlist-dp",
                "content": "```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        LinkedList<Integer> queue = new LinkedList<>();\\n        int max = 0;\\n        queue.addLast(0);\\n        int[] dp = new int[nums.length];\\n        for(int i =1;i< nums.length;i++){\\n          \\n            while(!queue.isEmpty()&& nums[i] >= nums[queue.peekLast()]){\\n                int idx = queue.pollLast();\\n                dp[i] = Math.max(dp[idx],dp[i]);\\n            }\\n            dp[i] = queue.isEmpty()? 0 : dp[i]+1;\\n            queue.addLast(i);\\n\\n            max = Math.max(max,dp[i]);\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        LinkedList<Integer> queue = new LinkedList<>();\\n        int max = 0;\\n        queue.addLast(0);\\n        int[] dp = new int[nums.length];\\n        for(int i =1;i< nums.length;i++){\\n          \\n            while(!queue.isEmpty()&& nums[i] >= nums[queue.peekLast()]){\\n                int idx = queue.pollLast();\\n                dp[i] = Math.max(dp[idx],dp[i]);\\n            }\\n            dp[i] = queue.isEmpty()? 0 : dp[i]+1;\\n            queue.addLast(i);\\n\\n            max = Math.max(max,dp[i]);\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139690,
                "title": "why-count-math-max-count-1-stk-peek-value",
                "content": "We start from ending, But how did we concluded that Math.max(count+1, stk.peek().value) will handle both cases where previous index\\'s value is to be included or not?\\n \\n\\n",
                "solutionTags": [],
                "code": "We start from ending, But how did we concluded that Math.max(count+1, stk.peek().value) will handle both cases where previous index\\'s value is to be included or not?\\n \\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2132225,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        stack = []\\n        dp = [0]*len(nums)\\n        for i in range(len(nums)-1,-1,-1):\\n            while stack and nums[i] > nums[stack[-1]]:\\n                dp[i] = max(dp[i]+1, dp[stack.pop()])\\n            stack.append(i)\\n        return max(dp)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        stack = []\\n        dp = [0]*len(nums)\\n        for i in range(len(nums)-1,-1,-1):\\n            while stack and nums[i] > nums[stack[-1]]:\\n                dp[i] = max(dp[i]+1, dp[stack.pop()])\\n            stack.append(i)\\n        return max(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2128593,
                "title": "python3-stack-with-explanation",
                "content": "```\\ndef totalSteps(self, nums: List[int]) -> int:\\n        stack = []\\n        # stack tracks [the number value nums[0], the rounds to remove the element]\\n        stack.append([nums[0],0])\\n        \\n        # use l to track the length of stack\\n        l = 1\\n        \\n        # initiate answer with 0 step\\n        ans = 0\\n        \\n        # loop through the array        \\n        for i in range(1,len(nums)):\\n            count = 1\\n            while l>0:\\n                # if nums[i] is greater than or equal to numbers in stack, \\n                # count is the max of (rounds of the number gets removed + 1, count)\\n                if stack[l-1][0]<=nums[i]:\\n                    count = max(count, stack[l-1][1]+1)\\n                    stack.pop()\\n                    l -= 1\\n                else:\\n                    ans = count if ans<count else ans\\n                    break\\n            stack.append([nums[i],count])\\n            l += 1\\n            \\n        return ans",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef totalSteps(self, nums: List[int]) -> int:\\n        stack = []\\n        # stack tracks [the number value nums[0], the rounds to remove the element]\\n        stack.append([nums[0],0])\\n        \\n        # use l to track the length of stack\\n        l = 1\\n        \\n        # initiate answer with 0 step\\n        ans = 0\\n        \\n        # loop through the array        \\n        for i in range(1,len(nums)):\\n            count = 1\\n            while l>0:\\n                # if nums[i] is greater than or equal to numbers in stack, \\n                # count is the max of (rounds of the number gets removed + 1, count)\\n                if stack[l-1][0]<=nums[i]:\\n                    count = max(count, stack[l-1][1]+1)\\n                    stack.pop()\\n                    l -= 1\\n                else:\\n                    ans = count if ans<count else ans\\n                    break\\n            stack.append([nums[i],count])\\n            l += 1\\n            \\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 2114774,
                "title": "simple-stack-with-previous-greater-element",
                "content": "```\\nint totalSteps(vector<int>& nums) {\\n        \\n        // store just previous greater element for each number with its distance.(note we use max steps till  //       now as distance measure) \\n        // this way we know in how many steps will it be removed. \\n        // find max of all these steps/\\n        // 10 1 2  6 1 2 3 4 \\n        //. 0 1 2 \\xA03 1 2 3 4\\n        \\n        stack<pair<int,int>> st;\\n        int n=nums.size();\\n        int pge[n];\\n        st.push({nums[0],0});\\n        pge[0]=0;\\n        for(int i=1;i<n;i++){\\n           if(st.empty()){\\n               st.push({nums[i],i});\\n               pge[i]=0;\\n           }\\n          else{\\n             // pair<int,int> p=st.top();\\n              int maxpge=0;\\n             while(!st.empty() and st.top().first<= nums[i]){\\n                 maxpge=max(pge[st.top().second],maxpge);\\n                 st.pop();\\n             }\\n             if(!st.empty()){\\n                 pge[i]= maxpge+1;\\n             }\\n             else pge[i]=0;\\n             st.push({nums[i],i});\\n          }\\n        }\\n        \\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            ans=max(ans,pge[i]);\\n            // cout<<pge[i]<<\" \";\\n        }\\n        // cout<<\"\\\\n\";\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint totalSteps(vector<int>& nums) {\\n        \\n        // store just previous greater element for each number with its distance.(note we use max steps till  //       now as distance measure) \\n        // this way we know in how many steps will it be removed. \\n        // find max of all these steps/\\n        // 10 1 2  6 1 2 3 4 \\n        //. 0 1 2 \\xA03 1 2 3 4\\n        \\n        stack<pair<int,int>> st;\\n        int n=nums.size();\\n        int pge[n];\\n        st.push({nums[0],0});\\n        pge[0]=0;\\n        for(int i=1;i<n;i++){\\n           if(st.empty()){\\n               st.push({nums[i],i});\\n               pge[i]=0;\\n           }\\n          else{\\n             // pair<int,int> p=st.top();\\n              int maxpge=0;\\n             while(!st.empty() and st.top().first<= nums[i]){\\n                 maxpge=max(pge[st.top().second],maxpge);\\n                 st.pop();\\n             }\\n             if(!st.empty()){\\n                 pge[i]= maxpge+1;\\n             }\\n             else pge[i]=0;\\n             st.push({nums[i],i});\\n          }\\n        }\\n        \\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            ans=max(ans,pge[i]);\\n            // cout<<pge[i]<<\" \";\\n        }\\n        // cout<<\"\\\\n\";\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2108740,
                "title": "c-bfs-based-simulation",
                "content": "simulation says: \\n* \\ttake each number as centers who are eating their next element \\n* \\tin each step check weather it eats it\\'s next element. \\n\\t* if YES : then increase it\\'s size telling who should be checked in next iteration for eating\\n\\t* else : just remove it from iteration \\n* terminate when there is no center for eating left \\n**IMPORTANT** : we are triversing centers in reverse order because each number can eat it\\'s next element so condition like 11 8 5, where 8 eats 5 and 11 eats 8 in single iteration can be covered \\n```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int n = nums.size(); \\n        vector<int> res; \\n        for(int i=n-1;i>=0;i-=1){\\n            res.push_back(i); \\n        }\\n        vector<int> size(n,1); \\n        int ans = -1; \\n        while(res.size()){\\n            vector<int>tp; \\n            for(auto &i: res){\\n                if(i+size[i] < n and nums[i + size[i]] < nums[i]){\\n                    // it\\'s eaten if present in queue remove it \\n                    if(tp.size() and tp.back() == i + size[i]) tp.pop_back(); \\n                    size[i] += size[i+size[i]];\\n                    tp.push_back(i); // inserting index who has eaten in this iteration \\n                }\\n            }\\n            swap(res,tp); \\n            ans += 1; \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int n = nums.size(); \\n        vector<int> res; \\n        for(int i=n-1;i>=0;i-=1){\\n            res.push_back(i); \\n        }\\n        vector<int> size(n,1); \\n        int ans = -1; \\n        while(res.size()){\\n            vector<int>tp; \\n            for(auto &i: res){\\n                if(i+size[i] < n and nums[i + size[i]] < nums[i]){\\n                    // it\\'s eaten if present in queue remove it \\n                    if(tp.size() and tp.back() == i + size[i]) tp.pop_back(); \\n                    size[i] += size[i+size[i]];\\n                    tp.push_back(i); // inserting index who has eaten in this iteration \\n                }\\n            }\\n            swap(res,tp); \\n            ans += 1; \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2108067,
                "title": "steps-to-make-array-non-decreasing",
                "content": "why am i getting runtime error in my code ?\\n\\n\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        long long int count=0;\\n        while(true)\\n        {\\n            \\n        \\n            int a = nums[0];\\n            int c=0;\\n            for(auto it=nums.begin()+1;it!=nums.end();it++)\\n            {\\n                \\n                if(a>(*it))\\n                {\\n                    nums.erase(it);\\n                    c++;\\n                }\\n                \\n                a=(*it);\\n            }\\n            if(c==0)\\n              break;\\n            count++;\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        long long int count=0;\\n        while(true)\\n        {\\n            \\n        \\n            int a = nums[0];\\n            int c=0;\\n            for(auto it=nums.begin()+1;it!=nums.end();it++)\\n            {\\n                \\n                if(a>(*it))\\n                {\\n                    nums.erase(it);\\n                    c++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2098755,
                "title": "still-stack-but-could-be-more-straight-forward-no-reverse",
                "content": "Let start from the first element, let say `j` is the index of the neareset element that is greater than `nums[0]`, we know that any element in the range `(i,j)` would be removed in the en. We notice that any element would be discarded by its **previous greater element `k`** .The time an element would be discarded would be 1 + the maximum discared time of the elements among it and the k-index element . A monotoic stack is required to find the previous greater element, each time an element is poped out, update the maximum discard time by the discarded time of the poped element (These elements must be removed first otherwise the current element would not get a chance to be removed). Repeat this process until we visit all element then we would find the answer.\\n\\n```python\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        i = res = 0 \\n        while i < len(nums):\\n            j = i + 1\\n            stack = []\\n            while j < len(nums) and nums[j] < nums[i]:\\n                time = 0\\n                while stack and stack[-1][0] <= nums[j]:\\n                    time = max(time, stack.pop()[1])\\n                stack.append((nums[j], time+1))\\n                res = max(res, time+1)\\n                j += 1\\n            i = j\\n        return res \\n ```\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        i = res = 0 \\n        while i < len(nums):\\n            j = i + 1\\n            stack = []\\n            while j < len(nums) and nums[j] < nums[i]:\\n                time = 0\\n                while stack and stack[-1][0] <= nums[j]:\\n                    time = max(time, stack.pop()[1])\\n                stack.append((nums[j], time+1))\\n                res = max(res, time+1)\\n                j += 1\\n            i = j\\n        return res \\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2098565,
                "title": "easy-faster-efficient-java-soln",
                "content": "```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        Stack<int [] > st = new Stack<>();\\n        int ans = 0;\\n        for(int i = nums.length - 1; i >= 0; i--){\\n            int num = nums[i];\\n            int count = 0;\\n            while(!st.isEmpty() && st.peek()[0] < num){\\n                int [] rem = st.pop();\\n                count = Math.max(count + 1, rem[1]);\\n            }\\n            int [] arr = new int[2];\\n            arr[0] = num;\\n            arr[1] = count;\\n            st.push(arr);\\n            ans = Math.max(ans, count);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        Stack<int [] > st = new Stack<>();\\n        int ans = 0;\\n        for(int i = nums.length - 1; i >= 0; i--){\\n            int num = nums[i];\\n            int count = 0;\\n            while(!st.isEmpty() && st.peek()[0] < num){\\n                int [] rem = st.pop();\\n                count = Math.max(count + 1, rem[1]);\\n            }\\n            int [] arr = new int[2];\\n            arr[0] = num;\\n            arr[1] = count;\\n            st.push(arr);\\n            ans = Math.max(ans, count);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2098249,
                "title": "c-easy-solution-stacks",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<pair<int,int>>st;\\n        int ans =0;\\n        st.push({nums[nums.size()-1],0});\\n        for(int i=nums.size()-2;i>=0;i--)\\n        {\\n            int t =0;\\n            while(!st.empty() && nums[i]>st.top().first)\\n            {\\n                t++;\\n                t = max(t,st.top().second);\\n                st.pop();\\n            }\\n            ans = max(ans,t);\\n            st.push({nums[i],t});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<pair<int,int>>st;\\n        int ans =0;\\n        st.push({nums[nums.size()-1],0});\\n        for(int i=nums.size()-2;i>=0;i--)\\n        {\\n            int t =0;\\n            while(!st.empty() && nums[i]>st.top().first)\\n            {\\n                t++;\\n                t = max(t,st.top().second);\\n                st.pop();\\n            }\\n            ans = max(ans,t);\\n            st.push({nums[i],t});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2097777,
                "title": "simple-c-code",
                "content": "# **(upvote)If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<pair<int,int>> StepOne;\\n        int ans = 0;\\n        int sz = nums.size();\\n        for(int i = sz-1; i >= 0; i--)\\n        {\\n            int cnt = 0;\\n            while(!StepOne.empty() && StepOne.top().first < nums[i])\\n            {\\n                if(StepOne.top().second == 0)\\n                {\\n                    cnt++;\\n                }\\n                else if(StepOne.top().second != 0)\\n                {\\n                    if(StepOne.top().second > cnt)\\n                    {\\n                        cnt += StepOne.top().second - cnt;\\n                    }\\n                    else\\n                    {\\n                        cnt += 1;\\n                    }\\n                }\\n                StepOne.pop();\\n            }\\n            StepOne.push({nums[i],cnt});\\n            ans = max(cnt,ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<pair<int,int>> StepOne;\\n        int ans = 0;\\n        int sz = nums.size();\\n        for(int i = sz-1; i >= 0; i--)\\n        {\\n            int cnt = 0;\\n            while(!StepOne.empty() && StepOne.top().first < nums[i])\\n            {\\n                if(StepOne.top().second == 0)\\n                {\\n                    cnt++;\\n                }\\n                else if(StepOne.top().second != 0)\\n                {\\n                    if(StepOne.top().second > cnt)\\n                    {\\n                        cnt += StepOne.top().second - cnt;\\n                    }\\n                    else\\n                    {\\n                        cnt += 1;\\n                    }\\n                }\\n                StepOne.pop();\\n            }\\n            StepOne.push({nums[i],cnt});\\n            ans = max(cnt,ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2097552,
                "title": "c-solution",
                "content": "```\\nvoid next(int* nums, int numsSize, int k, int* i, int time){\\n    int now = 0;\\n    *i += 1;\\n    while( *i < numsSize ){\\n        if (k > nums[*i]){\\n            now++;\\n            next( nums, numsSize, nums[*i], i, now);\\n            if (now == time){\\n                return;\\n            }\\n        } else {\\n            return;\\n        }\\n    }\\n}\\n\\nint totalSteps(int* nums, int numsSize){\\n    int ans = 0;\\n    int time = 0;\\n    int k = nums[0];\\n    int i = 1;\\n    while( i < numsSize ){\\n        if (k > nums[i]){\\n            time++;\\n            next(nums, numsSize, nums[i], &i, time);\\n        } else {\\n            if (time > ans){\\n                ans = time;\\n            }\\n            time = 0;\\n            k = nums[i];\\n            i++;\\n        }\\n    }\\n    if (time > ans){\\n        ans = time;\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid next(int* nums, int numsSize, int k, int* i, int time){\\n    int now = 0;\\n    *i += 1;\\n    while( *i < numsSize ){\\n        if (k > nums[*i]){\\n            now++;\\n            next( nums, numsSize, nums[*i], i, now);\\n            if (now == time){\\n                return;\\n            }\\n        } else {\\n            return;\\n        }\\n    }\\n}\\n\\nint totalSteps(int* nums, int numsSize){\\n    int ans = 0;\\n    int time = 0;\\n    int k = nums[0];\\n    int i = 1;\\n    while( i < numsSize ){\\n        if (k > nums[i]){\\n            time++;\\n            next(nums, numsSize, nums[i], &i, time);\\n        } else {\\n            if (time > ans){\\n                ans = time;\\n            }\\n            time = 0;\\n            k = nums[i];\\n            i++;\\n        }\\n    }\\n    if (time > ans){\\n        ans = time;\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2096226,
                "title": "java-faster-than-100-less-than-85-47",
                "content": "```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        int max = 0;\\n        int[] pos = new int[nums.length+1];\\n        int[] steps = new int[nums.length+1];\\n        int top = -1;\\n        for (int i = 0; i <= nums.length; i++) {\\n            int val = i == nums.length ? Integer.MAX_VALUE : nums[i];\\n            while (top >= 0 && nums[pos[top]] <= val) {\\n                if (top == 0) max = Math.max(max, steps[pos[top--]]);\\n                else steps[pos[--top]] = Math.max(steps[pos[top]]+1, steps[pos[top+1]]);\\n            }\\n            pos[++top] = i;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        int max = 0;\\n        int[] pos = new int[nums.length+1];\\n        int[] steps = new int[nums.length+1];\\n        int top = -1;\\n        for (int i = 0; i <= nums.length; i++) {\\n            int val = i == nums.length ? Integer.MAX_VALUE : nums[i];\\n            while (top >= 0 && nums[pos[top]] <= val) {\\n                if (top == 0) max = Math.max(max, steps[pos[top--]]);\\n                else steps[pos[--top]] = Math.max(steps[pos[top]]+1, steps[pos[top+1]]);\\n            }\\n            pos[++top] = i;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2095558,
                "title": "solution-using-stack-dp-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int ans=0,n=nums.size();\\n        vector<int>dp(n,0);  // keeping track of the smaller elements to a element to its right\\n        stack<int>stk;\\n        for(int i=n-1;i>=0;i--){\\n            while(!stk.empty() && nums[i]>nums[stk.top()]){\\n                dp[i] = max(++dp[i],dp[stk.top()]);\\n                stk.pop();\\n                ans = max(ans,dp[i]);\\n            }\\n            stk.push(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        int ans=0,n=nums.size();\\n        vector<int>dp(n,0);  // keeping track of the smaller elements to a element to its right\\n        stack<int>stk;\\n        for(int i=n-1;i>=0;i--){\\n            while(!stk.empty() && nums[i]>nums[stk.top()]){\\n                dp[i] = max(++dp[i],dp[stk.top()]);\\n                stk.pop();\\n                ans = max(ans,dp[i]);\\n            }\\n            stk.push(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2095306,
                "title": "java-stack",
                "content": "```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        int n = nums.length;\\n        int[] steps = new int[n];\\n        int ans = 0;\\n        Deque<Integer> deque = new ArrayDeque<>();\\n        for(int i = 0; i < nums.length; i++) {\\n            int maxSteps = 0;\\n            while(!deque.isEmpty() && (nums[deque.peekLast()] <= nums[i])) {\\n                int index = deque.removeLast();\\n                maxSteps = Math.max(maxSteps, steps[index]);\\n            }\\n            \\n            if(deque.isEmpty()) maxSteps = 0;\\n            else maxSteps += 1;\\n            steps[i] = maxSteps;\\n            deque.offerLast(i);\\n            ans = Math.max(ans, maxSteps);\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int totalSteps(int[] nums) {\\n        int n = nums.length;\\n        int[] steps = new int[n];\\n        int ans = 0;\\n        Deque<Integer> deque = new ArrayDeque<>();\\n        for(int i = 0; i < nums.length; i++) {\\n            int maxSteps = 0;\\n            while(!deque.isEmpty() && (nums[deque.peekLast()] <= nums[i])) {\\n                int index = deque.removeLast();\\n                maxSteps = Math.max(maxSteps, steps[index]);\\n            }\\n            \\n            if(deque.isEmpty()) maxSteps = 0;\\n            else maxSteps += 1;\\n            steps[i] = maxSteps;\\n            deque.offerLast(i);\\n            ans = Math.max(ans, maxSteps);\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2093897,
                "title": "segment-tree-java-o-n-log-n",
                "content": "```\\nclass Solution {\\n    int[] tree;\\n    void update(int[] tree, int idx, int l, int r, int i, int v){\\n        if(l==r){\\n            tree[idx]=v;\\n            return ;\\n        }\\n        int mid = (l+r)/2;\\n        if(i<=mid){\\n            update(tree,idx*2+1, l, mid, i, v);\\n        } else {\\n            update(tree, idx*2+2,mid+1,r,i,v);\\n        }\\n        tree[idx]=Math.max(tree[idx*2+1],tree[idx*2+2]);\\n    }\\n    int query(int[] tree, int idx, int l, int r, int ql, int qr){\\n        if(ql<=l && qr>=r){\\n            return tree[idx];\\n        }\\n        int max = 0;\\n        int mid = (l+r)/2;\\n        if(ql<=mid){\\n            max=Math.max(max,query(tree,idx*2+1,l,mid,ql,qr));\\n        }\\n        if(qr>mid){\\n            max=Math.max(max,query(tree,idx*2+2,mid+1,r,ql,qr));\\n        }\\n        return max;\\n    }\\n    public int totalSteps(int[] nums) {\\n        int n = nums.length;\\n        int leaves = (Integer.highestOneBit(n)==n) ? n : (Integer.highestOneBit(n)<<1); //next power of 2\\n        tree = new int[n*4];\\n        Stack<Integer> stack = new Stack<>();\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            while(!stack.isEmpty() && nums[stack.peek()]<=nums[i]){\\n                stack.pop();\\n            }\\n            if(!stack.isEmpty()){\\n                int steps = 1;\\n                if((i-stack.peek())>1){\\n                    steps = Math.max(steps,query(tree,0,0,leaves-1,stack.peek()+1,i-1)+1);\\n                }\\n                update(tree,0,0,leaves-1,i,steps);\\n                ans = Math.max(ans,steps);\\n            }\\n            stack.push(i);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Stack",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    int[] tree;\\n    void update(int[] tree, int idx, int l, int r, int i, int v){\\n        if(l==r){\\n            tree[idx]=v;\\n            return ;\\n        }\\n        int mid = (l+r)/2;\\n        if(i<=mid){\\n            update(tree,idx*2+1, l, mid, i, v);\\n        } else {\\n            update(tree, idx*2+2,mid+1,r,i,v);\\n        }\\n        tree[idx]=Math.max(tree[idx*2+1],tree[idx*2+2]);\\n    }\\n    int query(int[] tree, int idx, int l, int r, int ql, int qr){\\n        if(ql<=l && qr>=r){\\n            return tree[idx];\\n        }\\n        int max = 0;\\n        int mid = (l+r)/2;\\n        if(ql<=mid){\\n            max=Math.max(max,query(tree,idx*2+1,l,mid,ql,qr));\\n        }\\n        if(qr>mid){\\n            max=Math.max(max,query(tree,idx*2+2,mid+1,r,ql,qr));\\n        }\\n        return max;\\n    }\\n    public int totalSteps(int[] nums) {\\n        int n = nums.length;\\n        int leaves = (Integer.highestOneBit(n)==n) ? n : (Integer.highestOneBit(n)<<1); //next power of 2\\n        tree = new int[n*4];\\n        Stack<Integer> stack = new Stack<>();\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            while(!stack.isEmpty() && nums[stack.peek()]<=nums[i]){\\n                stack.pop();\\n            }\\n            if(!stack.isEmpty()){\\n                int steps = 1;\\n                if((i-stack.peek())>1){\\n                    steps = Math.max(steps,query(tree,0,0,leaves-1,stack.peek()+1,i-1)+1);\\n                }\\n                update(tree,0,0,leaves-1,i,steps);\\n                ans = Math.max(ans,steps);\\n            }\\n            stack.push(i);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2093723,
                "title": "c-stack-segment-tree-explanation",
                "content": "It\\'s easy to figure out that if a[i] not in the final non-descending array, it should be erase after some smaller values between previous larger value of a[i], let called b, [b+1, i-1]\\n\\nFor example:\\n```\\n[3, 5, 7, 15, 13, 12, 14]\\n\\nround1:\\n[3, 5, 7, 15, 14]\\n\\nround2:\\n[3, 5, 7, 15]\\n\\n-\\n\\nanother case\\n[3, 5, 7, 15, 12, 13, 14]\\n\\nround1:\\n[3, 5, 7, 15, 13, 14]\\n\\nround2:\\n[3, 5, 7, 15, 14]\\n\\nround3:\\n[3, 5, 7, 15]\\n```\\n14 is removed after 13 and 12, that the value between previous larger value to current one\\nwe don\\'t care who was removed first\\nthe solution will be max([prevLargerIndex+1, current-1]) + 1\\n\\n- range query max could be solved by segment tree\\n- and previous larger index could be solved by strictly monotonic decreasing stack\\n\\nThe corner case is that, if there have a descending in array, there must has at least 1 operation\\nHow to check it? => Just use `previousGreater` to check it\\n- answer for position i will be `max(max([prevLargerIndex+1, current-1]+1, 1))`\\n\\nand after calculating value of position i, we need to update the result to segment tree for further calculation\\n\\nHere is the solution\\n```\\nconst int nax = 1e5+5;\\nclass Solution {\\npublic:    \\n    int node[nax*4+5];\\n    int lazy[nax*4+5];\\n    \\n    void push(int lo, int hi, int idx) {\\n        if (lazy[idx] == 0) return;\\n        node[idx] = lazy[idx];\\n\\n        // push to childrens\\n        if (lo != hi) {\\n            lazy[2*idx+1] = lazy[idx];\\n            lazy[2*idx+2] = lazy[idx];\\n        }\\n        \\n        lazy[idx] = 0;\\n    }\\n    \\n    void pull(int idx) {\\n        node[idx] = max(node[2*idx+1], node[2*idx+2]);\\n    }\\n    \\n    void upd(int us, int ue, int lo, int hi, int val, int idx = 0) {\\n        push(lo, hi, idx);\\n\\n        if (us > hi || ue < lo) return;\\n\\n        // in range\\n        if (lo >= us && hi <= ue) {\\n            lazy[idx] = val;\\n            push(lo, hi, idx);\\n            return;\\n        }\\n\\n        int mid = (lo + hi)/2;\\n        upd(us, ue, lo, mid, val, 2*idx+1);\\n        upd(us, ue, mid+1, hi, val, 2*idx+2);\\n        pull(idx);\\n    }\\n    \\n    int query(int qs, int qe, int lo = 0, int hi = -1, int idx = 0) {\\n        push(lo, hi, idx);\\n\\n        if (hi < qs || lo > qe) return 0;\\n        if (lo >= qs && hi <= qe) return node[idx];\\n        int mid = (lo + hi)/2;\\n        return max(query(qs, qe, lo, mid, 2*idx+1),\\n                query(qs, qe, mid+1, hi, 2*idx+2));\\n    }\\n    \\n    int totalSteps(vector<int>& a) {\\n        int n = a.size();\\n        \\n        memset(node, 0, sizeof(node));\\n        memset(lazy, 0, sizeof(lazy));\\n        \\n        // previous greater and equal\\n        vector<int> prevGreater(n);\\n        stack<pair<int, int>> st;\\n        st.push(make_pair(1e9+5, -1));\\n        for (int i = 0; i < n; i++) {\\n            while (!st.empty() && st.top().first <= a[i])\\n                st.pop();\\n            prevGreater[i] = st.top().second;\\n            st.push(make_pair(a[i], i));\\n        }\\n        \\n        int ans = 0;\\n        for (int i = 1; i < n; i++) {\\n            int idx = prevGreater[i];\\n            \\n            // greatest value so far\\n            if (idx < 0) continue;\\n            int res = query(idx+1, i-1, 0, n-1);\\n            res = max(res+1, 1);\\n            upd(i, i, 0, n-1, res);\\n            ans = max(ans, res);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nT: O(NlogN + N)\\nS: O(N)",
                "solutionTags": [
                    "Stack",
                    "Tree"
                ],
                "code": "```\\n[3, 5, 7, 15, 13, 12, 14]\\n\\nround1:\\n[3, 5, 7, 15, 14]\\n\\nround2:\\n[3, 5, 7, 15]\\n\\n-\\n\\nanother case\\n[3, 5, 7, 15, 12, 13, 14]\\n\\nround1:\\n[3, 5, 7, 15, 13, 14]\\n\\nround2:\\n[3, 5, 7, 15, 14]\\n\\nround3:\\n[3, 5, 7, 15]\\n```\n```\\nconst int nax = 1e5+5;\\nclass Solution {\\npublic:    \\n    int node[nax*4+5];\\n    int lazy[nax*4+5];\\n    \\n    void push(int lo, int hi, int idx) {\\n        if (lazy[idx] == 0) return;\\n        node[idx] = lazy[idx];\\n\\n        // push to childrens\\n        if (lo != hi) {\\n            lazy[2*idx+1] = lazy[idx];\\n            lazy[2*idx+2] = lazy[idx];\\n        }\\n        \\n        lazy[idx] = 0;\\n    }\\n    \\n    void pull(int idx) {\\n        node[idx] = max(node[2*idx+1], node[2*idx+2]);\\n    }\\n    \\n    void upd(int us, int ue, int lo, int hi, int val, int idx = 0) {\\n        push(lo, hi, idx);\\n\\n        if (us > hi || ue < lo) return;\\n\\n        // in range\\n        if (lo >= us && hi <= ue) {\\n            lazy[idx] = val;\\n            push(lo, hi, idx);\\n            return;\\n        }\\n\\n        int mid = (lo + hi)/2;\\n        upd(us, ue, lo, mid, val, 2*idx+1);\\n        upd(us, ue, mid+1, hi, val, 2*idx+2);\\n        pull(idx);\\n    }\\n    \\n    int query(int qs, int qe, int lo = 0, int hi = -1, int idx = 0) {\\n        push(lo, hi, idx);\\n\\n        if (hi < qs || lo > qe) return 0;\\n        if (lo >= qs && hi <= qe) return node[idx];\\n        int mid = (lo + hi)/2;\\n        return max(query(qs, qe, lo, mid, 2*idx+1),\\n                query(qs, qe, mid+1, hi, 2*idx+2));\\n    }\\n    \\n    int totalSteps(vector<int>& a) {\\n        int n = a.size();\\n        \\n        memset(node, 0, sizeof(node));\\n        memset(lazy, 0, sizeof(lazy));\\n        \\n        // previous greater and equal\\n        vector<int> prevGreater(n);\\n        stack<pair<int, int>> st;\\n        st.push(make_pair(1e9+5, -1));\\n        for (int i = 0; i < n; i++) {\\n            while (!st.empty() && st.top().first <= a[i])\\n                st.pop();\\n            prevGreater[i] = st.top().second;\\n            st.push(make_pair(a[i], i));\\n        }\\n        \\n        int ans = 0;\\n        for (int i = 1; i < n; i++) {\\n            int idx = prevGreater[i];\\n            \\n            // greatest value so far\\n            if (idx < 0) continue;\\n            int res = query(idx+1, i-1, 0, n-1);\\n            res = max(res+1, 1);\\n            upd(i, i, 0, n-1, res);\\n            ans = max(ans, res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2093264,
                "title": "simple-efficient-solution",
                "content": "```\\ntypedef long long ll;\\ntypedef long double ld;\\ntypedef vector<ll> vi;\\n#define endl \\'\\\\n\\'\\n#define tn TreeNode\\n#define ln ListNode\\nconst ll mod = 1e9;\\n\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& v) {\\n        ll sz = v.size();\\n        stack<pair<ll, ll>>st;\\n        ll res = 0;\\n        for (ll i = sz - 1;i > -1;--i) {\\n            ll cnt = 0;\\n            while (!st.empty() && st.top().first < v[i]) {\\n                cnt = max(cnt + 1, st.top().second);\\n                st.pop();\\n            }\\n            res = max(res, cnt);\\n            st.push({ v[i], cnt });\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\ntypedef long long ll;\\ntypedef long double ld;\\ntypedef vector<ll> vi;\\n#define endl \\'\\\\n\\'\\n#define tn TreeNode\\n#define ln ListNode\\nconst ll mod = 1e9;\\n\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& v) {\\n        ll sz = v.size();\\n        stack<pair<ll, ll>>st;\\n        ll res = 0;\\n        for (ll i = sz - 1;i > -1;--i) {\\n            ll cnt = 0;\\n            while (!st.empty() && st.top().first < v[i]) {\\n                cnt = max(cnt + 1, st.top().second);\\n                st.pop();\\n            }\\n            res = max(res, cnt);\\n            st.push({ v[i], cnt });\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2092472,
                "title": "javascript-monotonic-stack-dp",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar totalSteps = function (nums) {\\n  let ans = 0;\\n  const n = nums.length;\\n  const stack = [];\\n  const dp = new Array(n).fill(0);\\n\\n  for (let i = n - 1; i >= 0; i--) {\\n    while (stack.length > 0 && nums[i] > nums[stack[stack.length - 1]]) {\\n      const j = stack.pop();\\n      dp[i] = Math.max(dp[i] + 1, dp[j]);\\n      ans = Math.max(ans, dp[i]);\\n    }\\n    stack.push(i);\\n  }\\n\\n  return ans;\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Monotonic Stack"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar totalSteps = function (nums) {\\n  let ans = 0;\\n  const n = nums.length;\\n  const stack = [];\\n  const dp = new Array(n).fill(0);\\n\\n  for (let i = n - 1; i >= 0; i--) {\\n    while (stack.length > 0 && nums[i] > nums[stack[stack.length - 1]]) {\\n      const j = stack.pop();\\n      dp[i] = Math.max(dp[i] + 1, dp[j]);\\n      ans = Math.max(ans, dp[i]);\\n    }\\n    stack.push(i);\\n  }\\n\\n  return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2092296,
                "title": "no-reverse-mono-stack",
                "content": "```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        i = 0\\n        ans = 0\\n        while i < n:\\n            j = i + 1\\n            while j < n and nums[j] < nums[i]:\\n                j += 1\\n            # find the interval in which all the num smaller than left side nums[i]\\n            # maintain the descresing stack [a, b, c, d]\\n            # when comes e and (b, c, d) <= e, the cost to remove e is max(b, c, d) + 1\\n            st = []\\n            for k in range(i + 1, j):\\n                t = 0\\n                while st and st[-1][0] <= nums[k]:\\n                    _, tmp = st.pop()\\n                    t = max(t, tmp)\\n                t += 1\\n                st.append((nums[k], t))\\n                ans = max(ans, t)\\n            i = j\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution:\\n    def totalSteps(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        i = 0\\n        ans = 0\\n        while i < n:\\n            j = i + 1\\n            while j < n and nums[j] < nums[i]:\\n                j += 1\\n            # find the interval in which all the num smaller than left side nums[i]\\n            # maintain the descresing stack [a, b, c, d]\\n            # when comes e and (b, c, d) <= e, the cost to remove e is max(b, c, d) + 1\\n            st = []\\n            for k in range(i + 1, j):\\n                t = 0\\n                while st and st[-1][0] <= nums[k]:\\n                    _, tmp = st.pop()\\n                    t = max(t, tmp)\\n                t += 1\\n                st.append((nums[k], t))\\n                ans = max(ans, t)\\n            i = j\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565314,
                "content": [
                    {
                        "username": "DolphinsAtDaybreak",
                        "content": "**EDIT: They\\'ve fixed the hints now!**\\n\\nI got to the idea of monotonic stack during the contest but didn\\'t quite figure out the final algorithm.  Looking at the hints now I see:\\n\\nHint 3\\nConsider an element at index i. Say there exists a strictly greater element to its left, and the closest one is located at index j (i.e. there is no index k such that j < k < i and nums[k] > nums[i]). The number of rounds required to remove nums[i] is i - j.\\n\\nHow does that work?  If we have an array [6,5,4,3,2,1,5] -- shouldn\\'t it take 2 rounds to remove the 5, not i-j=6 rounds?\\n\\n"
                    },
                    {
                        "username": "Taranovski",
                        "content": "leetcode, forget about \"medium\" rating for anything monolithic stack, it is extremely non-intuitive and \"jumping through the hoops\", set the realistic \"hard\" rating for it!\\nExtremely confusing \"pattern\" of the solution, be real!"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "great question but should be hard"
                    },
                    {
                        "username": "XeBaGac",
                        "content": "Time Limit Exceeded with TC 79, i don\\'t know how to make my code quicker :((("
                    },
                    {
                        "username": "Flankerr",
                        "content": "can someone please explain how this array is completed in 1 step.\\n\\naccording to my calculation\\noriginal [10,6,5,10,15]\\n1st step [10,5,10,15]\\n2nd step [10,10,15]"
                    },
                    {
                        "username": "XeBaGac",
                        "content": "in step1 u erase both 6 and 5 because  6>5 . Therefore, the result is 10,10,15\\n"
                    },
                    {
                        "username": "prashantkumarrai8",
                        "content": "1st we remove 5 bcz of 6 and then 6 bcz of 10"
                    },
                    {
                        "username": "shhattali2002",
                        "content": "[@Gyaneswar Singh](/Flankerr) don't delete the integer directly first check out the index elements that satisfy given condition ( nums[i]<nums[i-1] ) than go for deletion.\neg. original [10,6,5,10,15]\nHere index 1,2 satisfy the condition than delete them it will take 1 step.\n\neg. Original [5,3,4,4,7,3,6,11,8,5,11]\nHere index 1,5,8,9 satisfy hence step 1.\n[5,4,4,7,6,11,11]\nIn step 2 index 1,4 satisfy condition\n[5,4,4,7,11,11]\nIn step 3 index 1 satisfy condition\n[5,7,11,11]\n"
                    },
                    {
                        "username": "aaks-ctrl",
                        "content": "Can someone tell me where an I going wrong with my approach ?\\n \\n `\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<int> c;\\n        int ans{};\\n        int steps{};\\n        while(nums.size()){\\n            int last=nums.back();\\n            nums.pop_back();\\n            int i{};\\n            while(c.size() && last>c.top()){\\n                c.pop();\\n                i++;\\n            }\\n            ans=max(i,ans);\\n            c.push(last);\\n        }\\n        return ans;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "2uringTested",
                        "content": "i would\\'ve tried if it was written in a coding language...\\n\\n/s .... try writing a bit readable code."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "For the test case\\n\\n[5,1,2,3,4]\\n\\nJust removing 5 in the start would make it [1,2,3,4] which is a Non Decreasing Array . \\n\\nSo number of steps needed is \\'1\\' . But the solution expected is 4 . Am i missing something ? \\n\\nThanks in Advance."
                    },
                    {
                        "username": "ashishnethi",
                        "content": "We need to remove nums[i] not nums[i-1]"
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "[@sugreem](/sugreem) Thanks for this answer. I was removing nums[i - 1] and I was so confused. Should have read the question carefully."
                    },
                    {
                        "username": "sugreem",
                        "content": "remove nums[i] such that nums[i] < nums[i-1]"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1576819,
                "content": [
                    {
                        "username": "DolphinsAtDaybreak",
                        "content": "**EDIT: They\\'ve fixed the hints now!**\\n\\nI got to the idea of monotonic stack during the contest but didn\\'t quite figure out the final algorithm.  Looking at the hints now I see:\\n\\nHint 3\\nConsider an element at index i. Say there exists a strictly greater element to its left, and the closest one is located at index j (i.e. there is no index k such that j < k < i and nums[k] > nums[i]). The number of rounds required to remove nums[i] is i - j.\\n\\nHow does that work?  If we have an array [6,5,4,3,2,1,5] -- shouldn\\'t it take 2 rounds to remove the 5, not i-j=6 rounds?\\n\\n"
                    },
                    {
                        "username": "Taranovski",
                        "content": "leetcode, forget about \"medium\" rating for anything monolithic stack, it is extremely non-intuitive and \"jumping through the hoops\", set the realistic \"hard\" rating for it!\\nExtremely confusing \"pattern\" of the solution, be real!"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "great question but should be hard"
                    },
                    {
                        "username": "XeBaGac",
                        "content": "Time Limit Exceeded with TC 79, i don\\'t know how to make my code quicker :((("
                    },
                    {
                        "username": "Flankerr",
                        "content": "can someone please explain how this array is completed in 1 step.\\n\\naccording to my calculation\\noriginal [10,6,5,10,15]\\n1st step [10,5,10,15]\\n2nd step [10,10,15]"
                    },
                    {
                        "username": "XeBaGac",
                        "content": "in step1 u erase both 6 and 5 because  6>5 . Therefore, the result is 10,10,15\\n"
                    },
                    {
                        "username": "prashantkumarrai8",
                        "content": "1st we remove 5 bcz of 6 and then 6 bcz of 10"
                    },
                    {
                        "username": "shhattali2002",
                        "content": "[@Gyaneswar Singh](/Flankerr) don't delete the integer directly first check out the index elements that satisfy given condition ( nums[i]<nums[i-1] ) than go for deletion.\neg. original [10,6,5,10,15]\nHere index 1,2 satisfy the condition than delete them it will take 1 step.\n\neg. Original [5,3,4,4,7,3,6,11,8,5,11]\nHere index 1,5,8,9 satisfy hence step 1.\n[5,4,4,7,6,11,11]\nIn step 2 index 1,4 satisfy condition\n[5,4,4,7,11,11]\nIn step 3 index 1 satisfy condition\n[5,7,11,11]\n"
                    },
                    {
                        "username": "aaks-ctrl",
                        "content": "Can someone tell me where an I going wrong with my approach ?\\n \\n `\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<int> c;\\n        int ans{};\\n        int steps{};\\n        while(nums.size()){\\n            int last=nums.back();\\n            nums.pop_back();\\n            int i{};\\n            while(c.size() && last>c.top()){\\n                c.pop();\\n                i++;\\n            }\\n            ans=max(i,ans);\\n            c.push(last);\\n        }\\n        return ans;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "2uringTested",
                        "content": "i would\\'ve tried if it was written in a coding language...\\n\\n/s .... try writing a bit readable code."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "For the test case\\n\\n[5,1,2,3,4]\\n\\nJust removing 5 in the start would make it [1,2,3,4] which is a Non Decreasing Array . \\n\\nSo number of steps needed is \\'1\\' . But the solution expected is 4 . Am i missing something ? \\n\\nThanks in Advance."
                    },
                    {
                        "username": "ashishnethi",
                        "content": "We need to remove nums[i] not nums[i-1]"
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "[@sugreem](/sugreem) Thanks for this answer. I was removing nums[i - 1] and I was so confused. Should have read the question carefully."
                    },
                    {
                        "username": "sugreem",
                        "content": "remove nums[i] such that nums[i] < nums[i-1]"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1862481,
                "content": [
                    {
                        "username": "DolphinsAtDaybreak",
                        "content": "**EDIT: They\\'ve fixed the hints now!**\\n\\nI got to the idea of monotonic stack during the contest but didn\\'t quite figure out the final algorithm.  Looking at the hints now I see:\\n\\nHint 3\\nConsider an element at index i. Say there exists a strictly greater element to its left, and the closest one is located at index j (i.e. there is no index k such that j < k < i and nums[k] > nums[i]). The number of rounds required to remove nums[i] is i - j.\\n\\nHow does that work?  If we have an array [6,5,4,3,2,1,5] -- shouldn\\'t it take 2 rounds to remove the 5, not i-j=6 rounds?\\n\\n"
                    },
                    {
                        "username": "Taranovski",
                        "content": "leetcode, forget about \"medium\" rating for anything monolithic stack, it is extremely non-intuitive and \"jumping through the hoops\", set the realistic \"hard\" rating for it!\\nExtremely confusing \"pattern\" of the solution, be real!"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "great question but should be hard"
                    },
                    {
                        "username": "XeBaGac",
                        "content": "Time Limit Exceeded with TC 79, i don\\'t know how to make my code quicker :((("
                    },
                    {
                        "username": "Flankerr",
                        "content": "can someone please explain how this array is completed in 1 step.\\n\\naccording to my calculation\\noriginal [10,6,5,10,15]\\n1st step [10,5,10,15]\\n2nd step [10,10,15]"
                    },
                    {
                        "username": "XeBaGac",
                        "content": "in step1 u erase both 6 and 5 because  6>5 . Therefore, the result is 10,10,15\\n"
                    },
                    {
                        "username": "prashantkumarrai8",
                        "content": "1st we remove 5 bcz of 6 and then 6 bcz of 10"
                    },
                    {
                        "username": "shhattali2002",
                        "content": "[@Gyaneswar Singh](/Flankerr) don't delete the integer directly first check out the index elements that satisfy given condition ( nums[i]<nums[i-1] ) than go for deletion.\neg. original [10,6,5,10,15]\nHere index 1,2 satisfy the condition than delete them it will take 1 step.\n\neg. Original [5,3,4,4,7,3,6,11,8,5,11]\nHere index 1,5,8,9 satisfy hence step 1.\n[5,4,4,7,6,11,11]\nIn step 2 index 1,4 satisfy condition\n[5,4,4,7,11,11]\nIn step 3 index 1 satisfy condition\n[5,7,11,11]\n"
                    },
                    {
                        "username": "aaks-ctrl",
                        "content": "Can someone tell me where an I going wrong with my approach ?\\n \\n `\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<int> c;\\n        int ans{};\\n        int steps{};\\n        while(nums.size()){\\n            int last=nums.back();\\n            nums.pop_back();\\n            int i{};\\n            while(c.size() && last>c.top()){\\n                c.pop();\\n                i++;\\n            }\\n            ans=max(i,ans);\\n            c.push(last);\\n        }\\n        return ans;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "2uringTested",
                        "content": "i would\\'ve tried if it was written in a coding language...\\n\\n/s .... try writing a bit readable code."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "For the test case\\n\\n[5,1,2,3,4]\\n\\nJust removing 5 in the start would make it [1,2,3,4] which is a Non Decreasing Array . \\n\\nSo number of steps needed is \\'1\\' . But the solution expected is 4 . Am i missing something ? \\n\\nThanks in Advance."
                    },
                    {
                        "username": "ashishnethi",
                        "content": "We need to remove nums[i] not nums[i-1]"
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "[@sugreem](/sugreem) Thanks for this answer. I was removing nums[i - 1] and I was so confused. Should have read the question carefully."
                    },
                    {
                        "username": "sugreem",
                        "content": "remove nums[i] such that nums[i] < nums[i-1]"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1929815,
                "content": [
                    {
                        "username": "DolphinsAtDaybreak",
                        "content": "**EDIT: They\\'ve fixed the hints now!**\\n\\nI got to the idea of monotonic stack during the contest but didn\\'t quite figure out the final algorithm.  Looking at the hints now I see:\\n\\nHint 3\\nConsider an element at index i. Say there exists a strictly greater element to its left, and the closest one is located at index j (i.e. there is no index k such that j < k < i and nums[k] > nums[i]). The number of rounds required to remove nums[i] is i - j.\\n\\nHow does that work?  If we have an array [6,5,4,3,2,1,5] -- shouldn\\'t it take 2 rounds to remove the 5, not i-j=6 rounds?\\n\\n"
                    },
                    {
                        "username": "Taranovski",
                        "content": "leetcode, forget about \"medium\" rating for anything monolithic stack, it is extremely non-intuitive and \"jumping through the hoops\", set the realistic \"hard\" rating for it!\\nExtremely confusing \"pattern\" of the solution, be real!"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "great question but should be hard"
                    },
                    {
                        "username": "XeBaGac",
                        "content": "Time Limit Exceeded with TC 79, i don\\'t know how to make my code quicker :((("
                    },
                    {
                        "username": "Flankerr",
                        "content": "can someone please explain how this array is completed in 1 step.\\n\\naccording to my calculation\\noriginal [10,6,5,10,15]\\n1st step [10,5,10,15]\\n2nd step [10,10,15]"
                    },
                    {
                        "username": "XeBaGac",
                        "content": "in step1 u erase both 6 and 5 because  6>5 . Therefore, the result is 10,10,15\\n"
                    },
                    {
                        "username": "prashantkumarrai8",
                        "content": "1st we remove 5 bcz of 6 and then 6 bcz of 10"
                    },
                    {
                        "username": "shhattali2002",
                        "content": "[@Gyaneswar Singh](/Flankerr) don't delete the integer directly first check out the index elements that satisfy given condition ( nums[i]<nums[i-1] ) than go for deletion.\neg. original [10,6,5,10,15]\nHere index 1,2 satisfy the condition than delete them it will take 1 step.\n\neg. Original [5,3,4,4,7,3,6,11,8,5,11]\nHere index 1,5,8,9 satisfy hence step 1.\n[5,4,4,7,6,11,11]\nIn step 2 index 1,4 satisfy condition\n[5,4,4,7,11,11]\nIn step 3 index 1 satisfy condition\n[5,7,11,11]\n"
                    },
                    {
                        "username": "aaks-ctrl",
                        "content": "Can someone tell me where an I going wrong with my approach ?\\n \\n `\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<int> c;\\n        int ans{};\\n        int steps{};\\n        while(nums.size()){\\n            int last=nums.back();\\n            nums.pop_back();\\n            int i{};\\n            while(c.size() && last>c.top()){\\n                c.pop();\\n                i++;\\n            }\\n            ans=max(i,ans);\\n            c.push(last);\\n        }\\n        return ans;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "2uringTested",
                        "content": "i would\\'ve tried if it was written in a coding language...\\n\\n/s .... try writing a bit readable code."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "For the test case\\n\\n[5,1,2,3,4]\\n\\nJust removing 5 in the start would make it [1,2,3,4] which is a Non Decreasing Array . \\n\\nSo number of steps needed is \\'1\\' . But the solution expected is 4 . Am i missing something ? \\n\\nThanks in Advance."
                    },
                    {
                        "username": "ashishnethi",
                        "content": "We need to remove nums[i] not nums[i-1]"
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "[@sugreem](/sugreem) Thanks for this answer. I was removing nums[i - 1] and I was so confused. Should have read the question carefully."
                    },
                    {
                        "username": "sugreem",
                        "content": "remove nums[i] such that nums[i] < nums[i-1]"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1693111,
                "content": [
                    {
                        "username": "DolphinsAtDaybreak",
                        "content": "**EDIT: They\\'ve fixed the hints now!**\\n\\nI got to the idea of monotonic stack during the contest but didn\\'t quite figure out the final algorithm.  Looking at the hints now I see:\\n\\nHint 3\\nConsider an element at index i. Say there exists a strictly greater element to its left, and the closest one is located at index j (i.e. there is no index k such that j < k < i and nums[k] > nums[i]). The number of rounds required to remove nums[i] is i - j.\\n\\nHow does that work?  If we have an array [6,5,4,3,2,1,5] -- shouldn\\'t it take 2 rounds to remove the 5, not i-j=6 rounds?\\n\\n"
                    },
                    {
                        "username": "Taranovski",
                        "content": "leetcode, forget about \"medium\" rating for anything monolithic stack, it is extremely non-intuitive and \"jumping through the hoops\", set the realistic \"hard\" rating for it!\\nExtremely confusing \"pattern\" of the solution, be real!"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "great question but should be hard"
                    },
                    {
                        "username": "XeBaGac",
                        "content": "Time Limit Exceeded with TC 79, i don\\'t know how to make my code quicker :((("
                    },
                    {
                        "username": "Flankerr",
                        "content": "can someone please explain how this array is completed in 1 step.\\n\\naccording to my calculation\\noriginal [10,6,5,10,15]\\n1st step [10,5,10,15]\\n2nd step [10,10,15]"
                    },
                    {
                        "username": "XeBaGac",
                        "content": "in step1 u erase both 6 and 5 because  6>5 . Therefore, the result is 10,10,15\\n"
                    },
                    {
                        "username": "prashantkumarrai8",
                        "content": "1st we remove 5 bcz of 6 and then 6 bcz of 10"
                    },
                    {
                        "username": "shhattali2002",
                        "content": "[@Gyaneswar Singh](/Flankerr) don't delete the integer directly first check out the index elements that satisfy given condition ( nums[i]<nums[i-1] ) than go for deletion.\neg. original [10,6,5,10,15]\nHere index 1,2 satisfy the condition than delete them it will take 1 step.\n\neg. Original [5,3,4,4,7,3,6,11,8,5,11]\nHere index 1,5,8,9 satisfy hence step 1.\n[5,4,4,7,6,11,11]\nIn step 2 index 1,4 satisfy condition\n[5,4,4,7,11,11]\nIn step 3 index 1 satisfy condition\n[5,7,11,11]\n"
                    },
                    {
                        "username": "aaks-ctrl",
                        "content": "Can someone tell me where an I going wrong with my approach ?\\n \\n `\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<int> c;\\n        int ans{};\\n        int steps{};\\n        while(nums.size()){\\n            int last=nums.back();\\n            nums.pop_back();\\n            int i{};\\n            while(c.size() && last>c.top()){\\n                c.pop();\\n                i++;\\n            }\\n            ans=max(i,ans);\\n            c.push(last);\\n        }\\n        return ans;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "2uringTested",
                        "content": "i would\\'ve tried if it was written in a coding language...\\n\\n/s .... try writing a bit readable code."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "For the test case\\n\\n[5,1,2,3,4]\\n\\nJust removing 5 in the start would make it [1,2,3,4] which is a Non Decreasing Array . \\n\\nSo number of steps needed is \\'1\\' . But the solution expected is 4 . Am i missing something ? \\n\\nThanks in Advance."
                    },
                    {
                        "username": "ashishnethi",
                        "content": "We need to remove nums[i] not nums[i-1]"
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "[@sugreem](/sugreem) Thanks for this answer. I was removing nums[i - 1] and I was so confused. Should have read the question carefully."
                    },
                    {
                        "username": "sugreem",
                        "content": "remove nums[i] such that nums[i] < nums[i-1]"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1713368,
                "content": [
                    {
                        "username": "DolphinsAtDaybreak",
                        "content": "**EDIT: They\\'ve fixed the hints now!**\\n\\nI got to the idea of monotonic stack during the contest but didn\\'t quite figure out the final algorithm.  Looking at the hints now I see:\\n\\nHint 3\\nConsider an element at index i. Say there exists a strictly greater element to its left, and the closest one is located at index j (i.e. there is no index k such that j < k < i and nums[k] > nums[i]). The number of rounds required to remove nums[i] is i - j.\\n\\nHow does that work?  If we have an array [6,5,4,3,2,1,5] -- shouldn\\'t it take 2 rounds to remove the 5, not i-j=6 rounds?\\n\\n"
                    },
                    {
                        "username": "Taranovski",
                        "content": "leetcode, forget about \"medium\" rating for anything monolithic stack, it is extremely non-intuitive and \"jumping through the hoops\", set the realistic \"hard\" rating for it!\\nExtremely confusing \"pattern\" of the solution, be real!"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "great question but should be hard"
                    },
                    {
                        "username": "XeBaGac",
                        "content": "Time Limit Exceeded with TC 79, i don\\'t know how to make my code quicker :((("
                    },
                    {
                        "username": "Flankerr",
                        "content": "can someone please explain how this array is completed in 1 step.\\n\\naccording to my calculation\\noriginal [10,6,5,10,15]\\n1st step [10,5,10,15]\\n2nd step [10,10,15]"
                    },
                    {
                        "username": "XeBaGac",
                        "content": "in step1 u erase both 6 and 5 because  6>5 . Therefore, the result is 10,10,15\\n"
                    },
                    {
                        "username": "prashantkumarrai8",
                        "content": "1st we remove 5 bcz of 6 and then 6 bcz of 10"
                    },
                    {
                        "username": "shhattali2002",
                        "content": "[@Gyaneswar Singh](/Flankerr) don't delete the integer directly first check out the index elements that satisfy given condition ( nums[i]<nums[i-1] ) than go for deletion.\neg. original [10,6,5,10,15]\nHere index 1,2 satisfy the condition than delete them it will take 1 step.\n\neg. Original [5,3,4,4,7,3,6,11,8,5,11]\nHere index 1,5,8,9 satisfy hence step 1.\n[5,4,4,7,6,11,11]\nIn step 2 index 1,4 satisfy condition\n[5,4,4,7,11,11]\nIn step 3 index 1 satisfy condition\n[5,7,11,11]\n"
                    },
                    {
                        "username": "aaks-ctrl",
                        "content": "Can someone tell me where an I going wrong with my approach ?\\n \\n `\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<int> c;\\n        int ans{};\\n        int steps{};\\n        while(nums.size()){\\n            int last=nums.back();\\n            nums.pop_back();\\n            int i{};\\n            while(c.size() && last>c.top()){\\n                c.pop();\\n                i++;\\n            }\\n            ans=max(i,ans);\\n            c.push(last);\\n        }\\n        return ans;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "2uringTested",
                        "content": "i would\\'ve tried if it was written in a coding language...\\n\\n/s .... try writing a bit readable code."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "For the test case\\n\\n[5,1,2,3,4]\\n\\nJust removing 5 in the start would make it [1,2,3,4] which is a Non Decreasing Array . \\n\\nSo number of steps needed is \\'1\\' . But the solution expected is 4 . Am i missing something ? \\n\\nThanks in Advance."
                    },
                    {
                        "username": "ashishnethi",
                        "content": "We need to remove nums[i] not nums[i-1]"
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "[@sugreem](/sugreem) Thanks for this answer. I was removing nums[i - 1] and I was so confused. Should have read the question carefully."
                    },
                    {
                        "username": "sugreem",
                        "content": "remove nums[i] such that nums[i] < nums[i-1]"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1576960,
                "content": [
                    {
                        "username": "DolphinsAtDaybreak",
                        "content": "**EDIT: They\\'ve fixed the hints now!**\\n\\nI got to the idea of monotonic stack during the contest but didn\\'t quite figure out the final algorithm.  Looking at the hints now I see:\\n\\nHint 3\\nConsider an element at index i. Say there exists a strictly greater element to its left, and the closest one is located at index j (i.e. there is no index k such that j < k < i and nums[k] > nums[i]). The number of rounds required to remove nums[i] is i - j.\\n\\nHow does that work?  If we have an array [6,5,4,3,2,1,5] -- shouldn\\'t it take 2 rounds to remove the 5, not i-j=6 rounds?\\n\\n"
                    },
                    {
                        "username": "Taranovski",
                        "content": "leetcode, forget about \"medium\" rating for anything monolithic stack, it is extremely non-intuitive and \"jumping through the hoops\", set the realistic \"hard\" rating for it!\\nExtremely confusing \"pattern\" of the solution, be real!"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "great question but should be hard"
                    },
                    {
                        "username": "XeBaGac",
                        "content": "Time Limit Exceeded with TC 79, i don\\'t know how to make my code quicker :((("
                    },
                    {
                        "username": "Flankerr",
                        "content": "can someone please explain how this array is completed in 1 step.\\n\\naccording to my calculation\\noriginal [10,6,5,10,15]\\n1st step [10,5,10,15]\\n2nd step [10,10,15]"
                    },
                    {
                        "username": "XeBaGac",
                        "content": "in step1 u erase both 6 and 5 because  6>5 . Therefore, the result is 10,10,15\\n"
                    },
                    {
                        "username": "prashantkumarrai8",
                        "content": "1st we remove 5 bcz of 6 and then 6 bcz of 10"
                    },
                    {
                        "username": "shhattali2002",
                        "content": "[@Gyaneswar Singh](/Flankerr) don't delete the integer directly first check out the index elements that satisfy given condition ( nums[i]<nums[i-1] ) than go for deletion.\neg. original [10,6,5,10,15]\nHere index 1,2 satisfy the condition than delete them it will take 1 step.\n\neg. Original [5,3,4,4,7,3,6,11,8,5,11]\nHere index 1,5,8,9 satisfy hence step 1.\n[5,4,4,7,6,11,11]\nIn step 2 index 1,4 satisfy condition\n[5,4,4,7,11,11]\nIn step 3 index 1 satisfy condition\n[5,7,11,11]\n"
                    },
                    {
                        "username": "aaks-ctrl",
                        "content": "Can someone tell me where an I going wrong with my approach ?\\n \\n `\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<int> c;\\n        int ans{};\\n        int steps{};\\n        while(nums.size()){\\n            int last=nums.back();\\n            nums.pop_back();\\n            int i{};\\n            while(c.size() && last>c.top()){\\n                c.pop();\\n                i++;\\n            }\\n            ans=max(i,ans);\\n            c.push(last);\\n        }\\n        return ans;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "2uringTested",
                        "content": "i would\\'ve tried if it was written in a coding language...\\n\\n/s .... try writing a bit readable code."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "For the test case\\n\\n[5,1,2,3,4]\\n\\nJust removing 5 in the start would make it [1,2,3,4] which is a Non Decreasing Array . \\n\\nSo number of steps needed is \\'1\\' . But the solution expected is 4 . Am i missing something ? \\n\\nThanks in Advance."
                    },
                    {
                        "username": "ashishnethi",
                        "content": "We need to remove nums[i] not nums[i-1]"
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "[@sugreem](/sugreem) Thanks for this answer. I was removing nums[i - 1] and I was so confused. Should have read the question carefully."
                    },
                    {
                        "username": "sugreem",
                        "content": "remove nums[i] such that nums[i] < nums[i-1]"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1763841,
                "content": [
                    {
                        "username": "DolphinsAtDaybreak",
                        "content": "**EDIT: They\\'ve fixed the hints now!**\\n\\nI got to the idea of monotonic stack during the contest but didn\\'t quite figure out the final algorithm.  Looking at the hints now I see:\\n\\nHint 3\\nConsider an element at index i. Say there exists a strictly greater element to its left, and the closest one is located at index j (i.e. there is no index k such that j < k < i and nums[k] > nums[i]). The number of rounds required to remove nums[i] is i - j.\\n\\nHow does that work?  If we have an array [6,5,4,3,2,1,5] -- shouldn\\'t it take 2 rounds to remove the 5, not i-j=6 rounds?\\n\\n"
                    },
                    {
                        "username": "Taranovski",
                        "content": "leetcode, forget about \"medium\" rating for anything monolithic stack, it is extremely non-intuitive and \"jumping through the hoops\", set the realistic \"hard\" rating for it!\\nExtremely confusing \"pattern\" of the solution, be real!"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "great question but should be hard"
                    },
                    {
                        "username": "XeBaGac",
                        "content": "Time Limit Exceeded with TC 79, i don\\'t know how to make my code quicker :((("
                    },
                    {
                        "username": "Flankerr",
                        "content": "can someone please explain how this array is completed in 1 step.\\n\\naccording to my calculation\\noriginal [10,6,5,10,15]\\n1st step [10,5,10,15]\\n2nd step [10,10,15]"
                    },
                    {
                        "username": "XeBaGac",
                        "content": "in step1 u erase both 6 and 5 because  6>5 . Therefore, the result is 10,10,15\\n"
                    },
                    {
                        "username": "prashantkumarrai8",
                        "content": "1st we remove 5 bcz of 6 and then 6 bcz of 10"
                    },
                    {
                        "username": "shhattali2002",
                        "content": "[@Gyaneswar Singh](/Flankerr) don't delete the integer directly first check out the index elements that satisfy given condition ( nums[i]<nums[i-1] ) than go for deletion.\neg. original [10,6,5,10,15]\nHere index 1,2 satisfy the condition than delete them it will take 1 step.\n\neg. Original [5,3,4,4,7,3,6,11,8,5,11]\nHere index 1,5,8,9 satisfy hence step 1.\n[5,4,4,7,6,11,11]\nIn step 2 index 1,4 satisfy condition\n[5,4,4,7,11,11]\nIn step 3 index 1 satisfy condition\n[5,7,11,11]\n"
                    },
                    {
                        "username": "aaks-ctrl",
                        "content": "Can someone tell me where an I going wrong with my approach ?\\n \\n `\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<int> c;\\n        int ans{};\\n        int steps{};\\n        while(nums.size()){\\n            int last=nums.back();\\n            nums.pop_back();\\n            int i{};\\n            while(c.size() && last>c.top()){\\n                c.pop();\\n                i++;\\n            }\\n            ans=max(i,ans);\\n            c.push(last);\\n        }\\n        return ans;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "2uringTested",
                        "content": "i would\\'ve tried if it was written in a coding language...\\n\\n/s .... try writing a bit readable code."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "For the test case\\n\\n[5,1,2,3,4]\\n\\nJust removing 5 in the start would make it [1,2,3,4] which is a Non Decreasing Array . \\n\\nSo number of steps needed is \\'1\\' . But the solution expected is 4 . Am i missing something ? \\n\\nThanks in Advance."
                    },
                    {
                        "username": "ashishnethi",
                        "content": "We need to remove nums[i] not nums[i-1]"
                    },
                    {
                        "username": "MaverickEyedea",
                        "content": "[@sugreem](/sugreem) Thanks for this answer. I was removing nums[i - 1] and I was so confused. Should have read the question carefully."
                    },
                    {
                        "username": "sugreem",
                        "content": "remove nums[i] such that nums[i] < nums[i-1]"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            }
        ]
    },
    {
        "title": "Fair Distribution of Cookies",
        "question_content": "<p>You are given an integer array <code>cookies</code>, where <code>cookies[i]</code> denotes the number of cookies in the <code>i<sup>th</sup></code> bag. You are also given an integer <code>k</code> that denotes the number of children to distribute <strong>all</strong> the bags of cookies to. All the cookies in the same bag must go to the same child and cannot be split up.</p>\n\n<p>The <strong>unfairness</strong> of a distribution is defined as the <strong>maximum</strong> <strong>total</strong> cookies obtained by a single child in the distribution.</p>\n\n<p>Return <em>the <strong>minimum</strong> unfairness of all distributions</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> cookies = [8,15,10,20,8], k = 2\n<strong>Output:</strong> 31\n<strong>Explanation:</strong> One optimal distribution is [8,15,8] and [10,20]\n- The 1<sup>st</sup> child receives [8,15,8] which has a total of 8 + 15 + 8 = 31 cookies.\n- The 2<sup>nd</sup> child receives [10,20] which has a total of 10 + 20 = 30 cookies.\nThe unfairness of the distribution is max(31,30) = 31.\nIt can be shown that there is no distribution with an unfairness less than 31.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> cookies = [6,1,3,2,2,4,1,2], k = 3\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> One optimal distribution is [6,1], [3,2,2], and [4,1,2]\n- The 1<sup>st</sup> child receives [6,1] which has a total of 6 + 1 = 7 cookies.\n- The 2<sup>nd</sup> child receives [3,2,2] which has a total of 3 + 2 + 2 = 7 cookies.\n- The 3<sup>rd</sup> child receives [4,1,2] which has a total of 4 + 1 + 2 = 7 cookies.\nThe unfairness of the distribution is max(7,7,7) = 7.\nIt can be shown that there is no distribution with an unfairness less than 7.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= cookies.length &lt;= 8</code></li>\n\t<li><code>1 &lt;= cookies[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>2 &lt;= k &lt;= cookies.length</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 2140918,
                "title": "easy-c-backtracking",
                "content": "We use a k length vector, to store the sum of cookies for each child.\\nIt is like placing each element in k different subsets.\\nSo we assign each and every bag of cookies to different subsets using backtracking and if all are distributed, we check for the maximum element in that case, and update our ans according to it.\\nlet n = size of given array\\nAs for each element we have k subset choices and there are total of n elements, so **Time complexity : O(k^n)**\\n\\n```\\nclass Solution {\\npublic:\\n    int ans = INT_MAX;\\n    void solve(int start, vector<int>& nums, vector<int>& v, int k){\\n        if(start==nums.size()){\\n            int maxm = INT_MIN;\\n            for(int i=0;i<k;i++){\\n                maxm = max(maxm,v[i]);\\n            }\\n            ans = min(ans,maxm);\\n            return;\\n        }\\n        for(int i=0;i<k;i++){\\n            v[i] += nums[start];\\n            solve(start+1,nums,v,k);\\n            v[i] -= nums[start];\\n        }\\n    }\\n    \\n    int distributeCookies(vector<int>& nums, int k) { // nums is the cookies vector\\n        int n = nums.size();\\n        vector<int> v(k,0); // v is to store each sum of the k subsets\\n        solve(0,nums,v,k);\\n        return ans;\\n    }\\n};\\n```\\n\\n**Update: Optimization**\\nLet cookies = [8,15,10] and k=2.\\nThen the subsets we calculate are [33,0] , [23,10], [18,15], [8,25], [25,8], [15,18], [10,23], [0,33].\\nHere we observe [33,0] and [0,33] refers to same subset and similary other.\\nSo we can reduce the duplicates by breaking the loop if v[i] is equal to 0, as it will be covered in the other subset.\\nIn the for loop of above code, we break the loop if v[i] is equal to 0, because without this line we are just calculating the same subset with different combinations which is unnecessary.\\nSo now the subsets we calculate will only be: [33,0] , [23,10], [18,15], [8,25].\\n```\\nfor(int i=0;i<k;i++){\\n\\tv[i] += nums[start];\\n\\tsolve(start+1,nums,v,k);\\n\\tv[i] -= nums[start];\\n\\tif(v[i]==0) break;\\n}\\n```\\nThanks to @zyj5353\\n\\n**Upvote if it helps!**",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = INT_MAX;\\n    void solve(int start, vector<int>& nums, vector<int>& v, int k){\\n        if(start==nums.size()){\\n            int maxm = INT_MIN;\\n            for(int i=0;i<k;i++){\\n                maxm = max(maxm,v[i]);\\n            }\\n            ans = min(ans,maxm);\\n            return;\\n        }\\n        for(int i=0;i<k;i++){\\n            v[i] += nums[start];\\n            solve(start+1,nums,v,k);\\n            v[i] -= nums[start];\\n        }\\n    }\\n    \\n    int distributeCookies(vector<int>& nums, int k) { // nums is the cookies vector\\n        int n = nums.size();\\n        vector<int> v(k,0); // v is to store each sum of the k subsets\\n        solve(0,nums,v,k);\\n        return ans;\\n    }\\n};\\n```\n```\\nfor(int i=0;i<k;i++){\\n\\tv[i] += nums[start];\\n\\tsolve(start+1,nums,v,k);\\n\\tv[i] -= nums[start];\\n\\tif(v[i]==0) break;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702398,
                "title": "back-track-c-java-beginner-friendly",
                "content": "# Intuition:\\nThe two-pointer technique starts with the widest container and moves the pointers inward based on the comparison of heights. \\nIncreasing the width of the container can only lead to a larger area if the height of the new boundary is greater. By moving the pointers towards the center, we explore containers with the potential for greater areas.\\n\\n# Explanation:\\n\\n1. The function `helper` is a recursive function that performs the backtracking. It takes several parameters:\\n   - `start` represents the index of the current cookie we are considering.\\n   - `cookies` is a constant reference to the vector of cookies.\\n   - `temp` is a reference to the vector that stores the current distribution of cookies among the children.\\n   - `k` represents the number of children.\\n   - `ans` is a reference to the variable that stores the minimum difference between the maximum and minimum number of cookies among the children.\\n\\n2. The function starts by checking if we have processed all the cookies (base case). If `start` is equal to the size of the `cookies` vector, it means we have considered all cookies, and we can calculate the maximum number of cookies among the children. We iterate over the `temp` vector and update `maxi` with the maximum value.\\n\\n3. After obtaining the maximum value, we update `ans` with the minimum between its current value and `maxi`. This ensures that we keep track of the minimum difference between the maximum and minimum number of cookies among the children.\\n\\n4. Now comes the backtracking part. We iterate over the number of children, `k`, and perform the following steps:\\n   - Add the current cookie at index `start` to the `i`th child by incrementing `temp[i]` with `cookies[start]`.\\n   - Recursively call the `helper` function with the updated `start` index and the modified `temp` vector.\\n   - After the recursive call, we backtrack by subtracting the current cookie from the `i`th child. This is done by decrementing `temp[i]` with `cookies[start]`.\\n\\n5. Finally, the `distributeCookies` function initializes `ans` with a maximum value and creates a temporary vector `temp` of size `k` initialized with zeros. It then calls the `helper` function with the starting index `0`, the `cookies` vector, the `temp` vector, `k`, and the `ans` variable.\\n\\n6. Once the `helper` function completes, the `distributeCookies` function returns the calculated `ans`, which represents the minimum difference between the maximum and minimum number of cookies among the children.\\n\\n# Crucial step:\\n1. `temp[i] += cookies[start];`: This line adds the `start`-th cookie to the `i`-th child\\'s count. It updates the distribution temporarily for the current recursive call. This step represents \"taking\" the cookie and assigning it to a specific child.\\n2. `helper(start + 1, cookies, temp, k, ans);`: After adding the current cookie to a child, we make a recursive call to the `helper` function, incrementing the `start` index by 1. This means we move on to the next cookie and continue distributing it among the children. The recursive call explores all possible distributions of cookies by incrementally considering the next cookies.\\n3. `temp[i] -= cookies[start];`: This line performs backtracking. After the recursive call returns, we need to undo the changes made in step 1 to explore other possibilities. Subtracting `cookies[start]` from `temp[i]` reverts the distribution of the cookie we added to the `i`-th child. This step represents \"back-tracking\" or \"undoing\" the previous distribution.\\n\\nThe purpose of backtracking is to explore all possible combinations of cookie distributions among the children. By adding a cookie to a child, recursively exploring further distributions, and then backtracking by removing the cookie, we can systematically try out different scenarios without explicitly generating all permutations.\\n\\nThe backtracking step is crucial because it allows us to backtrack to a previous state and try a different choice. In this case, it enables us to consider different distributions of cookies among the children by undoing the changes made during the recursive call and trying out other possibilities.\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    void helper(int start, const vector<int>& cookies, vector<int>& temp, int k, int& ans) {\\n        int n = cookies.size();\\n        if (start == n) {\\n            int maxi = INT_MIN;\\n            for (int i = 0; i < k; i++) {\\n                maxi = max(maxi, temp[i]);\\n            }\\n            ans = min(ans, maxi);\\n            return;\\n        }\\n\\n        for (int i = 0; i < k; i++) {\\n            temp[i] += cookies[start]; // take\\n            helper(start + 1, cookies, temp, k, ans);\\n            temp[i] -= cookies[start]; // back-track\\n        }\\n    }\\n\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int ans = INT_MAX;\\n        vector<int> temp(k, 0);\\n        helper(0, cookies, temp, k, ans);\\n        return ans;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    int ans = Integer.MAX_VALUE;\\n\\n    void helper(int[] cookies, int start, int k, int[] temp) {\\n        if (start == cookies.length) {\\n            int max = 0;\\n            for (int c : temp)\\n                max = Math.max(max, c);\\n            ans = Math.min(ans, max);\\n            return;\\n        }\\n        for (int i = 0; i < k; i++) {\\n            temp[i] += cookies[start];\\n            helper(cookies, start + 1, k, temp);\\n            temp[i] -= cookies[start];\\n        }\\n    }\\n\\n    public int distributeCookies(int[] cookies, int k) {\\n        helper(cookies, 0, k, new int[k]);\\n        return ans;\\n    }\\n}\\n```\\n\\n![CUTE_CAT.png](https://assets.leetcode.com/users/images/65521afd-61eb-4bc2-a092-c20a552bd7dd_1688179940.040303.png)\\n\\n\\n**If you found my solution helpful, I would greatly appreciate your upvote, as it would motivate me to continue sharing more solutions.**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Backtracking"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    void helper(int start, const vector<int>& cookies, vector<int>& temp, int k, int& ans) {\\n        int n = cookies.size();\\n        if (start == n) {\\n            int maxi = INT_MIN;\\n            for (int i = 0; i < k; i++) {\\n                maxi = max(maxi, temp[i]);\\n            }\\n            ans = min(ans, maxi);\\n            return;\\n        }\\n\\n        for (int i = 0; i < k; i++) {\\n            temp[i] += cookies[start]; // take\\n            helper(start + 1, cookies, temp, k, ans);\\n            temp[i] -= cookies[start]; // back-track\\n        }\\n    }\\n\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int ans = INT_MAX;\\n        vector<int> temp(k, 0);\\n        helper(0, cookies, temp, k, ans);\\n        return ans;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    int ans = Integer.MAX_VALUE;\\n\\n    void helper(int[] cookies, int start, int k, int[] temp) {\\n        if (start == cookies.length) {\\n            int max = 0;\\n            for (int c : temp)\\n                max = Math.max(max, c);\\n            ans = Math.min(ans, max);\\n            return;\\n        }\\n        for (int i = 0; i < k; i++) {\\n            temp[i] += cookies[start];\\n            helper(cookies, start + 1, k, temp);\\n            temp[i] -= cookies[start];\\n        }\\n    }\\n\\n    public int distributeCookies(int[] cookies, int k) {\\n        helper(cookies, 0, k, new int[k]);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141573,
                "title": "dp-submask-enumeration-most-optimal-solution-100-faster-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int n = cookies.size();\\n        vector<vector<int>>dp(k + 1, vector<int>(1ll << n, INT_MAX));\\n        \\n        vector<int>sum(1ll << n);\\n        for(int mask = 0;mask<(1ll << n); mask++){\\n            int total = 0;\\n            for(int i = 0;i<n;i++){\\n                if(mask & (1ll << i)){\\n                    total += cookies[i];\\n                }\\n            }\\n            sum[mask] = total;\\n        }\\n\\n        dp[0][0] = 0;\\n        for(int person = 1;person<=k;person++){\\n            for(int mask = 0;mask<(1ll << n);mask++){\\n                for(int submask=mask;submask;submask=(submask - 1)&mask){\\n                    dp[person][mask] = min(dp[person][mask], max(sum[submask], dp[person - 1][mask ^ submask]));\\n                }\\n            }\\n        }\\n\\n        return dp[k][(1ll << n) - 1];\\n    }   \\n};\\n```\\n\\ndp[i][mask] denotes if we have in total i children and mask is the configuration of the cookies what will be the optimal answer for that.\\nThen we simply iterate on all possible submask of the current mask and check if we parition the current mask into submask and the rest i - 1 children have (mask xor submask) cookies, what will be the optimal answer.\\nFinaly we obtain the answer using k children and (1 << (cookies.size()) - 1) mask.\\n\\nFor further reading about submask enumeration i would suggest to go through the following article of CP algorithms: https://cp-algorithms.com/algebra/all-submasks.html#enumerating-all-submasks-of-a-given-mask\\n\\n**Time complexity**: enumeration of submasks takes 3 ^ n. thus the time complexity is k * (3 ^ n)\\n**Space complexity:** O(k * (2 ^ size(cookies)))\\n\\n\\n\\n***Do upvote if it helps***",
                "solutionTags": [
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int n = cookies.size();\\n        vector<vector<int>>dp(k + 1, vector<int>(1ll << n, INT_MAX));\\n        \\n        vector<int>sum(1ll << n);\\n        for(int mask = 0;mask<(1ll << n); mask++){\\n            int total = 0;\\n            for(int i = 0;i<n;i++){\\n                if(mask & (1ll << i)){\\n                    total += cookies[i];\\n                }\\n            }\\n            sum[mask] = total;\\n        }\\n\\n        dp[0][0] = 0;\\n        for(int person = 1;person<=k;person++){\\n            for(int mask = 0;mask<(1ll << n);mask++){\\n                for(int submask=mask;submask;submask=(submask - 1)&mask){\\n                    dp[person][mask] = min(dp[person][mask], max(sum[submask], dp[person - 1][mask ^ submask]));\\n                }\\n            }\\n        }\\n\\n        return dp[k][(1ll << n) - 1];\\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141268,
                "title": "just-don-t-overthink-do-as-question-said",
                "content": "Sometimes or most of the time, we programmers just make the problem more complex than it should be. The reason might be that we always love to solve problems without thinking about problems. So I also did this for this question. \\n# My mistakes :\\n1. Underestimate the constraints. I didn\\'t see the constraints carefully and my mind believe it should be solved in n or n * log n. So here the real game begins. Thought about binary search as my mind made a barrier and then it started looking like the same problem as Distributed candies. But was wrong.\\n2. After 10 min doing rough work without seeing the constraints now I got a point on constraints. And it was too low.\\n\\n# Suggestions :\\nWhen constraints are too loose in the contest/oa just follow the problem, don\\'t think optimize it first get the solution(might be possible you ruined your time to just get the optimal thought). If you got the basic solution and you have time then only look into the optimization. In the end, you need just AC don\\'t forget this line.\\n\\n# My intuition :\\nSo it\\'s as simple as the problem description. Let\\'s see some facts -\\n1. You can\\'t split the cookies. i.e. it\\'s not possible that you give some part of i-th cookies to j-th students and the rest to j+1-th students.\\n2. And there can be at most 8 students and at most 8 types of cookies.\\n3. So why don\\'t I just find all the combinations?\\n4. You have k choice for each cookie to assign it. Find all the way and consider the best one.\\n\\nHere is my code :\\n```\\nclass Solution {\\n    int []c;\\n    int []kval;\\n    int k;\\n    private int solve(int ic) {\\n      if(ic == c.length) {\\n        int res = 0;\\n        for(int i:kval) res = Math.max(res, i);\\n        return res;\\n      }\\n      int res = Integer.MAX_VALUE;\\n      for(int i=0;i<k;i++) {\\n        kval[i]+=c[ic];\\n        res = Math.min(res, solve(ic+1));\\n        kval[i]-=c[ic];\\n      }\\n      return res;\\n    }\\n  \\n    public int distributeCookies(int[] cookies, int k) {\\n      this.kval = new int[k];\\n      this.k = k;\\n      this.c= cookies;\\n      return solve(0);\\n    }\\n}\\n```\\n\\nAs @ray_striker suggested we can use dp here and optimize it further, which I couldn\\'t think in contest. You can check dp solution here. Please upvote for this cool solution.\\n\\nhttps://leetcode.com/problems/fair-distribution-of-cookies/discuss/2141573/DP-or-Submask-Enumeration-or-Most-Optimal-Solution-or-100-faster-or-C%2B%2B\\n\\n\\n**Please upvote this article if it helps you!\\nHappy coding**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int []c;\\n    int []kval;\\n    int k;\\n    private int solve(int ic) {\\n      if(ic == c.length) {\\n        int res = 0;\\n        for(int i:kval) res = Math.max(res, i);\\n        return res;\\n      }\\n      int res = Integer.MAX_VALUE;\\n      for(int i=0;i<k;i++) {\\n        kval[i]+=c[ic];\\n        res = Math.min(res, solve(ic+1));\\n        kval[i]-=c[ic];\\n      }\\n      return res;\\n    }\\n  \\n    public int distributeCookies(int[] cookies, int k) {\\n      this.kval = new int[k];\\n      this.k = k;\\n      this.c= cookies;\\n      return solve(0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2140935,
                "title": "java-backtracking-with-explanation",
                "content": "### Intuition\\nQ: Why using backtracking? \\nA: **check the constraints** (credit to [@manishpushkar\\'s comment](https://leetcode.com/problems/fair-distribution-of-cookies/discuss/2140935/Java-Backtracking-or-With-Explanation/1433567))\\n\\nthe backtracking takes `O(k^n)`\\nsince `2 <= k <= n <= 8`, it is an acceptable runtime\\n\\n### Steps\\n1. use an array `children` to store the total cookies for each child\\n2. for each cookie, try to distribute it to any child\\n3. if all the cookies are distributed, find the maximum cookie among children, and update the result\\n\\n### Complexity\\ntime: `O(k^n)` where n is cookies.length\\nspace: `O(k+n)` where k is children array, n is number of call stacks\\n\\n### Java\\n```java\\nint res = Integer.MAX_VALUE;\\npublic int distributeCookies(int[] cookies, int k) {\\n    dfs(cookies, 0, k, new int[k]);\\n    return res;\\n}\\n\\nvoid dfs(int[] cookies, int cur, int k, int[] children) {\\n    if (cur == cookies.length) {\\n        int max = 0;\\n        for (int c : children) max = Math.max(max, c);\\n        res = Math.min(res, max);\\n        return;\\n    }\\n    for (int i = 0; i < k; i++) {\\n        children[i] += cookies[cur];\\n        dfs(cookies, cur + 1, k, children);\\n        children[i] -= cookies[cur];\\n    }\\n}\\n```\\n\\nPlease let me know if there is anything unclear, thanks!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nint res = Integer.MAX_VALUE;\\npublic int distributeCookies(int[] cookies, int k) {\\n    dfs(cookies, 0, k, new int[k]);\\n    return res;\\n}\\n\\nvoid dfs(int[] cookies, int cur, int k, int[] children) {\\n    if (cur == cookies.length) {\\n        int max = 0;\\n        for (int c : children) max = Math.max(max, c);\\n        res = Math.min(res, max);\\n        return;\\n    }\\n    for (int i = 0; i < k; i++) {\\n        children[i] += cookies[cur];\\n        dfs(cookies, cur + 1, k, children);\\n        children[i] -= cookies[cur];\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2141220,
                "title": "c-binary-search-solution-with-explanation",
                "content": "```\\n/*\\nbinary search q, the binary search property is can i divide array into k parts with each part having sum<=s. if nnot so, then\\nany value less than s wont work, otherwise if true look for even lesser value of s for ans, give the min such value using binary search\\n*/\\n\\nclass Solution {\\npublic:\\n    bool check(int s, vector<int>a, int k)// a function to see if given sum s, can array a  be divided into  k parts, such that\\n        // sum of each part is just less than equal to s . we  take parts to have sum as close to s as possible,\\n        // now if no of parts <=k, then for less case we can easily increase no of parts to k, unless k>n but then it will never be possible to divide and that case is not in the constraints,\\n        //we check for all possiblities by checking all permutations\\n    {\\n        \\n        do{\\n        int parts=0;\\n        //remember to count in last part\\n        int sum=0;\\n        int n= a.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]>s)return false;\\n            sum+=a[i];\\n            if(sum >s)\\n            {\\n                sum=a[i];\\n                parts++;\\n            }\\n        }\\n        parts++;\\n        if(parts<=k)return true;\\n        } while(next_permutation(a.begin(),a.end()));\\n        return false;\\n        \\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n                  sort(cookies.begin(), cookies.end());\\n                int l=0;\\n        int r= 1000000;\\n        int ans=-1;\\n        \\n        while(l<=r)\\n        {\\n            int mid = (l+r)/2;\\n            if(check(mid,cookies,k))\\n            {\\n                 ans= mid;\\n                r= mid-1;\\n            }\\n            else l=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\n/*\\nbinary search q, the binary search property is can i divide array into k parts with each part having sum<=s. if nnot so, then\\nany value less than s wont work, otherwise if true look for even lesser value of s for ans, give the min such value using binary search\\n*/\\n\\nclass Solution {\\npublic:\\n    bool check(int s, vector<int>a, int k)// a function to see if given sum s, can array a  be divided into  k parts, such that\\n        // sum of each part is just less than equal to s . we  take parts to have sum as close to s as possible,\\n        // now if no of parts <=k, then for less case we can easily increase no of parts to k, unless k>n but then it will never be possible to divide and that case is not in the constraints,\\n        //we check for all possiblities by checking all permutations\\n    {\\n        \\n        do{\\n        int parts=0;\\n        //remember to count in last part\\n        int sum=0;\\n        int n= a.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]>s)return false;\\n            sum+=a[i];\\n            if(sum >s)\\n            {\\n                sum=a[i];\\n                parts++;\\n            }\\n        }\\n        parts++;\\n        if(parts<=k)return true;\\n        } while(next_permutation(a.begin(),a.end()));\\n        return false;\\n        \\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n                  sort(cookies.begin(), cookies.end());\\n                int l=0;\\n        int r= 1000000;\\n        int ans=-1;\\n        \\n        while(l<=r)\\n        {\\n            int mid = (l+r)/2;\\n            if(check(mid,cookies,k))\\n            {\\n                 ans= mid;\\n                r= mid-1;\\n            }\\n            else l=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141069,
                "title": "python-easy-solution-backtracking-recursion-branch-and-bound",
                "content": "```\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n        ans = float(\\'inf\\')\\n        fair = [0]*k\\n        def rec(i):\\n            nonlocal ans,fair\\n            if i == len(cookies):\\n                ans = min(ans,max(fair))\\n                return\\n\\t\\t\\t# Bounding condition to stop a branch if unfairness already exceeds current optimal soltution\\n\\t\\t\\tif ans <= max(fair):\\n                return\\n            for j in range(k):\\n                fair[j] += cookies[i]\\n                rec(i+1)\\n                fair[j] -= cookies[i]\\n        rec(0)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n        ans = float(\\'inf\\')\\n        fair = [0]*k\\n        def rec(i):\\n            nonlocal ans,fair\\n            if i == len(cookies):\\n                ans = min(ans,max(fair))\\n                return\\n\\t\\t\\t# Bounding condition to stop a branch if unfairness already exceeds current optimal soltution\\n\\t\\t\\tif ans <= max(fair):\\n                return\\n            for j in range(k):\\n                fair[j] += cookies[i]\\n                rec(i+1)\\n                fair[j] -= cookies[i]\\n        rec(0)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2140937,
                "title": "dfs-with-mask-0-ms",
                "content": "This is the same as [1723. Find Minimum Time to Finish All Jobs](https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/).  That problem is Hard, I think because `k` is limited to 12, not 8. \\n\\nThis is multi-knapsack problem, which is NP-complete, so we have to do a full search. For `k <= 12`, I needed to use a greedy result to prune, and check if two workers (children) have the same amount of work (candy), and assign a new job (give candy) to just one of them. Check out [this solution](https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/discuss/1009768/C%2B%2B-0ms-Use-Greedy-to-Prune) for the details.\\n\\nFor this problem, `k <= 8`, so a simple DFS is accepted. Memoisation it brings the runtime to a single-digit ms - and even to 0 ms with `popcount` pruning.\\n\\n> ![image](https://assets.leetcode.com/users/images/c02fbec1-8dba-4a47-b52c-840adae4a02c_1655014073.7249475.png)\\n\\nWe use a mask to represent bags selected for a given child. We iterate the mask from `1` to `254` to get all combinations.\\n\\n**C++**\\n```cpp\\nint dp[7][255] = {};\\nint mask_sum(vector<int>& cookies, int mask) {\\n    int sum = 0;\\n    for (int j = 0; j < cookies.size(); ++j)\\n        sum += (mask & (1 << j)) ? cookies[j] : 0;\\n    return sum;    \\n}\\nint distributeCookies(vector<int>& cookies, int k, int i = 0, int mask = 0) {\\n    int lim = (1 << cookies.size()) - 1;\\n    if (i == k - 1)\\n        return mask_sum(cookies, lim - mask);\\n    if (dp[i][mask] == 0) {\\n        dp[i][mask] = INT_MAX;\\n        for (int mask_i = 1; mask_i < lim; ++mask_i)\\n            if ((mask_i & mask) == 0 && __builtin_popcount(lim - mask_i - mask) >= k - i - 1)\\n                dp[i][mask] = min(dp[i][mask], \\n                    max(distributeCookies(cookies, k, i + 1, mask + mask_i), mask_sum(cookies, mask_i)));\\n    }\\n    return dp[i][mask];\\n}\\n```\\nThis is my solution for [1723. Find Minimum Time to Finish All Jobs](https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/), adapted for this problem.\\n**C++**\\n```cpp\\nint worker[12] = {}, res = 0;\\nint dfs(vector<int>& jobs, int i, int k, int cur) {\\n    if (cur >= res)\\n        return res;\\n    if (i == jobs.size())\\n        return res = cur;\\n    unordered_set<int> workTime;\\n    for (auto j = 0; j < k; ++j) {\\n        if (!workTime.insert(worker[j]).second)\\n            continue;\\n        worker[j] += jobs[i];\\n        dfs(jobs, i + 1, k, max(cur, worker[j]));\\n        worker[j] -= jobs[i];\\n    }\\n    return res;\\n}\\nint distributeCookies(vector<int>& jobs, int k) {\\n    if (k == jobs.size())\\n        return *max_element(begin(jobs), end(jobs));\\n    sort(begin(jobs), end(jobs), greater<int>());\\n    for (int i = 0; i < jobs.size(); i += k)\\n        res += jobs[i];\\n    return dfs(jobs, 0, k, 0);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint dp[7][255] = {};\\nint mask_sum(vector<int>& cookies, int mask) {\\n    int sum = 0;\\n    for (int j = 0; j < cookies.size(); ++j)\\n        sum += (mask & (1 << j)) ? cookies[j] : 0;\\n    return sum;    \\n}\\nint distributeCookies(vector<int>& cookies, int k, int i = 0, int mask = 0) {\\n    int lim = (1 << cookies.size()) - 1;\\n    if (i == k - 1)\\n        return mask_sum(cookies, lim - mask);\\n    if (dp[i][mask] == 0) {\\n        dp[i][mask] = INT_MAX;\\n        for (int mask_i = 1; mask_i < lim; ++mask_i)\\n            if ((mask_i & mask) == 0 && __builtin_popcount(lim - mask_i - mask) >= k - i - 1)\\n                dp[i][mask] = min(dp[i][mask], \\n                    max(distributeCookies(cookies, k, i + 1, mask + mask_i), mask_sum(cookies, mask_i)));\\n    }\\n    return dp[i][mask];\\n}\\n```\n```cpp\\nint worker[12] = {}, res = 0;\\nint dfs(vector<int>& jobs, int i, int k, int cur) {\\n    if (cur >= res)\\n        return res;\\n    if (i == jobs.size())\\n        return res = cur;\\n    unordered_set<int> workTime;\\n    for (auto j = 0; j < k; ++j) {\\n        if (!workTime.insert(worker[j]).second)\\n            continue;\\n        worker[j] += jobs[i];\\n        dfs(jobs, i + 1, k, max(cur, worker[j]));\\n        worker[j] -= jobs[i];\\n    }\\n    return res;\\n}\\nint distributeCookies(vector<int>& jobs, int k) {\\n    if (k == jobs.size())\\n        return *max_element(begin(jobs), end(jobs));\\n    sort(begin(jobs), end(jobs), greater<int>());\\n    for (int i = 0; i < jobs.size(); i += k)\\n        res += jobs[i];\\n    return dfs(jobs, 0, k, 0);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2144128,
                "title": "all-solutions-o-3-n-o-4-n-o-k-n-explained",
                "content": "**Solution 1: Backtracking O(k^n)**\\nLet\\'s try to analyze the number of possible distributions that can be there:\\nLet there be n elements in the array and k people.\\n\\nAny element `i` in the set of n elements has `k` choices: be taken by `1st person OR 2nd person OR 3rd person .... or kth person`.\\n\\n Therefore the total number of choices for all the n elements will be `k * k * k....(n times)` = `k^n`. \\n\\nWe can simulate the problem via backtracking since `max value of K = 8`, `max value of N = 8`.\\n\\n```\\nclass Solution {\\npublic:\\n    int dfs(int idx, vector<int>& person, vector<int>& cookies, int k) {\\n        if (idx == cookies.size()) { // We have distributed all the cookies\\n            return *max_element(person.begin(), person.end()); // The unfairness of this distribution\\n        }\\n        int ans = 1e8;\\n        // Cookie number idx can be given to any of the k persons\\n        for (int i = 0; i < k; i++) {\\n            person[i] += cookies[idx];\\n            // Calculating the minimum of all possible unfair distributions\\n            ans = min(ans, dfs(idx + 1, person, cookies, k));\\n            person[i] -= cookies[idx];\\n        }\\n        return ans;\\n    }\\n    \\n    int distributeCookies(vector<int>& cookies, int k) {\\n        vector<int> person(cookies.size());\\n        return dfs(0, person, cookies, k);\\n    }\\n};\\n```\\n\\n**Solution 2: DP O(k * 4^n)**\\nIf `sol(idx, mask)` is the function which gives us answer for the state: with `idx` indicating the number of the person whose turn it is to get the candies and `mask` indicating the `n-bit` bitmask for the candies array with the `ith` bit denoting if the element has already been taken or not. \\n\\nRecursive relation: \\nLet `sol(idx, mask)` denote the minimum unfairness value when we consider the person from [i...(k-1)] and current set of cookies is defined by mask.\\n\\n`sol(idx, mask) = MIN_FOR_ALL new_mask[ max(sol(idx + 1, new_mask), cost_of_new_mask) ]` where  `new_mask = {set of all possible bitmasks of size n such that new_mask & mask do not have any common set bits}`.\\n\\nMathematically: for any new_mask we can say `new_mask & mask = 0`\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> sum;\\n    int n, k, dp[15][1000];\\n    \\n    // TC: O(k * 2^n * 2^n) = O(k * 4^n)\\n    int sol(int i, int mask) { \\n        // If we have already selected for 0..k persons we have \\n        // reached the end, check if all elements have been \\n        // distributed if yes then return 0 else return + INF, so \\n        // this is ignored when we the calculate minimum.\\n        if (i == k) return (mask == ((1 << n) - 1)) ? 0 : 1e9;\\n        int& ans = dp[i][mask];\\n        if (ans != -1) return ans;\\n        ans = 1e9;\\n        // Traverse all masks and chose only that mask which satisfies\\n        // new_mask & mask == 0, i.e. there are no elements common\\n        // between the elements that were previous chosen(denoted by mask)\\n        // and the ones choosen for the new person (denoted by new_mask),\\n        // since a single element can only be selected once.\\n        for (int new_mask = 0; new_mask < (1<<n); new_mask++) {\\n            if ((new_mask & mask) == 0) {\\n                ans = min(ans, max(sum[new_mask], sol(i + 1, new_mask | mask)));\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int distributeCookies(vector<int>& cookies, int k) {\\n        this->k = k;\\n        n = cookies.size();\\n        // sum[i] = sum of elements present in set with mask as i\\n        // This is required so we can give the sum of elements of a certain \\n        // mask in constant amount of time\\n        // TC: O(n * 2^n)\\n        sum = vector<int>(1 << n, 0); \\n        for (int i = 0; i < (1 << n); i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (i & (1 << j)) {\\n                    sum[i] += cookies[j];\\n                }\\n            }\\n        }\\n        memset(dp, -1, sizeof(dp));\\n        return sol(0, 0);\\n    }\\n};\\n```\\n\\n**Solution 2: DP O(k * 3^n)**\\nNotice in above solution we are iterating over all subsets from `0 to 2^n - 1` to get the values for new_mask. We can optimize the above solution if we can somehow traverse only all the new_masks and not all the elements.\\n\\nFor an element `mask` we can traverse on all its subset of masks i.e. new_masks using:\\n```\\nfor (int new_mask = mask; new_mask > 0; new_mask= (new_mask- 1) & mask) {\\n\\t// Valid new_mask\\n}\\n```\\n\\nFor all elements from `0 to 2^n-1`, if we want to calculate the number of total iterations:\\n\\n1. For a mask with k one bits we will have `2^k` new_masks.\\n2. Number of elements in `0 to 2^n-1` with 0 bit set = `nC0` \\nNumber of elements in `0 to 2^n-1` with 1 bit set = `nC1`\\nNumber of elements in `0 to 2^n-1` with 2 bit set = `nC2`\\n..\\nNumber of elements in `0 to 2^n-1` with n bit set = `nCn` .\\n\\nTherefore, total number of iterations = `nC0 * (no_of_subset_with_mask_having_0_bit_set) + nC1 * (no_of_subset_with_mask_having_1_bit_set) + nC2 * (no_of_subset_with_mask_having_2_bit_set) + .... nCn (no_of_subset_with_mask_having_n_bit_set)`\\n\\n = `nC0 * 2^0 + nC1 * 2^1 + nC2 * 2^2 + .... + nCn * 2^n`\\n Using binomial expansion we can write it as \\n= `(1 + x)^n` where x = 2\\n= `3^n`\\n\\nModified code:\\n```\\nclass Solution {\\npublic:\\n    vector<int> sum;\\n    int n, k, dp[15][1000];\\n    \\n    // TC: O(k * 3^n)\\n    int sol(int i, int mask) { \\n        // If we have already selected for 0..k persons we have \\n        // reached the end, check if all elements have been \\n        // distributed if yes then return 0 else return + INF, so \\n        // this is ignored when we the calculate minimum.\\n        if (i == k) return (mask == ((1 << n) - 1)) ? 0 : 1e9;\\n        int& ans = dp[i][mask];\\n        if (ans != -1) return ans;\\n        ans = 1e9;\\n        // Traverse all masks and chose only that mask which satisfies\\n        // new_mask & mask == 0, i.e. there are no elements common\\n        // between the elements that were previous chosen(denoted by mask)\\n        // and the ones choosen for the new person (denoted by new_mask),\\n        // since a single element can only be selected once.\\n        int leftMask = ((1 << n) - 1) - mask;\\n        // If mask = 10110 then leftMask = 01001, i.e. all 1 -> 0 and 0 -> 1.\\n        // We make subsets of leftMask since those are our available options\\n        for (int new_mask = leftMask; new_mask > 0; new_mask = (new_mask - 1) & leftMask) {\\n            ans = min(ans, max(sum[new_mask], sol(i + 1, new_mask | mask)));\\n        }\\n        return ans;\\n    }\\n    \\n    int distributeCookies(vector<int>& cookies, int k) {\\n        this->k = k;\\n        n = cookies.size();\\n        // sum[i] = sum of elements present in set with mask as i\\n        // This is required so we can give the sum of elements of a certain \\n        // mask in constant amount of time\\n        // TC: O(n * 2^n)\\n        sum = vector<int>(1 << n, 0); \\n        for (int i = 0; i < (1 << n); i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (i & (1 << j)) {\\n                    sum[i] += cookies[j];\\n                }\\n            }\\n        }\\n        memset(dp, -1, sizeof(dp));\\n        return sol(0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int idx, vector<int>& person, vector<int>& cookies, int k) {\\n        if (idx == cookies.size()) { // We have distributed all the cookies\\n            return *max_element(person.begin(), person.end()); // The unfairness of this distribution\\n        }\\n        int ans = 1e8;\\n        // Cookie number idx can be given to any of the k persons\\n        for (int i = 0; i < k; i++) {\\n            person[i] += cookies[idx];\\n            // Calculating the minimum of all possible unfair distributions\\n            ans = min(ans, dfs(idx + 1, person, cookies, k));\\n            person[i] -= cookies[idx];\\n        }\\n        return ans;\\n    }\\n    \\n    int distributeCookies(vector<int>& cookies, int k) {\\n        vector<int> person(cookies.size());\\n        return dfs(0, person, cookies, k);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> sum;\\n    int n, k, dp[15][1000];\\n    \\n    // TC: O(k * 2^n * 2^n) = O(k * 4^n)\\n    int sol(int i, int mask) { \\n        // If we have already selected for 0..k persons we have \\n        // reached the end, check if all elements have been \\n        // distributed if yes then return 0 else return + INF, so \\n        // this is ignored when we the calculate minimum.\\n        if (i == k) return (mask == ((1 << n) - 1)) ? 0 : 1e9;\\n        int& ans = dp[i][mask];\\n        if (ans != -1) return ans;\\n        ans = 1e9;\\n        // Traverse all masks and chose only that mask which satisfies\\n        // new_mask & mask == 0, i.e. there are no elements common\\n        // between the elements that were previous chosen(denoted by mask)\\n        // and the ones choosen for the new person (denoted by new_mask),\\n        // since a single element can only be selected once.\\n        for (int new_mask = 0; new_mask < (1<<n); new_mask++) {\\n            if ((new_mask & mask) == 0) {\\n                ans = min(ans, max(sum[new_mask], sol(i + 1, new_mask | mask)));\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int distributeCookies(vector<int>& cookies, int k) {\\n        this->k = k;\\n        n = cookies.size();\\n        // sum[i] = sum of elements present in set with mask as i\\n        // This is required so we can give the sum of elements of a certain \\n        // mask in constant amount of time\\n        // TC: O(n * 2^n)\\n        sum = vector<int>(1 << n, 0); \\n        for (int i = 0; i < (1 << n); i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (i & (1 << j)) {\\n                    sum[i] += cookies[j];\\n                }\\n            }\\n        }\\n        memset(dp, -1, sizeof(dp));\\n        return sol(0, 0);\\n    }\\n};\\n```\n```\\nfor (int new_mask = mask; new_mask > 0; new_mask= (new_mask- 1) & mask) {\\n\\t// Valid new_mask\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> sum;\\n    int n, k, dp[15][1000];\\n    \\n    // TC: O(k * 3^n)\\n    int sol(int i, int mask) { \\n        // If we have already selected for 0..k persons we have \\n        // reached the end, check if all elements have been \\n        // distributed if yes then return 0 else return + INF, so \\n        // this is ignored when we the calculate minimum.\\n        if (i == k) return (mask == ((1 << n) - 1)) ? 0 : 1e9;\\n        int& ans = dp[i][mask];\\n        if (ans != -1) return ans;\\n        ans = 1e9;\\n        // Traverse all masks and chose only that mask which satisfies\\n        // new_mask & mask == 0, i.e. there are no elements common\\n        // between the elements that were previous chosen(denoted by mask)\\n        // and the ones choosen for the new person (denoted by new_mask),\\n        // since a single element can only be selected once.\\n        int leftMask = ((1 << n) - 1) - mask;\\n        // If mask = 10110 then leftMask = 01001, i.e. all 1 -> 0 and 0 -> 1.\\n        // We make subsets of leftMask since those are our available options\\n        for (int new_mask = leftMask; new_mask > 0; new_mask = (new_mask - 1) & leftMask) {\\n            ans = min(ans, max(sum[new_mask], sol(i + 1, new_mask | mask)));\\n        }\\n        return ans;\\n    }\\n    \\n    int distributeCookies(vector<int>& cookies, int k) {\\n        this->k = k;\\n        n = cookies.size();\\n        // sum[i] = sum of elements present in set with mask as i\\n        // This is required so we can give the sum of elements of a certain \\n        // mask in constant amount of time\\n        // TC: O(n * 2^n)\\n        sum = vector<int>(1 << n, 0); \\n        for (int i = 0; i < (1 << n); i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (i & (1 << j)) {\\n                    sum[i] += cookies[j];\\n                }\\n            }\\n        }\\n        memset(dp, -1, sizeof(dp));\\n        return sol(0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702352,
                "title": "beats-100-video-java-c-python",
                "content": "<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/vvC6wWkaIHA\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n```\\nclass Solution {\\n    int ans;\\n    int count[];\\n    public int distributeCookies(int[] cookies, int k) {\\n        ans= Integer.MAX_VALUE;\\n        count= new int[k];\\n\\n        backtrack(0,cookies, k);\\n        return ans;\\n    }\\n    public void backtrack(int cookieNumber, int[] cookies, int k)\\n    {\\n        if(cookieNumber==cookies.length)\\n        {\\n            int max= 0;\\n            for(int i=0; i<k; i++)\\n            {\\n                max=Math.max(max, count[i]);\\n\\n            }\\n            ans = Math.min(ans, max);\\n            return;\\n        }\\n        for(int i=0;i<k; i++)\\n        {\\n            count[i]+=cookies[cookieNumber];\\n            backtrack(cookieNumber+1, cookies, k);\\n            count[i]-=cookies[cookieNumber];\\n            if(count[i]==0) break;\\n        }\\n    }\\n}\\n```\\n\\n```\\n#include <climits>\\nclass Solution {\\npublic:\\n    int ans;\\n    std::vector<int> count;\\n    \\n    int distributeCookies(std::vector<int>& cookies, int k) {\\n        ans = INT_MAX;\\n        count.resize(k);\\n\\n        backtrack(0, cookies, k);\\n        return ans;\\n    }\\n    \\n    void backtrack(int cookieNumber, std::vector<int>& cookies, int k) {\\n        if (cookieNumber == cookies.size()) {\\n            int max = 0;\\n            for (int i = 0; i < k; i++) {\\n                max = std::max(max, count[i]);\\n            }\\n            ans = std::min(ans, max);\\n            return;\\n        }\\n        \\n        for (int i = 0; i < k; i++) {\\n            count[i] += cookies[cookieNumber];\\n            backtrack(cookieNumber + 1, cookies, k);\\n            count[i] -= cookies[cookieNumber];\\n            if (count[i] == 0) {\\n                break;\\n            }\\n        }\\n    }\\n};\\n\\n```\\n\\n```\\nclass Solution:\\n    def distributeCookies(self, cookies, k):\\n        self.ans = float(\\'inf\\')\\n        self.count = [0] * k\\n\\n        self.backtrack(0, cookies, k)\\n        return self.ans\\n\\n    def backtrack(self, cookieNumber, cookies, k):\\n        if cookieNumber == len(cookies):\\n            maximum = max(self.count)\\n            self.ans = min(self.ans, maximum)\\n            return\\n\\n        for i in range(k):\\n            self.count[i] += cookies[cookieNumber]\\n            self.backtrack(cookieNumber + 1, cookies, k)\\n            self.count[i] -= cookies[cookieNumber]\\n            if self.count[i] == 0:\\n                break\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    int ans;\\n    int count[];\\n    public int distributeCookies(int[] cookies, int k) {\\n        ans= Integer.MAX_VALUE;\\n        count= new int[k];\\n\\n        backtrack(0,cookies, k);\\n        return ans;\\n    }\\n    public void backtrack(int cookieNumber, int[] cookies, int k)\\n    {\\n        if(cookieNumber==cookies.length)\\n        {\\n            int max= 0;\\n            for(int i=0; i<k; i++)\\n            {\\n                max=Math.max(max, count[i]);\\n\\n            }\\n            ans = Math.min(ans, max);\\n            return;\\n        }\\n        for(int i=0;i<k; i++)\\n        {\\n            count[i]+=cookies[cookieNumber];\\n            backtrack(cookieNumber+1, cookies, k);\\n            count[i]-=cookies[cookieNumber];\\n            if(count[i]==0) break;\\n        }\\n    }\\n}\\n```\n```\\n#include <climits>\\nclass Solution {\\npublic:\\n    int ans;\\n    std::vector<int> count;\\n    \\n    int distributeCookies(std::vector<int>& cookies, int k) {\\n        ans = INT_MAX;\\n        count.resize(k);\\n\\n        backtrack(0, cookies, k);\\n        return ans;\\n    }\\n    \\n    void backtrack(int cookieNumber, std::vector<int>& cookies, int k) {\\n        if (cookieNumber == cookies.size()) {\\n            int max = 0;\\n            for (int i = 0; i < k; i++) {\\n                max = std::max(max, count[i]);\\n            }\\n            ans = std::min(ans, max);\\n            return;\\n        }\\n        \\n        for (int i = 0; i < k; i++) {\\n            count[i] += cookies[cookieNumber];\\n            backtrack(cookieNumber + 1, cookies, k);\\n            count[i] -= cookies[cookieNumber];\\n            if (count[i] == 0) {\\n                break;\\n            }\\n        }\\n    }\\n};\\n\\n```\n```\\nclass Solution:\\n    def distributeCookies(self, cookies, k):\\n        self.ans = float(\\'inf\\')\\n        self.count = [0] * k\\n\\n        self.backtrack(0, cookies, k)\\n        return self.ans\\n\\n    def backtrack(self, cookieNumber, cookies, k):\\n        if cookieNumber == len(cookies):\\n            maximum = max(self.count)\\n            self.ans = min(self.ans, maximum)\\n            return\\n\\n        for i in range(k):\\n            self.count[i] += cookies[cookieNumber]\\n            self.backtrack(cookieNumber + 1, cookies, k)\\n            self.count[i] -= cookies[cookieNumber]\\n            if self.count[i] == 0:\\n                break\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3702883,
                "title": "c-backtracking",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>v;\\n    int ans;\\n    void help(vector<int>&c,int k,int index){\\n        if(index == c.size()){\\n            int total = INT_MIN;\\n            for(int i=0;i<k;i++){\\n                total = max(total,v[i]);\\n            }\\n            ans = min(ans,total);\\n            return;\\n        }\\n        for(int i=0;i<k;i++){\\n            v[i] += c[index];\\n            help(c,k,index+1);\\n            v[i] -= c[index];\\n        }\\n    }\\n    int distributeCookies(vector<int>& c, int k) {\\n        ans = INT_MAX;\\n        v.resize(k,0);\\n        help(c,k,0);\\n        return ans;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/374e8ae5-27f8-484a-98df-e04861c7a1c8_1688191552.5648377.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>v;\\n    int ans;\\n    void help(vector<int>&c,int k,int index){\\n        if(index == c.size()){\\n            int total = INT_MIN;\\n            for(int i=0;i<k;i++){\\n                total = max(total,v[i]);\\n            }\\n            ans = min(ans,total);\\n            return;\\n        }\\n        for(int i=0;i<k;i++){\\n            v[i] += c[index];\\n            help(c,k,index+1);\\n            v[i] -= c[index];\\n        }\\n    }\\n    int distributeCookies(vector<int>& c, int k) {\\n        ans = INT_MAX;\\n        v.resize(k,0);\\n        help(c,k,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634043,
                "title": "python-efficient-backtracking-fully-explained",
                "content": "# Intuition\\nDistribute one bag at the time. Take advantage that the order of the kids does not matter to avoid duplicate distributions. Give a bag to a kid only if his new total is less than our best solution so far. \\n\\n# Approach\\nDFS with the index of the next bag to be given as parameter. The array `split` contains the quantities for the kids that already got cookies. For each bag either give it to a new kid (if possible) or give it to a kid that already has cookies (as long as he will still have less than the min unfairness already found).\\n\\n# Code\\n```\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n        def dfs(p):\\n            nonlocal best\\n            if p==len(cookies):\\n                best = min(best, max(split))\\n                return\\n            # give to a new kid\\n            if len(split)<k:\\n                split.append(cookies[p])\\n                dfs(p+1)\\n                split.pop()\\n            # give to a kid that already has cookies\\n            for i in range(len(split)):\\n                if split[i]+cookies[p] < best:\\n                    split[i] += cookies[p]\\n                    dfs(p+1)\\n                    split[i] -= cookies[p]\\n\\n        split = []\\n        best = float(\"inf\")\\n        dfs(0)\\n        return best\\n```\\n\\n# Further optimization ideas\\n\\nWe can avoid giving the bag to kids that have the same amount of cookies using a `seen` set.\\n\\n```\\n            # give to a kid that already has candy\\n            seen = set()\\n            for i in range(len(split)):\\n                if split[i]+cookies[p] < best and split[i] not in seen:\\n                    seen.add(split[i])\\n                    split[i] += cookies[p]\\n                    dfs(p+1)\\n                    split[i] -= cookies[p]\\n```\\n\\nWe can keep the `split` array sorted in descending order, to try to get to the better solutions faster and consequently avoid trying larger number of distributions that can\\'t improve the current best solution.\\n\\nThese will make sense for higher values for `n` and `k` (the problem only allows values up to 8). \\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n        def dfs(p):\\n            nonlocal best\\n            if p==len(cookies):\\n                best = min(best, max(split))\\n                return\\n            # give to a new kid\\n            if len(split)<k:\\n                split.append(cookies[p])\\n                dfs(p+1)\\n                split.pop()\\n            # give to a kid that already has cookies\\n            for i in range(len(split)):\\n                if split[i]+cookies[p] < best:\\n                    split[i] += cookies[p]\\n                    dfs(p+1)\\n                    split[i] -= cookies[p]\\n\\n        split = []\\n        best = float(\"inf\")\\n        dfs(0)\\n        return best\\n```\n```\\n            # give to a kid that already has candy\\n            seen = set()\\n            for i in range(len(split)):\\n                if split[i]+cookies[p] < best and split[i] not in seen:\\n                    seen.add(split[i])\\n                    split[i] += cookies[p]\\n                    dfs(p+1)\\n                    split[i] -= cookies[p]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702322,
                "title": "w-explanation-c-python-with-recursive-dp-bitmask",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n It uses dynamic programming with memoization. The code recursively calculates the minimum unfairness by considering different subsets of cookies in each bag. It optimizes the calculations by using bitwise operations and stores the results in a 2D array. The main function initializes the array, starts the recursive calculation, and returns the minimum unfairness. The code aims to distribute the cookies evenly among the children while minimizing the difference in the number of cookies received.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n[Please turn on English subtitles if neccessary]\\n[https://youtu.be/0AOyrZHu604](https://youtu.be/0AOyrZHu604)\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$ O(k * n * 2^n) $\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$ O(k * 2^n) $\\n# Code\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int unfairness(vector<int>& cookies, int n, int k, int bagMask) {\\n        if (dp[k][bagMask] != -1) return dp[k][bagMask];\\n        \\n        auto sum_cookies=[&](int Mask)-> int{\\n            int sum = 0;\\n            for (int i = 0; i < n; i++) {\\n                if (Mask & (1 << i))\\n                    sum += cookies[i];\\n            }\\n            return sum;\\n        };\\n\\n        if (k == 1) \\n            return dp[k][bagMask] = sum_cookies(bagMask);\\n\\n        int ans = INT_MAX;\\n        for (int Mask = bagMask; Mask > 0; Mask = (Mask - 1) & bagMask) {\\n            int sum1 = sum_cookies(Mask);\\n            int sum2 = unfairness(cookies, n, k - 1, bagMask ^ Mask);\\n            ans = min(ans, max(sum1, sum2));\\n        }\\n\\n        return dp[k][bagMask] = ans;\\n    }\\n\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int n = cookies.size();\\n        dp.assign(k + 1, vector<int>(1 << n, -1));\\n        return unfairness(cookies, n, k, (1 << n) - 1);\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n        n = len(cookies)\\n        dp = [[-1] * (1 << n) for _ in range(k + 1)]\\n        \\n        def unfairness(k, bagMask):\\n            if dp[k][bagMask] != -1: \\n                return dp[k][bagMask]\\n            \\n            def sum_cookies(Mask):\\n                sum=0\\n                for i in range(n):\\n                    if Mask&(1<<i):\\n                        sum+=cookies[i]\\n                return sum\\n            # end of  sum_cookies \\n            if k==1:\\n                dp[k][bagMask] = sum_cookies(bagMask)\\n                return dp[k][bagMask]\\n            ans=2**31\\n            Mask=bagMask\\n            while(Mask>0):\\n                sum1=sum_cookies(Mask)\\n                sum2=unfairness(k - 1, bagMask ^ Mask)\\n                ans=min(ans, max(sum1, sum2))\\n                Mask=(Mask - 1) & bagMask\\n            dp[k][bagMask] = ans\\n            return ans\\n        # end of unfairness\\n        return unfairness(k, (1 << n) - 1)\\n\\n```\\n# Code w Explanation in comments\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    \\n    // Function to calculate the unfairness using dynamic programming\\n    int unfairness(vector<int>& cookies, int n, int k, int bagMask) {\\n        // If the subproblem has already been solved, return the pre-calculated value\\n        if (dp[k][bagMask] != -1)\\n            return dp[k][bagMask];\\n        \\n        // Function to calculate the sum of cookies in a bag based on the Mask\\n        auto sum_cookies = [&](int Mask) -> int {\\n            int sum = 0;\\n            for (int i = 0; i < n; i++) {\\n                // Check if the ith cookie is included in the bag\\n                if (Mask & (1 << i))\\n                    sum += cookies[i];\\n            }\\n            return sum;\\n        };\\n\\n        // Base case: If there is only one bag remaining, return the sum of cookies in the bag\\n        if (k == 1) \\n            return dp[k][bagMask] = sum_cookies(bagMask);\\n\\n        int ans = INT_MAX;\\n        // Iterate over all possible subsets of the cookies in the bag\\n        for (int Mask = bagMask; Mask > 0; Mask = (Mask - 1) & bagMask) {\\n            // Calculate the sum of cookies in the current subset\\n            int sum1 = sum_cookies(Mask);\\n            // Recursively solve the subproblem for the remaining bags\\n            int sum2 = unfairness(cookies, n, k - 1, bagMask ^ Mask);\\n            // Update the minimum unfairness by considering the maximum of the current subset and the subproblem solution\\n            ans = min(ans, max(sum1, sum2));\\n        }\\n\\n        // Store the minimum unfairness in the dp array for future reference and return it\\n        return dp[k][bagMask] = ans;\\n    }\\n\\n    // Main function to distribute cookies among children while minimizing unfairness\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int n = cookies.size();\\n        // Initialize the dp array with -1 to indicate that subproblems have not been solved yet\\n        dp.assign(k + 1, vector<int>(1 << n, -1));\\n        // Start the recursive dynamic programming solution from the full bag mask\\n        return unfairness(cookies, n, k, (1 << n) - 1);\\n    }\\n};\\n\\n```\\n![DALL\\xB7E 2023-07-01 11.19.29 -  there  are many open bags of cookies beside the dog, Please present in a realistic style..png](https://assets.leetcode.com/users/images/fc580710-297a-4b48-8f64-c225af2b3f25_1688181628.5789618.png)\\n",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Dynamic Programming",
                    "Bit Manipulation"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int unfairness(vector<int>& cookies, int n, int k, int bagMask) {\\n        if (dp[k][bagMask] != -1) return dp[k][bagMask];\\n        \\n        auto sum_cookies=[&](int Mask)-> int{\\n            int sum = 0;\\n            for (int i = 0; i < n; i++) {\\n                if (Mask & (1 << i))\\n                    sum += cookies[i];\\n            }\\n            return sum;\\n        };\\n\\n        if (k == 1) \\n            return dp[k][bagMask] = sum_cookies(bagMask);\\n\\n        int ans = INT_MAX;\\n        for (int Mask = bagMask; Mask > 0; Mask = (Mask - 1) & bagMask) {\\n            int sum1 = sum_cookies(Mask);\\n            int sum2 = unfairness(cookies, n, k - 1, bagMask ^ Mask);\\n            ans = min(ans, max(sum1, sum2));\\n        }\\n\\n        return dp[k][bagMask] = ans;\\n    }\\n\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int n = cookies.size();\\n        dp.assign(k + 1, vector<int>(1 << n, -1));\\n        return unfairness(cookies, n, k, (1 << n) - 1);\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n        n = len(cookies)\\n        dp = [[-1] * (1 << n) for _ in range(k + 1)]\\n        \\n        def unfairness(k, bagMask):\\n            if dp[k][bagMask] != -1: \\n                return dp[k][bagMask]\\n            \\n            def sum_cookies(Mask):\\n                sum=0\\n                for i in range(n):\\n                    if Mask&(1<<i):\\n                        sum+=cookies[i]\\n                return sum\\n            # end of  sum_cookies \\n            if k==1:\\n                dp[k][bagMask] = sum_cookies(bagMask)\\n                return dp[k][bagMask]\\n            ans=2**31\\n            Mask=bagMask\\n            while(Mask>0):\\n                sum1=sum_cookies(Mask)\\n                sum2=unfairness(k - 1, bagMask ^ Mask)\\n                ans=min(ans, max(sum1, sum2))\\n                Mask=(Mask - 1) & bagMask\\n            dp[k][bagMask] = ans\\n            return ans\\n        # end of unfairness\\n        return unfairness(k, (1 << n) - 1)\\n\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    \\n    // Function to calculate the unfairness using dynamic programming\\n    int unfairness(vector<int>& cookies, int n, int k, int bagMask) {\\n        // If the subproblem has already been solved, return the pre-calculated value\\n        if (dp[k][bagMask] != -1)\\n            return dp[k][bagMask];\\n        \\n        // Function to calculate the sum of cookies in a bag based on the Mask\\n        auto sum_cookies = [&](int Mask) -> int {\\n            int sum = 0;\\n            for (int i = 0; i < n; i++) {\\n                // Check if the ith cookie is included in the bag\\n                if (Mask & (1 << i))\\n                    sum += cookies[i];\\n            }\\n            return sum;\\n        };\\n\\n        // Base case: If there is only one bag remaining, return the sum of cookies in the bag\\n        if (k == 1) \\n            return dp[k][bagMask] = sum_cookies(bagMask);\\n\\n        int ans = INT_MAX;\\n        // Iterate over all possible subsets of the cookies in the bag\\n        for (int Mask = bagMask; Mask > 0; Mask = (Mask - 1) & bagMask) {\\n            // Calculate the sum of cookies in the current subset\\n            int sum1 = sum_cookies(Mask);\\n            // Recursively solve the subproblem for the remaining bags\\n            int sum2 = unfairness(cookies, n, k - 1, bagMask ^ Mask);\\n            // Update the minimum unfairness by considering the maximum of the current subset and the subproblem solution\\n            ans = min(ans, max(sum1, sum2));\\n        }\\n\\n        // Store the minimum unfairness in the dp array for future reference and return it\\n        return dp[k][bagMask] = ans;\\n    }\\n\\n    // Main function to distribute cookies among children while minimizing unfairness\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int n = cookies.size();\\n        // Initialize the dp array with -1 to indicate that subproblems have not been solved yet\\n        dp.assign(k + 1, vector<int>(1 << n, -1));\\n        // Start the recursive dynamic programming solution from the full bag mask\\n        return unfairness(cookies, n, k, (1 << n) - 1);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2140978,
                "title": "c-backtracking-binary-search-next-permutation",
                "content": "**Approach 1:** \\n1. Create a `k` buckets space and try to fill it with all possible `permutation` of cookies.\\n2. Answer will be the `minimum` of all `maximum` values of `k` buckets.\\n\\n**Time:** `O(K^N)`\\n**Space:** `O(K) + Recursion stack`\\n```\\nclass Solution {\\npublic:\\n    int ans;\\n    void backtrack(int pos, vector<int>& cookies, vector<int>& buckets, int maxx){\\n        if(pos == cookies.size()){\\n            ans = min(ans, maxx);\\n            return;\\n        }\\n        for(int b = 0; b < buckets.size(); b++){\\n            buckets[b] += cookies[pos];\\n            backtrack(pos + 1, cookies, buckets, max(maxx, buckets[b]));\\n            buckets[b] -= cookies[pos];\\n        }\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        ans = INT_MAX;\\n        vector<int> buckets(k, 0);\\n        backtrack(0, cookies, buckets, 0);\\n        return ans;\\n    }\\n};\\n```\\n**Approach 2**\\nObservation of this problem is that `Split the given array into K sub-arrays such that maximum sum of all sub arrays is minimum`. Which is a common problem but how to apply this into this problem. So we can pick any order and the given array length is `8`. So if we permutate the array and calculate the result then `answer` will the `minimum` of all `answer`.\\n\\n**Time:** `O(N! * log N)`\\n**Space** `O(1)`\\n\\n```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>& nums, int mid, int k){\\n        int count = 0, sum = 0, n = nums.size();\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] > mid) return false;\\n            sum += nums[i];\\n            if(sum > mid){\\n                count++;\\n                sum = nums[i];\\n            }\\n        }\\n        count++;\\n        if(count <= k) return true;\\n        return false;\\n    }\\n    int bSearch(vector<int>& cookies, int low, int high, int k){\\n        int ans = 0;\\n        while(low <= high){\\n            int mid = (low + high) / 2;\\n            if(solve(cookies, mid, k)){\\n                ans = mid;\\n                high = mid - 1;\\n            }\\n            else{\\n                low = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        sort(cookies.begin(), cookies.end());\\n        int low = *max_element(cookies.begin(), cookies.end());\\n        int high = accumulate(cookies.begin(), cookies.end(), 0);\\n        int ans = INT_MAX;\\n        do{\\n            ans = min(ans, bSearch(cookies, low, high, k));\\n        }while(next_permutation(cookies.begin(), cookies.end()));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans;\\n    void backtrack(int pos, vector<int>& cookies, vector<int>& buckets, int maxx){\\n        if(pos == cookies.size()){\\n            ans = min(ans, maxx);\\n            return;\\n        }\\n        for(int b = 0; b < buckets.size(); b++){\\n            buckets[b] += cookies[pos];\\n            backtrack(pos + 1, cookies, buckets, max(maxx, buckets[b]));\\n            buckets[b] -= cookies[pos];\\n        }\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        ans = INT_MAX;\\n        vector<int> buckets(k, 0);\\n        backtrack(0, cookies, buckets, 0);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>& nums, int mid, int k){\\n        int count = 0, sum = 0, n = nums.size();\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] > mid) return false;\\n            sum += nums[i];\\n            if(sum > mid){\\n                count++;\\n                sum = nums[i];\\n            }\\n        }\\n        count++;\\n        if(count <= k) return true;\\n        return false;\\n    }\\n    int bSearch(vector<int>& cookies, int low, int high, int k){\\n        int ans = 0;\\n        while(low <= high){\\n            int mid = (low + high) / 2;\\n            if(solve(cookies, mid, k)){\\n                ans = mid;\\n                high = mid - 1;\\n            }\\n            else{\\n                low = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        sort(cookies.begin(), cookies.end());\\n        int low = *max_element(cookies.begin(), cookies.end());\\n        int high = accumulate(cookies.begin(), cookies.end(), 0);\\n        int ans = INT_MAX;\\n        do{\\n            ans = min(ans, bSearch(cookies, low, high, k));\\n        }while(next_permutation(cookies.begin(), cookies.end()));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702257,
                "title": "if-it-works-it-works-easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Firstly, it seemed like a binary search question to me, but it failed repeatedly. Then I noticed the constraints (n<=8), but I was still curious why binary search didn\\'t work.\\n\\n- After struggling, I went through other solutions and discovered that binary search didn\\'t work for anyone. So, let\\'s proceed with a simple recursive approach.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Create a new vector a of size k to represent subsets. Since the constraints are low (n<=8), we can generate all possible subsets of size k.\\n\\n- Call the solve function.\\n- Consider the base cases: If all elements have been considered,calculate the maximum number of cookies distributed according to the current subset.Return this value as ans.\\n- After checking the base condition, create a variable \\'mn\\' and initialize it with the maximum value.\\n- Iterate over each subset:\\n- Add the current element to the subset and keep track of the minimum sum obtained by comparing it with the value obtained from the recursive call.\\n- Subtract the current element from the subset and move on to the next one.\\n- Return the \\'ans\\' as the final result.\\n\\n# Complexity\\n- Time complexity: O(n^K)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>&v,int i,vector<int>&a){\\n        if(i==v.size()){\\n            int ans=0;\\n            for(auto it : a)ans=max(ans,it);\\n            return ans;\\n        }\\n        int mn=INT_MAX;\\n        for(int j=0;j<a.size();j++){\\n            a[j]+=v[i];\\n            mn=min(mn,solve(v,i+1,a));\\n            a[j]-=v[i];\\n        }\\n        return mn;\\n    }\\n    int distributeCookies(vector<int>&v, int k) {\\n        int i,n=v.size();\\n        vector<int>a(k);\\n        return solve(v,0,a);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>&v,int i,vector<int>&a){\\n        if(i==v.size()){\\n            int ans=0;\\n            for(auto it : a)ans=max(ans,it);\\n            return ans;\\n        }\\n        int mn=INT_MAX;\\n        for(int j=0;j<a.size();j++){\\n            a[j]+=v[i];\\n            mn=min(mn,solve(v,i+1,a));\\n            a[j]-=v[i];\\n        }\\n        return mn;\\n    }\\n    int distributeCookies(vector<int>&v, int k) {\\n        int i,n=v.size();\\n        vector<int>a(k);\\n        return solve(v,0,a);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704348,
                "title": "python-solution-backtracking-recursion-o-k-n",
                "content": "**PLEASE UPVOTE if you like \\uD83D\\uDE01 If you have any question, feel free to ask.**\\n# Intuition\\nRecursion and Backtracking\\nTry all distribution possibilities and return the minimum unfairness of all distribution.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Complexity\\n- Time complexity:O(K^N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(K)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n        #Backtracking\\n        def solve(ind,arr):\\n            if ind==n:\\n                nonlocal ans\\n                mx=max(arr)\\n                ans=min(ans,mx)\\n                return\\n            for i in range(k):\\n                arr[i]+=cookies[ind]\\n                solve(ind+1,arr)\\n                arr[i]-=cookies[ind]\\n                if arr[i]==0:\\n                    break\\n\\n        n=len(cookies)\\n        ans=float(\\'inf\\')\\n        arr=[0 for i in range(k)]\\n        solve(0,arr)\\n        return ans\\n\\n        \\n```\\n![cat.jpeg](https://assets.leetcode.com/users/images/5f4610c5-3513-4ad3-bc36-e1737376a191_1688216727.049382.jpeg)\\n",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n        #Backtracking\\n        def solve(ind,arr):\\n            if ind==n:\\n                nonlocal ans\\n                mx=max(arr)\\n                ans=min(ans,mx)\\n                return\\n            for i in range(k):\\n                arr[i]+=cookies[ind]\\n                solve(ind+1,arr)\\n                arr[i]-=cookies[ind]\\n                if arr[i]==0:\\n                    break\\n\\n        n=len(cookies)\\n        ans=float(\\'inf\\')\\n        arr=[0 for i in range(k)]\\n        solve(0,arr)\\n        return ans\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702644,
                "title": "c-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->The problem appears to involve distributing cookies into jars in a way that minimizes the maximum value of any jar. Here are my initial thoughts on how to approach this problem:\\n\\n1. The code uses a depth-first search (DFS) approach to explore different distribution possibilities. The DFS recursion is used to distribute cookies into jars one by one, considering two scenarios: adding the cookie to an existing jar or creating a new jar for the cookie.\\n\\n2. The function `dfs` is responsible for recursively distributing cookies and updating the maximum jar value (`curr`) and the minimum maximum jar value (`res`).\\n\\n3. The base case of the DFS recursion is when all cookies have been distributed. At this point, the maximum value among all jars (`curr`) is calculated, and `res` is updated with the minimum of `res` and `curr`.\\n\\n4. The code maintains a vector `d` to keep track of the current values in each jar. The size of the `d` vector is initialized to `k`, the number of jars.\\n\\n5. The `dfs` function explores all possible distributions by iterating through the cookies and considering two options: adding the cookie to an existing jar (incrementing the value in `d[i]`) or creating a new jar (incrementing the value in `d[f]`). The function then calls itself recursively to distribute the next cookie.\\n\\n6. After the DFS recursion is completed, the function `distributeCookies` sets the number of jars (`k`), resizes the `d` vector to accommodate `k` jars, and calls `dfs` to start the distribution process.\\n\\n7. Finally, the minimum maximum jar value (`res`) is returned as the result.\\n\\nBased on this analysis, the code uses a brute-force approach to find the minimum maximum jar value by exploring all possible cookie distributions using DFS recursion.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->The approach to solve the problem:\\n\\n1. We want to distribute cookies into a given number of jars while minimizing the maximum value in any jar.\\n\\n2. To solve this, we use a method called depth-first search (DFS) that explores different ways of distributing the cookies among the jars.\\n\\n3. We start with an empty set of jars and go through each cookie.\\n\\n4. For each cookie, we have two options: we can either add it to an existing jar or create a new jar for it.\\n\\n5. We recursively try both options for each cookie and keep track of the maximum value among all jars.\\n\\n6. After distributing all the cookies, we compare the maximum value with the minimum maximum value we have seen so far. If the new maximum value is smaller, we update the minimum maximum value.\\n\\n7. We repeat this process for all possible combinations of distributing cookies among the jars.\\n\\n8. Finally, we return the minimum maximum value as the result.\\n\\nIn simple terms, the code explores different ways of putting cookies in jars and keeps track of the jar with the highest number of cookies. It tries different combinations until it finds the distribution that minimizes the highest number of cookies in any jar.\\n\\n# Complexity\\n- Time complexity: O(2^N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N + K)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int k;                  // Number of jars\\n    int res = INT_MAX;      // Result variable to store the minimum maximum jar value\\n    vector<int> d;          // Vector to store the current jar values\\n\\n    void dfs(vector<int>& real, int index, int f) {\\n        if (index == real.size()) {   // Base case: If all cookies have been distributed\\n            int iron_man = 0;\\n            for (int i = 0; i < k; i++) {\\n                iron_man = max(iron_man, d[i]); // Find the maximum value among all jars\\n            }\\n            res = min(res, iron_man);       // Update the result with the minimum maximum jar value\\n            return;\\n        }\\n\\n        for (int i = 0; i < f; i++) {\\n            d[i] += real[index];     // Distribute the cookie to jar \\'i\\'\\n            dfs(real, index + 1, f); // Recurse to distribute the next cookie\\n            d[i] -= real[index];     // Backtrack: Remove the cookie from jar \\'i\\'\\n        }\\n\\n        if (f < k) {\\n            d[f] += real[index];     // Distribute the cookie to a new jar \\'f\\'\\n            dfs(real, index + 1, f + 1); // Recurse to distribute the next cookie\\n            d[f] -= real[index];     // Backtrack: Remove the cookie from jar \\'f\\'\\n        }\\n    }\\n\\n    int distributeCookies(vector<int>& real, int K) {\\n        k = K;\\n        d.resize(K);                    // Resize the vector \\'d\\' to \\'K\\' jars\\n        dfs(real, 0, 0);\\n        return res;\\n    }\\n};\\n\\n```\\n![Leetcode.jpeg](https://assets.leetcode.com/users/images/ac9c872f-b4ed-48d6-a8b6-81d3ababc068_1688186595.9547305.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Backtracking",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int k;                  // Number of jars\\n    int res = INT_MAX;      // Result variable to store the minimum maximum jar value\\n    vector<int> d;          // Vector to store the current jar values\\n\\n    void dfs(vector<int>& real, int index, int f) {\\n        if (index == real.size()) {   // Base case: If all cookies have been distributed\\n            int iron_man = 0;\\n            for (int i = 0; i < k; i++) {\\n                iron_man = max(iron_man, d[i]); // Find the maximum value among all jars\\n            }\\n            res = min(res, iron_man);       // Update the result with the minimum maximum jar value\\n            return;\\n        }\\n\\n        for (int i = 0; i < f; i++) {\\n            d[i] += real[index];     // Distribute the cookie to jar \\'i\\'\\n            dfs(real, index + 1, f); // Recurse to distribute the next cookie\\n            d[i] -= real[index];     // Backtrack: Remove the cookie from jar \\'i\\'\\n        }\\n\\n        if (f < k) {\\n            d[f] += real[index];     // Distribute the cookie to a new jar \\'f\\'\\n            dfs(real, index + 1, f + 1); // Recurse to distribute the next cookie\\n            d[f] -= real[index];     // Backtrack: Remove the cookie from jar \\'f\\'\\n        }\\n    }\\n\\n    int distributeCookies(vector<int>& real, int K) {\\n        k = K;\\n        d.resize(K);                    // Resize the vector \\'d\\' to \\'K\\' jars\\n        dfs(real, 0, 0);\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2719514,
                "title": "python-3-recursion-t-m-96-99",
                "content": "```\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n\\n        def dfs(i, mx):\\n  \\n            if mx >= self.ans:\\n                return\\n\\n            if i == len(cookies):\\n                self.ans = min(self.ans, mx)\\n                return\\n\\n            for j in range(k):\\n                kids[j] += cookies[i]\\n                dfs(i + 1, max(mx, kids[j]))\\n                kids[j] -= cookies[i]\\n            return\\n\\n        kids, self.ans = defaultdict(int), inf\\n        cookies.sort(reverse=True)\\n        dfs(0,0)\\n\\n        return self.ans\\n```\\n[https://leetcode.com/submissions/detail/825397756/](http://)",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n\\n        def dfs(i, mx):\\n  \\n            if mx >= self.ans:\\n                return\\n\\n            if i == len(cookies):\\n                self.ans = min(self.ans, mx)\\n                return\\n\\n            for j in range(k):\\n                kids[j] += cookies[i]\\n                dfs(i + 1, max(mx, kids[j]))\\n                kids[j] -= cookies[i]\\n            return\\n\\n        kids, self.ans = defaultdict(int), inf\\n        cookies.sort(reverse=True)\\n        dfs(0,0)\\n\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2254101,
                "title": "java-backtrack-beats-100",
                "content": "\\n```\\nclass Solution {\\n    int ans;\\n    public int distributeCookies(int[] cookies, int k) {\\n        ans= Integer.MAX_VALUE;\\n        int count[]= new int[k];\\n        \\n        fun(0,cookies, k, count);\\n        return ans;\\n    }\\n    public void fun(int start, int[] cookies, int k, int[] count)\\n    {\\n        if(start==cookies.length)\\n        {\\n            int max= 0;\\n            for(int i=0; i<k; i++)\\n            {\\n                max=Math.max(max, count[i]);\\n                \\n            }\\n            ans = Math.min(ans, max);\\n            return;\\n        }\\n        for(int i=0;i<k; i++)\\n        {\\n            count[i]+=cookies[start];\\n            fun(start+1, cookies, k, count);\\n            count[i]-=cookies[start];\\n            if(count[i]==0) break;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int ans;\\n    public int distributeCookies(int[] cookies, int k) {\\n        ans= Integer.MAX_VALUE;\\n        int count[]= new int[k];\\n        \\n        fun(0,cookies, k, count);\\n        return ans;\\n    }\\n    public void fun(int start, int[] cookies, int k, int[] count)\\n    {\\n        if(start==cookies.length)\\n        {\\n            int max= 0;\\n            for(int i=0; i<k; i++)\\n            {\\n                max=Math.max(max, count[i]);\\n                \\n            }\\n            ans = Math.min(ans, max);\\n            return;\\n        }\\n        for(int i=0;i<k; i++)\\n        {\\n            count[i]+=cookies[start];\\n            fun(start+1, cookies, k, count);\\n            count[i]-=cookies[start];\\n            if(count[i]==0) break;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141013,
                "title": "python-optimized-solution-backtracking-implemented-o-k-n-time-complexity",
                "content": "```\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n        l = [0]*k \\n        self.s = float(\\'inf\\')\\n        def ser(l,i):\\n            if i>=len(cookies):\\n                self.s = min(self.s,max(l))\\n                return \\n            if max(l)>=self.s:\\n                return \\n            for j in range(k):\\n                l[j]+=cookies[i]\\n                ser(l,i+1)\\n                l[j]-=cookies[i]\\n        \\n        ser(l,0)\\n        return self.s\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n        l = [0]*k \\n        self.s = float(\\'inf\\')\\n        def ser(l,i):\\n            if i>=len(cookies):\\n                self.s = min(self.s,max(l))\\n                return \\n            if max(l)>=self.s:\\n                return \\n            for j in range(k):\\n                l[j]+=cookies[i]\\n                ser(l,i+1)\\n                l[j]-=cookies[i]\\n        \\n        ser(l,0)\\n        return self.s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2140932,
                "title": "c-backtracking-solution",
                "content": "```C++\\nclass Solution {\\npublic:\\n    vector<int> nums;\\n    int n;\\n\\n    int distributeCookies(vector<int> &cookies, int k) {\\n        nums = cookies, n = k;\\n        vector<int> sum(k);\\n        return backtracking(sum, 0);\\n    }\\n\\n    int backtracking(vector<int> &sum, int cur) {\\n        if (cur == nums.size())\\n            return *max_element(sum.begin(), sum.end());\\n        int res = INT_MAX;\\n        for (int i = 0; i < n; ++i) {\\n            sum[i] += nums[cur];\\n            res = min(res, backtracking(sum, cur + 1));\\n            sum[i] -= nums[cur];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    vector<int> nums;\\n    int n;\\n\\n    int distributeCookies(vector<int> &cookies, int k) {\\n        nums = cookies, n = k;\\n        vector<int> sum(k);\\n        return backtracking(sum, 0);\\n    }\\n\\n    int backtracking(vector<int> &sum, int cur) {\\n        if (cur == nums.size())\\n            return *max_element(sum.begin(), sum.end());\\n        int res = INT_MAX;\\n        for (int i = 0; i < n; ++i) {\\n            sum[i] += nums[cur];\\n            res = min(res, backtracking(sum, cur + 1));\\n            sum[i] -= nums[cur];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704863,
                "title": "c-easiest-noob-solution-easy-explanation-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUmm, it\\'s easy isn\\'t it?\\nYou have `k` people.\\n`k` choices for each packet of cookies.\\nGiven `cookies.length<=8` and `k<=cookies.length`\\n\\nSo for each cookie packet, k choices. \\n**Maximum Time Complexity**: $$(cookies.length)^k=8^8=16777216 = 1.67*10^7$$ \\nSo can apply brute force method.\\n\\nNerds will call it backtracking, but come on, just use your common sense.\\nAfter giving a packet to $$i^{th}$$ person, if you want to now try giving it to the $$(i+1)^{th}$$ person, you will have to take it back from the $$i^{th}$$ person, right?\\nVoila - backtracking!\\n\\n#### So I can -- BE A NOOB AND RUN A FOR LOOP FOR CHOOSING EACH PERSON.\\n\\n# Code \\uD83D\\uDC47\\uD83D\\uDC47\\uD83D\\uDC47\\n```C++ []\\nclass Solution {\\npublic:\\n    int ans=INT_MAX,k;\\n    void func(vector<int>&cookies,vector<int> &ppl,int index){\\n        if(index==cookies.size()){\\n            ans=min(ans,*max_element(begin(ppl),end(ppl)));\\n            return;\\n        }\\n        for(int i=0;i<k;i++){\\n            ppl[i]+=cookies[index];\\n            func(cookies,ppl,index+1);\\n            ppl[i]-=cookies[index];\\n        }\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        this->k=k;\\n        vector<int>ppl(k,0);\\n        func(cookies,ppl,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int ans=INT_MAX,k;\\n    void func(vector<int>&cookies,vector<int> &ppl,int index){\\n        if(index==cookies.size()){\\n            ans=min(ans,*max_element(begin(ppl),end(ppl)));\\n            return;\\n        }\\n        for(int i=0;i<k;i++){\\n            ppl[i]+=cookies[index];\\n            func(cookies,ppl,index+1);\\n            ppl[i]-=cookies[index];\\n        }\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        this->k=k;\\n        vector<int>ppl(k,0);\\n        func(cookies,ppl,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2143203,
                "title": "javascript-backtrack-simple",
                "content": "```\\n/**\\n * @param {number[]} cookies\\n * @param {number} k\\n * @return {number}\\n */\\nvar distributeCookies = function(cookies, k) {\\n    let ans = Infinity;\\n    let bag = Array(k).fill(0)\\n    function backtrack(i) {\\n        if(i >= cookies.length) {\\n            let max = -Infinity;\\n            for(let b of bag) max = Math.max(max, b);\\n            ans = Math.min(ans, max);\\n            return;\\n        }\\n        for(let j=0;j<k;j++) {\\n            bag[j] += cookies[i];\\n            backtrack(i+1);\\n            bag[j] -= cookies[i];\\n        }\\n    }\\n    backtrack(0);\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {number[]} cookies\\n * @param {number} k\\n * @return {number}\\n */\\nvar distributeCookies = function(cookies, k) {\\n    let ans = Infinity;\\n    let bag = Array(k).fill(0)\\n    function backtrack(i) {\\n        if(i >= cookies.length) {\\n            let max = -Infinity;\\n            for(let b of bag) max = Math.max(max, b);\\n            ans = Math.min(ans, max);\\n            return;\\n        }\\n        for(let j=0;j<k;j++) {\\n            bag[j] += cookies[i];\\n            backtrack(i+1);\\n            bag[j] -= cookies[i];\\n        }\\n    }\\n    backtrack(0);\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3703893,
                "title": "easiest-solution-with-explanation-time-complexity-o-k-n-space-complexity-o-k-n",
                "content": "# Video Explanation \\uD83D\\uDC4D\\uD83C\\uDFFB\\nhttps://youtu.be/UQIkqfgq1uE\\n\\n# Code\\n```\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n        cur = [0]*k\\n        n = len(cookies)        \\n\\n        def dfs(i, zero_count):\\n            # If there are not enough cookies remaining, return `float(\\'inf\\')`\\n            # as it leads to an invalid distribution.\\n            if n -i < zero_count:\\n                return float(\\'inf\\')\\n            \\n            # After distributing all cookies, return the unfairness of this\\n            # distribution.\\n            if n == i:\\n                return max(cur)\\n            \\n            # Try to distribute the i-th cookie to each child, and update answer\\n            # as the minimum unfairness in these distributions.\\n            answer = float(\\'inf\\')\\n            for j in range(k): \\n                # if in current combination this kid was not having\\n                # any bag then decrement it\\'s zero_count\\n                zero_count -= int(cur[j] == 0)\\n                cur[j] += cookies[i]\\n                \\n                # Recursively distribute the next cookie.\\n                answer = min(answer, dfs(i+1, zero_count))\\n\\n                cur[j] -= cookies[i]\\n                zero_count += int(cur[j] == 0)\\n\\n            return answer\\n        \\n        return dfs(0, k)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n        cur = [0]*k\\n        n = len(cookies)        \\n\\n        def dfs(i, zero_count):\\n            # If there are not enough cookies remaining, return `float(\\'inf\\')`\\n            # as it leads to an invalid distribution.\\n            if n -i < zero_count:\\n                return float(\\'inf\\')\\n            \\n            # After distributing all cookies, return the unfairness of this\\n            # distribution.\\n            if n == i:\\n                return max(cur)\\n            \\n            # Try to distribute the i-th cookie to each child, and update answer\\n            # as the minimum unfairness in these distributions.\\n            answer = float(\\'inf\\')\\n            for j in range(k): \\n                # if in current combination this kid was not having\\n                # any bag then decrement it\\'s zero_count\\n                zero_count -= int(cur[j] == 0)\\n                cur[j] += cookies[i]\\n                \\n                # Recursively distribute the next cookie.\\n                answer = min(answer, dfs(i+1, zero_count))\\n\\n                cur[j] -= cookies[i]\\n                zero_count += int(cur[j] == 0)\\n\\n            return answer\\n        \\n        return dfs(0, k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703109,
                "title": "110-understandable-subset-sum-maximum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ngive **one** cookie to **one** child and remains to other.\\ngive **two** cookies to **one** child and remains to other.\\ngive **three** cookis to **one** child and remains to other  and so on ....\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nchildGet is array of size `k` , where `childGet[i]`  reprsents total sum of cookie that `ith` child get. when reach at last index (means distributed all the cookies) take the **maximum** from childGet array.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n  **O(k^n)** where n is cookies.length()\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**O(k)** and stack space for recursion.\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n   void solve(int ind,int n,vector<int>& nums,vector<int>& childGet,int k,int &ans)\\n    {\\n        if(ind==n)\\n        {\\n            int maxi=INT_MIN;\\n            for(int i=0;i<k;i++)\\n            {\\n                maxi=max(maxi,childGet[i]);\\n            }\\n            ans=min(ans,maxi);\\n            return ;\\n        }\\n\\n        for(int i=0;i<k;i++)\\n        {\\n            childGet[i]+=nums[ind];\\n            solve(ind+1,n,nums,childGet,k,ans);\\n            childGet[i]-=nums[ind];\\n        }\\n    }\\n    int distributeCookies(vector<int>& nums, int k) \\n    {\\n    \\n       int n=nums.size();\\n       int ans=INT_MAX;\\n       vector<int> childGet(k,0);\\n       solve(0,n,nums,childGet,k,ans);\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n   void solve(int ind,int n,vector<int>& nums,vector<int>& childGet,int k,int &ans)\\n    {\\n        if(ind==n)\\n        {\\n            int maxi=INT_MIN;\\n            for(int i=0;i<k;i++)\\n            {\\n                maxi=max(maxi,childGet[i]);\\n            }\\n            ans=min(ans,maxi);\\n            return ;\\n        }\\n\\n        for(int i=0;i<k;i++)\\n        {\\n            childGet[i]+=nums[ind];\\n            solve(ind+1,n,nums,childGet,k,ans);\\n            childGet[i]-=nums[ind];\\n        }\\n    }\\n    int distributeCookies(vector<int>& nums, int k) \\n    {\\n    \\n       int n=nums.size();\\n       int ans=INT_MAX;\\n       vector<int> childGet(k,0);\\n       solve(0,n,nums,childGet,k,ans);\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702665,
                "title": "daily-challenge-day-1-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is to distribute bags of cookies among a given number of children such that the unfairness (maximum number of cookies obtained by any child) is minimized. The code uses a recursive backtracking approach to explore all possible distributions and find the minimum unfairness.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize an array sum of length k to keep track of the number of cookies each child receives in different distributions\\n2. Initialize a variable minUnfairness to track the minimum unfairness among all distributions, and set it to Infinity.\\n3. Define a recursive function distribution that takes a parameter n, representing the current index of the bag in the cookies array.\\n4. In the distribution function:\\n   - Check if n is equal to the length of the cookies array. If true, calculate the maximum number of cookies obtained by any child using Math.max(...sum).\\n   - Update minUnfairness to be the minimum of the current minUnfairness and the calculated maximum.\\n   - Iterate through the children (from 0 to k-1) and do the following:\\n        - Add the n-th bag\\'s cookies to the i-th child\\'s sum by incrementing sum[i] with cookies[n].\\n        - Add the n-th bag\\'s cookies to the i-th child\\'s sum by incrementing sum[i] with cookies[n].\\n        - Subtract the n-th bag\\'s cookies from the i-th child\\'s sum by decrementing sum[i] with cookies[n].\\n\\n5. Call the distribution function initially with n set to 0 to start the distribution process.\\n6. After exploring all possible distributions, return the minimum unfairness stored in the variable minUnfairness.\\n\\nThe approach uses recursion to explore different distributions of cookies among the children. By keeping track of the maximum number of cookies each child receives in each distribution and updating the minimum unfairness, it finds the optimal solution with the minimum unfairness among all distributions.\\n\\n# Complexity\\n- Time complexity:O(k^(n+1))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(k^(n+1))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n## Dart Solution\\n```\\nclass Solution {\\n  int distributeCookies(List<int> cookies, int k) {\\n      List<int> sum = List<int>.filled(k, 0);\\n      int ans = 1000000;\\n      void distribute(int n){\\n          if (n == cookies.length){\\n              int max = sum.reduce((a, b) => a > b ? a : b);\\n              ans = ans < max ? ans : max;\\n              return;\\n          }\\n          for (int i = 0; i < k; i++){\\n              sum[i] += cookies[n];\\n              distribute(n + 1);\\n              sum[i] -= cookies[n];\\n          }\\n      }\\n      distribute(0);\\n      return ans;\\n  }\\n}\\n```\\n\\n## TypeScript Solution\\n ```\\n function distributeCookies(cookies: number[], k: number): number {\\n     let sum = new Array(k).fill(0);\\n    let ans = Infinity;\\n    const distribution = (n) => {\\n        if(n === cookies.length){\\n            const max = Math.max(...sum);\\n            ans = Math.min(ans,max);\\n            return;\\n        }\\n        for(let i=0;i<k;i++){\\n            sum[i] += cookies[n];\\n            distribution(n+1);\\n            sum[i] -= cookies[n];\\n        }\\n    }\\n    \\n    distribution(0)\\n    return ans\\n};\\n```\\n\\n![Bill Murray Upvote](https://th.bing.com/th/id/R.f048f12b76dcfa8335633f17d472281a?rik=jWgu54fRJr3QGw&riu=http%3a%2f%2fwww.reactiongifs.com%2fr%2f2013%2f02%2fmurray_upvote.gif&ehk=Qe7MtFmTQXVAHWoIuDgOlA4AyT6k7nm%2f%2fr6nmKwavns%3d&risl=&pid=ImgRaw&r=0)\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int distributeCookies(List<int> cookies, int k) {\\n      List<int> sum = List<int>.filled(k, 0);\\n      int ans = 1000000;\\n      void distribute(int n){\\n          if (n == cookies.length){\\n              int max = sum.reduce((a, b) => a > b ? a : b);\\n              ans = ans < max ? ans : max;\\n              return;\\n          }\\n          for (int i = 0; i < k; i++){\\n              sum[i] += cookies[n];\\n              distribute(n + 1);\\n              sum[i] -= cookies[n];\\n          }\\n      }\\n      distribute(0);\\n      return ans;\\n  }\\n}\\n```\n```\\n function distributeCookies(cookies: number[], k: number): number {\\n     let sum = new Array(k).fill(0);\\n    let ans = Infinity;\\n    const distribution = (n) => {\\n        if(n === cookies.length){\\n            const max = Math.max(...sum);\\n            ans = Math.min(ans,max);\\n            return;\\n        }\\n        for(let i=0;i<k;i++){\\n            sum[i] += cookies[n];\\n            distribution(n+1);\\n            sum[i] -= cookies[n];\\n        }\\n    }\\n    \\n    distribution(0)\\n    return ans\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702633,
                "title": "backtrack-c-easy-approach-basic-and-beginner-friendly",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void helper(int ind, const vector<int>& cookies, vector<int>& gotC, int k, int& ans) {\\n        int n = cookies.size();\\n        if (ind == n) {\\n            int currMax = INT_MIN;\\n            for (int i = 0; i < k; i++) {\\n                currMax = max(currMax, gotC[i]);\\n            }\\n            ans = min(ans, currMax);\\n            return;\\n        }\\n\\n        for (int i = 0; i < k; i++) {\\n            gotC[i] += cookies[ind]; \\n            helper(ind + 1, cookies, gotC, k, ans);\\n            gotC[i] -= cookies[ind];\\n        }\\n    }\\n\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int ans = INT_MAX;\\n        vector<int> gotC(k, 0);\\n        helper(0, cookies, gotC, k, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(int ind, const vector<int>& cookies, vector<int>& gotC, int k, int& ans) {\\n        int n = cookies.size();\\n        if (ind == n) {\\n            int currMax = INT_MIN;\\n            for (int i = 0; i < k; i++) {\\n                currMax = max(currMax, gotC[i]);\\n            }\\n            ans = min(ans, currMax);\\n            return;\\n        }\\n\\n        for (int i = 0; i < k; i++) {\\n            gotC[i] += cookies[ind]; \\n            helper(ind + 1, cookies, gotC, k, ans);\\n            gotC[i] -= cookies[ind];\\n        }\\n    }\\n\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int ans = INT_MAX;\\n        vector<int> gotC(k, 0);\\n        helper(0, cookies, gotC, k, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702338,
                "title": "binary-search-love-babbar-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAlways remember to use a do while loop while using next_permutation STL , as we did in recursion while doing the question :\\n\\n---\\n\\n\\nPermutation 1\\nhttps://leetcode.com/problems/permutations/\\nSolution to this -> https://leetcode.com/problems/permutations/solutions/3594754/3-approach-discussed-recursion-c-easy-to-understand/\\n\\n---\\n\\nand Permutation-II\\nhttps://leetcode.com/problems/permutations-ii/\\nSolution to this -> https://leetcode.com/problems/permutations-ii/solutions/3702513/2-approach-using-stl-and-recursion/\\n\\n---\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```\\nPLEASE UPVOTE IF IT HELPED YOU \\uD83E\\uDD70\\n```\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(int mid,vector<int>& cookies,int k){\\n        int n=cookies.size();\\n        int child=1;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=cookies[i];\\n            if(mid<cookies[i]) return false;\\n            if(sum>mid){\\n                child++;\\n                sum=cookies[i];\\n            }\\n            if(child>k) return false;\\n        }\\n        return true;\\n    }\\n    int binarySearch(vector<int>& cookies,int k,int sum){\\n        int start=0;\\n        int end=sum;\\n        int ans=0;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(check(mid,cookies,k)){\\n                ans=mid;\\n                end=mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int distributeCookies(vector<int>& cookies,int k){\\n        sort(cookies.begin(),cookies.end());\\n        int sum=accumulate(cookies.begin(),cookies.end(),0);\\n        int ans=1e8;\\n        do{\\n            ans=min(ans,binarySearch(cookies,k,sum));   \\n        }\\n        while(next_permutation(cookies.begin(),cookies.end()));  \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nPLEASE UPVOTE IF IT HELPED YOU \\uD83E\\uDD70\\n```\n```\\nclass Solution {\\npublic:\\n    bool check(int mid,vector<int>& cookies,int k){\\n        int n=cookies.size();\\n        int child=1;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=cookies[i];\\n            if(mid<cookies[i]) return false;\\n            if(sum>mid){\\n                child++;\\n                sum=cookies[i];\\n            }\\n            if(child>k) return false;\\n        }\\n        return true;\\n    }\\n    int binarySearch(vector<int>& cookies,int k,int sum){\\n        int start=0;\\n        int end=sum;\\n        int ans=0;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(check(mid,cookies,k)){\\n                ans=mid;\\n                end=mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int distributeCookies(vector<int>& cookies,int k){\\n        sort(cookies.begin(),cookies.end());\\n        int sum=accumulate(cookies.begin(),cookies.end(),0);\\n        int ans=1e8;\\n        do{\\n            ans=min(ans,binarySearch(cookies,k,sum));   \\n        }\\n        while(next_permutation(cookies.begin(),cookies.end()));  \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702306,
                "title": "java-backtracking-15-lines-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(k^n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(k+n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int children[], ans = Integer.MAX_VALUE;\\n\\n  private void backTrack(int[] cookies, int i) {\\n    for (var j=0; j < children.length; j++) {\\n      children[j] += cookies[i];\\n\\n      if (i == cookies.length - 1) {\\n        var max = 0;\\n        for (var a : children) max = Math.max(max, a);\\n        ans = Math.min(ans, max);\\n      } else {\\n        backTrack(cookies, i+1);\\n      }\\n      children[j] -= cookies[i];\\n    }\\n  }\\n\\n  public int distributeCookies(int[] cookies, int k) {\\n    children = new int[k];\\n    backTrack(cookies, 0);\\n    return ans;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n  int children[], ans = Integer.MAX_VALUE;\\n\\n  private void backTrack(int[] cookies, int i) {\\n    for (var j=0; j < children.length; j++) {\\n      children[j] += cookies[i];\\n\\n      if (i == cookies.length - 1) {\\n        var max = 0;\\n        for (var a : children) max = Math.max(max, a);\\n        ans = Math.min(ans, max);\\n      } else {\\n        backTrack(cookies, i+1);\\n      }\\n      children[j] -= cookies[i];\\n    }\\n  }\\n\\n  public int distributeCookies(int[] cookies, int k) {\\n    children = new int[k];\\n    backTrack(cookies, 0);\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141875,
                "title": "some-optimizations-python-39-33-ms",
                "content": "1. Special case: if `k == len(cookies)`, then obviously the answer is `max(cookies)`\\n2. Symmetry breaking: switching the children around doesn\\'t change the answer as what matters is how bags of cookies are distributed relative to each other. We can always give the biggest bag to the last child.\\n3. Pruning: there\\'s no reason to explore branches where a child gets more cookies than the best answer so far.\\n\\n```\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n        cookies.sort()\\n        \\n        if k == len(cookies):\\n            return cookies[-1]\\n        children = [0] * k\\n        children[-1] = cookies.pop()\\n        \\n        ans = math.inf\\n        def dfs(i):\\n            nonlocal ans\\n            if i == len(cookies):\\n                ans = min(ans, max(children))\\n                return\\n            for j in range(k):\\n                children[j] += cookies[i]\\n                if children[j] < ans:\\n                    dfs(i + 1)\\n                children[j] -= cookies[i]\\n        dfs(0)\\n        return ans\\n```\\nFurther reading: [Multiway number partitioning](https://en.wikipedia.org/wiki/Multiway_number_partitioning#Minimizing_the_largest_sum)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n        cookies.sort()\\n        \\n        if k == len(cookies):\\n            return cookies[-1]\\n        children = [0] * k\\n        children[-1] = cookies.pop()\\n        \\n        ans = math.inf\\n        def dfs(i):\\n            nonlocal ans\\n            if i == len(cookies):\\n                ans = min(ans, max(children))\\n                return\\n            for j in range(k):\\n                children[j] += cookies[i]\\n                if children[j] < ans:\\n                    dfs(i + 1)\\n                children[j] -= cookies[i]\\n        dfs(0)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141156,
                "title": "backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n     \\n   int maxi=INT_MAX;\\n    void explore(vector<int>&cookies,int n,int k,vector<int>&vec)\\n    {\\n      if(n==cookies.size())\\n      {\\n          int m=0;\\n          for(int i=0;i<k;i++)\\n          {\\n              m=max(m,vec[i]);\\n              \\n          }\\n          maxi=min(maxi,m);\\n          return;\\n      }\\n        for(int i=0;i<k;i++)\\n        {\\n            vec[i]+=cookies[n];\\n            explore(cookies,n+1,k,vec);\\n            vec[i]-=cookies[n];\\n        }\\n    }\\n    \\n       \\n    int distributeCookies(vector<int>& cookies, int k) {\\n      \\n        vector<int> vec(10,0);\\n          explore(cookies,0,k,vec); \\n        return maxi;\\n        \\n    }\\n};\\n```\\n**Like it? Please Upvote ;-)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     \\n   int maxi=INT_MAX;\\n    void explore(vector<int>&cookies,int n,int k,vector<int>&vec)\\n    {\\n      if(n==cookies.size())\\n      {\\n          int m=0;\\n          for(int i=0;i<k;i++)\\n          {\\n              m=max(m,vec[i]);\\n              \\n          }\\n          maxi=min(maxi,m);\\n          return;\\n      }\\n        for(int i=0;i<k;i++)\\n        {\\n            vec[i]+=cookies[n];\\n            explore(cookies,n+1,k,vec);\\n            vec[i]-=cookies[n];\\n        }\\n    }\\n    \\n       \\n    int distributeCookies(vector<int>& cookies, int k) {\\n      \\n        vector<int> vec(10,0);\\n          explore(cookies,0,k,vec); \\n        return maxi;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141072,
                "title": "python-recursion",
                "content": "```\\n\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n        children = [0] * k\\n        result = float(\\'inf\\')\\n\\n        def recurse(i, children):\\n            if i == len(cookies):\\n                nonlocal result\\n                result = min(result, max(children))\\n                return\\n\\n            cookie_size = cookies[i]\\n            for child in range(min(i + 1, k)): # min(i + 1, k) important for avoiding TLE\\n                children[child] += cookie_size\\n                recurse(i + 1, children)\\n                children[child] -= cookie_size\\n\\n        recurse(0, children)\\n\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n        children = [0] * k\\n        result = float(\\'inf\\')\\n\\n        def recurse(i, children):\\n            if i == len(cookies):\\n                nonlocal result\\n                result = min(result, max(children))\\n                return\\n\\n            cookie_size = cookies[i]\\n            for child in range(min(i + 1, k)): # min(i + 1, k) important for avoiding TLE\\n                children[child] += cookie_size\\n                recurse(i + 1, children)\\n                children[child] -= cookie_size\\n\\n        recurse(0, children)\\n\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141046,
                "title": "simple-brute-force-accepted-c",
                "content": "It was **accepted** by simple brute force method.\\nIt worked beacuse the k\\'s value can go upto 7 .\\nIf it were even 8 ,this approach wouldn\\'t work beacuse **8^8 = 16,777,216** ( >1e8 will give tle) but**7^8 is 5,764,801**. \\n\\n\\n# Time Complexity : O(k^n)\\n# Spcae Complexity : O(n)   \\n\\n\\n```\\n int mini = INT_MAX;\\n    \\n    void search(vector<int>& cook,int si,vector<int>& bag,int k){\\n        if(si == cook.size()){\\n            int mx = 0;\\n            for(int i =0;i<bag.size();i++){\\n                mx = max(mx,bag[i]);\\n            }\\n            mini = min(mini,mx);\\n            return ;\\n        }\\n        \\n        \\n        for(int i=0;i<bag.size();i++){\\n            bag[i]+= cook[si];\\n            search(cook,si+1,bag,k);\\n            bag[i]-=cook[si];}\\n        \\n        return ;    \\n    }\\n    \\n    int distributeCookies(vector<int>& cookies, int k) {\\n        mini = INT_MAX;\\n        vector<int> bag(k,0);\\n        search(cookies,0,bag,k);\\n        return mini;  \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n int mini = INT_MAX;\\n    \\n    void search(vector<int>& cook,int si,vector<int>& bag,int k){\\n        if(si == cook.size()){\\n            int mx = 0;\\n            for(int i =0;i<bag.size();i++){\\n                mx = max(mx,bag[i]);\\n            }\\n            mini = min(mini,mx);\\n            return ;\\n        }\\n        \\n        \\n        for(int i=0;i<bag.size();i++){\\n            bag[i]+= cook[si];\\n            search(cook,si+1,bag,k);\\n            bag[i]-=cook[si];}\\n        \\n        return ;    \\n    }\\n    \\n    int distributeCookies(vector<int>& cookies, int k) {\\n        mini = INT_MAX;\\n        vector<int> bag(k,0);\\n        search(cookies,0,bag,k);\\n        return mini;  \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3703738,
                "title": "c-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans=INT_MAX;\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        vector<vector<int>>v(k);\\n        int n=cookies.size();\\n\\t\\t//permute\\n        sort(cookies.begin(),cookies.end());\\n        do{\\n            assign(cookies,k,n,0,0,v);\\n        }while(next_permutation(cookies.begin(),cookies.end()));\\n        return ans;\\n    }\\n    void assign(vector<int>&cookies,int k,int n,int i,int j,vector<vector<int>>&v){\\n\\t\\t//you have placed all cookies atleast 1 to each child\\n        if(i==n and j==k){\\n            int res=0;\\n            for(int i=0;i<k;i++){\\n\\t\\t\\t\\t//find the max cookies given for a child\\n                res=max(accumulate(v[i].begin(),v[i].end(),0),res);\\n            }\\n\\t\\t\\t// the max should be less as possible for the final ans\\n            ans=min(ans,res);\\n            return;\\n        }\\n\\t\\t//you prematurely ended up either you can\\'t distribute all cookies or some cookies left\\n        if(j==k or n==i)\\n            return;\\n        \\n        v[j].push_back(cookies[i]);\\n\\t\\t//current cookie alone enough for child\\n        assign(cookies,k,n,i+1,j+1,v);\\n\\t\\t//give more cookies to the same child\\n        assign(cookies,k,n,i+1,j,v);\\n        v[j].pop_back();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=INT_MAX;\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        vector<vector<int>>v(k);\\n        int n=cookies.size();\\n\\t\\t//permute\\n        sort(cookies.begin(),cookies.end());\\n        do{\\n            assign(cookies,k,n,0,0,v);\\n        }while(next_permutation(cookies.begin(),cookies.end()));\\n        return ans;\\n    }\\n    void assign(vector<int>&cookies,int k,int n,int i,int j,vector<vector<int>>&v){\\n\\t\\t//you have placed all cookies atleast 1 to each child\\n        if(i==n and j==k){\\n            int res=0;\\n            for(int i=0;i<k;i++){\\n\\t\\t\\t\\t//find the max cookies given for a child\\n                res=max(accumulate(v[i].begin(),v[i].end(),0),res);\\n            }\\n\\t\\t\\t// the max should be less as possible for the final ans\\n            ans=min(ans,res);\\n            return;\\n        }\\n\\t\\t//you prematurely ended up either you can\\'t distribute all cookies or some cookies left\\n        if(j==k or n==i)\\n            return;\\n        \\n        v[j].push_back(cookies[i]);\\n\\t\\t//current cookie alone enough for child\\n        assign(cookies,k,n,i+1,j+1,v);\\n\\t\\t//give more cookies to the same child\\n        assign(cookies,k,n,i+1,j,v);\\n        v[j].pop_back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703003,
                "title": "binary-search-on-answer-solution-easy",
                "content": "Just do BS on answer and next permutation to get all possible configuration\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    int ans=1e9,sz;\\n    bool calc(int m, int k) {\\n        sort(v.begin(),v.end());\\n        do{\\n            int cnt=0,cur=0;\\n            for(int i=0;i<sz;i++) {\\n                if(cur+v[i]>m) {\\n                    cnt++; cur=v[i];\\n                }\\n                else cur+=v[i];\\n            }\\n            cnt++;\\n            if(cnt<=k) return 1;\\n        }while(next_permutation(v.begin(),v.end()));\\n        return 0;\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        v=cookies; \\n        sz=v.size();\\n        int l=*max_element(v.begin(),v.end()), r=1e6;\\n        while(l<=r) {\\n            int m=(l+r)/2;\\n            if(calc(m,k)) {\\n                r=m-1;\\n            }\\n            else {\\n                l=m+1;\\n            }\\n        }\\n        return r+1;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> v;\\n    int ans=1e9,sz;\\n    bool calc(int m, int k) {\\n        sort(v.begin(),v.end());\\n        do{\\n            int cnt=0,cur=0;\\n            for(int i=0;i<sz;i++) {\\n                if(cur+v[i]>m) {\\n                    cnt++; cur=v[i];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3702778,
                "title": "simple-backtracking-take-it-or-leave-it",
                "content": "# Java Code\\n```\\nclass Solution {\\n    int result = Integer.MAX_VALUE;\\n    public void backTrack(int[] cookies,int[] arr,int idx)\\n    {\\n        if(idx == cookies.length)\\n        {\\n            int ans = Integer.MIN_VALUE;\\n            for(int k = 0;k<arr.length;k++)\\n            {\\n                ans = Math.max(ans,arr[k]);\\n            }\\n            result = Math.min(result,ans);\\n            return;\\n        }\\n        for(int j = 0;j<arr.length;j++)\\n        {\\n            arr[j]+=cookies[idx];\\n            backTrack(cookies,arr,idx+1);\\n            arr[j]-=cookies[idx];\\n        }\\n    }\\n    public int distributeCookies(int[] cookies, int k) {\\n        int[] arr = new int[k];\\n        backTrack(cookies,arr,0);\\n        return result;\\n    }\\n}\\n```\\n---\\n#### \\uD83C\\uDF1F *Please don\\'t forget to upvote if you\\'ve liked my solution.* \\u2B06\\uFE0F\\n---",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int result = Integer.MAX_VALUE;\\n    public void backTrack(int[] cookies,int[] arr,int idx)\\n    {\\n        if(idx == cookies.length)\\n        {\\n            int ans = Integer.MIN_VALUE;\\n            for(int k = 0;k<arr.length;k++)\\n            {\\n                ans = Math.max(ans,arr[k]);\\n            }\\n            result = Math.min(result,ans);\\n            return;\\n        }\\n        for(int j = 0;j<arr.length;j++)\\n        {\\n            arr[j]+=cookies[idx];\\n            backTrack(cookies,arr,idx+1);\\n            arr[j]-=cookies[idx];\\n        }\\n    }\\n    public int distributeCookies(int[] cookies, int k) {\\n        int[] arr = new int[k];\\n        backTrack(cookies,arr,0);\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141127,
                "title": "c-backtrack",
                "content": "```\\n    int result = int.MaxValue;\\n    public int DistributeCookies(int[] cookies, int k)\\n    {\\n        Backtrack(cookies, k, new int[k], 0);\\n        return result;\\n    }\\n\\n    private void Backtrack(int[] cookies, int k, int[] child ,int counter)\\n    {\\n        if (counter == cookies.Length)\\n        {\\n            result = Math.Min(result, child.Max());\\n            return;\\n        }\\n        for (int i = 0; i < k; i++)\\n        {\\n            child[i] += cookies[counter];\\n            Backtrack(cookies, k, child, counter + 1);\\n            child[i] -= cookies[counter];\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\n    int result = int.MaxValue;\\n    public int DistributeCookies(int[] cookies, int k)\\n    {\\n        Backtrack(cookies, k, new int[k], 0);\\n        return result;\\n    }\\n\\n    private void Backtrack(int[] cookies, int k, int[] child ,int counter)\\n    {\\n        if (counter == cookies.Length)\\n        {\\n            result = Math.Min(result, child.Max());\\n            return;\\n        }\\n        for (int i = 0; i < k; i++)\\n        {\\n            child[i] += cookies[counter];\\n            Backtrack(cookies, k, child, counter + 1);\\n            child[i] -= cookies[counter];\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2140966,
                "title": "python-binary-search-bitmask",
                "content": "Binary Search Condition: We pick a number `mid` and check if we can split cookies in a way such that no child gets more than `mid` candies.\\nSince the length of cookies is very small we can iterate all the possible ways to split and check if condition is satisfied.\\n\\n```\\n# psuedocode to check if `mid` satisfies the condition\\ndef can_satisfy(cookies, max_size, childs):\\n\\tif childs == 1:\\n\\t\\treturn sum(cookies) <= max_size\\n\\tfor every way of picking more than 1 cookies from available cookies:\\n\\t\\tif can_satisfy(remaining_cookies, max_size, childs -1 ):\\n\\t\\t\\treturn True\\n\\treturn False\\n```\\n\\n```py\\nclass Solution:\\n    \\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n        lo = min(cookies)\\n        hi = sum(cookies) + 1\\n        \\n        def can_satisfy(cookies, max_size, childs: int = k) -> bool:\\n            if childs == 1:\\n                return sum(cookies) <= max_size\\n            \\n            for mask in range(1, 2**len(cookies)):\\n                total = 0\\n                rest = []\\n                for i in range(len(cookies)):\\n                    if mask & (1 << i):\\n                        total += cookies[i]\\n                    else:\\n                        rest.append(cookies[i])\\n                if total <= max_size:\\n                    if can_satisfy(rest, max_size, childs -1):\\n                        return True\\n            \\n            return False\\n        \\n        while lo < hi:\\n            mid = (lo+hi)//2\\n            if can_satisfy(cookies, mid):\\n                hi = mid\\n            else:\\n                lo = mid+1\\n        return lo\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree",
                    "Bitmask"
                ],
                "code": "```\\n# psuedocode to check if `mid` satisfies the condition\\ndef can_satisfy(cookies, max_size, childs):\\n\\tif childs == 1:\\n\\t\\treturn sum(cookies) <= max_size\\n\\tfor every way of picking more than 1 cookies from available cookies:\\n\\t\\tif can_satisfy(remaining_cookies, max_size, childs -1 ):\\n\\t\\t\\treturn True\\n\\treturn False\\n```\n```py\\nclass Solution:\\n    \\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n        lo = min(cookies)\\n        hi = sum(cookies) + 1\\n        \\n        def can_satisfy(cookies, max_size, childs: int = k) -> bool:\\n            if childs == 1:\\n                return sum(cookies) <= max_size\\n            \\n            for mask in range(1, 2**len(cookies)):\\n                total = 0\\n                rest = []\\n                for i in range(len(cookies)):\\n                    if mask & (1 << i):\\n                        total += cookies[i]\\n                    else:\\n                        rest.append(cookies[i])\\n                if total <= max_size:\\n                    if can_satisfy(rest, max_size, childs -1):\\n                        return True\\n            \\n            return False\\n        \\n        while lo < hi:\\n            mid = (lo+hi)//2\\n            if can_satisfy(cookies, mid):\\n                hi = mid\\n            else:\\n                lo = mid+1\\n        return lo\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2140947,
                "title": "backtracking-using-k-buckets",
                "content": "```\\nclass Solution:\\n    def distribute(self, cookies, i, n, k, buckets):\\n        if i >= n:\\n            self.minmax = min(self.minmax, max(buckets))\\n            return\\n        for j in range(k):\\n            buckets[j] += cookies[i]\\n            self.distribute(cookies, i + 1, n, k, buckets)\\n            buckets[j] -= cookies[i]\\n    \\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n        n = len(cookies)\\n        if n == k:\\n            return max(cookies)\\n        buckets = [0] * k\\n        self.minmax = float(\\'inf\\')\\n        self.distribute(cookies, 0, n, k, buckets)\\n        return self.minmax\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def distribute(self, cookies, i, n, k, buckets):\\n        if i >= n:\\n            self.minmax = min(self.minmax, max(buckets))\\n            return\\n        for j in range(k):\\n            buckets[j] += cookies[i]\\n            self.distribute(cookies, i + 1, n, k, buckets)\\n            buckets[j] -= cookies[i]\\n    \\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n        n = len(cookies)\\n        if n == k:\\n            return max(cookies)\\n        buckets = [0] * k\\n        self.minmax = float(\\'inf\\')\\n        self.distribute(cookies, 0, n, k, buckets)\\n        return self.minmax\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704845,
                "title": "swift-backtracking-dfs-optimized-in-every-way-possible",
                "content": "# Branch and Bound / Backtracking approach\\n\\nStart with a simple brute-force DFS solution that checks cookie by cookie, all possible options for passing the current cookie to each of the children:\\n\\n```\\nfunc distributeCookies(_ cookies: [Int], _ k: Int) -> Int\\n{\\n    let n = cookies.count        \\n    var kids = Array(repeating: 0, count: k)\\n    var minUnfairness = Int.max\\n\\n    dfs(0)\\n\\n    func dfs(_ cookieIndex: Int)\\n    {\\n        if cookieIndex == n { minUnfairness = min(minUnfairness, kids.max()!); return }\\n        for j in 0..<k\\n        {\\n            kids[j] += cookies[cookieIndex]\\n            dfs(cookieIndex + 1)\\n            kids[j] -= cookies[cookieIndex]\\n        }\\n    }\\n    return minUnfairness\\n}\\n```\\n\\n# Optimizations\\n\\n---\\n\\n\\n##### No point in following a route with an already worse result\\n\\nIf passing a cookie to a child will cause its cookie value to be greater than the best final score already found, then that route will not produce a better total. We can cut off this branch.\\n```\\nfunc dfs(_ cookieIndex: Int)\\n{\\n    if cookieIndex == n { minUnfairness = kids.max()!; return }\\n    for j in 0..<k\\n    {\\n        kids[j] += cookies[cookieIndex]\\n        if kids[j] < minUnfairness { \\n            dfs(cookieIndex + 1)\\n        }\\n        kids[j] -= cookies[cookieIndex]\\n    }\\n}\\nreturn minUnfairness\\n```\\n\\n---\\n\\n\\n##### Start with bigger bags of cookies first\\n\\nThis further develops the previous optimization. The earlier we use large cookie bags, the earlier we will come to an excess over the optimal result, i.e., the wider branches we will be able to eliminate from consideration beforehand.\\n\\n```\\nlet cookies = cookies.sorted(by: >)\\n```\\n\\n---\\n\\n##### Inital approximation\\n\\nWe can take advantage of the cookie array being sorted to quickly establish an initial approximate `minUnfairness` value, allowing us to start pruning out the bigger sums earlier.\\nIf we give cookies from larger to smaller to all children in turn, returning to the first child after the last one, we end up with an *approximately* equal distribution, with the first kid having the most cookies. So let\\'s just calculate the amount of first child\\'s cookies for this scenario and use that value as `minUnfairness`.\\n\\n```\\nvar minUnfairness = cookies.enumerated().reduce(into: 0) {\\n    if $1.0 % k == 0 { $0 += $1.1 }\\n}\\n```\\n\\n---\\n\\n##### Everyone shoud get a cookie\\n\\nThe final states with some kid left cookieless are suboptimal by the simple consideration: If we take a cookie from a child having max of them and give it to the one left hungry, this will produce a better total result.\\nSo we track a number of undistributed cookies left and a count of cookieless kids. If giving an already-fed child a cookie would result in a overall cookie shortage, we skip that variant.\\n\\n```\\nfunc dfs(_ cookieIndex: Int, _ cookiesLeft: Int = n, _ cookielessCount: Int = k)\\n{\\n    if cookieIndex == n { minUnfairness = kids.max()!; return }\\n    for j in 0..<k\\n    {\\n        let newCookieless = (kids[j] == 0) ? cookielessCount - 1 : cookielessCount\\n        if newCookieless >= cookiesLeft { continue }\\n\\n        kids[j] += cookies[cookieIndex]\\n        if kids[j] < minUnfairness { \\n            dfs(cookieIndex + 1, cookiesLeft - 1, newCookieless)\\n        }\\n        kids[j] -= cookies[cookieIndex]\\n    }\\n}\\n```\\n---\\n##### No going above average\\n\\nI\\'ll just quote [this](https://leetcode.com/problems/fair-distribution-of-cookies/editorial/comments/1951050) excellent explanation:\\n> A simple optimization is to pre-compute `avg = sum(cookies) / k` and refuse to add further to a given subset if its current `sum  > avg`.\\n>\\n> This follows from the following mathematical claim: any optimal solution ${S_1,S_2...,S_k}$ (i.e., an optimal partition of the $n$ cookies into $k$ non-empty subsets) cannot have a subset $S_i$ such that $sum(S_i - {s}) > avg$ for some element $s$ in $S_i$. To prove this claim, observe that the existence of such a subset implies there exists another subset $S_j (i \\\\ne j)$ such that $sum(S_j) < avg < sum(S_i - {s})$. So in particular $sum(S_j + {s}) < sum(S_i)$, and so putting $s$ in $S_j$ rather than $S_i$ would give a better solution.\\n\\n```\\nlet cookiesTotal = cookies.reduce(0, +)\\nlet avg = cookiesTotal / k\\n```\\n```\\nfor j in 0..<k where kids[j] <= avg\\n```\\n\\n---\\n\\n##### Early termination if best possible result achieved\\nBy further pondering the average, we can derive one simple conclusion: the best theoretically possible result is equal to the average value rounded up.\\n```\\nlet bestPossibleResult = 1 + (cookiesTotal - 1) / k\\n```\\nIf we get `minUnfairness` value equal to this, we can stop execution altogether and output the answer.\\nBut there is some technical issue here. It\\'s [not that easy](https://stackoverflow.com/questions/13784337/exit-the-entire-recursion-stack) to break from the depth of the recursion and get out of DFS at an arbitrary moment. One possible way would be to throw an exception and catch it in a main function:\\n```\\ndo { try dfs(0) }\\ncatch { return minUnfairness }\\n\\nfunc dfs(_ cookieIndex: Int) throws\\n{\\n    if cookieIndex == n\\n    { \\n        minUnfairness = kids.max()!\\n        if minUnfairness == bestPossibleResult { throw \"Best result achieved!\" }\\n        else { return }\\n    }\\n    for j in 0..<k where kids[j] <= avg\\n    {\\n        kids[j] += cookies[cookieIndex]\\n        if kids[j] < minUnfairness { \\n            try dfs(cookieIndex + 1)\\n        }\\n        kids[j] -= cookies[cookieIndex]\\n    }\\n}\\nreturn minUnfairness\\n\\nextension String: Error {}\\n```\\n...but we\\'ll take another option\\n\\n---\\n\\n##### From recursion to iteration\\n\\nAnother upgrade would be to change the recursive DFS to iterative one. It\\'s not that simple as our recursion is branching **and** we need the postorder action `kids[j] -= cookies[cookieIndex]` for backtracking, but it [can](https://nmamano.com/blog/iterativetreetraversal/iterativetreetraversal.html#a-nametechniqueaiterative-postorder-and-inorder-traversal) be done:\\n\\n```\\ntypealias State = (cookieIndex: Int, kid: Int, firstVisit: Bool)\\nvar stack: [State] = (0..<k).map { (0, $0, true) }\\n\\nwhile let (cookieIndex, kid, firstVisit) = stack.popLast()\\n{\\n    if !firstVisit { kids[kid] -= cookies[cookieIndex]; continue }\\n    \\n    kids[kid] += cookies[cookieIndex]\\n    if cookieIndex == n - 1\\n    { \\n        minUnfairness = min(minUnfairness, kids.max()!)\\n        if minUnfairness == bestPossibleResult { return minUnfairness }\\n        else { kids[kid] -= cookies[cookieIndex]; continue }\\n    }\\n\\n    stack.append((cookieIndex, kid, false))\\n\\n    for j in 0..<k where kids[j] <= avg\\n    {\\n        if kids[j] + cookies[cookieIndex + 1] < minUnfairness { \\n            stack.append((cookieIndex + 1, j, true))\\n        }\\n    }\\n}\\nreturn minUnfairness\\n```\\nThis not only eliminates the need for exceptions, but also gives a speed bonus, since iterations are faster than recursion. In fact, **several times** faster. Who would have thought?\\n\\n---\\n##### Why give the same cookie to different kids if their cookie counts don\\'t vary? They all look identical to me.\\nYet another optimization is to consider the fact that if there are currently several kids with the same cookie value, we only need to check one of them, as giving cookie to others will lead to the same state.\\nImagine children with current cookie amounts `[3,3,3,3,3,2,4]`. We\\'ll try give the next cookie to first of them with count `3`, then all subsequent kids with count `3` will be skipped for that cookie, as the result for them would be the same, only from the different position. Or, as an another example, the very initial state `[0,0,0,0,0,0,0]`. By considering only one child out of all $k$, we reduce the number of branches by $k$ times in just the first step! Not bad, eh?\\n<details>\\n<summary>\\nWe can even estimate how this will impact the overall time complexity\\n</summary>\\n<br/>\\nSuppose the sums won\\'t coincide randomly, and all pruning will concern only the starting zero sums. The first step leaves one choice out of k in the usual approach. In the second step, we will already have one different child and k-1 zeroes, so 2 variants are possible instead of k regular ones. At the third step, in the worst case the number of differing kids can increase by one more, and we have 3 further variants (instead of k in the usual case). Continuing this way, we obtain that the first k\\u22C5k\\u22C5...\\u22C5k branches are reduced to 1\\u22C52\\u22C53\\u22C5...\\u22C5k branches.\\n</details>\\n<br/>\\n\\nThe time complexity goes down from $O(k^n)$ to $O(k! \\\\cdot k^{n-k})$ \\n\\n```\\nvar kidsValues: Set<Int> = []\\nfor j in 0..<k where kids[j] <= avg\\n{\\n    // already tried to feed the kid with the same cookie value\\n    if !kidsValues.insert(kids[j]).inserted { continue }\\n...\\n\\n```\\nSuch evasion of equivalent states can also be considered as a somewhat partial substitute for a full-fledged memoization, allowing us to keep low space consumption.\\n\\n---\\n\\n*At this point we are probably reaching an over-optimization, when most of the ineffective ways are already discarded and any new checks will only slow down the code. So let\\'s settle for that. Just one more thing:*\\n\\n##### Edge cases\\nTo complement all the above, let\\'s add a check for some trivial edge cases at the very beginning.\\n\\n```\\nif n == k { return cookies.max()! } // one-to-one distribution\\nelse if n == k + 1\\n{   // find 2 smallest cookie bags and give both of them to some kid\\n    var indices = Set(cookies.indices)\\n    let minInd1 = indices.min { cookies[$0] < cookies[$1] }!\\n    indices.remove(minInd1)\\n    let minInd2 = indices.min { cookies[$0] < cookies[$1] }!\\n    let maxCookieBag = cookies.max()!\\n    return max(maxCookieBag, (cookies[minInd1] + cookies[minInd2]))\\n}\\n```\\n\\n---\\n\\n\\n## Complexity\\n- Time complexity: $O(k! \\\\cdot k^{n-k})$\\n- Space complexity: $O(k+n)$\\nWith all these optimizations, perhaps the exact time estimate is lower than this, but it will take some math analysis to prove it.\\n\\n## Final code, all optimizations together\\n```\\nfunc distributeCookies(_ cookies: [Int], _ k: Int) -> Int\\n{\\n    let n = cookies.count        \\n\\n    if n == k { return cookies.max()! } // one-to-one distribution\\n    else if n == k + 1\\n    {   // find 2 smallest cookie bags and give both of them to some kid\\n        var indices = Set(cookies.indices)\\n        let minInd1 = indices.min { cookies[$0] < cookies[$1] }!\\n        indices.remove(minInd1)\\n        let minInd2 = indices.min { cookies[$0] < cookies[$1] }!\\n        let maxCookieBag = cookies.max()!\\n        return max(maxCookieBag, (cookies[minInd1] + cookies[minInd2]))\\n    }\\n\\n    let cookies = cookies.sorted(by: >)\\n    let cookiesTotal = cookies.reduce(0, +)\\n    let avg = cookiesTotal / k\\n    let bestPossibleResult = 1 + (cookiesTotal - 1) / k\\n\\n    var kids = Array(repeating: 0, count: k)\\n    var minUnfairness = cookies.enumerated().reduce(into: 0) { if $1.0 % k == 0 { $0 += $1.1 }}\\n\\n    typealias State = (cookieIndex: Int, kid: Int, cookieless: Int, firstVisit: Bool)\\n    var stack: [State] = [(0, 0, k, true)]\\n\\n    while var (cookieIndex, kid, cookieless, firstVisit) = stack.popLast()\\n    {\\n        if !firstVisit { kids[kid] -= cookies[cookieIndex]; continue }\\n\\n        if kids[kid] == 0 { cookieless -= 1 }\\n        if cookieless >= (n - cookieIndex) { continue }\\n        \\n        if kids[kid] + cookies[cookieIndex] >= minUnfairness { continue }\\n        kids[kid] += cookies[cookieIndex]\\n\\n        if cookieIndex == n - 1\\n        { \\n            minUnfairness = min(minUnfairness, kids.max()!)\\n            if minUnfairness == bestPossibleResult { return minUnfairness }\\n            else { kids[kid] -= cookies[cookieIndex]; continue }\\n        }\\n\\n        stack.append((cookieIndex, kid, cookieless, false))\\n\\n        var kidsValues: Set<Int> = []\\n        for j in 0..<k where kids[j] <= avg\\n        {\\n            // already tried to feed the kid with the same cookie value\\n            if !kidsValues.insert(kids[j]).inserted { continue }                \\n            stack.append((cookieIndex + 1, j, cookieless, true))                \\n        }\\n    }\\n    return minUnfairness\\n}\\n```\\n\\n<details>\\n<summary>Bonus for those who have read this far:</summary>\\n<br/>\\nSetting an initial approximate result with a new <a href=\"https://arxiv.org/pdf/2203.05618.pdf\">locally optimal algorithm</a>  by Kaan and Hakan Gokcesu:\\n<br/>\\n<br/>\\n\\n```\\nvar minUnfairness = approximation(cookies, k)\\n\\n```\\n```\\nfunc approximation(_ nums: [Int], _ k: Int) -> Int\\n{\\n    var sets: [Set<Int>] = Array(repeating: [], count: k)\\n    var setSums: [Int] = Array(repeating: 0, count: k)\\n    sets[0] = Set(nums)\\n    setSums[0] = nums.reduce(0, +)\\n\\n    var indexSet = Set(0..<k)\\n\\n    var minSumInd = 0, maxSumInd = 0, minSetSum = 0, maxSetSum = 0\\n    while indexSet.count > 1\\n    {\\n        minSumInd = 0; maxSumInd = 0; minSetSum = Int.max; maxSetSum = Int.min\\n        for ind in indexSet // possible optimization with Priority Queue\\n        {\\n            let setSum = setSums[ind]\\n            if setSum < minSetSum { minSumInd = ind; minSetSum = setSum }\\n            if setSum > maxSetSum { maxSumInd = ind; maxSetSum = setSum }\\n        }\\n\\n        let diff = maxSetSum - minSetSum\\n        var itemsThatDecreaseDiff: [Int] = []\\n        for item in sets[maxSumInd]\\n        {\\n            let newDiff = abs((maxSetSum - item) - (minSetSum + item))\\n            if newDiff < diff {\\n                itemsThatDecreaseDiff.append(item)\\n            }\\n        }\\n\\n        if itemsThatDecreaseDiff.isEmpty {\\n            indexSet.remove(maxSumInd)\\n        }\\n        else\\n        {\\n            let moveItem = itemsThatDecreaseDiff.max()!                \\n            sets[maxSumInd].remove(moveItem); setSums[maxSumInd] -= moveItem\\n            sets[minSumInd].insert(moveItem); setSums[minSumInd] += moveItem\\n        }\\n    }\\n    return setSums.max()!\\n}\\n```\\nAlthough, it turned out that the initial approximation does not give a considerable gain \\uD83D\\uDE15\\n</details>",
                "solutionTags": [
                    "Swift",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nfunc distributeCookies(_ cookies: [Int], _ k: Int) -> Int\\n{\\n    let n = cookies.count        \\n    var kids = Array(repeating: 0, count: k)\\n    var minUnfairness = Int.max\\n\\n    dfs(0)\\n\\n    func dfs(_ cookieIndex: Int)\\n    {\\n        if cookieIndex == n { minUnfairness = min(minUnfairness, kids.max()!); return }\\n        for j in 0..<k\\n        {\\n            kids[j] += cookies[cookieIndex]\\n            dfs(cookieIndex + 1)\\n            kids[j] -= cookies[cookieIndex]\\n        }\\n    }\\n    return minUnfairness\\n}\\n```\n```\\nfunc dfs(_ cookieIndex: Int)\\n{\\n    if cookieIndex == n { minUnfairness = kids.max()!; return }\\n    for j in 0..<k\\n    {\\n        kids[j] += cookies[cookieIndex]\\n        if kids[j] < minUnfairness { \\n            dfs(cookieIndex + 1)\\n        }\\n        kids[j] -= cookies[cookieIndex]\\n    }\\n}\\nreturn minUnfairness\\n```\n```\\nlet cookies = cookies.sorted(by: >)\\n```\n```\\nvar minUnfairness = cookies.enumerated().reduce(into: 0) {\\n    if $1.0 % k == 0 { $0 += $1.1 }\\n}\\n```\n```\\nfunc dfs(_ cookieIndex: Int, _ cookiesLeft: Int = n, _ cookielessCount: Int = k)\\n{\\n    if cookieIndex == n { minUnfairness = kids.max()!; return }\\n    for j in 0..<k\\n    {\\n        let newCookieless = (kids[j] == 0) ? cookielessCount - 1 : cookielessCount\\n        if newCookieless >= cookiesLeft { continue }\\n\\n        kids[j] += cookies[cookieIndex]\\n        if kids[j] < minUnfairness { \\n            dfs(cookieIndex + 1, cookiesLeft - 1, newCookieless)\\n        }\\n        kids[j] -= cookies[cookieIndex]\\n    }\\n}\\n```\n```\\nlet cookiesTotal = cookies.reduce(0, +)\\nlet avg = cookiesTotal / k\\n```\n```\\nfor j in 0..<k where kids[j] <= avg\\n```\n```\\nlet bestPossibleResult = 1 + (cookiesTotal - 1) / k\\n```\n```\\ndo { try dfs(0) }\\ncatch { return minUnfairness }\\n\\nfunc dfs(_ cookieIndex: Int) throws\\n{\\n    if cookieIndex == n\\n    { \\n        minUnfairness = kids.max()!\\n        if minUnfairness == bestPossibleResult { throw \"Best result achieved!\" }\\n        else { return }\\n    }\\n    for j in 0..<k where kids[j] <= avg\\n    {\\n        kids[j] += cookies[cookieIndex]\\n        if kids[j] < minUnfairness { \\n            try dfs(cookieIndex + 1)\\n        }\\n        kids[j] -= cookies[cookieIndex]\\n    }\\n}\\nreturn minUnfairness\\n\\nextension String: Error {}\\n```\n```\\ntypealias State = (cookieIndex: Int, kid: Int, firstVisit: Bool)\\nvar stack: [State] = (0..<k).map { (0, $0, true) }\\n\\nwhile let (cookieIndex, kid, firstVisit) = stack.popLast()\\n{\\n    if !firstVisit { kids[kid] -= cookies[cookieIndex]; continue }\\n    \\n    kids[kid] += cookies[cookieIndex]\\n    if cookieIndex == n - 1\\n    { \\n        minUnfairness = min(minUnfairness, kids.max()!)\\n        if minUnfairness == bestPossibleResult { return minUnfairness }\\n        else { kids[kid] -= cookies[cookieIndex]; continue }\\n    }\\n\\n    stack.append((cookieIndex, kid, false))\\n\\n    for j in 0..<k where kids[j] <= avg\\n    {\\n        if kids[j] + cookies[cookieIndex + 1] < minUnfairness { \\n            stack.append((cookieIndex + 1, j, true))\\n        }\\n    }\\n}\\nreturn minUnfairness\\n```\n```\\nvar kidsValues: Set<Int> = []\\nfor j in 0..<k where kids[j] <= avg\\n{\\n    // already tried to feed the kid with the same cookie value\\n    if !kidsValues.insert(kids[j]).inserted { continue }\\n...\\n\\n```\n```\\nif n == k { return cookies.max()! } // one-to-one distribution\\nelse if n == k + 1\\n{   // find 2 smallest cookie bags and give both of them to some kid\\n    var indices = Set(cookies.indices)\\n    let minInd1 = indices.min { cookies[$0] < cookies[$1] }!\\n    indices.remove(minInd1)\\n    let minInd2 = indices.min { cookies[$0] < cookies[$1] }!\\n    let maxCookieBag = cookies.max()!\\n    return max(maxCookieBag, (cookies[minInd1] + cookies[minInd2]))\\n}\\n```\n```\\nfunc distributeCookies(_ cookies: [Int], _ k: Int) -> Int\\n{\\n    let n = cookies.count        \\n\\n    if n == k { return cookies.max()! } // one-to-one distribution\\n    else if n == k + 1\\n    {   // find 2 smallest cookie bags and give both of them to some kid\\n        var indices = Set(cookies.indices)\\n        let minInd1 = indices.min { cookies[$0] < cookies[$1] }!\\n        indices.remove(minInd1)\\n        let minInd2 = indices.min { cookies[$0] < cookies[$1] }!\\n        let maxCookieBag = cookies.max()!\\n        return max(maxCookieBag, (cookies[minInd1] + cookies[minInd2]))\\n    }\\n\\n    let cookies = cookies.sorted(by: >)\\n    let cookiesTotal = cookies.reduce(0, +)\\n    let avg = cookiesTotal / k\\n    let bestPossibleResult = 1 + (cookiesTotal - 1) / k\\n\\n    var kids = Array(repeating: 0, count: k)\\n    var minUnfairness = cookies.enumerated().reduce(into: 0) { if $1.0 % k == 0 { $0 += $1.1 }}\\n\\n    typealias State = (cookieIndex: Int, kid: Int, cookieless: Int, firstVisit: Bool)\\n    var stack: [State] = [(0, 0, k, true)]\\n\\n    while var (cookieIndex, kid, cookieless, firstVisit) = stack.popLast()\\n    {\\n        if !firstVisit { kids[kid] -= cookies[cookieIndex]; continue }\\n\\n        if kids[kid] == 0 { cookieless -= 1 }\\n        if cookieless >= (n - cookieIndex) { continue }\\n        \\n        if kids[kid] + cookies[cookieIndex] >= minUnfairness { continue }\\n        kids[kid] += cookies[cookieIndex]\\n\\n        if cookieIndex == n - 1\\n        { \\n            minUnfairness = min(minUnfairness, kids.max()!)\\n            if minUnfairness == bestPossibleResult { return minUnfairness }\\n            else { kids[kid] -= cookies[cookieIndex]; continue }\\n        }\\n\\n        stack.append((cookieIndex, kid, cookieless, false))\\n\\n        var kidsValues: Set<Int> = []\\n        for j in 0..<k where kids[j] <= avg\\n        {\\n            // already tried to feed the kid with the same cookie value\\n            if !kidsValues.insert(kids[j]).inserted { continue }                \\n            stack.append((cookieIndex + 1, j, cookieless, true))                \\n        }\\n    }\\n    return minUnfairness\\n}\\n```\n```\\nvar minUnfairness = approximation(cookies, k)\\n\\n```\n```\\nfunc approximation(_ nums: [Int], _ k: Int) -> Int\\n{\\n    var sets: [Set<Int>] = Array(repeating: [], count: k)\\n    var setSums: [Int] = Array(repeating: 0, count: k)\\n    sets[0] = Set(nums)\\n    setSums[0] = nums.reduce(0, +)\\n\\n    var indexSet = Set(0..<k)\\n\\n    var minSumInd = 0, maxSumInd = 0, minSetSum = 0, maxSetSum = 0\\n    while indexSet.count > 1\\n    {\\n        minSumInd = 0; maxSumInd = 0; minSetSum = Int.max; maxSetSum = Int.min\\n        for ind in indexSet // possible optimization with Priority Queue\\n        {\\n            let setSum = setSums[ind]\\n            if setSum < minSetSum { minSumInd = ind; minSetSum = setSum }\\n            if setSum > maxSetSum { maxSumInd = ind; maxSetSum = setSum }\\n        }\\n\\n        let diff = maxSetSum - minSetSum\\n        var itemsThatDecreaseDiff: [Int] = []\\n        for item in sets[maxSumInd]\\n        {\\n            let newDiff = abs((maxSetSum - item) - (minSetSum + item))\\n            if newDiff < diff {\\n                itemsThatDecreaseDiff.append(item)\\n            }\\n        }\\n\\n        if itemsThatDecreaseDiff.isEmpty {\\n            indexSet.remove(maxSumInd)\\n        }\\n        else\\n        {\\n            let moveItem = itemsThatDecreaseDiff.max()!                \\n            sets[maxSumInd].remove(moveItem); setSums[maxSumInd] -= moveItem\\n            sets[minSumInd].insert(moveItem); setSums[minSumInd] += moveItem\\n        }\\n    }\\n    return setSums.max()!\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3704690,
                "title": "video-explanation-with-clean-code-c-100-simple-and-easy-to-understand",
                "content": "# Intuition & Approach\\n- Create a new vector a of size k to represent subsets. Since the constraints are low (n<=8), we can generate all possible subsets of size k.\\n\\n- Call the solve function.\\n\\n- Consider the base cases: If all elements have been considered,calculate the maximum number of cookies distributed according to the current subset.Return this value as ans.\\n\\n- After checking the base condition, create a variable \\'mn\\' and initialize it with the maximum value.\\n\\n Iterate over each subset:\\n\\n- Add the current element to the subset and keep track of the minimum sum obtained by comparing it with the value obtained from the recursive call.\\n\\n- Subtract the current element from the subset and move on to the next one.\\n\\n- Return the \\'ans\\' as the final result.\\n\\n\\n---\\n\\nhttps://www.youtube.com/watch?v=MxYLYnGtJjg\\n\\n# Complexity\\n- Time complexity: The backtracking approach explores all possible distributions. In the worst case, there can be up to k^N distributions, where k is the number of children and N is the number of cookies. Therefore, the time complexity is **O(k^N)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(K) for bucket, and O(N) for recursive stack space. So, total of **O(N+K)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int i, vector<int>& cookies, int k, int& ans,vector<int> &bucket)\\n    {\\n        //Base case\\n        if(i<0)\\n        {\\n            ans = min(ans, *max_element(bucket.begin(), bucket.end()));\\n            return ;\\n        }\\n        if(*max_element(bucket.begin(), bucket.end()) > ans) return;\\n        for(int idx = 0;idx<k;idx++)\\n        {\\n            bucket[idx] += cookies[i];\\n            solve(i-1, cookies, k, ans, bucket);\\n            bucket[idx] -= cookies[i];\\n        }\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int n = cookies.size();\\n        vector<int> bucket(k, 0);\\n        int ans = INT_MAX;\\n        solve(n-1,cookies, k,ans, bucket);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int i, vector<int>& cookies, int k, int& ans,vector<int> &bucket)\\n    {\\n        //Base case\\n        if(i<0)\\n        {\\n            ans = min(ans, *max_element(bucket.begin(), bucket.end()));\\n            return ;\\n        }\\n        if(*max_element(bucket.begin(), bucket.end()) > ans) return;\\n        for(int idx = 0;idx<k;idx++)\\n        {\\n            bucket[idx] += cookies[i];\\n            solve(i-1, cookies, k, ans, bucket);\\n            bucket[idx] -= cookies[i];\\n        }\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int n = cookies.size();\\n        vector<int> bucket(k, 0);\\n        int ans = INT_MAX;\\n        solve(n-1,cookies, k,ans, bucket);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703648,
                "title": "java-beats-91-binary-search-backtracking-recursion",
                "content": "# Problem Statement\\nWe have an array of cookies, and we want to distribute them among \\'k\\' children. The goal is to make sure that each child receives the same number of cookies and avoid any unfairness. We\\'ll use binary search to find the optimal distribution for a fun-filled and yummy solution!\\n\\n # **Code** : \\n```java\\nclass distributeCookies {\\n    public int distributeCookies(int[] cookies, int k){\\n        int i = Arrays.stream(cookies).max().getAsInt();\\n        int j = Arrays.stream(cookies).sum();\\n        int ans = 0;\\n\\n        // Perform binary search to find the optimal distribution\\n        while (i <= j) {\\n            int mid = i + (j - i) / 2;\\n            int[] candidates = new int[k];\\n            int zeroCount = k;\\n            int max = Integer.MIN_VALUE;\\n\\n            // Check if it is possible to distribute cookies fairly using the current mid value\\n            if (isPossible(0, cookies, candidates, mid, max, zeroCount)) {\\n                // If possible, update the answer and explore the lower half of the range\\n                ans = mid;\\n                j = mid - 1;\\n            } else {\\n                // If not possible, explore the upper half of the range\\n                i = mid + 1;\\n            }\\n        }\\n\\n        // Print the optimal number of cookies that can be distributed fairly\\n        System.out.println(ans);\\n    }\\n\\n    // Helper method to check if it is possible to distribute cookies fairly\\n    private static boolean isPossible(int idx, int[] cookies, int[] candidates, int maxVal, int max, int zeroCount) {\\n        // If there are fewer cookies left than the number of empty slots (zeroCount),\\n        // it is not possible to distribute the cookies fairly\\n        if (cookies.length - idx < zeroCount) {\\n            return false;\\n        }\\n\\n        // Base case: If all cookies have been distributed\\n        if (idx == cookies.length) {\\n            // If the maximum number of cookies received by a child is greater than the maxVal,\\n            // it is not a fair distribution, so return false to indicate it\\'s not possible\\n            if (max > maxVal) {\\n                return false;\\n            }\\n            // Return true to indicate that the current distribution is fair\\n            return true;\\n        }\\n\\n        int c = cookies[idx];\\n        for (int i = 0; i < candidates.length; i++) {\\n            // Update the zeroCount if the child receives a cookie for the first time\\n            if (candidates[i] == 0) {\\n                zeroCount--;\\n            }\\n            // Add the current cookie to the child\\n            candidates[i] += c;\\n\\n            // Recursively check the next cookie with the updated distribution\\n            if (candidates[i] <= maxVal && isPossible(idx + 1, cookies, candidates, maxVal, Math.max(max, candidates[i]), zeroCount)) {\\n                // If the current distribution is fair, return true\\n                return true;\\n            }\\n\\n            // Remove the current cookie from the child\\n            candidates[i] -= c;\\n\\n            // Restore the zeroCount if the child no longer has any cookies\\n            if (candidates[i] == 0) {\\n                zeroCount++;\\n            }\\n        }\\n\\n        // Return false to indicate that it is not possible to distribute cookies fairly\\n        return false;\\n    }\\n}\\n\\n```\\n\\n**Complexity Analysis:**\\n\\nThe time complexity of this solution is O(N * log(S)* 2^K), where N is the number of cookies,S is the sum of all the cookies and K is the number of children. \\n\\nExplanation :\\nThe binary search operates in O(log(S)) time complexity. For each iteration of the binary search, the isPossible method is called, which has a time complexity of O(N) due to iterating through the cookies array to simulate the distribution.\\n\\nWithin the isPossible method, the recursion depth is limited to K levels, and at each level, we iterate over the candidates array, which has a length of K. This results in a backtracking time complexity of O(2^K)\\n\\nThe space complexity is O(k), as we use an array to keep track of the number of cookies each child receives.\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```java\\nclass distributeCookies {\\n    public int distributeCookies(int[] cookies, int k){\\n        int i = Arrays.stream(cookies).max().getAsInt();\\n        int j = Arrays.stream(cookies).sum();\\n        int ans = 0;\\n\\n        // Perform binary search to find the optimal distribution\\n        while (i <= j) {\\n            int mid = i + (j - i) / 2;\\n            int[] candidates = new int[k];\\n            int zeroCount = k;\\n            int max = Integer.MIN_VALUE;\\n\\n            // Check if it is possible to distribute cookies fairly using the current mid value\\n            if (isPossible(0, cookies, candidates, mid, max, zeroCount)) {\\n                // If possible, update the answer and explore the lower half of the range\\n                ans = mid;\\n                j = mid - 1;\\n            } else {\\n                // If not possible, explore the upper half of the range\\n                i = mid + 1;\\n            }\\n        }\\n\\n        // Print the optimal number of cookies that can be distributed fairly\\n        System.out.println(ans);\\n    }\\n\\n    // Helper method to check if it is possible to distribute cookies fairly\\n    private static boolean isPossible(int idx, int[] cookies, int[] candidates, int maxVal, int max, int zeroCount) {\\n        // If there are fewer cookies left than the number of empty slots (zeroCount),\\n        // it is not possible to distribute the cookies fairly\\n        if (cookies.length - idx < zeroCount) {\\n            return false;\\n        }\\n\\n        // Base case: If all cookies have been distributed\\n        if (idx == cookies.length) {\\n            // If the maximum number of cookies received by a child is greater than the maxVal,\\n            // it is not a fair distribution, so return false to indicate it\\'s not possible\\n            if (max > maxVal) {\\n                return false;\\n            }\\n            // Return true to indicate that the current distribution is fair\\n            return true;\\n        }\\n\\n        int c = cookies[idx];\\n        for (int i = 0; i < candidates.length; i++) {\\n            // Update the zeroCount if the child receives a cookie for the first time\\n            if (candidates[i] == 0) {\\n                zeroCount--;\\n            }\\n            // Add the current cookie to the child\\n            candidates[i] += c;\\n\\n            // Recursively check the next cookie with the updated distribution\\n            if (candidates[i] <= maxVal && isPossible(idx + 1, cookies, candidates, maxVal, Math.max(max, candidates[i]), zeroCount)) {\\n                // If the current distribution is fair, return true\\n                return true;\\n            }\\n\\n            // Remove the current cookie from the child\\n            candidates[i] -= c;\\n\\n            // Restore the zeroCount if the child no longer has any cookies\\n            if (candidates[i] == 0) {\\n                zeroCount++;\\n            }\\n        }\\n\\n        // Return false to indicate that it is not possible to distribute cookies fairly\\n        return false;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703485,
                "title": "c-simple-solution-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\nprivate:\\n    void solve(int index,vector<int>& cookies,vector<int>& ds,int k,int &ans){\\n        int n = cookies.size();\\n        if(index == n){\\n            int tp = INT_MIN;\\n            for(auto it : ds){\\n                tp = max(tp,it);\\n            }\\n            ans = min(ans,tp);\\n            return;\\n        }\\n        for(int i=0;i<k;i++){\\n            ds[i]+=cookies[index];\\n            solve(index+1,cookies,ds,k,ans);\\n            ds[i]-=cookies[index];\\n        }\\n\\n    }    \\npublic:\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        vector<int> ds(k,0);\\n        int ans=INT_MAX;\\n        solve(0,cookies,ds,k,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void solve(int index,vector<int>& cookies,vector<int>& ds,int k,int &ans){\\n        int n = cookies.size();\\n        if(index == n){\\n            int tp = INT_MIN;\\n            for(auto it : ds){\\n                tp = max(tp,it);\\n            }\\n            ans = min(ans,tp);\\n            return;\\n        }\\n        for(int i=0;i<k;i++){\\n            ds[i]+=cookies[index];\\n            solve(index+1,cookies,ds,k,ans);\\n            ds[i]-=cookies[index];\\n        }\\n\\n    }    \\npublic:\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        vector<int> ds(k,0);\\n        int ans=INT_MAX;\\n        solve(0,cookies,ds,k,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703478,
                "title": "backtracking-with-recursion-tree-diagram-and-optimization-method-explained-clearly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOk,The intuition here is simple you can give give 1 cookie to 1st child or 2nd child or kth child, same for every cookie and when you give one cookie to a child you just have to give another cookie for the same i.e you can give it to any child.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo as we can give a cookie from 1st child to kth child we can simply use a loop o that and if one cookie has been given then we have to use the next cookie so we have to keep track of the cookie number,we can track then as indexes.\\n\\nHere is the Tree Diagram of an example:\\ncookies[]: {8,15,10}, k = 2 \\n\\n![WhatsApp Image 2023-07-01 at 13.41.12.jpg](https://assets.leetcode.com/users/images/1fe85f94-7f37-45c5-a098-69d32cab0ef8_1688199118.5986788.jpeg)\\n\\nin the last level we have to find the maximum from the child array and then the answer will be the minimum of maximum which will be 18, if you carfully observe the last level.\\n\\n# **Now comes the optimization part:**\\nif in one node, we see that the maximum of that node (i.e the child array) is greater than the answer then there is no meaning to go into the depth of that node because if we go into the depth we can\\'t find any answer because in earlier node we see we have already greater number than the answer so if we go into the deep then two choices may arrive the previous greter number will be the the maximum of that node or a number which is greter than the previous maximum number will be the maximum of that node but this both will not be the answer beacuse the answer will be minimum of maximum, by this method we can eliminate some of the braches and can able to optimize the solution.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nAt max k branches possible in each level and total if n is cookies.size() then maximum leves possible is n. \\nSo Time Complexity will be O(k^n).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWe are using a child array of size k size so O(k) and the height of the tree will be at max n which is cookies.size(); \\nSo Space complexity: O(n+k)\\n\\n# Code\\n```\\nclass Solution {\\n    void helper(vector<int>& cookies,vector<int>child,int &ans,int ind)\\n    {\\n\\n        if(ind >= cookies.size())\\n        {\\n            //we have to find the maximum int child array \\n            int maxi = *max_element(child.begin(),child.end());\\n            \\n            //ans will be the minimum of maximum\\n            ans = min(ans,maxi);\\n            return;\\n        }\\n        // we can distribute this cookie in k children \\n        for(int i = 0; i < child.size();i++)\\n        {\\n            //i the child no suppose 0th cokkie is of the 0th child\\n            child[i] += cookies[ind];\\n            int maxi = *max_element(child.begin(),child.end());\\n            \\n            if(maxi < ans) helper(cookies,child,ans,ind+1);\\n            \\n            //backtrack\\n            child[i] -= cookies[ind];\\n\\n        }\\n    }\\npublic:\\n    int distributeCookies(vector<int>& cookies, int k)\\n    {\\n        vector<int>child(k,0);\\n        int ans = INT_MAX;\\n        helper(cookies,child,ans,0);\\n        return ans;\\n    }\\n};\\n```\\n**If this solution article helps you Please upvote it and if you have any question you can ask in the comment.**",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    void helper(vector<int>& cookies,vector<int>child,int &ans,int ind)\\n    {\\n\\n        if(ind >= cookies.size())\\n        {\\n            //we have to find the maximum int child array \\n            int maxi = *max_element(child.begin(),child.end());\\n            \\n            //ans will be the minimum of maximum\\n            ans = min(ans,maxi);\\n            return;\\n        }\\n        // we can distribute this cookie in k children \\n        for(int i = 0; i < child.size();i++)\\n        {\\n            //i the child no suppose 0th cokkie is of the 0th child\\n            child[i] += cookies[ind];\\n            int maxi = *max_element(child.begin(),child.end());\\n            \\n            if(maxi < ans) helper(cookies,child,ans,ind+1);\\n            \\n            //backtrack\\n            child[i] -= cookies[ind];\\n\\n        }\\n    }\\npublic:\\n    int distributeCookies(vector<int>& cookies, int k)\\n    {\\n        vector<int>child(k,0);\\n        int ans = INT_MAX;\\n        helper(cookies,child,ans,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702550,
                "title": "c-backtracking",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int k, res = INT_MAX;\\n    vector<int> d = {0, 0, 0, 0, 0, 0, 0, 0};\\n\\n    void S(vector<int> cookies, int index, int f) {\\n        if (index == cookies.size()) {\\n            int curr = 0;\\n            for (int i = 0; i < k; i++) curr = max(curr, d[i]);\\n            res = min(res, curr);\\n            return;\\n        }\\n\\n        for (int i = 0; i < f; i++) {\\n            d[i] += cookies[index];\\n            S(cookies, index + 1, f);\\n            d[i] -= cookies[index];\\n        }\\n\\n        if (f < k) {\\n            d[f] += cookies[index];\\n            S(cookies, index + 1, f + 1);\\n            d[f] -= cookies[index];\\n        }\\n\\n    }\\n\\n    int distributeCookies(vector<int>& cookies, int K) {\\n        k = K;\\n        S(cookies, 0, 0);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int k, res = INT_MAX;\\n    vector<int> d = {0, 0, 0, 0, 0, 0, 0, 0};\\n\\n    void S(vector<int> cookies, int index, int f) {\\n        if (index == cookies.size()) {\\n            int curr = 0;\\n            for (int i = 0; i < k; i++) curr = max(curr, d[i]);\\n            res = min(res, curr);\\n            return;\\n        }\\n\\n        for (int i = 0; i < f; i++) {\\n            d[i] += cookies[index];\\n            S(cookies, index + 1, f);\\n            d[i] -= cookies[index];\\n        }\\n\\n        if (f < k) {\\n            d[f] += cookies[index];\\n            S(cookies, index + 1, f + 1);\\n            d[f] -= cookies[index];\\n        }\\n\\n    }\\n\\n    int distributeCookies(vector<int>& cookies, int K) {\\n        k = K;\\n        S(cookies, 0, 0);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702522,
                "title": "simple-c-backtracking-100-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint final=INT_MAX;\\n  void solve(int i,vector<int>& cookies, int k, vector<int> &mask)\\n  {\\n      if(i==cookies.size())\\n      {\\n          int ans=INT_MIN;\\n          \\n          for(int i=0;i<k;i++) {\\n              ans=max(mask[i],ans);\\n              \\n          }\\n         final=min(ans,final);\\n          return ;\\n        \\n      }\\n     \\n      for(int it=0;it<k;it++)\\n      {\\n          mask[it]+=cookies[i];\\n        solve(i+1,cookies,k,mask);\\n          mask[it]-=cookies[i];\\n          if(mask[it]==0) break;\\n      }\\n      return ;\\n\\n  }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n       \\n       vector<int> mask(k,0);\\n        solve(0,cookies,k,mask);\\n        return final;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint final=INT_MAX;\\n  void solve(int i,vector<int>& cookies, int k, vector<int> &mask)\\n  {\\n      if(i==cookies.size())\\n      {\\n          int ans=INT_MIN;\\n          \\n          for(int i=0;i<k;i++) {\\n              ans=max(mask[i],ans);\\n              \\n          }\\n         final=min(ans,final);\\n          return ;\\n        \\n      }\\n     \\n      for(int it=0;it<k;it++)\\n      {\\n          mask[it]+=cookies[i];\\n        solve(i+1,cookies,k,mask);\\n          mask[it]-=cookies[i];\\n          if(mask[it]==0) break;\\n      }\\n      return ;\\n\\n  }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n       \\n       vector<int> mask(k,0);\\n        solve(0,cookies,k,mask);\\n        return final;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2361863,
                "title": "100-faster-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int ans = INT_MAX;\\n        \\n    void helper(int ind, int k, vector<int> &buckets, vector<int> &cookies){\\n        if(ind == cookies.size()){\\n            int large = *max_element(buckets.begin(), buckets.end());\\n            ans = min(ans, large);\\n            return;\\n        }\\n        \\n        for(int i=0;i<k;i++){\\n            buckets[i] += cookies[ind];\\n            helper(ind+1,k,buckets,cookies);\\n            buckets[i] -= cookies[ind];\\n            if(buckets[i]==0) break;\\n        }\\n    }\\n    \\n    int distributeCookies(vector<int>& cookies, int k) {\\n        if(k == cookies.size()){\\n            return *max_element(cookies.begin(), cookies.end());\\n        }\\n        \\n        vector<int> buckets(k, 0);\\n        helper(0, k, buckets, cookies);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int ans = INT_MAX;\\n        \\n    void helper(int ind, int k, vector<int> &buckets, vector<int> &cookies){\\n        if(ind == cookies.size()){\\n            int large = *max_element(buckets.begin(), buckets.end());\\n            ans = min(ans, large);\\n            return;\\n        }\\n        \\n        for(int i=0;i<k;i++){\\n            buckets[i] += cookies[ind];\\n            helper(ind+1,k,buckets,cookies);\\n            buckets[i] -= cookies[ind];\\n            if(buckets[i]==0) break;\\n        }\\n    }\\n    \\n    int distributeCookies(vector<int>& cookies, int k) {\\n        if(k == cookies.size()){\\n            return *max_element(cookies.begin(), cookies.end());\\n        }\\n        \\n        vector<int> buckets(k, 0);\\n        helper(0, k, buckets, cookies);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2273936,
                "title": "c-backtracking-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans=INT_MAX;\\n    void backtrack(vector<int>& cookies, int k,vector<int> &v,int idx)\\n    {\\n        if(idx>=cookies.size())\\n        {\\n            int res=INT_MIN;\\n            for(int i=0;i<k;i++)\\n            {\\n                res=max(res,v[i]);\\n            }\\n            ans=min(ans,res);\\n            return;\\n        }\\n        for(int i=0;i<k;i++)\\n        {\\n            v[i]+=cookies[idx];\\n            backtrack(cookies,k,v,idx+1);\\n            v[i]-=cookies[idx];\\n        }\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) \\n    {\\n        vector<int> v(k,0);\\n        backtrack(cookies,k,v,0);\\n        return ans;\\n        \\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    int ans=INT_MAX;\\n    void backtrack(vector<int>& cookies, int k,vector<int> &v,int idx)\\n    {\\n        if(idx>=cookies.size())\\n        {\\n            int res=INT_MIN;\\n            for(int i=0;i<k;i++)\\n            {\\n                res=max(res,v[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2178053,
                "title": "easy-to-understand-backtracking-c",
                "content": "This is my simple code using backtracking to solve this question. If you like it, please upvote.\\n```\\nvoid backtrack(int pos, vector<int> &cookies, vector<int> &current, int &res){\\n    if(pos == cookies.size()){\\n        int maxx=0;\\n        for(int i=0; i<current.size(); i++){\\n            maxx = max(maxx, current[i]);\\n        }\\n        res = min(res, maxx);\\n        return;\\n    }\\n    for(int i=0; i<current.size(); i++){\\n        current[i]+=cookies[pos];\\n        backtrack(pos+1, cookies, current, res);\\n        current[i]-=cookies[pos];\\n    }\\n}\\nclass Solution {\\npublic:\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int res = INT_MAX;\\n        vector<int> current(k, 0);\\n        backtrack(0, cookies, current, res);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nvoid backtrack(int pos, vector<int> &cookies, vector<int> &current, int &res){\\n    if(pos == cookies.size()){\\n        int maxx=0;\\n        for(int i=0; i<current.size(); i++){\\n            maxx = max(maxx, current[i]);\\n        }\\n        res = min(res, maxx);\\n        return;\\n    }\\n    for(int i=0; i<current.size(); i++){\\n        current[i]+=cookies[pos];\\n        backtrack(pos+1, cookies, current, res);\\n        current[i]-=cookies[pos];\\n    }\\n}\\nclass Solution {\\npublic:\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int res = INT_MAX;\\n        vector<int> current(k, 0);\\n        backtrack(0, cookies, current, res);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2162068,
                "title": "python-kind-of-dp-knapsack",
                "content": "Important part is to avoid duplicate calculations, this is one way:\\n```\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n        kids = [0] * k\\n        memo = dict()\\n        def dp(cookie):\\n            t = tuple(sorted(kids))\\n            if t in memo: return memo[t]\\n            if cookie == len(cookies): return max(kids)     \\n            result = math.inf\\n            for kid in range(k):\\n                kids[kid] += cookies[cookie]\\n                result = min(dp(cookie + 1), result)\\n                kids[kid] -= cookies[cookie]\\n            memo[t] = result\\n            return result                        \\n        return dp(0)   \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n        kids = [0] * k\\n        memo = dict()\\n        def dp(cookie):\\n            t = tuple(sorted(kids))\\n            if t in memo: return memo[t]\\n            if cookie == len(cookies): return max(kids)     \\n            result = math.inf\\n            for kid in range(k):\\n                kids[kid] += cookies[cookie]\\n                result = min(dp(cookie + 1), result)\\n                kids[kid] -= cookies[cookie]\\n            memo[t] = result\\n            return result                        \\n        return dp(0)   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2156565,
                "title": "java-simple-solution-find-all-combination",
                "content": "```\\nclass Solution {\\n    \\n    int maxCookies;\\n    \\n    public int distributeCookies(int[] cookies, int k) {   \\n        if (k == cookies.length) return getMax(cookies);\\n        maxCookies = Integer.MAX_VALUE;\\n        int[] childrens = new int[k];\\n        distributeCookies(cookies, childrens, 0);\\n        return maxCookies;\\n    }\\n    \\n    private void distributeCookies(int[] cookies, int[] childrens, int i) {\\n        if (i == cookies.length) {\\n            int max = getMax(childrens);\\n            if (max < maxCookies) maxCookies = max;\\n            return;\\n        }\\n        \\n        for (int j=0; j<childrens.length; j++) {\\n            childrens[j] += cookies[i]; \\n            distributeCookies(cookies, childrens, i+1);\\n            childrens[j] -= cookies[i]; \\n        }\\n    }\\n    \\n    private int getMax(int[] arr) {\\n        int max = -1;\\n        for (int ele : arr) if (max < ele) max = ele;\\n        return max;\\n    }\\n}",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "class Solution {\\n    \\n    int maxCookies;\\n    \\n    public int distributeCookies(int[] cookies, int k) {   \\n        if (k == cookies.length) return getMax(cookies);\\n        maxCookies = Integer.MAX_VALUE;\\n        int[] childrens = new int[k];\\n        distributeCookies(cookies, childrens, 0);\\n        return maxCookies;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2150352,
                "title": "c-two-solutions-binary-search-and-bactracking",
                "content": "This question is same as https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/\\n\\n\\n***Bactracking solution***\\n\\n```\\nclass Solution {\\npublic:\\n    int ans = INT_MAX;\\n    void backtrack(int ind, vector<int>& cookies, vector<int> child, int k){\\n        \\n        if(ind == cookies.size()){\\n            ans = min(ans, *max_element(child.begin(), child.end()));\\n            return;\\n        }\\n        \\n        for(int i = 0; i < k; i++){\\n            if(i > 0 && child[i] == child[i - 1]) continue;\\n            if(child[i] + cookies[ind] > ans) continue;\\n            child[i] += cookies[ind];\\n            \\n            backtrack(ind + 1, cookies, child, k);\\n            \\n            child[i] -= cookies[ind];\\n        }\\n    }    \\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int n = cookies.size();\\n        sort(cookies.begin(), cookies.end());\\n        vector<int> child(k, 0);\\n        backtrack(0, cookies, child, k);\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n***Binary Search***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n     bool ok(int max_cookies,int ind,vector<int>& cookies,int k,vector<int>& child){\\n        if(ind==cookies.size()){\\n            return true;\\n        }\\n        for(int i=0;i<k;i++){\\n            if(child[i]+cookies[ind]<=max_cookies){\\n                child[i] += cookies[ind];\\n                if(ok(max_cookies,ind+1,cookies,k,child)){\\n                    return true;\\n                }\\n                child[i] -= cookies[ind];\\n            }\\n            if(child[i]==0){\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    int distributeCookies(vector<int>& cookies, int k) {\\n       int n = cookies.size();\\n        int l = *max_element(cookies.begin(), cookies.end()), r = accumulate(cookies.begin(), cookies.end(), 0);\\n        vector<int> child(k, 0); \\n        sort(cookies.begin(), cookies.end());\\n        int ans = r;\\n        while(l <= r){\\n            int mid = (l + r) >> 1;\\n            fill(child.begin(),child.end(),0);\\n            if(ok(mid,0,cookies,k,child)){\\n                ans = mid;\\n                r = mid - 1;\\n            }\\n            else{\\n                l = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Backtracking",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = INT_MAX;\\n    void backtrack(int ind, vector<int>& cookies, vector<int> child, int k){\\n        \\n        if(ind == cookies.size()){\\n            ans = min(ans, *max_element(child.begin(), child.end()));\\n            return;\\n        }\\n        \\n        for(int i = 0; i < k; i++){\\n            if(i > 0 && child[i] == child[i - 1]) continue;\\n            if(child[i] + cookies[ind] > ans) continue;\\n            child[i] += cookies[ind];\\n            \\n            backtrack(ind + 1, cookies, child, k);\\n            \\n            child[i] -= cookies[ind];\\n        }\\n    }    \\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int n = cookies.size();\\n        sort(cookies.begin(), cookies.end());\\n        vector<int> child(k, 0);\\n        backtrack(0, cookies, child, k);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n     bool ok(int max_cookies,int ind,vector<int>& cookies,int k,vector<int>& child){\\n        if(ind==cookies.size()){\\n            return true;\\n        }\\n        for(int i=0;i<k;i++){\\n            if(child[i]+cookies[ind]<=max_cookies){\\n                child[i] += cookies[ind];\\n                if(ok(max_cookies,ind+1,cookies,k,child)){\\n                    return true;\\n                }\\n                child[i] -= cookies[ind];\\n            }\\n            if(child[i]==0){\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    int distributeCookies(vector<int>& cookies, int k) {\\n       int n = cookies.size();\\n        int l = *max_element(cookies.begin(), cookies.end()), r = accumulate(cookies.begin(), cookies.end(), 0);\\n        vector<int> child(k, 0); \\n        sort(cookies.begin(), cookies.end());\\n        int ans = r;\\n        while(l <= r){\\n            int mid = (l + r) >> 1;\\n            fill(child.begin(),child.end(),0);\\n            if(ok(mid,0,cookies,k,child)){\\n                ans = mid;\\n                r = mid - 1;\\n            }\\n            else{\\n                l = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2150153,
                "title": "next-permutation-binary-search-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool is_valid(vector<int>&arr,int k,int mid){\\n        int count = 1, sum = 0;\\n        for(int i=0;i<arr.size();i++){\\n            sum += arr[i];\\n            if(mid < arr[i]) return false;\\n            if(sum > mid){\\n                count++;\\n                sum = arr[i];\\n            }\\n        }\\n        return count <= k;\\n    }\\n    int solve(vector<int> &arr,int k){\\n        int l = *max_element(arr.begin(),arr.end());\\n        int r = accumulate(arr.begin(),arr.end(),0);\\n        int ans;\\n        while(l <= r){\\n            int mid = (l + r)/2;\\n            if(is_valid(arr,k,mid)){\\n                ans = mid;\\n                r = mid - 1;\\n            }\\n            else{\\n                l = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int distributeCookies(vector<int>& arr, int k) {\\n        int ans=1e9;\\n        sort(arr.begin(),arr.end());\\n        do{\\n            ans = min(ans,solve(arr,k));   \\n        }while(next_permutation(arr.begin(),arr.end()));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree",
                    "Probability and Statistics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool is_valid(vector<int>&arr,int k,int mid){\\n        int count = 1, sum = 0;\\n        for(int i=0;i<arr.size();i++){\\n            sum += arr[i];\\n            if(mid < arr[i]) return false;\\n            if(sum > mid){\\n                count++;\\n                sum = arr[i];\\n            }\\n        }\\n        return count <= k;\\n    }\\n    int solve(vector<int> &arr,int k){\\n        int l = *max_element(arr.begin(),arr.end());\\n        int r = accumulate(arr.begin(),arr.end(),0);\\n        int ans;\\n        while(l <= r){\\n            int mid = (l + r)/2;\\n            if(is_valid(arr,k,mid)){\\n                ans = mid;\\n                r = mid - 1;\\n            }\\n            else{\\n                l = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int distributeCookies(vector<int>& arr, int k) {\\n        int ans=1e9;\\n        sort(arr.begin(),arr.end());\\n        do{\\n            ans = min(ans,solve(arr,k));   \\n        }while(next_permutation(arr.begin(),arr.end()));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2140982,
                "title": "c-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        vector<int> cnt(k, 0);\\n        int ans = INT_MAX;\\n        dfs(cookies, cnt, 0, ans);\\n        return ans;\\n    }\\n\\nprivate: \\n    void dfs(vector<int>& cookies, vector<int>& cnt, int i, int& ans)\\n    {\\n        int n = cookies.size(), m = cnt.size();\\n        if (i == n)\\n        {\\n            ans = min(ans, *max_element(cnt.begin(), cnt.end()));\\n            return;\\n        }\\n        for (int j = 0; j < m; j++)\\n        {\\n            cnt[j] += cookies[i];\\n            dfs(cookies, cnt, i + 1, ans);\\n            cnt[j] -= cookies[i];\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        vector<int> cnt(k, 0);\\n        int ans = INT_MAX;\\n        dfs(cookies, cnt, 0, ans);\\n        return ans;\\n    }\\n\\nprivate: \\n    void dfs(vector<int>& cookies, vector<int>& cnt, int i, int& ans)\\n    {\\n        int n = cookies.size(), m = cnt.size();\\n        if (i == n)\\n        {\\n            ans = min(ans, *max_element(cnt.begin(), cnt.end()));\\n            return;\\n        }\\n        for (int j = 0; j < m; j++)\\n        {\\n            cnt[j] += cookies[i];\\n            dfs(cookies, cnt, i + 1, ans);\\n            cnt[j] -= cookies[i];\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2140926,
                "title": "c-backtracking-easy-66-ms-fastest-solution",
                "content": "```\\nclass Solution {\\n  public:\\n\\n    int distributeCookies(vector < int > & a, int k) {\\n      int ans = 1000000000;\\n      vector < vector < int >> bucket;\\n        \\n      //create K empty buckets\\n      for (int i = 0; i < k; i++) {\\n        bucket.push_back({});\\n      }\\n      back(a, a.size(), k, 0, bucket, ans);\\n      return ans;\\n    }\\n\\n  void back(vector < int > a, int n, int k, int i, vector < vector < int >> bucket, int & ans) {\\n    if (i == n) {\\n      if (k == 0) {\\n        int maxi = -1;\\n        for (auto array: bucket) \\n        {\\n          int sum = 0;\\n            \\n          for (auto val: array)\\n            sum += val;\\n\\n          maxi = max(maxi, sum);\\n        }\\n\\n        ans = min(ans, maxi); // here we are calculating final ans\\n      }\\n      return;\\n    }\\n    for (int j = 0; j < bucket.size(); j++) {\\n      if (bucket[j].size() == 0)\\n      {\\n        bucket[j].push_back(a[i]);\\n        back(a, n, k - 1, i + 1, bucket, ans);\\n        bucket[j].pop_back();\\n\\t\\tbreak;\\n      } \\n       else\\n      {\\n        bucket[j].push_back(a[i]);\\n        back(a, n, k, i + 1, bucket, ans);\\n        bucket[j].pop_back();\\n      }\\n    }\\n  }\\n};\\n```\\n\\nNo need to create K buckets to store elements we can store direct sum below code run much much faster 16ms only-\\n\\n```\\nclass Solution {\\n  public:\\n\\n    int distributeCookies(vector < int > & a, int k) {\\n      int ans = 1000000000;\\n      vector < int> bucket(k,0);  \\n      //create K empty buckets\\n\\t  \\n      back(a, a.size(), k, 0, bucket, ans);\\n      return ans;\\n    }\\n\\n  void back(vector < int > a, int n, int k, int i, vector <int> bucket, int & ans) {\\n    if (i == n) {\\n      if (k == 0) {\\n        int maxi = -1;\\n        for (auto array: bucket) \\n        {\\n          int sum = array;\\n\\n          maxi = max(maxi, sum);\\n        }\\n\\n        ans = min(ans, maxi); // here we are calculating final ans\\n      }\\n      return;\\n    }\\n    for (int j = 0; j < bucket.size(); j++) {\\n      if (bucket[j]==0)\\n      {\\n        bucket[j]+=(a[i]);\\n        back(a, n, k - 1, i + 1, bucket, ans);\\n        bucket[j]-=a[i];\\n\\t\\tbreak;\\n      } \\n       else\\n      {\\n        bucket[j]+=(a[i]);\\n        back(a, n, k, i + 1, bucket, ans);\\n        bucket[j]-=a[i];\\n      }\\n    }\\n  }\\n};\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n  public:\\n\\n    int distributeCookies(vector < int > & a, int k) {\\n      int ans = 1000000000;\\n      vector < vector < int >> bucket;\\n        \\n      //create K empty buckets\\n      for (int i = 0; i < k; i++) {\\n        bucket.push_back({});\\n      }\\n      back(a, a.size(), k, 0, bucket, ans);\\n      return ans;\\n    }\\n\\n  void back(vector < int > a, int n, int k, int i, vector < vector < int >> bucket, int & ans) {\\n    if (i == n) {\\n      if (k == 0) {\\n        int maxi = -1;\\n        for (auto array: bucket) \\n        {\\n          int sum = 0;\\n            \\n          for (auto val: array)\\n            sum += val;\\n\\n          maxi = max(maxi, sum);\\n        }\\n\\n        ans = min(ans, maxi); // here we are calculating final ans\\n      }\\n      return;\\n    }\\n    for (int j = 0; j < bucket.size(); j++) {\\n      if (bucket[j].size() == 0)\\n      {\\n        bucket[j].push_back(a[i]);\\n        back(a, n, k - 1, i + 1, bucket, ans);\\n        bucket[j].pop_back();\\n\\t\\tbreak;\\n      } \\n       else\\n      {\\n        bucket[j].push_back(a[i]);\\n        back(a, n, k, i + 1, bucket, ans);\\n        bucket[j].pop_back();\\n      }\\n    }\\n  }\\n};\\n```\n```\\nclass Solution {\\n  public:\\n\\n    int distributeCookies(vector < int > & a, int k) {\\n      int ans = 1000000000;\\n      vector < int> bucket(k,0);  \\n      //create K empty buckets\\n\\t  \\n      back(a, a.size(), k, 0, bucket, ans);\\n      return ans;\\n    }\\n\\n  void back(vector < int > a, int n, int k, int i, vector <int> bucket, int & ans) {\\n    if (i == n) {\\n      if (k == 0) {\\n        int maxi = -1;\\n        for (auto array: bucket) \\n        {\\n          int sum = array;\\n\\n          maxi = max(maxi, sum);\\n        }\\n\\n        ans = min(ans, maxi); // here we are calculating final ans\\n      }\\n      return;\\n    }\\n    for (int j = 0; j < bucket.size(); j++) {\\n      if (bucket[j]==0)\\n      {\\n        bucket[j]+=(a[i]);\\n        back(a, n, k - 1, i + 1, bucket, ans);\\n        bucket[j]-=a[i];\\n\\t\\tbreak;\\n      } \\n       else\\n      {\\n        bucket[j]+=(a[i]);\\n        back(a, n, k, i + 1, bucket, ans);\\n        bucket[j]-=a[i];\\n      }\\n    }\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3705949,
                "title": "python-very-fast-solution-using-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen distributing the cookies to the different children, we will have situations that are equal to come to a result. For example, it doesn\\'t matter if child1 gets the cookie, or child2 gets the cookie, the unfairness will be the same.\\n\\nSo we only need to store unique combinations of distributed cookies. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn order to only store unique combinations, I will use a Set. It is good to point out that a set can only contain tuples (and not lists), so I will convert the list to a tuple. \\n\\nEach set-element is a list/tuple containing the \"distribution\" of cookies, where distribution[i] is equal to the amount of cookies kid_i already got. Pay attention, because the order is not relevant, we will order the distrubtion before adding it back into the set (cookieDistribution). \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWe loop over the number of cookies, \\nand then the number of unique distributions, which is much smaller than non-unique distributions.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nA new cookieDistribution set needs to be created, which gives this solution a significant space complexity.\\n\\n# Code\\n```\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n        # Return minimum unfairness = maximum number cookies when minimum difference\\n        # Dynamic programming problem\\n        # Goal = max cookies as low as possible\\n        # each step, give cookies to 1-k kids\\n\\n        cookieDistribution = {tuple([0]*k)} # Initial distribution = every kid zero\\n        for cookie in cookies:\\n            # go over every existing distribution            \\n            newCookieDistribution = set()\\n            for distribution in cookieDistribution:\\n                # add to each child \\n                for i in range(k):\\n                    newDist = list(distribution)\\n                    newDist[i] += cookie\\n                    newCookieDistribution.add(tuple(sorted(newDist)))\\n            cookieDistribution = newCookieDistribution\\n\\n        return min([max(dist) for dist in cookieDistribution])\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n        # Return minimum unfairness = maximum number cookies when minimum difference\\n        # Dynamic programming problem\\n        # Goal = max cookies as low as possible\\n        # each step, give cookies to 1-k kids\\n\\n        cookieDistribution = {tuple([0]*k)} # Initial distribution = every kid zero\\n        for cookie in cookies:\\n            # go over every existing distribution            \\n            newCookieDistribution = set()\\n            for distribution in cookieDistribution:\\n                # add to each child \\n                for i in range(k):\\n                    newDist = list(distribution)\\n                    newDist[i] += cookie\\n                    newCookieDistribution.add(tuple(sorted(newDist)))\\n            cookieDistribution = newCookieDistribution\\n\\n        return min([max(dist) for dist in cookieDistribution])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3705455,
                "title": "c-solution-0ms-solution-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void backtrack(int num, vector<int>& cookies, int k, int& ans, vector<int>& count){\\n\\n        if(num == cookies.size()){\\n            int maxi = 0;\\n            for(int i = 0 ; i < k ; i++) maxi = max(maxi, count[i]);\\n            ans = min(ans, maxi);\\n            return;\\n        }\\n        if(*max_element(count.begin(), count.end()) >= ans) return;\\n\\n        for(int i = 0 ; i < k ; i++){\\n            count[i] += cookies[num];\\n            backtrack(num+1, cookies, k, ans, count);\\n            count[i] -= cookies[num];\\n            if(count[i] == 0) break;\\n        }\\n    }\\n\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        sort(cookies.begin(), cookies.end());\\n        int ans = INT_MAX;\\n        vector<int> count(k);\\n\\n        backtrack(0, cookies, k, ans, count);\\n        return ans;\\n    }\\n};\\n```\\n\\nSimilar Hard Question : [1723. Find Minimum Time to Finish All Jobs\\n](https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/solutions/3705432/c-solution-0ms-solution-beats-100-both-time-and-space-complexity/)",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void backtrack(int num, vector<int>& cookies, int k, int& ans, vector<int>& count){\\n\\n        if(num == cookies.size()){\\n            int maxi = 0;\\n            for(int i = 0 ; i < k ; i++) maxi = max(maxi, count[i]);\\n            ans = min(ans, maxi);\\n            return;\\n        }\\n        if(*max_element(count.begin(), count.end()) >= ans) return;\\n\\n        for(int i = 0 ; i < k ; i++){\\n            count[i] += cookies[num];\\n            backtrack(num+1, cookies, k, ans, count);\\n            count[i] -= cookies[num];\\n            if(count[i] == 0) break;\\n        }\\n    }\\n\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        sort(cookies.begin(), cookies.end());\\n        int ans = INT_MAX;\\n        vector<int> count(k);\\n\\n        backtrack(0, cookies, k, ans, count);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3705260,
                "title": "python-short-and-clean-backtracking-dfs",
                "content": "# Approach\\nTL;DR, Similar to [Editorial Solution](https://leetcode.com/problems/fair-distribution-of-cookies/editorial/) with an additional `average` based pruning.\\n\\n# Complexity\\n- Time complexity: $$O(k^n)$$\\n\\n- Space complexity: $$O(k + n)$$\\n\\nwhere, `n is number of cookies(bags)`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def distributeCookies(self, cookies: list[int], k: int) -> int:\\n        average = sum(cookies) // k\\n\\n        def min_unfairness(i: int, kids: list[int], zero_count: int) -> int:\\n            if i == len(cookies): return max(kids)\\n            unfairness = inf\\n\\n            if len(cookies) - i < zero_count: return unfairness # Prune if #cookies_left < #kids_with_zero\\n            optimal_next_kids = filter(lambda j: kids[j] < average, range(len(kids))) # Prune if kid_j has more cookies than average\\n\\n            for j in optimal_next_kids:\\n                is_kid_j_zero = int(kids[j] == 0)\\n                \\n                kids[j] += cookies[i]\\n                unfairness = min(unfairness, min_unfairness(i + 1, kids, zero_count - is_kid_j_zero))\\n                kids[j] -= cookies[i]\\n            \\n            return unfairness\\n        \\n        return min_unfairness(0, [0] * k, k)\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Backtracking"
                ],
                "code": "```python\\nclass Solution:\\n    def distributeCookies(self, cookies: list[int], k: int) -> int:\\n        average = sum(cookies) // k\\n\\n        def min_unfairness(i: int, kids: list[int], zero_count: int) -> int:\\n            if i == len(cookies): return max(kids)\\n            unfairness = inf\\n\\n            if len(cookies) - i < zero_count: return unfairness # Prune if #cookies_left < #kids_with_zero\\n            optimal_next_kids = filter(lambda j: kids[j] < average, range(len(kids))) # Prune if kid_j has more cookies than average\\n\\n            for j in optimal_next_kids:\\n                is_kid_j_zero = int(kids[j] == 0)\\n                \\n                kids[j] += cookies[i]\\n                unfairness = min(unfairness, min_unfairness(i + 1, kids, zero_count - is_kid_j_zero))\\n                kids[j] -= cookies[i]\\n            \\n            return unfairness\\n        \\n        return min_unfairness(0, [0] * k, k)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704545,
                "title": "python-simple-python-solution-using-dfs-backtracking",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 1208 ms, faster than 46.64% of Python3 online submissions for Fair Distribution of Cookies.\\n# Memory Usage: 16.2 MB, less than 89.55% of Python3 online submissions for Fair Distribution of Cookies.\\n\\n\\tclass Solution:\\n\\t\\tdef distributeCookies(self, cookies: List[int], k: int) -> int:\\n\\n\\t\\t\\tif len(cookies) == k:\\n\\t\\t\\t\\treturn max(cookies)\\n\\n\\t\\t\\tself.result = 100000000\\n\\n\\t\\t\\tchilds = [0] * k\\n\\n\\t\\t\\tdef DFS(cookies , index , childs , max_value):\\n\\n\\t\\t\\t\\tif index >= len(cookies):\\n\\n\\t\\t\\t\\t\\tself.result = min(self.result , max_value)\\n\\n\\t\\t\\t\\t\\treturn\\n\\n\\t\\t\\t\\tfor child_no in range(len(childs)):\\n\\n\\t\\t\\t\\t\\tchilds[child_no] = childs[child_no] + cookies[index]\\n\\n\\t\\t\\t\\t\\tcurrent_max_value = max(max_value , childs[child_no])\\n\\n\\t\\t\\t\\t\\tDFS(cookies , index + 1, childs , current_max_value)\\n\\n\\t\\t\\t\\t\\tchilds[child_no] = childs[child_no] - cookies[index]\\n\\n\\t\\t\\tDFS(cookies , 0 , childs , 0)\\n\\n\\t\\t\\treturn self.result\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 1208 ms, faster than 46.64% of Python3 online submissions for Fair Distribution of Cookies.\\n# Memory Usage: 16.2 MB, less than 89.55% of Python3 online submissions for Fair Distribution of Cookies.\\n\\n\\tclass Solution:\\n\\t\\tdef distributeCookies(self, cookies: List[int], k: int) -> int:\\n\\n\\t\\t\\tif len(cookies) == k:\\n\\t\\t\\t\\treturn max(cookies)\\n\\n\\t\\t\\tself.result = 100000000\\n\\n\\t\\t\\tchilds = [0] * k\\n\\n\\t\\t\\tdef DFS(cookies , index , childs , max_value):\\n\\n\\t\\t\\t\\tif index >= len(cookies):\\n\\n\\t\\t\\t\\t\\tself.result = min(self.result , max_value)\\n\\n\\t\\t\\t\\t\\treturn\\n\\n\\t\\t\\t\\tfor child_no in range(len(childs)):\\n\\n\\t\\t\\t\\t\\tchilds[child_no] = childs[child_no] + cookies[index]\\n\\n\\t\\t\\t\\t\\tcurrent_max_value = max(max_value , childs[child_no])\\n\\n\\t\\t\\t\\t\\tDFS(cookies , index + 1, childs , current_max_value)\\n\\n\\t\\t\\t\\t\\tchilds[child_no] = childs[child_no] - cookies[index]\\n\\n\\t\\t\\tDFS(cookies , 0 , childs , 0)\\n\\n\\t\\t\\treturn self.result\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D\\n",
                "codeTag": "Java"
            },
            {
                "id": 3704350,
                "title": "easy-backtracking-code-with-comments-explanation",
                "content": "# Intuition\\nVery easy approach with recursion for checking all the posibilities and backtracking for trying to give the cookie bag for each child to check all the possibilities\\n\\n# Approach\\n1. Define an array of numbers with the length of `k` and fill it with `0` because for first time the childs will have `0` cookies initially\\n2. Define a variable `ans` with a max number, Like positive `Infinity`\\n3. Define a recursion-backtracking function to check all the possibilities, this function will have this params => `ind`: index of the cookie bag, `childs`: the array of childs with their total cookies, and `bags`: array of cookie bags\\n    - `base-case` will be when you will finish the distribution of all the cookie bags\\n    - after all the distributions get the maximum cookie number from the childs\\n    - If the recent maximum cookie number is greater than the `ans` then store it in the `ans` because we need to get the minimum unfairness and it only possible with a max number of coookies from the childs should be minimum.\\n    - Ok, then go for traversing all the possibilities by running a loop on the `childs` array which we defined with all `zeroes`\\n    - everytime add the cookie bag for `i-th` child and call the same function with `index + 1` to check all the possibilities with the next cookie bag\\n    - then the backtracking step means remove the cookie-bag from the child and in the next itreation of the loop, the removed cookie-bag will be given to the next child.\\n\\nand that\\'s it, now you will have the minimum ans in the `ans`\\n\\n> IF YOU\\'RE ABLE TO UNDERSTAND THE APPROACH, GIVE IT A `UPVOTE \\u2B06`, SO THAT OTHER PEOPLE ALSO CAN TAKE HELP FROM IT.\\nTHANK YOU \\uD83E\\uDD1D FOR YOUR TIME \\u231A.\\n\\n# Complexity\\n- Time complexity: $$O(k^n)$$\\n\\n- Space complexity: $$O(k)$$\\n\\n# Javascript Code\\n```\\n/**\\n * @param {number[]} cookies\\n * @param {number} k\\n * @return {number}\\n */\\nvar distributeCookies = function (cookies, k) {\\n    // keep max number as the unfairness\\n    let ans = Infinity;\\n\\n    // initializing childs with 0 cookies\\n    const childs = new Array(k).fill(0);\\n\\n    function fairDistribution(ind, childs, bags) {\\n        // If we have distributed all the cookie bags\\n        if (ind === bags.length) {\\n\\n            // Get the maximum cookies a child have\\n            const maxCookie = Math.max(...childs);\\n            // store the minimum number of cookies\\n            ans = Math.min(maxCookie, ans);\\n\\n            return;\\n        }\\n\\n        // try all possibilities \\n        // by giving the cookie bag to each child once\\n        for (let i = 0; i < childs.length; i++) {\\n\\n            // Giving the cookie bag => bags[ind]\\n            childs[i] += bags[ind];\\n\\n            // go for the next cookie bag\\n            fairDistribution(ind + 1, childs, bags);\\n\\n            // Take the cookie bag back from the child [backtracking]\\n            childs[i] -= bags[ind];\\n        }\\n    }\\n\\n    fairDistribution(0, childs, cookies)\\n\\n    return ans;\\n};\\n\\n\\n```\\n\\n# Typescript Code\\n```\\nfunction distributeCookies(cookies: number[], k: number): number {\\n    // keep max number as the unfairness\\n    let ans: number = Infinity;\\n\\n    // initializing childs with 0 cookies\\n    const childs: Array<number> = new Array(k).fill(0);\\n\\n    function fairDistribution(ind: number, childs: number[], bags: number[]) {\\n        // If we have distributed all the cookie bags\\n        if (ind === bags.length) {\\n\\n            // Get the maximum cookies a child have\\n            const maxCookie = Math.max(...childs);\\n            // store the minimum number of cookies\\n            ans = Math.min(maxCookie, ans);\\n\\n            return;\\n        }\\n\\n        // try all possibilities \\n        // by giving the cookie bag to each child once\\n        for (let i: number = 0; i < childs.length; i++) {\\n\\n            // Giving the cookie bag => bags[ind]\\n            childs[i] += bags[ind];\\n\\n            // go for the next cookie bag\\n            fairDistribution(ind + 1, childs, bags);\\n\\n            // Take the cookie bag back from the child [backtracking]\\n            childs[i] -= bags[ind];\\n        }\\n    }\\n\\n    fairDistribution(0, childs, cookies)\\n\\n    return ans;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {number[]} cookies\\n * @param {number} k\\n * @return {number}\\n */\\nvar distributeCookies = function (cookies, k) {\\n    // keep max number as the unfairness\\n    let ans = Infinity;\\n\\n    // initializing childs with 0 cookies\\n    const childs = new Array(k).fill(0);\\n\\n    function fairDistribution(ind, childs, bags) {\\n        // If we have distributed all the cookie bags\\n        if (ind === bags.length) {\\n\\n            // Get the maximum cookies a child have\\n            const maxCookie = Math.max(...childs);\\n            // store the minimum number of cookies\\n            ans = Math.min(maxCookie, ans);\\n\\n            return;\\n        }\\n\\n        // try all possibilities \\n        // by giving the cookie bag to each child once\\n        for (let i = 0; i < childs.length; i++) {\\n\\n            // Giving the cookie bag => bags[ind]\\n            childs[i] += bags[ind];\\n\\n            // go for the next cookie bag\\n            fairDistribution(ind + 1, childs, bags);\\n\\n            // Take the cookie bag back from the child [backtracking]\\n            childs[i] -= bags[ind];\\n        }\\n    }\\n\\n    fairDistribution(0, childs, cookies)\\n\\n    return ans;\\n};\\n\\n\\n```\n```\\nfunction distributeCookies(cookies: number[], k: number): number {\\n    // keep max number as the unfairness\\n    let ans: number = Infinity;\\n\\n    // initializing childs with 0 cookies\\n    const childs: Array<number> = new Array(k).fill(0);\\n\\n    function fairDistribution(ind: number, childs: number[], bags: number[]) {\\n        // If we have distributed all the cookie bags\\n        if (ind === bags.length) {\\n\\n            // Get the maximum cookies a child have\\n            const maxCookie = Math.max(...childs);\\n            // store the minimum number of cookies\\n            ans = Math.min(maxCookie, ans);\\n\\n            return;\\n        }\\n\\n        // try all possibilities \\n        // by giving the cookie bag to each child once\\n        for (let i: number = 0; i < childs.length; i++) {\\n\\n            // Giving the cookie bag => bags[ind]\\n            childs[i] += bags[ind];\\n\\n            // go for the next cookie bag\\n            fairDistribution(ind + 1, childs, bags);\\n\\n            // Take the cookie bag back from the child [backtracking]\\n            childs[i] -= bags[ind];\\n        }\\n    }\\n\\n    fairDistribution(0, childs, cookies)\\n\\n    return ans;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3704045,
                "title": "backtracking-magic-finding-the-perfect-cookie-jar-balance-with-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is to distribute a given set of cookies among a fixed number of jars in such a way that the difference between the maximum and minimum number of cookies in any jar is minimized. To achieve this, we can use a recursive approach to explore all possible combinations of distributing the cookies among the jars.\\n# Approach\\n1. We can solve the problem using a recursive backtracking approach.\\n2. The recursive function will take the following parameters: `cookies` (vector of cookies), `jars` (vector representing the number of cookies in each jar), and `index` (the index of the current cookie).\\n3. The base case is when all cookies have been assigned to jars (i.e., `index` reaches the size of `cookies`). At this point, we calculate the maximum and minimum number of cookies in any jar and return the difference between them.\\n4. For each cookie, we have two options: assign it to the current jar or assign it to a different jar.\\n5. If we assign the current cookie to the current jar, we add its value to `jars[index]` and recursively call the function with `index + 1`.\\n6. After the recursive call, we undo the assignment by subtracting the cookie value from `jars[index]`.\\n7. If we assign the current cookie to a different jar, we iterate through all jars (starting from index 1) and do the following:\\n   - Add the cookie value to `jars[i]`.\\n   - Recursively call the function with `index + 1`.\\n   - After the recursive call, we undo the assignment by subtracting the cookie value from `jars[i]`.\\n8. We keep track of the minimum difference encountered throughout the recursive calls and return it as the final result.\\n\\nThis approach explores all possible combinations of assigning cookies to jars, effectively finding the minimum difference between the maximum and minimum number of cookies in any jar. It is a general approach that can be used to solve similar problems involving backtracking and optimization.\\n# Complexity\\n- Time complexity: **O(k^n)**\\nThe time complexity of this solution is O(k^n), where n is the number of cookies and k is the number of jars. In the worst case, the algorithm explores all possible combinations of assigning cookies to jars. Since there are k choices for each cookie, there will be k^n recursive calls.\\n- Space complexity: **O(k)**\\n- The space complexity is O(k) as we are using an additional jars vector of size k to keep track of the number of cookies in each jar during the recursive calls. The recursive stack also contributes to the space complexity, which is O(n) in the worst case when all cookies have to be assigned to jars.\\n\\n![tree.png](https://assets.leetcode.com/users/images/5ead34bc-006a-4c05-bc9b-514a1a8a183a_1688211105.1896133.png)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMinDifference(vector<int>& cookies, vector<int>& jars, int index) {\\n        int numCookies = cookies.size();\\n        int numJars = jars.size();\\n        \\n        // Base case: All cookies have been assigned to jars\\n        if (index == numCookies) {\\n            // Find the maximum number of cookies in any jar\\n            int maxCookies = jars[0];\\n            for (int i = 1; i < numJars; i++) {\\n                maxCookies = max(maxCookies, jars[i]);\\n            }\\n            return maxCookies;\\n        }\\n        \\n        // Assign the current cookie to the first jar\\n        jars[0] += cookies[index];\\n        int minDifference = findMinDifference(cookies, jars, index + 1);\\n        jars[0] -= cookies[index];\\n        \\n        // Try assigning the current cookie to each jar (except the first one)\\n        for (int i = 1; i < numJars; i++) {\\n            jars[i] += cookies[index];\\n            minDifference = min(minDifference, findMinDifference(cookies, jars, index + 1));\\n            jars[i] -= cookies[index];\\n        }\\n        \\n        return minDifference;\\n    }\\n    \\n    int distributeCookies(vector<int>& cookies, int k) {\\n        vector<int> jars(k, 0); // Initialize the jars with 0 cookies\\n        return findMinDifference(cookies, jars, 0);\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinDifference(vector<int>& cookies, vector<int>& jars, int index) {\\n        int numCookies = cookies.size();\\n        int numJars = jars.size();\\n        \\n        // Base case: All cookies have been assigned to jars\\n        if (index == numCookies) {\\n            // Find the maximum number of cookies in any jar\\n            int maxCookies = jars[0];\\n            for (int i = 1; i < numJars; i++) {\\n                maxCookies = max(maxCookies, jars[i]);\\n            }\\n            return maxCookies;\\n        }\\n        \\n        // Assign the current cookie to the first jar\\n        jars[0] += cookies[index];\\n        int minDifference = findMinDifference(cookies, jars, index + 1);\\n        jars[0] -= cookies[index];\\n        \\n        // Try assigning the current cookie to each jar (except the first one)\\n        for (int i = 1; i < numJars; i++) {\\n            jars[i] += cookies[index];\\n            minDifference = min(minDifference, findMinDifference(cookies, jars, index + 1));\\n            jars[i] -= cookies[index];\\n        }\\n        \\n        return minDifference;\\n    }\\n    \\n    int distributeCookies(vector<int>& cookies, int k) {\\n        vector<int> jars(k, 0); // Initialize the jars with 0 cookies\\n        return findMinDifference(cookies, jars, 0);\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703922,
                "title": "iterative-bits-enumeration-technique-clean-non-recursive-solution-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOne way to solve this problem is to use backtracking with recursion. But an interesting way is to use bitmasks to bruteforce all possible ways to split the cookies, here is the main idea.\\n\\nwe need to enumerate the ways to split each cookie to every child, consider an array ${b_1,b_2,b_3,.. b_n}$ representing that the $i$th cookie goes to the $b_i$th child, the maximum index of a child is 7 (0 based), so we can use atmost $log_2(k) = 3$ bits to represent each child.\\n\\nthen we can simply represent $b_1$ as the first 3 bits of the mask, $b_2$ as the next 3 bits and so on.. we need to loop over all $2^{3 \\\\cdot n}$ possibilities and find the best answer among them\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(2^{3 \\\\cdot N} \\\\cdot (N + K))$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(N+K)$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distributeCookies(vector<int>& a, int k) {\\n        ios::sync_with_stdio(0);cin.tie(0);\\n        int sum = 0 , maxx = 0;\\n        for(auto i:a){\\n            sum += i;\\n            maxx = max(maxx, i);\\n        }\\n        int x = a.size() , bits = (k <= 2 ? 1 : (k <= 4 ? 2 : 3));\\n        if(k == x)return maxx;\\n        if(k == 1)return sum;\\n        int cookies[k] , ans = 1e9;\\n        for(int msk = 0 ; msk <= (1<<(bits * x)) ; msk++){\\n            for(int i = 0; i < k; i++)\\n                cookies[i] = 0;\\n            int cur = 0;\\n            for(int i = 0 ;i < x ; i++){\\n                int bi = min(k-1, (msk >> (i * bits)) & ((1<<bits)-1));\\n                cur = max(cur , cookies[bi] += a[i]);\\n            }\\n            ans = min(ans, cur);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distributeCookies(vector<int>& a, int k) {\\n        ios::sync_with_stdio(0);cin.tie(0);\\n        int sum = 0 , maxx = 0;\\n        for(auto i:a){\\n            sum += i;\\n            maxx = max(maxx, i);\\n        }\\n        int x = a.size() , bits = (k <= 2 ? 1 : (k <= 4 ? 2 : 3));\\n        if(k == x)return maxx;\\n        if(k == 1)return sum;\\n        int cookies[k] , ans = 1e9;\\n        for(int msk = 0 ; msk <= (1<<(bits * x)) ; msk++){\\n            for(int i = 0; i < k; i++)\\n                cookies[i] = 0;\\n            int cur = 0;\\n            for(int i = 0 ;i < x ; i++){\\n                int bi = min(k-1, (msk >> (i * bits)) & ((1<<bits)-1));\\n                cur = max(cur , cookies[bi] += a[i]);\\n            }\\n            ans = min(ans, cur);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703914,
                "title": "c-khandani-backtracking-template-codestorywithmik-youtube-easy",
                "content": "My YouTube video Link - [Fair Distribution of Cookies](https://www.youtube.com/watch?v=vcaAC2fqFpk) \\nMy Github treasure - [Fair Distribution of Cookies](https://github.com/MAZHARMIK/Interview_DS_Algo/blob/master/Backtracking/Fair%20Distribution%20of%20Cookies.cpp)\\n\\n```\\n//TC : O(K^n)\\nclass Solution {\\npublic:\\n    \\n    int result = INT_MAX;\\n    int n;\\n    \\n    void solve(int idx, vector<int>& cookies, vector<int>& children, int k) {\\n        if(idx == cookies.size()) {\\n            \\n            int ans = *max_element(begin(children), end(children));\\n            result = min(result, ans);\\n            return;\\n        }\\n        \\n        int candy = cookies[idx];\\n        for(int i = 0; i<k; i++) {\\n            children[i] += candy;\\n            \\n            solve(idx+1, cookies, children, k);\\n            \\n            children[i] -= candy;\\n        }\\n        \\n    }\\n    \\n    int distributeCookies(vector<int>& cookies, int k) {\\n        n = cookies.size();\\n        vector<int> children(k);\\n        solve(0, cookies, children, k);\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//TC : O(K^n)\\nclass Solution {\\npublic:\\n    \\n    int result = INT_MAX;\\n    int n;\\n    \\n    void solve(int idx, vector<int>& cookies, vector<int>& children, int k) {\\n        if(idx == cookies.size()) {\\n            \\n            int ans = *max_element(begin(children), end(children));\\n            result = min(result, ans);\\n            return;\\n        }\\n        \\n        int candy = cookies[idx];\\n        for(int i = 0; i<k; i++) {\\n            children[i] += candy;\\n            \\n            solve(idx+1, cookies, children, k);\\n            \\n            children[i] -= candy;\\n        }\\n        \\n    }\\n    \\n    int distributeCookies(vector<int>& cookies, int k) {\\n        n = cookies.size();\\n        vector<int> children(k);\\n        solve(0, cookies, children, k);\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703053,
                "title": "beats-100-in-space-complexity-easy-to-understand-detailed-explanation-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->Although it seems like a dynamic programming question, simple recursion works due to the small limits of n and k. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor each cookie, we have to check by giving it to each kid (I have decalred it  as a kvector in the code), and when we reach the end, we can just return the maximum of the values in the kvector. There is a backtracking step involved here as well which is basically taking the cookie from the kid after computing the answer for each iteration, as we have to to give it to the next kid and compute the respective answer.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(k^n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(k)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int f(vector<int>& cookies,int k,int i,vector<int> &kvector){\\n        if(i==cookies.size()){\\n            int ans=0;\\n            for(int j=0;j<k;j++){\\n                ans=max(ans,kvector[j]);\\n            }\\n            return ans;\\n        }\\n\\n        int curr=INT_MAX;\\n        for(int j=0;j<k;j++){\\n            kvector[j]+=cookies[i];\\n            curr=min(curr,f(cookies,k,i+1,kvector));\\n            kvector[j]-=cookies[i];\\n        }\\n        return curr;\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        vector<int> kvector(k,0);\\n        \\n        return f(cookies,k,0,kvector);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int f(vector<int>& cookies,int k,int i,vector<int> &kvector){\\n        if(i==cookies.size()){\\n            int ans=0;\\n            for(int j=0;j<k;j++){\\n                ans=max(ans,kvector[j]);\\n            }\\n            return ans;\\n        }\\n\\n        int curr=INT_MAX;\\n        for(int j=0;j<k;j++){\\n            kvector[j]+=cookies[i];\\n            curr=min(curr,f(cookies,k,i+1,kvector));\\n            kvector[j]-=cookies[i];\\n        }\\n        return curr;\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        vector<int> kvector(k,0);\\n        \\n        return f(cookies,k,0,kvector);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703040,
                "title": "video-explanation-with-clean-code-c-100-simple-and-easy-to-understand",
                "content": "# Intuition & Approach\\n- Create a new vector a of size k to represent subsets. Since the constraints are low (n<=8), we can generate all possible subsets of size k.\\n\\n- Call the solve function.\\n\\n- Consider the base cases: If all elements have been considered,calculate the maximum number of cookies distributed according to the current subset.Return this value as ans.\\n\\n- After checking the base condition, create a variable \\'mn\\' and initialize it with the maximum value.\\n\\n Iterate over each subset:\\n\\n- Add the current element to the subset and keep track of the minimum sum obtained by comparing it with the value obtained from the recursive call.\\n\\n- Subtract the current element from the subset and move on to the next one.\\n\\n- Return the \\'ans\\' as the final result.\\n\\n\\n---\\n\\nhttps://www.youtube.com/watch?v=MxYLYnGtJjg\\n\\n# Complexity\\n- Time complexity: The backtracking approach explores all possible distributions. In the worst case, there can be up to k^N distributions, where k is the number of children and N is the number of cookies. Therefore, the time complexity is **O(k^N)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(K) for bucket, and O(N) for recursive stack space. So, total of **O(N+K)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int i, vector<int>& cookies, int k, int& ans,vector<int> &bucket)\\n    {\\n        //Base case\\n        if(i<0)\\n        {\\n            ans = min(ans, *max_element(bucket.begin(), bucket.end()));\\n            return ;\\n        }\\n        if(*max_element(bucket.begin(), bucket.end()) > ans) return;\\n        for(int idx = 0;idx<k;idx++)\\n        {\\n            bucket[idx] += cookies[i];\\n            solve(i-1, cookies, k, ans, bucket);\\n            bucket[idx] -= cookies[i];\\n        }\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int n = cookies.size();\\n        vector<int> bucket(k, 0);\\n        int ans = INT_MAX;\\n        solve(n-1,cookies, k,ans, bucket);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int i, vector<int>& cookies, int k, int& ans,vector<int> &bucket)\\n    {\\n        //Base case\\n        if(i<0)\\n        {\\n            ans = min(ans, *max_element(bucket.begin(), bucket.end()));\\n            return ;\\n        }\\n        if(*max_element(bucket.begin(), bucket.end()) > ans) return;\\n        for(int idx = 0;idx<k;idx++)\\n        {\\n            bucket[idx] += cookies[i];\\n            solve(i-1, cookies, k, ans, bucket);\\n            bucket[idx] -= cookies[i];\\n        }\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int n = cookies.size();\\n        vector<int> bucket(k, 0);\\n        int ans = INT_MAX;\\n        solve(n-1,cookies, k,ans, bucket);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702956,
                "title": "solution-using-backtracking-and-pruning-full-explanation",
                "content": "\\n\\n# Algorithm\\nThe solution uses a backtracking algorithm to find the minimum unfairness of distributing cookies among the children. \\n\\n- The distributeCookies function takes the input array cookies and the number of children k as parameters and returns the minimum unfairness.\\n\\n- It initializes minUnfairness to a maximum integer value and creates a distribution vector of size k to keep track of the number of cookies each child receives.\\n\\n- The backtrack function is a recursive function that explores all possible distributions of cookies among the children.\\n\\n- The base case is reached when all cookies have been distributed (i.e., index == cookies.size()). At this point, it calculates the maximum number of cookies received by any child using the getMaxCookies function and updates minUnfairness if necessary.\\n\\n- Before proceeding with the distribution, it checks if the current distribution is already unfairer than the current minimum unfairness (minUnfairness <= getMaxCookies(distribution)). If it is, there\\'s no need to continue exploring this branch, so the function returns.\\n\\n- It iterates through each child (using i from 0 to k-1) and performs the distribution by adding cookies[index] to the i-th child\\'s count. Then it recursively calls backtrack with the updated index + 1 to distribute the next cookie.\\n\\n- After the recursive call, it subtracts cookies[index] from the i-th child\\'s count to backtrack and explore other possibilities.\\n\\n- Finally, the getMaxCookies function calculates the maximum number of cookies received by any child in the current distribution. It iterates through the distribution vector and updates maxCookies if a larger number is found.\\n\\n# Complexity\\n- Time complexity:\\nO(k^N), where N is the number of cookies.\\n\\n- Space complexity:\\n O(k) since the distribution vector is of size k, and the recursion depth can go up to k.\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int minUnfairness = numeric_limits<int>::max();\\n        vector<int> distribution(k, 0);\\n        backtrack(cookies, k, 0, minUnfairness, distribution);\\n        return minUnfairness;\\n    }\\n    \\nprivate:\\n    void backtrack(const vector<int>& cookies, int k, int index, int& minUnfairness, vector<int>& distribution) {\\n        if (index == cookies.size()) {\\n            int maxCookies = getMaxCookies(distribution);\\n            minUnfairness = min(minUnfairness, maxCookies);\\n            return;\\n        }\\n        \\n        if (minUnfairness <= getMaxCookies(distribution)) {\\n            return;\\n        }\\n        \\n        for (int i = 0; i < k; i++) {\\n            distribution[i] += cookies[index];\\n            backtrack(cookies, k, index + 1, minUnfairness, distribution);\\n            distribution[i] -= cookies[index];\\n        }\\n    }\\n    \\n    int getMaxCookies(const vector<int>& distribution) {\\n        int maxCookies = numeric_limits<int>::min();\\n        for (int cookies : distribution) {\\n            maxCookies = max(maxCookies, cookies);\\n        }\\n        return maxCookies;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int minUnfairness = numeric_limits<int>::max();\\n        vector<int> distribution(k, 0);\\n        backtrack(cookies, k, 0, minUnfairness, distribution);\\n        return minUnfairness;\\n    }\\n    \\nprivate:\\n    void backtrack(const vector<int>& cookies, int k, int index, int& minUnfairness, vector<int>& distribution) {\\n        if (index == cookies.size()) {\\n            int maxCookies = getMaxCookies(distribution);\\n            minUnfairness = min(minUnfairness, maxCookies);\\n            return;\\n        }\\n        \\n        if (minUnfairness <= getMaxCookies(distribution)) {\\n            return;\\n        }\\n        \\n        for (int i = 0; i < k; i++) {\\n            distribution[i] += cookies[index];\\n            backtrack(cookies, k, index + 1, minUnfairness, distribution);\\n            distribution[i] -= cookies[index];\\n        }\\n    }\\n    \\n    int getMaxCookies(const vector<int>& distribution) {\\n        int maxCookies = numeric_limits<int>::min();\\n        for (int cookies : distribution) {\\n            maxCookies = max(maxCookies, cookies);\\n        }\\n        return maxCookies;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702828,
                "title": "easy-c-binary-search-solution",
                "content": "# Approach\\nExactly like the [minimum page allocation problem](https://practice.geeksforgeeks.org/problems/allocate-minimum-number-of-pages0937/1), but here the cookie bags can be in any order so we have to take the minimum from the all the answers generated by each permutation.\\nHere mid is calculating the maximum number of cookies per kid. So in that way we will decide whether to reduce the number of cookies per kid and increase the possible kids count or else we can increase the cookies per kid to decrease the number od kids count. \\n\\n\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool isPossible(vector<int>& cookies, int k, int mid){\\n        int noOfKids=1;\\n        int sum=0;\\n        for(int i=0;i<cookies.size();i++){\\n            if(cookies[i]>mid)return false;\\n            sum+=cookies[i];\\n            if(sum>mid){\\n                noOfKids++;\\n                sum=cookies[i];\\n            }\\n        }\\n        if(noOfKids>k)return false;\\n        return true;\\n    }\\n    int bs(vector<int>& cookies, int k){\\n        long long int lo=0, hi=INT_MAX, ans=0;\\n        while(lo<=hi){\\n            int mid=lo+(hi-lo)/2;\\n\\n            if(isPossible(cookies, k, mid)){\\n                ans=mid;\\n                hi=mid-1;\\n            }\\n            else{\\n                lo=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        sort(cookies.begin(), cookies.end());\\n        int ans=INT_MAX;\\n        do{\\n            ans=min(ans, bs(cookies, k));\\n        }while(next_permutation(cookies.begin(), cookies.end()));\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool isPossible(vector<int>& cookies, int k, int mid){\\n        int noOfKids=1;\\n        int sum=0;\\n        for(int i=0;i<cookies.size();i++){\\n            if(cookies[i]>mid)return false;\\n            sum+=cookies[i];\\n            if(sum>mid){\\n                noOfKids++;\\n                sum=cookies[i];\\n            }\\n        }\\n        if(noOfKids>k)return false;\\n        return true;\\n    }\\n    int bs(vector<int>& cookies, int k){\\n        long long int lo=0, hi=INT_MAX, ans=0;\\n        while(lo<=hi){\\n            int mid=lo+(hi-lo)/2;\\n\\n            if(isPossible(cookies, k, mid)){\\n                ans=mid;\\n                hi=mid-1;\\n            }\\n            else{\\n                lo=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        sort(cookies.begin(), cookies.end());\\n        int ans=INT_MAX;\\n        do{\\n            ans=min(ans, bs(cookies, k));\\n        }while(next_permutation(cookies.begin(), cookies.end()));\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702762,
                "title": "c-easy-backtrack-solution-with-explaination",
                "content": "# Intuition\\nwe try to give every cookie in every k distribution.\\n# Approach\\nWe will use simple Backtracking approach to solve this problem. When we reach the end of cookies we will return the max element present in the array. After backtrack, make sure to reduce the value of kth value of res because we try every possible distribution for the particular cookie.\\n\\n# Complexity\\n- Time complexity: O(k^n) where n is length of cookies\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(k+n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& cookies, int k,vector<int>&res,int i){\\n        if(i == cookies.size()){\\n            return *max_element(res.begin(),res.end());\\n        }\\n        int ans=INT_MAX;\\n        for(int j=0;j<k;j++){\\n            res[j] += cookies[i];\\n            ans=min(ans,solve(cookies,k,res,i+1));\\n            res[j] -= cookies[i];\\n        }\\n        return ans;\\n    }\\n\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        vector<int> res(k,0);\\n        return solve(cookies,k,res,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& cookies, int k,vector<int>&res,int i){\\n        if(i == cookies.size()){\\n            return *max_element(res.begin(),res.end());\\n        }\\n        int ans=INT_MAX;\\n        for(int j=0;j<k;j++){\\n            res[j] += cookies[i];\\n            ans=min(ans,solve(cookies,k,res,i+1));\\n            res[j] -= cookies[i];\\n        }\\n        return ans;\\n    }\\n\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        vector<int> res(k,0);\\n        return solve(cookies,k,res,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702630,
                "title": "c-solution-for-fair-distribution-of-cookies-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe goal is to distribute the cookies among the children in a way that minimizes the maximum total cookies obtained by a single child. To achieve this, we can use a backtracking approach to explore all possible distributions and track the minimum unfairness.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- We start with an initial distribution array, distribute, where each element represents the total number of cookies given to a child.\\n- We recursively explore all possible distributions by distributing the next cookie to each child and updating the unfairness accordingly.\\n- To distribute a cookie, we increment the corresponding child\\'s count and recursively distribute the next cookie.\\n- After distributing all cookies, we calculate the unfairness of the current distribution by finding the maximum count among all children.\\n- We track the minimum unfairness found so far and return it as the result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe backtracking approach explores all possible distributions. In the worst case, there can be up to k^N distributions, where k is the number of children and N is the number of cookies. Therefore, the time complexity is O(k^N).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(k) for the distribute array, which represents the count of cookies for each child. The recursion depth is at most N, so the overall space complexity is O(k + N).\\n\\n# Code\\n```\\npublic class Solution {\\n    public int DistributeCookies(int[] cookies, int k) {\\n        int[] distribute = new int[k];\\n        \\n        return DFS(0, distribute, cookies, k, k);\\n    }\\n\\n    private int DFS(int i, int[] distribute, int[] cookies, int k, int zeroCount) {\\n        // If there are not enough cookies remaining, return Int32.MaxValue\\n        // as it leads to an invalid distribution.\\n        if (cookies.Length - i < zeroCount) {\\n            return Int32.MaxValue;   \\n        }\\n\\n        // After distributing all cookies, return the unfairness of this\\n        // distribution.\\n        if (i == cookies.Length) {\\n            int unfairness = Int32.MinValue;\\n            foreach (int value in distribute) {\\n                unfairness = Math.Max(unfairness, value);\\n            }\\n            return unfairness;\\n        }\\n        \\n        // Try to distribute the i-th cookie to each child, and update answer\\n        // as the minimum unfairness in these distributions.\\n        int answer = Int32.MaxValue;\\n        for (int j = 0; j < k; ++j) {\\n            zeroCount -= distribute[j] == 0 ? 1 : 0;\\n            distribute[j] += cookies[i];\\n            \\n            // Recursively distribute the next cookie.\\n            answer = Math.Min(answer, DFS(i + 1, distribute, cookies, k, zeroCount));\\n            \\n            distribute[j] -= cookies[i];\\n            zeroCount += distribute[j] == 0 ? 1 : 0;\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int DistributeCookies(int[] cookies, int k) {\\n        int[] distribute = new int[k];\\n        \\n        return DFS(0, distribute, cookies, k, k);\\n    }\\n\\n    private int DFS(int i, int[] distribute, int[] cookies, int k, int zeroCount) {\\n        // If there are not enough cookies remaining, return Int32.MaxValue\\n        // as it leads to an invalid distribution.\\n        if (cookies.Length - i < zeroCount) {\\n            return Int32.MaxValue;   \\n        }\\n\\n        // After distributing all cookies, return the unfairness of this\\n        // distribution.\\n        if (i == cookies.Length) {\\n            int unfairness = Int32.MinValue;\\n            foreach (int value in distribute) {\\n                unfairness = Math.Max(unfairness, value);\\n            }\\n            return unfairness;\\n        }\\n        \\n        // Try to distribute the i-th cookie to each child, and update answer\\n        // as the minimum unfairness in these distributions.\\n        int answer = Int32.MaxValue;\\n        for (int j = 0; j < k; ++j) {\\n            zeroCount -= distribute[j] == 0 ? 1 : 0;\\n            distribute[j] += cookies[i];\\n            \\n            // Recursively distribute the next cookie.\\n            answer = Math.Min(answer, DFS(i + 1, distribute, cookies, k, zeroCount));\\n            \\n            distribute[j] -= cookies[i];\\n            zeroCount += distribute[j] == 0 ? 1 : 0;\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702460,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n        n=len(cookies)\\n\\n        @cache\\n        def fn(mask,k):\\n            if mask==0:\\n                return 0\\n\\n            if k==0:\\n                return inf\\n\\n            ans=inf\\n            orig=mask\\n\\n            while mask:\\n                mask=orig &(mask-1)\\n                res=sum(cookies[i] for i in range(n) if (orig^mask) & 1<<i)\\n                ans=min(ans,max(res,fn(mask,k-1)))\\n\\n            return ans\\n\\n        return fn((1<<n)-1,k)                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n        n=len(cookies)\\n\\n        @cache\\n        def fn(mask,k):\\n            if mask==0:\\n                return 0\\n\\n            if k==0:\\n                return inf\\n\\n            ans=inf\\n            orig=mask\\n\\n            while mask:\\n                mask=orig &(mask-1)\\n                res=sum(cookies[i] for i in range(n) if (orig^mask) & 1<<i)\\n                ans=min(ans,max(res,fn(mask,k-1)))\\n\\n            return ans\\n\\n        return fn((1<<n)-1,k)                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702309,
                "title": "java-dfs",
                "content": "```\\nclass Solution {\\n    private int dfs(int idx, int[] distribute, int[] cookies, int k, int zeroCount) {\\n        if (cookies.length - idx < zeroCount) {\\n            return Integer.MAX_VALUE;   \\n        }\\n\\n        if (idx == cookies.length) {\\n            int unfairness = Integer.MIN_VALUE;\\n            for (int value : distribute) {\\n                unfairness = Math.max(unfairness, value);\\n            }\\n            return unfairness;\\n        }\\n        \\n        int minUnfairness = Integer.MAX_VALUE;\\n        for (int j = 0; j < k; ++j) {\\n            zeroCount -= distribute[j] == 0 ? 1 : 0;\\n            distribute[j] += cookies[idx];\\n            \\n            minUnfairness = Math.min(minUnfairness, dfs(idx + 1, distribute, cookies, k, zeroCount));\\n            \\n            distribute[j] -= cookies[idx];\\n            zeroCount += distribute[j] == 0 ? 1 : 0;\\n        }\\n        \\n        return minUnfairness;\\n    }\\n    \\n    public int distributeCookies(int[] cookies, int k) {\\n        int[] distribute = new int[k];\\n        \\n        return dfs(0, distribute, cookies, k, k);\\n    }\\n}\\n```\\n\\n```\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    private int dfs(int idx, int[] distribute, int[] cookies, int k, int zeroCount) {\\n        if (cookies.length - idx < zeroCount) {\\n            return Integer.MAX_VALUE;   \\n        }\\n\\n        if (idx == cookies.length) {\\n            int unfairness = Integer.MIN_VALUE;\\n            for (int value : distribute) {\\n                unfairness = Math.max(unfairness, value);\\n            }\\n            return unfairness;\\n        }\\n        \\n        int minUnfairness = Integer.MAX_VALUE;\\n        for (int j = 0; j < k; ++j) {\\n            zeroCount -= distribute[j] == 0 ? 1 : 0;\\n            distribute[j] += cookies[idx];\\n            \\n            minUnfairness = Math.min(minUnfairness, dfs(idx + 1, distribute, cookies, k, zeroCount));\\n            \\n            distribute[j] -= cookies[idx];\\n            zeroCount += distribute[j] == 0 ? 1 : 0;\\n        }\\n        \\n        return minUnfairness;\\n    }\\n    \\n    public int distributeCookies(int[] cookies, int k) {\\n        int[] distribute = new int[k];\\n        \\n        return dfs(0, distribute, cookies, k, k);\\n    }\\n}\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702277,
                "title": "backtracking-python-js-solution",
                "content": "Hello **Tenno Leetcoders**, \\n\\nFor this problem, we are are given an integer array cookies, where `cookies[i]` denotes the number of cookies in the `ith` bag. We are also given an integer `k` that denotes the number of children to distribute all the bags of cookies to. All the cookies in the same bag must go to the same child and cannot be split up.\\n\\nThe unfairness of a distribution is defined as the maximum total cookies obtained by a single child in the distribution.\\n\\nReturn the minimum unfairness of all distributions.\\n\\n### Explanation\\n\\nTo ensure that no child receives significantly more cookies than others as we find the minimum unfairness of the distribution. \\nWe can use `backtracking` to allow us to explore all possible distributions of cookies among the children and find the one with the minimum unfairness. \\n\\n### dfs()\\n\\nOur dfs method performs the backtracking process which takes two parameters:\\n\\n- i: index of the current cookie to distribute\\n    \\n- count: the count of children with empty bags \\n    \\n#### base cases:\\n\\n- If there are not enough cookies remaining for distribution (n - i < zero_count), we cannot distribute the remaining cookies fairly to all children. In this case, return without making any further changes\\n    \\n- If cookies are all distributed (i == n), calculate the maximum number of cookies held by any child and update the minimum between the current minimum unfairness and the max cookies\\n    \\n#### backtracking\\n\\n- Iterate over each child from 0 to k and try to distribute the current cookie to that child.\\n\\n- Before any distribution happens, we need to update the bag count by decrementing if the current child bag was previously empty cur[j] == 0. if cur[j] == 0 becomes zero after decrementing, it means that all children have received at least one cookie. In such cases, continuing to distribute more cookies to the current child would result in an invalid or duplicate distribution. Therefore, we can prune the branches of the search space, reducing unnecessary computations.\\n\\n- Now add the current cookie for the current child by incrementing cur[j] by cookies[i]\\n\\n- Recursively call dfs method for the next cookie by incrementing i by 1 and passing the updated count to `count`\\n\\n- After the recursive call returns, we restore the previous state by subtracting the current cookie from the child\\'s bag and updating count accordingly. Also, update count by incrementing it if the child\\'s bag is now empty after removing the cookie cur[j] == 0.\\n\\nAfter the backtracking process, we call `dfs(0,k)` to start the backtracking process starting from the first cookie with all children having empty bags\\n\\nWe then return the value of min unfairness, which represents the minimum unfairness of all distributions.\\n\\n\\n# Code\\n\\n**Python**\\n```\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n        n = len(cookies)\\n        cur = [0] * k\\n        min_unfairness = float(\\'inf\\')\\n\\n        def dfs(i, zero_count):\\n            nonlocal min_unfairness\\n\\n            if n - i < zero_count: return\\n\\n            if i == n:\\n                max_cookies = max(cur)\\n                min_unfairness = min(min_unfairness, max_cookies)\\n                return\\n\\n            for j in range(k):\\n                zero_count -= int(cur[j] == 0)\\n                cur[j] += cookies[i]\\n                dfs(i + 1, zero_count)\\n                cur[j] -= cookies[i]\\n                zero_count += int(cur[j] == 0)\\n\\n        dfs(0, k)\\n        return min_unfairness\\n```\\n\\n\\n**JavaScript**\\n```\\n/**\\n * @param {number[]} cookies\\n * @param {number} k\\n * @return {number}\\n */\\nvar distributeCookies = function(cookies, k) {\\n    const n = cookies.length;\\n    const cur = new Array(k).fill(0);\\n    let minUnfairness = Infinity;\\n\\n    const dfs = (i, count) => {\\n        if(n - i < count) return\\n\\n        if(i === n){\\n            const maxCookies = Math.max(...cur)\\n            minUnfairness = Math.min(minUnfairness, maxCookies)\\n            return\\n        }\\n        \\n        for(let j = 0; j< k; j++){\\n            count -= cur[j] === 0 ? 1 : 0\\n            cur[j] += cookies[i]\\n            dfs(i+1, count)\\n            cur[j] -= cookies[i]\\n            count += cur[j] === 0 ? 1 : 0\\n        }\\n    }\\n    dfs(0, k)\\n    return minUnfairness\\n};\\n```\\n\\n### Time Complexity: O(k^n)\\n### Space Complexity: O(k+n)\\n\\n \\n***Warframe\\'s Darvo wants you to upvote this post  \\uD83D\\uDE4F\\uD83C\\uDFFB \\u2764\\uFE0F\\u200D\\uD83D\\uDD25***\\n\\n![image](https://assets.leetcode.com/users/images/814f5668-c966-46d7-ba42-e5435c4c1761_1675302761.3081913.gif)",
                "solutionTags": [
                    "Python3",
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n        n = len(cookies)\\n        cur = [0] * k\\n        min_unfairness = float(\\'inf\\')\\n\\n        def dfs(i, zero_count):\\n            nonlocal min_unfairness\\n\\n            if n - i < zero_count: return\\n\\n            if i == n:\\n                max_cookies = max(cur)\\n                min_unfairness = min(min_unfairness, max_cookies)\\n                return\\n\\n            for j in range(k):\\n                zero_count -= int(cur[j] == 0)\\n                cur[j] += cookies[i]\\n                dfs(i + 1, zero_count)\\n                cur[j] -= cookies[i]\\n                zero_count += int(cur[j] == 0)\\n\\n        dfs(0, k)\\n        return min_unfairness\\n```\n```\\n/**\\n * @param {number[]} cookies\\n * @param {number} k\\n * @return {number}\\n */\\nvar distributeCookies = function(cookies, k) {\\n    const n = cookies.length;\\n    const cur = new Array(k).fill(0);\\n    let minUnfairness = Infinity;\\n\\n    const dfs = (i, count) => {\\n        if(n - i < count) return\\n\\n        if(i === n){\\n            const maxCookies = Math.max(...cur)\\n            minUnfairness = Math.min(minUnfairness, maxCookies)\\n            return\\n        }\\n        \\n        for(let j = 0; j< k; j++){\\n            count -= cur[j] === 0 ? 1 : 0\\n            cur[j] += cookies[i]\\n            dfs(i+1, count)\\n            cur[j] -= cookies[i]\\n            count += cur[j] === 0 ? 1 : 0\\n        }\\n    }\\n    dfs(0, k)\\n    return minUnfairness\\n};\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3702249,
                "title": "rust",
                "content": "```\\nimpl Solution {\\n    pub fn distribute_cookies(cookies: Vec<i32>, k: i32) -> i32 {\\n        let mut a = vec![0; k as usize];\\n        Self::dfs(&cookies, &mut a, 0)\\n    }\\n\\n    fn dfs(cookies: &[i32], a: &mut [i32], i: usize) -> i32 {\\n        if i == cookies.len() {\\n            return *a.iter().max().unwrap();\\n        }\\n\\n        let mut t = i32::MAX;\\n        for j in 0..a.len() {\\n            a[j] += cookies[i];\\n            t = t.min(Self::dfs(cookies, a, i + 1));\\n            a[j] -= cookies[i];\\n        }\\n        t\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn distribute_cookies(cookies: Vec<i32>, k: i32) -> i32 {\\n        let mut a = vec![0; k as usize];\\n        Self::dfs(&cookies, &mut a, 0)\\n    }\\n\\n    fn dfs(cookies: &[i32], a: &mut [i32], i: usize) -> i32 {\\n        if i == cookies.len() {\\n            return *a.iter().max().unwrap();\\n        }\\n\\n        let mut t = i32::MAX;\\n        for j in 0..a.len() {\\n            a[j] += cookies[i];\\n            t = t.min(Self::dfs(cookies, a, i + 1));\\n            a[j] -= cookies[i];\\n        }\\n        t\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3669320,
                "title": "simple-recursion-solution-with-time-complexity-of-n-n",
                "content": "# Intuition\\nWe will simply brute force and try to distribute all the cookie bags to all the children.\\n\\n# Variables passed in recursive call stack :-\\n> mask : used to mark which bag of cookies have been distributed int the current tree.\\n\\n> count : how many children have been provided cookie bags(remember we can give more than one cookie bag to a children by no child should have zero cookie bags)\\n\\n> currentSum : this variable helps us to keep track that how many cookies have been given to current child ( (count)th child ).\\n\\n> maxSum : helps us to know the maximum cookies which a child gets while distribution.\\n\\n# Approach\\n// continue prev call (block of code)\\n 1 : what we are doing is just making a resursive call with the above variables present, and the looping over all the cookie bags(cookies) and try to figure out which bags have not been picked till the previous call by the previous childrens and the current childrens(1st to (count)th child) \\n(  #ignore above line for time being you will get it later)\\nAnd then we try to one by one pick all the cookies that were previously not picked and trying to make all the permutaions out and choosing the best permutation in which we can minimise the discrepancy.\\n2: what we do we for the next call stack we update the curentSum variable because the ( (count)th child ) picked the jth cookie bag,and also update the maxSum variable\\n\\n// start new(block of code)\\nin this block we first increase the count by one because we want to start fresh (means if a child was previously picking the cookie bags then we have stopped him and asked the next child to pick the cookie bags) and also reset the currentSum to zero as he have just started and not picked any cookie bags yet.\\n\\n// base case\\nif(candiesUsed variable is equal to cookies.size()) means we have distributed all the candies\\nnot its the time to update out answer and return \\nbut we will update our answer if and only if we have distribute the cookie bags to all the childrens(count==k) \\n\\n># Complexity\\n> - Time complexity:\\nO(n^n)\\n> - Space complexity:\\nO(n) \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int answer=INT_MAX;\\n    void f(int mask,int count,vector<int> &cookies,int k,int currentSum,int maxSum,int candiesUsed){\\n        if(candiesUsed == cookies.size()){\\n            if(count==k && currentSum!=0) answer=min(answer,maxSum);\\n            return;\\n        }\\n        // start new \\n        if(currentSum!=0) f(mask,count+1,cookies,k,0,maxSum,candiesUsed);\\n        // continue prev call;\\n        for(int j=0;j<cookies.size();j++){\\n            if((mask & 1<<j) == 0){\\n                f(mask|1<<j , count,cookies,k,currentSum+cookies[j],max(maxSum,currentSum+cookies[j]),1+candiesUsed);\\n            }\\n        }\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int maxSum=0;\\n        f(0,1,cookies,k,0,maxSum,0);\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int answer=INT_MAX;\\n    void f(int mask,int count,vector<int> &cookies,int k,int currentSum,int maxSum,int candiesUsed){\\n        if(candiesUsed == cookies.size()){\\n            if(count==k && currentSum!=0) answer=min(answer,maxSum);\\n            return;\\n        }\\n        // start new \\n        if(currentSum!=0) f(mask,count+1,cookies,k,0,maxSum,candiesUsed);\\n        // continue prev call;\\n        for(int j=0;j<cookies.size();j++){\\n            if((mask & 1<<j) == 0){\\n                f(mask|1<<j , count,cookies,k,currentSum+cookies[j],max(maxSum,currentSum+cookies[j]),1+candiesUsed);\\n            }\\n        }\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int maxSum=0;\\n        f(0,1,cookies,k,0,maxSum,0);\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3291531,
                "title": "solution-using-backtracking-easy-to-understand",
                "content": "\\tclass Solution:\\n\\t\\tdef distributeCookies(self, cookies: List[int], k: int) -> int:\\n\\t\\t\\tself.ans = inf\\n\\t\\t\\tself.length = len(cookies)\\n\\t\\t\\tcookies.sort(reverse = True)\\n\\t\\t\\tself.helper([0]*k,cookies,0,0,k)\\n\\t\\t\\treturn self.ans\\n\\n\\t\\tdef helper(self, child, cookies, ind,c,k):\\n\\t\\t\\tif ind < self.length:\\n\\t\\t\\t\\tfor j in range(k):\\n\\t\\t\\t\\t\\tif child[j] + cookies[ind] < self.ans:\\n\\t\\t\\t\\t\\t\\tchild[j] += cookies[ind]\\n\\t\\t\\t\\t\\t\\tself.helper(child,cookies,ind+1,j,k)\\n\\t\\t\\t\\t\\t\\tchild[j] -= cookies[ind]  \\n\\t\\t\\t\\treturn \\n\\t\\t\\tself.ans = min(self.ans,max(child))",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef distributeCookies(self, cookies: List[int], k: int) -> int:\\n\\t\\t\\tself.ans = inf\\n\\t\\t\\tself.length = len(cookies)\\n\\t\\t\\tcookies.sort(reverse = True)\\n\\t\\t\\tself.helper([0]*k,cookies,0,0,k)\\n\\t\\t\\treturn self.ans\\n\\n\\t\\tdef helper(self, child, cookies, ind,c,k):\\n\\t\\t\\tif ind < self.length:\\n\\t\\t\\t\\tfor j in range(k):\\n\\t\\t\\t\\t\\tif child[j] + cookies[ind] < self.ans:\\n\\t\\t\\t\\t\\t\\tchild[j] += cookies[ind]\\n\\t\\t\\t\\t\\t\\tself.helper(child,cookies,ind+1,j,k)\\n\\t\\t\\t\\t\\t\\tchild[j] -= cookies[ind]  \\n\\t\\t\\t\\treturn \\n\\t\\t\\tself.ans = min(self.ans,max(child))",
                "codeTag": "Java"
            },
            {
                "id": 2954167,
                "title": "100-faster-python-recursive-backtracking",
                "content": "```\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n        n = len(cookies)\\n        bucket = [0]*k\\n        def distribute(i= 0):\\n            nonlocal bucket\\n            ans = sys.maxsize\\n            visited = set()\\n            if i == n:\\n                return max(bucket)\\n            \\n            for j in range(k):\\n                if bucket[j] in visited:\\n                    continue\\n                visited.add(bucket[j])\\n                bucket[j]+=cookies[i]\\n                if max(bucket)<ans:\\n                    ans = min(ans,distribute(i+1))\\n                bucket[j]-=cookies[i]\\n            return ans\\n        cookies.sort(reverse = True)\\n        return distribute(0)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n        n = len(cookies)\\n        bucket = [0]*k\\n        def distribute(i= 0):\\n            nonlocal bucket\\n            ans = sys.maxsize\\n            visited = set()\\n            if i == n:\\n                return max(bucket)\\n            \\n            for j in range(k):\\n                if bucket[j] in visited:\\n                    continue\\n                visited.add(bucket[j])\\n                bucket[j]+=cookies[i]\\n                if max(bucket)<ans:\\n                    ans = min(ans,distribute(i+1))\\n                bucket[j]-=cookies[i]\\n            return ans\\n        cookies.sort(reverse = True)\\n        return distribute(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2317366,
                "title": "c-simple-recursive-approach-detailed-explanation",
                "content": "**Note:** If you do not understand the problem statement, go through the explanation in the code once and then read it again.\\n\\n**Rephrasing the problem statement:** Divide the given array into k subsequences and then find a subsequence which has largest sum out of all those subsequences. Out of all possible subsequences, find the min largest sum possible.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int unfairness = INT_MAX;\\n        \\n    void helper(int ind, int k, vector<int> &buckets, vector<int> &cookies){\\n        // Out of bounds\\n        if(ind >= cookies.size()){\\n            // Find the maximum total cookies obtained by one child\\n            int large = *max_element(buckets.begin(), buckets.end());\\n            unfairness = min(unfairness, large);\\n            return ;\\n        }\\n        \\n        // Adding cookie to the buckets\\n        // As there will be k buckets, we will add current cookie to each bucket \\n        for(int i=0; i<k; i++){\\n            // cout<<\"Adding cookie \"<<ind<<\" to \"<<i<<\"th bucket\"<<endl;\\n            buckets[i] += cookies[ind];\\n            helper(ind+1, k, buckets, cookies);\\n            buckets[i] -= cookies[ind];\\n        }\\n    }\\n    \\n    int distributeCookies(vector<int>& cookies, int k) {\\n\\t\\t// No.of students and cookie bags are same\\n        if(k == cookies.size()){\\n            return *max_element(cookies.begin(), cookies.end());\\n        }\\n        // Divide the array into k parts and find the min largest value\\n        vector<int> buckets(k, 0);\\n        helper(0, k, buckets, cookies);\\n        return unfairness;\\n    }\\n};\\n```\\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int unfairness = INT_MAX;\\n        \\n    void helper(int ind, int k, vector<int> &buckets, vector<int> &cookies){\\n        // Out of bounds\\n        if(ind >= cookies.size()){\\n            // Find the maximum total cookies obtained by one child\\n            int large = *max_element(buckets.begin(), buckets.end());\\n            unfairness = min(unfairness, large);\\n            return ;\\n        }\\n        \\n        // Adding cookie to the buckets\\n        // As there will be k buckets, we will add current cookie to each bucket \\n        for(int i=0; i<k; i++){\\n            // cout<<\"Adding cookie \"<<ind<<\" to \"<<i<<\"th bucket\"<<endl;\\n            buckets[i] += cookies[ind];\\n            helper(ind+1, k, buckets, cookies);\\n            buckets[i] -= cookies[ind];\\n        }\\n    }\\n    \\n    int distributeCookies(vector<int>& cookies, int k) {\\n\\t\\t// No.of students and cookie bags are same\\n        if(k == cookies.size()){\\n            return *max_element(cookies.begin(), cookies.end());\\n        }\\n        // Divide the array into k parts and find the min largest value\\n        vector<int> buckets(k, 0);\\n        helper(0, k, buckets, cookies);\\n        return unfairness;\\n    }\\n};\\n```\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2270765,
                "title": "python-backtracking-with-pruning-beat-100",
                "content": "Applying the similar pruning technique as in problem 1723. Find Minimum Time to Finish All Jobs.\\n```\\nclass Solution(object):\\n    def distributeCookies(self, cookies, k):\\n        self.ans = float(\\'inf\\')\\n        self.kids = [0] * k\\n        \\n        def backtrack(i):\\n            if i == len(cookies):\\n                self.ans = min(self.ans, max(self.kids))\\n                return\\n            \\n            seen = set()\\n            for j in range(k):\\n                if self.kids[j] in seen: # pruning condition 1\\n                    continue\\n                if self.kids[j] + cookies[i] > self.ans: # pruning condition 2\\n                    continue\\n                seen.add(self.kids[j])\\n                self.kids[j] += cookies[i]\\n                backtrack(i + 1)\\n                self.kids[j] -= cookies[i]\\n                \\n        backtrack(0)\\n        return self.ans\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution(object):\\n    def distributeCookies(self, cookies, k):\\n        self.ans = float(\\'inf\\')\\n        self.kids = [0] * k\\n        \\n        def backtrack(i):\\n            if i == len(cookies):\\n                self.ans = min(self.ans, max(self.kids))\\n                return\\n            \\n            seen = set()\\n            for j in range(k):\\n                if self.kids[j] in seen: # pruning condition 1\\n                    continue\\n                if self.kids[j] + cookies[i] > self.ans: # pruning condition 2\\n                    continue\\n                seen.add(self.kids[j])\\n                self.kids[j] += cookies[i]\\n                backtrack(i + 1)\\n                self.kids[j] -= cookies[i]\\n                \\n        backtrack(0)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2150807,
                "title": "c-binary-search-recursion-backtracking",
                "content": "* By Binary search find the maximum cookie given to a particular student. (`mid`).\\n\\n* Then Distribute in such  a way such that no student gets more than `mid` cookies.\\n\\n* If at the end of distribution we finished all cookies , it means we were successfull in giving cookies while satisfying the `barrier` condition.\\n```\\nclass Solution {\\npublic:\\n    bool solve(int pos ,vector<int>&cookies , vector<int>&distribute, int barrier ){\\n\\t//if all cookies were distributed , then distribution is valid for barrier max cookies \\n        if(pos >= cookies.size()) return true ;\\n        \\n        for(int i = 0 ; i < distribute.size() ; ++i ){\\n            if(distribute[i] + cookies[pos] > barrier) continue ;\\n            distribute[i] += cookies[pos] ;\\n            if(solve(pos + 1 , cookies,distribute,barrier)) return true ;\\n            distribute[i] -= cookies[pos] ;\\n        }\\n        \\n        return false ;\\n    }\\n    \\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int lo = 0 , hi = accumulate(begin(cookies),end(cookies),0) ;\\n        int ans = -1 ;\\n        while(lo <= hi){\\n            int mid = lo + (hi-lo) / 2 ;\\n\\t\\t\\t//distribution status of k students\\n            vector<int> distribute(k,0) ;\\n            if(solve(0,cookies,distribute,mid)){\\n                ans = mid ;\\n                hi = mid - 1 ;\\n            } else lo = mid + 1 ;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(int pos ,vector<int>&cookies , vector<int>&distribute, int barrier ){\\n\\t//if all cookies were distributed , then distribution is valid for barrier max cookies \\n        if(pos >= cookies.size()) return true ;\\n        \\n        for(int i = 0 ; i < distribute.size() ; ++i ){\\n            if(distribute[i] + cookies[pos] > barrier) continue ;\\n            distribute[i] += cookies[pos] ;\\n            if(solve(pos + 1 , cookies,distribute,barrier)) return true ;\\n            distribute[i] -= cookies[pos] ;\\n        }\\n        \\n        return false ;\\n    }\\n    \\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int lo = 0 , hi = accumulate(begin(cookies),end(cookies),0) ;\\n        int ans = -1 ;\\n        while(lo <= hi){\\n            int mid = lo + (hi-lo) / 2 ;\\n\\t\\t\\t//distribution status of k students\\n            vector<int> distribute(k,0) ;\\n            if(solve(0,cookies,distribute,mid)){\\n                ans = mid ;\\n                hi = mid - 1 ;\\n            } else lo = mid + 1 ;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2143881,
                "title": "binary-search-simple-solution-c",
                "content": "bool isvalid(vector<int> &cookies,int k,int mid)\\n    {   sort(cookies.begin(),cookies.end());\\n       \\n        do\\n        {\\n             int cnt=1;\\n        int x=0;\\n        int n=cookies.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            x=x+cookies[i];\\n            if(cookies[i]>x) return false;\\n            if(x>mid)\\n            {\\n                cnt++;\\n                x=cookies[i];\\n            }\\n        }\\n        \\n        if(cnt<=k)\\n        {\\n            return true;\\n            \\n        }\\n        }\\n        \\n        while(next_permutation(cookies.begin(),cookies.end()));\\n        \\n        return false;\\n    }\\n    \\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int ans;\\n        int n=cookies.size();\\n        int low=INT_MIN,high=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            high+=cookies[i];\\n            low=max(low,cookies[i]);\\n        }\\n      \\n        \\n        \\n        while(low<=high)\\n        {\\n            int mid=low +(high-low)/2;\\n        \\n            if(isvalid(cookies,k,mid))\\n            {  \\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n            \\n        }\\n        \\n       \\n        return ans;\\n        \\n    }",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "bool isvalid(vector<int> &cookies,int k,int mid)\\n    {   sort(cookies.begin(),cookies.end());\\n       \\n        do\\n        {\\n             int cnt=1;\\n        int x=0;\\n        int n=cookies.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            x=x+cookies[i];\\n            if(cookies[i]>x) return false;\\n            if(x>mid)\\n            {\\n                cnt++;\\n                x=cookies[i];\\n            }\\n        }\\n        \\n        if(cnt<=k)\\n        {\\n            return true;\\n            \\n        }\\n        }\\n        \\n        while(next_permutation(cookies.begin(),cookies.end()));\\n        \\n        return false;\\n    }\\n    \\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int ans;\\n        int n=cookies.size();\\n        int low=INT_MIN,high=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            high+=cookies[i];\\n            low=max(low,cookies[i]);\\n        }\\n      \\n        \\n        \\n        while(low<=high)\\n        {\\n            int mid=low +(high-low)/2;\\n        \\n            if(isvalid(cookies,k,mid))\\n            {  \\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n            \\n        }\\n        \\n       \\n        return ans;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2142896,
                "title": "can-anyone-tell-me-what-will-be-the-complexity-of-following-solution-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    bool divwithk(vector<int>&cookies,int k,int mid,int bitmask,int n,int sum,int i)\\n    {\\n        if(k==0 and bitmask==(1<<n)-1)return true;\\n        if(k==0)return false;\\n        if(i==n)return divwithk(cookies,k-1,mid,bitmask,n,0,0);\\n        //take\\n        bool ans=false;\\n        if(cookies[i]+sum<=mid and (bitmask&(1<<i))==0)\\n        {\\n            bitmask=(bitmask|(1<<i));\\n            ans=ans or divwithk(cookies,k,mid,bitmask,n,sum+cookies[i],i+1);\\n            bitmask=(bitmask^(1<<i));\\n        }\\n        ans=ans or divwithk(cookies,k,mid,bitmask,n,sum,i+1);\\n        return ans;\\n    }\\n    \\n    int distributeCookies(vector<int>& cookies, int k) {\\n        \\n        int l=0;\\n        int r=1e6;\\n        int ans=1e6;\\n        int  n=cookies.size();\\n      \\n        while(l<=r)\\n        {\\n            int mid=l+(r-l)/2;\\n            int bitmask=0;\\n            if(divwithk(cookies,k,mid,bitmask,n,0,0))\\n            {\\n                ans=mid;\\n                r=mid-1;\\n            }\\n            else l=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\ni fell it should be O(k * 2^n * (log(sum(array))))\\nplease tell me if i am correct and provide with the tc if i am wrong",
                "solutionTags": [
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool divwithk(vector<int>&cookies,int k,int mid,int bitmask,int n,int sum,int i)\\n    {\\n        if(k==0 and bitmask==(1<<n)-1)return true;\\n        if(k==0)return false;\\n        if(i==n)return divwithk(cookies,k-1,mid,bitmask,n,0,0);\\n        //take\\n        bool ans=false;\\n        if(cookies[i]+sum<=mid and (bitmask&(1<<i))==0)\\n        {\\n            bitmask=(bitmask|(1<<i));\\n            ans=ans or divwithk(cookies,k,mid,bitmask,n,sum+cookies[i],i+1);\\n            bitmask=(bitmask^(1<<i));\\n        }\\n        ans=ans or divwithk(cookies,k,mid,bitmask,n,sum,i+1);\\n        return ans;\\n    }\\n    \\n    int distributeCookies(vector<int>& cookies, int k) {\\n        \\n        int l=0;\\n        int r=1e6;\\n        int ans=1e6;\\n        int  n=cookies.size();\\n      \\n        while(l<=r)\\n        {\\n            int mid=l+(r-l)/2;\\n            int bitmask=0;\\n            if(divwithk(cookies,k,mid,bitmask,n,0,0))\\n            {\\n                ans=mid;\\n                r=mid-1;\\n            }\\n            else l=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141994,
                "title": "simple-java-solution",
                "content": "class Solution {\\n\\n   // declaring global ans and global min \\n   \\n    int gmin=Integer.MAX_VALUE;   \\n    int ans=0;\\n    public int distributeCookies(int[] cookies, int k) {\\n\\t\\n\\t// here we have to divide it into k boxes so we are using an array of size k\\n       int[]  res=new int[k];\\n\\t   \\n        rec(cookies,k,res,0);\\n        return ans;\\n        \\n     }\\n    \\n    public void rec(int[] cookies,int k,int[] res,int in){\\n        \\n        \\n        if(in==cookies.length){\\n            \\n            int min=Integer.MAX_VALUE;\\n            int max=Integer.MIN_VALUE;\\n            \\n\\t\\t\\t\\n            for(int i=0;i<k;i++){\\n                \\n                min=Math.min(res[i],min);\\n                max=Math.max(res[i],max);\\n                \\n                if(res[i]==0) return ;\\n\\t\\t\\t\\t\\n            }\\n\\t\\t\\t// just checking max diff bw boxes\\n            \\n          \\n            \\n            if(gmin>Math.abs(max-min)){\\n               \\n                ans=max;\\n                gmin=Math.abs(max-min);\\n            }\\n            return;\\n        }\\n        \\n        \\n    // distributing the cookies in k boxes\\n        for(int i=0;i<k;i++){\\n            \\n            res[i]+=cookies[in];\\n            \\n             rec(cookies,k,res,in+1);\\n            \\n\\t\\t\\t//  this is because every box have option to include it or exclude it\\n            res[i]-=cookies[in];\\n        }\\n   \\n    }\\n    \\n}",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\n   // declaring global ans and global min \\n   \\n    int gmin=Integer.MAX_VALUE;   \\n    int ans=0;\\n    public int distributeCookies(int[] cookies, int k) {\\n\\t\\n\\t// here we have to divide it into k boxes so we are using an array of size k\\n       int[]  res=new int[k];\\n\\t   \\n        rec(cookies,k,res,0);\\n        return ans;\\n        \\n     }",
                "codeTag": "Java"
            },
            {
                "id": 2141872,
                "title": "javascript-backtracking-dfs-146ms",
                "content": "Main idea: build up the possible conditions of split array into k subsequence, and get the unfairness of it, and min to result\\n```\\nconst initializeGraphSet = (n) => { let g = []; for (let i = 0; i < n; i++) { g.push(new Set()); } return g; };\\n\\nlet a, n, k, res;\\nconst distributeCookies = (cookies, K) => {\\n    a = cookies, k = K, n = a.length, res = Number.MAX_SAFE_INTEGER;\\n    dfs(0, initializeGraphSet(k));\\n    return res;\\n};\\n\\nconst dfs = (pos, cur) => { // save picked up index in cur[i]\\n    if (pos == n) {\\n        let v = unfairness(cur);\\n        // console.log(cur, debug(cur), v);\\n        res = Math.min(res, v);\\n        return;\\n    }\\n    for (let i = 0; i < k; i++) { // select k subsequence\\n        cur[i].add(pos);\\n        dfs(pos + 1, cur);\\n        cur[i].delete(pos);\\n        if (cur[i].size == 0) break;\\n    }\\n};\\n\\n/*\\nconst debug = (g) => {\\n    let d = [];\\n    g.map(se => {\\n        let t = [];\\n        for (const idx of se) t.push(a[idx]);\\n        d.push(t);\\n    });\\n    return d;\\n};\\n*/\\n\\nconst unfairness = (g) => Math.max(...g.map(se => sm(se)));\\nconst sm = (se) => { let sum = 0; for (const idx of se) sum += a[idx]; return sum; };\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nconst initializeGraphSet = (n) => { let g = []; for (let i = 0; i < n; i++) { g.push(new Set()); } return g; };\\n\\nlet a, n, k, res;\\nconst distributeCookies = (cookies, K) => {\\n    a = cookies, k = K, n = a.length, res = Number.MAX_SAFE_INTEGER;\\n    dfs(0, initializeGraphSet(k));\\n    return res;\\n};\\n\\nconst dfs = (pos, cur) => { // save picked up index in cur[i]\\n    if (pos == n) {\\n        let v = unfairness(cur);\\n        // console.log(cur, debug(cur), v);\\n        res = Math.min(res, v);\\n        return;\\n    }\\n    for (let i = 0; i < k; i++) { // select k subsequence\\n        cur[i].add(pos);\\n        dfs(pos + 1, cur);\\n        cur[i].delete(pos);\\n        if (cur[i].size == 0) break;\\n    }\\n};\\n\\n/*\\nconst debug = (g) => {\\n    let d = [];\\n    g.map(se => {\\n        let t = [];\\n        for (const idx of se) t.push(a[idx]);\\n        d.push(t);\\n    });\\n    return d;\\n};\\n*/\\n\\nconst unfairness = (g) => Math.max(...g.map(se => sm(se)));\\nconst sm = (se) => { let sum = 0; for (const idx of se) sum += a[idx]; return sum; };\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2141566,
                "title": "c-backtracking-solution-binary-search-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans=1e8;\\n    void find(vector<int>&nums,vector<int>&v,int k,int index)\\n    {\\n        if(index>=nums.size())\\n        {\\n            int mx=*max_element(v.begin(),v.end());\\n            ans=min(ans,mx);\\n            return ;\\n        }\\n        for(int i=0;i<k;i++)\\n        {\\n            v[i]+=nums[index];\\n            find(nums,v,k,index+1);\\n            v[i]-=nums[index];\\n        }\\n    }\\n    int distributeCookies(vector<int>&nums, int k) \\n    {\\n        vector<int>v(k);\\n        find(nums,v,k,0);\\n        return ans;\\n    }\\n};\\n```\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    bool find(vector<int>&nums,int k,int mid)\\n    {\\n        int count=1;\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=nums[i];\\n            if(mid<nums[i])\\n            {\\n                return false;\\n            }\\n            if(sum>mid)\\n            {\\n                count++;\\n                sum=nums[i];\\n            }\\n        }\\n        return count<=k;\\n    }\\n    int bs(vector<int>&nums,int k)\\n    {\\n        int l=0;\\n        int ans=0;\\n        int r=1e6;\\n        while(l<=r)\\n        {\\n            int mid=(l+r)/2;\\n            if(find(nums,k,mid))\\n            {\\n                ans=mid;\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int distributeCookies(vector<int>& nums, int k) \\n    {\\n        n=nums.size();\\n        int ans=1e8;\\n        sort(nums.begin(),nums.end());\\n        do\\n        {\\n         ans=min(ans,bs(nums,k));   \\n        }while(next_permutation(nums.begin(),nums.end()));\\n       \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=1e8;\\n    void find(vector<int>&nums,vector<int>&v,int k,int index)\\n    {\\n        if(index>=nums.size())\\n        {\\n            int mx=*max_element(v.begin(),v.end());\\n            ans=min(ans,mx);\\n            return ;\\n        }\\n        for(int i=0;i<k;i++)\\n        {\\n            v[i]+=nums[index];\\n            find(nums,v,k,index+1);\\n            v[i]-=nums[index];\\n        }\\n    }\\n    int distributeCookies(vector<int>&nums, int k) \\n    {\\n        vector<int>v(k);\\n        find(nums,v,k,0);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int n;\\n    bool find(vector<int>&nums,int k,int mid)\\n    {\\n        int count=1;\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=nums[i];\\n            if(mid<nums[i])\\n            {\\n                return false;\\n            }\\n            if(sum>mid)\\n            {\\n                count++;\\n                sum=nums[i];\\n            }\\n        }\\n        return count<=k;\\n    }\\n    int bs(vector<int>&nums,int k)\\n    {\\n        int l=0;\\n        int ans=0;\\n        int r=1e6;\\n        while(l<=r)\\n        {\\n            int mid=(l+r)/2;\\n            if(find(nums,k,mid))\\n            {\\n                ans=mid;\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int distributeCookies(vector<int>& nums, int k) \\n    {\\n        n=nums.size();\\n        int ans=1e8;\\n        sort(nums.begin(),nums.end());\\n        do\\n        {\\n         ans=min(ans,bs(nums,k));   \\n        }while(next_permutation(nums.begin(),nums.end()));\\n       \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141457,
                "title": "java-backtracking-recursion",
                "content": "```\\nclass Solution {\\n    public int distributeCookies(int[] cookies, int k) {\\n        int[] dist = new int[k];\\n\\t\\t// dist[i] is the amount of cookies ith children has\\n        return helper(cookies,dist,k,0,0);\\n    }\\n    public int helper(int[] cookies, int[] dist, int k, int i, int max){\\n\\t//max is the unfairness of the current distribution till now; \\n        if(i==cookies.length){\\n            return max;\\n        }\\n        int min = Integer.MAX_VALUE;\\n        for(int j=0;j<k;j++){\\n            dist[j]+=cookies[i];\\n            int max2 = Math.max(max,dist[j]);\\n            min = Math.min(helper(cookies,dist,k,i+1,max2),min);  //minimum unfairness\\n            dist[j]-=cookies[i];\\n        }\\n        return min;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int distributeCookies(int[] cookies, int k) {\\n        int[] dist = new int[k];\\n\\t\\t// dist[i] is the amount of cookies ith children has\\n        return helper(cookies,dist,k,0,0);\\n    }\\n    public int helper(int[] cookies, int[] dist, int k, int i, int max){\\n\\t//max is the unfairness of the current distribution till now; \\n        if(i==cookies.length){\\n            return max;\\n        }\\n        int min = Integer.MAX_VALUE;\\n        for(int j=0;j<k;j++){\\n            dist[j]+=cookies[i];\\n            int max2 = Math.max(max,dist[j]);\\n            min = Math.min(helper(cookies,dist,k,i+1,max2),min);  //minimum unfairness\\n            dist[j]-=cookies[i];\\n        }\\n        return min;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141241,
                "title": "python-backtrack-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n        result = float(\\'inf\\')\\n        children = [0] * k\\n        \\n        def backtrack(index):\\n            nonlocal result, children\\n            \\n            if index == len(cookies):\\n                result = min(result, max(children))\\n                return\\n\\t\\t\\t\\t\\n\\t\\t\\t# key point to pass the TLE!\\n            if result <= max(children):\\n                return\\n            \\n            for i in range(k):\\n                children[i] += cookies[index]\\n                backtrack(index + 1)\\n                children[i] -= cookies[index]\\n                \\n        backtrack(0)\\n        \\n        return result",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n        result = float(\\'inf\\')\\n        children = [0] * k\\n        \\n        def backtrack(index):\\n            nonlocal result, children\\n            \\n            if index == len(cookies):\\n                result = min(result, max(children))\\n                return\\n\\t\\t\\t\\t\\n\\t\\t\\t# key point to pass the TLE!\\n            if result <= max(children):\\n                return\\n            \\n            for i in range(k):\\n                children[i] += cookies[index]\\n                backtrack(index + 1)\\n                children[i] -= cookies[index]\\n                \\n        backtrack(0)\\n        \\n        return result",
                "codeTag": "Java"
            },
            {
                "id": 2141196,
                "title": "python3-bitmask-dp",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/e59b5d5832483707a595ae92b9aa1fb456986009) for solutions of weekly 297\\n\\n```\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n        n = len(cookies)\\n        \\n        @cache\\n        def fn(mask, k):\\n            \"\"\"Return min unfairness of distributing cookies marked by mask to k children.\"\"\"\\n            if mask == 0: return 0 \\n            if k == 0: return inf\\n            ans = inf \\n            orig = mask \\n            while mask: \\n                mask = orig & (mask - 1)\\n                amt = sum(cookies[i] for i in range(n) if (orig ^ mask) & 1<<i)\\n                ans = min(ans, max(amt, fn(mask, k-1)))\\n            return ans \\n        \\n        return fn((1<<n)-1, k)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n        n = len(cookies)\\n        \\n        @cache\\n        def fn(mask, k):\\n            \"\"\"Return min unfairness of distributing cookies marked by mask to k children.\"\"\"\\n            if mask == 0: return 0 \\n            if k == 0: return inf\\n            ans = inf \\n            orig = mask \\n            while mask: \\n                mask = orig & (mask - 1)\\n                amt = sum(cookies[i] for i in range(n) if (orig ^ mask) & 1<<i)\\n                ans = min(ans, max(amt, fn(mask, k-1)))\\n            return ans \\n        \\n        return fn((1<<n)-1, k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141139,
                "title": "dfs",
                "content": "```\\n  class Solution {\\npublic:\\n\\n    int dfs(int i,vector<int> &cur_sum,vector<int> &cookies)\\n    {\\n        if(i == cookies.size())\\n            return *max_element(cur_sum.begin() ,cur_sum.end());\\n    \\n        \\n        int res = INT_MAX;\\n        for(int k=0;k<cur_sum.size();k++)\\n        {\\n            cur_sum[k] += cookies[i];\\n            res = min(res, dfs(i+1,cur_sum,cookies));\\n            cur_sum[k] -= cookies[i];\\n        }\\n        \\n        return res;\\n    }\\n    \\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int n = cookies.size();\\n        if(n == k)\\n            return *max_element(cookies.begin() ,cookies.end());\\n        int sum = 0;\\n        for(auto &cookie : cookies)\\n            sum += cookie;\\n        \\n        vector<int> cur_sum(k,0);\\n        return dfs(0,cur_sum,cookies);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n  class Solution {\\npublic:\\n\\n    int dfs(int i,vector<int> &cur_sum,vector<int> &cookies)\\n    {\\n        if(i == cookies.size())\\n            return *max_element(cur_sum.begin() ,cur_sum.end());\\n    \\n        \\n        int res = INT_MAX;\\n        for(int k=0;k<cur_sum.size();k++)\\n        {\\n            cur_sum[k] += cookies[i];\\n            res = min(res, dfs(i+1,cur_sum,cookies));\\n            cur_sum[k] -= cookies[i];\\n        }\\n        \\n        return res;\\n    }\\n    \\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int n = cookies.size();\\n        if(n == k)\\n            return *max_element(cookies.begin() ,cookies.end());\\n        int sum = 0;\\n        for(auto &cookie : cookies)\\n            sum += cookie;\\n        \\n        vector<int> cur_sum(k,0);\\n        return dfs(0,cur_sum,cookies);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141079,
                "title": "c-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int res;\\n    void go(int i, int k, int mask, int val, int n, vector <int> &sum) {\\n      if (i == k) {\\n        // Make sure all of The cookies are finished.\\n        if (mask == 0) {\\n          res = min(res, val);\\n        } \\n        return;\\n      }\\n      /*\\n        Iterate thrrugh all the subsets of cuurent avaialbe cookies\\n        an assgn to ith person\\n        And try all the possibiltes\\n      */\\n      for (int nmask = 1; nmask < (1 << n); nmask++) {\\n        if ((nmask & mask) == nmask) {\\n          go(i + 1, k, mask^(nmask), max(val, sum[nmask]), n, sum);\\n        }\\n      }\\n      return;\\n    }\\n    int distributeCookies(vector<int>& a, int k) {\\n        int n = a.size();\\n        vector <int> sum(1 << n);\\n        /*\\n          Calcaulte the sum of cookies for all the possible susbsets \\n          given.\\n        */\\n        for (int mask = 0; mask < (1 << n); ++mask) {\\n          for (int i = 0; i < n; ++i) {\\n            if (mask >> i & 1) {\\n              sum[mask] += a[i];\\n            }\\n          }\\n        }\\n        res = 2e9;\\n        go(0, k, (1 << n) - 1, 0, n, sum);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int res;\\n    void go(int i, int k, int mask, int val, int n, vector <int> &sum) {\\n      if (i == k) {\\n        // Make sure all of The cookies are finished.\\n        if (mask == 0) {\\n          res = min(res, val);\\n        } \\n        return;\\n      }\\n      /*\\n        Iterate thrrugh all the subsets of cuurent avaialbe cookies\\n        an assgn to ith person\\n        And try all the possibiltes\\n      */\\n      for (int nmask = 1; nmask < (1 << n); nmask++) {\\n        if ((nmask & mask) == nmask) {\\n          go(i + 1, k, mask^(nmask), max(val, sum[nmask]), n, sum);\\n        }\\n      }\\n      return;\\n    }\\n    int distributeCookies(vector<int>& a, int k) {\\n        int n = a.size();\\n        vector <int> sum(1 << n);\\n        /*\\n          Calcaulte the sum of cookies for all the possible susbsets \\n          given.\\n        */\\n        for (int mask = 0; mask < (1 << n); ++mask) {\\n          for (int i = 0; i < n; ++i) {\\n            if (mask >> i & 1) {\\n              sum[mask] += a[i];\\n            }\\n          }\\n        }\\n        res = 2e9;\\n        go(0, k, (1 << n) - 1, 0, n, sum);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141077,
                "title": "c-binary-search-easy-o-n-time",
                "content": "```\\nclass Solution {\\n    \\n    bool go( vector<int>&A , int T , int k )\\n    {\\n        int s = 0 ;\\n        int cnt = 1 ;\\n        \\n        for( auto x : A )\\n        {\\n            if( s + x > T )\\n            {\\n                cnt++;\\n                s = x ;\\n            }\\n            else\\n                s += x ;\\n        }\\n        return cnt <= k ; \\n    }\\n\\n    bool ok( vector<int>A , int T , int k )\\n    {\\n        for( auto x : A )\\n            if( x > T )\\n                return 0 ;\\n        \\n        sort( A.begin() , A.end() );\\n        \\n        do{\\n            if( go( A , T , k ) )\\n                return 1 ;\\n        }\\n        while( next_permutation( A.begin() , A.end() ) );\\n\\n        return 0 ;                \\n    }\\n    \\n    public:\\n    int distributeCookies(vector<int>& A , int k) {\\n        int l = 0 ; \\n        int h = 1e9 ;\\n        while( l <= h )\\n        {\\n            int m = (l+h)>>1 ; \\n            if( ok( A , m , k ) )\\n                h = m-1 ;\\n            else \\n                l = m+1 ;\\n        }\\n        return l ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    \\n    bool go( vector<int>&A , int T , int k )\\n    {\\n        int s = 0 ;\\n        int cnt = 1 ;\\n        \\n        for( auto x : A )\\n        {\\n            if( s + x > T )\\n            {\\n                cnt++;\\n                s = x ;\\n            }\\n            else\\n                s += x ;\\n        }\\n        return cnt <= k ; \\n    }\\n\\n    bool ok( vector<int>A , int T , int k )\\n    {\\n        for( auto x : A )\\n            if( x > T )\\n                return 0 ;\\n        \\n        sort( A.begin() , A.end() );\\n        \\n        do{\\n            if( go( A , T , k ) )\\n                return 1 ;\\n        }\\n        while( next_permutation( A.begin() , A.end() ) );\\n\\n        return 0 ;                \\n    }\\n    \\n    public:\\n    int distributeCookies(vector<int>& A , int k) {\\n        int l = 0 ; \\n        int h = 1e9 ;\\n        while( l <= h )\\n        {\\n            int m = (l+h)>>1 ; \\n            if( ok( A , m , k ) )\\n                h = m-1 ;\\n            else \\n                l = m+1 ;\\n        }\\n        return l ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035589,
                "title": "easy-self-explanatory-code-two-approaches-backtracking-and-dp-bitmask",
                "content": "# Approach 1 - Backtracking\\n```\\nclass Solution{\\nprivate:\\n    int ans;\\n    void dfs(vector<int> &cookies, vector<int> &bag, int i, int k){\\n        // base case\\n        if(i==cookies.size()){\\n            ans=min(ans,*max_element(bag.begin(),bag.end()));\\n            return;\\n        }\\n        if(i>cookies.size())    return;\\n        // calling recursion\\n        for(int j=0;j<k;j++){\\n            bag[j]+=cookies[i];\\n            if(*max_element(bag.begin(),bag.end())<ans)\\n                dfs(cookies,bag,i+1,k);\\n            bag[j]-=cookies[i];\\n        }\\n    }\\npublic:\\n    int distributeCookies(vector<int> &cookies, int k){\\n        // using backtracking or dfs\\n        vector<int> bag(k,0);\\n        ans=INT_MAX;\\n        dfs(cookies,bag,0,k);\\n        return ans;\\n    }\\n};\\n```\\n# Approach 2 - Bitmask DP\\n```\\nclass Solution {\\nprivate:\\n    int n, k;\\n    int finalMask;\\n    int dp[8][1 << 8];\\n    int solve(vector<int>& cookies, int i, int mask) {\\n        // base case\\n        if(i == k) {\\n            if(mask == finalMask)   return 0;\\n            return 1e6;\\n        }\\n        // memoization case\\n        if(dp[i][mask] != -1)   return dp[i][mask];\\n        // calling recursion\\n        int tobeTaken = 0;\\n        for(int b = 0; b < n; b++) {\\n            if(!(mask & (1 << b)))\\n                tobeTaken |= (1 << b);\\n        }\\n        int subMask = tobeTaken;\\n        int ret = INT_MAX;\\n        while(subMask) {\\n            int curr = 0;\\n            for(int b = 0; b < n; b++) {\\n                if(subMask & (1 << b))\\n                    curr += cookies[b];\\n            }\\n            ret = min(ret, max(curr, solve(cookies, i + 1, mask | subMask)));\\n            subMask = (subMask - 1) & tobeTaken;\\n        }\\n        return dp[i][mask] = ret;\\n    }\\npublic:\\n    int distributeCookies(vector<int>& cookies, int K) {\\n        // using bitmask dp\\n        n = cookies.size();\\n        k = K;\\n        finalMask = (1 << n) - 1;\\n        memset(dp, -1, sizeof(dp));\\n        return solve(cookies, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Backtracking",
                    "Bit Manipulation",
                    "Recursion",
                    "Memoization",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution{\\nprivate:\\n    int ans;\\n    void dfs(vector<int> &cookies, vector<int> &bag, int i, int k){\\n        // base case\\n        if(i==cookies.size()){\\n            ans=min(ans,*max_element(bag.begin(),bag.end()));\\n            return;\\n        }\\n        if(i>cookies.size())    return;\\n        // calling recursion\\n        for(int j=0;j<k;j++){\\n            bag[j]+=cookies[i];\\n            if(*max_element(bag.begin(),bag.end())<ans)\\n                dfs(cookies,bag,i+1,k);\\n            bag[j]-=cookies[i];\\n        }\\n    }\\npublic:\\n    int distributeCookies(vector<int> &cookies, int k){\\n        // using backtracking or dfs\\n        vector<int> bag(k,0);\\n        ans=INT_MAX;\\n        dfs(cookies,bag,0,k);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    int n, k;\\n    int finalMask;\\n    int dp[8][1 << 8];\\n    int solve(vector<int>& cookies, int i, int mask) {\\n        // base case\\n        if(i == k) {\\n            if(mask == finalMask)   return 0;\\n            return 1e6;\\n        }\\n        // memoization case\\n        if(dp[i][mask] != -1)   return dp[i][mask];\\n        // calling recursion\\n        int tobeTaken = 0;\\n        for(int b = 0; b < n; b++) {\\n            if(!(mask & (1 << b)))\\n                tobeTaken |= (1 << b);\\n        }\\n        int subMask = tobeTaken;\\n        int ret = INT_MAX;\\n        while(subMask) {\\n            int curr = 0;\\n            for(int b = 0; b < n; b++) {\\n                if(subMask & (1 << b))\\n                    curr += cookies[b];\\n            }\\n            ret = min(ret, max(curr, solve(cookies, i + 1, mask | subMask)));\\n            subMask = (subMask - 1) & tobeTaken;\\n        }\\n        return dp[i][mask] = ret;\\n    }\\npublic:\\n    int distributeCookies(vector<int>& cookies, int K) {\\n        // using bitmask dp\\n        n = cookies.size();\\n        k = K;\\n        finalMask = (1 << n) - 1;\\n        memset(dp, -1, sizeof(dp));\\n        return solve(cookies, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3970183,
                "title": "neat-clean-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long ans = INT_MAX ;\\n    void solve(vector<int>&cookies , vector<long long>&child , int k, int i, long long maxCurr){\\n        if(i==cookies.size()){\\n            ans = min(ans , maxCurr) ;\\n            return ;\\n        }\\n        long long curr = maxCurr ;\\n        for(int j = 0 ; j< k ; j++){\\n            child[j] += (long long)cookies[i] ;\\n            solve(cookies , child , k , i+1 , max(curr , child[j]));\\n            child[j] -= (long long)cookies[i] ;\\n        }\\n        return ;\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        vector<long long> child(k,0) ;\\n        solve(cookies , child , k , 0 , 0);\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Backtracking",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long ans = INT_MAX ;\\n    void solve(vector<int>&cookies , vector<long long>&child , int k, int i, long long maxCurr){\\n        if(i==cookies.size()){\\n            ans = min(ans , maxCurr) ;\\n            return ;\\n        }\\n        long long curr = maxCurr ;\\n        for(int j = 0 ; j< k ; j++){\\n            child[j] += (long long)cookies[i] ;\\n            solve(cookies , child , k , i+1 , max(curr , child[j]));\\n            child[j] -= (long long)cookies[i] ;\\n        }\\n        return ;\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        vector<long long> child(k,0) ;\\n        solve(cookies , child , k , 0 , 0);\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946998,
                "title": "best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n*2^k)$$\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def solve(self,index,bucket,cookies):\\n        if index==len(cookies):\\n            if bucket:\\n                return max(bucket)\\n        mini=inf\\n        for choice in range(len(bucket)):\\n            bucket[choice]+=cookies[index]\\n            mini=min(mini,self.solve(index+1,bucket,cookies))\\n            bucket[choice]-=cookies[index]\\n            \"\"\"\\n                since the position of the maximum element doesn\\'t matter \\n                to avoid the repetitions of the permutations we stop them by bucket[choice]==0 which states the call has returned to the initial position \\n\\n            if bucket[choice]==0:\\n                return mini\\n\\n\\n\\n        return mini\\n        \\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n        bucket=[0 for i in range(k)]\\n        return self.solve(0,bucket,cookies)\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def solve(self,index,bucket,cookies):\\n        if index==len(cookies):\\n            if bucket:\\n                return max(bucket)\\n        mini=inf\\n        for choice in range(len(bucket)):\\n            bucket[choice]+=cookies[index]\\n            mini=min(mini,self.solve(index+1,bucket,cookies))\\n            bucket[choice]-=cookies[index]\\n            \"\"\"\\n                since the position of the maximum element doesn\\'t matter \\n                to avoid the repetitions of the permutations we stop them by bucket[choice]==0 which states the call has returned to the initial position \\n\\n            if bucket[choice]==0:\\n                return mini\\n\\n\\n\\n        return mini\\n        \\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n        bucket=[0 for i in range(k)]\\n        return self.solve(0,bucket,cookies)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716127,
                "title": "backtracking-easy-soution-every-step-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- SINCE WE HAVE TO CHECK FOR EVERY POSITION BY FIRST ADDING A COOKIE AND THE SUBSTRACTING , A TYPICAL BACKTRAKING QUESTION\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- THIS QUESTION IS SOLVED USING BACKTRACKING\\n- AT FIRST WE WILL GLOBALLY INITIALISE RESULT VARIABLE\\n- CREATE A CHILDREN VECTOR AND STORE ALL THE SUMS\\n- AND MAKE A FUNCTION, WHEN THE IDX REACHES THE END WE FIND THE MAXIMUM ELEMENT IN THE CHILDREN VECTOR AND CHECK IF ITS THE MINIMUM UNFAIRNESS\\n- THEN RETURN \\n- ELSE WE ITERATE OVER EVERY EVERY COOKIE AND CHECK AND IF NOT MEETING THE ABOVE CONDITON WE JUST SUBSTRACT\\n- TRADITIONAL BACKTRACKING\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(K^N)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int result= INT_MAX;\\n   \\n    void solve(int idx, vector<int> & cookies, vector<int>&children, int k ,int n)\\n    {\\n        if(idx>=n)\\n        {\\n            int unfair=*max_element(begin(children),end(children));\\n            result= min(result, unfair);\\n            return;\\n        }\\n\\n       int cookie= cookies[idx];\\n        for(int i =0;i<k;i++)\\n        {\\n            children[i]+=cookie;\\n            solve(idx+1,cookies, children, k,n);\\n            children[i]-=cookie;\\n        }\\n    }\\n\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int n= cookies.size();\\n        vector<int>children(k,0);\\n        // int idx=0;\\n        solve(0, cookies, children,k,n);\\n        return result;\\n    }\\n};\\n```\\n# PLEASE UPVOTE IF YOU FIND THIS SOLUTION HELPFUL! ![desktop-wallpaper-1080x1920-anime-girl-loli-cute-brown-hair-twintails-for-iphone-8-iphone-7-plus-iphone-6-sony-xperia-z-htc-one (1).jpg](https://assets.leetcode.com/users/images/aba885df-c7ae-4ebd-a0cf-8ce653e52621_1688455866.395906.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int result= INT_MAX;\\n   \\n    void solve(int idx, vector<int> & cookies, vector<int>&children, int k ,int n)\\n    {\\n        if(idx>=n)\\n        {\\n            int unfair=*max_element(begin(children),end(children));\\n            result= min(result, unfair);\\n            return;\\n        }\\n\\n       int cookie= cookies[idx];\\n        for(int i =0;i<k;i++)\\n        {\\n            children[i]+=cookie;\\n            solve(idx+1,cookies, children, k,n);\\n            children[i]-=cookie;\\n        }\\n    }\\n\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int n= cookies.size();\\n        vector<int>children(k,0);\\n        // int idx=0;\\n        solve(0, cookies, children,k,n);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712747,
                "title": "c-beats-100-backtracking",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int result = INT_MAX; \\n        int* children = new int[k]();\\n        solve(cookies, result, 0, children, k);\\n        delete[] children;\\n        return result;\\n    }\\n\\nprivate:\\n    void solve(vector<int>& cookies, int& result, int idx, int children[], int& k) {\\n        if (idx == cookies.size()) {\\n            int unfairness = *max_element(children, children + k);\\n            result = min(result, unfairness);\\n            return;\\n        }\\n\\n        for (int i = 0; i < k; i++) {\\n            children[i] += cookies[idx];\\n            solve(cookies, result, idx + 1, children, k);\\n            children[i] -= cookies[idx];\\n            if (children[i] == 0) break;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int result = INT_MAX; \\n        int* children = new int[k]();\\n        solve(cookies, result, 0, children, k);\\n        delete[] children;\\n        return result;\\n    }\\n\\nprivate:\\n    void solve(vector<int>& cookies, int& result, int idx, int children[], int& k) {\\n        if (idx == cookies.size()) {\\n            int unfairness = *max_element(children, children + k);\\n            result = min(result, unfairness);\\n            return;\\n        }\\n\\n        for (int i = 0; i < k; i++) {\\n            children[i] += cookies[idx];\\n            solve(cookies, result, idx + 1, children, k);\\n            children[i] -= cookies[idx];\\n            if (children[i] == 0) break;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709731,
                "title": "c-simple-solution-using-backtracking",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- distributeCookies() -> initializes the cookie distribution vector and calls the recursive function\\n- distributeCookiesRec() -> recursively calculate every permutation of possible distribution and store it in \"distribution\"(class member).\\n- calculate_unfairness() -> once a distribution is finalised this function calculates unfairness and if it is less than the previous unfairness it stores it in \"unfairness\"(class member). \\n- unfairness -> variable to store the min unfairness as each permutation of distribution is generated.\\n- dsitribution -> array/vector to store distribution (this variable changes during each recursive call except when base case is triggered)\\n\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    int unfairness = INT_MAX;\\n    vector<int> dsitribution;\\n\\n    int distributeCookies(vector<int> &cookies, int k)\\n    {\\n        dsitribution = vector<int>(k, 0);\\n        distributeCookiesRec(cookies, k);\\n        return unfairness;\\n    }\\n\\n    void distributeCookiesRec(vector<int> &cookies, int k, int counter = 0)\\n    {\\n        if (counter == cookies.size())\\n        {\\n            calculate_unfairness();\\n            return;\\n        }\\n\\n        for (int j = 0; j < k; j++)\\n            {\\n                dsitribution[j] += cookies[counter];\\n                distributeCookiesRec(cookies, k, counter + 1);\\n                dsitribution[j] -= cookies[counter];\\n            }\\n        return;\\n    }\\n\\n    void calculate_unfairness()\\n    {\\n        int max = INT_MIN;\\n        for (auto &i : dsitribution)\\n        {\\n            if (i > max)\\n            {\\n                max = i;\\n            }\\n        }\\n        if (max < unfairness)\\n        {\\n            unfairness = max;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int unfairness = INT_MAX;\\n    vector<int> dsitribution;\\n\\n    int distributeCookies(vector<int> &cookies, int k)\\n    {\\n        dsitribution = vector<int>(k, 0);\\n        distributeCookiesRec(cookies, k);\\n        return unfairness;\\n    }\\n\\n    void distributeCookiesRec(vector<int> &cookies, int k, int counter = 0)\\n    {\\n        if (counter == cookies.size())\\n        {\\n            calculate_unfairness();\\n            return;\\n        }\\n\\n        for (int j = 0; j < k; j++)\\n            {\\n                dsitribution[j] += cookies[counter];\\n                distributeCookiesRec(cookies, k, counter + 1);\\n                dsitribution[j] -= cookies[counter];\\n            }\\n        return;\\n    }\\n\\n    void calculate_unfairness()\\n    {\\n        int max = INT_MIN;\\n        for (auto &i : dsitribution)\\n        {\\n            if (i > max)\\n            {\\n                max = i;\\n            }\\n        }\\n        if (max < unfairness)\\n        {\\n            unfairness = max;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3705922,
                "title": "simple-solution-by-backtrack-suitable-for-beginners-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\n\\nint n, num_of_childs;\\nvector<int>v;\\nint mn;\\nint mx(vector<int>&total_cookies_for_one_child)\\n{\\n\\tint max_element = INT_MIN;\\n\\t//cout << \"ans\\\\n\";\\n\\tfor (auto& it : total_cookies_for_one_child)\\n\\t{\\n\\t\\t//cout << it << \" \";\\n\\t\\tmax_element = max(max_element, it);\\n\\t}\\n\\t//cout << endl;\\n\\treturn max_element;\\n}\\n\\nvoid bt(int idx, vector<int>&total_cookies_for_one_child)\\n{\\n\\n\\tif (idx == n)\\n\\t{\\n\\t\\tint ans = mx(total_cookies_for_one_child);\\n\\t\\tmn = min(mn, ans);\\n\\t\\treturn;\\n\\t\\t\\n\\t}\\n\\tfor (int i = 0; i < num_of_childs; i++)\\n\\t{\\n\\t\\ttotal_cookies_for_one_child[i] += v[idx];\\n\\t\\tbt(idx + 1, total_cookies_for_one_child);\\n\\t\\ttotal_cookies_for_one_child[i] -= v[idx];\\n\\t}\\n\\n}\\n\\npublic:\\n    int distributeCookies(vector<int>& cookies, int k) {\\n                \\n    mn = INT_MAX;\\n\\tnum_of_childs = k;\\n    n = cookies.size();\\n\\tv = cookies;\\n\\n\\tvector<int>total_cookies_for_one_child(k, 0);\\n\\t\\n    bt(0, total_cookies_for_one_child);\\n\\n\\treturn mn;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\nint n, num_of_childs;\\nvector<int>v;\\nint mn;\\nint mx(vector<int>&total_cookies_for_one_child)\\n{\\n\\tint max_element = INT_MIN;\\n\\t//cout << \"ans\\\\n\";\\n\\tfor (auto& it : total_cookies_for_one_child)\\n\\t{\\n\\t\\t//cout << it << \" \";\\n\\t\\tmax_element = max(max_element, it);\\n\\t}\\n\\t//cout << endl;\\n\\treturn max_element;\\n}\\n\\nvoid bt(int idx, vector<int>&total_cookies_for_one_child)\\n{\\n\\n\\tif (idx == n)\\n\\t{\\n\\t\\tint ans = mx(total_cookies_for_one_child);\\n\\t\\tmn = min(mn, ans);\\n\\t\\treturn;\\n\\t\\t\\n\\t}\\n\\tfor (int i = 0; i < num_of_childs; i++)\\n\\t{\\n\\t\\ttotal_cookies_for_one_child[i] += v[idx];\\n\\t\\tbt(idx + 1, total_cookies_for_one_child);\\n\\t\\ttotal_cookies_for_one_child[i] -= v[idx];\\n\\t}\\n\\n}\\n\\npublic:\\n    int distributeCookies(vector<int>& cookies, int k) {\\n                \\n    mn = INT_MAX;\\n\\tnum_of_childs = k;\\n    n = cookies.size();\\n\\tv = cookies;\\n\\n\\tvector<int>total_cookies_for_one_child(k, 0);\\n\\t\\n    bt(0, total_cookies_for_one_child);\\n\\n\\treturn mn;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3705764,
                "title": "c-backtracking-beginner-friendly-easy-to-understand-clean-code",
                "content": "##### Intuition\\n- Since we have to distribute the cookies and each cookie has multiple options - to go to 1st child, 2nd one and so on. I thought of recursion here.\\n- As many people suggested to not overthink this problem, I took the advice and did exactly what was asked, i.e, get the unfairness in each distribution and then return the minimum unfairness of all distributions\\n\\n\\n---\\n\\n\\n### What the recursive function does?\\nIt returns the minimum unfairness in distributing a given number of bags (from ith bag to the last one)\\n\\n##### Recursive Case\\nWe\\'ll try giving our current bag of cookies (`number of cookies in it = cookies[i]`) to each child one by one and get unfairness of each case. The minimum unfairness among all cases is our answer.\\n\\n##### Base Case \\nWhen we have no cookie bags left as we have distributed all we have our distribution array ready which contains the number of cookies each child got.\\nSince, `Unfairness = Maximum cookies given to a child in a distribution`\\nThus we check the max number of cookies in our distribution array and return it.\\n\\n---\\n\\n\\n### Code\\n```\\nclass Solution {\\npublic:\\n\\n    int optimalDistribution(vector<int>&cookies, int k, vector<int>& distribution, int currbag){\\n        if(currbag == cookies.size()) {\\n            int maxCookie = 0;\\n            for(int cookie : distribution) maxCookie = max(maxCookie, cookie);\\n            return maxCookie;\\n        }\\n\\n        int minUnfairness = INT_MAX;\\n        for(int i=0; i<k; i++){\\n            distribution[i] += cookies[currbag];\\n            minUnfairness = min(minUnfairness, optimalDistribution(cookies, k, distribution, currbag+1));\\n            distribution[i] -= cookies[currbag];\\n        }\\n\\n        return minUnfairness;\\n    }\\n\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        vector<int> distribution(k, 0);\\n        return optimalDistribution(cookies, k, distribution, 0);\\n    }\\n};\\n```\\n\\n``` \\nTime Complexity: O(k^n)\\nSpace Complexity: O(k)\\n\\n```\\n\\nDo upvote if you found this useful! \\u2B06\\uFE0F",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int optimalDistribution(vector<int>&cookies, int k, vector<int>& distribution, int currbag){\\n        if(currbag == cookies.size()) {\\n            int maxCookie = 0;\\n            for(int cookie : distribution) maxCookie = max(maxCookie, cookie);\\n            return maxCookie;\\n        }\\n\\n        int minUnfairness = INT_MAX;\\n        for(int i=0; i<k; i++){\\n            distribution[i] += cookies[currbag];\\n            minUnfairness = min(minUnfairness, optimalDistribution(cookies, k, distribution, currbag+1));\\n            distribution[i] -= cookies[currbag];\\n        }\\n\\n        return minUnfairness;\\n    }\\n\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        vector<int> distribution(k, 0);\\n        return optimalDistribution(cookies, k, distribution, 0);\\n    }\\n};\\n```\n``` \\nTime Complexity: O(k^n)\\nSpace Complexity: O(k)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3705686,
                "title": "easy-python-solution-using-backtracking-and-dp",
                "content": "# Code\\n```\\nclass Solution: \\n    def dp(self,i,dist,cookies,k,dct):\\n        if i<0:\\n            return max(dist)\\n        if (i,tuple(dist)) in dct:\\n            return dct[(i,tuple(dist))]\\n        ans=float(\"infinity\")\\n        for j in range(k):\\n            dist[j]+=cookies[i]\\n            if max(dist)<ans:\\n                x=self.dp(i-1,dist,cookies,k,dct)\\n                ans=min(ans,x)\\n            dist[j]-=cookies[i]\\n        dct[(i,tuple(dist))]=ans\\n        return ans\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n        dist=[0]*k\\n        n=len(cookies)\\n        return self.dp(n-1,dist,cookies,k,{})\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution: \\n    def dp(self,i,dist,cookies,k,dct):\\n        if i<0:\\n            return max(dist)\\n        if (i,tuple(dist)) in dct:\\n            return dct[(i,tuple(dist))]\\n        ans=float(\"infinity\")\\n        for j in range(k):\\n            dist[j]+=cookies[i]\\n            if max(dist)<ans:\\n                x=self.dp(i-1,dist,cookies,k,dct)\\n                ans=min(ans,x)\\n            dist[j]-=cookies[i]\\n        dct[(i,tuple(dist))]=ans\\n        return ans\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n        dist=[0]*k\\n        n=len(cookies)\\n        return self.dp(n-1,dist,cookies,k,{})\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3705634,
                "title": "backtracking-memo-recursion-tc-sc",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->traversing the each person with their possible cookies\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncheck each and retrive back\\n\\n# Complexity\\n- Time complexity:2^N\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distributeCookies(vector<int>& c, int k) {\\n   int mini=INT_MAX;\\n    vector<int>Chave(k,0);\\n      return solve(c,Chave,k,0,mini);\\n       \\n    }\\n     private:\\n      int solve(vector<int>& c,vector<int>& Chave,int k  , int s, int &mini)\\n      {\\n          if(s==c.size())\\n          {\\n              int maxi=INT_MIN;\\n            for(int  i=0;i<k;++i)\\n            {\\n                maxi=max(maxi,Chave[i]);\\n            }\\n             \\n            return maxi;\\n          }\\n          for(int i=0;i<k;++i)\\n          {\\n              Chave[i]+=c[s];\\n            mini=min(mini,solve(c,Chave,k,s+1,mini));\\n              Chave[i]-=c[s];\\n             \\n          }\\n          return mini;\\n          \\n      }\\n};\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distributeCookies(vector<int>& c, int k) {\\n   int mini=INT_MAX;\\n    vector<int>Chave(k,0);\\n      return solve(c,Chave,k,0,mini);\\n       \\n    }\\n     private:\\n      int solve(vector<int>& c,vector<int>& Chave,int k  , int s, int &mini)\\n      {\\n          if(s==c.size())\\n          {\\n              int maxi=INT_MIN;\\n            for(int  i=0;i<k;++i)\\n            {\\n                maxi=max(maxi,Chave[i]);\\n            }\\n             \\n            return maxi;\\n          }\\n          for(int i=0;i<k;++i)\\n          {\\n              Chave[i]+=c[s];\\n            mini=min(mini,solve(c,Chave,k,s+1,mini));\\n              Chave[i]-=c[s];\\n             \\n          }\\n          return mini;\\n          \\n      }\\n};\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3705469,
                "title": "beats-100-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    int ans = Integer.MAX_VALUE;\\n    public int distributeCookies(int[] cookies, int k) {\\n        helper(cookies,0,k,new int[k]);\\n        return ans;\\n    }\\n    public void helper(int[] cookies, int index,int k, int[] cookieDist){\\n        if(index==cookies.length){\\n            int max =0;\\n            for(int cookie:cookieDist) \\n                max=Math.max(max,cookie);\\n            ans = Math.min(ans, max);\\n            return;\\n        }\\n        for(int i=0;i<k;i++){\\n            cookieDist[i]+=cookies[index];\\n            helper(cookies,index+1,k,cookieDist);\\n            cookieDist[i]-=cookies[index];\\n            if(cookieDist[i]==0) break;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int ans = Integer.MAX_VALUE;\\n    public int distributeCookies(int[] cookies, int k) {\\n        helper(cookies,0,k,new int[k]);\\n        return ans;\\n    }\\n    public void helper(int[] cookies, int index,int k, int[] cookieDist){\\n        if(index==cookies.length){\\n            int max =0;\\n            for(int cookie:cookieDist) \\n                max=Math.max(max,cookie);\\n            ans = Math.min(ans, max);\\n            return;\\n        }\\n        for(int i=0;i<k;i++){\\n            cookieDist[i]+=cookies[index];\\n            helper(cookies,index+1,k,cookieDist);\\n            cookieDist[i]-=cookies[index];\\n            if(cookieDist[i]==0) break;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3705426,
                "title": "using-backtracking",
                "content": "```\\nclass Solution {\\n    int ans = Integer.MAX_VALUE;\\n    public int distributeCookies(int[] cookies, int k) {\\n        \\n        int arr[] = new int[k];\\n        Unfairness(cookies,arr,0,Integer.MIN_VALUE);\\n        \\n            return ans;\\n    }\\n    \\n    public void Unfairness(int[] cookies,int array[],int idx,int max){\\n        \\n        if(idx == cookies.length){\\n            \\n            ans = Math.min(ans,max);\\n            return;\\n        }\\n        \\n        \\n        for(int i=0;i<array.length;i++){\\n            array[i] += cookies[idx];\\n            Unfairness(cookies,array,idx+1,Math.max(max,array[i]));\\n            array[i] -= cookies[idx];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int ans = Integer.MAX_VALUE;\\n    public int distributeCookies(int[] cookies, int k) {\\n        \\n        int arr[] = new int[k];\\n        Unfairness(cookies,arr,0,Integer.MIN_VALUE);\\n        \\n            return ans;\\n    }\\n    \\n    public void Unfairness(int[] cookies,int array[],int idx,int max){\\n        \\n        if(idx == cookies.length){\\n            \\n            ans = Math.min(ans,max);\\n            return;\\n        }\\n        \\n        \\n        for(int i=0;i<array.length;i++){\\n            array[i] += cookies[idx];\\n            Unfairness(cookies,array,idx+1,Math.max(max,array[i]));\\n            array[i] -= cookies[idx];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3705394,
                "title": "backtrack-solution-to-cookies-problem",
                "content": "# Intuition\\nintuition was simple that we need to assume that for any particular index of cookies array we will be sending that much amount of cookies in any of particular bag(from k choices)and while doing so we need to minimize the maximum value from our resultant value.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans = INT_MAX;\\n    void helper(vector<int>&cookies,vector<int>&bag,int start){\\n        if(start==cookies.size()){\\n            int res = INT_MIN;\\n            for(int i = 0 ; i < bag.size();i++){\\n                res = max(res,bag[i]);\\n            }\\n            ans = min(ans,res);\\n            return;\\n        }\\n        for(int i = 0 ; i < bag.size(); i++){\\n            bag[i] += cookies[start];\\n            helper(cookies,bag,start+1);\\n            bag[i] -= cookies[start];\\n        }\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        vector<int>bag(k,0);\\n        helper(cookies,bag,0);\\n        return ans;\\n    }\\n};\\n```\\n\\nplease do upvote the solution if you found it helpful ^_^",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = INT_MAX;\\n    void helper(vector<int>&cookies,vector<int>&bag,int start){\\n        if(start==cookies.size()){\\n            int res = INT_MIN;\\n            for(int i = 0 ; i < bag.size();i++){\\n                res = max(res,bag[i]);\\n            }\\n            ans = min(ans,res);\\n            return;\\n        }\\n        for(int i = 0 ; i < bag.size(); i++){\\n            bag[i] += cookies[start];\\n            helper(cookies,bag,start+1);\\n            bag[i] -= cookies[start];\\n        }\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        vector<int>bag(k,0);\\n        helper(cookies,bag,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3705131,
                "title": "java-recursion-dp",
                "content": "```\\nclass Solution {\\n    public int solve(int ind, int[] cookies, int k, int zeros,int[] temp, int max){\\n        int n = cookies.length;\\n        if(n - ind < zeros)\\n            return Integer.MAX_VALUE;\\n        \\n        if(ind == n ){\\n            int ret = zeros == 0 ? max : Integer.MAX_VALUE;\\n            return ret;\\n        }\\n        \\n        int ret = Integer.MAX_VALUE;\\n        for( int i = 0; i < k ; i++ ){\\n            zeros-= temp[i] == 0 ? 1 : 0;\\n            temp[i]+=cookies[ind];\\n            ret = Math.min(solve(ind+1, cookies, k, zeros, temp, Math.max(max, temp[i]) != Integer.MAX_VALUE ? Math.max(max, temp[i])  : max ), ret);\\n            temp[i]-=cookies[ind];\\n            zeros+=temp[i] == 0 ? 1 : 0;\\n        }\\n        return ret;\\n    }\\n    \\n    public int distributeCookies(int[] cookies, int k) {\\n        int[] temp = new int[k];\\n        return solve(0, cookies, k, k , temp, 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int solve(int ind, int[] cookies, int k, int zeros,int[] temp, int max){\\n        int n = cookies.length;\\n        if(n - ind < zeros)\\n            return Integer.MAX_VALUE;\\n        \\n        if(ind == n ){\\n            int ret = zeros == 0 ? max : Integer.MAX_VALUE;\\n            return ret;\\n        }\\n        \\n        int ret = Integer.MAX_VALUE;\\n        for( int i = 0; i < k ; i++ ){\\n            zeros-= temp[i] == 0 ? 1 : 0;\\n            temp[i]+=cookies[ind];\\n            ret = Math.min(solve(ind+1, cookies, k, zeros, temp, Math.max(max, temp[i]) != Integer.MAX_VALUE ? Math.max(max, temp[i])  : max ), ret);\\n            temp[i]-=cookies[ind];\\n            zeros+=temp[i] == 0 ? 1 : 0;\\n        }\\n        return ret;\\n    }\\n    \\n    public int distributeCookies(int[] cookies, int k) {\\n        int[] temp = new int[k];\\n        return solve(0, cookies, k, k , temp, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3705091,
                "title": "easy-c-backtracking-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int i,int k,vector<int> &child,vector<int>& cookies)\\n    {\\n        if(i==cookies.size())\\n            return *max_element(child.begin(),child.end());\\n        int ans=1e9;\\n        for(int c=0;c<k;c++)\\n        {\\n            child[c]+=cookies[i];\\n            int val = solve(i+1,k,child,cookies);\\n            // cout<<\"index: \"<<i<<endl;\\n            // for(auto it: child)\\n            //     cout<<it<<\" \";\\n            // cout<<endl;\\n            ans=min(ans,val);\\n            child[c]-=cookies[i];\\n        }\\n        return ans;\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int n=cookies.size();\\n        vector<int> child(k,0);\\n        return solve(0,k,child,cookies);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,int k,vector<int> &child,vector<int>& cookies)\\n    {\\n        if(i==cookies.size())\\n            return *max_element(child.begin(),child.end());\\n        int ans=1e9;\\n        for(int c=0;c<k;c++)\\n        {\\n            child[c]+=cookies[i];\\n            int val = solve(i+1,k,child,cookies);\\n            // cout<<\"index: \"<<i<<endl;\\n            // for(auto it: child)\\n            //     cout<<it<<\" \";\\n            // cout<<endl;\\n            ans=min(ans,val);\\n            child[c]-=cookies[i];\\n        }\\n        return ans;\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int n=cookies.size();\\n        vector<int> child(k,0);\\n        return solve(0,k,child,cookies);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3705046,
                "title": "c-super-easy-clean-code-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int mini;\\n    void solver(int i, vector<int>& cookies, vector<int>& children, int k){\\n        if(i == cookies.size()){\\n            int maxi = 0;\\n            for(int j=0; j<k; j++){\\n                maxi = max(maxi,children[j]);\\n            }\\n            mini = min(mini,maxi);\\n            return;\\n        }\\n        for(int j=0; j<k; j++){\\n            children[j] += cookies[i];\\n            solver(i+1,cookies,children,k);\\n            children[j] -= cookies[i];\\n            if(!children[j]) break;\\n        }\\n        return;\\n    }\\npublic:\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        \\n        mini = 1e9;\\n        vector<int> children(k,0);\\n        solver(0,cookies,children,k);\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int mini;\\n    void solver(int i, vector<int>& cookies, vector<int>& children, int k){\\n        if(i == cookies.size()){\\n            int maxi = 0;\\n            for(int j=0; j<k; j++){\\n                maxi = max(maxi,children[j]);\\n            }\\n            mini = min(mini,maxi);\\n            return;\\n        }\\n        for(int j=0; j<k; j++){\\n            children[j] += cookies[i];\\n            solver(i+1,cookies,children,k);\\n            children[j] -= cookies[i];\\n            if(!children[j]) break;\\n        }\\n        return;\\n    }\\npublic:\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        \\n        mini = 1e9;\\n        vector<int> children(k,0);\\n        solver(0,cookies,children,k);\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704864,
                "title": "c-solution-backtracking-easy-explanation",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The function `backtrack` is a recursive helper function that explores different combinations of distributing cookies to bags.\\n\\n2. The \"backtrack\" function takes three parameters:\\nThe vector \"c\" represents the cookies to be distributed.\\nThe vector \"b\" represents the current distribution of cookies in bags.\\nThe \"index\" represents the current cookie being considered for distribution.\\n\\n3. The base case for the recursion is when the `index` equals the size of the `c` vector. This means all cookies have been distributed, and the function calculates the maximum number of cookies in any bag (`maxi`) and updates the `ans` variable if maxi is smaller than the current ans.\\n\\n4. In the recursive case, the function iterates through all bags (represented by i) and tries adding the current cookie to each bag.\\nAfter adding the cookie to a bag, the function makes a recursive call to \"backtrack\" with the next index.\\n\\n5. After the recursive call, the function backtracks by subtracting the cookie from the bag to explore other possibilities.\\n\\n6. The \"distributeCookies\" function initializes the \"ans\" variable to a large value (INT_MAX) and creates a vector \"bags\" of size \"k\" to represent the bags.\\n\\n7. It then calls the \"backtrack\" function with the given cookies, bags, and starting index of 0.\\n\\n8. Finally, the \"distributeCookies\" function returns the minimum maximum number of cookies in any bag after distribution, which is stored in the `ans` variable.\\n\\n# Complexity\\n- Time complexity:  $$O(k^n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$ O(n + k)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans;\\n    void backtrack(vector<int>& c,vector<int>& b,int index){\\n           int k=b.size();\\n        if(index==c.size()){\\n\\n            int maxi=INT_MIN;\\n            for(int i=0;i<k;i++){\\n                maxi=max(maxi,b[i]);\\n            }\\n\\n            ans=min(ans,maxi);\\n            return;\\n        }\\n\\n\\n        for(int i=0;i<k;i++){\\n            b[i]+=c[index];\\n            backtrack(c,b,index+1);\\n            //backtrack\\n            b[i]-=c[index];\\n        }\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n          \\n           ans=INT_MAX;\\n           vector<int>bags(k,0);\\n\\n           backtrack(cookies,bags,0);\\n\\n           return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans;\\n    void backtrack(vector<int>& c,vector<int>& b,int index){\\n           int k=b.size();\\n        if(index==c.size()){\\n\\n            int maxi=INT_MIN;\\n            for(int i=0;i<k;i++){\\n                maxi=max(maxi,b[i]);\\n            }\\n\\n            ans=min(ans,maxi);\\n            return;\\n        }\\n\\n\\n        for(int i=0;i<k;i++){\\n            b[i]+=c[index];\\n            backtrack(c,b,index+1);\\n            //backtrack\\n            b[i]-=c[index];\\n        }\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n          \\n           ans=INT_MAX;\\n           vector<int>bags(k,0);\\n\\n           backtrack(cookies,bags,0);\\n\\n           return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704405,
                "title": "simple-backtracking-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans = INT_MAX;\\n    void solve(vector<int>& cookies, int k,vector<int>& count, int i){\\n        if(i == cookies.size()){\\n           int x=*max_element(count.begin(),count.end());\\n           ans=min(ans,x);\\n            return;\\n        }\\n\\n        for(int j = 0;j<k;j++){\\n            count[j] += cookies[i];\\n            solve(cookies,k,count,i+1);\\n            count[j] -= cookies[i];\\n        }\\n    }\\n\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        vector<int>count(k,0);\\n        solve(cookies,k,count,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = INT_MAX;\\n    void solve(vector<int>& cookies, int k,vector<int>& count, int i){\\n        if(i == cookies.size()){\\n           int x=*max_element(count.begin(),count.end());\\n           ans=min(ans,x);\\n            return;\\n        }\\n\\n        for(int j = 0;j<k;j++){\\n            count[j] += cookies[i];\\n            solve(cookies,k,count,i+1);\\n            count[j] -= cookies[i];\\n        }\\n    }\\n\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        vector<int>count(k,0);\\n        solve(cookies,k,count,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704365,
                "title": "brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans = INT_MAX;\\n    \\n    void solve(vector<int>& c , int i, int k, vector<int> &v)\\n    {\\n        if(c.size() <= i)\\n        {\\n            int res = INT_MIN;\\n            for(auto j:v)\\n            {\\n                res = max(res,j);\\n            }\\n            \\n            ans = min(ans,res);\\n            return;\\n        }\\n        \\n        \\n        \\n        for(int l = 0;l<k;l++)\\n        {\\n            v[l]+=c[i];\\n            solve(c,i+1,k,v);\\n            v[l]-=c[i];\\n        }\\n    }\\n    int distributeCookies(vector<int>& c, int k) {\\n        vector<int> v(k,0);\\n        solve(c,0,k,v);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = INT_MAX;\\n    \\n    void solve(vector<int>& c , int i, int k, vector<int> &v)\\n    {\\n        if(c.size() <= i)\\n        {\\n            int res = INT_MIN;\\n            for(auto j:v)\\n            {\\n                res = max(res,j);\\n            }\\n            \\n            ans = min(ans,res);\\n            return;\\n        }\\n        \\n        \\n        \\n        for(int l = 0;l<k;l++)\\n        {\\n            v[l]+=c[i];\\n            solve(c,i+1,k,v);\\n            v[l]-=c[i];\\n        }\\n    }\\n    int distributeCookies(vector<int>& c, int k) {\\n        vector<int> v(k,0);\\n        solve(c,0,k,v);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704354,
                "title": "noob-guy-s-code-don-t-click",
                "content": "Hello there, Stranger \\uD83D\\uDE4B\\uD83C\\uDFFB\\u200D\\u2642\\uFE0F\\nThanks for stopping by \\uD83E\\uDEE1\\nHope you find what you\\'re looking for \\uD83D\\uDE0C\\nHave a great day \\uD83C\\uDF89\\uD83D\\uDE07\\nThank you \\uD83D\\uDC4D\\n\\n# Code\\n```\\n/**\\n * @param {number[]} cookies\\n * @param {number} k\\n * @return {number}\\n */\\nvar distributeCookies = function(cookies, k) {\\n    let n = cookies.length, arr = Array(k).fill(0), res = Infinity;\\n    function solve(arr, idx) {\\n        if (idx >= n) return res = Math.min(res, Math.max(...arr));\\n        let cookiesInBag = cookies[idx];\\n        for (let i = 0; i < k; i++) {\\n            arr[i] += cookiesInBag;\\n            solve(arr, idx + 1);\\n            arr[i] -= cookiesInBag;\\n        }\\n        return res;\\n    }\\n    return solve(arr, 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} cookies\\n * @param {number} k\\n * @return {number}\\n */\\nvar distributeCookies = function(cookies, k) {\\n    let n = cookies.length, arr = Array(k).fill(0), res = Infinity;\\n    function solve(arr, idx) {\\n        if (idx >= n) return res = Math.min(res, Math.max(...arr));\\n        let cookiesInBag = cookies[idx];\\n        for (let i = 0; i < k; i++) {\\n            arr[i] += cookiesInBag;\\n            solve(arr, idx + 1);\\n            arr[i] -= cookiesInBag;\\n        }\\n        return res;\\n    }\\n    return solve(arr, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3704341,
                "title": "python-3-better-complexity",
                "content": "# Intuition\\nLet\\'s perform binary search over the answer and for each answer candidate check whether this answer is possible.\\n* Answer lies in range [0, $\\\\sum cookies$] so binary search will take $O(\\\\log(\\\\sum cookies)) \\\\le O(\\\\log(n \\\\cdot 10^5))$)\\n* Checking answer candidate can be done through splitting permutation of cookie bags in greedy manner. So for each permutation ($O(n!)$) we greedily distribute cookie bags ($O(n)$).\\n\\n# Complexity\\n- Time complexity:\\n  $O(n! \\\\cdot n \\\\cdot \\\\log(\\\\sum cookies))$\\n\\n- Space complexity:\\n  $O(n)$ \\u2014 size of cookie bags permutation\\n\\n# Comparison with Editorial approach\\nTL;DR \\u2014 $n! \\\\cdot n \\\\cdot \\\\log(\\\\sum cookies) \\\\le k^n$ (keeping $cookies[i] \\\\le 10^5$ and assuming it to always be limited and so be constant).\\nVisualized: https://www.desmos.com/calculator/fzfnsdgwmi\\n\\nEditorial approach has time complexity $O(k^n)$, which in the worst case ($k=n$) will become $O(n^n)$.\\nIn fact it\\'s impossible to compare these approaches because editorial\\'s complexity doesn\\'t use limitation for $cookies[i]$, but we can assume it to be limited and focus on how algorithm works with different $n$.\\nNow I will show that editorial approach has worse complexity and so it will work way slower in certain cases. It\\'s enough to prove that $n! \\\\cdot n \\\\cdot \\\\log(\\\\sum cookies) = o(n^n)$, i.e. $\\\\lim_{n \\\\rightarrow \\\\infty} \\\\frac{n! \\\\cdot n \\\\cdot \\\\log(\\\\sum cookies)}{n^n} = 0$.\\nMoreover, even with $n = 8$, which is in current limitations, we have $8^8 \\\\ge 8! \\\\cdot 8 \\\\cdot \\\\log(\\\\sum cookies)$.\\n## Proof\\nUsing [Stirling\\'s approximation](https://en.wikipedia.org/wiki/Stirling%27s_approximation)\\n$$ \\\\lim_{n \\\\rightarrow \\\\infty} \\\\frac{n! \\\\cdot n \\\\cdot \\\\log(\\\\sum cookies)}{n^n}\\n= \\\\lim_{n \\\\rightarrow \\\\infty} \\\\frac{\\\\sqrt{2\\\\pi n}(\\\\frac{n}{e})^n \\\\cdot n \\\\cdot \\\\log\\\\big(n \\\\cdot \\\\max_{i}(cookies[i])\\\\big)}{n^n}\\n= \\\\lim_{n \\\\rightarrow \\\\infty} \\\\frac{\\\\sqrt{2\\\\pi} n^{3/2} \\\\log n}{e^n} = 0$$\\n\\n# Code\\n```\\nfrom itertools import permutations\\n\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n        l = -1\\n        r = sum(cookies)\\n        while r - l > 1:\\n            max_unfairness = l + (r - l) // 2\\n            if self.is_possible(cookies, k, max_unfairness):\\n                r = max_unfairness\\n            else:\\n                l = max_unfairness\\n        return r\\n\\n    def is_possible(self, cookies, k, max_unfairness):\\n        for pcookies in permutations(cookies):\\n            suitable_permutation = True\\n            cur = 0\\n            cur_child = 0\\n            for c in pcookies:\\n                while cur + c > max_unfairness:\\n                    cur_child += 1\\n                    cur = 0\\n                    if cur_child == k:\\n                        suitable_permutation = False\\n                        break\\n                if not suitable_permutation:\\n                    break\\n                cur += c\\n            if suitable_permutation:\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom itertools import permutations\\n\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n        l = -1\\n        r = sum(cookies)\\n        while r - l > 1:\\n            max_unfairness = l + (r - l) // 2\\n            if self.is_possible(cookies, k, max_unfairness):\\n                r = max_unfairness\\n            else:\\n                l = max_unfairness\\n        return r\\n\\n    def is_possible(self, cookies, k, max_unfairness):\\n        for pcookies in permutations(cookies):\\n            suitable_permutation = True\\n            cur = 0\\n            cur_child = 0\\n            for c in pcookies:\\n                while cur + c > max_unfairness:\\n                    cur_child += 1\\n                    cur = 0\\n                    if cur_child == k:\\n                        suitable_permutation = False\\n                        break\\n                if not suitable_permutation:\\n                    break\\n                cur += c\\n            if suitable_permutation:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704214,
                "title": "c-dp-backtracking",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    int a = INT_MAX;\\npublic:\\n    int helper(int index, vector<int>& cookies, int k, map<int,int>& m,int maxi){\\n        if(index==cookies.size())return maxi;\\n        int ans = INT_MAX;\\n        int temp = maxi;\\n        for(int i = 0; i<k; i++){\\n            if((m[i]+cookies[index])>a)continue;\\n            m[i]+=cookies[index];\\n            maxi=max(maxi,m[i]);\\n            ans=min(ans,helper(index+1,cookies,k,m,maxi));\\n            a=min(a,ans);\\n            maxi=temp;\\n            m[i]-=cookies[index];\\n        }\\n        return ans;\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        map<int,int> m;\\n        return helper(0,cookies,k,m,0);\\n    }\\n};\\n```\\nACCEPTED.\\n\\nI tried memoising this with DP, but got TLE. \\n\\n```\\nclass Solution {\\n    int a = INT_MAX;\\npublic:\\n    int helper(int index, vector<int>& cookies, int k, map<int,int>& m, vector<map<map<int,int>,int>>&dp, int maxi){\\n        if(index==cookies.size())return maxi;\\n        if(dp[index].count(m)!=0)return dp[index][m];\\n        int ans = INT_MAX;\\n        int temp = maxi;\\n        for(int i = 0; i<k; i++){\\n            if((m[i]+cookies[index])>a)continue;\\n            m[i]+=cookies[index];\\n            maxi=max(maxi,m[i]);\\n            ans=min(ans,helper(index+1,cookies,k,m,dp,maxi));\\n            a=min(a,ans);\\n            maxi=temp;\\n            m[i]-=cookies[index];\\n        }\\n        return dp[index][m]=ans;\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        map<int,int> m;\\n        vector<map<map<int,int>,int>>dp(cookies.size());\\n        sort(cookies.begin(),cookies.end());\\n        return helper(0,cookies,k,m,dp,0);\\n    }\\n};\\n```\\n\\nGot better DP approach?",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    int a = INT_MAX;\\npublic:\\n    int helper(int index, vector<int>& cookies, int k, map<int,int>& m,int maxi){\\n        if(index==cookies.size())return maxi;\\n        int ans = INT_MAX;\\n        int temp = maxi;\\n        for(int i = 0; i<k; i++){\\n            if((m[i]+cookies[index])>a)continue;\\n            m[i]+=cookies[index];\\n            maxi=max(maxi,m[i]);\\n            ans=min(ans,helper(index+1,cookies,k,m,maxi));\\n            a=min(a,ans);\\n            maxi=temp;\\n            m[i]-=cookies[index];\\n        }\\n        return ans;\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        map<int,int> m;\\n        return helper(0,cookies,k,m,0);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    int a = INT_MAX;\\npublic:\\n    int helper(int index, vector<int>& cookies, int k, map<int,int>& m, vector<map<map<int,int>,int>>&dp, int maxi){\\n        if(index==cookies.size())return maxi;\\n        if(dp[index].count(m)!=0)return dp[index][m];\\n        int ans = INT_MAX;\\n        int temp = maxi;\\n        for(int i = 0; i<k; i++){\\n            if((m[i]+cookies[index])>a)continue;\\n            m[i]+=cookies[index];\\n            maxi=max(maxi,m[i]);\\n            ans=min(ans,helper(index+1,cookies,k,m,dp,maxi));\\n            a=min(a,ans);\\n            maxi=temp;\\n            m[i]-=cookies[index];\\n        }\\n        return dp[index][m]=ans;\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        map<int,int> m;\\n        vector<map<map<int,int>,int>>dp(cookies.size());\\n        sort(cookies.begin(),cookies.end());\\n        return helper(0,cookies,k,m,dp,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704152,
                "title": "easy-to-understand-short-code-backtracking-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nif we look carefully each packet of cookie has k options, it can go to any child out of k children. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBased on intution we can make k recursive calls for every packet, to keep atrck of total cookies with a child we will make an array, and every step we will return the minimum number of unfairness.\\n\\n# Complexity\\n- Time complexity: O(k^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(n+k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int helper(int index, vector<int>&child, vector<int>cookies){\\n        if(index==cookies.size()){\\n            int ans=0;\\n            for(auto val:child){\\n                ans=max(ans,val);\\n            }\\n            return ans;\\n        }\\n\\n\\n        int ans=INT_MAX;\\n        for(int i=0;i<child.size();i++){\\n            child[i]+=cookies[index];\\n            int small=helper(index+1,child,cookies);\\n            child[i]-=cookies[index];\\n            ans=min(ans,small);\\n        }\\n\\n        return ans;\\n    }\\n\\n\\n    int distributeCookies(vector<int>& cookies, int k) {\\n       /* to reduce recursive calls, it is pretty obvious that if k==number\\n       of cookie packets than packet with highest number of cookies will\\n       be the ans.*/\\n         if(k==cookies.size()){ \\n            int ans=0;\\n            for(auto val:cookies){\\n                ans=max(ans,val);\\n            }\\n            return ans;\\n        }\\n        vector<int>child(k,0);\\n        return helper(0,child,cookies);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int helper(int index, vector<int>&child, vector<int>cookies){\\n        if(index==cookies.size()){\\n            int ans=0;\\n            for(auto val:child){\\n                ans=max(ans,val);\\n            }\\n            return ans;\\n        }\\n\\n\\n        int ans=INT_MAX;\\n        for(int i=0;i<child.size();i++){\\n            child[i]+=cookies[index];\\n            int small=helper(index+1,child,cookies);\\n            child[i]-=cookies[index];\\n            ans=min(ans,small);\\n        }\\n\\n        return ans;\\n    }\\n\\n\\n    int distributeCookies(vector<int>& cookies, int k) {\\n       /* to reduce recursive calls, it is pretty obvious that if k==number\\n       of cookie packets than packet with highest number of cookies will\\n       be the ans.*/\\n         if(k==cookies.size()){ \\n            int ans=0;\\n            for(auto val:cookies){\\n                ans=max(ans,val);\\n            }\\n            return ans;\\n        }\\n        vector<int>child(k,0);\\n        return helper(0,child,cookies);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704021,
                "title": "c-simple-dp-o-k-o-k-n",
                "content": "# Intuition\\nFirst of all, its not a binary search question because there is no cantinous distribution.\\nThe idea is pretty straigth that one has to try all the possible ways\\nANd at last return the minimum of all\\n \\n# Approach\\nWe can see this as two major things being done:\\n- Trying out all the possibilities: A loop for all the k children to recieve the current bag of cookie, and checking if this possibility can give us desired solution or not.\\n- Base Condition: Once we have distributed all the cookie bags, we shall treat the sum as expected answer to be compared with all the other possibilities.\\n\\n\\n# Complexity\\n- Time complexity:\\nWe have \"k\" choices for each cookie bag. SO, trying all of them will make it: \\nO(k^n)\\n\\n- Space complexity:\\nSince we are storing all the cookies given to k children in order to be able to calculate the minimized max so:\\nO(k)\\n# Suggestion\\nhttps://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/description/\\nExactly the same question if you have the eye!\\n\\'~\\'\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans = INT_MAX;\\\\\\n\\n    void cal ( int curr, vector<int> &cookies, vector<int> &given){\\n        if (curr==cookies.size()){\\n            int unfair = INT_MIN;\\n            for (auto it: given){\\n                unfair = max (unfair, it);  //calculating the max cookies\\n            }\\n            ans = min(ans, unfair);     //finding the possibility with min\\n            return;\\n        }\\n        for (int i=0; i<given.size(); i++){\\n            given[i]+= cookies[curr];        //giving current cookie to ith child\\n            cal( curr+1, cookies, given);   //checking if this distribution\\n                                            //can give us the answer\\n            given[i] -= cookies[curr];       //after the current possibility is calculated\\n                                            //other possibility should be tried\\n        }\\n    }\\n\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        vector<int> given (k, 0);\\n        cal(0, cookies, given);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = INT_MAX;\\\\\\n\\n    void cal ( int curr, vector<int> &cookies, vector<int> &given){\\n        if (curr==cookies.size()){\\n            int unfair = INT_MIN;\\n            for (auto it: given){\\n                unfair = max (unfair, it);  //calculating the max cookies\\n            }\\n            ans = min(ans, unfair);     //finding the possibility with min\\n            return;\\n        }\\n        for (int i=0; i<given.size(); i++){\\n            given[i]+= cookies[curr];        //giving current cookie to ith child\\n            cal( curr+1, cookies, given);   //checking if this distribution\\n                                            //can give us the answer\\n            given[i] -= cookies[curr];       //after the current possibility is calculated\\n                                            //other possibility should be tried\\n        }\\n    }\\n\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        vector<int> given (k, 0);\\n        cal(0, cookies, given);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703850,
                "title": "python-c-bitmask-dynamic-programming-solution-with-explanation",
                "content": "```dp[i][j]``` is min value of unfairness for ```0 ~ i``` childrens when bit mask of cookie bags is ```j```, \\nwhere a bit of ```1``` means that the bag is used, vice versa.\\nWe just return ```dp[k-1][1<<len(cookies)-1]```.\\n```sum[j]``` is sum of cookie when bit mask of cookie bags is ```j```.\\n\\nFor ```i-th``` child, bit mask is ```j```,\\nwe can enumerate all subset of ```j``` as bags of cookies for the ```i-th``` children,\\nunfairness value of a subset ```sub``` is ```sum[sub]```, and min unfairness value of ```0~i-1```childs is ```dp[i-1][j^sub]```,\\nwhere ```j^sub``` is to remove a subset ```sub``` from ```j```.\\n\\nSo, ```dp[i][j] = min(dp[i][j], max(dp[i-1][j^sub], sum[sub])) for all subset sub```.\\n\\nAnd, a problem is how to enumerate all subset ```s``` of bitmask ```j```, \\n```sub = j -> (sub - 1) & j is alway a subset of j for sub >= 0 ```\\n\\ntc is O(k * 2^len(cookies) * tc of enumerating all subset), sc is O(k * 2^len(cookies))\\n\\n\\n### python\\n```python\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n        size = len(cookies)\\n\\t\\t\\n        dp = [[0] * (1 << size) for _ in range(k)]\\n        sum_ = [0] * (1 << size)\\n        inf = int(1e9)\\n\\t\\t\\n\\t\\t# calcalate sum of cookie when bitmask is i\\n        for i in range(1, 1 << size):\\n            for j, c in enumerate(cookies):\\n                if i >> j & 1: sum_[i] += c\\n\\t\\t\\n\\t\\t# The bitmask j is the cookie bag for first children, so min unfairness value = sum_\\n        dp[0] = sum_\\n\\t\\t\\n\\t\\t# for each child\\n        for i in range(1, k):\\n\\t\\t\\n\\t\\t\\t# and enumerate all bitmask j\\n            for j in range(1 << size):\\n\\t\\t\\t\\n\\t\\t\\t\\t# set dp[i][j] to inf to find min unfairness value\\n                dp[i][j] = inf\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# enumerate all subset `sub` of bitmask j\\n\\t\\t\\t\\t# where sub is bags of cookies for the i-th child\\n                sub = j\\n                while sub:\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# unfairness value is max total cookies obtained by a single child\\n                    max_cost = max(dp[i-1][j^sub], sum_[sub])\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# check min unfairness value\\n                    dp[i][j] = min(dp[i][j], max_cost)\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# next subset\\n                    sub = (sub - 1) & j\\n        return dp[k-1][-1]\\n```\\n\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int size = cookies.size();\\n        vector<vector<int>> dp (k, vector<int>(1 << size));\\n        vector<int> sum (1 << size);\\n        for (int i = 0; i < 1 << size; i+=1) {\\n            for (int j = 0; j < size; j+=1) {\\n                if (i >> j & 1) sum[i] += cookies[j];\\n            }\\n        }\\n        dp[0] = sum;\\n        for (int i = 1; i < k; i+=1) {\\n            for (int j = 0; j < 1 << size; j+=1) {\\n                dp[i][j] = INT_MAX;\\n                for (int sub = j, max_cost; sub; sub = (sub - 1) & j) {\\n                    max_cost = max(dp[i-1][j^sub], sum[sub]);\\n                    dp[i][j] = min(dp[i][j], max_cost);\\n                }\\n            }\\n        }\\n        return dp[k-1].back();\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```dp[i][j]```\n```0 ~ i```\n```j```\n```1```\n```dp[k-1][1<<len(cookies)-1]```\n```sum[j]```\n```j```\n```i-th```\n```j```\n```j```\n```i-th```\n```sub```\n```sum[sub]```\n```0~i-1```\n```dp[i-1][j^sub]```\n```j^sub```\n```sub```\n```j```\n```dp[i][j] = min(dp[i][j], max(dp[i-1][j^sub], sum[sub])) for all subset sub```\n```s```\n```j```\n```sub = j -> (sub - 1) & j is alway a subset of j for sub >= 0 ```\n```python\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n        size = len(cookies)\\n\\t\\t\\n        dp = [[0] * (1 << size) for _ in range(k)]\\n        sum_ = [0] * (1 << size)\\n        inf = int(1e9)\\n\\t\\t\\n\\t\\t# calcalate sum of cookie when bitmask is i\\n        for i in range(1, 1 << size):\\n            for j, c in enumerate(cookies):\\n                if i >> j & 1: sum_[i] += c\\n\\t\\t\\n\\t\\t# The bitmask j is the cookie bag for first children, so min unfairness value = sum_\\n        dp[0] = sum_\\n\\t\\t\\n\\t\\t# for each child\\n        for i in range(1, k):\\n\\t\\t\\n\\t\\t\\t# and enumerate all bitmask j\\n            for j in range(1 << size):\\n\\t\\t\\t\\n\\t\\t\\t\\t# set dp[i][j] to inf to find min unfairness value\\n                dp[i][j] = inf\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# enumerate all subset `sub` of bitmask j\\n\\t\\t\\t\\t# where sub is bags of cookies for the i-th child\\n                sub = j\\n                while sub:\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# unfairness value is max total cookies obtained by a single child\\n                    max_cost = max(dp[i-1][j^sub], sum_[sub])\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# check min unfairness value\\n                    dp[i][j] = min(dp[i][j], max_cost)\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# next subset\\n                    sub = (sub - 1) & j\\n        return dp[k-1][-1]\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int size = cookies.size();\\n        vector<vector<int>> dp (k, vector<int>(1 << size));\\n        vector<int> sum (1 << size);\\n        for (int i = 0; i < 1 << size; i+=1) {\\n            for (int j = 0; j < size; j+=1) {\\n                if (i >> j & 1) sum[i] += cookies[j];\\n            }\\n        }\\n        dp[0] = sum;\\n        for (int i = 1; i < k; i+=1) {\\n            for (int j = 0; j < 1 << size; j+=1) {\\n                dp[i][j] = INT_MAX;\\n                for (int sub = j, max_cost; sub; sub = (sub - 1) & j) {\\n                    max_cost = max(dp[i-1][j^sub], sum[sub]);\\n                    dp[i][j] = min(dp[i][j], max_cost);\\n                }\\n            }\\n        }\\n        return dp[k-1].back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703846,
                "title": "backtracking-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn order to get all the possible distribution of cookies among children we will use backtracking \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe will store the distribution of all the possibilities in a vector ans. when we will arrive at the base case we firstly iterate over our ans vector and find out the maximum among these and then out of all the maximum of all the distribution we will find our minimum which is the result of the problem.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(k^n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(k+n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int i,vector<int>& cookies, vector<int>& ans,int& mini,int k){\\n        if(i==cookies.size()){\\n            int maxi = INT_MIN;\\n            for(int j=0; j<k; j++){\\n                maxi = max(maxi,ans[j]);\\n            }\\n            mini = min(mini,maxi); \\n            return;  \\n        }\\n        for(int j=0; j<k; j++){\\n            ans[j]+=cookies[i];\\n            solve(i+1,cookies,ans,mini,k);\\n            ans[j]-=cookies[i];\\n        }\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        vector<int> ans(k,0);\\n        int mini=INT_MAX;\\n        solve(0,cookies,ans,mini,k);\\n        return mini;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int i,vector<int>& cookies, vector<int>& ans,int& mini,int k){\\n        if(i==cookies.size()){\\n            int maxi = INT_MIN;\\n            for(int j=0; j<k; j++){\\n                maxi = max(maxi,ans[j]);\\n            }\\n            mini = min(mini,maxi); \\n            return;  \\n        }\\n        for(int j=0; j<k; j++){\\n            ans[j]+=cookies[i];\\n            solve(i+1,cookies,ans,mini,k);\\n            ans[j]-=cookies[i];\\n        }\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        vector<int> ans(k,0);\\n        int mini=INT_MAX;\\n        solve(0,cookies,ans,mini,k);\\n        return mini;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703830,
                "title": "dp-generating-approach-in-rust-c-python3",
                "content": "# Intuition\\n\\nThis solution is somewhat inspired by this question: [956. Tallest Billboard](https://leetcode.com/problems/tallest-billboard).\\n\\n## Brute Force\\n\\nThe most intuitive method is brute force enumerating:\\n\\n1. Start with the condition that all childrens have $0$ cookies\\n2. For each bag of cookies, \\n    1. For each condition\\n        1. For each child\\n            In the condition, give that bag of cookie to the child to generate a new condition;\\n3. Iterate though all final conditions and get the minimum unfairness.\\n\\nFor $n$ bags of cookies and $k$ childrens: we start with $1$ condition; in the $1$st iteration, we generate $k$ new conditions; in the $2$nd iteration, we generate $k^2$ new conditions; \\u2026 ; in the $n$th iteration, there will be $k^n$ new conditions. The complexity is $O(k^n)$.\\n\\nTo make it more efficient, we want to reduce the duplicated generation. \\n\\n## Defination of Duplicated Conditions\\n\\nSo what are duplicated conditions? The conditions with same number and the same order must be duplicated. For example, there are 3 children, and each of them holds $4$, $5$ and $6$ cookies. Then, $(4, 5, 6)$ must be duplicated with $(4, 5, 6)$. However, since the same numbers with permutated orders have the same unfairness, and will generate duplicated results, then they are also duplicated. For example, the $(4, 5, 6)$, $(4, 6, 5)$, $(5, 4, 6)$, \\u2026 , all have unfairness $6$.\\n\\n## Generation of Duplicated Conditions\\n\\nThen, how do duplicated conditions be generated?\\n\\nFirst, when there are duplicated conditions in the old conditions, there also will be duplicated conditions in the new generated ones. For example, there are conditions $(4, 5, 6)$, $(4, 6, 5)$, $(5, 4, 6)$, \\u2026 . After adding a new bag with $2$ cookies, the $(4, 7, 6)$, $(4, 6, 7)$, $(7, 4, 6)$, \\u2026 , all can be generated.\\n\\nAlso, giving the same bag to childrens with the samenumber of cookies will generate duplicated conditions. or example, add a bag of 3 cookies to $(1, 1, 2)$, then $(4, 1, 2)$ and $(1, 4, 2)$ are duplicated.\\n\\n## Avoid Generating Duplicated Conditions\\n\\nTo avoid generating duplicated condtions:\\n\\n1. We should start with no duplications in the initial conditions\\n2. We should not introduce duplications when generating.\\n\\nSo we can do this:\\n\\n1. Start with only one condtion: all $0$s\\n    e.g. $(0, 0, 0)$\\n2. If there are more than one children holding the same number of cookies, only give the new bag of cookies to one of them to create a new condition.\\n    e.g. add $3$ to $(1, 1, 2)$, only generate one $(4, 1, 2)$\\n3. After adding new cookies, re-sort. This helps us to find the same number of cookies.\\n    e.g. add $3$ to $(1, 1, 2)$ generates $(4, 1, 2)$, then sort to be $(1, 2, 4)$\\n\\nNote that we do not need to sort the whole array and cost $O(k \\\\cdot \\\\log k)$. Instead, after increasing the number, just find a new suitable place behind and shift other elements, which costs $O(k)$. For example, when $(1, 2, 3, 4, 7)$ become $(1, 5, 3, 4, 7)$, just find $5$ should go to index $3$ and shift $3, 4$ front one step to get $(1, 3, 4, 5, 7)$.\\n\\nAlso note that after sorted, the \\n\\n\\n# Complexity\\n\\nThere will be no duplicated conditions.\\n\\ncondributing $n$ bags to $k$ childrens, when the children are unordered, there will be around $\\\\dfrac{k^n}{n!}$ conditions.\\n\\nWe need to sort each new condtion, which is $O(k)$.\\n\\n- Time complexity: $O(k^n \\\\mathbin{/} n!)$\\n- Space complexity: $O(k^n \\\\mathbin{/} n!)$\\n\\n# Code\\n\\n```rust []\\nimpl Solution {\\n    fn resort(vect: &mut Vec<i32>, idx: usize) {\\n        let len = vect.len();\\n        let val = vect[idx];\\n        for i in idx + 1 .. len {\\n            if vect[i] >= val {\\n                vect[i - 1] = val;\\n                return;\\n            }\\n            vect[i - 1] = vect[i];\\n        }\\n        vect[len - 1] = val;\\n    }\\n    \\n    pub fn distribute_cookies(cookies: Vec<i32>, k: i32) -> i32 {\\n        let mut conds: Vec<Vec<i32>> = vec![vec![0 ; k as usize]];\\n        for co in cookies.iter() {\\n            let mut new_conds = Vec::<Vec<i32>>::with_capacity(3 * conds.len());\\n            for cond in conds.iter() {\\n                for i in 0 .. k as usize {\\n                    if i != 0 && cond[i] == cond[i - 1] {\\n                        continue;\\n                    }\\n                    let mut new_cond = cond.clone();\\n                    new_cond[i] += *co;\\n                    Self::resort(&mut new_cond, i);\\n                    new_conds.push(new_cond);\\n                }\\n            }\\n            conds = new_conds;\\n        }\\n\\n        let mut min_unfair = i32::MAX;\\n        for cond in conds.iter() {\\n            let unfair = cond[k as usize - 1];\\n            if unfair < min_unfair {\\n                min_unfair = unfair;\\n            }\\n        }\\n        return min_unfair;\\n    }\\n}\\n```\\n``` cpp []\\n#include <climits>\\n#include <utility>\\n\\nclass Solution {\\nprivate:\\n    static void resort(vector<int>& vec, size_t idx) {\\n        size_t len = vec.size();\\n        int val = vec[idx];\\n        for (size_t i = idx + 1; i < len; ++i) {\\n            if (vec[i] >= val) {\\n                vec[i - 1] = val;\\n                return;\\n            }\\n            vec[i - 1] = vec[i];\\n        }\\n        vec[len - 1] = val;\\n    }\\n\\npublic:\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        vector<vector<int>> conds = {vector<int>(k, 0)};\\n        for (int co : cookies) {\\n            vector<vector<int>> new_conds;\\n            new_conds.reserve(k * conds.size());\\n            for (const vector<int>& cond : conds) {\\n                for (size_t i = 0; i < k; ++i) {\\n                    if (i != 0 && cond[i] == cond[i - 1])\\n                        continue;\\n                    vector<int> new_cond = cond; // copy\\n                    new_cond[i] += co;\\n                    resort(new_cond, i);\\n                    new_conds.push_back(move(new_cond));\\n                }\\n            }\\n            conds = move(new_conds);\\n        }\\n\\n        int min_unfair = INT_MAX;\\n        for (const vector<int>& cond : conds) {\\n            int unfair = cond.back();\\n            if (unfair < min_unfair)\\n                min_unfair = unfair;\\n        }\\n        return min_unfair;\\n    }\\n};\\n```\\n``` python []\\nclass Solution:\\n\\n    def __resort(self, arr: List[int], idx: int):\\n        val = arr[idx]\\n        for i in range(idx + 1, len(arr)):\\n            if arr[i] >= val:\\n                arr[i - 1] = val \\n                return\\n            arr[i - 1] = arr[i]\\n        arr[-1] = val\\n\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n        conds = [[0] * k]\\n        for co in cookies:\\n            new_conds = []\\n            for cond in conds:\\n                for i in range(k):\\n                    if i != 0 and cond[i] == cond[i - 1]:\\n                        continue\\n                    new_cond = cond.copy()\\n                    new_cond[i] += co\\n                    self.__resort(new_cond, i)\\n                    new_conds.append(new_cond)\\n            conds = new_conds\\n        \\n        min_unfair = 800000  # 8 * 10**5\\n        for cond in conds:\\n            unfair = cond[-1]\\n            if unfair < min_unfair:\\n                min_unfair = unfair\\n        return min_unfair\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Rust",
                    "Dynamic Programming"
                ],
                "code": "```rust []\\nimpl Solution {\\n    fn resort(vect: &mut Vec<i32>, idx: usize) {\\n        let len = vect.len();\\n        let val = vect[idx];\\n        for i in idx + 1 .. len {\\n            if vect[i] >= val {\\n                vect[i - 1] = val;\\n                return;\\n            }\\n            vect[i - 1] = vect[i];\\n        }\\n        vect[len - 1] = val;\\n    }\\n    \\n    pub fn distribute_cookies(cookies: Vec<i32>, k: i32) -> i32 {\\n        let mut conds: Vec<Vec<i32>> = vec![vec![0 ; k as usize]];\\n        for co in cookies.iter() {\\n            let mut new_conds = Vec::<Vec<i32>>::with_capacity(3 * conds.len());\\n            for cond in conds.iter() {\\n                for i in 0 .. k as usize {\\n                    if i != 0 && cond[i] == cond[i - 1] {\\n                        continue;\\n                    }\\n                    let mut new_cond = cond.clone();\\n                    new_cond[i] += *co;\\n                    Self::resort(&mut new_cond, i);\\n                    new_conds.push(new_cond);\\n                }\\n            }\\n            conds = new_conds;\\n        }\\n\\n        let mut min_unfair = i32::MAX;\\n        for cond in conds.iter() {\\n            let unfair = cond[k as usize - 1];\\n            if unfair < min_unfair {\\n                min_unfair = unfair;\\n            }\\n        }\\n        return min_unfair;\\n    }\\n}\\n```\n``` cpp []\\n#include <climits>\\n#include <utility>\\n\\nclass Solution {\\nprivate:\\n    static void resort(vector<int>& vec, size_t idx) {\\n        size_t len = vec.size();\\n        int val = vec[idx];\\n        for (size_t i = idx + 1; i < len; ++i) {\\n            if (vec[i] >= val) {\\n                vec[i - 1] = val;\\n                return;\\n            }\\n            vec[i - 1] = vec[i];\\n        }\\n        vec[len - 1] = val;\\n    }\\n\\npublic:\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        vector<vector<int>> conds = {vector<int>(k, 0)};\\n        for (int co : cookies) {\\n            vector<vector<int>> new_conds;\\n            new_conds.reserve(k * conds.size());\\n            for (const vector<int>& cond : conds) {\\n                for (size_t i = 0; i < k; ++i) {\\n                    if (i != 0 && cond[i] == cond[i - 1])\\n                        continue;\\n                    vector<int> new_cond = cond; // copy\\n                    new_cond[i] += co;\\n                    resort(new_cond, i);\\n                    new_conds.push_back(move(new_cond));\\n                }\\n            }\\n            conds = move(new_conds);\\n        }\\n\\n        int min_unfair = INT_MAX;\\n        for (const vector<int>& cond : conds) {\\n            int unfair = cond.back();\\n            if (unfair < min_unfair)\\n                min_unfair = unfair;\\n        }\\n        return min_unfair;\\n    }\\n};\\n```\n``` python []\\nclass Solution:\\n\\n    def __resort(self, arr: List[int], idx: int):\\n        val = arr[idx]\\n        for i in range(idx + 1, len(arr)):\\n            if arr[i] >= val:\\n                arr[i - 1] = val \\n                return\\n            arr[i - 1] = arr[i]\\n        arr[-1] = val\\n\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n        conds = [[0] * k]\\n        for co in cookies:\\n            new_conds = []\\n            for cond in conds:\\n                for i in range(k):\\n                    if i != 0 and cond[i] == cond[i - 1]:\\n                        continue\\n                    new_cond = cond.copy()\\n                    new_cond[i] += co\\n                    self.__resort(new_cond, i)\\n                    new_conds.append(new_cond)\\n            conds = new_conds\\n        \\n        min_unfair = 800000  # 8 * 10**5\\n        for cond in conds:\\n            unfair = cond[-1]\\n            if unfair < min_unfair:\\n                min_unfair = unfair\\n        return min_unfair\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3703807,
                "title": "clean-concise-c-solution-backtrack-with-comments",
                "content": "\\n# Complexity\\n- Time complexity: O(k^n) as we attempt to distribute n cookies to each of k children.\\n\\n- Space complexity: O(n+k) considering the recursion stack space and a vectorof size(k).\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dfs(int i, int zerocnt, int n, vector<int>& cookies, vector<int>& distribute ){\\n\\n        if((n-i)<zerocnt) return 1e8;\\n\\n        if(i==n){\\n            int M=0;\\n            for(int i=0; i<distribute.size(); i++){\\n                M = max( M,distribute[i]);\\n            }\\n            return M;\\n        }\\n\\n        int ans=1e8;\\n        int val = cookies[i];\\n\\n        for(int j=0; j<distribute.size(); j++){\\n\\n            if(distribute[j]==0) zerocnt-=1;\\n            distribute[j]=distribute[j]+val;\\n\\n           ans = min( ans, dfs(i+1,zerocnt,n,cookies,distribute) );\\n           distribute[j]=distribute[j]-val;\\n           if(distribute[j]==0) zerocnt+=1;\\n        }\\n\\n        return ans;\\n    }\\n\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        \\n        int n = cookies.size();\\n        vector<int> distribute(k,0); // represents the unfairness of each child.\\n        int zerocnt=k; //zerocnt = no of children empty handed\\n\\n        return dfs(0,k,n,cookies,distribute);\\n        \\n\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dfs(int i, int zerocnt, int n, vector<int>& cookies, vector<int>& distribute ){\\n\\n        if((n-i)<zerocnt) return 1e8;\\n\\n        if(i==n){\\n            int M=0;\\n            for(int i=0; i<distribute.size(); i++){\\n                M = max( M,distribute[i]);\\n            }\\n            return M;\\n        }\\n\\n        int ans=1e8;\\n        int val = cookies[i];\\n\\n        for(int j=0; j<distribute.size(); j++){\\n\\n            if(distribute[j]==0) zerocnt-=1;\\n            distribute[j]=distribute[j]+val;\\n\\n           ans = min( ans, dfs(i+1,zerocnt,n,cookies,distribute) );\\n           distribute[j]=distribute[j]-val;\\n           if(distribute[j]==0) zerocnt+=1;\\n        }\\n\\n        return ans;\\n    }\\n\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        \\n        int n = cookies.size();\\n        vector<int> distribute(k,0); // represents the unfairness of each child.\\n        int zerocnt=k; //zerocnt = no of children empty handed\\n\\n        return dfs(0,k,n,cookies,distribute);\\n        \\n\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703637,
                "title": "go-dfs-backtracking",
                "content": "# Intuition\\nThis seems like a decision-based problem. We have multiple ways to distribute cookies (decisions) and we need to find the one with the least unfairness.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTo solve this, we will use a method known as Depth-First Search (DFS) with Backtracking. This means we will try out all possible ways to distribute the cookies amongst the children and keep track of the minimum unfairness we come across.\\n\\n\\n1. We sort the bags of cookies in descending order. This allows us to start with the bags having more cookies first.\\n2. Next, we distribute the bags of cookies one by one to each child. For each bag, we have k options (where k is the number of children).\\n3. If the unfairness after giving a bag to a child is less than the current minimum unfairness, we proceed with this option. If not, we skip it.\\n4. We keep repeating this process until we\\'ve tried all possible distributions and found the one with the least unfairness.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(nk))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc min(a, b int) int {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\nfunc dfs(cookies []int, k int, index int, children []int, unfairness int) int {\\n\\tif index < 0 {\\n\\t\\treturn unfairness\\n\\t}\\n\\tminUnfairness := 1<<31 - 1\\n\\tfor i := 0; i < k; i++ {\\n\\t\\tif max(children[i]+cookies[index], unfairness) >= minUnfairness {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tchildren[i] += cookies[index]\\n\\t\\tminUnfairness = min(minUnfairness, dfs(cookies, k, index-1, children, max(children[i], unfairness)))\\n\\t\\tchildren[i] -= cookies[index]\\n\\t}\\n\\treturn minUnfairness\\n}\\n\\nfunc distributeCookies(cookies []int, k int) int {\\n\\tsort.Slice(cookies, func(i, j int) bool {\\n\\t\\treturn cookies[i] > cookies[j]\\n\\t})\\n\\tchildren := make([]int, k)\\n\\treturn dfs(cookies, k, len(cookies)-1, children, 0)\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc min(a, b int) int {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\nfunc dfs(cookies []int, k int, index int, children []int, unfairness int) int {\\n\\tif index < 0 {\\n\\t\\treturn unfairness\\n\\t}\\n\\tminUnfairness := 1<<31 - 1\\n\\tfor i := 0; i < k; i++ {\\n\\t\\tif max(children[i]+cookies[index], unfairness) >= minUnfairness {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tchildren[i] += cookies[index]\\n\\t\\tminUnfairness = min(minUnfairness, dfs(cookies, k, index-1, children, max(children[i], unfairness)))\\n\\t\\tchildren[i] -= cookies[index]\\n\\t}\\n\\treturn minUnfairness\\n}\\n\\nfunc distributeCookies(cookies []int, k int) int {\\n\\tsort.Slice(cookies, func(i, j int) bool {\\n\\t\\treturn cookies[i] > cookies[j]\\n\\t})\\n\\tchildren := make([]int, k)\\n\\treturn dfs(cookies, k, len(cookies)-1, children, 0)\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3703496,
                "title": "java-binary-search-solution-with-all-possible-permutations",
                "content": "```\\nclass Solution {\\n    public int distributeCookies(int[] cookies, int k) {\\n        Arrays.sort(cookies);\\n        int ans = Integer.MAX_VALUE;\\n        do{\\n            ans = Math.min(ans, bs(cookies, k));\\n        }while(nextPermutation(cookies));\\n        return ans;\\n    }\\n\\n    private boolean isValid(int[] cookies, int k, int midValue){\\n        int kids = 1;\\n        int cookiesDistributed = 0;\\n\\n        for(int i=0; i<cookies.length; i++){\\n            if(cookiesDistributed + cookies[i] <= midValue) cookiesDistributed += cookies[i];\\n            else{\\n                kids++;\\n                if(kids > k || cookies[i] > midValue) return false;\\n                cookiesDistributed = cookies[i];\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private int bs(int[] cookies, int k){\\n        int l = Integer.MAX_VALUE;\\n        int r = 0;\\n        for(int i=0; i<cookies.length; i++){\\n            r += cookies[i];\\n            l = Math.min(l, cookies[i]);\\n        }\\n\\n        int ans = -1;\\n        while(l<=r){\\n            int mid = l+(r-l)/2;\\n            if(isValid(cookies, k, mid)){\\n                ans = mid;\\n                r = mid-1;\\n            }else{\\n                l = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n//find next permutation \\n\\n    // Function to find the next permutation\\n    // of the given integer array\\n    public static boolean nextPermutation(int data[])\\n    {\\n \\n        // If the given dataset is empty\\n        // or contains only one element\\n        // next_permutation is not possible\\n        if (data.length <= 1)\\n            return false;\\n \\n        int last = data.length - 2;\\n \\n        // find the longest non-increasing suffix\\n        // and find the pivot\\n        while (last >= 0) {\\n            if (data[last] < data[last + 1]) {\\n                break;\\n            }\\n            last--;\\n        }\\n \\n        // If there is no increasing pair\\n        // there is no higher order permutation\\n        if (last < 0)\\n            return false;\\n \\n        int nextGreater = data.length - 1;\\n \\n        // Find the rightmost successor to the pivot\\n        for (int i = data.length - 1; i > last; i--) {\\n            if (data[i] > data[last]) {\\n                nextGreater = i;\\n                break;\\n            }\\n        }\\n \\n        // Swap the successor and the pivot\\n        data = swap(data, nextGreater, last);\\n \\n        // Reverse the suffix\\n        data = reverse(data, last + 1, data.length - 1);\\n \\n        // Return true as the next_permutation is done\\n        return true;\\n    }\\n\\n\\n    // Function to reverse the sub-array\\n    // starting from left to the right\\n    // both inclusive\\n    public static int[] reverse(int data[], int left, int right)\\n    {\\n \\n        // Reverse the sub-array\\n        while (left < right) {\\n            int temp = data[left];\\n            data[left++] = data[right];\\n            data[right--] = temp;\\n        }\\n \\n        // Return the updated array\\n        return data;\\n    }\\n\\n    // Function to swap the data\\n    // present in the left and right indices\\n    public static int[] swap(int data[], int left, int right)\\n    {\\n \\n        // Swap the data\\n        int temp = data[left];\\n        data[left] = data[right];\\n        data[right] = temp;\\n \\n        // Return the updated array\\n        return data;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int distributeCookies(int[] cookies, int k) {\\n        Arrays.sort(cookies);\\n        int ans = Integer.MAX_VALUE;\\n        do{\\n            ans = Math.min(ans, bs(cookies, k));\\n        }while(nextPermutation(cookies));\\n        return ans;\\n    }\\n\\n    private boolean isValid(int[] cookies, int k, int midValue){\\n        int kids = 1;\\n        int cookiesDistributed = 0;\\n\\n        for(int i=0; i<cookies.length; i++){\\n            if(cookiesDistributed + cookies[i] <= midValue) cookiesDistributed += cookies[i];\\n            else{\\n                kids++;\\n                if(kids > k || cookies[i] > midValue) return false;\\n                cookiesDistributed = cookies[i];\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private int bs(int[] cookies, int k){\\n        int l = Integer.MAX_VALUE;\\n        int r = 0;\\n        for(int i=0; i<cookies.length; i++){\\n            r += cookies[i];\\n            l = Math.min(l, cookies[i]);\\n        }\\n\\n        int ans = -1;\\n        while(l<=r){\\n            int mid = l+(r-l)/2;\\n            if(isValid(cookies, k, mid)){\\n                ans = mid;\\n                r = mid-1;\\n            }else{\\n                l = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n//find next permutation \\n\\n    // Function to find the next permutation\\n    // of the given integer array\\n    public static boolean nextPermutation(int data[])\\n    {\\n \\n        // If the given dataset is empty\\n        // or contains only one element\\n        // next_permutation is not possible\\n        if (data.length <= 1)\\n            return false;\\n \\n        int last = data.length - 2;\\n \\n        // find the longest non-increasing suffix\\n        // and find the pivot\\n        while (last >= 0) {\\n            if (data[last] < data[last + 1]) {\\n                break;\\n            }\\n            last--;\\n        }\\n \\n        // If there is no increasing pair\\n        // there is no higher order permutation\\n        if (last < 0)\\n            return false;\\n \\n        int nextGreater = data.length - 1;\\n \\n        // Find the rightmost successor to the pivot\\n        for (int i = data.length - 1; i > last; i--) {\\n            if (data[i] > data[last]) {\\n                nextGreater = i;\\n                break;\\n            }\\n        }\\n \\n        // Swap the successor and the pivot\\n        data = swap(data, nextGreater, last);\\n \\n        // Reverse the suffix\\n        data = reverse(data, last + 1, data.length - 1);\\n \\n        // Return true as the next_permutation is done\\n        return true;\\n    }\\n\\n\\n    // Function to reverse the sub-array\\n    // starting from left to the right\\n    // both inclusive\\n    public static int[] reverse(int data[], int left, int right)\\n    {\\n \\n        // Reverse the sub-array\\n        while (left < right) {\\n            int temp = data[left];\\n            data[left++] = data[right];\\n            data[right--] = temp;\\n        }\\n \\n        // Return the updated array\\n        return data;\\n    }\\n\\n    // Function to swap the data\\n    // present in the left and right indices\\n    public static int[] swap(int data[], int left, int right)\\n    {\\n \\n        // Swap the data\\n        int temp = data[left];\\n        data[left] = data[right];\\n        data[right] = temp;\\n \\n        // Return the updated array\\n        return data;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703458,
                "title": "my-java-short-and-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int res = Integer.MAX_VALUE;\\n    public int distributeCookies(int[] cookies, int k) {\\n        dist(0, cookies, new int[k], 0);\\n        return res;\\n    }\\n\\n    public void dist(int idx, int[] cookies, int[] arr, int max){\\n        if(idx == cookies.length){\\n            res = Math.min(res, max);\\n            return;\\n        }\\n        for(int i = 0; i < arr.length; i++){\\n            arr[i] += cookies[idx];\\n            int nm = Math.max(max, arr[i]);\\n            dist(idx + 1, cookies, arr, nm);\\n            arr[i] -= cookies[idx];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int res = Integer.MAX_VALUE;\\n    public int distributeCookies(int[] cookies, int k) {\\n        dist(0, cookies, new int[k], 0);\\n        return res;\\n    }\\n\\n    public void dist(int idx, int[] cookies, int[] arr, int max){\\n        if(idx == cookies.length){\\n            res = Math.min(res, max);\\n            return;\\n        }\\n        for(int i = 0; i < arr.length; i++){\\n            arr[i] += cookies[idx];\\n            int nm = Math.max(max, arr[i]);\\n            dist(idx + 1, cookies, arr, nm);\\n            arr[i] -= cookies[idx];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703299,
                "title": "just-use-backtracking-optimized-easy-c-easy-to-read",
                "content": "# Complexity\\n- Time complexity: O(k^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n    int solve(vector<int>&cookies,int &k,vector<int> &childrens,int &m,int i){\\n        // If all cookies are used return the maximum cookies which is m.\\n        if(i == cookies.size()) return m;\\n        int minAns = INT_MAX;\\n\\n        // one by one calculate ans for every children.\\n        // by thinking if we give the current bag to  xth children.\\n        for(int x=0;x<k;x++){\\n            childrens[x]+=cookies[i];\\n            int temp = m;\\n            if(childrens[x]>m) m = childrens[x];\\n            int ans = solve(cookies,k,childrens,m,i+1);\\n            m = temp;\\n            childrens[x]-=cookies[i];\\n            minAns = min(ans,minAns);\\n        }\\n        return minAns;\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        // To store all ans for all childrens.\\n        vector<int> childrens(k,0);\\n        // This will help to save some time.\\n        sort(cookies.begin(),cookies.end());\\n        // Remember m is used to store maximum of cookies a children have from childrens.\\n        int m = -1;\\n        return solve(cookies,k,childrens,m,0);\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    int solve(vector<int>&cookies,int &k,vector<int> &childrens,int &m,int i){\\n        // If all cookies are used return the maximum cookies which is m.\\n        if(i == cookies.size()) return m;\\n        int minAns = INT_MAX;\\n\\n        // one by one calculate ans for every children.\\n        // by thinking if we give the current bag to  xth children.\\n        for(int x=0;x<k;x++){\\n            childrens[x]+=cookies[i];\\n            int temp = m;\\n            if(childrens[x]>m) m = childrens[x];\\n            int ans = solve(cookies,k,childrens,m,i+1);\\n            m = temp;\\n            childrens[x]-=cookies[i];\\n            minAns = min(ans,minAns);\\n        }\\n        return minAns;\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        // To store all ans for all childrens.\\n        vector<int> childrens(k,0);\\n        // This will help to save some time.\\n        sort(cookies.begin(),cookies.end());\\n        // Remember m is used to store maximum of cookies a children have from childrens.\\n        int m = -1;\\n        return solve(cookies,k,childrens,m,0);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3703131,
                "title": "easy-c-backtracking-beats-100-same-code-solves-another-hardproblem",
                "content": "Same code works in hard problem [https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/discuss/3703126/Same-code-as-2305.-Fair-Distribution-of-Cookies](1723. Find Minimum Time to Finish All Jobs)\\nimprovement:\\n```\\nclass Solution {\\npublic:\\n    int unfairness=INT_MAX;\\n    \\n    void sol(int i, vector<int>& nums, vector<int>& ans, int k){\\n        int n=nums.size();\\n        if(i==n){\\n            int max_cookie = *max_element(ans.begin(),ans.end());\\n            unfairness=min(unfairness,max_cookie);\\n            return ;\\n        }\\n        unordered_set<int> vis;\\n        for(int j=0;j<k;j++){\\n\\t\\t\\tif(vis.count( ans[j] )) continue;\\n\\t\\t\\tvis.insert( ans[j] );\\n            ans[j]+=nums[i];\\n            if(*max_element(ans.begin(),ans.end())<unfairness){\\n            sol(i+1,nums,ans,k);}\\n            ans[j]-=nums[i];\\n        }\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        sort(cookies.begin(), cookies.end() , greater<int>());\\n\\n        int n=cookies.size();\\n        vector<int>ans(n,0);\\n        sol(0,cookies,ans,k);\\n        return unfairness;\\n    }\\n};\\n```\\n```\\nclass Solution {\\npublic:\\n    int unfairness=INT_MAX;\\n    void sol(int i, vector<int>& nums, vector<int>& ans, int k){\\n        int n=nums.size();\\n        if(i==n){\\n            int max_cookie = *max_element(ans.begin(),ans.end());\\n            unfairness=min(unfairness,max_cookie);\\n            return ;\\n        }\\n        \\n        for(int j=0;j<k;j++){\\n            ans[j]+=nums[i];\\n            sol(i+1,nums,ans,k);\\n            ans[j]-=nums[i];\\n        }\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int n=cookies.size();\\n        vector<int>ans(n,0);\\n        sol(0,cookies,ans,k);\\n        return unfairness;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/39852147-6e9c-4e8e-8a6f-fdd4449114ba_1688195314.5089116.gif)\\n",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int unfairness=INT_MAX;\\n    \\n    void sol(int i, vector<int>& nums, vector<int>& ans, int k){\\n        int n=nums.size();\\n        if(i==n){\\n            int max_cookie = *max_element(ans.begin(),ans.end());\\n            unfairness=min(unfairness,max_cookie);\\n            return ;\\n        }\\n        unordered_set<int> vis;\\n        for(int j=0;j<k;j++){\\n\\t\\t\\tif(vis.count( ans[j] )) continue;\\n\\t\\t\\tvis.insert( ans[j] );\\n            ans[j]+=nums[i];\\n            if(*max_element(ans.begin(),ans.end())<unfairness){\\n            sol(i+1,nums,ans,k);}\\n            ans[j]-=nums[i];\\n        }\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        sort(cookies.begin(), cookies.end() , greater<int>());\\n\\n        int n=cookies.size();\\n        vector<int>ans(n,0);\\n        sol(0,cookies,ans,k);\\n        return unfairness;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int unfairness=INT_MAX;\\n    void sol(int i, vector<int>& nums, vector<int>& ans, int k){\\n        int n=nums.size();\\n        if(i==n){\\n            int max_cookie = *max_element(ans.begin(),ans.end());\\n            unfairness=min(unfairness,max_cookie);\\n            return ;\\n        }\\n        \\n        for(int j=0;j<k;j++){\\n            ans[j]+=nums[i];\\n            sol(i+1,nums,ans,k);\\n            ans[j]-=nums[i];\\n        }\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int n=cookies.size();\\n        vector<int>ans(n,0);\\n        sol(0,cookies,ans,k);\\n        return unfairness;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703122,
                "title": "explained-c-base-and-optimized",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGiven that `2 <= cookies.length <= 8`, it is feasible to obtain all possible permutations for the distribution.\\n\\nIn other words, the worst-case for this problem involves distributing 8 bags of cookies among 8 children. In this particular case, each bag of cookies can be assigned to any child, resulting in a total of $8^8 = 2^{24}\\\\approx 1.6 \\\\times 10^7$ permutations.\\n\\nHence, the remaining objective of the problem is to identify the minimum value among the maximum values within each permutation.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStep 1: Define a `helper` function responsible for distributing each bag of cookies to each child.\\nStep 2: The `helper` function terminates when there are no more cookies to be distributed (i.e., the base case of recursion is `index >= n`) and determines the maximum number of cookies among the children.\\nStep 3: Pass the resulting maximum value back to the caller.\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int helper(const vector<int>& nums, int index, int k, vector<int> &acc){\\n        int n = nums.size();\\n        if(index >= n){ \\n            int result = 0;\\n            for(int i=0; i<k; ++i){ result = max(result, acc[i]); }\\n            return result;\\n        }\\n\\n        int result = INT_MAX;\\n        for(int i=0; i<k; ++i){\\n            acc[i] += nums[index];\\n            result = min(result, helper(nums, index+1, k, acc));\\n            acc[i] -= nums[index];\\n        }\\n        return result;\\n    }\\npublic:\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        vector<int> acc(k, 0);\\n        return helper(cookies, 0, k, acc);\\n    }\\n};\\n```\\n\\n# Optimized\\nThere are two ways to speed up the above solution\\n1. Avoid finding the maximum value in the base case (i.e., `index >= n`), but instead update it whenever a child receives cookies. As a result, the time complexity can be reduced to $O(n^k)$.\\n\\n2. If the correctness of a certain scenario is evidently incorrect, there is no need to proceed with the recursion for that particular case.\\n\\n# Code\\n\\n```\\nclass Solution {\\nprivate:\\n    int global_min_ = INT_MAX;\\n    int n_; \\n    int k_;\\n    void helper(const vector<int>& nums, size_t index, vector<int> &acc, int curr_max){\\n        if(index >= n_){ \\n            global_min_ = min(global_min_, curr_max);\\n            return;\\n        }\\n\\n        for(int i=0; i<k_; ++i){\\n\\n            // Skip obviously wrong case\\n            if((acc[i] + nums[index]) > global_min_){ \\n                continue;\\n            }\\n            acc[i] += nums[index];\\n            helper(nums, index+1, acc, max(curr_max, acc[i]));\\n            acc[i] -= nums[index];\\n        }\\n    }\\npublic:\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        n_ = cookies.size();\\n        k_ = k;\\n        vector<int> acc(k, 0);\\n        helper(cookies, 0, acc, 0);\\n        return global_min_;\\n    }\\n};\\n```\\n\\n# Complexity\\n$k$: The number of children\\n$n$: The number of bags of cookies\\n- Time complexity: $O(n^k)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nDetermining all permutations requires $O(n^k)$ time complexity. Additionally, identifying the maximum value from each permutation can be achieved in $O(1)$ time complexity.\\n- Space complexity: $O(n+k)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe recursive call reaches a maximum depth of $O(n)$, and we utilize an additional vector, which size is $k$, to store the number of cookies each child has accumulated",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int helper(const vector<int>& nums, int index, int k, vector<int> &acc){\\n        int n = nums.size();\\n        if(index >= n){ \\n            int result = 0;\\n            for(int i=0; i<k; ++i){ result = max(result, acc[i]); }\\n            return result;\\n        }\\n\\n        int result = INT_MAX;\\n        for(int i=0; i<k; ++i){\\n            acc[i] += nums[index];\\n            result = min(result, helper(nums, index+1, k, acc));\\n            acc[i] -= nums[index];\\n        }\\n        return result;\\n    }\\npublic:\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        vector<int> acc(k, 0);\\n        return helper(cookies, 0, k, acc);\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    int global_min_ = INT_MAX;\\n    int n_; \\n    int k_;\\n    void helper(const vector<int>& nums, size_t index, vector<int> &acc, int curr_max){\\n        if(index >= n_){ \\n            global_min_ = min(global_min_, curr_max);\\n            return;\\n        }\\n\\n        for(int i=0; i<k_; ++i){\\n\\n            // Skip obviously wrong case\\n            if((acc[i] + nums[index]) > global_min_){ \\n                continue;\\n            }\\n            acc[i] += nums[index];\\n            helper(nums, index+1, acc, max(curr_max, acc[i]));\\n            acc[i] -= nums[index];\\n        }\\n    }\\npublic:\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        n_ = cookies.size();\\n        k_ = k;\\n        vector<int> acc(k, 0);\\n        helper(cookies, 0, acc, 0);\\n        return global_min_;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703074,
                "title": "o-k-n-using-backtracking-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem can be approached as a combinatorial optimization problem where we need to distribute cookies among k people such that the difference between the maximum and minimum number of cookies is minimized.\\n\\n# Approach\\nThe code uses a recursive backtracking approach to generate all possible distributions of cookies among the people. It starts with the first cookie and tries assigning it to each person, then recursively explores all possible assignments for the remaining cookies. The maximum difference between the number of cookies each person has is updated at each step. The minimum difference among all possible distributions is returned as the answer.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution depends on the number of possible distributions, which is k^n, where n is the number of cookies. In the worst case, each cookie can be assigned to any of the k people, resulting in a time complexity of O(k^n).\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(k) since we are using an additional vector temp to keep track of the number of cookies each person currently has. The recursion stack also contributes to the space complexity, which is O(n) in the worst case.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void helper(int start, const vector<int>& cookies, vector<int>& temp, int k, int& ans) {\\n        int n = cookies.size();\\n        if (start == n) {\\n            int maxi = INT_MIN;\\n            for (int i = 0; i < k; i++) {\\n                maxi = max(maxi, temp[i]);\\n            }\\n            ans = min(ans, maxi);\\n            return;\\n        }\\n\\n        for (int i = 0; i < k; i++) {\\n            temp[i] += cookies[start]; // take\\n            helper(start + 1, cookies, temp, k, ans);\\n            temp[i] -= cookies[start]; // back-track\\n        }\\n    }\\n\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int ans = INT_MAX;\\n        vector<int> temp(k, 0);\\n        helper(0, cookies, temp, k, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(int start, const vector<int>& cookies, vector<int>& temp, int k, int& ans) {\\n        int n = cookies.size();\\n        if (start == n) {\\n            int maxi = INT_MIN;\\n            for (int i = 0; i < k; i++) {\\n                maxi = max(maxi, temp[i]);\\n            }\\n            ans = min(ans, maxi);\\n            return;\\n        }\\n\\n        for (int i = 0; i < k; i++) {\\n            temp[i] += cookies[start]; // take\\n            helper(start + 1, cookies, temp, k, ans);\\n            temp[i] -= cookies[start]; // back-track\\n        }\\n    }\\n\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int ans = INT_MAX;\\n        vector<int> temp(k, 0);\\n        helper(0, cookies, temp, k, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703060,
                "title": "two-approaches-binary-search-backtracking-c",
                "content": "# Simple Backtrack Approach (2241 ms)\\n```\\nclass Solution {\\npublic:\\n    void help(vector<int>& cookies, int& ans, vector<int>& kids, int idx){\\n        if(idx==cookies.size()){\\n            ans = min(ans,*max_element(kids.begin(),kids.end()));\\n            return;\\n        }\\n\\n        for(int i=0;i<kids.size();i++){\\n            kids[i] += cookies[idx];\\n            help(cookies,ans,kids,idx+1);\\n            kids[i] -= cookies[idx];\\n        }\\n    }\\n\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        vector<int> kids(k,0);\\n        int ans = accumulate(cookies.begin(),cookies.end(),0);\\n        help(cookies,ans,kids,0);\\n        return ans;\\n    }\\n};\\n```\\n# Binary Search Approach (414 ms)\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& cookies, int max_val, vector<int>& kids, int idx){\\n        if(idx==cookies.size()){\\n            if(*max_element(kids.begin(),kids.end())<=max_val){\\n                return true;\\n            }\\n            return false;\\n        }\\n\\n        for(int i=0;i<kids.size();i++){\\n            kids[i] += cookies[idx];\\n            if(check(cookies,max_val,kids,idx+1)) return true;\\n            kids[i] -= cookies[idx];\\n        }\\n        return false;\\n    }\\n\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int i = *max_element(cookies.begin(),cookies.end()), j = accumulate(cookies.begin(),cookies.end(),0);\\n        int ans;\\n        while(i<=j){\\n            int mid = i + (j-i)/2;\\n            vector<int> kids(k,0);\\n            if(check(cookies,mid,kids,0)){\\n                ans = mid;\\n                j = mid-1;\\n            }\\n            else i = mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Please upvote for your continuous support \\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void help(vector<int>& cookies, int& ans, vector<int>& kids, int idx){\\n        if(idx==cookies.size()){\\n            ans = min(ans,*max_element(kids.begin(),kids.end()));\\n            return;\\n        }\\n\\n        for(int i=0;i<kids.size();i++){\\n            kids[i] += cookies[idx];\\n            help(cookies,ans,kids,idx+1);\\n            kids[i] -= cookies[idx];\\n        }\\n    }\\n\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        vector<int> kids(k,0);\\n        int ans = accumulate(cookies.begin(),cookies.end(),0);\\n        help(cookies,ans,kids,0);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& cookies, int max_val, vector<int>& kids, int idx){\\n        if(idx==cookies.size()){\\n            if(*max_element(kids.begin(),kids.end())<=max_val){\\n                return true;\\n            }\\n            return false;\\n        }\\n\\n        for(int i=0;i<kids.size();i++){\\n            kids[i] += cookies[idx];\\n            if(check(cookies,max_val,kids,idx+1)) return true;\\n            kids[i] -= cookies[idx];\\n        }\\n        return false;\\n    }\\n\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int i = *max_element(cookies.begin(),cookies.end()), j = accumulate(cookies.begin(),cookies.end(),0);\\n        int ans;\\n        while(i<=j){\\n            int mid = i + (j-i)/2;\\n            vector<int> kids(k,0);\\n            if(check(cookies,mid,kids,0)){\\n                ans = mid;\\n                j = mid-1;\\n            }\\n            else i = mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703044,
                "title": "python3-backtracking-binary-search-approach",
                "content": "# Approach\\n\\n#### Backtracking:\\n\\n- Utilize backtracking to explore every possible path.\\n- Apply pruning whenever adding a cookie. If the current distribution exceeds the current minimum answer, there is no need to continue recursion.\\n\\n#### Backtracking + Binary Search:\\n\\n- The answer must lie between the maximum value and the sum of all cookies. Therefore, we can use binary search within this range.\\n- Utilize backtracking to check if a particular distribution is valid. If it is valid, try with a smaller value; otherwise, try with a larger value.\\n\\n\\n\\n# Code\\n\\n1. Backtracking\\n```\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n        minimum = math.inf\\n        def dfs(i, arr):\\n            nonlocal minimum\\n            if i==len(cookies):\\n                minimum = min(minimum, max(arr))\\n                return\\n            for idx in range(len(arr)):\\n                if arr[idx]+cookies[i]>=minimum:\\n                    continue\\n                arr[idx]+=cookies[i]\\n                dfs(i+1, arr)\\n                arr[idx]-=cookies[i]\\n        arr = [0 for _ in range(k)]\\n        dfs(0, arr)\\n        return minimum\\n```\\n\\n2. Backtracking+Binary search\\n```\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n        left = max(cookies)\\n        right = sum(cookies)\\n        def check(mid):\\n            def dfs(i):\\n                if i==len(cookies):\\n                    return True\\n                for j in range(len(arr)):\\n                    if arr[j]+cookies[i]<=mid:\\n                        arr[j]+=cookies[i]\\n                        if dfs(i+1):\\n                            return True\\n                        arr[j]-=cookies[i]\\n                return False\\n            arr = [0 for _ in range(k)]\\n            return dfs(0)\\n\\n        while left<=right:\\n            mid = (left+right)//2\\n            if check(mid):\\n                right = mid-1\\n            else:\\n                left = mid+1\\n        return left\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n        minimum = math.inf\\n        def dfs(i, arr):\\n            nonlocal minimum\\n            if i==len(cookies):\\n                minimum = min(minimum, max(arr))\\n                return\\n            for idx in range(len(arr)):\\n                if arr[idx]+cookies[i]>=minimum:\\n                    continue\\n                arr[idx]+=cookies[i]\\n                dfs(i+1, arr)\\n                arr[idx]-=cookies[i]\\n        arr = [0 for _ in range(k)]\\n        dfs(0, arr)\\n        return minimum\\n```\n```\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n        left = max(cookies)\\n        right = sum(cookies)\\n        def check(mid):\\n            def dfs(i):\\n                if i==len(cookies):\\n                    return True\\n                for j in range(len(arr)):\\n                    if arr[j]+cookies[i]<=mid:\\n                        arr[j]+=cookies[i]\\n                        if dfs(i+1):\\n                            return True\\n                        arr[j]-=cookies[i]\\n                return False\\n            arr = [0 for _ in range(k)]\\n            return dfs(0)\\n\\n        while left<=right:\\n            mid = (left+right)//2\\n            if check(mid):\\n                right = mid-1\\n            else:\\n                left = mid+1\\n        return left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703034,
                "title": "java-easiest-solution-using-recursion-and-backtracking-with-proper-comments",
                "content": "```\\nclass Solution {\\n    int minimumUnfairValue = Integer.MAX_VALUE;\\n    public int distributeCookies(int[] cookies, int k) {\\n        // we have total k children\\n        int[] childrenDistributionList = new int[k];\\n\\n        // try all possible combinations, using recursion\\n        helper(0, childrenDistributionList, cookies);\\n\\n        return minimumUnfairValue;\\n    }\\n\\n    public void helper(int ind, int[] childrenDistributionList, int[] cookies) {\\n        if(ind == cookies.length) {\\n            // no more cookies are left\\n            findMinimumUnFairValue(childrenDistributionList);\\n            return;\\n        }\\n\\n        int currentCookie = cookies[ind];\\n        // now try to distribute currentCookie to all k childrens\\n        for(int i = 0; i < childrenDistributionList.length; i++) {\\n            childrenDistributionList[i] += currentCookie;\\n            helper(ind+1, childrenDistributionList, cookies);\\n            // do backtracking\\n            childrenDistributionList[i] -= currentCookie;\\n\\n            if(childrenDistributionList[i] == 0) break;\\n        }\\n    }\\n\\n    public void findMinimumUnFairValue(int[] arr) {\\n        int maxValueFromArray = Integer.MIN_VALUE;\\n        for(int item : arr) {\\n            maxValueFromArray = Math.max(maxValueFromArray, item);\\n        }\\n        minimumUnfairValue = Math.min(minimumUnfairValue, maxValueFromArray);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int minimumUnfairValue = Integer.MAX_VALUE;\\n    public int distributeCookies(int[] cookies, int k) {\\n        // we have total k children\\n        int[] childrenDistributionList = new int[k];\\n\\n        // try all possible combinations, using recursion\\n        helper(0, childrenDistributionList, cookies);\\n\\n        return minimumUnfairValue;\\n    }\\n\\n    public void helper(int ind, int[] childrenDistributionList, int[] cookies) {\\n        if(ind == cookies.length) {\\n            // no more cookies are left\\n            findMinimumUnFairValue(childrenDistributionList);\\n            return;\\n        }\\n\\n        int currentCookie = cookies[ind];\\n        // now try to distribute currentCookie to all k childrens\\n        for(int i = 0; i < childrenDistributionList.length; i++) {\\n            childrenDistributionList[i] += currentCookie;\\n            helper(ind+1, childrenDistributionList, cookies);\\n            // do backtracking\\n            childrenDistributionList[i] -= currentCookie;\\n\\n            if(childrenDistributionList[i] == 0) break;\\n        }\\n    }\\n\\n    public void findMinimumUnFairValue(int[] arr) {\\n        int maxValueFromArray = Integer.MIN_VALUE;\\n        for(int item : arr) {\\n            maxValueFromArray = Math.max(maxValueFromArray, item);\\n        }\\n        minimumUnfairValue = Math.min(minimumUnfairValue, maxValueFromArray);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703031,
                "title": "c-backtracking-intuition-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTry all possible ways. Pick the best way.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInclusion-exclusion of a cookie for all children \\n\\n# Complexity\\n- Time complexity: O(k^n) \\n  for all n cookies, k calls on k children\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(k+n)\\n  k for temp vector and n for recursion call stack\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int ans = INT_MAX;\\n        vector<int> temp(k, 0);\\n        dfs(0, cookies, temp, k, ans);\\n        return ans;\\n    }\\n\\nprivate:\\n    void dfs(int start, vector<int>& cookies, vector<int>& temp, int k, int& ans) {\\n        int n = cookies.size();\\n        if (start == n) {//processed all cookies\\n            //calculating max # of cookies among all children int his arrangement\\n            int maxi = INT_MIN;\\n            for (int i = 0; i < k; i++) {\\n                maxi = max(maxi, temp[i]);\\n            }\\n            //updating min value among this arrangement and other arrangements\\n            ans = min(ans, maxi);\\n            return;\\n        }\\n\\n        for (int i = 0; i < k; i++) {\\n            temp[i] += cookies[start]; // take\\n            dfs(start + 1, cookies, temp, k, ans);\\n            temp[i] -= cookies[start]; // back-track\\n        }\\n    }\\n};\\n\\n\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int ans = INT_MAX;\\n        vector<int> temp(k, 0);\\n        dfs(0, cookies, temp, k, ans);\\n        return ans;\\n    }\\n\\nprivate:\\n    void dfs(int start, vector<int>& cookies, vector<int>& temp, int k, int& ans) {\\n        int n = cookies.size();\\n        if (start == n) {//processed all cookies\\n            //calculating max # of cookies among all children int his arrangement\\n            int maxi = INT_MIN;\\n            for (int i = 0; i < k; i++) {\\n                maxi = max(maxi, temp[i]);\\n            }\\n            //updating min value among this arrangement and other arrangements\\n            ans = min(ans, maxi);\\n            return;\\n        }\\n\\n        for (int i = 0; i < k; i++) {\\n            temp[i] += cookies[start]; // take\\n            dfs(start + 1, cookies, temp, k, ans);\\n            temp[i] -= cookies[start]; // back-track\\n        }\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703007,
                "title": "c-backtracking-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int f(int ind, int k, vector<int> &cookies, vector<int> &child){\\n        \\n        if(ind==cookies.size()){\\n            int temp = 0;\\n            for(int i=0; i<k; i++){\\n                temp = max(temp,child[i]);\\n            }\\n            return temp;\\n        }\\n\\n        int ans = INT_MAX;\\n        for(int i=0; i<k; i++){\\n            child[i] += cookies[ind];\\n            ans = min(ans,f(ind+1,k,cookies,child));\\n            child[i] -= cookies[ind];\\n        }\\n        return ans;\\n\\n    }\\n\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        vector<int> child(k,0);\\n        return f(0,k,cookies,child);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int f(int ind, int k, vector<int> &cookies, vector<int> &child){\\n        \\n        if(ind==cookies.size()){\\n            int temp = 0;\\n            for(int i=0; i<k; i++){\\n                temp = max(temp,child[i]);\\n            }\\n            return temp;\\n        }\\n\\n        int ans = INT_MAX;\\n        for(int i=0; i<k; i++){\\n            child[i] += cookies[ind];\\n            ans = min(ans,f(ind+1,k,cookies,child));\\n            child[i] -= cookies[ind];\\n        }\\n        return ans;\\n\\n    }\\n\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        vector<int> child(k,0);\\n        return f(0,k,cookies,child);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702849,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalmax;\\n    void allocate(vector<int>& cookies,vector<int>& children,int ind,int n,int k){\\n        if(ind==n){\\n            int maxm=0;\\n            for(int j=0;j<k;j++){\\n                maxm=max(maxm,children[j]);\\n            }\\n            totalmax=min(totalmax,maxm);\\n            return;\\n        }\\n        \\n        for(int j=0;j<k;j++){\\n            if(children[j]+cookies[ind]>=totalmax) continue;\\n            children[j]+=cookies[ind];\\n            allocate(cookies,children,ind+1,n,k);\\n            children[j]-=cookies[ind];\\n        }\\n    }\\n    \\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int n = cookies.size();\\n        vector<int>children(k);\\n        totalmax=INT_MAX;\\n        allocate(cookies,children,0,n,k);\\n        return totalmax;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalmax;\\n    void allocate(vector<int>& cookies,vector<int>& children,int ind,int n,int k){\\n        if(ind==n){\\n            int maxm=0;\\n            for(int j=0;j<k;j++){\\n                maxm=max(maxm,children[j]);\\n            }\\n            totalmax=min(totalmax,maxm);\\n            return;\\n        }\\n        \\n        for(int j=0;j<k;j++){\\n            if(children[j]+cookies[ind]>=totalmax) continue;\\n            children[j]+=cookies[ind];\\n            allocate(cookies,children,ind+1,n,k);\\n            children[j]-=cookies[ind];\\n        }\\n    }\\n    \\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int n = cookies.size();\\n        vector<int>children(k);\\n        totalmax=INT_MAX;\\n        allocate(cookies,children,0,n,k);\\n        return totalmax;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702768,
                "title": "solved-using-backtracking-o-k-n-c-easy-to-understand-with-comments-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nConcept behind backtracking is that we try to distribute every cookie to each child and if we reached to end then we update our answer and backtrack.\\n\\nSo, create vector of size K. Child[i] indicates sum of cookies that i<sup>th</sup> child has. \\n\\n\\nInside backtrack function We run loop of K and assign Cookies[index] to each child. Then we move to next index. If we reach to end then calculate Max sum and update answer.\\n\\nHere, Max Sum denotes unfairness of a distribution that is defined as maximum total cookies obtained by a single  child in the distribution. Remember We want to minimize unfairness here. Hence ans=min(ans,sum).\\n# Complexity\\n- Time complexity: O(k<sup>n</sup>)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(k+n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void backtrack(int index, int end,int k, vector<int> &child,vector<int> &cookies, int &ans){\\n        if(index==end){\\n            int sum=0;\\n            for(int i=0;i<k;i++) {\\n                // The unfairness of a distribution is defined as the maximum total cookies obtained by a single  child in the distribution.\\n                sum=max(sum,child[i]);\\n            }\\n            ans=min(ans,sum); \\n            return;\\n        }\\n        for(int i=0;i<k;i++){\\n            child[i]+=cookies[index];\\n            backtrack(index+1,end,k,child,cookies,ans);\\n            child[i]-=cookies[index]; //backtrack\\n        }\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        vector<int> child(k);\\n        int ans=1e9; //we want to minimize unfairness of all distributions\\n        backtrack(0,cookies.size(),k,child,cookies,ans);\\n        return ans;\\n    }\\n};\\n```\\n\\n![memix-sad-cat-cry.jpeg](https://assets.leetcode.com/users/images/ac281d87-7dab-49d1-b9f7-8c462ad46edf_1688189401.6081083.jpeg)",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void backtrack(int index, int end,int k, vector<int> &child,vector<int> &cookies, int &ans){\\n        if(index==end){\\n            int sum=0;\\n            for(int i=0;i<k;i++) {\\n                // The unfairness of a distribution is defined as the maximum total cookies obtained by a single  child in the distribution.\\n                sum=max(sum,child[i]);\\n            }\\n            ans=min(ans,sum); \\n            return;\\n        }\\n        for(int i=0;i<k;i++){\\n            child[i]+=cookies[index];\\n            backtrack(index+1,end,k,child,cookies,ans);\\n            child[i]-=cookies[index]; //backtrack\\n        }\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        vector<int> child(k);\\n        int ans=1e9; //we want to minimize unfairness of all distributions\\n        backtrack(0,cookies.size(),k,child,cookies,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702728,
                "title": "distribute-the-cookie-one-by-one",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int f(int i,vector<int>&cookies,vector<int>v)\\n    {\\n        if(i==cookies.size()) \\n        return *max_element(begin(v),end(v));\\n\\n        int ans=INT_MAX;\\n        for(int j=0;j<size(v);j++)\\n        {\\n            v[j]+=cookies[i];\\n            ans=min(ans,f(i+1,cookies,v));\\n            v[j]-=cookies[i];\\n            if(v[j]==0) break; // if a candidate does not get any cookie ,it will be the case of maximum unfairness\\n        }\\n        return ans;\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        vector<int>v(k,0);\\n        return f(0,cookies,v);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int i,vector<int>&cookies,vector<int>v)\\n    {\\n        if(i==cookies.size()) \\n        return *max_element(begin(v),end(v));\\n\\n        int ans=INT_MAX;\\n        for(int j=0;j<size(v);j++)\\n        {\\n            v[j]+=cookies[i];\\n            ans=min(ans,f(i+1,cookies,v));\\n            v[j]-=cookies[i];\\n            if(v[j]==0) break; // if a candidate does not get any cookie ,it will be the case of maximum unfairness\\n        }\\n        return ans;\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        vector<int>v(k,0);\\n        return f(0,cookies,v);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702726,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    int[] children;\\n    int minUnfairness;\\n\\n    public int DistributeCookies(int[] cookies, int k) {\\n        children = new int[k];\\n        minUnfairness = int.MaxValue;\\n        Helper(cookies, 0, k);\\n        return minUnfairness;\\n    }\\n\\n    private void Helper(int[] cookies, int idx, int k){\\n        if(idx >= cookies.Length){\\n            minUnfairness = Math.Min(children.Max(), minUnfairness);\\n            return;\\n        }\\n\\n        for(int i=0; i<k; i++){\\n            children[i] += cookies[idx];\\n            Helper(cookies, idx+1, k);\\n            children[i] -= cookies[idx];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\npublic class Solution {\\n    int[] children;\\n    int minUnfairness;\\n\\n    public int DistributeCookies(int[] cookies, int k) {\\n        children = new int[k];\\n        minUnfairness = int.MaxValue;\\n        Helper(cookies, 0, k);\\n        return minUnfairness;\\n    }\\n\\n    private void Helper(int[] cookies, int idx, int k){\\n        if(idx >= cookies.Length){\\n            minUnfairness = Math.Min(children.Max(), minUnfairness);\\n            return;\\n        }\\n\\n        for(int i=0; i<k; i++){\\n            children[i] += cookies[idx];\\n            Helper(cookies, idx+1, k);\\n            children[i] -= cookies[idx];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702687,
                "title": "q2305-accepted-c-used-rec-bt-easiest",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans = INT_MAX;\\n    void solve(int idx,int k,vector<int> &v,vector<int>& cookies){\\n        if(idx == cookies.size()){\\n            int m = 0;\\n            for(auto c:v)\\n                m = max(m,c);\\n            ans = min(ans,m);\\n            return;\\n        }\\n        for(int i=0;i<k;i++){\\n            v[i] += cookies[idx];\\n            solve(idx+1,k,v,cookies);\\n            v[i] -= cookies[idx];\\n        }\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        vector<int> v(k,0);\\n        solve(0,k,v,cookies);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = INT_MAX;\\n    void solve(int idx,int k,vector<int> &v,vector<int>& cookies){\\n        if(idx == cookies.size()){\\n            int m = 0;\\n            for(auto c:v)\\n                m = max(m,c);\\n            ans = min(ans,m);\\n            return;\\n        }\\n        for(int i=0;i<k;i++){\\n            v[i] += cookies[idx];\\n            solve(idx+1,k,v,cookies);\\n            v[i] -= cookies[idx];\\n        }\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        vector<int> v(k,0);\\n        solve(0,k,v,cookies);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702662,
                "title": "simple-backtracking-solution-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int res = INT_MAX; \\n    void cook(int i,vector<int>&cookies,vector<int> &countcookies,int k){\\n        //base condition\\n        if(i==cookies.size()){\\n        int x = *max_element(countcookies.begin(),countcookies.end());//find max from array\\n            res = min(res,x); //calculating result\\n            return ;\\n        }\\n        for(int j=0;j<k;j++){\\n           countcookies[j]+=cookies[i];//assign each cookies to the childeren\\n           cook(i+1,cookies,countcookies,k);//call for next cookies\\n           countcookies[j]-=cookies[i];//backtrack here\\n        }\\n   \\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n       vector<int> countcookies(k,0); \\n         cook(0,cookies,countcookies,k);\\n         return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int res = INT_MAX; \\n    void cook(int i,vector<int>&cookies,vector<int> &countcookies,int k){\\n        //base condition\\n        if(i==cookies.size()){\\n        int x = *max_element(countcookies.begin(),countcookies.end());//find max from array\\n            res = min(res,x); //calculating result\\n            return ;\\n        }\\n        for(int j=0;j<k;j++){\\n           countcookies[j]+=cookies[i];//assign each cookies to the childeren\\n           cook(i+1,cookies,countcookies,k);//call for next cookies\\n           countcookies[j]-=cookies[i];//backtrack here\\n        }\\n   \\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n       vector<int> countcookies(k,0); \\n         cook(0,cookies,countcookies,k);\\n         return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702659,
                "title": "backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dfs(int i,vector<int>&distribute, vector<int>& cookies,int k,int zeroCount){\\n        if(cookies.size()-i < zeroCount)\\n            return INT_MAX;\\n        if(i == cookies.size())\\n            return *max_element(distribute.begin(),distribute.end());\\n\\n        int answer = INT_MAX;\\n        for(int j=0;j<k;j++){\\n            zeroCount -= distribute[j] ==0 ? 1:0;\\n            distribute[j]+=cookies[i];\\n\\n            answer = min(answer,dfs(i+1,distribute,cookies,k,zeroCount));\\n\\n            distribute[j] -= cookies[i];\\n            zeroCount += distribute[j]==0?1:0;\\n        }\\n        return answer;\\n    }\\n    \\n\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        vector<int> distribute(k,0);\\n        return dfs(0,distribute,cookies,k,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dfs(int i,vector<int>&distribute, vector<int>& cookies,int k,int zeroCount){\\n        if(cookies.size()-i < zeroCount)\\n            return INT_MAX;\\n        if(i == cookies.size())\\n            return *max_element(distribute.begin(),distribute.end());\\n\\n        int answer = INT_MAX;\\n        for(int j=0;j<k;j++){\\n            zeroCount -= distribute[j] ==0 ? 1:0;\\n            distribute[j]+=cookies[i];\\n\\n            answer = min(answer,dfs(i+1,distribute,cookies,k,zeroCount));\\n\\n            distribute[j] -= cookies[i];\\n            zeroCount += distribute[j]==0?1:0;\\n        }\\n        return answer;\\n    }\\n    \\n\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        vector<int> distribute(k,0);\\n        return dfs(0,distribute,cookies,k,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702647,
                "title": "easy-c-solution-begineer-friendly-recursion-simple-with-comments",
                "content": "\\n# Approach\\nAs we have k child so we are trying to break cookies array into k parts and trying to minimize the difference between them.\\n<!-- Describe your approach to solving the problem. -->\\n\\nNow see code with comments to understand in easy way\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int getAns(int index,vector<int>&cookies,vector<int>&child,int k){\\n        //here it is base case if it reaches at the end then it will return the ans which is maximum element in our child array as per question\\n        if(index==cookies.size()){\\n            return *max_element(child.begin(),child.end());\\n        }\\n        //we have to minimize difference in child array \\n        int ans=1e8;\\n\\n        //trying out all sort of combination to give that cookies to any child\\n        for(int i=0;i<k;i++){\\n            //first adding that cookies to ith child and trying to minimize our answer\\n            child[i]+=cookies[index];\\n            //trying to give another set of cookies to ith child and trying out differnt combination\\n            ans=min(ans,getAns(index+1,cookies,child,k));\\n            //and later backtracking means deleting that cookies from ith child so that we can assign it to different child \\n            //this way we can try all different combination and we can minimize our solution\\n            child[i]-=cookies[index];\\n        }\\n\\n        return ans;\\n    }\\npublic:\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        //We are keeping track of cookies such that we know th number that which child gets how many number of cookies\\n        vector<int>child(k,0);\\n        return getAns(0,cookies,child,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int getAns(int index,vector<int>&cookies,vector<int>&child,int k){\\n        //here it is base case if it reaches at the end then it will return the ans which is maximum element in our child array as per question\\n        if(index==cookies.size()){\\n            return *max_element(child.begin(),child.end());\\n        }\\n        //we have to minimize difference in child array \\n        int ans=1e8;\\n\\n        //trying out all sort of combination to give that cookies to any child\\n        for(int i=0;i<k;i++){\\n            //first adding that cookies to ith child and trying to minimize our answer\\n            child[i]+=cookies[index];\\n            //trying to give another set of cookies to ith child and trying out differnt combination\\n            ans=min(ans,getAns(index+1,cookies,child,k));\\n            //and later backtracking means deleting that cookies from ith child so that we can assign it to different child \\n            //this way we can try all different combination and we can minimize our solution\\n            child[i]-=cookies[index];\\n        }\\n\\n        return ans;\\n    }\\npublic:\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        //We are keeping track of cookies such that we know th number that which child gets how many number of cookies\\n        vector<int>child(k,0);\\n        return getAns(0,cookies,child,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702605,
                "title": "daily-coding-challenge-java-using-backtracking-and-recursion",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n   private int res=Integer.MAX_VALUE;\\n    public int distributeCookies(int[] cookies, int k) {\\n       backtracking(cookies,0,k,new int[k]);\\n       return res;\\n    }\\n void backtracking(int[] cookies,int index,int k,int[] cookiesdistribution){\\n         if(index==cookies.length)  {\\n             int max=0;\\n             for(int cook: cookiesdistribution)  max=Math.max(max,cook);\\n                \\n                 res=Math.min(res,max);\\n                 return;\\n             \\n         }\\n         for(int i=0;i<k;i++){\\n             cookiesdistribution[i]+=cookies[index];\\n             backtracking(cookies,index+1,k,cookiesdistribution);\\n             cookiesdistribution[i]-=cookies[index];\\n         }\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n   private int res=Integer.MAX_VALUE;\\n    public int distributeCookies(int[] cookies, int k) {\\n       backtracking(cookies,0,k,new int[k]);\\n       return res;\\n    }\\n void backtracking(int[] cookies,int index,int k,int[] cookiesdistribution){\\n         if(index==cookies.length)  {\\n             int max=0;\\n             for(int cook: cookiesdistribution)  max=Math.max(max,cook);\\n                \\n                 res=Math.min(res,max);\\n                 return;\\n             \\n         }\\n         for(int i=0;i<k;i++){\\n             cookiesdistribution[i]+=cookies[index];\\n             backtracking(cookies,index+1,k,cookiesdistribution);\\n             cookiesdistribution[i]-=cookies[index];\\n         }\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702556,
                "title": "c-bit-manipulation-dp-4-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        // Pre-compute vector sum over a k bit mask.\\n        vector<int> sums;\\n        int num_cookies = cookies.size();\\n        for (int i = 0; i < (1 << num_cookies); ++i) {\\n            sums.push_back(Sum(cookies, i));\\n        }\\n\\n        int output = INT_MAX;\\n        int num_status = 1 << num_cookies;\\n        vector<vector<int>> dp(1 + k, vector<int>(num_status, 0));\\n        // If k = 1, then at each bit mask the dp value is the sum of\\n        // array masked.\\n        for (int i = 0; i < num_status; ++i) {\\n            dp[1][i] = sums[i];\\n        }\\n        for (int i = 2; i <= k; ++i) {\\n            for (int j = 1; j < num_status; ++j) {\\n                int res = INT_MAX;\\n                for (int x = 1; x < j; ++x) {\\n                    if ((j & x) == x) {\\n                        // let\\'s say j = 0x11 and i = 2\\n                        // and x = 0x01\\n                        // Then the first child gets the cookies[0]\\n                        // And the second child gets cookies[1], aka dp[i - 1][j - x]\\n                        int part1 = dp[i - 1][j - x];\\n                        int part2 = sums[x];\\n                        res = std::min(res, std::max(part1, part2));\\n                    }\\n                }\\n                dp[i][j] = res;\\n            }\\n        }\\n        // dp[k][num_status - 1] means partition it with k groups, and\\n        // use all cookies (bit mask = \"1111...\")\\n        return dp[k][num_status - 1];\\n    }\\nprivate:\\n    int Sum(const vector<int> &cookies, int status) {\\n        int sum = 0;\\n        for (int i = 0; i < cookies.size(); ++i) {\\n            if (status & (1 << i)) sum += cookies[i];\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        // Pre-compute vector sum over a k bit mask.\\n        vector<int> sums;\\n        int num_cookies = cookies.size();\\n        for (int i = 0; i < (1 << num_cookies); ++i) {\\n            sums.push_back(Sum(cookies, i));\\n        }\\n\\n        int output = INT_MAX;\\n        int num_status = 1 << num_cookies;\\n        vector<vector<int>> dp(1 + k, vector<int>(num_status, 0));\\n        // If k = 1, then at each bit mask the dp value is the sum of\\n        // array masked.\\n        for (int i = 0; i < num_status; ++i) {\\n            dp[1][i] = sums[i];\\n        }\\n        for (int i = 2; i <= k; ++i) {\\n            for (int j = 1; j < num_status; ++j) {\\n                int res = INT_MAX;\\n                for (int x = 1; x < j; ++x) {\\n                    if ((j & x) == x) {\\n                        // let\\'s say j = 0x11 and i = 2\\n                        // and x = 0x01\\n                        // Then the first child gets the cookies[0]\\n                        // And the second child gets cookies[1], aka dp[i - 1][j - x]\\n                        int part1 = dp[i - 1][j - x];\\n                        int part2 = sums[x];\\n                        res = std::min(res, std::max(part1, part2));\\n                    }\\n                }\\n                dp[i][j] = res;\\n            }\\n        }\\n        // dp[k][num_status - 1] means partition it with k groups, and\\n        // use all cookies (bit mask = \"1111...\")\\n        return dp[k][num_status - 1];\\n    }\\nprivate:\\n    int Sum(const vector<int> &cookies, int status) {\\n        int sum = 0;\\n        for (int i = 0; i < cookies.size(); ++i) {\\n            if (status & (1 << i)) sum += cookies[i];\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702511,
                "title": "python-optimization-needed-to-avoid-tle",
                "content": "# Intuition\\nSince data size is small, just brutal force it using backtracking; however, for python3 time constraint is tight. \\n\\nTo make it work, each time I sort the current count for each child to break symmetry of the state. For example, if we have 2 children and 30 candies, then allocation (10, 20) equal (20, 10), we only need to compute one of them to save time.\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n        # distribute as even as possible\\n        # brutal force it: \\n\\n        self.res = float(\\'inf\\')\\n\\n        @cache\\n        def dfs(start, state):\\n            # Given the state which is the count for each kid, return the result\\n            if start == len(cookies):\\n                self.res = min(self.res, max(state))\\n                return max(state)\\n            \\n            if max(state) > self.res:\\n                # early stopping\\n                return float(\\'inf\\')\\n            \\n            # break the symmetry for state\\n            lst = sorted(state)\\n            res = float(\\'inf\\')\\n\\n            for i in range(k):\\n                lst[i] += cookies[start]\\n                res = min(res, dfs(start+1, tuple(lst)))\\n                lst[i] -= cookies[start]\\n\\n            return res\\n        \\n        return dfs(0, tuple([0]*k))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n        # distribute as even as possible\\n        # brutal force it: \\n\\n        self.res = float(\\'inf\\')\\n\\n        @cache\\n        def dfs(start, state):\\n            # Given the state which is the count for each kid, return the result\\n            if start == len(cookies):\\n                self.res = min(self.res, max(state))\\n                return max(state)\\n            \\n            if max(state) > self.res:\\n                # early stopping\\n                return float(\\'inf\\')\\n            \\n            # break the symmetry for state\\n            lst = sorted(state)\\n            res = float(\\'inf\\')\\n\\n            for i in range(k):\\n                lst[i] += cookies[start]\\n                res = min(res, dfs(start+1, tuple(lst)))\\n                lst[i] -= cookies[start]\\n\\n            return res\\n        \\n        return dfs(0, tuple([0]*k))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702506,
                "title": "c-easy-solution-using-next-permutation-and-binary-search",
                "content": "# Intuition\\nSuppose the number of cookies as N.We just need to find the ideal distrubution for which the maximum sum among the k partitions we do (for k children), is minimum. This can be achieved using binary search among all possible permutations of the `cookies` array.As N is not that high, we can easily calculate our result in less time. \\n\\n# Approach\\nWe initialize our answer to be INT_MAX. Then minimum of maximum sum is calculated iteratively for each permutation.\\nFor binary search, the function is designed such that the partition is as optimal as possible.\\n\\n# Complexity\\n- Time complexity:\\nO(N! * (N * log(N) + log(N) * sum))) where  N = `cookies.size()` and\\n `sum` = \\u03A3`cookies[i]` where i = 0 to N-1 \\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool isValid(vector<int>& nums, int k, int mid) {\\n    int count = 0;\\n    int sum = 0;\\n    for (int num : nums) {\\n        sum += num;\\n        if (sum > mid) {\\n            count++;\\n            sum = num;\\n        }\\n    }\\n    count++;\\n    return count <= k;\\n}\\n\\nint findMinimumMaximumSum(vector<int>& nums, int k) {\\n    int left = 0;\\n    int right = 0;\\n    for (int num : nums) {\\n        left = max(left, num);\\n        right += num;\\n    }\\n\\n    int result = right;\\n    while (left <= right) {\\n        int mid = left + (right - left) / 2;\\n        if (isValid(nums, k, mid)) {\\n            result = mid;\\n            right = mid - 1;\\n        } else {\\n            left = mid + 1;\\n        }\\n    }\\n\\n    return result;\\n}\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int ans = INT_MAX;\\n        sort(cookies.begin(),cookies.end());\\n        do{\\n            ans = min(ans,findMinimumMaximumSum(cookies,k));\\n\\n        }while(next_permutation(cookies.begin(),cookies.end()));\\n        return ans;\\n    }\\n};\\n```\\nPlease upvote if you liked the solution!\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool isValid(vector<int>& nums, int k, int mid) {\\n    int count = 0;\\n    int sum = 0;\\n    for (int num : nums) {\\n        sum += num;\\n        if (sum > mid) {\\n            count++;\\n            sum = num;\\n        }\\n    }\\n    count++;\\n    return count <= k;\\n}\\n\\nint findMinimumMaximumSum(vector<int>& nums, int k) {\\n    int left = 0;\\n    int right = 0;\\n    for (int num : nums) {\\n        left = max(left, num);\\n        right += num;\\n    }\\n\\n    int result = right;\\n    while (left <= right) {\\n        int mid = left + (right - left) / 2;\\n        if (isValid(nums, k, mid)) {\\n            result = mid;\\n            right = mid - 1;\\n        } else {\\n            left = mid + 1;\\n        }\\n    }\\n\\n    return result;\\n}\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int ans = INT_MAX;\\n        sort(cookies.begin(),cookies.end());\\n        do{\\n            ans = min(ans,findMinimumMaximumSum(cookies,k));\\n\\n        }while(next_permutation(cookies.begin(),cookies.end()));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702471,
                "title": "c-backtracking-solution-with-approach-explained",
                "content": "# Intuition\\nFirst I thought that this is a binary search problem. But when I saw the constraint then I thought that the constraints this low should be a question of Recursion.\\n\\n# Approach\\nThe naive approach to the problem is generate all the subsets and see the minimum of the maximum sum for k children.\\n\\nFirst generate a vector of size k to store the sum of cookies for each children. Now in the Recursive Function we generate all subsets and keep storing it in vector of size k. \\n\\nWhen all are stored then find the max of them in the base case and return res.\\nThen find the minimum of them and store in ans.\\n\\n# Complexity\\n- Time complexity:\\nO(N^N)\\n\\n- Space complexity:\\nO(K)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int f(int ind, vector<int> &arr, int k, int n, vector<int> &temp){\\n        if(ind==n){\\n            int res = 0;\\n            for(int i=0; i<k; i++){\\n                res=max(res, temp[i]);\\n            }\\n            return res;\\n        }\\n\\n\\n        int ans = 1e8;\\n        for(int i=0; i<k; i++){\\n            temp[i]+=arr[ind];\\n            int mincookie = f(ind+1,arr,k,n,temp);\\n            ans=min(ans, mincookie);\\n            temp[i]-=arr[ind];\\n        }\\n        return ans;\\n    }\\n\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int n=cookies.size();\\n        vector<int> temp(k);\\n        int ans = f(0,cookies,k,n,temp);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int ind, vector<int> &arr, int k, int n, vector<int> &temp){\\n        if(ind==n){\\n            int res = 0;\\n            for(int i=0; i<k; i++){\\n                res=max(res, temp[i]);\\n            }\\n            return res;\\n        }\\n\\n\\n        int ans = 1e8;\\n        for(int i=0; i<k; i++){\\n            temp[i]+=arr[ind];\\n            int mincookie = f(ind+1,arr,k,n,temp);\\n            ans=min(ans, mincookie);\\n            temp[i]-=arr[ind];\\n        }\\n        return ans;\\n    }\\n\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int n=cookies.size();\\n        vector<int> temp(k);\\n        int ans = f(0,cookies,k,n,temp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702410,
                "title": "c-2305-fair-distribution-of-cookies-easy-to-understand",
                "content": "# C++ | 2305. Fair Distribution of Cookies | Easy to Understand\\n```\\nclass Solution {\\npublic:\\n    int ans = INT_MAX;\\n    void solve(vector<int>& c, int k,vector<int>& b, int i){\\n        if(i == c.size()){\\n            int mini = INT_MIN;\\n            for(int i = 0;i<k;i++){\\n                mini = max(mini,b[i]);\\n            }\\n\\n            ans = min(mini,ans);\\n            return;\\n        }\\n\\n        for(int j = 0;j<k;j++){\\n            b[j] += c[i];\\n            solve(c,k,b,i+1);\\n            b[j] -= c[i];\\n        }\\n    }\\n\\n    int distributeCookies(vector<int>& c, int k) {\\n        vector<int>b(k,0);\\n        solve(c,k,b,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = INT_MAX;\\n    void solve(vector<int>& c, int k,vector<int>& b, int i){\\n        if(i == c.size()){\\n            int mini = INT_MIN;\\n            for(int i = 0;i<k;i++){\\n                mini = max(mini,b[i]);\\n            }\\n\\n            ans = min(mini,ans);\\n            return;\\n        }\\n\\n        for(int j = 0;j<k;j++){\\n            b[j] += c[i];\\n            solve(c,k,b,i+1);\\n            b[j] -= c[i];\\n        }\\n    }\\n\\n    int distributeCookies(vector<int>& c, int k) {\\n        vector<int>b(k,0);\\n        solve(c,k,b,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702401,
                "title": "backtracking-javascript-code-explained",
                "content": "# \\uD83D\\uDD25 Please upvote if it was helpful. Thanks! \\uD83D\\uDD25\\n\\n# Complexity\\n- Time complexity: $$O(k^n)$$ \\n- Space complexity: $$O(k+n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} cookies\\n * @param {number} k\\n * @return {number}\\n */\\nvar distributeCookies = function (cookies, k) {\\n    // distribution[k] - sum of cookies get by a k-th child\\n    const distribution = new Map()\\n\\n    // the minimum unfairness of all distributions\\n    let minUnfairness = Infinity\\n\\n    const dfs = (i) => {\\n        // i - index of a cookies we are going to distribute\\n\\n        // if i == cookies.length - calculate an unfairness for the current distibution \\n        if (i == cookies.length) {\\n            let unfairness = 0\\n            for (let n = 1; n <= k; n++) {\\n                unfairness = Math.max(unfairness, (distribution.get(n) || 0))\\n            }\\n            minUnfairness = Math.min(minUnfairness, unfairness)\\n            return\\n        }\\n\\n        // iterate over all children and distibute the current i-th cookie\\n        for (let n = 1; n <= k; n++) {\\n            let newSum = (distribution.get(n) || 0) + cookies[i]\\n            // if the total cookies for the k-th kid is more \\n            // than the best found case already => no value of checking it further\\n            if (newSum < minUnfairness) {\\n                distribution.set(n, newSum)\\n                dfs(i + 1)\\n                distribution.set(n, (distribution.get(n) || 0) - cookies[i])\\n            }\\n        }\\n    }\\n\\n    dfs(0)\\n\\n    return minUnfairness\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} cookies\\n * @param {number} k\\n * @return {number}\\n */\\nvar distributeCookies = function (cookies, k) {\\n    // distribution[k] - sum of cookies get by a k-th child\\n    const distribution = new Map()\\n\\n    // the minimum unfairness of all distributions\\n    let minUnfairness = Infinity\\n\\n    const dfs = (i) => {\\n        // i - index of a cookies we are going to distribute\\n\\n        // if i == cookies.length - calculate an unfairness for the current distibution \\n        if (i == cookies.length) {\\n            let unfairness = 0\\n            for (let n = 1; n <= k; n++) {\\n                unfairness = Math.max(unfairness, (distribution.get(n) || 0))\\n            }\\n            minUnfairness = Math.min(minUnfairness, unfairness)\\n            return\\n        }\\n\\n        // iterate over all children and distibute the current i-th cookie\\n        for (let n = 1; n <= k; n++) {\\n            let newSum = (distribution.get(n) || 0) + cookies[i]\\n            // if the total cookies for the k-th kid is more \\n            // than the best found case already => no value of checking it further\\n            if (newSum < minUnfairness) {\\n                distribution.set(n, newSum)\\n                dfs(i + 1)\\n                distribution.set(n, (distribution.get(n) || 0) - cookies[i])\\n            }\\n        }\\n    }\\n\\n    dfs(0)\\n\\n    return minUnfairness\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3702384,
                "title": "java-solution-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int ans; // Variable to store the minimum maximum number of cookies distributed\\n    int count[]; // Array to keep track of the number of cookies each child has\\n\\n    public int distributeCookies(int[] cookies, int k) {\\n        ans = Integer.MAX_VALUE;\\n        count = new int[k];\\n\\n        backtrack(0, cookies, k); // Start the backtracking process\\n        return ans;\\n    }\\n\\n    public void backtrack(int cookieNumber, int[] cookies, int k) {\\n        if (cookieNumber == cookies.length) {\\n            int max = 0;\\n            for (int i = 0; i < k; i++) {\\n                max = Math.max(max, count[i]); // Find the maximum number of cookies given to any child\\n            }\\n            ans = Math.min(ans, max); // Update the minimum maximum number of cookies distributed\\n            return;\\n        }\\n        for (int i = 0; i < k; i++) {\\n            count[i] += cookies[cookieNumber]; // Give the current cookie to the i-th child\\n            backtrack(cookieNumber + 1, cookies, k); // Recursively distribute the remaining cookies\\n            count[i] -= cookies[cookieNumber]; // Backtrack: take back the cookie from the i-th child\\n            if (count[i] == 0)\\n                break; // Optimization: If a child has no cookies, no need to continue distributing\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int ans; // Variable to store the minimum maximum number of cookies distributed\\n    int count[]; // Array to keep track of the number of cookies each child has\\n\\n    public int distributeCookies(int[] cookies, int k) {\\n        ans = Integer.MAX_VALUE;\\n        count = new int[k];\\n\\n        backtrack(0, cookies, k); // Start the backtracking process\\n        return ans;\\n    }\\n\\n    public void backtrack(int cookieNumber, int[] cookies, int k) {\\n        if (cookieNumber == cookies.length) {\\n            int max = 0;\\n            for (int i = 0; i < k; i++) {\\n                max = Math.max(max, count[i]); // Find the maximum number of cookies given to any child\\n            }\\n            ans = Math.min(ans, max); // Update the minimum maximum number of cookies distributed\\n            return;\\n        }\\n        for (int i = 0; i < k; i++) {\\n            count[i] += cookies[cookieNumber]; // Give the current cookie to the i-th child\\n            backtrack(cookieNumber + 1, cookies, k); // Recursively distribute the remaining cookies\\n            count[i] -= cookies[cookieNumber]; // Backtrack: take back the cookie from the i-th child\\n            if (count[i] == 0)\\n                break; // Optimization: If a child has no cookies, no need to continue distributing\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702376,
                "title": "simple-c-solution-backtracking-array-recursion",
                "content": "[https://youtu.be/4Pd8bwOOk9w](https://youtu.be/4Pd8bwOOk9w)\\n\\n# Intuition\\nFor each of the cookies we have ```k``` options. So we can use backtracking for each cookies.\\n\\n# Approach\\n1. Let\\'s have a ```vector<int> kids``` which will store the number of cookies given to k kids.\\n2. Also we have a variable ```int ans=INT_MAX``` which will be returned as final answer.\\n3. Now take a void recursive function in which we will give cookies to ith kid and will minimize the maximum number of cookies given to a particular kid for each case.\\n4. In recursive function:\\n    1. In base case: If we distributed all our cookies packed, then we will find the maximum cookies given to a kid and then we minimize this maximum value for all cases.\\n    2. In main cases: We will iterate over all kids and increase the value of ith kid by ```cookies[ind]``` and will again run fuction recursively. After that we will do backtracking which means we will reduce the value of ith kid by ```cookies[ind]```.\\n5. Finally we will return our ```ans```\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^k)$$\\n\\n- Space complexity:\\n$$O(k)$$\\n\\n    **Please upvote if you liked it !!!**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int ind,vector<int>&cookies,vector<int>&kids,int &ans){\\n        if(ind==cookies.size()){\\n            int ans1=0;\\n            for(auto ele:kids){\\n                ans1=max(ans1,ele);\\n            }\\n            ans=min(ans1,ans);\\n            return;\\n        }\\n        for(int i=0;i<kids.size();i++){\\n            kids[i]+=cookies[ind];\\n            solve(ind+1,cookies,kids,ans);\\n            kids[i]-=cookies[ind];\\n        }\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        vector<int>kids(k,0);\\n        int ans=INT_MAX;\\n        int ind=0;\\n        solve(ind,cookies,kids,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```k```\n```vector<int> kids```\n```int ans=INT_MAX```\n```cookies[ind]```\n```cookies[ind]```\n```ans```\n```\\nclass Solution {\\npublic:\\n    void solve(int ind,vector<int>&cookies,vector<int>&kids,int &ans){\\n        if(ind==cookies.size()){\\n            int ans1=0;\\n            for(auto ele:kids){\\n                ans1=max(ans1,ele);\\n            }\\n            ans=min(ans1,ans);\\n            return;\\n        }\\n        for(int i=0;i<kids.size();i++){\\n            kids[i]+=cookies[ind];\\n            solve(ind+1,cookies,kids,ans);\\n            kids[i]-=cookies[ind];\\n        }\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        vector<int>kids(k,0);\\n        int ans=INT_MAX;\\n        int ind=0;\\n        solve(ind,cookies,kids,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702333,
                "title": "very-easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans = INT_MAX;\\n    void solve(vector<int>& c, int k,vector<int>& b, int i){\\n        if(i == c.size()){\\n            int mini = INT_MIN;\\n            for(int i = 0;i<k;i++){\\n                mini = max(mini,b[i]);\\n            }\\n\\n            ans = min(mini,ans);\\n            return;\\n        }\\n\\n        for(int j = 0;j<k;j++){\\n            b[j] += c[i];\\n            solve(c,k,b,i+1);\\n            b[j] -= c[i];\\n        }\\n    }\\n\\n    int distributeCookies(vector<int>& c, int k) {\\n        vector<int>b(k,0);\\n        solve(c,k,b,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = INT_MAX;\\n    void solve(vector<int>& c, int k,vector<int>& b, int i){\\n        if(i == c.size()){\\n            int mini = INT_MIN;\\n            for(int i = 0;i<k;i++){\\n                mini = max(mini,b[i]);\\n            }\\n\\n            ans = min(mini,ans);\\n            return;\\n        }\\n\\n        for(int j = 0;j<k;j++){\\n            b[j] += c[i];\\n            solve(c,k,b,i+1);\\n            b[j] -= c[i];\\n        }\\n    }\\n\\n    int distributeCookies(vector<int>& c, int k) {\\n        vector<int>b(k,0);\\n        solve(c,k,b,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702293,
                "title": "c-solution-memoization",
                "content": "\\n\\n- Space complexity: O(n*k^n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distributeCookies(vector<int>& cookies, int k) {\\n          int n = cookies.size();\\n        int res = INT_MAX;\\n        map<pair<int, vector<vector<int>>>, int> memo;\\n        function<void(int, vector<vector<int>>)> dfs = [&](int i, vector<vector<int>> dist) {\\n            if (i == n) {\\n                if (dist.size() == k) {\\n                    int max_cookies = 0;\\n                    for (auto& bags : dist) {\\n                        max_cookies = max(max_cookies, accumulate(bags.begin(), bags.end(), 0));\\n                    }\\n                    res = min(res, max_cookies);\\n                }\\n                return;\\n            }\\n            pair<int, vector<vector<int>>> key = {i, dist};\\n            if (memo.count(key)) return;\\n            for (int j = 0; j < dist.size(); j++) {\\n                dist[j].push_back(cookies[i]);\\n                dfs(i + 1, dist);\\n                dist[j].pop_back();\\n            }\\n            if (dist.size() < k) {\\n                dist.push_back({cookies[i]});\\n                dfs(i + 1, dist);\\n                dist.pop_back();\\n            }\\n            memo[key] = res;\\n        };\\n        dfs(0, {});\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distributeCookies(vector<int>& cookies, int k) {\\n          int n = cookies.size();\\n        int res = INT_MAX;\\n        map<pair<int, vector<vector<int>>>, int> memo;\\n        function<void(int, vector<vector<int>>)> dfs = [&](int i, vector<vector<int>> dist) {\\n            if (i == n) {\\n                if (dist.size() == k) {\\n                    int max_cookies = 0;\\n                    for (auto& bags : dist) {\\n                        max_cookies = max(max_cookies, accumulate(bags.begin(), bags.end(), 0));\\n                    }\\n                    res = min(res, max_cookies);\\n                }\\n                return;\\n            }\\n            pair<int, vector<vector<int>>> key = {i, dist};\\n            if (memo.count(key)) return;\\n            for (int j = 0; j < dist.size(); j++) {\\n                dist[j].push_back(cookies[i]);\\n                dfs(i + 1, dist);\\n                dist[j].pop_back();\\n            }\\n            if (dist.size() < k) {\\n                dist.push_back({cookies[i]});\\n                dfs(i + 1, dist);\\n                dist.pop_back();\\n            }\\n            memo[key] = res;\\n        };\\n        dfs(0, {});\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702247,
                "title": "c-backtracking-o-n-n-explained",
                "content": "# Approach\\n1. By looking at constraints we can think of backtrack solution.\\n2. In backtrack we try giving bag of cookies to one of children and when all bags are ditributed (i.e. end of array), we can update our answer.\\n3. As we need to minimize answer we take minimum of last answer and current maximum value(i.e. unfairness in current distribution).\\n\\n# Complexity\\n- Time complexity: O(n^n)\\n\\n- Space complexity: O(k)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void backtrack(vector<int>& cookies,vector<int>& children,int i,int n,int k,int& ans){\\n        if(i>=n){ \\n            // When all bags are distributes we update \\n            // our answer with maximum value of current distribution\\n            ans=min(ans,*max_element(children.begin(),children.end())); \\n        }else{\\n            // For current bag we will try giving it to each of kids\\n            // And then use backtrack\\n            for(int j=0; j<k; j++){\\n                children[j]+=cookies[i];\\n                backtrack(cookies,children,i+1,n,k,ans);\\n                children[j]-=cookies[i];\\n            }\\n        }\\n    }\\n    \\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int n=cookies.size(),ans=INT_MAX; \\n        // Initial unfairness is set to Maximum\\n        vector<int> children(k,0); \\n        // Array to store count of cookies given to each children\\n        // Initially set to 0\\n        backtrack(cookies,children,0,n,k,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void backtrack(vector<int>& cookies,vector<int>& children,int i,int n,int k,int& ans){\\n        if(i>=n){ \\n            // When all bags are distributes we update \\n            // our answer with maximum value of current distribution\\n            ans=min(ans,*max_element(children.begin(),children.end())); \\n        }else{\\n            // For current bag we will try giving it to each of kids\\n            // And then use backtrack\\n            for(int j=0; j<k; j++){\\n                children[j]+=cookies[i];\\n                backtrack(cookies,children,i+1,n,k,ans);\\n                children[j]-=cookies[i];\\n            }\\n        }\\n    }\\n    \\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int n=cookies.size(),ans=INT_MAX; \\n        // Initial unfairness is set to Maximum\\n        vector<int> children(k,0); \\n        // Array to store count of cookies given to each children\\n        // Initially set to 0\\n        backtrack(cookies,children,0,n,k,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1951000,
                "content": [
                    {
                        "username": "JerExplosion",
                        "content": "We should teach the kids that the world is not always fair "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "Prolly should teach them how to build guillotines too. "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> The unfairness of a distribution is defined as the maximum total cookies obtained by a single child in the distribution.\n\nThe most fair (and satisfying) distribution then would be to eat all the cookies yourself."
                    },
                    {
                        "username": "emilmohan24",
                        "content": "O(1) solution. Absolute genius. "
                    },
                    {
                        "username": "Stewie-Griffin",
                        "content": "I mean i can\\'t help to understand that why is it not of binary search  , its language is similar to most of binary search problems."
                    },
                    {
                        "username": "utkarshinobi",
                        "content": "[@vishalkgupta9821](/vishalkgupta9821) Thanks a lot! This was extremely helpful."
                    },
                    {
                        "username": "vishalkgupta9821",
                        "content": "we can solve this problem using binary search like problem 1011. Capacity To Ship Packages Within D Days\\nbut we need to generate all possible permutation of array in order to check unfairness.\\n\\n\\n//fist find the max in min like book allocation \\n    //repeat the process for all permutation\\n    bool ispossible(vector<int>&arr,int k,int mid){\\n        int count=1;\\n        int sum=0;\\n        for(auto  n:arr){\\n            sum+=n;\\n            if(sum>mid){\\n                count++;\\n                sum=n;\\n            }\\n        }\\n        return count<=k;\\n    }\\n\\n    int findMinMax(vector<int>&arr,int k){\\n        int low=0;\\n        int high=0;\\n        for(auto a:arr){\\n            low=max(a,low);\\n            high+=a;\\n        }\\n\\n        int ans=high;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(ispossible(arr,k,mid)){\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int ans=INT_MAX;\\n        sort(cookies.begin(),cookies.end());\\n        do{\\n            ans=min(ans,findMinMax(cookies,k));\\n        }while(next_permutation(cookies.begin(),cookies.end()));\\n\\n        return ans;\\n    }\\n\\n\\n"
                    },
                    {
                        "username": "user7717f",
                        "content": "We can use binary search in this problem to do the pruning by finding the upper bound in searching.\n\n```java\nclass Solution {\n    public int distributeCookies(int[] cookies, int k) {\n        Arrays.sort(cookies);\n        \n        int n = cookies.length, lb = cookies[n - 1], rb = cookies[n - 1] * n, ans = -1;\n        while (lb <= rb) {\n            int mb = lb + rb >> 1;\n\n            if (dfs(cookies, 0, new int[k], mb)) {\n                ans = mb;\n                rb = mb - 1;\n            }else {\n                lb = mb + 1;\n            }\n        }\n\n        return ans;\n    }\n\n    private boolean dfs(int[] cookies, int start, int[] nums, int mb) {\n        if (start == cookies.length) {\n            return true;\n        }\n\n        for (int i = 0; i < nums.length; ++i) {\n            if (nums[i] + cookies[start] <= mb) {\n                nums[i] += cookies[start];\n                if (dfs(cookies, start + 1, nums, mb)) {\n                    return true;\n                }\n                nums[i] -= cookies[start];\n            }\n            if (nums[i] == 0) {\n                return false;\n            }\n        }\n\n        return false;\n    }\n}\n```"
                    },
                    {
                        "username": "srk696772",
                        "content": "Because All the Problems we solved on binary Search Mentions Consecutiveness In the Description , But In The Above There is no Constraint on Consecutive Distribution so we cannot apply binary search here."
                    },
                    {
                        "username": "lalit10368",
                        "content": "[@akamboj](/akamboj) Thanks! for that justification. Hence, no boundary to search here."
                    },
                    {
                        "username": "lalit10368",
                        "content": "Hmm, I had a similar thought while solving. But I don\\'t know how to apply binary search over this. The constraints suggested brute force algorithm should work here. That\\'s why, I simply used bitmask & backtracking. Much easier than working out the binary search here."
                    },
                    {
                        "username": "akamboj",
                        "content": "because there is no contiguous allocation."
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "it's been  45+ minutes trying to solve this problem.. Am I dumb or most of the people are facing the same issue?"
                    },
                    {
                        "username": "emilmohan24",
                        "content": "Bro it takes me days sometimes lol\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "really struggling right now"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Brute force solution works"
                    },
                    {
                        "username": "akshatmaheshwar78",
                        "content": "Yah mate, this was hurting my brain until I took my paper and pen."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "[@longb1997](/longb1997) eveyones dumb mate until the same questions drops in interview"
                    },
                    {
                        "username": "longb1997",
                        "content": "i don't even think about backtracking\ni'm suck :((("
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "[@void_8t](/void_8t)  fr..."
                    },
                    {
                        "username": "meow_power",
                        "content": "you are not alone:("
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Who else thought it was binary search and then realized that the distribution is not contagious \\uD83D\\uDE22"
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This can be cone using binary search\\n\\n\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n\\n        def canDistribute(mid):\\n            children = [0] * k\\n            return assignCookies(0, mid, children)\\n        \\n        def assignCookies(index, mid, children):\\n            if index == len(cookies):\\n                return True\\n            curCookie = cookies[index]\\n            for i in range(k):\\n                if children[i] + curCookie <= mid:\\n                    children[i] += curCookie\\n                    if assignCookies(index + 1, mid, children):\\n                        return True\\n                    children[i] -= curCookie\\n                # If the child hasn\\'t been given any cookie, we break to avoid redundancies.\\n                if children[i] == 0:\\n                    break\\n            return False\\n        \\n        # Set the binary search range\\n        low, high = max(cookies), sum(cookies)\\n        while low < high:\\n            mid = (low + high) // 2\\n            if canDistribute(mid):\\n                high = mid\\n            else:\\n                low = mid + 1\\n\\n        return low\\n"
                    },
                    {
                        "username": "mt790191",
                        "content": "can u please elaborate what do you  mean by  distribution is not contagious and how it effects the solution"
                    },
                    {
                        "username": "_Aman_13_",
                        "content": "I not only thought but also code the BS solution, and also it accepted for 34 test cases. After that I realized that it will not work \\uD83D\\uDE2D"
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "also if it would have binary search question then array size also would have 1e5"
                    },
                    {
                        "username": "Jaiff",
                        "content": "*contiguous"
                    },
                    {
                        "username": "bortengineer",
                        "content": "Time limits for Python are too harsh (as always). Exact same naive backtracking solution that is good enough for c++ is no good for python, so you have to do additional optimizations."
                    },
                    {
                        "username": "dz_adman",
                        "content": "[@cswartzell](/cswartzell) I stand with the argument that equivalent solutions in any language should be acceptable. On the other hand, the fact that python is less efficient, is independent of how leetcode treat any language\\'s code."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@dz_adman](/dz_adman) That is meaningless. The point is that equivalent solutions for each language should be acceptable for each language, regardless of the time required to compute that solution IN the given language. The Time Limits are different for each language as is. \n\nAn equivalent Python solution to a passing C++ solution should absolutely count as valid"
                    },
                    {
                        "username": "dz_adman",
                        "content": "[python is less efficient](https://thenextweb.com/news/python-progamming-language-energy-analysis) than many other languages."
                    },
                    {
                        "username": "stefan1096",
                        "content": "I got TLE in Python3 but beats 56% in C++ with the same code(it only passed after an optimization)."
                    },
                    {
                        "username": "PencilBro27",
                        "content": "This problem is the same as\\n[1723. Find Minimum Time to Finish All Jobs](https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/description/)"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "https://leetcode.com/problems/matchsticks-to-square/\\nhttps://leetcode.com/problems/partition-to-k-equal-sum-subsets/\\nThese Two also Similar"
                    },
                    {
                        "username": "jason3410",
                        "content": "That\\'s a bit harder but still thx for the information."
                    },
                    {
                        "username": "AnywaySo",
                        "content": "Thank you, another problem was accepted."
                    },
                    {
                        "username": "charonme",
                        "content": "although 1723 has stricter time limits"
                    },
                    {
                        "username": "psionl0",
                        "content": "I hate backtracking. It is one of the few areas in algorithms that I can\\'t seem to master.\\n\\nAnd a sloppily worded editorial didn\\'t help. It took me 10 minutes to figure out that they said \"cookie\" they weren\\'t talking about an individual cookie but a bag of cookies."
                    },
                    {
                        "username": "cswartzell",
                        "content": "For me, its not that I cant master backtracking. The actual backtracking algo is almost silly trivial: Do a task, backtrack and undo it, redo the task a different way such that every combination is covered. The problem for me is recognizing: \"we are just going to have to try every combination. No greedy algorthim is going to shortcut these trials. Maybe there is some pruning we can do to early exit a trial branch, but effectively we need to check every branch\"\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "Me too, if it were single cookies, the question is much simpler. If it were single cookies, we would not need an array, we would just be given the total number of cookies. \\n\\nI still haven\\'t solved it."
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "Can anyone explain what do you all mean by saying there\\'s no continuous allocation?\\n"
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "[@JaAt_BhOi](/JaAt_BhOi) from the cookies array we can select cookies[i] in any order(random) need not be contiguous sub array....."
                    },
                    {
                        "username": "y-not",
                        "content": "Java Video Solution - \\nhttps://www.youtube.com/watch?v=kYQ5jXXhWYE"
                    }
                ]
            },
            {
                "id": 1951077,
                "content": [
                    {
                        "username": "JerExplosion",
                        "content": "We should teach the kids that the world is not always fair "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "Prolly should teach them how to build guillotines too. "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> The unfairness of a distribution is defined as the maximum total cookies obtained by a single child in the distribution.\n\nThe most fair (and satisfying) distribution then would be to eat all the cookies yourself."
                    },
                    {
                        "username": "emilmohan24",
                        "content": "O(1) solution. Absolute genius. "
                    },
                    {
                        "username": "Stewie-Griffin",
                        "content": "I mean i can\\'t help to understand that why is it not of binary search  , its language is similar to most of binary search problems."
                    },
                    {
                        "username": "utkarshinobi",
                        "content": "[@vishalkgupta9821](/vishalkgupta9821) Thanks a lot! This was extremely helpful."
                    },
                    {
                        "username": "vishalkgupta9821",
                        "content": "we can solve this problem using binary search like problem 1011. Capacity To Ship Packages Within D Days\\nbut we need to generate all possible permutation of array in order to check unfairness.\\n\\n\\n//fist find the max in min like book allocation \\n    //repeat the process for all permutation\\n    bool ispossible(vector<int>&arr,int k,int mid){\\n        int count=1;\\n        int sum=0;\\n        for(auto  n:arr){\\n            sum+=n;\\n            if(sum>mid){\\n                count++;\\n                sum=n;\\n            }\\n        }\\n        return count<=k;\\n    }\\n\\n    int findMinMax(vector<int>&arr,int k){\\n        int low=0;\\n        int high=0;\\n        for(auto a:arr){\\n            low=max(a,low);\\n            high+=a;\\n        }\\n\\n        int ans=high;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(ispossible(arr,k,mid)){\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int ans=INT_MAX;\\n        sort(cookies.begin(),cookies.end());\\n        do{\\n            ans=min(ans,findMinMax(cookies,k));\\n        }while(next_permutation(cookies.begin(),cookies.end()));\\n\\n        return ans;\\n    }\\n\\n\\n"
                    },
                    {
                        "username": "user7717f",
                        "content": "We can use binary search in this problem to do the pruning by finding the upper bound in searching.\n\n```java\nclass Solution {\n    public int distributeCookies(int[] cookies, int k) {\n        Arrays.sort(cookies);\n        \n        int n = cookies.length, lb = cookies[n - 1], rb = cookies[n - 1] * n, ans = -1;\n        while (lb <= rb) {\n            int mb = lb + rb >> 1;\n\n            if (dfs(cookies, 0, new int[k], mb)) {\n                ans = mb;\n                rb = mb - 1;\n            }else {\n                lb = mb + 1;\n            }\n        }\n\n        return ans;\n    }\n\n    private boolean dfs(int[] cookies, int start, int[] nums, int mb) {\n        if (start == cookies.length) {\n            return true;\n        }\n\n        for (int i = 0; i < nums.length; ++i) {\n            if (nums[i] + cookies[start] <= mb) {\n                nums[i] += cookies[start];\n                if (dfs(cookies, start + 1, nums, mb)) {\n                    return true;\n                }\n                nums[i] -= cookies[start];\n            }\n            if (nums[i] == 0) {\n                return false;\n            }\n        }\n\n        return false;\n    }\n}\n```"
                    },
                    {
                        "username": "srk696772",
                        "content": "Because All the Problems we solved on binary Search Mentions Consecutiveness In the Description , But In The Above There is no Constraint on Consecutive Distribution so we cannot apply binary search here."
                    },
                    {
                        "username": "lalit10368",
                        "content": "[@akamboj](/akamboj) Thanks! for that justification. Hence, no boundary to search here."
                    },
                    {
                        "username": "lalit10368",
                        "content": "Hmm, I had a similar thought while solving. But I don\\'t know how to apply binary search over this. The constraints suggested brute force algorithm should work here. That\\'s why, I simply used bitmask & backtracking. Much easier than working out the binary search here."
                    },
                    {
                        "username": "akamboj",
                        "content": "because there is no contiguous allocation."
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "it's been  45+ minutes trying to solve this problem.. Am I dumb or most of the people are facing the same issue?"
                    },
                    {
                        "username": "emilmohan24",
                        "content": "Bro it takes me days sometimes lol\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "really struggling right now"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Brute force solution works"
                    },
                    {
                        "username": "akshatmaheshwar78",
                        "content": "Yah mate, this was hurting my brain until I took my paper and pen."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "[@longb1997](/longb1997) eveyones dumb mate until the same questions drops in interview"
                    },
                    {
                        "username": "longb1997",
                        "content": "i don't even think about backtracking\ni'm suck :((("
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "[@void_8t](/void_8t)  fr..."
                    },
                    {
                        "username": "meow_power",
                        "content": "you are not alone:("
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Who else thought it was binary search and then realized that the distribution is not contagious \\uD83D\\uDE22"
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This can be cone using binary search\\n\\n\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n\\n        def canDistribute(mid):\\n            children = [0] * k\\n            return assignCookies(0, mid, children)\\n        \\n        def assignCookies(index, mid, children):\\n            if index == len(cookies):\\n                return True\\n            curCookie = cookies[index]\\n            for i in range(k):\\n                if children[i] + curCookie <= mid:\\n                    children[i] += curCookie\\n                    if assignCookies(index + 1, mid, children):\\n                        return True\\n                    children[i] -= curCookie\\n                # If the child hasn\\'t been given any cookie, we break to avoid redundancies.\\n                if children[i] == 0:\\n                    break\\n            return False\\n        \\n        # Set the binary search range\\n        low, high = max(cookies), sum(cookies)\\n        while low < high:\\n            mid = (low + high) // 2\\n            if canDistribute(mid):\\n                high = mid\\n            else:\\n                low = mid + 1\\n\\n        return low\\n"
                    },
                    {
                        "username": "mt790191",
                        "content": "can u please elaborate what do you  mean by  distribution is not contagious and how it effects the solution"
                    },
                    {
                        "username": "_Aman_13_",
                        "content": "I not only thought but also code the BS solution, and also it accepted for 34 test cases. After that I realized that it will not work \\uD83D\\uDE2D"
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "also if it would have binary search question then array size also would have 1e5"
                    },
                    {
                        "username": "Jaiff",
                        "content": "*contiguous"
                    },
                    {
                        "username": "bortengineer",
                        "content": "Time limits for Python are too harsh (as always). Exact same naive backtracking solution that is good enough for c++ is no good for python, so you have to do additional optimizations."
                    },
                    {
                        "username": "dz_adman",
                        "content": "[@cswartzell](/cswartzell) I stand with the argument that equivalent solutions in any language should be acceptable. On the other hand, the fact that python is less efficient, is independent of how leetcode treat any language\\'s code."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@dz_adman](/dz_adman) That is meaningless. The point is that equivalent solutions for each language should be acceptable for each language, regardless of the time required to compute that solution IN the given language. The Time Limits are different for each language as is. \n\nAn equivalent Python solution to a passing C++ solution should absolutely count as valid"
                    },
                    {
                        "username": "dz_adman",
                        "content": "[python is less efficient](https://thenextweb.com/news/python-progamming-language-energy-analysis) than many other languages."
                    },
                    {
                        "username": "stefan1096",
                        "content": "I got TLE in Python3 but beats 56% in C++ with the same code(it only passed after an optimization)."
                    },
                    {
                        "username": "PencilBro27",
                        "content": "This problem is the same as\\n[1723. Find Minimum Time to Finish All Jobs](https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/description/)"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "https://leetcode.com/problems/matchsticks-to-square/\\nhttps://leetcode.com/problems/partition-to-k-equal-sum-subsets/\\nThese Two also Similar"
                    },
                    {
                        "username": "jason3410",
                        "content": "That\\'s a bit harder but still thx for the information."
                    },
                    {
                        "username": "AnywaySo",
                        "content": "Thank you, another problem was accepted."
                    },
                    {
                        "username": "charonme",
                        "content": "although 1723 has stricter time limits"
                    },
                    {
                        "username": "psionl0",
                        "content": "I hate backtracking. It is one of the few areas in algorithms that I can\\'t seem to master.\\n\\nAnd a sloppily worded editorial didn\\'t help. It took me 10 minutes to figure out that they said \"cookie\" they weren\\'t talking about an individual cookie but a bag of cookies."
                    },
                    {
                        "username": "cswartzell",
                        "content": "For me, its not that I cant master backtracking. The actual backtracking algo is almost silly trivial: Do a task, backtrack and undo it, redo the task a different way such that every combination is covered. The problem for me is recognizing: \"we are just going to have to try every combination. No greedy algorthim is going to shortcut these trials. Maybe there is some pruning we can do to early exit a trial branch, but effectively we need to check every branch\"\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "Me too, if it were single cookies, the question is much simpler. If it were single cookies, we would not need an array, we would just be given the total number of cookies. \\n\\nI still haven\\'t solved it."
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "Can anyone explain what do you all mean by saying there\\'s no continuous allocation?\\n"
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "[@JaAt_BhOi](/JaAt_BhOi) from the cookies array we can select cookies[i] in any order(random) need not be contiguous sub array....."
                    },
                    {
                        "username": "y-not",
                        "content": "Java Video Solution - \\nhttps://www.youtube.com/watch?v=kYQ5jXXhWYE"
                    }
                ]
            },
            {
                "id": 1576890,
                "content": [
                    {
                        "username": "JerExplosion",
                        "content": "We should teach the kids that the world is not always fair "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "Prolly should teach them how to build guillotines too. "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> The unfairness of a distribution is defined as the maximum total cookies obtained by a single child in the distribution.\n\nThe most fair (and satisfying) distribution then would be to eat all the cookies yourself."
                    },
                    {
                        "username": "emilmohan24",
                        "content": "O(1) solution. Absolute genius. "
                    },
                    {
                        "username": "Stewie-Griffin",
                        "content": "I mean i can\\'t help to understand that why is it not of binary search  , its language is similar to most of binary search problems."
                    },
                    {
                        "username": "utkarshinobi",
                        "content": "[@vishalkgupta9821](/vishalkgupta9821) Thanks a lot! This was extremely helpful."
                    },
                    {
                        "username": "vishalkgupta9821",
                        "content": "we can solve this problem using binary search like problem 1011. Capacity To Ship Packages Within D Days\\nbut we need to generate all possible permutation of array in order to check unfairness.\\n\\n\\n//fist find the max in min like book allocation \\n    //repeat the process for all permutation\\n    bool ispossible(vector<int>&arr,int k,int mid){\\n        int count=1;\\n        int sum=0;\\n        for(auto  n:arr){\\n            sum+=n;\\n            if(sum>mid){\\n                count++;\\n                sum=n;\\n            }\\n        }\\n        return count<=k;\\n    }\\n\\n    int findMinMax(vector<int>&arr,int k){\\n        int low=0;\\n        int high=0;\\n        for(auto a:arr){\\n            low=max(a,low);\\n            high+=a;\\n        }\\n\\n        int ans=high;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(ispossible(arr,k,mid)){\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int ans=INT_MAX;\\n        sort(cookies.begin(),cookies.end());\\n        do{\\n            ans=min(ans,findMinMax(cookies,k));\\n        }while(next_permutation(cookies.begin(),cookies.end()));\\n\\n        return ans;\\n    }\\n\\n\\n"
                    },
                    {
                        "username": "user7717f",
                        "content": "We can use binary search in this problem to do the pruning by finding the upper bound in searching.\n\n```java\nclass Solution {\n    public int distributeCookies(int[] cookies, int k) {\n        Arrays.sort(cookies);\n        \n        int n = cookies.length, lb = cookies[n - 1], rb = cookies[n - 1] * n, ans = -1;\n        while (lb <= rb) {\n            int mb = lb + rb >> 1;\n\n            if (dfs(cookies, 0, new int[k], mb)) {\n                ans = mb;\n                rb = mb - 1;\n            }else {\n                lb = mb + 1;\n            }\n        }\n\n        return ans;\n    }\n\n    private boolean dfs(int[] cookies, int start, int[] nums, int mb) {\n        if (start == cookies.length) {\n            return true;\n        }\n\n        for (int i = 0; i < nums.length; ++i) {\n            if (nums[i] + cookies[start] <= mb) {\n                nums[i] += cookies[start];\n                if (dfs(cookies, start + 1, nums, mb)) {\n                    return true;\n                }\n                nums[i] -= cookies[start];\n            }\n            if (nums[i] == 0) {\n                return false;\n            }\n        }\n\n        return false;\n    }\n}\n```"
                    },
                    {
                        "username": "srk696772",
                        "content": "Because All the Problems we solved on binary Search Mentions Consecutiveness In the Description , But In The Above There is no Constraint on Consecutive Distribution so we cannot apply binary search here."
                    },
                    {
                        "username": "lalit10368",
                        "content": "[@akamboj](/akamboj) Thanks! for that justification. Hence, no boundary to search here."
                    },
                    {
                        "username": "lalit10368",
                        "content": "Hmm, I had a similar thought while solving. But I don\\'t know how to apply binary search over this. The constraints suggested brute force algorithm should work here. That\\'s why, I simply used bitmask & backtracking. Much easier than working out the binary search here."
                    },
                    {
                        "username": "akamboj",
                        "content": "because there is no contiguous allocation."
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "it's been  45+ minutes trying to solve this problem.. Am I dumb or most of the people are facing the same issue?"
                    },
                    {
                        "username": "emilmohan24",
                        "content": "Bro it takes me days sometimes lol\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "really struggling right now"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Brute force solution works"
                    },
                    {
                        "username": "akshatmaheshwar78",
                        "content": "Yah mate, this was hurting my brain until I took my paper and pen."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "[@longb1997](/longb1997) eveyones dumb mate until the same questions drops in interview"
                    },
                    {
                        "username": "longb1997",
                        "content": "i don't even think about backtracking\ni'm suck :((("
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "[@void_8t](/void_8t)  fr..."
                    },
                    {
                        "username": "meow_power",
                        "content": "you are not alone:("
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Who else thought it was binary search and then realized that the distribution is not contagious \\uD83D\\uDE22"
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This can be cone using binary search\\n\\n\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n\\n        def canDistribute(mid):\\n            children = [0] * k\\n            return assignCookies(0, mid, children)\\n        \\n        def assignCookies(index, mid, children):\\n            if index == len(cookies):\\n                return True\\n            curCookie = cookies[index]\\n            for i in range(k):\\n                if children[i] + curCookie <= mid:\\n                    children[i] += curCookie\\n                    if assignCookies(index + 1, mid, children):\\n                        return True\\n                    children[i] -= curCookie\\n                # If the child hasn\\'t been given any cookie, we break to avoid redundancies.\\n                if children[i] == 0:\\n                    break\\n            return False\\n        \\n        # Set the binary search range\\n        low, high = max(cookies), sum(cookies)\\n        while low < high:\\n            mid = (low + high) // 2\\n            if canDistribute(mid):\\n                high = mid\\n            else:\\n                low = mid + 1\\n\\n        return low\\n"
                    },
                    {
                        "username": "mt790191",
                        "content": "can u please elaborate what do you  mean by  distribution is not contagious and how it effects the solution"
                    },
                    {
                        "username": "_Aman_13_",
                        "content": "I not only thought but also code the BS solution, and also it accepted for 34 test cases. After that I realized that it will not work \\uD83D\\uDE2D"
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "also if it would have binary search question then array size also would have 1e5"
                    },
                    {
                        "username": "Jaiff",
                        "content": "*contiguous"
                    },
                    {
                        "username": "bortengineer",
                        "content": "Time limits for Python are too harsh (as always). Exact same naive backtracking solution that is good enough for c++ is no good for python, so you have to do additional optimizations."
                    },
                    {
                        "username": "dz_adman",
                        "content": "[@cswartzell](/cswartzell) I stand with the argument that equivalent solutions in any language should be acceptable. On the other hand, the fact that python is less efficient, is independent of how leetcode treat any language\\'s code."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@dz_adman](/dz_adman) That is meaningless. The point is that equivalent solutions for each language should be acceptable for each language, regardless of the time required to compute that solution IN the given language. The Time Limits are different for each language as is. \n\nAn equivalent Python solution to a passing C++ solution should absolutely count as valid"
                    },
                    {
                        "username": "dz_adman",
                        "content": "[python is less efficient](https://thenextweb.com/news/python-progamming-language-energy-analysis) than many other languages."
                    },
                    {
                        "username": "stefan1096",
                        "content": "I got TLE in Python3 but beats 56% in C++ with the same code(it only passed after an optimization)."
                    },
                    {
                        "username": "PencilBro27",
                        "content": "This problem is the same as\\n[1723. Find Minimum Time to Finish All Jobs](https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/description/)"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "https://leetcode.com/problems/matchsticks-to-square/\\nhttps://leetcode.com/problems/partition-to-k-equal-sum-subsets/\\nThese Two also Similar"
                    },
                    {
                        "username": "jason3410",
                        "content": "That\\'s a bit harder but still thx for the information."
                    },
                    {
                        "username": "AnywaySo",
                        "content": "Thank you, another problem was accepted."
                    },
                    {
                        "username": "charonme",
                        "content": "although 1723 has stricter time limits"
                    },
                    {
                        "username": "psionl0",
                        "content": "I hate backtracking. It is one of the few areas in algorithms that I can\\'t seem to master.\\n\\nAnd a sloppily worded editorial didn\\'t help. It took me 10 minutes to figure out that they said \"cookie\" they weren\\'t talking about an individual cookie but a bag of cookies."
                    },
                    {
                        "username": "cswartzell",
                        "content": "For me, its not that I cant master backtracking. The actual backtracking algo is almost silly trivial: Do a task, backtrack and undo it, redo the task a different way such that every combination is covered. The problem for me is recognizing: \"we are just going to have to try every combination. No greedy algorthim is going to shortcut these trials. Maybe there is some pruning we can do to early exit a trial branch, but effectively we need to check every branch\"\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "Me too, if it were single cookies, the question is much simpler. If it were single cookies, we would not need an array, we would just be given the total number of cookies. \\n\\nI still haven\\'t solved it."
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "Can anyone explain what do you all mean by saying there\\'s no continuous allocation?\\n"
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "[@JaAt_BhOi](/JaAt_BhOi) from the cookies array we can select cookies[i] in any order(random) need not be contiguous sub array....."
                    },
                    {
                        "username": "y-not",
                        "content": "Java Video Solution - \\nhttps://www.youtube.com/watch?v=kYQ5jXXhWYE"
                    }
                ]
            },
            {
                "id": 1951220,
                "content": [
                    {
                        "username": "JerExplosion",
                        "content": "We should teach the kids that the world is not always fair "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "Prolly should teach them how to build guillotines too. "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> The unfairness of a distribution is defined as the maximum total cookies obtained by a single child in the distribution.\n\nThe most fair (and satisfying) distribution then would be to eat all the cookies yourself."
                    },
                    {
                        "username": "emilmohan24",
                        "content": "O(1) solution. Absolute genius. "
                    },
                    {
                        "username": "Stewie-Griffin",
                        "content": "I mean i can\\'t help to understand that why is it not of binary search  , its language is similar to most of binary search problems."
                    },
                    {
                        "username": "utkarshinobi",
                        "content": "[@vishalkgupta9821](/vishalkgupta9821) Thanks a lot! This was extremely helpful."
                    },
                    {
                        "username": "vishalkgupta9821",
                        "content": "we can solve this problem using binary search like problem 1011. Capacity To Ship Packages Within D Days\\nbut we need to generate all possible permutation of array in order to check unfairness.\\n\\n\\n//fist find the max in min like book allocation \\n    //repeat the process for all permutation\\n    bool ispossible(vector<int>&arr,int k,int mid){\\n        int count=1;\\n        int sum=0;\\n        for(auto  n:arr){\\n            sum+=n;\\n            if(sum>mid){\\n                count++;\\n                sum=n;\\n            }\\n        }\\n        return count<=k;\\n    }\\n\\n    int findMinMax(vector<int>&arr,int k){\\n        int low=0;\\n        int high=0;\\n        for(auto a:arr){\\n            low=max(a,low);\\n            high+=a;\\n        }\\n\\n        int ans=high;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(ispossible(arr,k,mid)){\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int ans=INT_MAX;\\n        sort(cookies.begin(),cookies.end());\\n        do{\\n            ans=min(ans,findMinMax(cookies,k));\\n        }while(next_permutation(cookies.begin(),cookies.end()));\\n\\n        return ans;\\n    }\\n\\n\\n"
                    },
                    {
                        "username": "user7717f",
                        "content": "We can use binary search in this problem to do the pruning by finding the upper bound in searching.\n\n```java\nclass Solution {\n    public int distributeCookies(int[] cookies, int k) {\n        Arrays.sort(cookies);\n        \n        int n = cookies.length, lb = cookies[n - 1], rb = cookies[n - 1] * n, ans = -1;\n        while (lb <= rb) {\n            int mb = lb + rb >> 1;\n\n            if (dfs(cookies, 0, new int[k], mb)) {\n                ans = mb;\n                rb = mb - 1;\n            }else {\n                lb = mb + 1;\n            }\n        }\n\n        return ans;\n    }\n\n    private boolean dfs(int[] cookies, int start, int[] nums, int mb) {\n        if (start == cookies.length) {\n            return true;\n        }\n\n        for (int i = 0; i < nums.length; ++i) {\n            if (nums[i] + cookies[start] <= mb) {\n                nums[i] += cookies[start];\n                if (dfs(cookies, start + 1, nums, mb)) {\n                    return true;\n                }\n                nums[i] -= cookies[start];\n            }\n            if (nums[i] == 0) {\n                return false;\n            }\n        }\n\n        return false;\n    }\n}\n```"
                    },
                    {
                        "username": "srk696772",
                        "content": "Because All the Problems we solved on binary Search Mentions Consecutiveness In the Description , But In The Above There is no Constraint on Consecutive Distribution so we cannot apply binary search here."
                    },
                    {
                        "username": "lalit10368",
                        "content": "[@akamboj](/akamboj) Thanks! for that justification. Hence, no boundary to search here."
                    },
                    {
                        "username": "lalit10368",
                        "content": "Hmm, I had a similar thought while solving. But I don\\'t know how to apply binary search over this. The constraints suggested brute force algorithm should work here. That\\'s why, I simply used bitmask & backtracking. Much easier than working out the binary search here."
                    },
                    {
                        "username": "akamboj",
                        "content": "because there is no contiguous allocation."
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "it's been  45+ minutes trying to solve this problem.. Am I dumb or most of the people are facing the same issue?"
                    },
                    {
                        "username": "emilmohan24",
                        "content": "Bro it takes me days sometimes lol\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "really struggling right now"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Brute force solution works"
                    },
                    {
                        "username": "akshatmaheshwar78",
                        "content": "Yah mate, this was hurting my brain until I took my paper and pen."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "[@longb1997](/longb1997) eveyones dumb mate until the same questions drops in interview"
                    },
                    {
                        "username": "longb1997",
                        "content": "i don't even think about backtracking\ni'm suck :((("
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "[@void_8t](/void_8t)  fr..."
                    },
                    {
                        "username": "meow_power",
                        "content": "you are not alone:("
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Who else thought it was binary search and then realized that the distribution is not contagious \\uD83D\\uDE22"
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This can be cone using binary search\\n\\n\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n\\n        def canDistribute(mid):\\n            children = [0] * k\\n            return assignCookies(0, mid, children)\\n        \\n        def assignCookies(index, mid, children):\\n            if index == len(cookies):\\n                return True\\n            curCookie = cookies[index]\\n            for i in range(k):\\n                if children[i] + curCookie <= mid:\\n                    children[i] += curCookie\\n                    if assignCookies(index + 1, mid, children):\\n                        return True\\n                    children[i] -= curCookie\\n                # If the child hasn\\'t been given any cookie, we break to avoid redundancies.\\n                if children[i] == 0:\\n                    break\\n            return False\\n        \\n        # Set the binary search range\\n        low, high = max(cookies), sum(cookies)\\n        while low < high:\\n            mid = (low + high) // 2\\n            if canDistribute(mid):\\n                high = mid\\n            else:\\n                low = mid + 1\\n\\n        return low\\n"
                    },
                    {
                        "username": "mt790191",
                        "content": "can u please elaborate what do you  mean by  distribution is not contagious and how it effects the solution"
                    },
                    {
                        "username": "_Aman_13_",
                        "content": "I not only thought but also code the BS solution, and also it accepted for 34 test cases. After that I realized that it will not work \\uD83D\\uDE2D"
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "also if it would have binary search question then array size also would have 1e5"
                    },
                    {
                        "username": "Jaiff",
                        "content": "*contiguous"
                    },
                    {
                        "username": "bortengineer",
                        "content": "Time limits for Python are too harsh (as always). Exact same naive backtracking solution that is good enough for c++ is no good for python, so you have to do additional optimizations."
                    },
                    {
                        "username": "dz_adman",
                        "content": "[@cswartzell](/cswartzell) I stand with the argument that equivalent solutions in any language should be acceptable. On the other hand, the fact that python is less efficient, is independent of how leetcode treat any language\\'s code."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@dz_adman](/dz_adman) That is meaningless. The point is that equivalent solutions for each language should be acceptable for each language, regardless of the time required to compute that solution IN the given language. The Time Limits are different for each language as is. \n\nAn equivalent Python solution to a passing C++ solution should absolutely count as valid"
                    },
                    {
                        "username": "dz_adman",
                        "content": "[python is less efficient](https://thenextweb.com/news/python-progamming-language-energy-analysis) than many other languages."
                    },
                    {
                        "username": "stefan1096",
                        "content": "I got TLE in Python3 but beats 56% in C++ with the same code(it only passed after an optimization)."
                    },
                    {
                        "username": "PencilBro27",
                        "content": "This problem is the same as\\n[1723. Find Minimum Time to Finish All Jobs](https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/description/)"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "https://leetcode.com/problems/matchsticks-to-square/\\nhttps://leetcode.com/problems/partition-to-k-equal-sum-subsets/\\nThese Two also Similar"
                    },
                    {
                        "username": "jason3410",
                        "content": "That\\'s a bit harder but still thx for the information."
                    },
                    {
                        "username": "AnywaySo",
                        "content": "Thank you, another problem was accepted."
                    },
                    {
                        "username": "charonme",
                        "content": "although 1723 has stricter time limits"
                    },
                    {
                        "username": "psionl0",
                        "content": "I hate backtracking. It is one of the few areas in algorithms that I can\\'t seem to master.\\n\\nAnd a sloppily worded editorial didn\\'t help. It took me 10 minutes to figure out that they said \"cookie\" they weren\\'t talking about an individual cookie but a bag of cookies."
                    },
                    {
                        "username": "cswartzell",
                        "content": "For me, its not that I cant master backtracking. The actual backtracking algo is almost silly trivial: Do a task, backtrack and undo it, redo the task a different way such that every combination is covered. The problem for me is recognizing: \"we are just going to have to try every combination. No greedy algorthim is going to shortcut these trials. Maybe there is some pruning we can do to early exit a trial branch, but effectively we need to check every branch\"\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "Me too, if it were single cookies, the question is much simpler. If it were single cookies, we would not need an array, we would just be given the total number of cookies. \\n\\nI still haven\\'t solved it."
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "Can anyone explain what do you all mean by saying there\\'s no continuous allocation?\\n"
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "[@JaAt_BhOi](/JaAt_BhOi) from the cookies array we can select cookies[i] in any order(random) need not be contiguous sub array....."
                    },
                    {
                        "username": "y-not",
                        "content": "Java Video Solution - \\nhttps://www.youtube.com/watch?v=kYQ5jXXhWYE"
                    }
                ]
            },
            {
                "id": 1951180,
                "content": [
                    {
                        "username": "JerExplosion",
                        "content": "We should teach the kids that the world is not always fair "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "Prolly should teach them how to build guillotines too. "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> The unfairness of a distribution is defined as the maximum total cookies obtained by a single child in the distribution.\n\nThe most fair (and satisfying) distribution then would be to eat all the cookies yourself."
                    },
                    {
                        "username": "emilmohan24",
                        "content": "O(1) solution. Absolute genius. "
                    },
                    {
                        "username": "Stewie-Griffin",
                        "content": "I mean i can\\'t help to understand that why is it not of binary search  , its language is similar to most of binary search problems."
                    },
                    {
                        "username": "utkarshinobi",
                        "content": "[@vishalkgupta9821](/vishalkgupta9821) Thanks a lot! This was extremely helpful."
                    },
                    {
                        "username": "vishalkgupta9821",
                        "content": "we can solve this problem using binary search like problem 1011. Capacity To Ship Packages Within D Days\\nbut we need to generate all possible permutation of array in order to check unfairness.\\n\\n\\n//fist find the max in min like book allocation \\n    //repeat the process for all permutation\\n    bool ispossible(vector<int>&arr,int k,int mid){\\n        int count=1;\\n        int sum=0;\\n        for(auto  n:arr){\\n            sum+=n;\\n            if(sum>mid){\\n                count++;\\n                sum=n;\\n            }\\n        }\\n        return count<=k;\\n    }\\n\\n    int findMinMax(vector<int>&arr,int k){\\n        int low=0;\\n        int high=0;\\n        for(auto a:arr){\\n            low=max(a,low);\\n            high+=a;\\n        }\\n\\n        int ans=high;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(ispossible(arr,k,mid)){\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int ans=INT_MAX;\\n        sort(cookies.begin(),cookies.end());\\n        do{\\n            ans=min(ans,findMinMax(cookies,k));\\n        }while(next_permutation(cookies.begin(),cookies.end()));\\n\\n        return ans;\\n    }\\n\\n\\n"
                    },
                    {
                        "username": "user7717f",
                        "content": "We can use binary search in this problem to do the pruning by finding the upper bound in searching.\n\n```java\nclass Solution {\n    public int distributeCookies(int[] cookies, int k) {\n        Arrays.sort(cookies);\n        \n        int n = cookies.length, lb = cookies[n - 1], rb = cookies[n - 1] * n, ans = -1;\n        while (lb <= rb) {\n            int mb = lb + rb >> 1;\n\n            if (dfs(cookies, 0, new int[k], mb)) {\n                ans = mb;\n                rb = mb - 1;\n            }else {\n                lb = mb + 1;\n            }\n        }\n\n        return ans;\n    }\n\n    private boolean dfs(int[] cookies, int start, int[] nums, int mb) {\n        if (start == cookies.length) {\n            return true;\n        }\n\n        for (int i = 0; i < nums.length; ++i) {\n            if (nums[i] + cookies[start] <= mb) {\n                nums[i] += cookies[start];\n                if (dfs(cookies, start + 1, nums, mb)) {\n                    return true;\n                }\n                nums[i] -= cookies[start];\n            }\n            if (nums[i] == 0) {\n                return false;\n            }\n        }\n\n        return false;\n    }\n}\n```"
                    },
                    {
                        "username": "srk696772",
                        "content": "Because All the Problems we solved on binary Search Mentions Consecutiveness In the Description , But In The Above There is no Constraint on Consecutive Distribution so we cannot apply binary search here."
                    },
                    {
                        "username": "lalit10368",
                        "content": "[@akamboj](/akamboj) Thanks! for that justification. Hence, no boundary to search here."
                    },
                    {
                        "username": "lalit10368",
                        "content": "Hmm, I had a similar thought while solving. But I don\\'t know how to apply binary search over this. The constraints suggested brute force algorithm should work here. That\\'s why, I simply used bitmask & backtracking. Much easier than working out the binary search here."
                    },
                    {
                        "username": "akamboj",
                        "content": "because there is no contiguous allocation."
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "it's been  45+ minutes trying to solve this problem.. Am I dumb or most of the people are facing the same issue?"
                    },
                    {
                        "username": "emilmohan24",
                        "content": "Bro it takes me days sometimes lol\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "really struggling right now"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Brute force solution works"
                    },
                    {
                        "username": "akshatmaheshwar78",
                        "content": "Yah mate, this was hurting my brain until I took my paper and pen."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "[@longb1997](/longb1997) eveyones dumb mate until the same questions drops in interview"
                    },
                    {
                        "username": "longb1997",
                        "content": "i don't even think about backtracking\ni'm suck :((("
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "[@void_8t](/void_8t)  fr..."
                    },
                    {
                        "username": "meow_power",
                        "content": "you are not alone:("
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Who else thought it was binary search and then realized that the distribution is not contagious \\uD83D\\uDE22"
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This can be cone using binary search\\n\\n\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n\\n        def canDistribute(mid):\\n            children = [0] * k\\n            return assignCookies(0, mid, children)\\n        \\n        def assignCookies(index, mid, children):\\n            if index == len(cookies):\\n                return True\\n            curCookie = cookies[index]\\n            for i in range(k):\\n                if children[i] + curCookie <= mid:\\n                    children[i] += curCookie\\n                    if assignCookies(index + 1, mid, children):\\n                        return True\\n                    children[i] -= curCookie\\n                # If the child hasn\\'t been given any cookie, we break to avoid redundancies.\\n                if children[i] == 0:\\n                    break\\n            return False\\n        \\n        # Set the binary search range\\n        low, high = max(cookies), sum(cookies)\\n        while low < high:\\n            mid = (low + high) // 2\\n            if canDistribute(mid):\\n                high = mid\\n            else:\\n                low = mid + 1\\n\\n        return low\\n"
                    },
                    {
                        "username": "mt790191",
                        "content": "can u please elaborate what do you  mean by  distribution is not contagious and how it effects the solution"
                    },
                    {
                        "username": "_Aman_13_",
                        "content": "I not only thought but also code the BS solution, and also it accepted for 34 test cases. After that I realized that it will not work \\uD83D\\uDE2D"
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "also if it would have binary search question then array size also would have 1e5"
                    },
                    {
                        "username": "Jaiff",
                        "content": "*contiguous"
                    },
                    {
                        "username": "bortengineer",
                        "content": "Time limits for Python are too harsh (as always). Exact same naive backtracking solution that is good enough for c++ is no good for python, so you have to do additional optimizations."
                    },
                    {
                        "username": "dz_adman",
                        "content": "[@cswartzell](/cswartzell) I stand with the argument that equivalent solutions in any language should be acceptable. On the other hand, the fact that python is less efficient, is independent of how leetcode treat any language\\'s code."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@dz_adman](/dz_adman) That is meaningless. The point is that equivalent solutions for each language should be acceptable for each language, regardless of the time required to compute that solution IN the given language. The Time Limits are different for each language as is. \n\nAn equivalent Python solution to a passing C++ solution should absolutely count as valid"
                    },
                    {
                        "username": "dz_adman",
                        "content": "[python is less efficient](https://thenextweb.com/news/python-progamming-language-energy-analysis) than many other languages."
                    },
                    {
                        "username": "stefan1096",
                        "content": "I got TLE in Python3 but beats 56% in C++ with the same code(it only passed after an optimization)."
                    },
                    {
                        "username": "PencilBro27",
                        "content": "This problem is the same as\\n[1723. Find Minimum Time to Finish All Jobs](https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/description/)"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "https://leetcode.com/problems/matchsticks-to-square/\\nhttps://leetcode.com/problems/partition-to-k-equal-sum-subsets/\\nThese Two also Similar"
                    },
                    {
                        "username": "jason3410",
                        "content": "That\\'s a bit harder but still thx for the information."
                    },
                    {
                        "username": "AnywaySo",
                        "content": "Thank you, another problem was accepted."
                    },
                    {
                        "username": "charonme",
                        "content": "although 1723 has stricter time limits"
                    },
                    {
                        "username": "psionl0",
                        "content": "I hate backtracking. It is one of the few areas in algorithms that I can\\'t seem to master.\\n\\nAnd a sloppily worded editorial didn\\'t help. It took me 10 minutes to figure out that they said \"cookie\" they weren\\'t talking about an individual cookie but a bag of cookies."
                    },
                    {
                        "username": "cswartzell",
                        "content": "For me, its not that I cant master backtracking. The actual backtracking algo is almost silly trivial: Do a task, backtrack and undo it, redo the task a different way such that every combination is covered. The problem for me is recognizing: \"we are just going to have to try every combination. No greedy algorthim is going to shortcut these trials. Maybe there is some pruning we can do to early exit a trial branch, but effectively we need to check every branch\"\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "Me too, if it were single cookies, the question is much simpler. If it were single cookies, we would not need an array, we would just be given the total number of cookies. \\n\\nI still haven\\'t solved it."
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "Can anyone explain what do you all mean by saying there\\'s no continuous allocation?\\n"
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "[@JaAt_BhOi](/JaAt_BhOi) from the cookies array we can select cookies[i] in any order(random) need not be contiguous sub array....."
                    },
                    {
                        "username": "y-not",
                        "content": "Java Video Solution - \\nhttps://www.youtube.com/watch?v=kYQ5jXXhWYE"
                    }
                ]
            },
            {
                "id": 1826418,
                "content": [
                    {
                        "username": "JerExplosion",
                        "content": "We should teach the kids that the world is not always fair "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "Prolly should teach them how to build guillotines too. "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> The unfairness of a distribution is defined as the maximum total cookies obtained by a single child in the distribution.\n\nThe most fair (and satisfying) distribution then would be to eat all the cookies yourself."
                    },
                    {
                        "username": "emilmohan24",
                        "content": "O(1) solution. Absolute genius. "
                    },
                    {
                        "username": "Stewie-Griffin",
                        "content": "I mean i can\\'t help to understand that why is it not of binary search  , its language is similar to most of binary search problems."
                    },
                    {
                        "username": "utkarshinobi",
                        "content": "[@vishalkgupta9821](/vishalkgupta9821) Thanks a lot! This was extremely helpful."
                    },
                    {
                        "username": "vishalkgupta9821",
                        "content": "we can solve this problem using binary search like problem 1011. Capacity To Ship Packages Within D Days\\nbut we need to generate all possible permutation of array in order to check unfairness.\\n\\n\\n//fist find the max in min like book allocation \\n    //repeat the process for all permutation\\n    bool ispossible(vector<int>&arr,int k,int mid){\\n        int count=1;\\n        int sum=0;\\n        for(auto  n:arr){\\n            sum+=n;\\n            if(sum>mid){\\n                count++;\\n                sum=n;\\n            }\\n        }\\n        return count<=k;\\n    }\\n\\n    int findMinMax(vector<int>&arr,int k){\\n        int low=0;\\n        int high=0;\\n        for(auto a:arr){\\n            low=max(a,low);\\n            high+=a;\\n        }\\n\\n        int ans=high;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(ispossible(arr,k,mid)){\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int ans=INT_MAX;\\n        sort(cookies.begin(),cookies.end());\\n        do{\\n            ans=min(ans,findMinMax(cookies,k));\\n        }while(next_permutation(cookies.begin(),cookies.end()));\\n\\n        return ans;\\n    }\\n\\n\\n"
                    },
                    {
                        "username": "user7717f",
                        "content": "We can use binary search in this problem to do the pruning by finding the upper bound in searching.\n\n```java\nclass Solution {\n    public int distributeCookies(int[] cookies, int k) {\n        Arrays.sort(cookies);\n        \n        int n = cookies.length, lb = cookies[n - 1], rb = cookies[n - 1] * n, ans = -1;\n        while (lb <= rb) {\n            int mb = lb + rb >> 1;\n\n            if (dfs(cookies, 0, new int[k], mb)) {\n                ans = mb;\n                rb = mb - 1;\n            }else {\n                lb = mb + 1;\n            }\n        }\n\n        return ans;\n    }\n\n    private boolean dfs(int[] cookies, int start, int[] nums, int mb) {\n        if (start == cookies.length) {\n            return true;\n        }\n\n        for (int i = 0; i < nums.length; ++i) {\n            if (nums[i] + cookies[start] <= mb) {\n                nums[i] += cookies[start];\n                if (dfs(cookies, start + 1, nums, mb)) {\n                    return true;\n                }\n                nums[i] -= cookies[start];\n            }\n            if (nums[i] == 0) {\n                return false;\n            }\n        }\n\n        return false;\n    }\n}\n```"
                    },
                    {
                        "username": "srk696772",
                        "content": "Because All the Problems we solved on binary Search Mentions Consecutiveness In the Description , But In The Above There is no Constraint on Consecutive Distribution so we cannot apply binary search here."
                    },
                    {
                        "username": "lalit10368",
                        "content": "[@akamboj](/akamboj) Thanks! for that justification. Hence, no boundary to search here."
                    },
                    {
                        "username": "lalit10368",
                        "content": "Hmm, I had a similar thought while solving. But I don\\'t know how to apply binary search over this. The constraints suggested brute force algorithm should work here. That\\'s why, I simply used bitmask & backtracking. Much easier than working out the binary search here."
                    },
                    {
                        "username": "akamboj",
                        "content": "because there is no contiguous allocation."
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "it's been  45+ minutes trying to solve this problem.. Am I dumb or most of the people are facing the same issue?"
                    },
                    {
                        "username": "emilmohan24",
                        "content": "Bro it takes me days sometimes lol\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "really struggling right now"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Brute force solution works"
                    },
                    {
                        "username": "akshatmaheshwar78",
                        "content": "Yah mate, this was hurting my brain until I took my paper and pen."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "[@longb1997](/longb1997) eveyones dumb mate until the same questions drops in interview"
                    },
                    {
                        "username": "longb1997",
                        "content": "i don't even think about backtracking\ni'm suck :((("
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "[@void_8t](/void_8t)  fr..."
                    },
                    {
                        "username": "meow_power",
                        "content": "you are not alone:("
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Who else thought it was binary search and then realized that the distribution is not contagious \\uD83D\\uDE22"
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This can be cone using binary search\\n\\n\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n\\n        def canDistribute(mid):\\n            children = [0] * k\\n            return assignCookies(0, mid, children)\\n        \\n        def assignCookies(index, mid, children):\\n            if index == len(cookies):\\n                return True\\n            curCookie = cookies[index]\\n            for i in range(k):\\n                if children[i] + curCookie <= mid:\\n                    children[i] += curCookie\\n                    if assignCookies(index + 1, mid, children):\\n                        return True\\n                    children[i] -= curCookie\\n                # If the child hasn\\'t been given any cookie, we break to avoid redundancies.\\n                if children[i] == 0:\\n                    break\\n            return False\\n        \\n        # Set the binary search range\\n        low, high = max(cookies), sum(cookies)\\n        while low < high:\\n            mid = (low + high) // 2\\n            if canDistribute(mid):\\n                high = mid\\n            else:\\n                low = mid + 1\\n\\n        return low\\n"
                    },
                    {
                        "username": "mt790191",
                        "content": "can u please elaborate what do you  mean by  distribution is not contagious and how it effects the solution"
                    },
                    {
                        "username": "_Aman_13_",
                        "content": "I not only thought but also code the BS solution, and also it accepted for 34 test cases. After that I realized that it will not work \\uD83D\\uDE2D"
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "also if it would have binary search question then array size also would have 1e5"
                    },
                    {
                        "username": "Jaiff",
                        "content": "*contiguous"
                    },
                    {
                        "username": "bortengineer",
                        "content": "Time limits for Python are too harsh (as always). Exact same naive backtracking solution that is good enough for c++ is no good for python, so you have to do additional optimizations."
                    },
                    {
                        "username": "dz_adman",
                        "content": "[@cswartzell](/cswartzell) I stand with the argument that equivalent solutions in any language should be acceptable. On the other hand, the fact that python is less efficient, is independent of how leetcode treat any language\\'s code."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@dz_adman](/dz_adman) That is meaningless. The point is that equivalent solutions for each language should be acceptable for each language, regardless of the time required to compute that solution IN the given language. The Time Limits are different for each language as is. \n\nAn equivalent Python solution to a passing C++ solution should absolutely count as valid"
                    },
                    {
                        "username": "dz_adman",
                        "content": "[python is less efficient](https://thenextweb.com/news/python-progamming-language-energy-analysis) than many other languages."
                    },
                    {
                        "username": "stefan1096",
                        "content": "I got TLE in Python3 but beats 56% in C++ with the same code(it only passed after an optimization)."
                    },
                    {
                        "username": "PencilBro27",
                        "content": "This problem is the same as\\n[1723. Find Minimum Time to Finish All Jobs](https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/description/)"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "https://leetcode.com/problems/matchsticks-to-square/\\nhttps://leetcode.com/problems/partition-to-k-equal-sum-subsets/\\nThese Two also Similar"
                    },
                    {
                        "username": "jason3410",
                        "content": "That\\'s a bit harder but still thx for the information."
                    },
                    {
                        "username": "AnywaySo",
                        "content": "Thank you, another problem was accepted."
                    },
                    {
                        "username": "charonme",
                        "content": "although 1723 has stricter time limits"
                    },
                    {
                        "username": "psionl0",
                        "content": "I hate backtracking. It is one of the few areas in algorithms that I can\\'t seem to master.\\n\\nAnd a sloppily worded editorial didn\\'t help. It took me 10 minutes to figure out that they said \"cookie\" they weren\\'t talking about an individual cookie but a bag of cookies."
                    },
                    {
                        "username": "cswartzell",
                        "content": "For me, its not that I cant master backtracking. The actual backtracking algo is almost silly trivial: Do a task, backtrack and undo it, redo the task a different way such that every combination is covered. The problem for me is recognizing: \"we are just going to have to try every combination. No greedy algorthim is going to shortcut these trials. Maybe there is some pruning we can do to early exit a trial branch, but effectively we need to check every branch\"\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "Me too, if it were single cookies, the question is much simpler. If it were single cookies, we would not need an array, we would just be given the total number of cookies. \\n\\nI still haven\\'t solved it."
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "Can anyone explain what do you all mean by saying there\\'s no continuous allocation?\\n"
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "[@JaAt_BhOi](/JaAt_BhOi) from the cookies array we can select cookies[i] in any order(random) need not be contiguous sub array....."
                    },
                    {
                        "username": "y-not",
                        "content": "Java Video Solution - \\nhttps://www.youtube.com/watch?v=kYQ5jXXhWYE"
                    }
                ]
            },
            {
                "id": 1643606,
                "content": [
                    {
                        "username": "JerExplosion",
                        "content": "We should teach the kids that the world is not always fair "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "Prolly should teach them how to build guillotines too. "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> The unfairness of a distribution is defined as the maximum total cookies obtained by a single child in the distribution.\n\nThe most fair (and satisfying) distribution then would be to eat all the cookies yourself."
                    },
                    {
                        "username": "emilmohan24",
                        "content": "O(1) solution. Absolute genius. "
                    },
                    {
                        "username": "Stewie-Griffin",
                        "content": "I mean i can\\'t help to understand that why is it not of binary search  , its language is similar to most of binary search problems."
                    },
                    {
                        "username": "utkarshinobi",
                        "content": "[@vishalkgupta9821](/vishalkgupta9821) Thanks a lot! This was extremely helpful."
                    },
                    {
                        "username": "vishalkgupta9821",
                        "content": "we can solve this problem using binary search like problem 1011. Capacity To Ship Packages Within D Days\\nbut we need to generate all possible permutation of array in order to check unfairness.\\n\\n\\n//fist find the max in min like book allocation \\n    //repeat the process for all permutation\\n    bool ispossible(vector<int>&arr,int k,int mid){\\n        int count=1;\\n        int sum=0;\\n        for(auto  n:arr){\\n            sum+=n;\\n            if(sum>mid){\\n                count++;\\n                sum=n;\\n            }\\n        }\\n        return count<=k;\\n    }\\n\\n    int findMinMax(vector<int>&arr,int k){\\n        int low=0;\\n        int high=0;\\n        for(auto a:arr){\\n            low=max(a,low);\\n            high+=a;\\n        }\\n\\n        int ans=high;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(ispossible(arr,k,mid)){\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int ans=INT_MAX;\\n        sort(cookies.begin(),cookies.end());\\n        do{\\n            ans=min(ans,findMinMax(cookies,k));\\n        }while(next_permutation(cookies.begin(),cookies.end()));\\n\\n        return ans;\\n    }\\n\\n\\n"
                    },
                    {
                        "username": "user7717f",
                        "content": "We can use binary search in this problem to do the pruning by finding the upper bound in searching.\n\n```java\nclass Solution {\n    public int distributeCookies(int[] cookies, int k) {\n        Arrays.sort(cookies);\n        \n        int n = cookies.length, lb = cookies[n - 1], rb = cookies[n - 1] * n, ans = -1;\n        while (lb <= rb) {\n            int mb = lb + rb >> 1;\n\n            if (dfs(cookies, 0, new int[k], mb)) {\n                ans = mb;\n                rb = mb - 1;\n            }else {\n                lb = mb + 1;\n            }\n        }\n\n        return ans;\n    }\n\n    private boolean dfs(int[] cookies, int start, int[] nums, int mb) {\n        if (start == cookies.length) {\n            return true;\n        }\n\n        for (int i = 0; i < nums.length; ++i) {\n            if (nums[i] + cookies[start] <= mb) {\n                nums[i] += cookies[start];\n                if (dfs(cookies, start + 1, nums, mb)) {\n                    return true;\n                }\n                nums[i] -= cookies[start];\n            }\n            if (nums[i] == 0) {\n                return false;\n            }\n        }\n\n        return false;\n    }\n}\n```"
                    },
                    {
                        "username": "srk696772",
                        "content": "Because All the Problems we solved on binary Search Mentions Consecutiveness In the Description , But In The Above There is no Constraint on Consecutive Distribution so we cannot apply binary search here."
                    },
                    {
                        "username": "lalit10368",
                        "content": "[@akamboj](/akamboj) Thanks! for that justification. Hence, no boundary to search here."
                    },
                    {
                        "username": "lalit10368",
                        "content": "Hmm, I had a similar thought while solving. But I don\\'t know how to apply binary search over this. The constraints suggested brute force algorithm should work here. That\\'s why, I simply used bitmask & backtracking. Much easier than working out the binary search here."
                    },
                    {
                        "username": "akamboj",
                        "content": "because there is no contiguous allocation."
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "it's been  45+ minutes trying to solve this problem.. Am I dumb or most of the people are facing the same issue?"
                    },
                    {
                        "username": "emilmohan24",
                        "content": "Bro it takes me days sometimes lol\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "really struggling right now"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Brute force solution works"
                    },
                    {
                        "username": "akshatmaheshwar78",
                        "content": "Yah mate, this was hurting my brain until I took my paper and pen."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "[@longb1997](/longb1997) eveyones dumb mate until the same questions drops in interview"
                    },
                    {
                        "username": "longb1997",
                        "content": "i don't even think about backtracking\ni'm suck :((("
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "[@void_8t](/void_8t)  fr..."
                    },
                    {
                        "username": "meow_power",
                        "content": "you are not alone:("
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Who else thought it was binary search and then realized that the distribution is not contagious \\uD83D\\uDE22"
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This can be cone using binary search\\n\\n\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n\\n        def canDistribute(mid):\\n            children = [0] * k\\n            return assignCookies(0, mid, children)\\n        \\n        def assignCookies(index, mid, children):\\n            if index == len(cookies):\\n                return True\\n            curCookie = cookies[index]\\n            for i in range(k):\\n                if children[i] + curCookie <= mid:\\n                    children[i] += curCookie\\n                    if assignCookies(index + 1, mid, children):\\n                        return True\\n                    children[i] -= curCookie\\n                # If the child hasn\\'t been given any cookie, we break to avoid redundancies.\\n                if children[i] == 0:\\n                    break\\n            return False\\n        \\n        # Set the binary search range\\n        low, high = max(cookies), sum(cookies)\\n        while low < high:\\n            mid = (low + high) // 2\\n            if canDistribute(mid):\\n                high = mid\\n            else:\\n                low = mid + 1\\n\\n        return low\\n"
                    },
                    {
                        "username": "mt790191",
                        "content": "can u please elaborate what do you  mean by  distribution is not contagious and how it effects the solution"
                    },
                    {
                        "username": "_Aman_13_",
                        "content": "I not only thought but also code the BS solution, and also it accepted for 34 test cases. After that I realized that it will not work \\uD83D\\uDE2D"
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "also if it would have binary search question then array size also would have 1e5"
                    },
                    {
                        "username": "Jaiff",
                        "content": "*contiguous"
                    },
                    {
                        "username": "bortengineer",
                        "content": "Time limits for Python are too harsh (as always). Exact same naive backtracking solution that is good enough for c++ is no good for python, so you have to do additional optimizations."
                    },
                    {
                        "username": "dz_adman",
                        "content": "[@cswartzell](/cswartzell) I stand with the argument that equivalent solutions in any language should be acceptable. On the other hand, the fact that python is less efficient, is independent of how leetcode treat any language\\'s code."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@dz_adman](/dz_adman) That is meaningless. The point is that equivalent solutions for each language should be acceptable for each language, regardless of the time required to compute that solution IN the given language. The Time Limits are different for each language as is. \n\nAn equivalent Python solution to a passing C++ solution should absolutely count as valid"
                    },
                    {
                        "username": "dz_adman",
                        "content": "[python is less efficient](https://thenextweb.com/news/python-progamming-language-energy-analysis) than many other languages."
                    },
                    {
                        "username": "stefan1096",
                        "content": "I got TLE in Python3 but beats 56% in C++ with the same code(it only passed after an optimization)."
                    },
                    {
                        "username": "PencilBro27",
                        "content": "This problem is the same as\\n[1723. Find Minimum Time to Finish All Jobs](https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/description/)"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "https://leetcode.com/problems/matchsticks-to-square/\\nhttps://leetcode.com/problems/partition-to-k-equal-sum-subsets/\\nThese Two also Similar"
                    },
                    {
                        "username": "jason3410",
                        "content": "That\\'s a bit harder but still thx for the information."
                    },
                    {
                        "username": "AnywaySo",
                        "content": "Thank you, another problem was accepted."
                    },
                    {
                        "username": "charonme",
                        "content": "although 1723 has stricter time limits"
                    },
                    {
                        "username": "psionl0",
                        "content": "I hate backtracking. It is one of the few areas in algorithms that I can\\'t seem to master.\\n\\nAnd a sloppily worded editorial didn\\'t help. It took me 10 minutes to figure out that they said \"cookie\" they weren\\'t talking about an individual cookie but a bag of cookies."
                    },
                    {
                        "username": "cswartzell",
                        "content": "For me, its not that I cant master backtracking. The actual backtracking algo is almost silly trivial: Do a task, backtrack and undo it, redo the task a different way such that every combination is covered. The problem for me is recognizing: \"we are just going to have to try every combination. No greedy algorthim is going to shortcut these trials. Maybe there is some pruning we can do to early exit a trial branch, but effectively we need to check every branch\"\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "Me too, if it were single cookies, the question is much simpler. If it were single cookies, we would not need an array, we would just be given the total number of cookies. \\n\\nI still haven\\'t solved it."
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "Can anyone explain what do you all mean by saying there\\'s no continuous allocation?\\n"
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "[@JaAt_BhOi](/JaAt_BhOi) from the cookies array we can select cookies[i] in any order(random) need not be contiguous sub array....."
                    },
                    {
                        "username": "y-not",
                        "content": "Java Video Solution - \\nhttps://www.youtube.com/watch?v=kYQ5jXXhWYE"
                    }
                ]
            },
            {
                "id": 1951127,
                "content": [
                    {
                        "username": "JerExplosion",
                        "content": "We should teach the kids that the world is not always fair "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "Prolly should teach them how to build guillotines too. "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> The unfairness of a distribution is defined as the maximum total cookies obtained by a single child in the distribution.\n\nThe most fair (and satisfying) distribution then would be to eat all the cookies yourself."
                    },
                    {
                        "username": "emilmohan24",
                        "content": "O(1) solution. Absolute genius. "
                    },
                    {
                        "username": "Stewie-Griffin",
                        "content": "I mean i can\\'t help to understand that why is it not of binary search  , its language is similar to most of binary search problems."
                    },
                    {
                        "username": "utkarshinobi",
                        "content": "[@vishalkgupta9821](/vishalkgupta9821) Thanks a lot! This was extremely helpful."
                    },
                    {
                        "username": "vishalkgupta9821",
                        "content": "we can solve this problem using binary search like problem 1011. Capacity To Ship Packages Within D Days\\nbut we need to generate all possible permutation of array in order to check unfairness.\\n\\n\\n//fist find the max in min like book allocation \\n    //repeat the process for all permutation\\n    bool ispossible(vector<int>&arr,int k,int mid){\\n        int count=1;\\n        int sum=0;\\n        for(auto  n:arr){\\n            sum+=n;\\n            if(sum>mid){\\n                count++;\\n                sum=n;\\n            }\\n        }\\n        return count<=k;\\n    }\\n\\n    int findMinMax(vector<int>&arr,int k){\\n        int low=0;\\n        int high=0;\\n        for(auto a:arr){\\n            low=max(a,low);\\n            high+=a;\\n        }\\n\\n        int ans=high;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(ispossible(arr,k,mid)){\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int ans=INT_MAX;\\n        sort(cookies.begin(),cookies.end());\\n        do{\\n            ans=min(ans,findMinMax(cookies,k));\\n        }while(next_permutation(cookies.begin(),cookies.end()));\\n\\n        return ans;\\n    }\\n\\n\\n"
                    },
                    {
                        "username": "user7717f",
                        "content": "We can use binary search in this problem to do the pruning by finding the upper bound in searching.\n\n```java\nclass Solution {\n    public int distributeCookies(int[] cookies, int k) {\n        Arrays.sort(cookies);\n        \n        int n = cookies.length, lb = cookies[n - 1], rb = cookies[n - 1] * n, ans = -1;\n        while (lb <= rb) {\n            int mb = lb + rb >> 1;\n\n            if (dfs(cookies, 0, new int[k], mb)) {\n                ans = mb;\n                rb = mb - 1;\n            }else {\n                lb = mb + 1;\n            }\n        }\n\n        return ans;\n    }\n\n    private boolean dfs(int[] cookies, int start, int[] nums, int mb) {\n        if (start == cookies.length) {\n            return true;\n        }\n\n        for (int i = 0; i < nums.length; ++i) {\n            if (nums[i] + cookies[start] <= mb) {\n                nums[i] += cookies[start];\n                if (dfs(cookies, start + 1, nums, mb)) {\n                    return true;\n                }\n                nums[i] -= cookies[start];\n            }\n            if (nums[i] == 0) {\n                return false;\n            }\n        }\n\n        return false;\n    }\n}\n```"
                    },
                    {
                        "username": "srk696772",
                        "content": "Because All the Problems we solved on binary Search Mentions Consecutiveness In the Description , But In The Above There is no Constraint on Consecutive Distribution so we cannot apply binary search here."
                    },
                    {
                        "username": "lalit10368",
                        "content": "[@akamboj](/akamboj) Thanks! for that justification. Hence, no boundary to search here."
                    },
                    {
                        "username": "lalit10368",
                        "content": "Hmm, I had a similar thought while solving. But I don\\'t know how to apply binary search over this. The constraints suggested brute force algorithm should work here. That\\'s why, I simply used bitmask & backtracking. Much easier than working out the binary search here."
                    },
                    {
                        "username": "akamboj",
                        "content": "because there is no contiguous allocation."
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "it's been  45+ minutes trying to solve this problem.. Am I dumb or most of the people are facing the same issue?"
                    },
                    {
                        "username": "emilmohan24",
                        "content": "Bro it takes me days sometimes lol\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "really struggling right now"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Brute force solution works"
                    },
                    {
                        "username": "akshatmaheshwar78",
                        "content": "Yah mate, this was hurting my brain until I took my paper and pen."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "[@longb1997](/longb1997) eveyones dumb mate until the same questions drops in interview"
                    },
                    {
                        "username": "longb1997",
                        "content": "i don't even think about backtracking\ni'm suck :((("
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "[@void_8t](/void_8t)  fr..."
                    },
                    {
                        "username": "meow_power",
                        "content": "you are not alone:("
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Who else thought it was binary search and then realized that the distribution is not contagious \\uD83D\\uDE22"
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This can be cone using binary search\\n\\n\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n\\n        def canDistribute(mid):\\n            children = [0] * k\\n            return assignCookies(0, mid, children)\\n        \\n        def assignCookies(index, mid, children):\\n            if index == len(cookies):\\n                return True\\n            curCookie = cookies[index]\\n            for i in range(k):\\n                if children[i] + curCookie <= mid:\\n                    children[i] += curCookie\\n                    if assignCookies(index + 1, mid, children):\\n                        return True\\n                    children[i] -= curCookie\\n                # If the child hasn\\'t been given any cookie, we break to avoid redundancies.\\n                if children[i] == 0:\\n                    break\\n            return False\\n        \\n        # Set the binary search range\\n        low, high = max(cookies), sum(cookies)\\n        while low < high:\\n            mid = (low + high) // 2\\n            if canDistribute(mid):\\n                high = mid\\n            else:\\n                low = mid + 1\\n\\n        return low\\n"
                    },
                    {
                        "username": "mt790191",
                        "content": "can u please elaborate what do you  mean by  distribution is not contagious and how it effects the solution"
                    },
                    {
                        "username": "_Aman_13_",
                        "content": "I not only thought but also code the BS solution, and also it accepted for 34 test cases. After that I realized that it will not work \\uD83D\\uDE2D"
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "also if it would have binary search question then array size also would have 1e5"
                    },
                    {
                        "username": "Jaiff",
                        "content": "*contiguous"
                    },
                    {
                        "username": "bortengineer",
                        "content": "Time limits for Python are too harsh (as always). Exact same naive backtracking solution that is good enough for c++ is no good for python, so you have to do additional optimizations."
                    },
                    {
                        "username": "dz_adman",
                        "content": "[@cswartzell](/cswartzell) I stand with the argument that equivalent solutions in any language should be acceptable. On the other hand, the fact that python is less efficient, is independent of how leetcode treat any language\\'s code."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@dz_adman](/dz_adman) That is meaningless. The point is that equivalent solutions for each language should be acceptable for each language, regardless of the time required to compute that solution IN the given language. The Time Limits are different for each language as is. \n\nAn equivalent Python solution to a passing C++ solution should absolutely count as valid"
                    },
                    {
                        "username": "dz_adman",
                        "content": "[python is less efficient](https://thenextweb.com/news/python-progamming-language-energy-analysis) than many other languages."
                    },
                    {
                        "username": "stefan1096",
                        "content": "I got TLE in Python3 but beats 56% in C++ with the same code(it only passed after an optimization)."
                    },
                    {
                        "username": "PencilBro27",
                        "content": "This problem is the same as\\n[1723. Find Minimum Time to Finish All Jobs](https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/description/)"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "https://leetcode.com/problems/matchsticks-to-square/\\nhttps://leetcode.com/problems/partition-to-k-equal-sum-subsets/\\nThese Two also Similar"
                    },
                    {
                        "username": "jason3410",
                        "content": "That\\'s a bit harder but still thx for the information."
                    },
                    {
                        "username": "AnywaySo",
                        "content": "Thank you, another problem was accepted."
                    },
                    {
                        "username": "charonme",
                        "content": "although 1723 has stricter time limits"
                    },
                    {
                        "username": "psionl0",
                        "content": "I hate backtracking. It is one of the few areas in algorithms that I can\\'t seem to master.\\n\\nAnd a sloppily worded editorial didn\\'t help. It took me 10 minutes to figure out that they said \"cookie\" they weren\\'t talking about an individual cookie but a bag of cookies."
                    },
                    {
                        "username": "cswartzell",
                        "content": "For me, its not that I cant master backtracking. The actual backtracking algo is almost silly trivial: Do a task, backtrack and undo it, redo the task a different way such that every combination is covered. The problem for me is recognizing: \"we are just going to have to try every combination. No greedy algorthim is going to shortcut these trials. Maybe there is some pruning we can do to early exit a trial branch, but effectively we need to check every branch\"\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "Me too, if it were single cookies, the question is much simpler. If it were single cookies, we would not need an array, we would just be given the total number of cookies. \\n\\nI still haven\\'t solved it."
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "Can anyone explain what do you all mean by saying there\\'s no continuous allocation?\\n"
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "[@JaAt_BhOi](/JaAt_BhOi) from the cookies array we can select cookies[i] in any order(random) need not be contiguous sub array....."
                    },
                    {
                        "username": "y-not",
                        "content": "Java Video Solution - \\nhttps://www.youtube.com/watch?v=kYQ5jXXhWYE"
                    }
                ]
            },
            {
                "id": 1951291,
                "content": [
                    {
                        "username": "JerExplosion",
                        "content": "We should teach the kids that the world is not always fair "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "Prolly should teach them how to build guillotines too. "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> The unfairness of a distribution is defined as the maximum total cookies obtained by a single child in the distribution.\n\nThe most fair (and satisfying) distribution then would be to eat all the cookies yourself."
                    },
                    {
                        "username": "emilmohan24",
                        "content": "O(1) solution. Absolute genius. "
                    },
                    {
                        "username": "Stewie-Griffin",
                        "content": "I mean i can\\'t help to understand that why is it not of binary search  , its language is similar to most of binary search problems."
                    },
                    {
                        "username": "utkarshinobi",
                        "content": "[@vishalkgupta9821](/vishalkgupta9821) Thanks a lot! This was extremely helpful."
                    },
                    {
                        "username": "vishalkgupta9821",
                        "content": "we can solve this problem using binary search like problem 1011. Capacity To Ship Packages Within D Days\\nbut we need to generate all possible permutation of array in order to check unfairness.\\n\\n\\n//fist find the max in min like book allocation \\n    //repeat the process for all permutation\\n    bool ispossible(vector<int>&arr,int k,int mid){\\n        int count=1;\\n        int sum=0;\\n        for(auto  n:arr){\\n            sum+=n;\\n            if(sum>mid){\\n                count++;\\n                sum=n;\\n            }\\n        }\\n        return count<=k;\\n    }\\n\\n    int findMinMax(vector<int>&arr,int k){\\n        int low=0;\\n        int high=0;\\n        for(auto a:arr){\\n            low=max(a,low);\\n            high+=a;\\n        }\\n\\n        int ans=high;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(ispossible(arr,k,mid)){\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int ans=INT_MAX;\\n        sort(cookies.begin(),cookies.end());\\n        do{\\n            ans=min(ans,findMinMax(cookies,k));\\n        }while(next_permutation(cookies.begin(),cookies.end()));\\n\\n        return ans;\\n    }\\n\\n\\n"
                    },
                    {
                        "username": "user7717f",
                        "content": "We can use binary search in this problem to do the pruning by finding the upper bound in searching.\n\n```java\nclass Solution {\n    public int distributeCookies(int[] cookies, int k) {\n        Arrays.sort(cookies);\n        \n        int n = cookies.length, lb = cookies[n - 1], rb = cookies[n - 1] * n, ans = -1;\n        while (lb <= rb) {\n            int mb = lb + rb >> 1;\n\n            if (dfs(cookies, 0, new int[k], mb)) {\n                ans = mb;\n                rb = mb - 1;\n            }else {\n                lb = mb + 1;\n            }\n        }\n\n        return ans;\n    }\n\n    private boolean dfs(int[] cookies, int start, int[] nums, int mb) {\n        if (start == cookies.length) {\n            return true;\n        }\n\n        for (int i = 0; i < nums.length; ++i) {\n            if (nums[i] + cookies[start] <= mb) {\n                nums[i] += cookies[start];\n                if (dfs(cookies, start + 1, nums, mb)) {\n                    return true;\n                }\n                nums[i] -= cookies[start];\n            }\n            if (nums[i] == 0) {\n                return false;\n            }\n        }\n\n        return false;\n    }\n}\n```"
                    },
                    {
                        "username": "srk696772",
                        "content": "Because All the Problems we solved on binary Search Mentions Consecutiveness In the Description , But In The Above There is no Constraint on Consecutive Distribution so we cannot apply binary search here."
                    },
                    {
                        "username": "lalit10368",
                        "content": "[@akamboj](/akamboj) Thanks! for that justification. Hence, no boundary to search here."
                    },
                    {
                        "username": "lalit10368",
                        "content": "Hmm, I had a similar thought while solving. But I don\\'t know how to apply binary search over this. The constraints suggested brute force algorithm should work here. That\\'s why, I simply used bitmask & backtracking. Much easier than working out the binary search here."
                    },
                    {
                        "username": "akamboj",
                        "content": "because there is no contiguous allocation."
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "it's been  45+ minutes trying to solve this problem.. Am I dumb or most of the people are facing the same issue?"
                    },
                    {
                        "username": "emilmohan24",
                        "content": "Bro it takes me days sometimes lol\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "really struggling right now"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Brute force solution works"
                    },
                    {
                        "username": "akshatmaheshwar78",
                        "content": "Yah mate, this was hurting my brain until I took my paper and pen."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "[@longb1997](/longb1997) eveyones dumb mate until the same questions drops in interview"
                    },
                    {
                        "username": "longb1997",
                        "content": "i don't even think about backtracking\ni'm suck :((("
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "[@void_8t](/void_8t)  fr..."
                    },
                    {
                        "username": "meow_power",
                        "content": "you are not alone:("
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Who else thought it was binary search and then realized that the distribution is not contagious \\uD83D\\uDE22"
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This can be cone using binary search\\n\\n\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n\\n        def canDistribute(mid):\\n            children = [0] * k\\n            return assignCookies(0, mid, children)\\n        \\n        def assignCookies(index, mid, children):\\n            if index == len(cookies):\\n                return True\\n            curCookie = cookies[index]\\n            for i in range(k):\\n                if children[i] + curCookie <= mid:\\n                    children[i] += curCookie\\n                    if assignCookies(index + 1, mid, children):\\n                        return True\\n                    children[i] -= curCookie\\n                # If the child hasn\\'t been given any cookie, we break to avoid redundancies.\\n                if children[i] == 0:\\n                    break\\n            return False\\n        \\n        # Set the binary search range\\n        low, high = max(cookies), sum(cookies)\\n        while low < high:\\n            mid = (low + high) // 2\\n            if canDistribute(mid):\\n                high = mid\\n            else:\\n                low = mid + 1\\n\\n        return low\\n"
                    },
                    {
                        "username": "mt790191",
                        "content": "can u please elaborate what do you  mean by  distribution is not contagious and how it effects the solution"
                    },
                    {
                        "username": "_Aman_13_",
                        "content": "I not only thought but also code the BS solution, and also it accepted for 34 test cases. After that I realized that it will not work \\uD83D\\uDE2D"
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "also if it would have binary search question then array size also would have 1e5"
                    },
                    {
                        "username": "Jaiff",
                        "content": "*contiguous"
                    },
                    {
                        "username": "bortengineer",
                        "content": "Time limits for Python are too harsh (as always). Exact same naive backtracking solution that is good enough for c++ is no good for python, so you have to do additional optimizations."
                    },
                    {
                        "username": "dz_adman",
                        "content": "[@cswartzell](/cswartzell) I stand with the argument that equivalent solutions in any language should be acceptable. On the other hand, the fact that python is less efficient, is independent of how leetcode treat any language\\'s code."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@dz_adman](/dz_adman) That is meaningless. The point is that equivalent solutions for each language should be acceptable for each language, regardless of the time required to compute that solution IN the given language. The Time Limits are different for each language as is. \n\nAn equivalent Python solution to a passing C++ solution should absolutely count as valid"
                    },
                    {
                        "username": "dz_adman",
                        "content": "[python is less efficient](https://thenextweb.com/news/python-progamming-language-energy-analysis) than many other languages."
                    },
                    {
                        "username": "stefan1096",
                        "content": "I got TLE in Python3 but beats 56% in C++ with the same code(it only passed after an optimization)."
                    },
                    {
                        "username": "PencilBro27",
                        "content": "This problem is the same as\\n[1723. Find Minimum Time to Finish All Jobs](https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/description/)"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "https://leetcode.com/problems/matchsticks-to-square/\\nhttps://leetcode.com/problems/partition-to-k-equal-sum-subsets/\\nThese Two also Similar"
                    },
                    {
                        "username": "jason3410",
                        "content": "That\\'s a bit harder but still thx for the information."
                    },
                    {
                        "username": "AnywaySo",
                        "content": "Thank you, another problem was accepted."
                    },
                    {
                        "username": "charonme",
                        "content": "although 1723 has stricter time limits"
                    },
                    {
                        "username": "psionl0",
                        "content": "I hate backtracking. It is one of the few areas in algorithms that I can\\'t seem to master.\\n\\nAnd a sloppily worded editorial didn\\'t help. It took me 10 minutes to figure out that they said \"cookie\" they weren\\'t talking about an individual cookie but a bag of cookies."
                    },
                    {
                        "username": "cswartzell",
                        "content": "For me, its not that I cant master backtracking. The actual backtracking algo is almost silly trivial: Do a task, backtrack and undo it, redo the task a different way such that every combination is covered. The problem for me is recognizing: \"we are just going to have to try every combination. No greedy algorthim is going to shortcut these trials. Maybe there is some pruning we can do to early exit a trial branch, but effectively we need to check every branch\"\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "Me too, if it were single cookies, the question is much simpler. If it were single cookies, we would not need an array, we would just be given the total number of cookies. \\n\\nI still haven\\'t solved it."
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "Can anyone explain what do you all mean by saying there\\'s no continuous allocation?\\n"
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "[@JaAt_BhOi](/JaAt_BhOi) from the cookies array we can select cookies[i] in any order(random) need not be contiguous sub array....."
                    },
                    {
                        "username": "y-not",
                        "content": "Java Video Solution - \\nhttps://www.youtube.com/watch?v=kYQ5jXXhWYE"
                    }
                ]
            },
            {
                "id": 1951427,
                "content": [
                    {
                        "username": "JerExplosion",
                        "content": "We should teach the kids that the world is not always fair "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "Prolly should teach them how to build guillotines too. "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> The unfairness of a distribution is defined as the maximum total cookies obtained by a single child in the distribution.\n\nThe most fair (and satisfying) distribution then would be to eat all the cookies yourself."
                    },
                    {
                        "username": "emilmohan24",
                        "content": "O(1) solution. Absolute genius. "
                    },
                    {
                        "username": "Stewie-Griffin",
                        "content": "I mean i can\\'t help to understand that why is it not of binary search  , its language is similar to most of binary search problems."
                    },
                    {
                        "username": "utkarshinobi",
                        "content": "[@vishalkgupta9821](/vishalkgupta9821) Thanks a lot! This was extremely helpful."
                    },
                    {
                        "username": "vishalkgupta9821",
                        "content": "we can solve this problem using binary search like problem 1011. Capacity To Ship Packages Within D Days\\nbut we need to generate all possible permutation of array in order to check unfairness.\\n\\n\\n//fist find the max in min like book allocation \\n    //repeat the process for all permutation\\n    bool ispossible(vector<int>&arr,int k,int mid){\\n        int count=1;\\n        int sum=0;\\n        for(auto  n:arr){\\n            sum+=n;\\n            if(sum>mid){\\n                count++;\\n                sum=n;\\n            }\\n        }\\n        return count<=k;\\n    }\\n\\n    int findMinMax(vector<int>&arr,int k){\\n        int low=0;\\n        int high=0;\\n        for(auto a:arr){\\n            low=max(a,low);\\n            high+=a;\\n        }\\n\\n        int ans=high;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(ispossible(arr,k,mid)){\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int ans=INT_MAX;\\n        sort(cookies.begin(),cookies.end());\\n        do{\\n            ans=min(ans,findMinMax(cookies,k));\\n        }while(next_permutation(cookies.begin(),cookies.end()));\\n\\n        return ans;\\n    }\\n\\n\\n"
                    },
                    {
                        "username": "user7717f",
                        "content": "We can use binary search in this problem to do the pruning by finding the upper bound in searching.\n\n```java\nclass Solution {\n    public int distributeCookies(int[] cookies, int k) {\n        Arrays.sort(cookies);\n        \n        int n = cookies.length, lb = cookies[n - 1], rb = cookies[n - 1] * n, ans = -1;\n        while (lb <= rb) {\n            int mb = lb + rb >> 1;\n\n            if (dfs(cookies, 0, new int[k], mb)) {\n                ans = mb;\n                rb = mb - 1;\n            }else {\n                lb = mb + 1;\n            }\n        }\n\n        return ans;\n    }\n\n    private boolean dfs(int[] cookies, int start, int[] nums, int mb) {\n        if (start == cookies.length) {\n            return true;\n        }\n\n        for (int i = 0; i < nums.length; ++i) {\n            if (nums[i] + cookies[start] <= mb) {\n                nums[i] += cookies[start];\n                if (dfs(cookies, start + 1, nums, mb)) {\n                    return true;\n                }\n                nums[i] -= cookies[start];\n            }\n            if (nums[i] == 0) {\n                return false;\n            }\n        }\n\n        return false;\n    }\n}\n```"
                    },
                    {
                        "username": "srk696772",
                        "content": "Because All the Problems we solved on binary Search Mentions Consecutiveness In the Description , But In The Above There is no Constraint on Consecutive Distribution so we cannot apply binary search here."
                    },
                    {
                        "username": "lalit10368",
                        "content": "[@akamboj](/akamboj) Thanks! for that justification. Hence, no boundary to search here."
                    },
                    {
                        "username": "lalit10368",
                        "content": "Hmm, I had a similar thought while solving. But I don\\'t know how to apply binary search over this. The constraints suggested brute force algorithm should work here. That\\'s why, I simply used bitmask & backtracking. Much easier than working out the binary search here."
                    },
                    {
                        "username": "akamboj",
                        "content": "because there is no contiguous allocation."
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "it's been  45+ minutes trying to solve this problem.. Am I dumb or most of the people are facing the same issue?"
                    },
                    {
                        "username": "emilmohan24",
                        "content": "Bro it takes me days sometimes lol\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "really struggling right now"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Brute force solution works"
                    },
                    {
                        "username": "akshatmaheshwar78",
                        "content": "Yah mate, this was hurting my brain until I took my paper and pen."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "[@longb1997](/longb1997) eveyones dumb mate until the same questions drops in interview"
                    },
                    {
                        "username": "longb1997",
                        "content": "i don't even think about backtracking\ni'm suck :((("
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "[@void_8t](/void_8t)  fr..."
                    },
                    {
                        "username": "meow_power",
                        "content": "you are not alone:("
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Who else thought it was binary search and then realized that the distribution is not contagious \\uD83D\\uDE22"
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This can be cone using binary search\\n\\n\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n\\n        def canDistribute(mid):\\n            children = [0] * k\\n            return assignCookies(0, mid, children)\\n        \\n        def assignCookies(index, mid, children):\\n            if index == len(cookies):\\n                return True\\n            curCookie = cookies[index]\\n            for i in range(k):\\n                if children[i] + curCookie <= mid:\\n                    children[i] += curCookie\\n                    if assignCookies(index + 1, mid, children):\\n                        return True\\n                    children[i] -= curCookie\\n                # If the child hasn\\'t been given any cookie, we break to avoid redundancies.\\n                if children[i] == 0:\\n                    break\\n            return False\\n        \\n        # Set the binary search range\\n        low, high = max(cookies), sum(cookies)\\n        while low < high:\\n            mid = (low + high) // 2\\n            if canDistribute(mid):\\n                high = mid\\n            else:\\n                low = mid + 1\\n\\n        return low\\n"
                    },
                    {
                        "username": "mt790191",
                        "content": "can u please elaborate what do you  mean by  distribution is not contagious and how it effects the solution"
                    },
                    {
                        "username": "_Aman_13_",
                        "content": "I not only thought but also code the BS solution, and also it accepted for 34 test cases. After that I realized that it will not work \\uD83D\\uDE2D"
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "also if it would have binary search question then array size also would have 1e5"
                    },
                    {
                        "username": "Jaiff",
                        "content": "*contiguous"
                    },
                    {
                        "username": "bortengineer",
                        "content": "Time limits for Python are too harsh (as always). Exact same naive backtracking solution that is good enough for c++ is no good for python, so you have to do additional optimizations."
                    },
                    {
                        "username": "dz_adman",
                        "content": "[@cswartzell](/cswartzell) I stand with the argument that equivalent solutions in any language should be acceptable. On the other hand, the fact that python is less efficient, is independent of how leetcode treat any language\\'s code."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@dz_adman](/dz_adman) That is meaningless. The point is that equivalent solutions for each language should be acceptable for each language, regardless of the time required to compute that solution IN the given language. The Time Limits are different for each language as is. \n\nAn equivalent Python solution to a passing C++ solution should absolutely count as valid"
                    },
                    {
                        "username": "dz_adman",
                        "content": "[python is less efficient](https://thenextweb.com/news/python-progamming-language-energy-analysis) than many other languages."
                    },
                    {
                        "username": "stefan1096",
                        "content": "I got TLE in Python3 but beats 56% in C++ with the same code(it only passed after an optimization)."
                    },
                    {
                        "username": "PencilBro27",
                        "content": "This problem is the same as\\n[1723. Find Minimum Time to Finish All Jobs](https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/description/)"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "https://leetcode.com/problems/matchsticks-to-square/\\nhttps://leetcode.com/problems/partition-to-k-equal-sum-subsets/\\nThese Two also Similar"
                    },
                    {
                        "username": "jason3410",
                        "content": "That\\'s a bit harder but still thx for the information."
                    },
                    {
                        "username": "AnywaySo",
                        "content": "Thank you, another problem was accepted."
                    },
                    {
                        "username": "charonme",
                        "content": "although 1723 has stricter time limits"
                    },
                    {
                        "username": "psionl0",
                        "content": "I hate backtracking. It is one of the few areas in algorithms that I can\\'t seem to master.\\n\\nAnd a sloppily worded editorial didn\\'t help. It took me 10 minutes to figure out that they said \"cookie\" they weren\\'t talking about an individual cookie but a bag of cookies."
                    },
                    {
                        "username": "cswartzell",
                        "content": "For me, its not that I cant master backtracking. The actual backtracking algo is almost silly trivial: Do a task, backtrack and undo it, redo the task a different way such that every combination is covered. The problem for me is recognizing: \"we are just going to have to try every combination. No greedy algorthim is going to shortcut these trials. Maybe there is some pruning we can do to early exit a trial branch, but effectively we need to check every branch\"\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "Me too, if it were single cookies, the question is much simpler. If it were single cookies, we would not need an array, we would just be given the total number of cookies. \\n\\nI still haven\\'t solved it."
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "Can anyone explain what do you all mean by saying there\\'s no continuous allocation?\\n"
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "[@JaAt_BhOi](/JaAt_BhOi) from the cookies array we can select cookies[i] in any order(random) need not be contiguous sub array....."
                    },
                    {
                        "username": "y-not",
                        "content": "Java Video Solution - \\nhttps://www.youtube.com/watch?v=kYQ5jXXhWYE"
                    }
                ]
            },
            {
                "id": 1951000,
                "content": [
                    {
                        "username": "JerExplosion",
                        "content": "We should teach the kids that the world is not always fair "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "Prolly should teach them how to build guillotines too. "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> The unfairness of a distribution is defined as the maximum total cookies obtained by a single child in the distribution.\n\nThe most fair (and satisfying) distribution then would be to eat all the cookies yourself."
                    },
                    {
                        "username": "emilmohan24",
                        "content": "O(1) solution. Absolute genius. "
                    },
                    {
                        "username": "Stewie-Griffin",
                        "content": "I mean i can\\'t help to understand that why is it not of binary search  , its language is similar to most of binary search problems."
                    },
                    {
                        "username": "utkarshinobi",
                        "content": "[@vishalkgupta9821](/vishalkgupta9821) Thanks a lot! This was extremely helpful."
                    },
                    {
                        "username": "vishalkgupta9821",
                        "content": "we can solve this problem using binary search like problem 1011. Capacity To Ship Packages Within D Days\\nbut we need to generate all possible permutation of array in order to check unfairness.\\n\\n\\n//fist find the max in min like book allocation \\n    //repeat the process for all permutation\\n    bool ispossible(vector<int>&arr,int k,int mid){\\n        int count=1;\\n        int sum=0;\\n        for(auto  n:arr){\\n            sum+=n;\\n            if(sum>mid){\\n                count++;\\n                sum=n;\\n            }\\n        }\\n        return count<=k;\\n    }\\n\\n    int findMinMax(vector<int>&arr,int k){\\n        int low=0;\\n        int high=0;\\n        for(auto a:arr){\\n            low=max(a,low);\\n            high+=a;\\n        }\\n\\n        int ans=high;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(ispossible(arr,k,mid)){\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int ans=INT_MAX;\\n        sort(cookies.begin(),cookies.end());\\n        do{\\n            ans=min(ans,findMinMax(cookies,k));\\n        }while(next_permutation(cookies.begin(),cookies.end()));\\n\\n        return ans;\\n    }\\n\\n\\n"
                    },
                    {
                        "username": "user7717f",
                        "content": "We can use binary search in this problem to do the pruning by finding the upper bound in searching.\n\n```java\nclass Solution {\n    public int distributeCookies(int[] cookies, int k) {\n        Arrays.sort(cookies);\n        \n        int n = cookies.length, lb = cookies[n - 1], rb = cookies[n - 1] * n, ans = -1;\n        while (lb <= rb) {\n            int mb = lb + rb >> 1;\n\n            if (dfs(cookies, 0, new int[k], mb)) {\n                ans = mb;\n                rb = mb - 1;\n            }else {\n                lb = mb + 1;\n            }\n        }\n\n        return ans;\n    }\n\n    private boolean dfs(int[] cookies, int start, int[] nums, int mb) {\n        if (start == cookies.length) {\n            return true;\n        }\n\n        for (int i = 0; i < nums.length; ++i) {\n            if (nums[i] + cookies[start] <= mb) {\n                nums[i] += cookies[start];\n                if (dfs(cookies, start + 1, nums, mb)) {\n                    return true;\n                }\n                nums[i] -= cookies[start];\n            }\n            if (nums[i] == 0) {\n                return false;\n            }\n        }\n\n        return false;\n    }\n}\n```"
                    },
                    {
                        "username": "srk696772",
                        "content": "Because All the Problems we solved on binary Search Mentions Consecutiveness In the Description , But In The Above There is no Constraint on Consecutive Distribution so we cannot apply binary search here."
                    },
                    {
                        "username": "lalit10368",
                        "content": "[@akamboj](/akamboj) Thanks! for that justification. Hence, no boundary to search here."
                    },
                    {
                        "username": "lalit10368",
                        "content": "Hmm, I had a similar thought while solving. But I don\\'t know how to apply binary search over this. The constraints suggested brute force algorithm should work here. That\\'s why, I simply used bitmask & backtracking. Much easier than working out the binary search here."
                    },
                    {
                        "username": "akamboj",
                        "content": "because there is no contiguous allocation."
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "it's been  45+ minutes trying to solve this problem.. Am I dumb or most of the people are facing the same issue?"
                    },
                    {
                        "username": "emilmohan24",
                        "content": "Bro it takes me days sometimes lol\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "really struggling right now"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Brute force solution works"
                    },
                    {
                        "username": "akshatmaheshwar78",
                        "content": "Yah mate, this was hurting my brain until I took my paper and pen."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "[@longb1997](/longb1997) eveyones dumb mate until the same questions drops in interview"
                    },
                    {
                        "username": "longb1997",
                        "content": "i don't even think about backtracking\ni'm suck :((("
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "[@void_8t](/void_8t)  fr..."
                    },
                    {
                        "username": "meow_power",
                        "content": "you are not alone:("
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Who else thought it was binary search and then realized that the distribution is not contagious \\uD83D\\uDE22"
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This can be cone using binary search\\n\\n\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n\\n        def canDistribute(mid):\\n            children = [0] * k\\n            return assignCookies(0, mid, children)\\n        \\n        def assignCookies(index, mid, children):\\n            if index == len(cookies):\\n                return True\\n            curCookie = cookies[index]\\n            for i in range(k):\\n                if children[i] + curCookie <= mid:\\n                    children[i] += curCookie\\n                    if assignCookies(index + 1, mid, children):\\n                        return True\\n                    children[i] -= curCookie\\n                # If the child hasn\\'t been given any cookie, we break to avoid redundancies.\\n                if children[i] == 0:\\n                    break\\n            return False\\n        \\n        # Set the binary search range\\n        low, high = max(cookies), sum(cookies)\\n        while low < high:\\n            mid = (low + high) // 2\\n            if canDistribute(mid):\\n                high = mid\\n            else:\\n                low = mid + 1\\n\\n        return low\\n"
                    },
                    {
                        "username": "mt790191",
                        "content": "can u please elaborate what do you  mean by  distribution is not contagious and how it effects the solution"
                    },
                    {
                        "username": "_Aman_13_",
                        "content": "I not only thought but also code the BS solution, and also it accepted for 34 test cases. After that I realized that it will not work \\uD83D\\uDE2D"
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "also if it would have binary search question then array size also would have 1e5"
                    },
                    {
                        "username": "Jaiff",
                        "content": "*contiguous"
                    },
                    {
                        "username": "bortengineer",
                        "content": "Time limits for Python are too harsh (as always). Exact same naive backtracking solution that is good enough for c++ is no good for python, so you have to do additional optimizations."
                    },
                    {
                        "username": "dz_adman",
                        "content": "[@cswartzell](/cswartzell) I stand with the argument that equivalent solutions in any language should be acceptable. On the other hand, the fact that python is less efficient, is independent of how leetcode treat any language\\'s code."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@dz_adman](/dz_adman) That is meaningless. The point is that equivalent solutions for each language should be acceptable for each language, regardless of the time required to compute that solution IN the given language. The Time Limits are different for each language as is. \n\nAn equivalent Python solution to a passing C++ solution should absolutely count as valid"
                    },
                    {
                        "username": "dz_adman",
                        "content": "[python is less efficient](https://thenextweb.com/news/python-progamming-language-energy-analysis) than many other languages."
                    },
                    {
                        "username": "stefan1096",
                        "content": "I got TLE in Python3 but beats 56% in C++ with the same code(it only passed after an optimization)."
                    },
                    {
                        "username": "PencilBro27",
                        "content": "This problem is the same as\\n[1723. Find Minimum Time to Finish All Jobs](https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/description/)"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "https://leetcode.com/problems/matchsticks-to-square/\\nhttps://leetcode.com/problems/partition-to-k-equal-sum-subsets/\\nThese Two also Similar"
                    },
                    {
                        "username": "jason3410",
                        "content": "That\\'s a bit harder but still thx for the information."
                    },
                    {
                        "username": "AnywaySo",
                        "content": "Thank you, another problem was accepted."
                    },
                    {
                        "username": "charonme",
                        "content": "although 1723 has stricter time limits"
                    },
                    {
                        "username": "psionl0",
                        "content": "I hate backtracking. It is one of the few areas in algorithms that I can\\'t seem to master.\\n\\nAnd a sloppily worded editorial didn\\'t help. It took me 10 minutes to figure out that they said \"cookie\" they weren\\'t talking about an individual cookie but a bag of cookies."
                    },
                    {
                        "username": "cswartzell",
                        "content": "For me, its not that I cant master backtracking. The actual backtracking algo is almost silly trivial: Do a task, backtrack and undo it, redo the task a different way such that every combination is covered. The problem for me is recognizing: \"we are just going to have to try every combination. No greedy algorthim is going to shortcut these trials. Maybe there is some pruning we can do to early exit a trial branch, but effectively we need to check every branch\"\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "Me too, if it were single cookies, the question is much simpler. If it were single cookies, we would not need an array, we would just be given the total number of cookies. \\n\\nI still haven\\'t solved it."
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "Can anyone explain what do you all mean by saying there\\'s no continuous allocation?\\n"
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "[@JaAt_BhOi](/JaAt_BhOi) from the cookies array we can select cookies[i] in any order(random) need not be contiguous sub array....."
                    },
                    {
                        "username": "y-not",
                        "content": "Java Video Solution - \\nhttps://www.youtube.com/watch?v=kYQ5jXXhWYE"
                    }
                ]
            },
            {
                "id": 1951077,
                "content": [
                    {
                        "username": "JerExplosion",
                        "content": "We should teach the kids that the world is not always fair "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "Prolly should teach them how to build guillotines too. "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> The unfairness of a distribution is defined as the maximum total cookies obtained by a single child in the distribution.\n\nThe most fair (and satisfying) distribution then would be to eat all the cookies yourself."
                    },
                    {
                        "username": "emilmohan24",
                        "content": "O(1) solution. Absolute genius. "
                    },
                    {
                        "username": "Stewie-Griffin",
                        "content": "I mean i can\\'t help to understand that why is it not of binary search  , its language is similar to most of binary search problems."
                    },
                    {
                        "username": "utkarshinobi",
                        "content": "[@vishalkgupta9821](/vishalkgupta9821) Thanks a lot! This was extremely helpful."
                    },
                    {
                        "username": "vishalkgupta9821",
                        "content": "we can solve this problem using binary search like problem 1011. Capacity To Ship Packages Within D Days\\nbut we need to generate all possible permutation of array in order to check unfairness.\\n\\n\\n//fist find the max in min like book allocation \\n    //repeat the process for all permutation\\n    bool ispossible(vector<int>&arr,int k,int mid){\\n        int count=1;\\n        int sum=0;\\n        for(auto  n:arr){\\n            sum+=n;\\n            if(sum>mid){\\n                count++;\\n                sum=n;\\n            }\\n        }\\n        return count<=k;\\n    }\\n\\n    int findMinMax(vector<int>&arr,int k){\\n        int low=0;\\n        int high=0;\\n        for(auto a:arr){\\n            low=max(a,low);\\n            high+=a;\\n        }\\n\\n        int ans=high;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(ispossible(arr,k,mid)){\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int ans=INT_MAX;\\n        sort(cookies.begin(),cookies.end());\\n        do{\\n            ans=min(ans,findMinMax(cookies,k));\\n        }while(next_permutation(cookies.begin(),cookies.end()));\\n\\n        return ans;\\n    }\\n\\n\\n"
                    },
                    {
                        "username": "user7717f",
                        "content": "We can use binary search in this problem to do the pruning by finding the upper bound in searching.\n\n```java\nclass Solution {\n    public int distributeCookies(int[] cookies, int k) {\n        Arrays.sort(cookies);\n        \n        int n = cookies.length, lb = cookies[n - 1], rb = cookies[n - 1] * n, ans = -1;\n        while (lb <= rb) {\n            int mb = lb + rb >> 1;\n\n            if (dfs(cookies, 0, new int[k], mb)) {\n                ans = mb;\n                rb = mb - 1;\n            }else {\n                lb = mb + 1;\n            }\n        }\n\n        return ans;\n    }\n\n    private boolean dfs(int[] cookies, int start, int[] nums, int mb) {\n        if (start == cookies.length) {\n            return true;\n        }\n\n        for (int i = 0; i < nums.length; ++i) {\n            if (nums[i] + cookies[start] <= mb) {\n                nums[i] += cookies[start];\n                if (dfs(cookies, start + 1, nums, mb)) {\n                    return true;\n                }\n                nums[i] -= cookies[start];\n            }\n            if (nums[i] == 0) {\n                return false;\n            }\n        }\n\n        return false;\n    }\n}\n```"
                    },
                    {
                        "username": "srk696772",
                        "content": "Because All the Problems we solved on binary Search Mentions Consecutiveness In the Description , But In The Above There is no Constraint on Consecutive Distribution so we cannot apply binary search here."
                    },
                    {
                        "username": "lalit10368",
                        "content": "[@akamboj](/akamboj) Thanks! for that justification. Hence, no boundary to search here."
                    },
                    {
                        "username": "lalit10368",
                        "content": "Hmm, I had a similar thought while solving. But I don\\'t know how to apply binary search over this. The constraints suggested brute force algorithm should work here. That\\'s why, I simply used bitmask & backtracking. Much easier than working out the binary search here."
                    },
                    {
                        "username": "akamboj",
                        "content": "because there is no contiguous allocation."
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "it's been  45+ minutes trying to solve this problem.. Am I dumb or most of the people are facing the same issue?"
                    },
                    {
                        "username": "emilmohan24",
                        "content": "Bro it takes me days sometimes lol\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "really struggling right now"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Brute force solution works"
                    },
                    {
                        "username": "akshatmaheshwar78",
                        "content": "Yah mate, this was hurting my brain until I took my paper and pen."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "[@longb1997](/longb1997) eveyones dumb mate until the same questions drops in interview"
                    },
                    {
                        "username": "longb1997",
                        "content": "i don't even think about backtracking\ni'm suck :((("
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "[@void_8t](/void_8t)  fr..."
                    },
                    {
                        "username": "meow_power",
                        "content": "you are not alone:("
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Who else thought it was binary search and then realized that the distribution is not contagious \\uD83D\\uDE22"
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This can be cone using binary search\\n\\n\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n\\n        def canDistribute(mid):\\n            children = [0] * k\\n            return assignCookies(0, mid, children)\\n        \\n        def assignCookies(index, mid, children):\\n            if index == len(cookies):\\n                return True\\n            curCookie = cookies[index]\\n            for i in range(k):\\n                if children[i] + curCookie <= mid:\\n                    children[i] += curCookie\\n                    if assignCookies(index + 1, mid, children):\\n                        return True\\n                    children[i] -= curCookie\\n                # If the child hasn\\'t been given any cookie, we break to avoid redundancies.\\n                if children[i] == 0:\\n                    break\\n            return False\\n        \\n        # Set the binary search range\\n        low, high = max(cookies), sum(cookies)\\n        while low < high:\\n            mid = (low + high) // 2\\n            if canDistribute(mid):\\n                high = mid\\n            else:\\n                low = mid + 1\\n\\n        return low\\n"
                    },
                    {
                        "username": "mt790191",
                        "content": "can u please elaborate what do you  mean by  distribution is not contagious and how it effects the solution"
                    },
                    {
                        "username": "_Aman_13_",
                        "content": "I not only thought but also code the BS solution, and also it accepted for 34 test cases. After that I realized that it will not work \\uD83D\\uDE2D"
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "also if it would have binary search question then array size also would have 1e5"
                    },
                    {
                        "username": "Jaiff",
                        "content": "*contiguous"
                    },
                    {
                        "username": "bortengineer",
                        "content": "Time limits for Python are too harsh (as always). Exact same naive backtracking solution that is good enough for c++ is no good for python, so you have to do additional optimizations."
                    },
                    {
                        "username": "dz_adman",
                        "content": "[@cswartzell](/cswartzell) I stand with the argument that equivalent solutions in any language should be acceptable. On the other hand, the fact that python is less efficient, is independent of how leetcode treat any language\\'s code."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@dz_adman](/dz_adman) That is meaningless. The point is that equivalent solutions for each language should be acceptable for each language, regardless of the time required to compute that solution IN the given language. The Time Limits are different for each language as is. \n\nAn equivalent Python solution to a passing C++ solution should absolutely count as valid"
                    },
                    {
                        "username": "dz_adman",
                        "content": "[python is less efficient](https://thenextweb.com/news/python-progamming-language-energy-analysis) than many other languages."
                    },
                    {
                        "username": "stefan1096",
                        "content": "I got TLE in Python3 but beats 56% in C++ with the same code(it only passed after an optimization)."
                    },
                    {
                        "username": "PencilBro27",
                        "content": "This problem is the same as\\n[1723. Find Minimum Time to Finish All Jobs](https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/description/)"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "https://leetcode.com/problems/matchsticks-to-square/\\nhttps://leetcode.com/problems/partition-to-k-equal-sum-subsets/\\nThese Two also Similar"
                    },
                    {
                        "username": "jason3410",
                        "content": "That\\'s a bit harder but still thx for the information."
                    },
                    {
                        "username": "AnywaySo",
                        "content": "Thank you, another problem was accepted."
                    },
                    {
                        "username": "charonme",
                        "content": "although 1723 has stricter time limits"
                    },
                    {
                        "username": "psionl0",
                        "content": "I hate backtracking. It is one of the few areas in algorithms that I can\\'t seem to master.\\n\\nAnd a sloppily worded editorial didn\\'t help. It took me 10 minutes to figure out that they said \"cookie\" they weren\\'t talking about an individual cookie but a bag of cookies."
                    },
                    {
                        "username": "cswartzell",
                        "content": "For me, its not that I cant master backtracking. The actual backtracking algo is almost silly trivial: Do a task, backtrack and undo it, redo the task a different way such that every combination is covered. The problem for me is recognizing: \"we are just going to have to try every combination. No greedy algorthim is going to shortcut these trials. Maybe there is some pruning we can do to early exit a trial branch, but effectively we need to check every branch\"\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "Me too, if it were single cookies, the question is much simpler. If it were single cookies, we would not need an array, we would just be given the total number of cookies. \\n\\nI still haven\\'t solved it."
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "Can anyone explain what do you all mean by saying there\\'s no continuous allocation?\\n"
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "[@JaAt_BhOi](/JaAt_BhOi) from the cookies array we can select cookies[i] in any order(random) need not be contiguous sub array....."
                    },
                    {
                        "username": "y-not",
                        "content": "Java Video Solution - \\nhttps://www.youtube.com/watch?v=kYQ5jXXhWYE"
                    }
                ]
            },
            {
                "id": 1576890,
                "content": [
                    {
                        "username": "JerExplosion",
                        "content": "We should teach the kids that the world is not always fair "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "Prolly should teach them how to build guillotines too. "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> The unfairness of a distribution is defined as the maximum total cookies obtained by a single child in the distribution.\n\nThe most fair (and satisfying) distribution then would be to eat all the cookies yourself."
                    },
                    {
                        "username": "emilmohan24",
                        "content": "O(1) solution. Absolute genius. "
                    },
                    {
                        "username": "Stewie-Griffin",
                        "content": "I mean i can\\'t help to understand that why is it not of binary search  , its language is similar to most of binary search problems."
                    },
                    {
                        "username": "utkarshinobi",
                        "content": "[@vishalkgupta9821](/vishalkgupta9821) Thanks a lot! This was extremely helpful."
                    },
                    {
                        "username": "vishalkgupta9821",
                        "content": "we can solve this problem using binary search like problem 1011. Capacity To Ship Packages Within D Days\\nbut we need to generate all possible permutation of array in order to check unfairness.\\n\\n\\n//fist find the max in min like book allocation \\n    //repeat the process for all permutation\\n    bool ispossible(vector<int>&arr,int k,int mid){\\n        int count=1;\\n        int sum=0;\\n        for(auto  n:arr){\\n            sum+=n;\\n            if(sum>mid){\\n                count++;\\n                sum=n;\\n            }\\n        }\\n        return count<=k;\\n    }\\n\\n    int findMinMax(vector<int>&arr,int k){\\n        int low=0;\\n        int high=0;\\n        for(auto a:arr){\\n            low=max(a,low);\\n            high+=a;\\n        }\\n\\n        int ans=high;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(ispossible(arr,k,mid)){\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int ans=INT_MAX;\\n        sort(cookies.begin(),cookies.end());\\n        do{\\n            ans=min(ans,findMinMax(cookies,k));\\n        }while(next_permutation(cookies.begin(),cookies.end()));\\n\\n        return ans;\\n    }\\n\\n\\n"
                    },
                    {
                        "username": "user7717f",
                        "content": "We can use binary search in this problem to do the pruning by finding the upper bound in searching.\n\n```java\nclass Solution {\n    public int distributeCookies(int[] cookies, int k) {\n        Arrays.sort(cookies);\n        \n        int n = cookies.length, lb = cookies[n - 1], rb = cookies[n - 1] * n, ans = -1;\n        while (lb <= rb) {\n            int mb = lb + rb >> 1;\n\n            if (dfs(cookies, 0, new int[k], mb)) {\n                ans = mb;\n                rb = mb - 1;\n            }else {\n                lb = mb + 1;\n            }\n        }\n\n        return ans;\n    }\n\n    private boolean dfs(int[] cookies, int start, int[] nums, int mb) {\n        if (start == cookies.length) {\n            return true;\n        }\n\n        for (int i = 0; i < nums.length; ++i) {\n            if (nums[i] + cookies[start] <= mb) {\n                nums[i] += cookies[start];\n                if (dfs(cookies, start + 1, nums, mb)) {\n                    return true;\n                }\n                nums[i] -= cookies[start];\n            }\n            if (nums[i] == 0) {\n                return false;\n            }\n        }\n\n        return false;\n    }\n}\n```"
                    },
                    {
                        "username": "srk696772",
                        "content": "Because All the Problems we solved on binary Search Mentions Consecutiveness In the Description , But In The Above There is no Constraint on Consecutive Distribution so we cannot apply binary search here."
                    },
                    {
                        "username": "lalit10368",
                        "content": "[@akamboj](/akamboj) Thanks! for that justification. Hence, no boundary to search here."
                    },
                    {
                        "username": "lalit10368",
                        "content": "Hmm, I had a similar thought while solving. But I don\\'t know how to apply binary search over this. The constraints suggested brute force algorithm should work here. That\\'s why, I simply used bitmask & backtracking. Much easier than working out the binary search here."
                    },
                    {
                        "username": "akamboj",
                        "content": "because there is no contiguous allocation."
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "it's been  45+ minutes trying to solve this problem.. Am I dumb or most of the people are facing the same issue?"
                    },
                    {
                        "username": "emilmohan24",
                        "content": "Bro it takes me days sometimes lol\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "really struggling right now"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Brute force solution works"
                    },
                    {
                        "username": "akshatmaheshwar78",
                        "content": "Yah mate, this was hurting my brain until I took my paper and pen."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "[@longb1997](/longb1997) eveyones dumb mate until the same questions drops in interview"
                    },
                    {
                        "username": "longb1997",
                        "content": "i don't even think about backtracking\ni'm suck :((("
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "[@void_8t](/void_8t)  fr..."
                    },
                    {
                        "username": "meow_power",
                        "content": "you are not alone:("
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Who else thought it was binary search and then realized that the distribution is not contagious \\uD83D\\uDE22"
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This can be cone using binary search\\n\\n\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n\\n        def canDistribute(mid):\\n            children = [0] * k\\n            return assignCookies(0, mid, children)\\n        \\n        def assignCookies(index, mid, children):\\n            if index == len(cookies):\\n                return True\\n            curCookie = cookies[index]\\n            for i in range(k):\\n                if children[i] + curCookie <= mid:\\n                    children[i] += curCookie\\n                    if assignCookies(index + 1, mid, children):\\n                        return True\\n                    children[i] -= curCookie\\n                # If the child hasn\\'t been given any cookie, we break to avoid redundancies.\\n                if children[i] == 0:\\n                    break\\n            return False\\n        \\n        # Set the binary search range\\n        low, high = max(cookies), sum(cookies)\\n        while low < high:\\n            mid = (low + high) // 2\\n            if canDistribute(mid):\\n                high = mid\\n            else:\\n                low = mid + 1\\n\\n        return low\\n"
                    },
                    {
                        "username": "mt790191",
                        "content": "can u please elaborate what do you  mean by  distribution is not contagious and how it effects the solution"
                    },
                    {
                        "username": "_Aman_13_",
                        "content": "I not only thought but also code the BS solution, and also it accepted for 34 test cases. After that I realized that it will not work \\uD83D\\uDE2D"
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "also if it would have binary search question then array size also would have 1e5"
                    },
                    {
                        "username": "Jaiff",
                        "content": "*contiguous"
                    },
                    {
                        "username": "bortengineer",
                        "content": "Time limits for Python are too harsh (as always). Exact same naive backtracking solution that is good enough for c++ is no good for python, so you have to do additional optimizations."
                    },
                    {
                        "username": "dz_adman",
                        "content": "[@cswartzell](/cswartzell) I stand with the argument that equivalent solutions in any language should be acceptable. On the other hand, the fact that python is less efficient, is independent of how leetcode treat any language\\'s code."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@dz_adman](/dz_adman) That is meaningless. The point is that equivalent solutions for each language should be acceptable for each language, regardless of the time required to compute that solution IN the given language. The Time Limits are different for each language as is. \n\nAn equivalent Python solution to a passing C++ solution should absolutely count as valid"
                    },
                    {
                        "username": "dz_adman",
                        "content": "[python is less efficient](https://thenextweb.com/news/python-progamming-language-energy-analysis) than many other languages."
                    },
                    {
                        "username": "stefan1096",
                        "content": "I got TLE in Python3 but beats 56% in C++ with the same code(it only passed after an optimization)."
                    },
                    {
                        "username": "PencilBro27",
                        "content": "This problem is the same as\\n[1723. Find Minimum Time to Finish All Jobs](https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/description/)"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "https://leetcode.com/problems/matchsticks-to-square/\\nhttps://leetcode.com/problems/partition-to-k-equal-sum-subsets/\\nThese Two also Similar"
                    },
                    {
                        "username": "jason3410",
                        "content": "That\\'s a bit harder but still thx for the information."
                    },
                    {
                        "username": "AnywaySo",
                        "content": "Thank you, another problem was accepted."
                    },
                    {
                        "username": "charonme",
                        "content": "although 1723 has stricter time limits"
                    },
                    {
                        "username": "psionl0",
                        "content": "I hate backtracking. It is one of the few areas in algorithms that I can\\'t seem to master.\\n\\nAnd a sloppily worded editorial didn\\'t help. It took me 10 minutes to figure out that they said \"cookie\" they weren\\'t talking about an individual cookie but a bag of cookies."
                    },
                    {
                        "username": "cswartzell",
                        "content": "For me, its not that I cant master backtracking. The actual backtracking algo is almost silly trivial: Do a task, backtrack and undo it, redo the task a different way such that every combination is covered. The problem for me is recognizing: \"we are just going to have to try every combination. No greedy algorthim is going to shortcut these trials. Maybe there is some pruning we can do to early exit a trial branch, but effectively we need to check every branch\"\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "Me too, if it were single cookies, the question is much simpler. If it were single cookies, we would not need an array, we would just be given the total number of cookies. \\n\\nI still haven\\'t solved it."
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "Can anyone explain what do you all mean by saying there\\'s no continuous allocation?\\n"
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "[@JaAt_BhOi](/JaAt_BhOi) from the cookies array we can select cookies[i] in any order(random) need not be contiguous sub array....."
                    },
                    {
                        "username": "y-not",
                        "content": "Java Video Solution - \\nhttps://www.youtube.com/watch?v=kYQ5jXXhWYE"
                    }
                ]
            },
            {
                "id": 1951220,
                "content": [
                    {
                        "username": "JerExplosion",
                        "content": "We should teach the kids that the world is not always fair "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "Prolly should teach them how to build guillotines too. "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> The unfairness of a distribution is defined as the maximum total cookies obtained by a single child in the distribution.\n\nThe most fair (and satisfying) distribution then would be to eat all the cookies yourself."
                    },
                    {
                        "username": "emilmohan24",
                        "content": "O(1) solution. Absolute genius. "
                    },
                    {
                        "username": "Stewie-Griffin",
                        "content": "I mean i can\\'t help to understand that why is it not of binary search  , its language is similar to most of binary search problems."
                    },
                    {
                        "username": "utkarshinobi",
                        "content": "[@vishalkgupta9821](/vishalkgupta9821) Thanks a lot! This was extremely helpful."
                    },
                    {
                        "username": "vishalkgupta9821",
                        "content": "we can solve this problem using binary search like problem 1011. Capacity To Ship Packages Within D Days\\nbut we need to generate all possible permutation of array in order to check unfairness.\\n\\n\\n//fist find the max in min like book allocation \\n    //repeat the process for all permutation\\n    bool ispossible(vector<int>&arr,int k,int mid){\\n        int count=1;\\n        int sum=0;\\n        for(auto  n:arr){\\n            sum+=n;\\n            if(sum>mid){\\n                count++;\\n                sum=n;\\n            }\\n        }\\n        return count<=k;\\n    }\\n\\n    int findMinMax(vector<int>&arr,int k){\\n        int low=0;\\n        int high=0;\\n        for(auto a:arr){\\n            low=max(a,low);\\n            high+=a;\\n        }\\n\\n        int ans=high;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(ispossible(arr,k,mid)){\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int ans=INT_MAX;\\n        sort(cookies.begin(),cookies.end());\\n        do{\\n            ans=min(ans,findMinMax(cookies,k));\\n        }while(next_permutation(cookies.begin(),cookies.end()));\\n\\n        return ans;\\n    }\\n\\n\\n"
                    },
                    {
                        "username": "user7717f",
                        "content": "We can use binary search in this problem to do the pruning by finding the upper bound in searching.\n\n```java\nclass Solution {\n    public int distributeCookies(int[] cookies, int k) {\n        Arrays.sort(cookies);\n        \n        int n = cookies.length, lb = cookies[n - 1], rb = cookies[n - 1] * n, ans = -1;\n        while (lb <= rb) {\n            int mb = lb + rb >> 1;\n\n            if (dfs(cookies, 0, new int[k], mb)) {\n                ans = mb;\n                rb = mb - 1;\n            }else {\n                lb = mb + 1;\n            }\n        }\n\n        return ans;\n    }\n\n    private boolean dfs(int[] cookies, int start, int[] nums, int mb) {\n        if (start == cookies.length) {\n            return true;\n        }\n\n        for (int i = 0; i < nums.length; ++i) {\n            if (nums[i] + cookies[start] <= mb) {\n                nums[i] += cookies[start];\n                if (dfs(cookies, start + 1, nums, mb)) {\n                    return true;\n                }\n                nums[i] -= cookies[start];\n            }\n            if (nums[i] == 0) {\n                return false;\n            }\n        }\n\n        return false;\n    }\n}\n```"
                    },
                    {
                        "username": "srk696772",
                        "content": "Because All the Problems we solved on binary Search Mentions Consecutiveness In the Description , But In The Above There is no Constraint on Consecutive Distribution so we cannot apply binary search here."
                    },
                    {
                        "username": "lalit10368",
                        "content": "[@akamboj](/akamboj) Thanks! for that justification. Hence, no boundary to search here."
                    },
                    {
                        "username": "lalit10368",
                        "content": "Hmm, I had a similar thought while solving. But I don\\'t know how to apply binary search over this. The constraints suggested brute force algorithm should work here. That\\'s why, I simply used bitmask & backtracking. Much easier than working out the binary search here."
                    },
                    {
                        "username": "akamboj",
                        "content": "because there is no contiguous allocation."
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "it's been  45+ minutes trying to solve this problem.. Am I dumb or most of the people are facing the same issue?"
                    },
                    {
                        "username": "emilmohan24",
                        "content": "Bro it takes me days sometimes lol\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "really struggling right now"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Brute force solution works"
                    },
                    {
                        "username": "akshatmaheshwar78",
                        "content": "Yah mate, this was hurting my brain until I took my paper and pen."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "[@longb1997](/longb1997) eveyones dumb mate until the same questions drops in interview"
                    },
                    {
                        "username": "longb1997",
                        "content": "i don't even think about backtracking\ni'm suck :((("
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "[@void_8t](/void_8t)  fr..."
                    },
                    {
                        "username": "meow_power",
                        "content": "you are not alone:("
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Who else thought it was binary search and then realized that the distribution is not contagious \\uD83D\\uDE22"
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This can be cone using binary search\\n\\n\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n\\n        def canDistribute(mid):\\n            children = [0] * k\\n            return assignCookies(0, mid, children)\\n        \\n        def assignCookies(index, mid, children):\\n            if index == len(cookies):\\n                return True\\n            curCookie = cookies[index]\\n            for i in range(k):\\n                if children[i] + curCookie <= mid:\\n                    children[i] += curCookie\\n                    if assignCookies(index + 1, mid, children):\\n                        return True\\n                    children[i] -= curCookie\\n                # If the child hasn\\'t been given any cookie, we break to avoid redundancies.\\n                if children[i] == 0:\\n                    break\\n            return False\\n        \\n        # Set the binary search range\\n        low, high = max(cookies), sum(cookies)\\n        while low < high:\\n            mid = (low + high) // 2\\n            if canDistribute(mid):\\n                high = mid\\n            else:\\n                low = mid + 1\\n\\n        return low\\n"
                    },
                    {
                        "username": "mt790191",
                        "content": "can u please elaborate what do you  mean by  distribution is not contagious and how it effects the solution"
                    },
                    {
                        "username": "_Aman_13_",
                        "content": "I not only thought but also code the BS solution, and also it accepted for 34 test cases. After that I realized that it will not work \\uD83D\\uDE2D"
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "also if it would have binary search question then array size also would have 1e5"
                    },
                    {
                        "username": "Jaiff",
                        "content": "*contiguous"
                    },
                    {
                        "username": "bortengineer",
                        "content": "Time limits for Python are too harsh (as always). Exact same naive backtracking solution that is good enough for c++ is no good for python, so you have to do additional optimizations."
                    },
                    {
                        "username": "dz_adman",
                        "content": "[@cswartzell](/cswartzell) I stand with the argument that equivalent solutions in any language should be acceptable. On the other hand, the fact that python is less efficient, is independent of how leetcode treat any language\\'s code."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@dz_adman](/dz_adman) That is meaningless. The point is that equivalent solutions for each language should be acceptable for each language, regardless of the time required to compute that solution IN the given language. The Time Limits are different for each language as is. \n\nAn equivalent Python solution to a passing C++ solution should absolutely count as valid"
                    },
                    {
                        "username": "dz_adman",
                        "content": "[python is less efficient](https://thenextweb.com/news/python-progamming-language-energy-analysis) than many other languages."
                    },
                    {
                        "username": "stefan1096",
                        "content": "I got TLE in Python3 but beats 56% in C++ with the same code(it only passed after an optimization)."
                    },
                    {
                        "username": "PencilBro27",
                        "content": "This problem is the same as\\n[1723. Find Minimum Time to Finish All Jobs](https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/description/)"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "https://leetcode.com/problems/matchsticks-to-square/\\nhttps://leetcode.com/problems/partition-to-k-equal-sum-subsets/\\nThese Two also Similar"
                    },
                    {
                        "username": "jason3410",
                        "content": "That\\'s a bit harder but still thx for the information."
                    },
                    {
                        "username": "AnywaySo",
                        "content": "Thank you, another problem was accepted."
                    },
                    {
                        "username": "charonme",
                        "content": "although 1723 has stricter time limits"
                    },
                    {
                        "username": "psionl0",
                        "content": "I hate backtracking. It is one of the few areas in algorithms that I can\\'t seem to master.\\n\\nAnd a sloppily worded editorial didn\\'t help. It took me 10 minutes to figure out that they said \"cookie\" they weren\\'t talking about an individual cookie but a bag of cookies."
                    },
                    {
                        "username": "cswartzell",
                        "content": "For me, its not that I cant master backtracking. The actual backtracking algo is almost silly trivial: Do a task, backtrack and undo it, redo the task a different way such that every combination is covered. The problem for me is recognizing: \"we are just going to have to try every combination. No greedy algorthim is going to shortcut these trials. Maybe there is some pruning we can do to early exit a trial branch, but effectively we need to check every branch\"\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "Me too, if it were single cookies, the question is much simpler. If it were single cookies, we would not need an array, we would just be given the total number of cookies. \\n\\nI still haven\\'t solved it."
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "Can anyone explain what do you all mean by saying there\\'s no continuous allocation?\\n"
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "[@JaAt_BhOi](/JaAt_BhOi) from the cookies array we can select cookies[i] in any order(random) need not be contiguous sub array....."
                    },
                    {
                        "username": "y-not",
                        "content": "Java Video Solution - \\nhttps://www.youtube.com/watch?v=kYQ5jXXhWYE"
                    }
                ]
            },
            {
                "id": 1951180,
                "content": [
                    {
                        "username": "JerExplosion",
                        "content": "We should teach the kids that the world is not always fair "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "Prolly should teach them how to build guillotines too. "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> The unfairness of a distribution is defined as the maximum total cookies obtained by a single child in the distribution.\n\nThe most fair (and satisfying) distribution then would be to eat all the cookies yourself."
                    },
                    {
                        "username": "emilmohan24",
                        "content": "O(1) solution. Absolute genius. "
                    },
                    {
                        "username": "Stewie-Griffin",
                        "content": "I mean i can\\'t help to understand that why is it not of binary search  , its language is similar to most of binary search problems."
                    },
                    {
                        "username": "utkarshinobi",
                        "content": "[@vishalkgupta9821](/vishalkgupta9821) Thanks a lot! This was extremely helpful."
                    },
                    {
                        "username": "vishalkgupta9821",
                        "content": "we can solve this problem using binary search like problem 1011. Capacity To Ship Packages Within D Days\\nbut we need to generate all possible permutation of array in order to check unfairness.\\n\\n\\n//fist find the max in min like book allocation \\n    //repeat the process for all permutation\\n    bool ispossible(vector<int>&arr,int k,int mid){\\n        int count=1;\\n        int sum=0;\\n        for(auto  n:arr){\\n            sum+=n;\\n            if(sum>mid){\\n                count++;\\n                sum=n;\\n            }\\n        }\\n        return count<=k;\\n    }\\n\\n    int findMinMax(vector<int>&arr,int k){\\n        int low=0;\\n        int high=0;\\n        for(auto a:arr){\\n            low=max(a,low);\\n            high+=a;\\n        }\\n\\n        int ans=high;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(ispossible(arr,k,mid)){\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int ans=INT_MAX;\\n        sort(cookies.begin(),cookies.end());\\n        do{\\n            ans=min(ans,findMinMax(cookies,k));\\n        }while(next_permutation(cookies.begin(),cookies.end()));\\n\\n        return ans;\\n    }\\n\\n\\n"
                    },
                    {
                        "username": "user7717f",
                        "content": "We can use binary search in this problem to do the pruning by finding the upper bound in searching.\n\n```java\nclass Solution {\n    public int distributeCookies(int[] cookies, int k) {\n        Arrays.sort(cookies);\n        \n        int n = cookies.length, lb = cookies[n - 1], rb = cookies[n - 1] * n, ans = -1;\n        while (lb <= rb) {\n            int mb = lb + rb >> 1;\n\n            if (dfs(cookies, 0, new int[k], mb)) {\n                ans = mb;\n                rb = mb - 1;\n            }else {\n                lb = mb + 1;\n            }\n        }\n\n        return ans;\n    }\n\n    private boolean dfs(int[] cookies, int start, int[] nums, int mb) {\n        if (start == cookies.length) {\n            return true;\n        }\n\n        for (int i = 0; i < nums.length; ++i) {\n            if (nums[i] + cookies[start] <= mb) {\n                nums[i] += cookies[start];\n                if (dfs(cookies, start + 1, nums, mb)) {\n                    return true;\n                }\n                nums[i] -= cookies[start];\n            }\n            if (nums[i] == 0) {\n                return false;\n            }\n        }\n\n        return false;\n    }\n}\n```"
                    },
                    {
                        "username": "srk696772",
                        "content": "Because All the Problems we solved on binary Search Mentions Consecutiveness In the Description , But In The Above There is no Constraint on Consecutive Distribution so we cannot apply binary search here."
                    },
                    {
                        "username": "lalit10368",
                        "content": "[@akamboj](/akamboj) Thanks! for that justification. Hence, no boundary to search here."
                    },
                    {
                        "username": "lalit10368",
                        "content": "Hmm, I had a similar thought while solving. But I don\\'t know how to apply binary search over this. The constraints suggested brute force algorithm should work here. That\\'s why, I simply used bitmask & backtracking. Much easier than working out the binary search here."
                    },
                    {
                        "username": "akamboj",
                        "content": "because there is no contiguous allocation."
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "it's been  45+ minutes trying to solve this problem.. Am I dumb or most of the people are facing the same issue?"
                    },
                    {
                        "username": "emilmohan24",
                        "content": "Bro it takes me days sometimes lol\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "really struggling right now"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Brute force solution works"
                    },
                    {
                        "username": "akshatmaheshwar78",
                        "content": "Yah mate, this was hurting my brain until I took my paper and pen."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "[@longb1997](/longb1997) eveyones dumb mate until the same questions drops in interview"
                    },
                    {
                        "username": "longb1997",
                        "content": "i don't even think about backtracking\ni'm suck :((("
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "[@void_8t](/void_8t)  fr..."
                    },
                    {
                        "username": "meow_power",
                        "content": "you are not alone:("
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Who else thought it was binary search and then realized that the distribution is not contagious \\uD83D\\uDE22"
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This can be cone using binary search\\n\\n\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n\\n        def canDistribute(mid):\\n            children = [0] * k\\n            return assignCookies(0, mid, children)\\n        \\n        def assignCookies(index, mid, children):\\n            if index == len(cookies):\\n                return True\\n            curCookie = cookies[index]\\n            for i in range(k):\\n                if children[i] + curCookie <= mid:\\n                    children[i] += curCookie\\n                    if assignCookies(index + 1, mid, children):\\n                        return True\\n                    children[i] -= curCookie\\n                # If the child hasn\\'t been given any cookie, we break to avoid redundancies.\\n                if children[i] == 0:\\n                    break\\n            return False\\n        \\n        # Set the binary search range\\n        low, high = max(cookies), sum(cookies)\\n        while low < high:\\n            mid = (low + high) // 2\\n            if canDistribute(mid):\\n                high = mid\\n            else:\\n                low = mid + 1\\n\\n        return low\\n"
                    },
                    {
                        "username": "mt790191",
                        "content": "can u please elaborate what do you  mean by  distribution is not contagious and how it effects the solution"
                    },
                    {
                        "username": "_Aman_13_",
                        "content": "I not only thought but also code the BS solution, and also it accepted for 34 test cases. After that I realized that it will not work \\uD83D\\uDE2D"
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "also if it would have binary search question then array size also would have 1e5"
                    },
                    {
                        "username": "Jaiff",
                        "content": "*contiguous"
                    },
                    {
                        "username": "bortengineer",
                        "content": "Time limits for Python are too harsh (as always). Exact same naive backtracking solution that is good enough for c++ is no good for python, so you have to do additional optimizations."
                    },
                    {
                        "username": "dz_adman",
                        "content": "[@cswartzell](/cswartzell) I stand with the argument that equivalent solutions in any language should be acceptable. On the other hand, the fact that python is less efficient, is independent of how leetcode treat any language\\'s code."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@dz_adman](/dz_adman) That is meaningless. The point is that equivalent solutions for each language should be acceptable for each language, regardless of the time required to compute that solution IN the given language. The Time Limits are different for each language as is. \n\nAn equivalent Python solution to a passing C++ solution should absolutely count as valid"
                    },
                    {
                        "username": "dz_adman",
                        "content": "[python is less efficient](https://thenextweb.com/news/python-progamming-language-energy-analysis) than many other languages."
                    },
                    {
                        "username": "stefan1096",
                        "content": "I got TLE in Python3 but beats 56% in C++ with the same code(it only passed after an optimization)."
                    },
                    {
                        "username": "PencilBro27",
                        "content": "This problem is the same as\\n[1723. Find Minimum Time to Finish All Jobs](https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/description/)"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "https://leetcode.com/problems/matchsticks-to-square/\\nhttps://leetcode.com/problems/partition-to-k-equal-sum-subsets/\\nThese Two also Similar"
                    },
                    {
                        "username": "jason3410",
                        "content": "That\\'s a bit harder but still thx for the information."
                    },
                    {
                        "username": "AnywaySo",
                        "content": "Thank you, another problem was accepted."
                    },
                    {
                        "username": "charonme",
                        "content": "although 1723 has stricter time limits"
                    },
                    {
                        "username": "psionl0",
                        "content": "I hate backtracking. It is one of the few areas in algorithms that I can\\'t seem to master.\\n\\nAnd a sloppily worded editorial didn\\'t help. It took me 10 minutes to figure out that they said \"cookie\" they weren\\'t talking about an individual cookie but a bag of cookies."
                    },
                    {
                        "username": "cswartzell",
                        "content": "For me, its not that I cant master backtracking. The actual backtracking algo is almost silly trivial: Do a task, backtrack and undo it, redo the task a different way such that every combination is covered. The problem for me is recognizing: \"we are just going to have to try every combination. No greedy algorthim is going to shortcut these trials. Maybe there is some pruning we can do to early exit a trial branch, but effectively we need to check every branch\"\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "Me too, if it were single cookies, the question is much simpler. If it were single cookies, we would not need an array, we would just be given the total number of cookies. \\n\\nI still haven\\'t solved it."
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "Can anyone explain what do you all mean by saying there\\'s no continuous allocation?\\n"
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "[@JaAt_BhOi](/JaAt_BhOi) from the cookies array we can select cookies[i] in any order(random) need not be contiguous sub array....."
                    },
                    {
                        "username": "y-not",
                        "content": "Java Video Solution - \\nhttps://www.youtube.com/watch?v=kYQ5jXXhWYE"
                    }
                ]
            },
            {
                "id": 1826418,
                "content": [
                    {
                        "username": "JerExplosion",
                        "content": "We should teach the kids that the world is not always fair "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "Prolly should teach them how to build guillotines too. "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> The unfairness of a distribution is defined as the maximum total cookies obtained by a single child in the distribution.\n\nThe most fair (and satisfying) distribution then would be to eat all the cookies yourself."
                    },
                    {
                        "username": "emilmohan24",
                        "content": "O(1) solution. Absolute genius. "
                    },
                    {
                        "username": "Stewie-Griffin",
                        "content": "I mean i can\\'t help to understand that why is it not of binary search  , its language is similar to most of binary search problems."
                    },
                    {
                        "username": "utkarshinobi",
                        "content": "[@vishalkgupta9821](/vishalkgupta9821) Thanks a lot! This was extremely helpful."
                    },
                    {
                        "username": "vishalkgupta9821",
                        "content": "we can solve this problem using binary search like problem 1011. Capacity To Ship Packages Within D Days\\nbut we need to generate all possible permutation of array in order to check unfairness.\\n\\n\\n//fist find the max in min like book allocation \\n    //repeat the process for all permutation\\n    bool ispossible(vector<int>&arr,int k,int mid){\\n        int count=1;\\n        int sum=0;\\n        for(auto  n:arr){\\n            sum+=n;\\n            if(sum>mid){\\n                count++;\\n                sum=n;\\n            }\\n        }\\n        return count<=k;\\n    }\\n\\n    int findMinMax(vector<int>&arr,int k){\\n        int low=0;\\n        int high=0;\\n        for(auto a:arr){\\n            low=max(a,low);\\n            high+=a;\\n        }\\n\\n        int ans=high;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(ispossible(arr,k,mid)){\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int ans=INT_MAX;\\n        sort(cookies.begin(),cookies.end());\\n        do{\\n            ans=min(ans,findMinMax(cookies,k));\\n        }while(next_permutation(cookies.begin(),cookies.end()));\\n\\n        return ans;\\n    }\\n\\n\\n"
                    },
                    {
                        "username": "user7717f",
                        "content": "We can use binary search in this problem to do the pruning by finding the upper bound in searching.\n\n```java\nclass Solution {\n    public int distributeCookies(int[] cookies, int k) {\n        Arrays.sort(cookies);\n        \n        int n = cookies.length, lb = cookies[n - 1], rb = cookies[n - 1] * n, ans = -1;\n        while (lb <= rb) {\n            int mb = lb + rb >> 1;\n\n            if (dfs(cookies, 0, new int[k], mb)) {\n                ans = mb;\n                rb = mb - 1;\n            }else {\n                lb = mb + 1;\n            }\n        }\n\n        return ans;\n    }\n\n    private boolean dfs(int[] cookies, int start, int[] nums, int mb) {\n        if (start == cookies.length) {\n            return true;\n        }\n\n        for (int i = 0; i < nums.length; ++i) {\n            if (nums[i] + cookies[start] <= mb) {\n                nums[i] += cookies[start];\n                if (dfs(cookies, start + 1, nums, mb)) {\n                    return true;\n                }\n                nums[i] -= cookies[start];\n            }\n            if (nums[i] == 0) {\n                return false;\n            }\n        }\n\n        return false;\n    }\n}\n```"
                    },
                    {
                        "username": "srk696772",
                        "content": "Because All the Problems we solved on binary Search Mentions Consecutiveness In the Description , But In The Above There is no Constraint on Consecutive Distribution so we cannot apply binary search here."
                    },
                    {
                        "username": "lalit10368",
                        "content": "[@akamboj](/akamboj) Thanks! for that justification. Hence, no boundary to search here."
                    },
                    {
                        "username": "lalit10368",
                        "content": "Hmm, I had a similar thought while solving. But I don\\'t know how to apply binary search over this. The constraints suggested brute force algorithm should work here. That\\'s why, I simply used bitmask & backtracking. Much easier than working out the binary search here."
                    },
                    {
                        "username": "akamboj",
                        "content": "because there is no contiguous allocation."
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "it's been  45+ minutes trying to solve this problem.. Am I dumb or most of the people are facing the same issue?"
                    },
                    {
                        "username": "emilmohan24",
                        "content": "Bro it takes me days sometimes lol\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "really struggling right now"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Brute force solution works"
                    },
                    {
                        "username": "akshatmaheshwar78",
                        "content": "Yah mate, this was hurting my brain until I took my paper and pen."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "[@longb1997](/longb1997) eveyones dumb mate until the same questions drops in interview"
                    },
                    {
                        "username": "longb1997",
                        "content": "i don't even think about backtracking\ni'm suck :((("
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "[@void_8t](/void_8t)  fr..."
                    },
                    {
                        "username": "meow_power",
                        "content": "you are not alone:("
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Who else thought it was binary search and then realized that the distribution is not contagious \\uD83D\\uDE22"
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This can be cone using binary search\\n\\n\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n\\n        def canDistribute(mid):\\n            children = [0] * k\\n            return assignCookies(0, mid, children)\\n        \\n        def assignCookies(index, mid, children):\\n            if index == len(cookies):\\n                return True\\n            curCookie = cookies[index]\\n            for i in range(k):\\n                if children[i] + curCookie <= mid:\\n                    children[i] += curCookie\\n                    if assignCookies(index + 1, mid, children):\\n                        return True\\n                    children[i] -= curCookie\\n                # If the child hasn\\'t been given any cookie, we break to avoid redundancies.\\n                if children[i] == 0:\\n                    break\\n            return False\\n        \\n        # Set the binary search range\\n        low, high = max(cookies), sum(cookies)\\n        while low < high:\\n            mid = (low + high) // 2\\n            if canDistribute(mid):\\n                high = mid\\n            else:\\n                low = mid + 1\\n\\n        return low\\n"
                    },
                    {
                        "username": "mt790191",
                        "content": "can u please elaborate what do you  mean by  distribution is not contagious and how it effects the solution"
                    },
                    {
                        "username": "_Aman_13_",
                        "content": "I not only thought but also code the BS solution, and also it accepted for 34 test cases. After that I realized that it will not work \\uD83D\\uDE2D"
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "also if it would have binary search question then array size also would have 1e5"
                    },
                    {
                        "username": "Jaiff",
                        "content": "*contiguous"
                    },
                    {
                        "username": "bortengineer",
                        "content": "Time limits for Python are too harsh (as always). Exact same naive backtracking solution that is good enough for c++ is no good for python, so you have to do additional optimizations."
                    },
                    {
                        "username": "dz_adman",
                        "content": "[@cswartzell](/cswartzell) I stand with the argument that equivalent solutions in any language should be acceptable. On the other hand, the fact that python is less efficient, is independent of how leetcode treat any language\\'s code."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@dz_adman](/dz_adman) That is meaningless. The point is that equivalent solutions for each language should be acceptable for each language, regardless of the time required to compute that solution IN the given language. The Time Limits are different for each language as is. \n\nAn equivalent Python solution to a passing C++ solution should absolutely count as valid"
                    },
                    {
                        "username": "dz_adman",
                        "content": "[python is less efficient](https://thenextweb.com/news/python-progamming-language-energy-analysis) than many other languages."
                    },
                    {
                        "username": "stefan1096",
                        "content": "I got TLE in Python3 but beats 56% in C++ with the same code(it only passed after an optimization)."
                    },
                    {
                        "username": "PencilBro27",
                        "content": "This problem is the same as\\n[1723. Find Minimum Time to Finish All Jobs](https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/description/)"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "https://leetcode.com/problems/matchsticks-to-square/\\nhttps://leetcode.com/problems/partition-to-k-equal-sum-subsets/\\nThese Two also Similar"
                    },
                    {
                        "username": "jason3410",
                        "content": "That\\'s a bit harder but still thx for the information."
                    },
                    {
                        "username": "AnywaySo",
                        "content": "Thank you, another problem was accepted."
                    },
                    {
                        "username": "charonme",
                        "content": "although 1723 has stricter time limits"
                    },
                    {
                        "username": "psionl0",
                        "content": "I hate backtracking. It is one of the few areas in algorithms that I can\\'t seem to master.\\n\\nAnd a sloppily worded editorial didn\\'t help. It took me 10 minutes to figure out that they said \"cookie\" they weren\\'t talking about an individual cookie but a bag of cookies."
                    },
                    {
                        "username": "cswartzell",
                        "content": "For me, its not that I cant master backtracking. The actual backtracking algo is almost silly trivial: Do a task, backtrack and undo it, redo the task a different way such that every combination is covered. The problem for me is recognizing: \"we are just going to have to try every combination. No greedy algorthim is going to shortcut these trials. Maybe there is some pruning we can do to early exit a trial branch, but effectively we need to check every branch\"\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "Me too, if it were single cookies, the question is much simpler. If it were single cookies, we would not need an array, we would just be given the total number of cookies. \\n\\nI still haven\\'t solved it."
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "Can anyone explain what do you all mean by saying there\\'s no continuous allocation?\\n"
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "[@JaAt_BhOi](/JaAt_BhOi) from the cookies array we can select cookies[i] in any order(random) need not be contiguous sub array....."
                    },
                    {
                        "username": "y-not",
                        "content": "Java Video Solution - \\nhttps://www.youtube.com/watch?v=kYQ5jXXhWYE"
                    }
                ]
            },
            {
                "id": 1643606,
                "content": [
                    {
                        "username": "JerExplosion",
                        "content": "We should teach the kids that the world is not always fair "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "Prolly should teach them how to build guillotines too. "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> The unfairness of a distribution is defined as the maximum total cookies obtained by a single child in the distribution.\n\nThe most fair (and satisfying) distribution then would be to eat all the cookies yourself."
                    },
                    {
                        "username": "emilmohan24",
                        "content": "O(1) solution. Absolute genius. "
                    },
                    {
                        "username": "Stewie-Griffin",
                        "content": "I mean i can\\'t help to understand that why is it not of binary search  , its language is similar to most of binary search problems."
                    },
                    {
                        "username": "utkarshinobi",
                        "content": "[@vishalkgupta9821](/vishalkgupta9821) Thanks a lot! This was extremely helpful."
                    },
                    {
                        "username": "vishalkgupta9821",
                        "content": "we can solve this problem using binary search like problem 1011. Capacity To Ship Packages Within D Days\\nbut we need to generate all possible permutation of array in order to check unfairness.\\n\\n\\n//fist find the max in min like book allocation \\n    //repeat the process for all permutation\\n    bool ispossible(vector<int>&arr,int k,int mid){\\n        int count=1;\\n        int sum=0;\\n        for(auto  n:arr){\\n            sum+=n;\\n            if(sum>mid){\\n                count++;\\n                sum=n;\\n            }\\n        }\\n        return count<=k;\\n    }\\n\\n    int findMinMax(vector<int>&arr,int k){\\n        int low=0;\\n        int high=0;\\n        for(auto a:arr){\\n            low=max(a,low);\\n            high+=a;\\n        }\\n\\n        int ans=high;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(ispossible(arr,k,mid)){\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int ans=INT_MAX;\\n        sort(cookies.begin(),cookies.end());\\n        do{\\n            ans=min(ans,findMinMax(cookies,k));\\n        }while(next_permutation(cookies.begin(),cookies.end()));\\n\\n        return ans;\\n    }\\n\\n\\n"
                    },
                    {
                        "username": "user7717f",
                        "content": "We can use binary search in this problem to do the pruning by finding the upper bound in searching.\n\n```java\nclass Solution {\n    public int distributeCookies(int[] cookies, int k) {\n        Arrays.sort(cookies);\n        \n        int n = cookies.length, lb = cookies[n - 1], rb = cookies[n - 1] * n, ans = -1;\n        while (lb <= rb) {\n            int mb = lb + rb >> 1;\n\n            if (dfs(cookies, 0, new int[k], mb)) {\n                ans = mb;\n                rb = mb - 1;\n            }else {\n                lb = mb + 1;\n            }\n        }\n\n        return ans;\n    }\n\n    private boolean dfs(int[] cookies, int start, int[] nums, int mb) {\n        if (start == cookies.length) {\n            return true;\n        }\n\n        for (int i = 0; i < nums.length; ++i) {\n            if (nums[i] + cookies[start] <= mb) {\n                nums[i] += cookies[start];\n                if (dfs(cookies, start + 1, nums, mb)) {\n                    return true;\n                }\n                nums[i] -= cookies[start];\n            }\n            if (nums[i] == 0) {\n                return false;\n            }\n        }\n\n        return false;\n    }\n}\n```"
                    },
                    {
                        "username": "srk696772",
                        "content": "Because All the Problems we solved on binary Search Mentions Consecutiveness In the Description , But In The Above There is no Constraint on Consecutive Distribution so we cannot apply binary search here."
                    },
                    {
                        "username": "lalit10368",
                        "content": "[@akamboj](/akamboj) Thanks! for that justification. Hence, no boundary to search here."
                    },
                    {
                        "username": "lalit10368",
                        "content": "Hmm, I had a similar thought while solving. But I don\\'t know how to apply binary search over this. The constraints suggested brute force algorithm should work here. That\\'s why, I simply used bitmask & backtracking. Much easier than working out the binary search here."
                    },
                    {
                        "username": "akamboj",
                        "content": "because there is no contiguous allocation."
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "it's been  45+ minutes trying to solve this problem.. Am I dumb or most of the people are facing the same issue?"
                    },
                    {
                        "username": "emilmohan24",
                        "content": "Bro it takes me days sometimes lol\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "really struggling right now"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Brute force solution works"
                    },
                    {
                        "username": "akshatmaheshwar78",
                        "content": "Yah mate, this was hurting my brain until I took my paper and pen."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "[@longb1997](/longb1997) eveyones dumb mate until the same questions drops in interview"
                    },
                    {
                        "username": "longb1997",
                        "content": "i don't even think about backtracking\ni'm suck :((("
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "[@void_8t](/void_8t)  fr..."
                    },
                    {
                        "username": "meow_power",
                        "content": "you are not alone:("
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Who else thought it was binary search and then realized that the distribution is not contagious \\uD83D\\uDE22"
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This can be cone using binary search\\n\\n\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n\\n        def canDistribute(mid):\\n            children = [0] * k\\n            return assignCookies(0, mid, children)\\n        \\n        def assignCookies(index, mid, children):\\n            if index == len(cookies):\\n                return True\\n            curCookie = cookies[index]\\n            for i in range(k):\\n                if children[i] + curCookie <= mid:\\n                    children[i] += curCookie\\n                    if assignCookies(index + 1, mid, children):\\n                        return True\\n                    children[i] -= curCookie\\n                # If the child hasn\\'t been given any cookie, we break to avoid redundancies.\\n                if children[i] == 0:\\n                    break\\n            return False\\n        \\n        # Set the binary search range\\n        low, high = max(cookies), sum(cookies)\\n        while low < high:\\n            mid = (low + high) // 2\\n            if canDistribute(mid):\\n                high = mid\\n            else:\\n                low = mid + 1\\n\\n        return low\\n"
                    },
                    {
                        "username": "mt790191",
                        "content": "can u please elaborate what do you  mean by  distribution is not contagious and how it effects the solution"
                    },
                    {
                        "username": "_Aman_13_",
                        "content": "I not only thought but also code the BS solution, and also it accepted for 34 test cases. After that I realized that it will not work \\uD83D\\uDE2D"
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "also if it would have binary search question then array size also would have 1e5"
                    },
                    {
                        "username": "Jaiff",
                        "content": "*contiguous"
                    },
                    {
                        "username": "bortengineer",
                        "content": "Time limits for Python are too harsh (as always). Exact same naive backtracking solution that is good enough for c++ is no good for python, so you have to do additional optimizations."
                    },
                    {
                        "username": "dz_adman",
                        "content": "[@cswartzell](/cswartzell) I stand with the argument that equivalent solutions in any language should be acceptable. On the other hand, the fact that python is less efficient, is independent of how leetcode treat any language\\'s code."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@dz_adman](/dz_adman) That is meaningless. The point is that equivalent solutions for each language should be acceptable for each language, regardless of the time required to compute that solution IN the given language. The Time Limits are different for each language as is. \n\nAn equivalent Python solution to a passing C++ solution should absolutely count as valid"
                    },
                    {
                        "username": "dz_adman",
                        "content": "[python is less efficient](https://thenextweb.com/news/python-progamming-language-energy-analysis) than many other languages."
                    },
                    {
                        "username": "stefan1096",
                        "content": "I got TLE in Python3 but beats 56% in C++ with the same code(it only passed after an optimization)."
                    },
                    {
                        "username": "PencilBro27",
                        "content": "This problem is the same as\\n[1723. Find Minimum Time to Finish All Jobs](https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/description/)"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "https://leetcode.com/problems/matchsticks-to-square/\\nhttps://leetcode.com/problems/partition-to-k-equal-sum-subsets/\\nThese Two also Similar"
                    },
                    {
                        "username": "jason3410",
                        "content": "That\\'s a bit harder but still thx for the information."
                    },
                    {
                        "username": "AnywaySo",
                        "content": "Thank you, another problem was accepted."
                    },
                    {
                        "username": "charonme",
                        "content": "although 1723 has stricter time limits"
                    },
                    {
                        "username": "psionl0",
                        "content": "I hate backtracking. It is one of the few areas in algorithms that I can\\'t seem to master.\\n\\nAnd a sloppily worded editorial didn\\'t help. It took me 10 minutes to figure out that they said \"cookie\" they weren\\'t talking about an individual cookie but a bag of cookies."
                    },
                    {
                        "username": "cswartzell",
                        "content": "For me, its not that I cant master backtracking. The actual backtracking algo is almost silly trivial: Do a task, backtrack and undo it, redo the task a different way such that every combination is covered. The problem for me is recognizing: \"we are just going to have to try every combination. No greedy algorthim is going to shortcut these trials. Maybe there is some pruning we can do to early exit a trial branch, but effectively we need to check every branch\"\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "Me too, if it were single cookies, the question is much simpler. If it were single cookies, we would not need an array, we would just be given the total number of cookies. \\n\\nI still haven\\'t solved it."
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "Can anyone explain what do you all mean by saying there\\'s no continuous allocation?\\n"
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "[@JaAt_BhOi](/JaAt_BhOi) from the cookies array we can select cookies[i] in any order(random) need not be contiguous sub array....."
                    },
                    {
                        "username": "y-not",
                        "content": "Java Video Solution - \\nhttps://www.youtube.com/watch?v=kYQ5jXXhWYE"
                    }
                ]
            },
            {
                "id": 1951127,
                "content": [
                    {
                        "username": "JerExplosion",
                        "content": "We should teach the kids that the world is not always fair "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "Prolly should teach them how to build guillotines too. "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> The unfairness of a distribution is defined as the maximum total cookies obtained by a single child in the distribution.\n\nThe most fair (and satisfying) distribution then would be to eat all the cookies yourself."
                    },
                    {
                        "username": "emilmohan24",
                        "content": "O(1) solution. Absolute genius. "
                    },
                    {
                        "username": "Stewie-Griffin",
                        "content": "I mean i can\\'t help to understand that why is it not of binary search  , its language is similar to most of binary search problems."
                    },
                    {
                        "username": "utkarshinobi",
                        "content": "[@vishalkgupta9821](/vishalkgupta9821) Thanks a lot! This was extremely helpful."
                    },
                    {
                        "username": "vishalkgupta9821",
                        "content": "we can solve this problem using binary search like problem 1011. Capacity To Ship Packages Within D Days\\nbut we need to generate all possible permutation of array in order to check unfairness.\\n\\n\\n//fist find the max in min like book allocation \\n    //repeat the process for all permutation\\n    bool ispossible(vector<int>&arr,int k,int mid){\\n        int count=1;\\n        int sum=0;\\n        for(auto  n:arr){\\n            sum+=n;\\n            if(sum>mid){\\n                count++;\\n                sum=n;\\n            }\\n        }\\n        return count<=k;\\n    }\\n\\n    int findMinMax(vector<int>&arr,int k){\\n        int low=0;\\n        int high=0;\\n        for(auto a:arr){\\n            low=max(a,low);\\n            high+=a;\\n        }\\n\\n        int ans=high;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(ispossible(arr,k,mid)){\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int ans=INT_MAX;\\n        sort(cookies.begin(),cookies.end());\\n        do{\\n            ans=min(ans,findMinMax(cookies,k));\\n        }while(next_permutation(cookies.begin(),cookies.end()));\\n\\n        return ans;\\n    }\\n\\n\\n"
                    },
                    {
                        "username": "user7717f",
                        "content": "We can use binary search in this problem to do the pruning by finding the upper bound in searching.\n\n```java\nclass Solution {\n    public int distributeCookies(int[] cookies, int k) {\n        Arrays.sort(cookies);\n        \n        int n = cookies.length, lb = cookies[n - 1], rb = cookies[n - 1] * n, ans = -1;\n        while (lb <= rb) {\n            int mb = lb + rb >> 1;\n\n            if (dfs(cookies, 0, new int[k], mb)) {\n                ans = mb;\n                rb = mb - 1;\n            }else {\n                lb = mb + 1;\n            }\n        }\n\n        return ans;\n    }\n\n    private boolean dfs(int[] cookies, int start, int[] nums, int mb) {\n        if (start == cookies.length) {\n            return true;\n        }\n\n        for (int i = 0; i < nums.length; ++i) {\n            if (nums[i] + cookies[start] <= mb) {\n                nums[i] += cookies[start];\n                if (dfs(cookies, start + 1, nums, mb)) {\n                    return true;\n                }\n                nums[i] -= cookies[start];\n            }\n            if (nums[i] == 0) {\n                return false;\n            }\n        }\n\n        return false;\n    }\n}\n```"
                    },
                    {
                        "username": "srk696772",
                        "content": "Because All the Problems we solved on binary Search Mentions Consecutiveness In the Description , But In The Above There is no Constraint on Consecutive Distribution so we cannot apply binary search here."
                    },
                    {
                        "username": "lalit10368",
                        "content": "[@akamboj](/akamboj) Thanks! for that justification. Hence, no boundary to search here."
                    },
                    {
                        "username": "lalit10368",
                        "content": "Hmm, I had a similar thought while solving. But I don\\'t know how to apply binary search over this. The constraints suggested brute force algorithm should work here. That\\'s why, I simply used bitmask & backtracking. Much easier than working out the binary search here."
                    },
                    {
                        "username": "akamboj",
                        "content": "because there is no contiguous allocation."
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "it's been  45+ minutes trying to solve this problem.. Am I dumb or most of the people are facing the same issue?"
                    },
                    {
                        "username": "emilmohan24",
                        "content": "Bro it takes me days sometimes lol\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "really struggling right now"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Brute force solution works"
                    },
                    {
                        "username": "akshatmaheshwar78",
                        "content": "Yah mate, this was hurting my brain until I took my paper and pen."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "[@longb1997](/longb1997) eveyones dumb mate until the same questions drops in interview"
                    },
                    {
                        "username": "longb1997",
                        "content": "i don't even think about backtracking\ni'm suck :((("
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "[@void_8t](/void_8t)  fr..."
                    },
                    {
                        "username": "meow_power",
                        "content": "you are not alone:("
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Who else thought it was binary search and then realized that the distribution is not contagious \\uD83D\\uDE22"
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This can be cone using binary search\\n\\n\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n\\n        def canDistribute(mid):\\n            children = [0] * k\\n            return assignCookies(0, mid, children)\\n        \\n        def assignCookies(index, mid, children):\\n            if index == len(cookies):\\n                return True\\n            curCookie = cookies[index]\\n            for i in range(k):\\n                if children[i] + curCookie <= mid:\\n                    children[i] += curCookie\\n                    if assignCookies(index + 1, mid, children):\\n                        return True\\n                    children[i] -= curCookie\\n                # If the child hasn\\'t been given any cookie, we break to avoid redundancies.\\n                if children[i] == 0:\\n                    break\\n            return False\\n        \\n        # Set the binary search range\\n        low, high = max(cookies), sum(cookies)\\n        while low < high:\\n            mid = (low + high) // 2\\n            if canDistribute(mid):\\n                high = mid\\n            else:\\n                low = mid + 1\\n\\n        return low\\n"
                    },
                    {
                        "username": "mt790191",
                        "content": "can u please elaborate what do you  mean by  distribution is not contagious and how it effects the solution"
                    },
                    {
                        "username": "_Aman_13_",
                        "content": "I not only thought but also code the BS solution, and also it accepted for 34 test cases. After that I realized that it will not work \\uD83D\\uDE2D"
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "also if it would have binary search question then array size also would have 1e5"
                    },
                    {
                        "username": "Jaiff",
                        "content": "*contiguous"
                    },
                    {
                        "username": "bortengineer",
                        "content": "Time limits for Python are too harsh (as always). Exact same naive backtracking solution that is good enough for c++ is no good for python, so you have to do additional optimizations."
                    },
                    {
                        "username": "dz_adman",
                        "content": "[@cswartzell](/cswartzell) I stand with the argument that equivalent solutions in any language should be acceptable. On the other hand, the fact that python is less efficient, is independent of how leetcode treat any language\\'s code."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@dz_adman](/dz_adman) That is meaningless. The point is that equivalent solutions for each language should be acceptable for each language, regardless of the time required to compute that solution IN the given language. The Time Limits are different for each language as is. \n\nAn equivalent Python solution to a passing C++ solution should absolutely count as valid"
                    },
                    {
                        "username": "dz_adman",
                        "content": "[python is less efficient](https://thenextweb.com/news/python-progamming-language-energy-analysis) than many other languages."
                    },
                    {
                        "username": "stefan1096",
                        "content": "I got TLE in Python3 but beats 56% in C++ with the same code(it only passed after an optimization)."
                    },
                    {
                        "username": "PencilBro27",
                        "content": "This problem is the same as\\n[1723. Find Minimum Time to Finish All Jobs](https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/description/)"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "https://leetcode.com/problems/matchsticks-to-square/\\nhttps://leetcode.com/problems/partition-to-k-equal-sum-subsets/\\nThese Two also Similar"
                    },
                    {
                        "username": "jason3410",
                        "content": "That\\'s a bit harder but still thx for the information."
                    },
                    {
                        "username": "AnywaySo",
                        "content": "Thank you, another problem was accepted."
                    },
                    {
                        "username": "charonme",
                        "content": "although 1723 has stricter time limits"
                    },
                    {
                        "username": "psionl0",
                        "content": "I hate backtracking. It is one of the few areas in algorithms that I can\\'t seem to master.\\n\\nAnd a sloppily worded editorial didn\\'t help. It took me 10 minutes to figure out that they said \"cookie\" they weren\\'t talking about an individual cookie but a bag of cookies."
                    },
                    {
                        "username": "cswartzell",
                        "content": "For me, its not that I cant master backtracking. The actual backtracking algo is almost silly trivial: Do a task, backtrack and undo it, redo the task a different way such that every combination is covered. The problem for me is recognizing: \"we are just going to have to try every combination. No greedy algorthim is going to shortcut these trials. Maybe there is some pruning we can do to early exit a trial branch, but effectively we need to check every branch\"\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "Me too, if it were single cookies, the question is much simpler. If it were single cookies, we would not need an array, we would just be given the total number of cookies. \\n\\nI still haven\\'t solved it."
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "Can anyone explain what do you all mean by saying there\\'s no continuous allocation?\\n"
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "[@JaAt_BhOi](/JaAt_BhOi) from the cookies array we can select cookies[i] in any order(random) need not be contiguous sub array....."
                    },
                    {
                        "username": "y-not",
                        "content": "Java Video Solution - \\nhttps://www.youtube.com/watch?v=kYQ5jXXhWYE"
                    }
                ]
            },
            {
                "id": 1951291,
                "content": [
                    {
                        "username": "JerExplosion",
                        "content": "We should teach the kids that the world is not always fair "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "Prolly should teach them how to build guillotines too. "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> The unfairness of a distribution is defined as the maximum total cookies obtained by a single child in the distribution.\n\nThe most fair (and satisfying) distribution then would be to eat all the cookies yourself."
                    },
                    {
                        "username": "emilmohan24",
                        "content": "O(1) solution. Absolute genius. "
                    },
                    {
                        "username": "Stewie-Griffin",
                        "content": "I mean i can\\'t help to understand that why is it not of binary search  , its language is similar to most of binary search problems."
                    },
                    {
                        "username": "utkarshinobi",
                        "content": "[@vishalkgupta9821](/vishalkgupta9821) Thanks a lot! This was extremely helpful."
                    },
                    {
                        "username": "vishalkgupta9821",
                        "content": "we can solve this problem using binary search like problem 1011. Capacity To Ship Packages Within D Days\\nbut we need to generate all possible permutation of array in order to check unfairness.\\n\\n\\n//fist find the max in min like book allocation \\n    //repeat the process for all permutation\\n    bool ispossible(vector<int>&arr,int k,int mid){\\n        int count=1;\\n        int sum=0;\\n        for(auto  n:arr){\\n            sum+=n;\\n            if(sum>mid){\\n                count++;\\n                sum=n;\\n            }\\n        }\\n        return count<=k;\\n    }\\n\\n    int findMinMax(vector<int>&arr,int k){\\n        int low=0;\\n        int high=0;\\n        for(auto a:arr){\\n            low=max(a,low);\\n            high+=a;\\n        }\\n\\n        int ans=high;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(ispossible(arr,k,mid)){\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int ans=INT_MAX;\\n        sort(cookies.begin(),cookies.end());\\n        do{\\n            ans=min(ans,findMinMax(cookies,k));\\n        }while(next_permutation(cookies.begin(),cookies.end()));\\n\\n        return ans;\\n    }\\n\\n\\n"
                    },
                    {
                        "username": "user7717f",
                        "content": "We can use binary search in this problem to do the pruning by finding the upper bound in searching.\n\n```java\nclass Solution {\n    public int distributeCookies(int[] cookies, int k) {\n        Arrays.sort(cookies);\n        \n        int n = cookies.length, lb = cookies[n - 1], rb = cookies[n - 1] * n, ans = -1;\n        while (lb <= rb) {\n            int mb = lb + rb >> 1;\n\n            if (dfs(cookies, 0, new int[k], mb)) {\n                ans = mb;\n                rb = mb - 1;\n            }else {\n                lb = mb + 1;\n            }\n        }\n\n        return ans;\n    }\n\n    private boolean dfs(int[] cookies, int start, int[] nums, int mb) {\n        if (start == cookies.length) {\n            return true;\n        }\n\n        for (int i = 0; i < nums.length; ++i) {\n            if (nums[i] + cookies[start] <= mb) {\n                nums[i] += cookies[start];\n                if (dfs(cookies, start + 1, nums, mb)) {\n                    return true;\n                }\n                nums[i] -= cookies[start];\n            }\n            if (nums[i] == 0) {\n                return false;\n            }\n        }\n\n        return false;\n    }\n}\n```"
                    },
                    {
                        "username": "srk696772",
                        "content": "Because All the Problems we solved on binary Search Mentions Consecutiveness In the Description , But In The Above There is no Constraint on Consecutive Distribution so we cannot apply binary search here."
                    },
                    {
                        "username": "lalit10368",
                        "content": "[@akamboj](/akamboj) Thanks! for that justification. Hence, no boundary to search here."
                    },
                    {
                        "username": "lalit10368",
                        "content": "Hmm, I had a similar thought while solving. But I don\\'t know how to apply binary search over this. The constraints suggested brute force algorithm should work here. That\\'s why, I simply used bitmask & backtracking. Much easier than working out the binary search here."
                    },
                    {
                        "username": "akamboj",
                        "content": "because there is no contiguous allocation."
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "it's been  45+ minutes trying to solve this problem.. Am I dumb or most of the people are facing the same issue?"
                    },
                    {
                        "username": "emilmohan24",
                        "content": "Bro it takes me days sometimes lol\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "really struggling right now"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Brute force solution works"
                    },
                    {
                        "username": "akshatmaheshwar78",
                        "content": "Yah mate, this was hurting my brain until I took my paper and pen."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "[@longb1997](/longb1997) eveyones dumb mate until the same questions drops in interview"
                    },
                    {
                        "username": "longb1997",
                        "content": "i don't even think about backtracking\ni'm suck :((("
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "[@void_8t](/void_8t)  fr..."
                    },
                    {
                        "username": "meow_power",
                        "content": "you are not alone:("
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Who else thought it was binary search and then realized that the distribution is not contagious \\uD83D\\uDE22"
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This can be cone using binary search\\n\\n\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n\\n        def canDistribute(mid):\\n            children = [0] * k\\n            return assignCookies(0, mid, children)\\n        \\n        def assignCookies(index, mid, children):\\n            if index == len(cookies):\\n                return True\\n            curCookie = cookies[index]\\n            for i in range(k):\\n                if children[i] + curCookie <= mid:\\n                    children[i] += curCookie\\n                    if assignCookies(index + 1, mid, children):\\n                        return True\\n                    children[i] -= curCookie\\n                # If the child hasn\\'t been given any cookie, we break to avoid redundancies.\\n                if children[i] == 0:\\n                    break\\n            return False\\n        \\n        # Set the binary search range\\n        low, high = max(cookies), sum(cookies)\\n        while low < high:\\n            mid = (low + high) // 2\\n            if canDistribute(mid):\\n                high = mid\\n            else:\\n                low = mid + 1\\n\\n        return low\\n"
                    },
                    {
                        "username": "mt790191",
                        "content": "can u please elaborate what do you  mean by  distribution is not contagious and how it effects the solution"
                    },
                    {
                        "username": "_Aman_13_",
                        "content": "I not only thought but also code the BS solution, and also it accepted for 34 test cases. After that I realized that it will not work \\uD83D\\uDE2D"
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "also if it would have binary search question then array size also would have 1e5"
                    },
                    {
                        "username": "Jaiff",
                        "content": "*contiguous"
                    },
                    {
                        "username": "bortengineer",
                        "content": "Time limits for Python are too harsh (as always). Exact same naive backtracking solution that is good enough for c++ is no good for python, so you have to do additional optimizations."
                    },
                    {
                        "username": "dz_adman",
                        "content": "[@cswartzell](/cswartzell) I stand with the argument that equivalent solutions in any language should be acceptable. On the other hand, the fact that python is less efficient, is independent of how leetcode treat any language\\'s code."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@dz_adman](/dz_adman) That is meaningless. The point is that equivalent solutions for each language should be acceptable for each language, regardless of the time required to compute that solution IN the given language. The Time Limits are different for each language as is. \n\nAn equivalent Python solution to a passing C++ solution should absolutely count as valid"
                    },
                    {
                        "username": "dz_adman",
                        "content": "[python is less efficient](https://thenextweb.com/news/python-progamming-language-energy-analysis) than many other languages."
                    },
                    {
                        "username": "stefan1096",
                        "content": "I got TLE in Python3 but beats 56% in C++ with the same code(it only passed after an optimization)."
                    },
                    {
                        "username": "PencilBro27",
                        "content": "This problem is the same as\\n[1723. Find Minimum Time to Finish All Jobs](https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/description/)"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "https://leetcode.com/problems/matchsticks-to-square/\\nhttps://leetcode.com/problems/partition-to-k-equal-sum-subsets/\\nThese Two also Similar"
                    },
                    {
                        "username": "jason3410",
                        "content": "That\\'s a bit harder but still thx for the information."
                    },
                    {
                        "username": "AnywaySo",
                        "content": "Thank you, another problem was accepted."
                    },
                    {
                        "username": "charonme",
                        "content": "although 1723 has stricter time limits"
                    },
                    {
                        "username": "psionl0",
                        "content": "I hate backtracking. It is one of the few areas in algorithms that I can\\'t seem to master.\\n\\nAnd a sloppily worded editorial didn\\'t help. It took me 10 minutes to figure out that they said \"cookie\" they weren\\'t talking about an individual cookie but a bag of cookies."
                    },
                    {
                        "username": "cswartzell",
                        "content": "For me, its not that I cant master backtracking. The actual backtracking algo is almost silly trivial: Do a task, backtrack and undo it, redo the task a different way such that every combination is covered. The problem for me is recognizing: \"we are just going to have to try every combination. No greedy algorthim is going to shortcut these trials. Maybe there is some pruning we can do to early exit a trial branch, but effectively we need to check every branch\"\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "Me too, if it were single cookies, the question is much simpler. If it were single cookies, we would not need an array, we would just be given the total number of cookies. \\n\\nI still haven\\'t solved it."
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "Can anyone explain what do you all mean by saying there\\'s no continuous allocation?\\n"
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "[@JaAt_BhOi](/JaAt_BhOi) from the cookies array we can select cookies[i] in any order(random) need not be contiguous sub array....."
                    },
                    {
                        "username": "y-not",
                        "content": "Java Video Solution - \\nhttps://www.youtube.com/watch?v=kYQ5jXXhWYE"
                    }
                ]
            },
            {
                "id": 1951427,
                "content": [
                    {
                        "username": "JerExplosion",
                        "content": "We should teach the kids that the world is not always fair "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "Prolly should teach them how to build guillotines too. "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> The unfairness of a distribution is defined as the maximum total cookies obtained by a single child in the distribution.\n\nThe most fair (and satisfying) distribution then would be to eat all the cookies yourself."
                    },
                    {
                        "username": "emilmohan24",
                        "content": "O(1) solution. Absolute genius. "
                    },
                    {
                        "username": "Stewie-Griffin",
                        "content": "I mean i can\\'t help to understand that why is it not of binary search  , its language is similar to most of binary search problems."
                    },
                    {
                        "username": "utkarshinobi",
                        "content": "[@vishalkgupta9821](/vishalkgupta9821) Thanks a lot! This was extremely helpful."
                    },
                    {
                        "username": "vishalkgupta9821",
                        "content": "we can solve this problem using binary search like problem 1011. Capacity To Ship Packages Within D Days\\nbut we need to generate all possible permutation of array in order to check unfairness.\\n\\n\\n//fist find the max in min like book allocation \\n    //repeat the process for all permutation\\n    bool ispossible(vector<int>&arr,int k,int mid){\\n        int count=1;\\n        int sum=0;\\n        for(auto  n:arr){\\n            sum+=n;\\n            if(sum>mid){\\n                count++;\\n                sum=n;\\n            }\\n        }\\n        return count<=k;\\n    }\\n\\n    int findMinMax(vector<int>&arr,int k){\\n        int low=0;\\n        int high=0;\\n        for(auto a:arr){\\n            low=max(a,low);\\n            high+=a;\\n        }\\n\\n        int ans=high;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(ispossible(arr,k,mid)){\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int distributeCookies(vector<int>& cookies, int k) {\\n        int ans=INT_MAX;\\n        sort(cookies.begin(),cookies.end());\\n        do{\\n            ans=min(ans,findMinMax(cookies,k));\\n        }while(next_permutation(cookies.begin(),cookies.end()));\\n\\n        return ans;\\n    }\\n\\n\\n"
                    },
                    {
                        "username": "user7717f",
                        "content": "We can use binary search in this problem to do the pruning by finding the upper bound in searching.\n\n```java\nclass Solution {\n    public int distributeCookies(int[] cookies, int k) {\n        Arrays.sort(cookies);\n        \n        int n = cookies.length, lb = cookies[n - 1], rb = cookies[n - 1] * n, ans = -1;\n        while (lb <= rb) {\n            int mb = lb + rb >> 1;\n\n            if (dfs(cookies, 0, new int[k], mb)) {\n                ans = mb;\n                rb = mb - 1;\n            }else {\n                lb = mb + 1;\n            }\n        }\n\n        return ans;\n    }\n\n    private boolean dfs(int[] cookies, int start, int[] nums, int mb) {\n        if (start == cookies.length) {\n            return true;\n        }\n\n        for (int i = 0; i < nums.length; ++i) {\n            if (nums[i] + cookies[start] <= mb) {\n                nums[i] += cookies[start];\n                if (dfs(cookies, start + 1, nums, mb)) {\n                    return true;\n                }\n                nums[i] -= cookies[start];\n            }\n            if (nums[i] == 0) {\n                return false;\n            }\n        }\n\n        return false;\n    }\n}\n```"
                    },
                    {
                        "username": "srk696772",
                        "content": "Because All the Problems we solved on binary Search Mentions Consecutiveness In the Description , But In The Above There is no Constraint on Consecutive Distribution so we cannot apply binary search here."
                    },
                    {
                        "username": "lalit10368",
                        "content": "[@akamboj](/akamboj) Thanks! for that justification. Hence, no boundary to search here."
                    },
                    {
                        "username": "lalit10368",
                        "content": "Hmm, I had a similar thought while solving. But I don\\'t know how to apply binary search over this. The constraints suggested brute force algorithm should work here. That\\'s why, I simply used bitmask & backtracking. Much easier than working out the binary search here."
                    },
                    {
                        "username": "akamboj",
                        "content": "because there is no contiguous allocation."
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "it's been  45+ minutes trying to solve this problem.. Am I dumb or most of the people are facing the same issue?"
                    },
                    {
                        "username": "emilmohan24",
                        "content": "Bro it takes me days sometimes lol\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "really struggling right now"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Brute force solution works"
                    },
                    {
                        "username": "akshatmaheshwar78",
                        "content": "Yah mate, this was hurting my brain until I took my paper and pen."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "[@longb1997](/longb1997) eveyones dumb mate until the same questions drops in interview"
                    },
                    {
                        "username": "longb1997",
                        "content": "i don't even think about backtracking\ni'm suck :((("
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "[@void_8t](/void_8t)  fr..."
                    },
                    {
                        "username": "meow_power",
                        "content": "you are not alone:("
                    },
                    {
                        "username": "Shubh2407",
                        "content": "Who else thought it was binary search and then realized that the distribution is not contagious \\uD83D\\uDE22"
                    },
                    {
                        "username": "soumyajitchakraborty23",
                        "content": "This can be cone using binary search\\n\\n\\nclass Solution:\\n    def distributeCookies(self, cookies: List[int], k: int) -> int:\\n\\n        def canDistribute(mid):\\n            children = [0] * k\\n            return assignCookies(0, mid, children)\\n        \\n        def assignCookies(index, mid, children):\\n            if index == len(cookies):\\n                return True\\n            curCookie = cookies[index]\\n            for i in range(k):\\n                if children[i] + curCookie <= mid:\\n                    children[i] += curCookie\\n                    if assignCookies(index + 1, mid, children):\\n                        return True\\n                    children[i] -= curCookie\\n                # If the child hasn\\'t been given any cookie, we break to avoid redundancies.\\n                if children[i] == 0:\\n                    break\\n            return False\\n        \\n        # Set the binary search range\\n        low, high = max(cookies), sum(cookies)\\n        while low < high:\\n            mid = (low + high) // 2\\n            if canDistribute(mid):\\n                high = mid\\n            else:\\n                low = mid + 1\\n\\n        return low\\n"
                    },
                    {
                        "username": "mt790191",
                        "content": "can u please elaborate what do you  mean by  distribution is not contagious and how it effects the solution"
                    },
                    {
                        "username": "_Aman_13_",
                        "content": "I not only thought but also code the BS solution, and also it accepted for 34 test cases. After that I realized that it will not work \\uD83D\\uDE2D"
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "also if it would have binary search question then array size also would have 1e5"
                    },
                    {
                        "username": "Jaiff",
                        "content": "*contiguous"
                    },
                    {
                        "username": "bortengineer",
                        "content": "Time limits for Python are too harsh (as always). Exact same naive backtracking solution that is good enough for c++ is no good for python, so you have to do additional optimizations."
                    },
                    {
                        "username": "dz_adman",
                        "content": "[@cswartzell](/cswartzell) I stand with the argument that equivalent solutions in any language should be acceptable. On the other hand, the fact that python is less efficient, is independent of how leetcode treat any language\\'s code."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@dz_adman](/dz_adman) That is meaningless. The point is that equivalent solutions for each language should be acceptable for each language, regardless of the time required to compute that solution IN the given language. The Time Limits are different for each language as is. \n\nAn equivalent Python solution to a passing C++ solution should absolutely count as valid"
                    },
                    {
                        "username": "dz_adman",
                        "content": "[python is less efficient](https://thenextweb.com/news/python-progamming-language-energy-analysis) than many other languages."
                    },
                    {
                        "username": "stefan1096",
                        "content": "I got TLE in Python3 but beats 56% in C++ with the same code(it only passed after an optimization)."
                    },
                    {
                        "username": "PencilBro27",
                        "content": "This problem is the same as\\n[1723. Find Minimum Time to Finish All Jobs](https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/description/)"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "https://leetcode.com/problems/matchsticks-to-square/\\nhttps://leetcode.com/problems/partition-to-k-equal-sum-subsets/\\nThese Two also Similar"
                    },
                    {
                        "username": "jason3410",
                        "content": "That\\'s a bit harder but still thx for the information."
                    },
                    {
                        "username": "AnywaySo",
                        "content": "Thank you, another problem was accepted."
                    },
                    {
                        "username": "charonme",
                        "content": "although 1723 has stricter time limits"
                    },
                    {
                        "username": "psionl0",
                        "content": "I hate backtracking. It is one of the few areas in algorithms that I can\\'t seem to master.\\n\\nAnd a sloppily worded editorial didn\\'t help. It took me 10 minutes to figure out that they said \"cookie\" they weren\\'t talking about an individual cookie but a bag of cookies."
                    },
                    {
                        "username": "cswartzell",
                        "content": "For me, its not that I cant master backtracking. The actual backtracking algo is almost silly trivial: Do a task, backtrack and undo it, redo the task a different way such that every combination is covered. The problem for me is recognizing: \"we are just going to have to try every combination. No greedy algorthim is going to shortcut these trials. Maybe there is some pruning we can do to early exit a trial branch, but effectively we need to check every branch\"\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "Me too, if it were single cookies, the question is much simpler. If it were single cookies, we would not need an array, we would just be given the total number of cookies. \\n\\nI still haven\\'t solved it."
                    },
                    {
                        "username": "JaAt_BhOi",
                        "content": "Can anyone explain what do you all mean by saying there\\'s no continuous allocation?\\n"
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "[@JaAt_BhOi](/JaAt_BhOi) from the cookies array we can select cookies[i] in any order(random) need not be contiguous sub array....."
                    },
                    {
                        "username": "y-not",
                        "content": "Java Video Solution - \\nhttps://www.youtube.com/watch?v=kYQ5jXXhWYE"
                    }
                ]
            },
            {
                "id": 1951405,
                "content": [
                    {
                        "username": "anshgrover020307",
                        "content": "[941,797,1475,638,191,712]\\n3\\n\\nwith this test case given sol is 1653 but according to my algo the optimize distribution for the above is  1579 ,1509 ,1666 with and with this distribution answer should be 1666 not 1653 ......\\ncan anyone explain me with this........"
                    },
                    {
                        "username": "quanqx",
                        "content": "Return the minimum unfairness of ALL distributions.\\nNOT FAIREST distribution."
                    },
                    {
                        "username": "CodeNinjaX",
                        "content": "How do you find if the current distribution is optimal or not?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Backtracking means that you have to try almost every case. But there is still an alternative by using DP & bit mask! It is doable."
                    },
                    {
                        "username": "webguru77777",
                        "content": "I\\'ve used DP+Bitmask+Backtracking lol\\nhttps://leetcode.com/problems/fair-distribution-of-cookies/submissions/983481061/"
                    },
                    {
                        "username": "divy_kant",
                        "content": "Whenever the question has said to find minimum of maximum or maximum of minimum , then it is a question of BINARY SEARCH ."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@divy_kant](/divy_kant) Yes, you\\'re absolutely correct. The technique you\\'re describing is sometimes referred to as \"binary search on the answer,\" which is a type of binary search where we use binary search to find the optimal value from a range of possible answers.\\n\\nIn such problems, we usually have a predicate function that can test whether a certain value is feasible or not, and our goal is to find the smallest or largest feasible value.\\n\\nFor the \"distribute cookies\" problem, a binary search approach could look something like this:\\n\\n1. **Finding the Search Space**: The lower bound can be the maximum value in the cookies array, and the upper bound can be the sum of all elements in the cookies array.\\n\\n2. **Predicate Function**: Given a value X, the predicate function checks if it is possible to distribute the cookies such that no child receives more than X cookies. This can be done by simulating the distribution and checking if the number of children exceeds \\'k\\'.\\n\\n3. **Binary Search**: We then perform a binary search over the possible values of X using our predicate function, aiming to find the smallest X for which the predicate function returns true.\\n\\nI agree that recognizing this pattern and determining the search space is often the most crucial part of solving such problems. Once we can do that, we can use a standard binary search template to find the solution."
                    },
                    {
                        "username": "divy_kant",
                        "content": "[@hbhutta](/hbhutta) \\n-> Yes sure , taking example of question like Maximum pages allocation , painters problem or aggressive cows - all these are solved using binary search and in each of them question stated to find minimum of maximum.\\n-> So , in these question if we are able to find the search space for out binary search , half of the question gets over , like it\\'s the main part to think and evaluate. in 50% cases which can be done by taking the lower limit as 0 or the least element and upper limit as the sum of all the elements.\\n-> You can check my solution for further understanding , it took a lot of effort in researching and explaining , PLEASE UPVOTE if it helped you a bit ."
                    },
                    {
                        "username": "hbhutta",
                        "content": "Can you explain this?"
                    },
                    {
                        "username": "Canaximui",
                        "content": "The question is to find the minimum unfairness and then in the example they used max(31, 30), can someone explain this to me ?\\n"
                    },
                    {
                        "username": "unters",
                        "content": "From the problem statement: \"The unfairness of a distribution is defined as the maximum total cookies obtained by a single child in the distribution.\""
                    },
                    {
                        "username": "cy171",
                        "content": "sorted the cookies in decrease order make my backtrack code from TLE to Beats 96 %,  I just don\\'t get it.\\n"
                    },
                    {
                        "username": "theRadFad",
                        "content": "Depends on what pruning (i.e., early termination) technique you\\'re using. It shouldn\\'t change anything if you don\\'t do any pruning. If you\\'re e.g. terminating a certain permutation as soon as the current maximum crosses the current best answer, sorting by descending order ensures that you cross this threshold early, saving time and space (via callstack)."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "How come the acceptance rate is more than 70% I didn\\'t even understand the question completely for like last 10 minutes :) and everyone in comments seems to find it tricky as well "
                    },
                    {
                        "username": "TKR_6",
                        "content": "Because everyone saw the solution and coded it."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Man this question made me overthink for hours after I saw the question and thought I will solve it later. Took me 5 mins to write the actual solution :/ P.S. Don\\'t overthink on some problems"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Understood the logic very late but code is very simple.\\nStandard Backtracking Problem"
                    },
                    {
                        "username": "alex2266",
                        "content": "its not hard to realize its a backtracking problem. its kind of difficult to implement though."
                    }
                ]
            },
            {
                "id": 1951285,
                "content": [
                    {
                        "username": "anshgrover020307",
                        "content": "[941,797,1475,638,191,712]\\n3\\n\\nwith this test case given sol is 1653 but according to my algo the optimize distribution for the above is  1579 ,1509 ,1666 with and with this distribution answer should be 1666 not 1653 ......\\ncan anyone explain me with this........"
                    },
                    {
                        "username": "quanqx",
                        "content": "Return the minimum unfairness of ALL distributions.\\nNOT FAIREST distribution."
                    },
                    {
                        "username": "CodeNinjaX",
                        "content": "How do you find if the current distribution is optimal or not?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Backtracking means that you have to try almost every case. But there is still an alternative by using DP & bit mask! It is doable."
                    },
                    {
                        "username": "webguru77777",
                        "content": "I\\'ve used DP+Bitmask+Backtracking lol\\nhttps://leetcode.com/problems/fair-distribution-of-cookies/submissions/983481061/"
                    },
                    {
                        "username": "divy_kant",
                        "content": "Whenever the question has said to find minimum of maximum or maximum of minimum , then it is a question of BINARY SEARCH ."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@divy_kant](/divy_kant) Yes, you\\'re absolutely correct. The technique you\\'re describing is sometimes referred to as \"binary search on the answer,\" which is a type of binary search where we use binary search to find the optimal value from a range of possible answers.\\n\\nIn such problems, we usually have a predicate function that can test whether a certain value is feasible or not, and our goal is to find the smallest or largest feasible value.\\n\\nFor the \"distribute cookies\" problem, a binary search approach could look something like this:\\n\\n1. **Finding the Search Space**: The lower bound can be the maximum value in the cookies array, and the upper bound can be the sum of all elements in the cookies array.\\n\\n2. **Predicate Function**: Given a value X, the predicate function checks if it is possible to distribute the cookies such that no child receives more than X cookies. This can be done by simulating the distribution and checking if the number of children exceeds \\'k\\'.\\n\\n3. **Binary Search**: We then perform a binary search over the possible values of X using our predicate function, aiming to find the smallest X for which the predicate function returns true.\\n\\nI agree that recognizing this pattern and determining the search space is often the most crucial part of solving such problems. Once we can do that, we can use a standard binary search template to find the solution."
                    },
                    {
                        "username": "divy_kant",
                        "content": "[@hbhutta](/hbhutta) \\n-> Yes sure , taking example of question like Maximum pages allocation , painters problem or aggressive cows - all these are solved using binary search and in each of them question stated to find minimum of maximum.\\n-> So , in these question if we are able to find the search space for out binary search , half of the question gets over , like it\\'s the main part to think and evaluate. in 50% cases which can be done by taking the lower limit as 0 or the least element and upper limit as the sum of all the elements.\\n-> You can check my solution for further understanding , it took a lot of effort in researching and explaining , PLEASE UPVOTE if it helped you a bit ."
                    },
                    {
                        "username": "hbhutta",
                        "content": "Can you explain this?"
                    },
                    {
                        "username": "Canaximui",
                        "content": "The question is to find the minimum unfairness and then in the example they used max(31, 30), can someone explain this to me ?\\n"
                    },
                    {
                        "username": "unters",
                        "content": "From the problem statement: \"The unfairness of a distribution is defined as the maximum total cookies obtained by a single child in the distribution.\""
                    },
                    {
                        "username": "cy171",
                        "content": "sorted the cookies in decrease order make my backtrack code from TLE to Beats 96 %,  I just don\\'t get it.\\n"
                    },
                    {
                        "username": "theRadFad",
                        "content": "Depends on what pruning (i.e., early termination) technique you\\'re using. It shouldn\\'t change anything if you don\\'t do any pruning. If you\\'re e.g. terminating a certain permutation as soon as the current maximum crosses the current best answer, sorting by descending order ensures that you cross this threshold early, saving time and space (via callstack)."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "How come the acceptance rate is more than 70% I didn\\'t even understand the question completely for like last 10 minutes :) and everyone in comments seems to find it tricky as well "
                    },
                    {
                        "username": "TKR_6",
                        "content": "Because everyone saw the solution and coded it."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Man this question made me overthink for hours after I saw the question and thought I will solve it later. Took me 5 mins to write the actual solution :/ P.S. Don\\'t overthink on some problems"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Understood the logic very late but code is very simple.\\nStandard Backtracking Problem"
                    },
                    {
                        "username": "alex2266",
                        "content": "its not hard to realize its a backtracking problem. its kind of difficult to implement though."
                    }
                ]
            },
            {
                "id": 1951055,
                "content": [
                    {
                        "username": "anshgrover020307",
                        "content": "[941,797,1475,638,191,712]\\n3\\n\\nwith this test case given sol is 1653 but according to my algo the optimize distribution for the above is  1579 ,1509 ,1666 with and with this distribution answer should be 1666 not 1653 ......\\ncan anyone explain me with this........"
                    },
                    {
                        "username": "quanqx",
                        "content": "Return the minimum unfairness of ALL distributions.\\nNOT FAIREST distribution."
                    },
                    {
                        "username": "CodeNinjaX",
                        "content": "How do you find if the current distribution is optimal or not?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Backtracking means that you have to try almost every case. But there is still an alternative by using DP & bit mask! It is doable."
                    },
                    {
                        "username": "webguru77777",
                        "content": "I\\'ve used DP+Bitmask+Backtracking lol\\nhttps://leetcode.com/problems/fair-distribution-of-cookies/submissions/983481061/"
                    },
                    {
                        "username": "divy_kant",
                        "content": "Whenever the question has said to find minimum of maximum or maximum of minimum , then it is a question of BINARY SEARCH ."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@divy_kant](/divy_kant) Yes, you\\'re absolutely correct. The technique you\\'re describing is sometimes referred to as \"binary search on the answer,\" which is a type of binary search where we use binary search to find the optimal value from a range of possible answers.\\n\\nIn such problems, we usually have a predicate function that can test whether a certain value is feasible or not, and our goal is to find the smallest or largest feasible value.\\n\\nFor the \"distribute cookies\" problem, a binary search approach could look something like this:\\n\\n1. **Finding the Search Space**: The lower bound can be the maximum value in the cookies array, and the upper bound can be the sum of all elements in the cookies array.\\n\\n2. **Predicate Function**: Given a value X, the predicate function checks if it is possible to distribute the cookies such that no child receives more than X cookies. This can be done by simulating the distribution and checking if the number of children exceeds \\'k\\'.\\n\\n3. **Binary Search**: We then perform a binary search over the possible values of X using our predicate function, aiming to find the smallest X for which the predicate function returns true.\\n\\nI agree that recognizing this pattern and determining the search space is often the most crucial part of solving such problems. Once we can do that, we can use a standard binary search template to find the solution."
                    },
                    {
                        "username": "divy_kant",
                        "content": "[@hbhutta](/hbhutta) \\n-> Yes sure , taking example of question like Maximum pages allocation , painters problem or aggressive cows - all these are solved using binary search and in each of them question stated to find minimum of maximum.\\n-> So , in these question if we are able to find the search space for out binary search , half of the question gets over , like it\\'s the main part to think and evaluate. in 50% cases which can be done by taking the lower limit as 0 or the least element and upper limit as the sum of all the elements.\\n-> You can check my solution for further understanding , it took a lot of effort in researching and explaining , PLEASE UPVOTE if it helped you a bit ."
                    },
                    {
                        "username": "hbhutta",
                        "content": "Can you explain this?"
                    },
                    {
                        "username": "Canaximui",
                        "content": "The question is to find the minimum unfairness and then in the example they used max(31, 30), can someone explain this to me ?\\n"
                    },
                    {
                        "username": "unters",
                        "content": "From the problem statement: \"The unfairness of a distribution is defined as the maximum total cookies obtained by a single child in the distribution.\""
                    },
                    {
                        "username": "cy171",
                        "content": "sorted the cookies in decrease order make my backtrack code from TLE to Beats 96 %,  I just don\\'t get it.\\n"
                    },
                    {
                        "username": "theRadFad",
                        "content": "Depends on what pruning (i.e., early termination) technique you\\'re using. It shouldn\\'t change anything if you don\\'t do any pruning. If you\\'re e.g. terminating a certain permutation as soon as the current maximum crosses the current best answer, sorting by descending order ensures that you cross this threshold early, saving time and space (via callstack)."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "How come the acceptance rate is more than 70% I didn\\'t even understand the question completely for like last 10 minutes :) and everyone in comments seems to find it tricky as well "
                    },
                    {
                        "username": "TKR_6",
                        "content": "Because everyone saw the solution and coded it."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Man this question made me overthink for hours after I saw the question and thought I will solve it later. Took me 5 mins to write the actual solution :/ P.S. Don\\'t overthink on some problems"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Understood the logic very late but code is very simple.\\nStandard Backtracking Problem"
                    },
                    {
                        "username": "alex2266",
                        "content": "its not hard to realize its a backtracking problem. its kind of difficult to implement though."
                    }
                ]
            },
            {
                "id": 1951052,
                "content": [
                    {
                        "username": "anshgrover020307",
                        "content": "[941,797,1475,638,191,712]\\n3\\n\\nwith this test case given sol is 1653 but according to my algo the optimize distribution for the above is  1579 ,1509 ,1666 with and with this distribution answer should be 1666 not 1653 ......\\ncan anyone explain me with this........"
                    },
                    {
                        "username": "quanqx",
                        "content": "Return the minimum unfairness of ALL distributions.\\nNOT FAIREST distribution."
                    },
                    {
                        "username": "CodeNinjaX",
                        "content": "How do you find if the current distribution is optimal or not?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Backtracking means that you have to try almost every case. But there is still an alternative by using DP & bit mask! It is doable."
                    },
                    {
                        "username": "webguru77777",
                        "content": "I\\'ve used DP+Bitmask+Backtracking lol\\nhttps://leetcode.com/problems/fair-distribution-of-cookies/submissions/983481061/"
                    },
                    {
                        "username": "divy_kant",
                        "content": "Whenever the question has said to find minimum of maximum or maximum of minimum , then it is a question of BINARY SEARCH ."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@divy_kant](/divy_kant) Yes, you\\'re absolutely correct. The technique you\\'re describing is sometimes referred to as \"binary search on the answer,\" which is a type of binary search where we use binary search to find the optimal value from a range of possible answers.\\n\\nIn such problems, we usually have a predicate function that can test whether a certain value is feasible or not, and our goal is to find the smallest or largest feasible value.\\n\\nFor the \"distribute cookies\" problem, a binary search approach could look something like this:\\n\\n1. **Finding the Search Space**: The lower bound can be the maximum value in the cookies array, and the upper bound can be the sum of all elements in the cookies array.\\n\\n2. **Predicate Function**: Given a value X, the predicate function checks if it is possible to distribute the cookies such that no child receives more than X cookies. This can be done by simulating the distribution and checking if the number of children exceeds \\'k\\'.\\n\\n3. **Binary Search**: We then perform a binary search over the possible values of X using our predicate function, aiming to find the smallest X for which the predicate function returns true.\\n\\nI agree that recognizing this pattern and determining the search space is often the most crucial part of solving such problems. Once we can do that, we can use a standard binary search template to find the solution."
                    },
                    {
                        "username": "divy_kant",
                        "content": "[@hbhutta](/hbhutta) \\n-> Yes sure , taking example of question like Maximum pages allocation , painters problem or aggressive cows - all these are solved using binary search and in each of them question stated to find minimum of maximum.\\n-> So , in these question if we are able to find the search space for out binary search , half of the question gets over , like it\\'s the main part to think and evaluate. in 50% cases which can be done by taking the lower limit as 0 or the least element and upper limit as the sum of all the elements.\\n-> You can check my solution for further understanding , it took a lot of effort in researching and explaining , PLEASE UPVOTE if it helped you a bit ."
                    },
                    {
                        "username": "hbhutta",
                        "content": "Can you explain this?"
                    },
                    {
                        "username": "Canaximui",
                        "content": "The question is to find the minimum unfairness and then in the example they used max(31, 30), can someone explain this to me ?\\n"
                    },
                    {
                        "username": "unters",
                        "content": "From the problem statement: \"The unfairness of a distribution is defined as the maximum total cookies obtained by a single child in the distribution.\""
                    },
                    {
                        "username": "cy171",
                        "content": "sorted the cookies in decrease order make my backtrack code from TLE to Beats 96 %,  I just don\\'t get it.\\n"
                    },
                    {
                        "username": "theRadFad",
                        "content": "Depends on what pruning (i.e., early termination) technique you\\'re using. It shouldn\\'t change anything if you don\\'t do any pruning. If you\\'re e.g. terminating a certain permutation as soon as the current maximum crosses the current best answer, sorting by descending order ensures that you cross this threshold early, saving time and space (via callstack)."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "How come the acceptance rate is more than 70% I didn\\'t even understand the question completely for like last 10 minutes :) and everyone in comments seems to find it tricky as well "
                    },
                    {
                        "username": "TKR_6",
                        "content": "Because everyone saw the solution and coded it."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Man this question made me overthink for hours after I saw the question and thought I will solve it later. Took me 5 mins to write the actual solution :/ P.S. Don\\'t overthink on some problems"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Understood the logic very late but code is very simple.\\nStandard Backtracking Problem"
                    },
                    {
                        "username": "alex2266",
                        "content": "its not hard to realize its a backtracking problem. its kind of difficult to implement though."
                    }
                ]
            },
            {
                "id": 1951850,
                "content": [
                    {
                        "username": "anshgrover020307",
                        "content": "[941,797,1475,638,191,712]\\n3\\n\\nwith this test case given sol is 1653 but according to my algo the optimize distribution for the above is  1579 ,1509 ,1666 with and with this distribution answer should be 1666 not 1653 ......\\ncan anyone explain me with this........"
                    },
                    {
                        "username": "quanqx",
                        "content": "Return the minimum unfairness of ALL distributions.\\nNOT FAIREST distribution."
                    },
                    {
                        "username": "CodeNinjaX",
                        "content": "How do you find if the current distribution is optimal or not?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Backtracking means that you have to try almost every case. But there is still an alternative by using DP & bit mask! It is doable."
                    },
                    {
                        "username": "webguru77777",
                        "content": "I\\'ve used DP+Bitmask+Backtracking lol\\nhttps://leetcode.com/problems/fair-distribution-of-cookies/submissions/983481061/"
                    },
                    {
                        "username": "divy_kant",
                        "content": "Whenever the question has said to find minimum of maximum or maximum of minimum , then it is a question of BINARY SEARCH ."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@divy_kant](/divy_kant) Yes, you\\'re absolutely correct. The technique you\\'re describing is sometimes referred to as \"binary search on the answer,\" which is a type of binary search where we use binary search to find the optimal value from a range of possible answers.\\n\\nIn such problems, we usually have a predicate function that can test whether a certain value is feasible or not, and our goal is to find the smallest or largest feasible value.\\n\\nFor the \"distribute cookies\" problem, a binary search approach could look something like this:\\n\\n1. **Finding the Search Space**: The lower bound can be the maximum value in the cookies array, and the upper bound can be the sum of all elements in the cookies array.\\n\\n2. **Predicate Function**: Given a value X, the predicate function checks if it is possible to distribute the cookies such that no child receives more than X cookies. This can be done by simulating the distribution and checking if the number of children exceeds \\'k\\'.\\n\\n3. **Binary Search**: We then perform a binary search over the possible values of X using our predicate function, aiming to find the smallest X for which the predicate function returns true.\\n\\nI agree that recognizing this pattern and determining the search space is often the most crucial part of solving such problems. Once we can do that, we can use a standard binary search template to find the solution."
                    },
                    {
                        "username": "divy_kant",
                        "content": "[@hbhutta](/hbhutta) \\n-> Yes sure , taking example of question like Maximum pages allocation , painters problem or aggressive cows - all these are solved using binary search and in each of them question stated to find minimum of maximum.\\n-> So , in these question if we are able to find the search space for out binary search , half of the question gets over , like it\\'s the main part to think and evaluate. in 50% cases which can be done by taking the lower limit as 0 or the least element and upper limit as the sum of all the elements.\\n-> You can check my solution for further understanding , it took a lot of effort in researching and explaining , PLEASE UPVOTE if it helped you a bit ."
                    },
                    {
                        "username": "hbhutta",
                        "content": "Can you explain this?"
                    },
                    {
                        "username": "Canaximui",
                        "content": "The question is to find the minimum unfairness and then in the example they used max(31, 30), can someone explain this to me ?\\n"
                    },
                    {
                        "username": "unters",
                        "content": "From the problem statement: \"The unfairness of a distribution is defined as the maximum total cookies obtained by a single child in the distribution.\""
                    },
                    {
                        "username": "cy171",
                        "content": "sorted the cookies in decrease order make my backtrack code from TLE to Beats 96 %,  I just don\\'t get it.\\n"
                    },
                    {
                        "username": "theRadFad",
                        "content": "Depends on what pruning (i.e., early termination) technique you\\'re using. It shouldn\\'t change anything if you don\\'t do any pruning. If you\\'re e.g. terminating a certain permutation as soon as the current maximum crosses the current best answer, sorting by descending order ensures that you cross this threshold early, saving time and space (via callstack)."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "How come the acceptance rate is more than 70% I didn\\'t even understand the question completely for like last 10 minutes :) and everyone in comments seems to find it tricky as well "
                    },
                    {
                        "username": "TKR_6",
                        "content": "Because everyone saw the solution and coded it."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Man this question made me overthink for hours after I saw the question and thought I will solve it later. Took me 5 mins to write the actual solution :/ P.S. Don\\'t overthink on some problems"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Understood the logic very late but code is very simple.\\nStandard Backtracking Problem"
                    },
                    {
                        "username": "alex2266",
                        "content": "its not hard to realize its a backtracking problem. its kind of difficult to implement though."
                    }
                ]
            },
            {
                "id": 1951294,
                "content": [
                    {
                        "username": "anshgrover020307",
                        "content": "[941,797,1475,638,191,712]\\n3\\n\\nwith this test case given sol is 1653 but according to my algo the optimize distribution for the above is  1579 ,1509 ,1666 with and with this distribution answer should be 1666 not 1653 ......\\ncan anyone explain me with this........"
                    },
                    {
                        "username": "quanqx",
                        "content": "Return the minimum unfairness of ALL distributions.\\nNOT FAIREST distribution."
                    },
                    {
                        "username": "CodeNinjaX",
                        "content": "How do you find if the current distribution is optimal or not?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Backtracking means that you have to try almost every case. But there is still an alternative by using DP & bit mask! It is doable."
                    },
                    {
                        "username": "webguru77777",
                        "content": "I\\'ve used DP+Bitmask+Backtracking lol\\nhttps://leetcode.com/problems/fair-distribution-of-cookies/submissions/983481061/"
                    },
                    {
                        "username": "divy_kant",
                        "content": "Whenever the question has said to find minimum of maximum or maximum of minimum , then it is a question of BINARY SEARCH ."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@divy_kant](/divy_kant) Yes, you\\'re absolutely correct. The technique you\\'re describing is sometimes referred to as \"binary search on the answer,\" which is a type of binary search where we use binary search to find the optimal value from a range of possible answers.\\n\\nIn such problems, we usually have a predicate function that can test whether a certain value is feasible or not, and our goal is to find the smallest or largest feasible value.\\n\\nFor the \"distribute cookies\" problem, a binary search approach could look something like this:\\n\\n1. **Finding the Search Space**: The lower bound can be the maximum value in the cookies array, and the upper bound can be the sum of all elements in the cookies array.\\n\\n2. **Predicate Function**: Given a value X, the predicate function checks if it is possible to distribute the cookies such that no child receives more than X cookies. This can be done by simulating the distribution and checking if the number of children exceeds \\'k\\'.\\n\\n3. **Binary Search**: We then perform a binary search over the possible values of X using our predicate function, aiming to find the smallest X for which the predicate function returns true.\\n\\nI agree that recognizing this pattern and determining the search space is often the most crucial part of solving such problems. Once we can do that, we can use a standard binary search template to find the solution."
                    },
                    {
                        "username": "divy_kant",
                        "content": "[@hbhutta](/hbhutta) \\n-> Yes sure , taking example of question like Maximum pages allocation , painters problem or aggressive cows - all these are solved using binary search and in each of them question stated to find minimum of maximum.\\n-> So , in these question if we are able to find the search space for out binary search , half of the question gets over , like it\\'s the main part to think and evaluate. in 50% cases which can be done by taking the lower limit as 0 or the least element and upper limit as the sum of all the elements.\\n-> You can check my solution for further understanding , it took a lot of effort in researching and explaining , PLEASE UPVOTE if it helped you a bit ."
                    },
                    {
                        "username": "hbhutta",
                        "content": "Can you explain this?"
                    },
                    {
                        "username": "Canaximui",
                        "content": "The question is to find the minimum unfairness and then in the example they used max(31, 30), can someone explain this to me ?\\n"
                    },
                    {
                        "username": "unters",
                        "content": "From the problem statement: \"The unfairness of a distribution is defined as the maximum total cookies obtained by a single child in the distribution.\""
                    },
                    {
                        "username": "cy171",
                        "content": "sorted the cookies in decrease order make my backtrack code from TLE to Beats 96 %,  I just don\\'t get it.\\n"
                    },
                    {
                        "username": "theRadFad",
                        "content": "Depends on what pruning (i.e., early termination) technique you\\'re using. It shouldn\\'t change anything if you don\\'t do any pruning. If you\\'re e.g. terminating a certain permutation as soon as the current maximum crosses the current best answer, sorting by descending order ensures that you cross this threshold early, saving time and space (via callstack)."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "How come the acceptance rate is more than 70% I didn\\'t even understand the question completely for like last 10 minutes :) and everyone in comments seems to find it tricky as well "
                    },
                    {
                        "username": "TKR_6",
                        "content": "Because everyone saw the solution and coded it."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Man this question made me overthink for hours after I saw the question and thought I will solve it later. Took me 5 mins to write the actual solution :/ P.S. Don\\'t overthink on some problems"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Understood the logic very late but code is very simple.\\nStandard Backtracking Problem"
                    },
                    {
                        "username": "alex2266",
                        "content": "its not hard to realize its a backtracking problem. its kind of difficult to implement though."
                    }
                ]
            },
            {
                "id": 1952160,
                "content": [
                    {
                        "username": "anshgrover020307",
                        "content": "[941,797,1475,638,191,712]\\n3\\n\\nwith this test case given sol is 1653 but according to my algo the optimize distribution for the above is  1579 ,1509 ,1666 with and with this distribution answer should be 1666 not 1653 ......\\ncan anyone explain me with this........"
                    },
                    {
                        "username": "quanqx",
                        "content": "Return the minimum unfairness of ALL distributions.\\nNOT FAIREST distribution."
                    },
                    {
                        "username": "CodeNinjaX",
                        "content": "How do you find if the current distribution is optimal or not?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Backtracking means that you have to try almost every case. But there is still an alternative by using DP & bit mask! It is doable."
                    },
                    {
                        "username": "webguru77777",
                        "content": "I\\'ve used DP+Bitmask+Backtracking lol\\nhttps://leetcode.com/problems/fair-distribution-of-cookies/submissions/983481061/"
                    },
                    {
                        "username": "divy_kant",
                        "content": "Whenever the question has said to find minimum of maximum or maximum of minimum , then it is a question of BINARY SEARCH ."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@divy_kant](/divy_kant) Yes, you\\'re absolutely correct. The technique you\\'re describing is sometimes referred to as \"binary search on the answer,\" which is a type of binary search where we use binary search to find the optimal value from a range of possible answers.\\n\\nIn such problems, we usually have a predicate function that can test whether a certain value is feasible or not, and our goal is to find the smallest or largest feasible value.\\n\\nFor the \"distribute cookies\" problem, a binary search approach could look something like this:\\n\\n1. **Finding the Search Space**: The lower bound can be the maximum value in the cookies array, and the upper bound can be the sum of all elements in the cookies array.\\n\\n2. **Predicate Function**: Given a value X, the predicate function checks if it is possible to distribute the cookies such that no child receives more than X cookies. This can be done by simulating the distribution and checking if the number of children exceeds \\'k\\'.\\n\\n3. **Binary Search**: We then perform a binary search over the possible values of X using our predicate function, aiming to find the smallest X for which the predicate function returns true.\\n\\nI agree that recognizing this pattern and determining the search space is often the most crucial part of solving such problems. Once we can do that, we can use a standard binary search template to find the solution."
                    },
                    {
                        "username": "divy_kant",
                        "content": "[@hbhutta](/hbhutta) \\n-> Yes sure , taking example of question like Maximum pages allocation , painters problem or aggressive cows - all these are solved using binary search and in each of them question stated to find minimum of maximum.\\n-> So , in these question if we are able to find the search space for out binary search , half of the question gets over , like it\\'s the main part to think and evaluate. in 50% cases which can be done by taking the lower limit as 0 or the least element and upper limit as the sum of all the elements.\\n-> You can check my solution for further understanding , it took a lot of effort in researching and explaining , PLEASE UPVOTE if it helped you a bit ."
                    },
                    {
                        "username": "hbhutta",
                        "content": "Can you explain this?"
                    },
                    {
                        "username": "Canaximui",
                        "content": "The question is to find the minimum unfairness and then in the example they used max(31, 30), can someone explain this to me ?\\n"
                    },
                    {
                        "username": "unters",
                        "content": "From the problem statement: \"The unfairness of a distribution is defined as the maximum total cookies obtained by a single child in the distribution.\""
                    },
                    {
                        "username": "cy171",
                        "content": "sorted the cookies in decrease order make my backtrack code from TLE to Beats 96 %,  I just don\\'t get it.\\n"
                    },
                    {
                        "username": "theRadFad",
                        "content": "Depends on what pruning (i.e., early termination) technique you\\'re using. It shouldn\\'t change anything if you don\\'t do any pruning. If you\\'re e.g. terminating a certain permutation as soon as the current maximum crosses the current best answer, sorting by descending order ensures that you cross this threshold early, saving time and space (via callstack)."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "How come the acceptance rate is more than 70% I didn\\'t even understand the question completely for like last 10 minutes :) and everyone in comments seems to find it tricky as well "
                    },
                    {
                        "username": "TKR_6",
                        "content": "Because everyone saw the solution and coded it."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Man this question made me overthink for hours after I saw the question and thought I will solve it later. Took me 5 mins to write the actual solution :/ P.S. Don\\'t overthink on some problems"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Understood the logic very late but code is very simple.\\nStandard Backtracking Problem"
                    },
                    {
                        "username": "alex2266",
                        "content": "its not hard to realize its a backtracking problem. its kind of difficult to implement though."
                    }
                ]
            },
            {
                "id": 1951970,
                "content": [
                    {
                        "username": "anshgrover020307",
                        "content": "[941,797,1475,638,191,712]\\n3\\n\\nwith this test case given sol is 1653 but according to my algo the optimize distribution for the above is  1579 ,1509 ,1666 with and with this distribution answer should be 1666 not 1653 ......\\ncan anyone explain me with this........"
                    },
                    {
                        "username": "quanqx",
                        "content": "Return the minimum unfairness of ALL distributions.\\nNOT FAIREST distribution."
                    },
                    {
                        "username": "CodeNinjaX",
                        "content": "How do you find if the current distribution is optimal or not?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Backtracking means that you have to try almost every case. But there is still an alternative by using DP & bit mask! It is doable."
                    },
                    {
                        "username": "webguru77777",
                        "content": "I\\'ve used DP+Bitmask+Backtracking lol\\nhttps://leetcode.com/problems/fair-distribution-of-cookies/submissions/983481061/"
                    },
                    {
                        "username": "divy_kant",
                        "content": "Whenever the question has said to find minimum of maximum or maximum of minimum , then it is a question of BINARY SEARCH ."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@divy_kant](/divy_kant) Yes, you\\'re absolutely correct. The technique you\\'re describing is sometimes referred to as \"binary search on the answer,\" which is a type of binary search where we use binary search to find the optimal value from a range of possible answers.\\n\\nIn such problems, we usually have a predicate function that can test whether a certain value is feasible or not, and our goal is to find the smallest or largest feasible value.\\n\\nFor the \"distribute cookies\" problem, a binary search approach could look something like this:\\n\\n1. **Finding the Search Space**: The lower bound can be the maximum value in the cookies array, and the upper bound can be the sum of all elements in the cookies array.\\n\\n2. **Predicate Function**: Given a value X, the predicate function checks if it is possible to distribute the cookies such that no child receives more than X cookies. This can be done by simulating the distribution and checking if the number of children exceeds \\'k\\'.\\n\\n3. **Binary Search**: We then perform a binary search over the possible values of X using our predicate function, aiming to find the smallest X for which the predicate function returns true.\\n\\nI agree that recognizing this pattern and determining the search space is often the most crucial part of solving such problems. Once we can do that, we can use a standard binary search template to find the solution."
                    },
                    {
                        "username": "divy_kant",
                        "content": "[@hbhutta](/hbhutta) \\n-> Yes sure , taking example of question like Maximum pages allocation , painters problem or aggressive cows - all these are solved using binary search and in each of them question stated to find minimum of maximum.\\n-> So , in these question if we are able to find the search space for out binary search , half of the question gets over , like it\\'s the main part to think and evaluate. in 50% cases which can be done by taking the lower limit as 0 or the least element and upper limit as the sum of all the elements.\\n-> You can check my solution for further understanding , it took a lot of effort in researching and explaining , PLEASE UPVOTE if it helped you a bit ."
                    },
                    {
                        "username": "hbhutta",
                        "content": "Can you explain this?"
                    },
                    {
                        "username": "Canaximui",
                        "content": "The question is to find the minimum unfairness and then in the example they used max(31, 30), can someone explain this to me ?\\n"
                    },
                    {
                        "username": "unters",
                        "content": "From the problem statement: \"The unfairness of a distribution is defined as the maximum total cookies obtained by a single child in the distribution.\""
                    },
                    {
                        "username": "cy171",
                        "content": "sorted the cookies in decrease order make my backtrack code from TLE to Beats 96 %,  I just don\\'t get it.\\n"
                    },
                    {
                        "username": "theRadFad",
                        "content": "Depends on what pruning (i.e., early termination) technique you\\'re using. It shouldn\\'t change anything if you don\\'t do any pruning. If you\\'re e.g. terminating a certain permutation as soon as the current maximum crosses the current best answer, sorting by descending order ensures that you cross this threshold early, saving time and space (via callstack)."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "How come the acceptance rate is more than 70% I didn\\'t even understand the question completely for like last 10 minutes :) and everyone in comments seems to find it tricky as well "
                    },
                    {
                        "username": "TKR_6",
                        "content": "Because everyone saw the solution and coded it."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Man this question made me overthink for hours after I saw the question and thought I will solve it later. Took me 5 mins to write the actual solution :/ P.S. Don\\'t overthink on some problems"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Understood the logic very late but code is very simple.\\nStandard Backtracking Problem"
                    },
                    {
                        "username": "alex2266",
                        "content": "its not hard to realize its a backtracking problem. its kind of difficult to implement though."
                    }
                ]
            },
            {
                "id": 1951896,
                "content": [
                    {
                        "username": "anshgrover020307",
                        "content": "[941,797,1475,638,191,712]\\n3\\n\\nwith this test case given sol is 1653 but according to my algo the optimize distribution for the above is  1579 ,1509 ,1666 with and with this distribution answer should be 1666 not 1653 ......\\ncan anyone explain me with this........"
                    },
                    {
                        "username": "quanqx",
                        "content": "Return the minimum unfairness of ALL distributions.\\nNOT FAIREST distribution."
                    },
                    {
                        "username": "CodeNinjaX",
                        "content": "How do you find if the current distribution is optimal or not?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Backtracking means that you have to try almost every case. But there is still an alternative by using DP & bit mask! It is doable."
                    },
                    {
                        "username": "webguru77777",
                        "content": "I\\'ve used DP+Bitmask+Backtracking lol\\nhttps://leetcode.com/problems/fair-distribution-of-cookies/submissions/983481061/"
                    },
                    {
                        "username": "divy_kant",
                        "content": "Whenever the question has said to find minimum of maximum or maximum of minimum , then it is a question of BINARY SEARCH ."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@divy_kant](/divy_kant) Yes, you\\'re absolutely correct. The technique you\\'re describing is sometimes referred to as \"binary search on the answer,\" which is a type of binary search where we use binary search to find the optimal value from a range of possible answers.\\n\\nIn such problems, we usually have a predicate function that can test whether a certain value is feasible or not, and our goal is to find the smallest or largest feasible value.\\n\\nFor the \"distribute cookies\" problem, a binary search approach could look something like this:\\n\\n1. **Finding the Search Space**: The lower bound can be the maximum value in the cookies array, and the upper bound can be the sum of all elements in the cookies array.\\n\\n2. **Predicate Function**: Given a value X, the predicate function checks if it is possible to distribute the cookies such that no child receives more than X cookies. This can be done by simulating the distribution and checking if the number of children exceeds \\'k\\'.\\n\\n3. **Binary Search**: We then perform a binary search over the possible values of X using our predicate function, aiming to find the smallest X for which the predicate function returns true.\\n\\nI agree that recognizing this pattern and determining the search space is often the most crucial part of solving such problems. Once we can do that, we can use a standard binary search template to find the solution."
                    },
                    {
                        "username": "divy_kant",
                        "content": "[@hbhutta](/hbhutta) \\n-> Yes sure , taking example of question like Maximum pages allocation , painters problem or aggressive cows - all these are solved using binary search and in each of them question stated to find minimum of maximum.\\n-> So , in these question if we are able to find the search space for out binary search , half of the question gets over , like it\\'s the main part to think and evaluate. in 50% cases which can be done by taking the lower limit as 0 or the least element and upper limit as the sum of all the elements.\\n-> You can check my solution for further understanding , it took a lot of effort in researching and explaining , PLEASE UPVOTE if it helped you a bit ."
                    },
                    {
                        "username": "hbhutta",
                        "content": "Can you explain this?"
                    },
                    {
                        "username": "Canaximui",
                        "content": "The question is to find the minimum unfairness and then in the example they used max(31, 30), can someone explain this to me ?\\n"
                    },
                    {
                        "username": "unters",
                        "content": "From the problem statement: \"The unfairness of a distribution is defined as the maximum total cookies obtained by a single child in the distribution.\""
                    },
                    {
                        "username": "cy171",
                        "content": "sorted the cookies in decrease order make my backtrack code from TLE to Beats 96 %,  I just don\\'t get it.\\n"
                    },
                    {
                        "username": "theRadFad",
                        "content": "Depends on what pruning (i.e., early termination) technique you\\'re using. It shouldn\\'t change anything if you don\\'t do any pruning. If you\\'re e.g. terminating a certain permutation as soon as the current maximum crosses the current best answer, sorting by descending order ensures that you cross this threshold early, saving time and space (via callstack)."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "How come the acceptance rate is more than 70% I didn\\'t even understand the question completely for like last 10 minutes :) and everyone in comments seems to find it tricky as well "
                    },
                    {
                        "username": "TKR_6",
                        "content": "Because everyone saw the solution and coded it."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Man this question made me overthink for hours after I saw the question and thought I will solve it later. Took me 5 mins to write the actual solution :/ P.S. Don\\'t overthink on some problems"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Understood the logic very late but code is very simple.\\nStandard Backtracking Problem"
                    },
                    {
                        "username": "alex2266",
                        "content": "its not hard to realize its a backtracking problem. its kind of difficult to implement though."
                    }
                ]
            },
            {
                "id": 1951762,
                "content": [
                    {
                        "username": "anshgrover020307",
                        "content": "[941,797,1475,638,191,712]\\n3\\n\\nwith this test case given sol is 1653 but according to my algo the optimize distribution for the above is  1579 ,1509 ,1666 with and with this distribution answer should be 1666 not 1653 ......\\ncan anyone explain me with this........"
                    },
                    {
                        "username": "quanqx",
                        "content": "Return the minimum unfairness of ALL distributions.\\nNOT FAIREST distribution."
                    },
                    {
                        "username": "CodeNinjaX",
                        "content": "How do you find if the current distribution is optimal or not?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Backtracking means that you have to try almost every case. But there is still an alternative by using DP & bit mask! It is doable."
                    },
                    {
                        "username": "webguru77777",
                        "content": "I\\'ve used DP+Bitmask+Backtracking lol\\nhttps://leetcode.com/problems/fair-distribution-of-cookies/submissions/983481061/"
                    },
                    {
                        "username": "divy_kant",
                        "content": "Whenever the question has said to find minimum of maximum or maximum of minimum , then it is a question of BINARY SEARCH ."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@divy_kant](/divy_kant) Yes, you\\'re absolutely correct. The technique you\\'re describing is sometimes referred to as \"binary search on the answer,\" which is a type of binary search where we use binary search to find the optimal value from a range of possible answers.\\n\\nIn such problems, we usually have a predicate function that can test whether a certain value is feasible or not, and our goal is to find the smallest or largest feasible value.\\n\\nFor the \"distribute cookies\" problem, a binary search approach could look something like this:\\n\\n1. **Finding the Search Space**: The lower bound can be the maximum value in the cookies array, and the upper bound can be the sum of all elements in the cookies array.\\n\\n2. **Predicate Function**: Given a value X, the predicate function checks if it is possible to distribute the cookies such that no child receives more than X cookies. This can be done by simulating the distribution and checking if the number of children exceeds \\'k\\'.\\n\\n3. **Binary Search**: We then perform a binary search over the possible values of X using our predicate function, aiming to find the smallest X for which the predicate function returns true.\\n\\nI agree that recognizing this pattern and determining the search space is often the most crucial part of solving such problems. Once we can do that, we can use a standard binary search template to find the solution."
                    },
                    {
                        "username": "divy_kant",
                        "content": "[@hbhutta](/hbhutta) \\n-> Yes sure , taking example of question like Maximum pages allocation , painters problem or aggressive cows - all these are solved using binary search and in each of them question stated to find minimum of maximum.\\n-> So , in these question if we are able to find the search space for out binary search , half of the question gets over , like it\\'s the main part to think and evaluate. in 50% cases which can be done by taking the lower limit as 0 or the least element and upper limit as the sum of all the elements.\\n-> You can check my solution for further understanding , it took a lot of effort in researching and explaining , PLEASE UPVOTE if it helped you a bit ."
                    },
                    {
                        "username": "hbhutta",
                        "content": "Can you explain this?"
                    },
                    {
                        "username": "Canaximui",
                        "content": "The question is to find the minimum unfairness and then in the example they used max(31, 30), can someone explain this to me ?\\n"
                    },
                    {
                        "username": "unters",
                        "content": "From the problem statement: \"The unfairness of a distribution is defined as the maximum total cookies obtained by a single child in the distribution.\""
                    },
                    {
                        "username": "cy171",
                        "content": "sorted the cookies in decrease order make my backtrack code from TLE to Beats 96 %,  I just don\\'t get it.\\n"
                    },
                    {
                        "username": "theRadFad",
                        "content": "Depends on what pruning (i.e., early termination) technique you\\'re using. It shouldn\\'t change anything if you don\\'t do any pruning. If you\\'re e.g. terminating a certain permutation as soon as the current maximum crosses the current best answer, sorting by descending order ensures that you cross this threshold early, saving time and space (via callstack)."
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "How come the acceptance rate is more than 70% I didn\\'t even understand the question completely for like last 10 minutes :) and everyone in comments seems to find it tricky as well "
                    },
                    {
                        "username": "TKR_6",
                        "content": "Because everyone saw the solution and coded it."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Man this question made me overthink for hours after I saw the question and thought I will solve it later. Took me 5 mins to write the actual solution :/ P.S. Don\\'t overthink on some problems"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Understood the logic very late but code is very simple.\\nStandard Backtracking Problem"
                    },
                    {
                        "username": "alex2266",
                        "content": "its not hard to realize its a backtracking problem. its kind of difficult to implement though."
                    }
                ]
            },
            {
                "id": 1951645,
                "content": [
                    {
                        "username": "Tobe_Triton",
                        "content": "I definitely dont understand this question"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "who think it\\'s binary search problem\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "vishalgunawad",
                        "content": "Time Limit Exceeded  \n27 / 38 testcases passed     \n\n passed all case use    \n```\n let key = `${start}, ${child.sort((a,b)=>a-b)}`\n```\n\n````\nvar distributeCookies = function (cookies, k) {\n\n  let memo = {}, end = cookies.length\n  return knapSack(0, Array(k).fill(0))\n\n  function knapSack(start, child) {\n\n//  let key = `${start}, ${child}`    TLE\n    let key = `${start}, ${child.sort((a, b) => a - b)}`\n    if (key in memo) return memo[key]\n\n    if (start == end) {\n      let max = 0\n      for (let bit of child) {\n        let sum = 0, i = 8\n        while (i--)\n          if (bit & (1 << i))\n            sum += cookies[i]\n        max = Math.max(max, sum)\n      }\n      return max\n    }\n    let ans = 1e6\n    for (let i = 0; i < k; i++) {\n      let newChild = [...child]\n      newChild[i] = (child[i] | (1 << start))\n      ans = Math.min(ans, knapSack(start + 1, newChild))\n    }\n    return memo[key] = ans\n  }\n}\n```"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "The constraints are the biggest hints to this problem "
                    },
                    {
                        "username": "Ganes123",
                        "content": "yeah!\\ngot it"
                    },
                    {
                        "username": "rawwar",
                        "content": "correct me if I am wrong. But, there is no mention that one child can\\'t get all of them. So, shouldn\\'t the maximum unfairness be just sum(input_list)? "
                    },
                    {
                        "username": "rawwar",
                        "content": "[@AllenJue](/AllenJue) My bad."
                    },
                    {
                        "username": "hbhutta",
                        "content": "Look at my comment above. I have a similar thought but I consider deviations."
                    },
                    {
                        "username": "AllenJue",
                        "content": "that would indeed maximize unfairness, but the problem asks to minimize unfairness"
                    },
                    {
                        "username": "czjnbb",
                        "content": "A pretty standard backtracking question."
                    },
                    {
                        "username": "Limon020",
                        "content": "Feels great  going from the backtrack solution to using binary search as an optimization"
                    },
                    {
                        "username": "raskushwaha8",
                        "content": "facing problem with the test case :- [941,797,1475,638,191,712], k = 3\\nthe most optimal discrimination seems to be [1579 1509 1666]\\nbut answer is 1653 which is not optimal. \\n\\nis anyone else facing this issue ?"
                    },
                    {
                        "username": "sukiboo",
                        "content": "I don't think there is an issue here.\nIn your split `[1579, 1509, 1666]` the unfairness is `1666`\nHowever, the optimal split would be `[1653, 1626, 1475]`, which results in unfairness of `1653` < `1666`"
                    },
                    {
                        "username": "pboddupalli",
                        "content": "Why is it difficult for leetcode folks to describe the problem more clearly ?"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "I solved the case. The problem is it says Memory Limit Exceeded. I have to optimize it beyond memoization."
                    }
                ]
            },
            {
                "id": 1951475,
                "content": [
                    {
                        "username": "Tobe_Triton",
                        "content": "I definitely dont understand this question"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "who think it\\'s binary search problem\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "vishalgunawad",
                        "content": "Time Limit Exceeded  \n27 / 38 testcases passed     \n\n passed all case use    \n```\n let key = `${start}, ${child.sort((a,b)=>a-b)}`\n```\n\n````\nvar distributeCookies = function (cookies, k) {\n\n  let memo = {}, end = cookies.length\n  return knapSack(0, Array(k).fill(0))\n\n  function knapSack(start, child) {\n\n//  let key = `${start}, ${child}`    TLE\n    let key = `${start}, ${child.sort((a, b) => a - b)}`\n    if (key in memo) return memo[key]\n\n    if (start == end) {\n      let max = 0\n      for (let bit of child) {\n        let sum = 0, i = 8\n        while (i--)\n          if (bit & (1 << i))\n            sum += cookies[i]\n        max = Math.max(max, sum)\n      }\n      return max\n    }\n    let ans = 1e6\n    for (let i = 0; i < k; i++) {\n      let newChild = [...child]\n      newChild[i] = (child[i] | (1 << start))\n      ans = Math.min(ans, knapSack(start + 1, newChild))\n    }\n    return memo[key] = ans\n  }\n}\n```"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "The constraints are the biggest hints to this problem "
                    },
                    {
                        "username": "Ganes123",
                        "content": "yeah!\\ngot it"
                    },
                    {
                        "username": "rawwar",
                        "content": "correct me if I am wrong. But, there is no mention that one child can\\'t get all of them. So, shouldn\\'t the maximum unfairness be just sum(input_list)? "
                    },
                    {
                        "username": "rawwar",
                        "content": "[@AllenJue](/AllenJue) My bad."
                    },
                    {
                        "username": "hbhutta",
                        "content": "Look at my comment above. I have a similar thought but I consider deviations."
                    },
                    {
                        "username": "AllenJue",
                        "content": "that would indeed maximize unfairness, but the problem asks to minimize unfairness"
                    },
                    {
                        "username": "czjnbb",
                        "content": "A pretty standard backtracking question."
                    },
                    {
                        "username": "Limon020",
                        "content": "Feels great  going from the backtrack solution to using binary search as an optimization"
                    },
                    {
                        "username": "raskushwaha8",
                        "content": "facing problem with the test case :- [941,797,1475,638,191,712], k = 3\\nthe most optimal discrimination seems to be [1579 1509 1666]\\nbut answer is 1653 which is not optimal. \\n\\nis anyone else facing this issue ?"
                    },
                    {
                        "username": "sukiboo",
                        "content": "I don't think there is an issue here.\nIn your split `[1579, 1509, 1666]` the unfairness is `1666`\nHowever, the optimal split would be `[1653, 1626, 1475]`, which results in unfairness of `1653` < `1666`"
                    },
                    {
                        "username": "pboddupalli",
                        "content": "Why is it difficult for leetcode folks to describe the problem more clearly ?"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "I solved the case. The problem is it says Memory Limit Exceeded. I have to optimize it beyond memoization."
                    }
                ]
            },
            {
                "id": 1951320,
                "content": [
                    {
                        "username": "Tobe_Triton",
                        "content": "I definitely dont understand this question"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "who think it\\'s binary search problem\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "vishalgunawad",
                        "content": "Time Limit Exceeded  \n27 / 38 testcases passed     \n\n passed all case use    \n```\n let key = `${start}, ${child.sort((a,b)=>a-b)}`\n```\n\n````\nvar distributeCookies = function (cookies, k) {\n\n  let memo = {}, end = cookies.length\n  return knapSack(0, Array(k).fill(0))\n\n  function knapSack(start, child) {\n\n//  let key = `${start}, ${child}`    TLE\n    let key = `${start}, ${child.sort((a, b) => a - b)}`\n    if (key in memo) return memo[key]\n\n    if (start == end) {\n      let max = 0\n      for (let bit of child) {\n        let sum = 0, i = 8\n        while (i--)\n          if (bit & (1 << i))\n            sum += cookies[i]\n        max = Math.max(max, sum)\n      }\n      return max\n    }\n    let ans = 1e6\n    for (let i = 0; i < k; i++) {\n      let newChild = [...child]\n      newChild[i] = (child[i] | (1 << start))\n      ans = Math.min(ans, knapSack(start + 1, newChild))\n    }\n    return memo[key] = ans\n  }\n}\n```"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "The constraints are the biggest hints to this problem "
                    },
                    {
                        "username": "Ganes123",
                        "content": "yeah!\\ngot it"
                    },
                    {
                        "username": "rawwar",
                        "content": "correct me if I am wrong. But, there is no mention that one child can\\'t get all of them. So, shouldn\\'t the maximum unfairness be just sum(input_list)? "
                    },
                    {
                        "username": "rawwar",
                        "content": "[@AllenJue](/AllenJue) My bad."
                    },
                    {
                        "username": "hbhutta",
                        "content": "Look at my comment above. I have a similar thought but I consider deviations."
                    },
                    {
                        "username": "AllenJue",
                        "content": "that would indeed maximize unfairness, but the problem asks to minimize unfairness"
                    },
                    {
                        "username": "czjnbb",
                        "content": "A pretty standard backtracking question."
                    },
                    {
                        "username": "Limon020",
                        "content": "Feels great  going from the backtrack solution to using binary search as an optimization"
                    },
                    {
                        "username": "raskushwaha8",
                        "content": "facing problem with the test case :- [941,797,1475,638,191,712], k = 3\\nthe most optimal discrimination seems to be [1579 1509 1666]\\nbut answer is 1653 which is not optimal. \\n\\nis anyone else facing this issue ?"
                    },
                    {
                        "username": "sukiboo",
                        "content": "I don't think there is an issue here.\nIn your split `[1579, 1509, 1666]` the unfairness is `1666`\nHowever, the optimal split would be `[1653, 1626, 1475]`, which results in unfairness of `1653` < `1666`"
                    },
                    {
                        "username": "pboddupalli",
                        "content": "Why is it difficult for leetcode folks to describe the problem more clearly ?"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "I solved the case. The problem is it says Memory Limit Exceeded. I have to optimize it beyond memoization."
                    }
                ]
            },
            {
                "id": 1951213,
                "content": [
                    {
                        "username": "Tobe_Triton",
                        "content": "I definitely dont understand this question"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "who think it\\'s binary search problem\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "vishalgunawad",
                        "content": "Time Limit Exceeded  \n27 / 38 testcases passed     \n\n passed all case use    \n```\n let key = `${start}, ${child.sort((a,b)=>a-b)}`\n```\n\n````\nvar distributeCookies = function (cookies, k) {\n\n  let memo = {}, end = cookies.length\n  return knapSack(0, Array(k).fill(0))\n\n  function knapSack(start, child) {\n\n//  let key = `${start}, ${child}`    TLE\n    let key = `${start}, ${child.sort((a, b) => a - b)}`\n    if (key in memo) return memo[key]\n\n    if (start == end) {\n      let max = 0\n      for (let bit of child) {\n        let sum = 0, i = 8\n        while (i--)\n          if (bit & (1 << i))\n            sum += cookies[i]\n        max = Math.max(max, sum)\n      }\n      return max\n    }\n    let ans = 1e6\n    for (let i = 0; i < k; i++) {\n      let newChild = [...child]\n      newChild[i] = (child[i] | (1 << start))\n      ans = Math.min(ans, knapSack(start + 1, newChild))\n    }\n    return memo[key] = ans\n  }\n}\n```"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "The constraints are the biggest hints to this problem "
                    },
                    {
                        "username": "Ganes123",
                        "content": "yeah!\\ngot it"
                    },
                    {
                        "username": "rawwar",
                        "content": "correct me if I am wrong. But, there is no mention that one child can\\'t get all of them. So, shouldn\\'t the maximum unfairness be just sum(input_list)? "
                    },
                    {
                        "username": "rawwar",
                        "content": "[@AllenJue](/AllenJue) My bad."
                    },
                    {
                        "username": "hbhutta",
                        "content": "Look at my comment above. I have a similar thought but I consider deviations."
                    },
                    {
                        "username": "AllenJue",
                        "content": "that would indeed maximize unfairness, but the problem asks to minimize unfairness"
                    },
                    {
                        "username": "czjnbb",
                        "content": "A pretty standard backtracking question."
                    },
                    {
                        "username": "Limon020",
                        "content": "Feels great  going from the backtrack solution to using binary search as an optimization"
                    },
                    {
                        "username": "raskushwaha8",
                        "content": "facing problem with the test case :- [941,797,1475,638,191,712], k = 3\\nthe most optimal discrimination seems to be [1579 1509 1666]\\nbut answer is 1653 which is not optimal. \\n\\nis anyone else facing this issue ?"
                    },
                    {
                        "username": "sukiboo",
                        "content": "I don't think there is an issue here.\nIn your split `[1579, 1509, 1666]` the unfairness is `1666`\nHowever, the optimal split would be `[1653, 1626, 1475]`, which results in unfairness of `1653` < `1666`"
                    },
                    {
                        "username": "pboddupalli",
                        "content": "Why is it difficult for leetcode folks to describe the problem more clearly ?"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "I solved the case. The problem is it says Memory Limit Exceeded. I have to optimize it beyond memoization."
                    }
                ]
            },
            {
                "id": 1951042,
                "content": [
                    {
                        "username": "Tobe_Triton",
                        "content": "I definitely dont understand this question"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "who think it\\'s binary search problem\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "vishalgunawad",
                        "content": "Time Limit Exceeded  \n27 / 38 testcases passed     \n\n passed all case use    \n```\n let key = `${start}, ${child.sort((a,b)=>a-b)}`\n```\n\n````\nvar distributeCookies = function (cookies, k) {\n\n  let memo = {}, end = cookies.length\n  return knapSack(0, Array(k).fill(0))\n\n  function knapSack(start, child) {\n\n//  let key = `${start}, ${child}`    TLE\n    let key = `${start}, ${child.sort((a, b) => a - b)}`\n    if (key in memo) return memo[key]\n\n    if (start == end) {\n      let max = 0\n      for (let bit of child) {\n        let sum = 0, i = 8\n        while (i--)\n          if (bit & (1 << i))\n            sum += cookies[i]\n        max = Math.max(max, sum)\n      }\n      return max\n    }\n    let ans = 1e6\n    for (let i = 0; i < k; i++) {\n      let newChild = [...child]\n      newChild[i] = (child[i] | (1 << start))\n      ans = Math.min(ans, knapSack(start + 1, newChild))\n    }\n    return memo[key] = ans\n  }\n}\n```"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "The constraints are the biggest hints to this problem "
                    },
                    {
                        "username": "Ganes123",
                        "content": "yeah!\\ngot it"
                    },
                    {
                        "username": "rawwar",
                        "content": "correct me if I am wrong. But, there is no mention that one child can\\'t get all of them. So, shouldn\\'t the maximum unfairness be just sum(input_list)? "
                    },
                    {
                        "username": "rawwar",
                        "content": "[@AllenJue](/AllenJue) My bad."
                    },
                    {
                        "username": "hbhutta",
                        "content": "Look at my comment above. I have a similar thought but I consider deviations."
                    },
                    {
                        "username": "AllenJue",
                        "content": "that would indeed maximize unfairness, but the problem asks to minimize unfairness"
                    },
                    {
                        "username": "czjnbb",
                        "content": "A pretty standard backtracking question."
                    },
                    {
                        "username": "Limon020",
                        "content": "Feels great  going from the backtrack solution to using binary search as an optimization"
                    },
                    {
                        "username": "raskushwaha8",
                        "content": "facing problem with the test case :- [941,797,1475,638,191,712], k = 3\\nthe most optimal discrimination seems to be [1579 1509 1666]\\nbut answer is 1653 which is not optimal. \\n\\nis anyone else facing this issue ?"
                    },
                    {
                        "username": "sukiboo",
                        "content": "I don't think there is an issue here.\nIn your split `[1579, 1509, 1666]` the unfairness is `1666`\nHowever, the optimal split would be `[1653, 1626, 1475]`, which results in unfairness of `1653` < `1666`"
                    },
                    {
                        "username": "pboddupalli",
                        "content": "Why is it difficult for leetcode folks to describe the problem more clearly ?"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "I solved the case. The problem is it says Memory Limit Exceeded. I have to optimize it beyond memoization."
                    }
                ]
            },
            {
                "id": 1951015,
                "content": [
                    {
                        "username": "Tobe_Triton",
                        "content": "I definitely dont understand this question"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "who think it\\'s binary search problem\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "vishalgunawad",
                        "content": "Time Limit Exceeded  \n27 / 38 testcases passed     \n\n passed all case use    \n```\n let key = `${start}, ${child.sort((a,b)=>a-b)}`\n```\n\n````\nvar distributeCookies = function (cookies, k) {\n\n  let memo = {}, end = cookies.length\n  return knapSack(0, Array(k).fill(0))\n\n  function knapSack(start, child) {\n\n//  let key = `${start}, ${child}`    TLE\n    let key = `${start}, ${child.sort((a, b) => a - b)}`\n    if (key in memo) return memo[key]\n\n    if (start == end) {\n      let max = 0\n      for (let bit of child) {\n        let sum = 0, i = 8\n        while (i--)\n          if (bit & (1 << i))\n            sum += cookies[i]\n        max = Math.max(max, sum)\n      }\n      return max\n    }\n    let ans = 1e6\n    for (let i = 0; i < k; i++) {\n      let newChild = [...child]\n      newChild[i] = (child[i] | (1 << start))\n      ans = Math.min(ans, knapSack(start + 1, newChild))\n    }\n    return memo[key] = ans\n  }\n}\n```"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "The constraints are the biggest hints to this problem "
                    },
                    {
                        "username": "Ganes123",
                        "content": "yeah!\\ngot it"
                    },
                    {
                        "username": "rawwar",
                        "content": "correct me if I am wrong. But, there is no mention that one child can\\'t get all of them. So, shouldn\\'t the maximum unfairness be just sum(input_list)? "
                    },
                    {
                        "username": "rawwar",
                        "content": "[@AllenJue](/AllenJue) My bad."
                    },
                    {
                        "username": "hbhutta",
                        "content": "Look at my comment above. I have a similar thought but I consider deviations."
                    },
                    {
                        "username": "AllenJue",
                        "content": "that would indeed maximize unfairness, but the problem asks to minimize unfairness"
                    },
                    {
                        "username": "czjnbb",
                        "content": "A pretty standard backtracking question."
                    },
                    {
                        "username": "Limon020",
                        "content": "Feels great  going from the backtrack solution to using binary search as an optimization"
                    },
                    {
                        "username": "raskushwaha8",
                        "content": "facing problem with the test case :- [941,797,1475,638,191,712], k = 3\\nthe most optimal discrimination seems to be [1579 1509 1666]\\nbut answer is 1653 which is not optimal. \\n\\nis anyone else facing this issue ?"
                    },
                    {
                        "username": "sukiboo",
                        "content": "I don't think there is an issue here.\nIn your split `[1579, 1509, 1666]` the unfairness is `1666`\nHowever, the optimal split would be `[1653, 1626, 1475]`, which results in unfairness of `1653` < `1666`"
                    },
                    {
                        "username": "pboddupalli",
                        "content": "Why is it difficult for leetcode folks to describe the problem more clearly ?"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "I solved the case. The problem is it says Memory Limit Exceeded. I have to optimize it beyond memoization."
                    }
                ]
            },
            {
                "id": 2053943,
                "content": [
                    {
                        "username": "Tobe_Triton",
                        "content": "I definitely dont understand this question"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "who think it\\'s binary search problem\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "vishalgunawad",
                        "content": "Time Limit Exceeded  \n27 / 38 testcases passed     \n\n passed all case use    \n```\n let key = `${start}, ${child.sort((a,b)=>a-b)}`\n```\n\n````\nvar distributeCookies = function (cookies, k) {\n\n  let memo = {}, end = cookies.length\n  return knapSack(0, Array(k).fill(0))\n\n  function knapSack(start, child) {\n\n//  let key = `${start}, ${child}`    TLE\n    let key = `${start}, ${child.sort((a, b) => a - b)}`\n    if (key in memo) return memo[key]\n\n    if (start == end) {\n      let max = 0\n      for (let bit of child) {\n        let sum = 0, i = 8\n        while (i--)\n          if (bit & (1 << i))\n            sum += cookies[i]\n        max = Math.max(max, sum)\n      }\n      return max\n    }\n    let ans = 1e6\n    for (let i = 0; i < k; i++) {\n      let newChild = [...child]\n      newChild[i] = (child[i] | (1 << start))\n      ans = Math.min(ans, knapSack(start + 1, newChild))\n    }\n    return memo[key] = ans\n  }\n}\n```"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "The constraints are the biggest hints to this problem "
                    },
                    {
                        "username": "Ganes123",
                        "content": "yeah!\\ngot it"
                    },
                    {
                        "username": "rawwar",
                        "content": "correct me if I am wrong. But, there is no mention that one child can\\'t get all of them. So, shouldn\\'t the maximum unfairness be just sum(input_list)? "
                    },
                    {
                        "username": "rawwar",
                        "content": "[@AllenJue](/AllenJue) My bad."
                    },
                    {
                        "username": "hbhutta",
                        "content": "Look at my comment above. I have a similar thought but I consider deviations."
                    },
                    {
                        "username": "AllenJue",
                        "content": "that would indeed maximize unfairness, but the problem asks to minimize unfairness"
                    },
                    {
                        "username": "czjnbb",
                        "content": "A pretty standard backtracking question."
                    },
                    {
                        "username": "Limon020",
                        "content": "Feels great  going from the backtrack solution to using binary search as an optimization"
                    },
                    {
                        "username": "raskushwaha8",
                        "content": "facing problem with the test case :- [941,797,1475,638,191,712], k = 3\\nthe most optimal discrimination seems to be [1579 1509 1666]\\nbut answer is 1653 which is not optimal. \\n\\nis anyone else facing this issue ?"
                    },
                    {
                        "username": "sukiboo",
                        "content": "I don't think there is an issue here.\nIn your split `[1579, 1509, 1666]` the unfairness is `1666`\nHowever, the optimal split would be `[1653, 1626, 1475]`, which results in unfairness of `1653` < `1666`"
                    },
                    {
                        "username": "pboddupalli",
                        "content": "Why is it difficult for leetcode folks to describe the problem more clearly ?"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "I solved the case. The problem is it says Memory Limit Exceeded. I have to optimize it beyond memoization."
                    }
                ]
            },
            {
                "id": 2048067,
                "content": [
                    {
                        "username": "Tobe_Triton",
                        "content": "I definitely dont understand this question"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "who think it\\'s binary search problem\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "vishalgunawad",
                        "content": "Time Limit Exceeded  \n27 / 38 testcases passed     \n\n passed all case use    \n```\n let key = `${start}, ${child.sort((a,b)=>a-b)}`\n```\n\n````\nvar distributeCookies = function (cookies, k) {\n\n  let memo = {}, end = cookies.length\n  return knapSack(0, Array(k).fill(0))\n\n  function knapSack(start, child) {\n\n//  let key = `${start}, ${child}`    TLE\n    let key = `${start}, ${child.sort((a, b) => a - b)}`\n    if (key in memo) return memo[key]\n\n    if (start == end) {\n      let max = 0\n      for (let bit of child) {\n        let sum = 0, i = 8\n        while (i--)\n          if (bit & (1 << i))\n            sum += cookies[i]\n        max = Math.max(max, sum)\n      }\n      return max\n    }\n    let ans = 1e6\n    for (let i = 0; i < k; i++) {\n      let newChild = [...child]\n      newChild[i] = (child[i] | (1 << start))\n      ans = Math.min(ans, knapSack(start + 1, newChild))\n    }\n    return memo[key] = ans\n  }\n}\n```"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "The constraints are the biggest hints to this problem "
                    },
                    {
                        "username": "Ganes123",
                        "content": "yeah!\\ngot it"
                    },
                    {
                        "username": "rawwar",
                        "content": "correct me if I am wrong. But, there is no mention that one child can\\'t get all of them. So, shouldn\\'t the maximum unfairness be just sum(input_list)? "
                    },
                    {
                        "username": "rawwar",
                        "content": "[@AllenJue](/AllenJue) My bad."
                    },
                    {
                        "username": "hbhutta",
                        "content": "Look at my comment above. I have a similar thought but I consider deviations."
                    },
                    {
                        "username": "AllenJue",
                        "content": "that would indeed maximize unfairness, but the problem asks to minimize unfairness"
                    },
                    {
                        "username": "czjnbb",
                        "content": "A pretty standard backtracking question."
                    },
                    {
                        "username": "Limon020",
                        "content": "Feels great  going from the backtrack solution to using binary search as an optimization"
                    },
                    {
                        "username": "raskushwaha8",
                        "content": "facing problem with the test case :- [941,797,1475,638,191,712], k = 3\\nthe most optimal discrimination seems to be [1579 1509 1666]\\nbut answer is 1653 which is not optimal. \\n\\nis anyone else facing this issue ?"
                    },
                    {
                        "username": "sukiboo",
                        "content": "I don't think there is an issue here.\nIn your split `[1579, 1509, 1666]` the unfairness is `1666`\nHowever, the optimal split would be `[1653, 1626, 1475]`, which results in unfairness of `1653` < `1666`"
                    },
                    {
                        "username": "pboddupalli",
                        "content": "Why is it difficult for leetcode folks to describe the problem more clearly ?"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "I solved the case. The problem is it says Memory Limit Exceeded. I have to optimize it beyond memoization."
                    }
                ]
            },
            {
                "id": 2018156,
                "content": [
                    {
                        "username": "Tobe_Triton",
                        "content": "I definitely dont understand this question"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "who think it\\'s binary search problem\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "vishalgunawad",
                        "content": "Time Limit Exceeded  \n27 / 38 testcases passed     \n\n passed all case use    \n```\n let key = `${start}, ${child.sort((a,b)=>a-b)}`\n```\n\n````\nvar distributeCookies = function (cookies, k) {\n\n  let memo = {}, end = cookies.length\n  return knapSack(0, Array(k).fill(0))\n\n  function knapSack(start, child) {\n\n//  let key = `${start}, ${child}`    TLE\n    let key = `${start}, ${child.sort((a, b) => a - b)}`\n    if (key in memo) return memo[key]\n\n    if (start == end) {\n      let max = 0\n      for (let bit of child) {\n        let sum = 0, i = 8\n        while (i--)\n          if (bit & (1 << i))\n            sum += cookies[i]\n        max = Math.max(max, sum)\n      }\n      return max\n    }\n    let ans = 1e6\n    for (let i = 0; i < k; i++) {\n      let newChild = [...child]\n      newChild[i] = (child[i] | (1 << start))\n      ans = Math.min(ans, knapSack(start + 1, newChild))\n    }\n    return memo[key] = ans\n  }\n}\n```"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "The constraints are the biggest hints to this problem "
                    },
                    {
                        "username": "Ganes123",
                        "content": "yeah!\\ngot it"
                    },
                    {
                        "username": "rawwar",
                        "content": "correct me if I am wrong. But, there is no mention that one child can\\'t get all of them. So, shouldn\\'t the maximum unfairness be just sum(input_list)? "
                    },
                    {
                        "username": "rawwar",
                        "content": "[@AllenJue](/AllenJue) My bad."
                    },
                    {
                        "username": "hbhutta",
                        "content": "Look at my comment above. I have a similar thought but I consider deviations."
                    },
                    {
                        "username": "AllenJue",
                        "content": "that would indeed maximize unfairness, but the problem asks to minimize unfairness"
                    },
                    {
                        "username": "czjnbb",
                        "content": "A pretty standard backtracking question."
                    },
                    {
                        "username": "Limon020",
                        "content": "Feels great  going from the backtrack solution to using binary search as an optimization"
                    },
                    {
                        "username": "raskushwaha8",
                        "content": "facing problem with the test case :- [941,797,1475,638,191,712], k = 3\\nthe most optimal discrimination seems to be [1579 1509 1666]\\nbut answer is 1653 which is not optimal. \\n\\nis anyone else facing this issue ?"
                    },
                    {
                        "username": "sukiboo",
                        "content": "I don't think there is an issue here.\nIn your split `[1579, 1509, 1666]` the unfairness is `1666`\nHowever, the optimal split would be `[1653, 1626, 1475]`, which results in unfairness of `1653` < `1666`"
                    },
                    {
                        "username": "pboddupalli",
                        "content": "Why is it difficult for leetcode folks to describe the problem more clearly ?"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "I solved the case. The problem is it says Memory Limit Exceeded. I have to optimize it beyond memoization."
                    }
                ]
            },
            {
                "id": 2007623,
                "content": [
                    {
                        "username": "Tobe_Triton",
                        "content": "I definitely dont understand this question"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "who think it\\'s binary search problem\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "vishalgunawad",
                        "content": "Time Limit Exceeded  \n27 / 38 testcases passed     \n\n passed all case use    \n```\n let key = `${start}, ${child.sort((a,b)=>a-b)}`\n```\n\n````\nvar distributeCookies = function (cookies, k) {\n\n  let memo = {}, end = cookies.length\n  return knapSack(0, Array(k).fill(0))\n\n  function knapSack(start, child) {\n\n//  let key = `${start}, ${child}`    TLE\n    let key = `${start}, ${child.sort((a, b) => a - b)}`\n    if (key in memo) return memo[key]\n\n    if (start == end) {\n      let max = 0\n      for (let bit of child) {\n        let sum = 0, i = 8\n        while (i--)\n          if (bit & (1 << i))\n            sum += cookies[i]\n        max = Math.max(max, sum)\n      }\n      return max\n    }\n    let ans = 1e6\n    for (let i = 0; i < k; i++) {\n      let newChild = [...child]\n      newChild[i] = (child[i] | (1 << start))\n      ans = Math.min(ans, knapSack(start + 1, newChild))\n    }\n    return memo[key] = ans\n  }\n}\n```"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "The constraints are the biggest hints to this problem "
                    },
                    {
                        "username": "Ganes123",
                        "content": "yeah!\\ngot it"
                    },
                    {
                        "username": "rawwar",
                        "content": "correct me if I am wrong. But, there is no mention that one child can\\'t get all of them. So, shouldn\\'t the maximum unfairness be just sum(input_list)? "
                    },
                    {
                        "username": "rawwar",
                        "content": "[@AllenJue](/AllenJue) My bad."
                    },
                    {
                        "username": "hbhutta",
                        "content": "Look at my comment above. I have a similar thought but I consider deviations."
                    },
                    {
                        "username": "AllenJue",
                        "content": "that would indeed maximize unfairness, but the problem asks to minimize unfairness"
                    },
                    {
                        "username": "czjnbb",
                        "content": "A pretty standard backtracking question."
                    },
                    {
                        "username": "Limon020",
                        "content": "Feels great  going from the backtrack solution to using binary search as an optimization"
                    },
                    {
                        "username": "raskushwaha8",
                        "content": "facing problem with the test case :- [941,797,1475,638,191,712], k = 3\\nthe most optimal discrimination seems to be [1579 1509 1666]\\nbut answer is 1653 which is not optimal. \\n\\nis anyone else facing this issue ?"
                    },
                    {
                        "username": "sukiboo",
                        "content": "I don't think there is an issue here.\nIn your split `[1579, 1509, 1666]` the unfairness is `1666`\nHowever, the optimal split would be `[1653, 1626, 1475]`, which results in unfairness of `1653` < `1666`"
                    },
                    {
                        "username": "pboddupalli",
                        "content": "Why is it difficult for leetcode folks to describe the problem more clearly ?"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "I solved the case. The problem is it says Memory Limit Exceeded. I have to optimize it beyond memoization."
                    }
                ]
            },
            {
                "id": 2000430,
                "content": [
                    {
                        "username": "silentgeek6",
                        "content": "can someone please tell why this code is giving wrong output Looks like this can be solved using BS on answer concept\\n\\nthis is similar to split largest sum help would be really appreciated \\n\\nclass Solution {\\n    public int distributeCookies(int[] cookies, int k) {\\n        int s=Integer.MIN_VALUE;\\n        int e=0;\\n        int res=0;\\n        for(int i=0;i<cookies.length;i++)\\n        {\\n            s=Math.max(s,cookies[i]);\\n            e+=cookies[i];\\n        }\\n        while(s<=e)\\n        {\\n            int m=s+(e-s)/2;\\n            if(isvalid(cookies,m,k))\\n            {\\n                res=m;\\n                e=m-1;\\n            }\\n            else{\\n                s=m+1;\\n            }\\n        }\\n        return res;\\n    }\\n    public boolean isvalid(int[]cookies,int m,int k)\\n    {\\n        int ch=1;\\n        int sum=0;\\n        for(int i=0;i<cookies.length;i++)\\n        {\\n            sum+=cookies[i];\\n            if(sum>m)\\n            {\\n                ch++;\\n                sum=cookies[i];\\n            }\\n            if(ch>k)\\n                return false;\\n      }\\n      return true;\\n\\n   \\n    }}\\n"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "Anyone Who thought 0/1 Knapsack in first go.\\nOr I am the Only One \\uD83D\\uDE22"
                    },
                    {
                        "username": "Mick3l",
                        "content": "Strange task. Spent 1h thinking how to solve it in polynomial time. Then checked editorial and wrote this comment"
                    },
                    {
                        "username": "ramandeep_singh",
                        "content": "I have come up with a brute force solution that uses recursion & backtracking to generate all possible K partitions from the array of cookies.\\n\\nHowever I get 38/38 test cases passed, but then I get a time limit exceeded? The last test case just shows:\\n\"cookies =\" (It\\'s blank in the console) Why is that happening?"
                    },
                    {
                        "username": "x065p4mp6",
                        "content": "greedy does not work"
                    },
                    {
                        "username": "hbhutta",
                        "content": "In the first step in the editorial, they say:\\n> Create an array distribute of length k initialized with all zeros, which represents the unfairness of each child.\\n\\nWhat do they mean by this? I thought unfairness was the maximum out of all the children, and then we minimize the unfairness over the backtracking stages. How can we have define unfairness for a single child?"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "I thougt naive backtracking solution won\\'t work,it would give TLE error but to my surprise it worked."
                    },
                    {
                        "username": "ashu_kr",
                        "content": "I was thinking that it is similar problem to distribute candies, thought in that way through DP but couldn\\'t get the answer. Can anybody explain why we cant use that"
                    },
                    {
                        "username": "harshpratap1601",
                        "content": "What will be the time and space complexity of this question?"
                    },
                    {
                        "username": "LupinTheThird",
                        "content": "am I the only one TLE\\'ing on a seemingly blank testcase?"
                    }
                ]
            },
            {
                "id": 1995693,
                "content": [
                    {
                        "username": "silentgeek6",
                        "content": "can someone please tell why this code is giving wrong output Looks like this can be solved using BS on answer concept\\n\\nthis is similar to split largest sum help would be really appreciated \\n\\nclass Solution {\\n    public int distributeCookies(int[] cookies, int k) {\\n        int s=Integer.MIN_VALUE;\\n        int e=0;\\n        int res=0;\\n        for(int i=0;i<cookies.length;i++)\\n        {\\n            s=Math.max(s,cookies[i]);\\n            e+=cookies[i];\\n        }\\n        while(s<=e)\\n        {\\n            int m=s+(e-s)/2;\\n            if(isvalid(cookies,m,k))\\n            {\\n                res=m;\\n                e=m-1;\\n            }\\n            else{\\n                s=m+1;\\n            }\\n        }\\n        return res;\\n    }\\n    public boolean isvalid(int[]cookies,int m,int k)\\n    {\\n        int ch=1;\\n        int sum=0;\\n        for(int i=0;i<cookies.length;i++)\\n        {\\n            sum+=cookies[i];\\n            if(sum>m)\\n            {\\n                ch++;\\n                sum=cookies[i];\\n            }\\n            if(ch>k)\\n                return false;\\n      }\\n      return true;\\n\\n   \\n    }}\\n"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "Anyone Who thought 0/1 Knapsack in first go.\\nOr I am the Only One \\uD83D\\uDE22"
                    },
                    {
                        "username": "Mick3l",
                        "content": "Strange task. Spent 1h thinking how to solve it in polynomial time. Then checked editorial and wrote this comment"
                    },
                    {
                        "username": "ramandeep_singh",
                        "content": "I have come up with a brute force solution that uses recursion & backtracking to generate all possible K partitions from the array of cookies.\\n\\nHowever I get 38/38 test cases passed, but then I get a time limit exceeded? The last test case just shows:\\n\"cookies =\" (It\\'s blank in the console) Why is that happening?"
                    },
                    {
                        "username": "x065p4mp6",
                        "content": "greedy does not work"
                    },
                    {
                        "username": "hbhutta",
                        "content": "In the first step in the editorial, they say:\\n> Create an array distribute of length k initialized with all zeros, which represents the unfairness of each child.\\n\\nWhat do they mean by this? I thought unfairness was the maximum out of all the children, and then we minimize the unfairness over the backtracking stages. How can we have define unfairness for a single child?"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "I thougt naive backtracking solution won\\'t work,it would give TLE error but to my surprise it worked."
                    },
                    {
                        "username": "ashu_kr",
                        "content": "I was thinking that it is similar problem to distribute candies, thought in that way through DP but couldn\\'t get the answer. Can anybody explain why we cant use that"
                    },
                    {
                        "username": "harshpratap1601",
                        "content": "What will be the time and space complexity of this question?"
                    },
                    {
                        "username": "LupinTheThird",
                        "content": "am I the only one TLE\\'ing on a seemingly blank testcase?"
                    }
                ]
            },
            {
                "id": 1976158,
                "content": [
                    {
                        "username": "silentgeek6",
                        "content": "can someone please tell why this code is giving wrong output Looks like this can be solved using BS on answer concept\\n\\nthis is similar to split largest sum help would be really appreciated \\n\\nclass Solution {\\n    public int distributeCookies(int[] cookies, int k) {\\n        int s=Integer.MIN_VALUE;\\n        int e=0;\\n        int res=0;\\n        for(int i=0;i<cookies.length;i++)\\n        {\\n            s=Math.max(s,cookies[i]);\\n            e+=cookies[i];\\n        }\\n        while(s<=e)\\n        {\\n            int m=s+(e-s)/2;\\n            if(isvalid(cookies,m,k))\\n            {\\n                res=m;\\n                e=m-1;\\n            }\\n            else{\\n                s=m+1;\\n            }\\n        }\\n        return res;\\n    }\\n    public boolean isvalid(int[]cookies,int m,int k)\\n    {\\n        int ch=1;\\n        int sum=0;\\n        for(int i=0;i<cookies.length;i++)\\n        {\\n            sum+=cookies[i];\\n            if(sum>m)\\n            {\\n                ch++;\\n                sum=cookies[i];\\n            }\\n            if(ch>k)\\n                return false;\\n      }\\n      return true;\\n\\n   \\n    }}\\n"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "Anyone Who thought 0/1 Knapsack in first go.\\nOr I am the Only One \\uD83D\\uDE22"
                    },
                    {
                        "username": "Mick3l",
                        "content": "Strange task. Spent 1h thinking how to solve it in polynomial time. Then checked editorial and wrote this comment"
                    },
                    {
                        "username": "ramandeep_singh",
                        "content": "I have come up with a brute force solution that uses recursion & backtracking to generate all possible K partitions from the array of cookies.\\n\\nHowever I get 38/38 test cases passed, but then I get a time limit exceeded? The last test case just shows:\\n\"cookies =\" (It\\'s blank in the console) Why is that happening?"
                    },
                    {
                        "username": "x065p4mp6",
                        "content": "greedy does not work"
                    },
                    {
                        "username": "hbhutta",
                        "content": "In the first step in the editorial, they say:\\n> Create an array distribute of length k initialized with all zeros, which represents the unfairness of each child.\\n\\nWhat do they mean by this? I thought unfairness was the maximum out of all the children, and then we minimize the unfairness over the backtracking stages. How can we have define unfairness for a single child?"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "I thougt naive backtracking solution won\\'t work,it would give TLE error but to my surprise it worked."
                    },
                    {
                        "username": "ashu_kr",
                        "content": "I was thinking that it is similar problem to distribute candies, thought in that way through DP but couldn\\'t get the answer. Can anybody explain why we cant use that"
                    },
                    {
                        "username": "harshpratap1601",
                        "content": "What will be the time and space complexity of this question?"
                    },
                    {
                        "username": "LupinTheThird",
                        "content": "am I the only one TLE\\'ing on a seemingly blank testcase?"
                    }
                ]
            },
            {
                "id": 1974575,
                "content": [
                    {
                        "username": "silentgeek6",
                        "content": "can someone please tell why this code is giving wrong output Looks like this can be solved using BS on answer concept\\n\\nthis is similar to split largest sum help would be really appreciated \\n\\nclass Solution {\\n    public int distributeCookies(int[] cookies, int k) {\\n        int s=Integer.MIN_VALUE;\\n        int e=0;\\n        int res=0;\\n        for(int i=0;i<cookies.length;i++)\\n        {\\n            s=Math.max(s,cookies[i]);\\n            e+=cookies[i];\\n        }\\n        while(s<=e)\\n        {\\n            int m=s+(e-s)/2;\\n            if(isvalid(cookies,m,k))\\n            {\\n                res=m;\\n                e=m-1;\\n            }\\n            else{\\n                s=m+1;\\n            }\\n        }\\n        return res;\\n    }\\n    public boolean isvalid(int[]cookies,int m,int k)\\n    {\\n        int ch=1;\\n        int sum=0;\\n        for(int i=0;i<cookies.length;i++)\\n        {\\n            sum+=cookies[i];\\n            if(sum>m)\\n            {\\n                ch++;\\n                sum=cookies[i];\\n            }\\n            if(ch>k)\\n                return false;\\n      }\\n      return true;\\n\\n   \\n    }}\\n"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "Anyone Who thought 0/1 Knapsack in first go.\\nOr I am the Only One \\uD83D\\uDE22"
                    },
                    {
                        "username": "Mick3l",
                        "content": "Strange task. Spent 1h thinking how to solve it in polynomial time. Then checked editorial and wrote this comment"
                    },
                    {
                        "username": "ramandeep_singh",
                        "content": "I have come up with a brute force solution that uses recursion & backtracking to generate all possible K partitions from the array of cookies.\\n\\nHowever I get 38/38 test cases passed, but then I get a time limit exceeded? The last test case just shows:\\n\"cookies =\" (It\\'s blank in the console) Why is that happening?"
                    },
                    {
                        "username": "x065p4mp6",
                        "content": "greedy does not work"
                    },
                    {
                        "username": "hbhutta",
                        "content": "In the first step in the editorial, they say:\\n> Create an array distribute of length k initialized with all zeros, which represents the unfairness of each child.\\n\\nWhat do they mean by this? I thought unfairness was the maximum out of all the children, and then we minimize the unfairness over the backtracking stages. How can we have define unfairness for a single child?"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "I thougt naive backtracking solution won\\'t work,it would give TLE error but to my surprise it worked."
                    },
                    {
                        "username": "ashu_kr",
                        "content": "I was thinking that it is similar problem to distribute candies, thought in that way through DP but couldn\\'t get the answer. Can anybody explain why we cant use that"
                    },
                    {
                        "username": "harshpratap1601",
                        "content": "What will be the time and space complexity of this question?"
                    },
                    {
                        "username": "LupinTheThird",
                        "content": "am I the only one TLE\\'ing on a seemingly blank testcase?"
                    }
                ]
            },
            {
                "id": 1962847,
                "content": [
                    {
                        "username": "silentgeek6",
                        "content": "can someone please tell why this code is giving wrong output Looks like this can be solved using BS on answer concept\\n\\nthis is similar to split largest sum help would be really appreciated \\n\\nclass Solution {\\n    public int distributeCookies(int[] cookies, int k) {\\n        int s=Integer.MIN_VALUE;\\n        int e=0;\\n        int res=0;\\n        for(int i=0;i<cookies.length;i++)\\n        {\\n            s=Math.max(s,cookies[i]);\\n            e+=cookies[i];\\n        }\\n        while(s<=e)\\n        {\\n            int m=s+(e-s)/2;\\n            if(isvalid(cookies,m,k))\\n            {\\n                res=m;\\n                e=m-1;\\n            }\\n            else{\\n                s=m+1;\\n            }\\n        }\\n        return res;\\n    }\\n    public boolean isvalid(int[]cookies,int m,int k)\\n    {\\n        int ch=1;\\n        int sum=0;\\n        for(int i=0;i<cookies.length;i++)\\n        {\\n            sum+=cookies[i];\\n            if(sum>m)\\n            {\\n                ch++;\\n                sum=cookies[i];\\n            }\\n            if(ch>k)\\n                return false;\\n      }\\n      return true;\\n\\n   \\n    }}\\n"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "Anyone Who thought 0/1 Knapsack in first go.\\nOr I am the Only One \\uD83D\\uDE22"
                    },
                    {
                        "username": "Mick3l",
                        "content": "Strange task. Spent 1h thinking how to solve it in polynomial time. Then checked editorial and wrote this comment"
                    },
                    {
                        "username": "ramandeep_singh",
                        "content": "I have come up with a brute force solution that uses recursion & backtracking to generate all possible K partitions from the array of cookies.\\n\\nHowever I get 38/38 test cases passed, but then I get a time limit exceeded? The last test case just shows:\\n\"cookies =\" (It\\'s blank in the console) Why is that happening?"
                    },
                    {
                        "username": "x065p4mp6",
                        "content": "greedy does not work"
                    },
                    {
                        "username": "hbhutta",
                        "content": "In the first step in the editorial, they say:\\n> Create an array distribute of length k initialized with all zeros, which represents the unfairness of each child.\\n\\nWhat do they mean by this? I thought unfairness was the maximum out of all the children, and then we minimize the unfairness over the backtracking stages. How can we have define unfairness for a single child?"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "I thougt naive backtracking solution won\\'t work,it would give TLE error but to my surprise it worked."
                    },
                    {
                        "username": "ashu_kr",
                        "content": "I was thinking that it is similar problem to distribute candies, thought in that way through DP but couldn\\'t get the answer. Can anybody explain why we cant use that"
                    },
                    {
                        "username": "harshpratap1601",
                        "content": "What will be the time and space complexity of this question?"
                    },
                    {
                        "username": "LupinTheThird",
                        "content": "am I the only one TLE\\'ing on a seemingly blank testcase?"
                    }
                ]
            },
            {
                "id": 1952170,
                "content": [
                    {
                        "username": "silentgeek6",
                        "content": "can someone please tell why this code is giving wrong output Looks like this can be solved using BS on answer concept\\n\\nthis is similar to split largest sum help would be really appreciated \\n\\nclass Solution {\\n    public int distributeCookies(int[] cookies, int k) {\\n        int s=Integer.MIN_VALUE;\\n        int e=0;\\n        int res=0;\\n        for(int i=0;i<cookies.length;i++)\\n        {\\n            s=Math.max(s,cookies[i]);\\n            e+=cookies[i];\\n        }\\n        while(s<=e)\\n        {\\n            int m=s+(e-s)/2;\\n            if(isvalid(cookies,m,k))\\n            {\\n                res=m;\\n                e=m-1;\\n            }\\n            else{\\n                s=m+1;\\n            }\\n        }\\n        return res;\\n    }\\n    public boolean isvalid(int[]cookies,int m,int k)\\n    {\\n        int ch=1;\\n        int sum=0;\\n        for(int i=0;i<cookies.length;i++)\\n        {\\n            sum+=cookies[i];\\n            if(sum>m)\\n            {\\n                ch++;\\n                sum=cookies[i];\\n            }\\n            if(ch>k)\\n                return false;\\n      }\\n      return true;\\n\\n   \\n    }}\\n"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "Anyone Who thought 0/1 Knapsack in first go.\\nOr I am the Only One \\uD83D\\uDE22"
                    },
                    {
                        "username": "Mick3l",
                        "content": "Strange task. Spent 1h thinking how to solve it in polynomial time. Then checked editorial and wrote this comment"
                    },
                    {
                        "username": "ramandeep_singh",
                        "content": "I have come up with a brute force solution that uses recursion & backtracking to generate all possible K partitions from the array of cookies.\\n\\nHowever I get 38/38 test cases passed, but then I get a time limit exceeded? The last test case just shows:\\n\"cookies =\" (It\\'s blank in the console) Why is that happening?"
                    },
                    {
                        "username": "x065p4mp6",
                        "content": "greedy does not work"
                    },
                    {
                        "username": "hbhutta",
                        "content": "In the first step in the editorial, they say:\\n> Create an array distribute of length k initialized with all zeros, which represents the unfairness of each child.\\n\\nWhat do they mean by this? I thought unfairness was the maximum out of all the children, and then we minimize the unfairness over the backtracking stages. How can we have define unfairness for a single child?"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "I thougt naive backtracking solution won\\'t work,it would give TLE error but to my surprise it worked."
                    },
                    {
                        "username": "ashu_kr",
                        "content": "I was thinking that it is similar problem to distribute candies, thought in that way through DP but couldn\\'t get the answer. Can anybody explain why we cant use that"
                    },
                    {
                        "username": "harshpratap1601",
                        "content": "What will be the time and space complexity of this question?"
                    },
                    {
                        "username": "LupinTheThird",
                        "content": "am I the only one TLE\\'ing on a seemingly blank testcase?"
                    }
                ]
            },
            {
                "id": 1952071,
                "content": [
                    {
                        "username": "silentgeek6",
                        "content": "can someone please tell why this code is giving wrong output Looks like this can be solved using BS on answer concept\\n\\nthis is similar to split largest sum help would be really appreciated \\n\\nclass Solution {\\n    public int distributeCookies(int[] cookies, int k) {\\n        int s=Integer.MIN_VALUE;\\n        int e=0;\\n        int res=0;\\n        for(int i=0;i<cookies.length;i++)\\n        {\\n            s=Math.max(s,cookies[i]);\\n            e+=cookies[i];\\n        }\\n        while(s<=e)\\n        {\\n            int m=s+(e-s)/2;\\n            if(isvalid(cookies,m,k))\\n            {\\n                res=m;\\n                e=m-1;\\n            }\\n            else{\\n                s=m+1;\\n            }\\n        }\\n        return res;\\n    }\\n    public boolean isvalid(int[]cookies,int m,int k)\\n    {\\n        int ch=1;\\n        int sum=0;\\n        for(int i=0;i<cookies.length;i++)\\n        {\\n            sum+=cookies[i];\\n            if(sum>m)\\n            {\\n                ch++;\\n                sum=cookies[i];\\n            }\\n            if(ch>k)\\n                return false;\\n      }\\n      return true;\\n\\n   \\n    }}\\n"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "Anyone Who thought 0/1 Knapsack in first go.\\nOr I am the Only One \\uD83D\\uDE22"
                    },
                    {
                        "username": "Mick3l",
                        "content": "Strange task. Spent 1h thinking how to solve it in polynomial time. Then checked editorial and wrote this comment"
                    },
                    {
                        "username": "ramandeep_singh",
                        "content": "I have come up with a brute force solution that uses recursion & backtracking to generate all possible K partitions from the array of cookies.\\n\\nHowever I get 38/38 test cases passed, but then I get a time limit exceeded? The last test case just shows:\\n\"cookies =\" (It\\'s blank in the console) Why is that happening?"
                    },
                    {
                        "username": "x065p4mp6",
                        "content": "greedy does not work"
                    },
                    {
                        "username": "hbhutta",
                        "content": "In the first step in the editorial, they say:\\n> Create an array distribute of length k initialized with all zeros, which represents the unfairness of each child.\\n\\nWhat do they mean by this? I thought unfairness was the maximum out of all the children, and then we minimize the unfairness over the backtracking stages. How can we have define unfairness for a single child?"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "I thougt naive backtracking solution won\\'t work,it would give TLE error but to my surprise it worked."
                    },
                    {
                        "username": "ashu_kr",
                        "content": "I was thinking that it is similar problem to distribute candies, thought in that way through DP but couldn\\'t get the answer. Can anybody explain why we cant use that"
                    },
                    {
                        "username": "harshpratap1601",
                        "content": "What will be the time and space complexity of this question?"
                    },
                    {
                        "username": "LupinTheThird",
                        "content": "am I the only one TLE\\'ing on a seemingly blank testcase?"
                    }
                ]
            },
            {
                "id": 1952046,
                "content": [
                    {
                        "username": "silentgeek6",
                        "content": "can someone please tell why this code is giving wrong output Looks like this can be solved using BS on answer concept\\n\\nthis is similar to split largest sum help would be really appreciated \\n\\nclass Solution {\\n    public int distributeCookies(int[] cookies, int k) {\\n        int s=Integer.MIN_VALUE;\\n        int e=0;\\n        int res=0;\\n        for(int i=0;i<cookies.length;i++)\\n        {\\n            s=Math.max(s,cookies[i]);\\n            e+=cookies[i];\\n        }\\n        while(s<=e)\\n        {\\n            int m=s+(e-s)/2;\\n            if(isvalid(cookies,m,k))\\n            {\\n                res=m;\\n                e=m-1;\\n            }\\n            else{\\n                s=m+1;\\n            }\\n        }\\n        return res;\\n    }\\n    public boolean isvalid(int[]cookies,int m,int k)\\n    {\\n        int ch=1;\\n        int sum=0;\\n        for(int i=0;i<cookies.length;i++)\\n        {\\n            sum+=cookies[i];\\n            if(sum>m)\\n            {\\n                ch++;\\n                sum=cookies[i];\\n            }\\n            if(ch>k)\\n                return false;\\n      }\\n      return true;\\n\\n   \\n    }}\\n"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "Anyone Who thought 0/1 Knapsack in first go.\\nOr I am the Only One \\uD83D\\uDE22"
                    },
                    {
                        "username": "Mick3l",
                        "content": "Strange task. Spent 1h thinking how to solve it in polynomial time. Then checked editorial and wrote this comment"
                    },
                    {
                        "username": "ramandeep_singh",
                        "content": "I have come up with a brute force solution that uses recursion & backtracking to generate all possible K partitions from the array of cookies.\\n\\nHowever I get 38/38 test cases passed, but then I get a time limit exceeded? The last test case just shows:\\n\"cookies =\" (It\\'s blank in the console) Why is that happening?"
                    },
                    {
                        "username": "x065p4mp6",
                        "content": "greedy does not work"
                    },
                    {
                        "username": "hbhutta",
                        "content": "In the first step in the editorial, they say:\\n> Create an array distribute of length k initialized with all zeros, which represents the unfairness of each child.\\n\\nWhat do they mean by this? I thought unfairness was the maximum out of all the children, and then we minimize the unfairness over the backtracking stages. How can we have define unfairness for a single child?"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "I thougt naive backtracking solution won\\'t work,it would give TLE error but to my surprise it worked."
                    },
                    {
                        "username": "ashu_kr",
                        "content": "I was thinking that it is similar problem to distribute candies, thought in that way through DP but couldn\\'t get the answer. Can anybody explain why we cant use that"
                    },
                    {
                        "username": "harshpratap1601",
                        "content": "What will be the time and space complexity of this question?"
                    },
                    {
                        "username": "LupinTheThird",
                        "content": "am I the only one TLE\\'ing on a seemingly blank testcase?"
                    }
                ]
            },
            {
                "id": 1951903,
                "content": [
                    {
                        "username": "silentgeek6",
                        "content": "can someone please tell why this code is giving wrong output Looks like this can be solved using BS on answer concept\\n\\nthis is similar to split largest sum help would be really appreciated \\n\\nclass Solution {\\n    public int distributeCookies(int[] cookies, int k) {\\n        int s=Integer.MIN_VALUE;\\n        int e=0;\\n        int res=0;\\n        for(int i=0;i<cookies.length;i++)\\n        {\\n            s=Math.max(s,cookies[i]);\\n            e+=cookies[i];\\n        }\\n        while(s<=e)\\n        {\\n            int m=s+(e-s)/2;\\n            if(isvalid(cookies,m,k))\\n            {\\n                res=m;\\n                e=m-1;\\n            }\\n            else{\\n                s=m+1;\\n            }\\n        }\\n        return res;\\n    }\\n    public boolean isvalid(int[]cookies,int m,int k)\\n    {\\n        int ch=1;\\n        int sum=0;\\n        for(int i=0;i<cookies.length;i++)\\n        {\\n            sum+=cookies[i];\\n            if(sum>m)\\n            {\\n                ch++;\\n                sum=cookies[i];\\n            }\\n            if(ch>k)\\n                return false;\\n      }\\n      return true;\\n\\n   \\n    }}\\n"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "Anyone Who thought 0/1 Knapsack in first go.\\nOr I am the Only One \\uD83D\\uDE22"
                    },
                    {
                        "username": "Mick3l",
                        "content": "Strange task. Spent 1h thinking how to solve it in polynomial time. Then checked editorial and wrote this comment"
                    },
                    {
                        "username": "ramandeep_singh",
                        "content": "I have come up with a brute force solution that uses recursion & backtracking to generate all possible K partitions from the array of cookies.\\n\\nHowever I get 38/38 test cases passed, but then I get a time limit exceeded? The last test case just shows:\\n\"cookies =\" (It\\'s blank in the console) Why is that happening?"
                    },
                    {
                        "username": "x065p4mp6",
                        "content": "greedy does not work"
                    },
                    {
                        "username": "hbhutta",
                        "content": "In the first step in the editorial, they say:\\n> Create an array distribute of length k initialized with all zeros, which represents the unfairness of each child.\\n\\nWhat do they mean by this? I thought unfairness was the maximum out of all the children, and then we minimize the unfairness over the backtracking stages. How can we have define unfairness for a single child?"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "I thougt naive backtracking solution won\\'t work,it would give TLE error but to my surprise it worked."
                    },
                    {
                        "username": "ashu_kr",
                        "content": "I was thinking that it is similar problem to distribute candies, thought in that way through DP but couldn\\'t get the answer. Can anybody explain why we cant use that"
                    },
                    {
                        "username": "harshpratap1601",
                        "content": "What will be the time and space complexity of this question?"
                    },
                    {
                        "username": "LupinTheThird",
                        "content": "am I the only one TLE\\'ing on a seemingly blank testcase?"
                    }
                ]
            },
            {
                "id": 1951773,
                "content": [
                    {
                        "username": "silentgeek6",
                        "content": "can someone please tell why this code is giving wrong output Looks like this can be solved using BS on answer concept\\n\\nthis is similar to split largest sum help would be really appreciated \\n\\nclass Solution {\\n    public int distributeCookies(int[] cookies, int k) {\\n        int s=Integer.MIN_VALUE;\\n        int e=0;\\n        int res=0;\\n        for(int i=0;i<cookies.length;i++)\\n        {\\n            s=Math.max(s,cookies[i]);\\n            e+=cookies[i];\\n        }\\n        while(s<=e)\\n        {\\n            int m=s+(e-s)/2;\\n            if(isvalid(cookies,m,k))\\n            {\\n                res=m;\\n                e=m-1;\\n            }\\n            else{\\n                s=m+1;\\n            }\\n        }\\n        return res;\\n    }\\n    public boolean isvalid(int[]cookies,int m,int k)\\n    {\\n        int ch=1;\\n        int sum=0;\\n        for(int i=0;i<cookies.length;i++)\\n        {\\n            sum+=cookies[i];\\n            if(sum>m)\\n            {\\n                ch++;\\n                sum=cookies[i];\\n            }\\n            if(ch>k)\\n                return false;\\n      }\\n      return true;\\n\\n   \\n    }}\\n"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "Anyone Who thought 0/1 Knapsack in first go.\\nOr I am the Only One \\uD83D\\uDE22"
                    },
                    {
                        "username": "Mick3l",
                        "content": "Strange task. Spent 1h thinking how to solve it in polynomial time. Then checked editorial and wrote this comment"
                    },
                    {
                        "username": "ramandeep_singh",
                        "content": "I have come up with a brute force solution that uses recursion & backtracking to generate all possible K partitions from the array of cookies.\\n\\nHowever I get 38/38 test cases passed, but then I get a time limit exceeded? The last test case just shows:\\n\"cookies =\" (It\\'s blank in the console) Why is that happening?"
                    },
                    {
                        "username": "x065p4mp6",
                        "content": "greedy does not work"
                    },
                    {
                        "username": "hbhutta",
                        "content": "In the first step in the editorial, they say:\\n> Create an array distribute of length k initialized with all zeros, which represents the unfairness of each child.\\n\\nWhat do they mean by this? I thought unfairness was the maximum out of all the children, and then we minimize the unfairness over the backtracking stages. How can we have define unfairness for a single child?"
                    },
                    {
                        "username": "dheeraj2002_",
                        "content": "I thougt naive backtracking solution won\\'t work,it would give TLE error but to my surprise it worked."
                    },
                    {
                        "username": "ashu_kr",
                        "content": "I was thinking that it is similar problem to distribute candies, thought in that way through DP but couldn\\'t get the answer. Can anybody explain why we cant use that"
                    },
                    {
                        "username": "harshpratap1601",
                        "content": "What will be the time and space complexity of this question?"
                    },
                    {
                        "username": "LupinTheThird",
                        "content": "am I the only one TLE\\'ing on a seemingly blank testcase?"
                    }
                ]
            },
            {
                "id": 1951738,
                "content": [
                    {
                        "username": "Hatsoff",
                        "content": "Don\\'t overthink, check constraints."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Speaking of the importance of the right test cases selection.\nJust adding simple check for two edge cases reduces the runtime from 600ms to **0**\n```\nlet n = cookies.count\n\n// edge cases\nif n == k { return cookies.max()! } // one-to-one distribution\nelse if n == k + 1\n{   // find 2 smallest cookie bags and give them both to some kid\n    var indices = Set(cookies.indices)\n    let minInd1 = indices.min { cookies[$0] < cookies[$1] }!\n    indices.remove(minInd1)\n    let minInd2 = indices.min { cookies[$0] < cookies[$1] }!\n    let maxCookieBag = cookies.max()!\n    return max(maxCookieBag, (cookies[minInd1] + cookies[minInd2]))\n}\n```\n[640ms submission](https://leetcode.com/problems/fair-distribution-of-cookies/submissions/983773575/)\n[0ms submission](https://leetcode.com/problems/fair-distribution-of-cookies/submissions/983769578/)\n\n[@LeetCode](/LeetCode), does that seem ok to you?\n\nUPD: Oh, come on. I found yet another way to 0ms.\nConsider the fact that if there are currently several kids with the same cookie value, we only need to check one of them, as giving cookie to others will lead to the same state. This optimization alone reduces runtime to 0:\n[0 ms submission](https://leetcode.com/problems/fair-distribution-of-cookies/submissions/983896552/)"
                    },
                    {
                        "username": "gopal_0208",
                        "content": "Can\\'t we do it with minimum subset problem approach?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem of distributing cookies among children such that the maximum number of cookies received by any child is minimized can be thought of as a variation of the subset sum problem. However, there are some key differences that make this problem more complex and prevent a direct application of the subset sum approach.\\n\\nIn the subset sum problem, we\\'re given a set of numbers and we have to determine whether there is a subset whose sum is a particular target value. It\\'s a binary problem: either such a subset exists or it doesn\\'t.\\n\\nIn this problem, we\\'re given a set of numbers (the cookies) and a number of subsets (the children), and we have to divide the numbers among the subsets such that the maximum sum in any subset is minimized. This is an optimization problem rather than a binary one.\\n\\nFurthermore, in the subset sum problem, we only need to find one subset that meets the criteria. In this problem, we need to find a distribution of the entire set across multiple subsets.\\n\\nWhile there are some similarities between the problems, they are different in key ways. In particular, this problem has additional constraints and a different objective, which make it more complex. You would likely need a more advanced algorithm, such as backtracking or binary search, to solve it effectively."
                    },
                    {
                        "username": "rmtngdr",
                        "content": "I came up with the backtracking idea within 10 minutes, but i was sure there must be a more efficient solution. So I wasted another hour looking for a more optimal solution :("
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "kind of ez question\\n"
                    },
                    {
                        "username": "PrakharUniyal",
                        "content": "Where does it say that a child must be given non-zero cookies? You people don't understand the meaning of \"unfairness\".\n(Just kidding)"
                    },
                    {
                        "username": "ixeridium",
                        "content": "Sure, but the condition 2 <= k <= cookies.length implies that each child gets some cookies in the optimal solution. I.e., if there is a child without cookies then one can take a bag from the child with the most cookies and give that to the former one. This would lead to a better solution."
                    },
                    {
                        "username": "abhiMikasa",
                        "content": " ```\nclass Solution {\n    public static int maximaxi = Integer.MAX_VALUE;\n    public static int distributeCookies(int[] cookies, int k) {\n        distidfs(cookies,k,0,new int[k]);\n        int a = maximaxi;\n        maximaxi = Integer.MAX_VALUE;\n        return a;\n    }\n     public static  void  distidfs(int[] cookies, int k , int index , int[] child){\n        if(index == cookies.length){\n            int max = 0;\n            for(int i = 0; i < child.length; i++){\n                max = Math.max(max,child[i]);\n            }\n            maximaxi = Math.min(max,maximaxi);\n            return;\n        }\n        for(int i = 0; i < child.length; i++){\n            child[i] += cookies[index];\n            distidfs(cookies,k,index + 1,child);\n            child[i] -= cookies[index];\n            if(child[i] == 0) break;\n        }\n     }\n}\n```\n\n\nhow the statement :- `if(child[i] == 0) break;` \nincreases the efficiency of code."
                    },
                    {
                        "username": "bparanj",
                        "content": "The statement `if(child[i] == 0) break;` is a pruning operation that helps to eliminate some unnecessary recursive calls, thereby increasing the efficiency of the code.\\n\\nIn the context of this problem, it\\'s saying that if a child hasn\\'t received any cookies yet (`child[i] == 0`), we don\\'t need to consider giving cookies to the rest of the children for the current distribution. This is because we\\'re trying to minimize the maximum number of cookies any child gets, and giving more cookies to children who have already received cookies will only increase the maximum.\\n\\nBy breaking early when we encounter a child who hasn\\'t received any cookies yet, we eliminate the possibility of distributing cookies in a way that is guaranteed to be suboptimal (i.e., a way that results in a larger maximum number of cookies for any child). This pruning operation helps to reduce the size of the search space that the backtracking algorithm needs to explore, thereby increasing its efficiency.\\n\\nHowever, please note that this type of optimization is problem-specific and depends on the problem\\'s unique requirements and constraints. It may not be applicable or beneficial in all situations."
                    },
                    {
                        "username": "bhruti1",
                        "content": "Interesting problem statement."
                    },
                    {
                        "username": "Master_Floppa",
                        "content": "Why is the dp solution failing here? Isn\\'t there a repetitive subproblem?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem of distributing cookies to children might initially seem like it could be solved using a dynamic programming (DP) approach, especially given that there seems to be overlapping subproblems (i.e., the distribution of remaining cookies after giving some to a child). \\n\\nHowever, there are a few reasons why a traditional DP solution could fail or be inefficient for this problem:\\n\\n1. **State definition is complex**: In a DP problem, we typically define the state in terms of a few variables, like the current index or remaining value, and we base our subproblems around these states. However, in this case, to define a state, we need to keep track of the remaining cookies, the number of children left, and also how much each child has already received to maintain the \"minimum unfairness\" constraint. This leads to a very high-dimensional DP table, which can be challenging to handle and reason about.\\n\\n2. **No optimal substructure**: DP relies on the principle of optimal substructure, which says that the optimal solution to a problem can be constructed efficiently from the optimal solutions of its subproblems. However, in this problem, giving more cookies to a child in an attempt to optimize the current distribution does not guarantee that this will lead to the optimal solution in the end, as we are trying to minimize the maximum number of cookies a child can get. The choice at one step depends on choices at other steps, which does not adhere strictly to the optimal substructure property.\\n\\nThese factors make the problem unsuitable for a straightforward DP solution. However, a more advanced technique, such as using DP with bitmasking to keep track of which cookies have been distributed, might be possible but would be far more complex than simpler approaches like backtracking or binary search."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Binary Search + 0/1Kp ??"
                    }
                ]
            },
            {
                "id": 1951728,
                "content": [
                    {
                        "username": "Hatsoff",
                        "content": "Don\\'t overthink, check constraints."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Speaking of the importance of the right test cases selection.\nJust adding simple check for two edge cases reduces the runtime from 600ms to **0**\n```\nlet n = cookies.count\n\n// edge cases\nif n == k { return cookies.max()! } // one-to-one distribution\nelse if n == k + 1\n{   // find 2 smallest cookie bags and give them both to some kid\n    var indices = Set(cookies.indices)\n    let minInd1 = indices.min { cookies[$0] < cookies[$1] }!\n    indices.remove(minInd1)\n    let minInd2 = indices.min { cookies[$0] < cookies[$1] }!\n    let maxCookieBag = cookies.max()!\n    return max(maxCookieBag, (cookies[minInd1] + cookies[minInd2]))\n}\n```\n[640ms submission](https://leetcode.com/problems/fair-distribution-of-cookies/submissions/983773575/)\n[0ms submission](https://leetcode.com/problems/fair-distribution-of-cookies/submissions/983769578/)\n\n[@LeetCode](/LeetCode), does that seem ok to you?\n\nUPD: Oh, come on. I found yet another way to 0ms.\nConsider the fact that if there are currently several kids with the same cookie value, we only need to check one of them, as giving cookie to others will lead to the same state. This optimization alone reduces runtime to 0:\n[0 ms submission](https://leetcode.com/problems/fair-distribution-of-cookies/submissions/983896552/)"
                    },
                    {
                        "username": "gopal_0208",
                        "content": "Can\\'t we do it with minimum subset problem approach?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem of distributing cookies among children such that the maximum number of cookies received by any child is minimized can be thought of as a variation of the subset sum problem. However, there are some key differences that make this problem more complex and prevent a direct application of the subset sum approach.\\n\\nIn the subset sum problem, we\\'re given a set of numbers and we have to determine whether there is a subset whose sum is a particular target value. It\\'s a binary problem: either such a subset exists or it doesn\\'t.\\n\\nIn this problem, we\\'re given a set of numbers (the cookies) and a number of subsets (the children), and we have to divide the numbers among the subsets such that the maximum sum in any subset is minimized. This is an optimization problem rather than a binary one.\\n\\nFurthermore, in the subset sum problem, we only need to find one subset that meets the criteria. In this problem, we need to find a distribution of the entire set across multiple subsets.\\n\\nWhile there are some similarities between the problems, they are different in key ways. In particular, this problem has additional constraints and a different objective, which make it more complex. You would likely need a more advanced algorithm, such as backtracking or binary search, to solve it effectively."
                    },
                    {
                        "username": "rmtngdr",
                        "content": "I came up with the backtracking idea within 10 minutes, but i was sure there must be a more efficient solution. So I wasted another hour looking for a more optimal solution :("
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "kind of ez question\\n"
                    },
                    {
                        "username": "PrakharUniyal",
                        "content": "Where does it say that a child must be given non-zero cookies? You people don't understand the meaning of \"unfairness\".\n(Just kidding)"
                    },
                    {
                        "username": "ixeridium",
                        "content": "Sure, but the condition 2 <= k <= cookies.length implies that each child gets some cookies in the optimal solution. I.e., if there is a child without cookies then one can take a bag from the child with the most cookies and give that to the former one. This would lead to a better solution."
                    },
                    {
                        "username": "abhiMikasa",
                        "content": " ```\nclass Solution {\n    public static int maximaxi = Integer.MAX_VALUE;\n    public static int distributeCookies(int[] cookies, int k) {\n        distidfs(cookies,k,0,new int[k]);\n        int a = maximaxi;\n        maximaxi = Integer.MAX_VALUE;\n        return a;\n    }\n     public static  void  distidfs(int[] cookies, int k , int index , int[] child){\n        if(index == cookies.length){\n            int max = 0;\n            for(int i = 0; i < child.length; i++){\n                max = Math.max(max,child[i]);\n            }\n            maximaxi = Math.min(max,maximaxi);\n            return;\n        }\n        for(int i = 0; i < child.length; i++){\n            child[i] += cookies[index];\n            distidfs(cookies,k,index + 1,child);\n            child[i] -= cookies[index];\n            if(child[i] == 0) break;\n        }\n     }\n}\n```\n\n\nhow the statement :- `if(child[i] == 0) break;` \nincreases the efficiency of code."
                    },
                    {
                        "username": "bparanj",
                        "content": "The statement `if(child[i] == 0) break;` is a pruning operation that helps to eliminate some unnecessary recursive calls, thereby increasing the efficiency of the code.\\n\\nIn the context of this problem, it\\'s saying that if a child hasn\\'t received any cookies yet (`child[i] == 0`), we don\\'t need to consider giving cookies to the rest of the children for the current distribution. This is because we\\'re trying to minimize the maximum number of cookies any child gets, and giving more cookies to children who have already received cookies will only increase the maximum.\\n\\nBy breaking early when we encounter a child who hasn\\'t received any cookies yet, we eliminate the possibility of distributing cookies in a way that is guaranteed to be suboptimal (i.e., a way that results in a larger maximum number of cookies for any child). This pruning operation helps to reduce the size of the search space that the backtracking algorithm needs to explore, thereby increasing its efficiency.\\n\\nHowever, please note that this type of optimization is problem-specific and depends on the problem\\'s unique requirements and constraints. It may not be applicable or beneficial in all situations."
                    },
                    {
                        "username": "bhruti1",
                        "content": "Interesting problem statement."
                    },
                    {
                        "username": "Master_Floppa",
                        "content": "Why is the dp solution failing here? Isn\\'t there a repetitive subproblem?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem of distributing cookies to children might initially seem like it could be solved using a dynamic programming (DP) approach, especially given that there seems to be overlapping subproblems (i.e., the distribution of remaining cookies after giving some to a child). \\n\\nHowever, there are a few reasons why a traditional DP solution could fail or be inefficient for this problem:\\n\\n1. **State definition is complex**: In a DP problem, we typically define the state in terms of a few variables, like the current index or remaining value, and we base our subproblems around these states. However, in this case, to define a state, we need to keep track of the remaining cookies, the number of children left, and also how much each child has already received to maintain the \"minimum unfairness\" constraint. This leads to a very high-dimensional DP table, which can be challenging to handle and reason about.\\n\\n2. **No optimal substructure**: DP relies on the principle of optimal substructure, which says that the optimal solution to a problem can be constructed efficiently from the optimal solutions of its subproblems. However, in this problem, giving more cookies to a child in an attempt to optimize the current distribution does not guarantee that this will lead to the optimal solution in the end, as we are trying to minimize the maximum number of cookies a child can get. The choice at one step depends on choices at other steps, which does not adhere strictly to the optimal substructure property.\\n\\nThese factors make the problem unsuitable for a straightforward DP solution. However, a more advanced technique, such as using DP with bitmasking to keep track of which cookies have been distributed, might be possible but would be far more complex than simpler approaches like backtracking or binary search."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Binary Search + 0/1Kp ??"
                    }
                ]
            },
            {
                "id": 1951686,
                "content": [
                    {
                        "username": "Hatsoff",
                        "content": "Don\\'t overthink, check constraints."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Speaking of the importance of the right test cases selection.\nJust adding simple check for two edge cases reduces the runtime from 600ms to **0**\n```\nlet n = cookies.count\n\n// edge cases\nif n == k { return cookies.max()! } // one-to-one distribution\nelse if n == k + 1\n{   // find 2 smallest cookie bags and give them both to some kid\n    var indices = Set(cookies.indices)\n    let minInd1 = indices.min { cookies[$0] < cookies[$1] }!\n    indices.remove(minInd1)\n    let minInd2 = indices.min { cookies[$0] < cookies[$1] }!\n    let maxCookieBag = cookies.max()!\n    return max(maxCookieBag, (cookies[minInd1] + cookies[minInd2]))\n}\n```\n[640ms submission](https://leetcode.com/problems/fair-distribution-of-cookies/submissions/983773575/)\n[0ms submission](https://leetcode.com/problems/fair-distribution-of-cookies/submissions/983769578/)\n\n[@LeetCode](/LeetCode), does that seem ok to you?\n\nUPD: Oh, come on. I found yet another way to 0ms.\nConsider the fact that if there are currently several kids with the same cookie value, we only need to check one of them, as giving cookie to others will lead to the same state. This optimization alone reduces runtime to 0:\n[0 ms submission](https://leetcode.com/problems/fair-distribution-of-cookies/submissions/983896552/)"
                    },
                    {
                        "username": "gopal_0208",
                        "content": "Can\\'t we do it with minimum subset problem approach?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem of distributing cookies among children such that the maximum number of cookies received by any child is minimized can be thought of as a variation of the subset sum problem. However, there are some key differences that make this problem more complex and prevent a direct application of the subset sum approach.\\n\\nIn the subset sum problem, we\\'re given a set of numbers and we have to determine whether there is a subset whose sum is a particular target value. It\\'s a binary problem: either such a subset exists or it doesn\\'t.\\n\\nIn this problem, we\\'re given a set of numbers (the cookies) and a number of subsets (the children), and we have to divide the numbers among the subsets such that the maximum sum in any subset is minimized. This is an optimization problem rather than a binary one.\\n\\nFurthermore, in the subset sum problem, we only need to find one subset that meets the criteria. In this problem, we need to find a distribution of the entire set across multiple subsets.\\n\\nWhile there are some similarities between the problems, they are different in key ways. In particular, this problem has additional constraints and a different objective, which make it more complex. You would likely need a more advanced algorithm, such as backtracking or binary search, to solve it effectively."
                    },
                    {
                        "username": "rmtngdr",
                        "content": "I came up with the backtracking idea within 10 minutes, but i was sure there must be a more efficient solution. So I wasted another hour looking for a more optimal solution :("
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "kind of ez question\\n"
                    },
                    {
                        "username": "PrakharUniyal",
                        "content": "Where does it say that a child must be given non-zero cookies? You people don't understand the meaning of \"unfairness\".\n(Just kidding)"
                    },
                    {
                        "username": "ixeridium",
                        "content": "Sure, but the condition 2 <= k <= cookies.length implies that each child gets some cookies in the optimal solution. I.e., if there is a child without cookies then one can take a bag from the child with the most cookies and give that to the former one. This would lead to a better solution."
                    },
                    {
                        "username": "abhiMikasa",
                        "content": " ```\nclass Solution {\n    public static int maximaxi = Integer.MAX_VALUE;\n    public static int distributeCookies(int[] cookies, int k) {\n        distidfs(cookies,k,0,new int[k]);\n        int a = maximaxi;\n        maximaxi = Integer.MAX_VALUE;\n        return a;\n    }\n     public static  void  distidfs(int[] cookies, int k , int index , int[] child){\n        if(index == cookies.length){\n            int max = 0;\n            for(int i = 0; i < child.length; i++){\n                max = Math.max(max,child[i]);\n            }\n            maximaxi = Math.min(max,maximaxi);\n            return;\n        }\n        for(int i = 0; i < child.length; i++){\n            child[i] += cookies[index];\n            distidfs(cookies,k,index + 1,child);\n            child[i] -= cookies[index];\n            if(child[i] == 0) break;\n        }\n     }\n}\n```\n\n\nhow the statement :- `if(child[i] == 0) break;` \nincreases the efficiency of code."
                    },
                    {
                        "username": "bparanj",
                        "content": "The statement `if(child[i] == 0) break;` is a pruning operation that helps to eliminate some unnecessary recursive calls, thereby increasing the efficiency of the code.\\n\\nIn the context of this problem, it\\'s saying that if a child hasn\\'t received any cookies yet (`child[i] == 0`), we don\\'t need to consider giving cookies to the rest of the children for the current distribution. This is because we\\'re trying to minimize the maximum number of cookies any child gets, and giving more cookies to children who have already received cookies will only increase the maximum.\\n\\nBy breaking early when we encounter a child who hasn\\'t received any cookies yet, we eliminate the possibility of distributing cookies in a way that is guaranteed to be suboptimal (i.e., a way that results in a larger maximum number of cookies for any child). This pruning operation helps to reduce the size of the search space that the backtracking algorithm needs to explore, thereby increasing its efficiency.\\n\\nHowever, please note that this type of optimization is problem-specific and depends on the problem\\'s unique requirements and constraints. It may not be applicable or beneficial in all situations."
                    },
                    {
                        "username": "bhruti1",
                        "content": "Interesting problem statement."
                    },
                    {
                        "username": "Master_Floppa",
                        "content": "Why is the dp solution failing here? Isn\\'t there a repetitive subproblem?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem of distributing cookies to children might initially seem like it could be solved using a dynamic programming (DP) approach, especially given that there seems to be overlapping subproblems (i.e., the distribution of remaining cookies after giving some to a child). \\n\\nHowever, there are a few reasons why a traditional DP solution could fail or be inefficient for this problem:\\n\\n1. **State definition is complex**: In a DP problem, we typically define the state in terms of a few variables, like the current index or remaining value, and we base our subproblems around these states. However, in this case, to define a state, we need to keep track of the remaining cookies, the number of children left, and also how much each child has already received to maintain the \"minimum unfairness\" constraint. This leads to a very high-dimensional DP table, which can be challenging to handle and reason about.\\n\\n2. **No optimal substructure**: DP relies on the principle of optimal substructure, which says that the optimal solution to a problem can be constructed efficiently from the optimal solutions of its subproblems. However, in this problem, giving more cookies to a child in an attempt to optimize the current distribution does not guarantee that this will lead to the optimal solution in the end, as we are trying to minimize the maximum number of cookies a child can get. The choice at one step depends on choices at other steps, which does not adhere strictly to the optimal substructure property.\\n\\nThese factors make the problem unsuitable for a straightforward DP solution. However, a more advanced technique, such as using DP with bitmasking to keep track of which cookies have been distributed, might be possible but would be far more complex than simpler approaches like backtracking or binary search."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Binary Search + 0/1Kp ??"
                    }
                ]
            },
            {
                "id": 1951652,
                "content": [
                    {
                        "username": "Hatsoff",
                        "content": "Don\\'t overthink, check constraints."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Speaking of the importance of the right test cases selection.\nJust adding simple check for two edge cases reduces the runtime from 600ms to **0**\n```\nlet n = cookies.count\n\n// edge cases\nif n == k { return cookies.max()! } // one-to-one distribution\nelse if n == k + 1\n{   // find 2 smallest cookie bags and give them both to some kid\n    var indices = Set(cookies.indices)\n    let minInd1 = indices.min { cookies[$0] < cookies[$1] }!\n    indices.remove(minInd1)\n    let minInd2 = indices.min { cookies[$0] < cookies[$1] }!\n    let maxCookieBag = cookies.max()!\n    return max(maxCookieBag, (cookies[minInd1] + cookies[minInd2]))\n}\n```\n[640ms submission](https://leetcode.com/problems/fair-distribution-of-cookies/submissions/983773575/)\n[0ms submission](https://leetcode.com/problems/fair-distribution-of-cookies/submissions/983769578/)\n\n[@LeetCode](/LeetCode), does that seem ok to you?\n\nUPD: Oh, come on. I found yet another way to 0ms.\nConsider the fact that if there are currently several kids with the same cookie value, we only need to check one of them, as giving cookie to others will lead to the same state. This optimization alone reduces runtime to 0:\n[0 ms submission](https://leetcode.com/problems/fair-distribution-of-cookies/submissions/983896552/)"
                    },
                    {
                        "username": "gopal_0208",
                        "content": "Can\\'t we do it with minimum subset problem approach?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem of distributing cookies among children such that the maximum number of cookies received by any child is minimized can be thought of as a variation of the subset sum problem. However, there are some key differences that make this problem more complex and prevent a direct application of the subset sum approach.\\n\\nIn the subset sum problem, we\\'re given a set of numbers and we have to determine whether there is a subset whose sum is a particular target value. It\\'s a binary problem: either such a subset exists or it doesn\\'t.\\n\\nIn this problem, we\\'re given a set of numbers (the cookies) and a number of subsets (the children), and we have to divide the numbers among the subsets such that the maximum sum in any subset is minimized. This is an optimization problem rather than a binary one.\\n\\nFurthermore, in the subset sum problem, we only need to find one subset that meets the criteria. In this problem, we need to find a distribution of the entire set across multiple subsets.\\n\\nWhile there are some similarities between the problems, they are different in key ways. In particular, this problem has additional constraints and a different objective, which make it more complex. You would likely need a more advanced algorithm, such as backtracking or binary search, to solve it effectively."
                    },
                    {
                        "username": "rmtngdr",
                        "content": "I came up with the backtracking idea within 10 minutes, but i was sure there must be a more efficient solution. So I wasted another hour looking for a more optimal solution :("
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "kind of ez question\\n"
                    },
                    {
                        "username": "PrakharUniyal",
                        "content": "Where does it say that a child must be given non-zero cookies? You people don't understand the meaning of \"unfairness\".\n(Just kidding)"
                    },
                    {
                        "username": "ixeridium",
                        "content": "Sure, but the condition 2 <= k <= cookies.length implies that each child gets some cookies in the optimal solution. I.e., if there is a child without cookies then one can take a bag from the child with the most cookies and give that to the former one. This would lead to a better solution."
                    },
                    {
                        "username": "abhiMikasa",
                        "content": " ```\nclass Solution {\n    public static int maximaxi = Integer.MAX_VALUE;\n    public static int distributeCookies(int[] cookies, int k) {\n        distidfs(cookies,k,0,new int[k]);\n        int a = maximaxi;\n        maximaxi = Integer.MAX_VALUE;\n        return a;\n    }\n     public static  void  distidfs(int[] cookies, int k , int index , int[] child){\n        if(index == cookies.length){\n            int max = 0;\n            for(int i = 0; i < child.length; i++){\n                max = Math.max(max,child[i]);\n            }\n            maximaxi = Math.min(max,maximaxi);\n            return;\n        }\n        for(int i = 0; i < child.length; i++){\n            child[i] += cookies[index];\n            distidfs(cookies,k,index + 1,child);\n            child[i] -= cookies[index];\n            if(child[i] == 0) break;\n        }\n     }\n}\n```\n\n\nhow the statement :- `if(child[i] == 0) break;` \nincreases the efficiency of code."
                    },
                    {
                        "username": "bparanj",
                        "content": "The statement `if(child[i] == 0) break;` is a pruning operation that helps to eliminate some unnecessary recursive calls, thereby increasing the efficiency of the code.\\n\\nIn the context of this problem, it\\'s saying that if a child hasn\\'t received any cookies yet (`child[i] == 0`), we don\\'t need to consider giving cookies to the rest of the children for the current distribution. This is because we\\'re trying to minimize the maximum number of cookies any child gets, and giving more cookies to children who have already received cookies will only increase the maximum.\\n\\nBy breaking early when we encounter a child who hasn\\'t received any cookies yet, we eliminate the possibility of distributing cookies in a way that is guaranteed to be suboptimal (i.e., a way that results in a larger maximum number of cookies for any child). This pruning operation helps to reduce the size of the search space that the backtracking algorithm needs to explore, thereby increasing its efficiency.\\n\\nHowever, please note that this type of optimization is problem-specific and depends on the problem\\'s unique requirements and constraints. It may not be applicable or beneficial in all situations."
                    },
                    {
                        "username": "bhruti1",
                        "content": "Interesting problem statement."
                    },
                    {
                        "username": "Master_Floppa",
                        "content": "Why is the dp solution failing here? Isn\\'t there a repetitive subproblem?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem of distributing cookies to children might initially seem like it could be solved using a dynamic programming (DP) approach, especially given that there seems to be overlapping subproblems (i.e., the distribution of remaining cookies after giving some to a child). \\n\\nHowever, there are a few reasons why a traditional DP solution could fail or be inefficient for this problem:\\n\\n1. **State definition is complex**: In a DP problem, we typically define the state in terms of a few variables, like the current index or remaining value, and we base our subproblems around these states. However, in this case, to define a state, we need to keep track of the remaining cookies, the number of children left, and also how much each child has already received to maintain the \"minimum unfairness\" constraint. This leads to a very high-dimensional DP table, which can be challenging to handle and reason about.\\n\\n2. **No optimal substructure**: DP relies on the principle of optimal substructure, which says that the optimal solution to a problem can be constructed efficiently from the optimal solutions of its subproblems. However, in this problem, giving more cookies to a child in an attempt to optimize the current distribution does not guarantee that this will lead to the optimal solution in the end, as we are trying to minimize the maximum number of cookies a child can get. The choice at one step depends on choices at other steps, which does not adhere strictly to the optimal substructure property.\\n\\nThese factors make the problem unsuitable for a straightforward DP solution. However, a more advanced technique, such as using DP with bitmasking to keep track of which cookies have been distributed, might be possible but would be far more complex than simpler approaches like backtracking or binary search."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Binary Search + 0/1Kp ??"
                    }
                ]
            },
            {
                "id": 1951562,
                "content": [
                    {
                        "username": "Hatsoff",
                        "content": "Don\\'t overthink, check constraints."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Speaking of the importance of the right test cases selection.\nJust adding simple check for two edge cases reduces the runtime from 600ms to **0**\n```\nlet n = cookies.count\n\n// edge cases\nif n == k { return cookies.max()! } // one-to-one distribution\nelse if n == k + 1\n{   // find 2 smallest cookie bags and give them both to some kid\n    var indices = Set(cookies.indices)\n    let minInd1 = indices.min { cookies[$0] < cookies[$1] }!\n    indices.remove(minInd1)\n    let minInd2 = indices.min { cookies[$0] < cookies[$1] }!\n    let maxCookieBag = cookies.max()!\n    return max(maxCookieBag, (cookies[minInd1] + cookies[minInd2]))\n}\n```\n[640ms submission](https://leetcode.com/problems/fair-distribution-of-cookies/submissions/983773575/)\n[0ms submission](https://leetcode.com/problems/fair-distribution-of-cookies/submissions/983769578/)\n\n[@LeetCode](/LeetCode), does that seem ok to you?\n\nUPD: Oh, come on. I found yet another way to 0ms.\nConsider the fact that if there are currently several kids with the same cookie value, we only need to check one of them, as giving cookie to others will lead to the same state. This optimization alone reduces runtime to 0:\n[0 ms submission](https://leetcode.com/problems/fair-distribution-of-cookies/submissions/983896552/)"
                    },
                    {
                        "username": "gopal_0208",
                        "content": "Can\\'t we do it with minimum subset problem approach?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem of distributing cookies among children such that the maximum number of cookies received by any child is minimized can be thought of as a variation of the subset sum problem. However, there are some key differences that make this problem more complex and prevent a direct application of the subset sum approach.\\n\\nIn the subset sum problem, we\\'re given a set of numbers and we have to determine whether there is a subset whose sum is a particular target value. It\\'s a binary problem: either such a subset exists or it doesn\\'t.\\n\\nIn this problem, we\\'re given a set of numbers (the cookies) and a number of subsets (the children), and we have to divide the numbers among the subsets such that the maximum sum in any subset is minimized. This is an optimization problem rather than a binary one.\\n\\nFurthermore, in the subset sum problem, we only need to find one subset that meets the criteria. In this problem, we need to find a distribution of the entire set across multiple subsets.\\n\\nWhile there are some similarities between the problems, they are different in key ways. In particular, this problem has additional constraints and a different objective, which make it more complex. You would likely need a more advanced algorithm, such as backtracking or binary search, to solve it effectively."
                    },
                    {
                        "username": "rmtngdr",
                        "content": "I came up with the backtracking idea within 10 minutes, but i was sure there must be a more efficient solution. So I wasted another hour looking for a more optimal solution :("
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "kind of ez question\\n"
                    },
                    {
                        "username": "PrakharUniyal",
                        "content": "Where does it say that a child must be given non-zero cookies? You people don't understand the meaning of \"unfairness\".\n(Just kidding)"
                    },
                    {
                        "username": "ixeridium",
                        "content": "Sure, but the condition 2 <= k <= cookies.length implies that each child gets some cookies in the optimal solution. I.e., if there is a child without cookies then one can take a bag from the child with the most cookies and give that to the former one. This would lead to a better solution."
                    },
                    {
                        "username": "abhiMikasa",
                        "content": " ```\nclass Solution {\n    public static int maximaxi = Integer.MAX_VALUE;\n    public static int distributeCookies(int[] cookies, int k) {\n        distidfs(cookies,k,0,new int[k]);\n        int a = maximaxi;\n        maximaxi = Integer.MAX_VALUE;\n        return a;\n    }\n     public static  void  distidfs(int[] cookies, int k , int index , int[] child){\n        if(index == cookies.length){\n            int max = 0;\n            for(int i = 0; i < child.length; i++){\n                max = Math.max(max,child[i]);\n            }\n            maximaxi = Math.min(max,maximaxi);\n            return;\n        }\n        for(int i = 0; i < child.length; i++){\n            child[i] += cookies[index];\n            distidfs(cookies,k,index + 1,child);\n            child[i] -= cookies[index];\n            if(child[i] == 0) break;\n        }\n     }\n}\n```\n\n\nhow the statement :- `if(child[i] == 0) break;` \nincreases the efficiency of code."
                    },
                    {
                        "username": "bparanj",
                        "content": "The statement `if(child[i] == 0) break;` is a pruning operation that helps to eliminate some unnecessary recursive calls, thereby increasing the efficiency of the code.\\n\\nIn the context of this problem, it\\'s saying that if a child hasn\\'t received any cookies yet (`child[i] == 0`), we don\\'t need to consider giving cookies to the rest of the children for the current distribution. This is because we\\'re trying to minimize the maximum number of cookies any child gets, and giving more cookies to children who have already received cookies will only increase the maximum.\\n\\nBy breaking early when we encounter a child who hasn\\'t received any cookies yet, we eliminate the possibility of distributing cookies in a way that is guaranteed to be suboptimal (i.e., a way that results in a larger maximum number of cookies for any child). This pruning operation helps to reduce the size of the search space that the backtracking algorithm needs to explore, thereby increasing its efficiency.\\n\\nHowever, please note that this type of optimization is problem-specific and depends on the problem\\'s unique requirements and constraints. It may not be applicable or beneficial in all situations."
                    },
                    {
                        "username": "bhruti1",
                        "content": "Interesting problem statement."
                    },
                    {
                        "username": "Master_Floppa",
                        "content": "Why is the dp solution failing here? Isn\\'t there a repetitive subproblem?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem of distributing cookies to children might initially seem like it could be solved using a dynamic programming (DP) approach, especially given that there seems to be overlapping subproblems (i.e., the distribution of remaining cookies after giving some to a child). \\n\\nHowever, there are a few reasons why a traditional DP solution could fail or be inefficient for this problem:\\n\\n1. **State definition is complex**: In a DP problem, we typically define the state in terms of a few variables, like the current index or remaining value, and we base our subproblems around these states. However, in this case, to define a state, we need to keep track of the remaining cookies, the number of children left, and also how much each child has already received to maintain the \"minimum unfairness\" constraint. This leads to a very high-dimensional DP table, which can be challenging to handle and reason about.\\n\\n2. **No optimal substructure**: DP relies on the principle of optimal substructure, which says that the optimal solution to a problem can be constructed efficiently from the optimal solutions of its subproblems. However, in this problem, giving more cookies to a child in an attempt to optimize the current distribution does not guarantee that this will lead to the optimal solution in the end, as we are trying to minimize the maximum number of cookies a child can get. The choice at one step depends on choices at other steps, which does not adhere strictly to the optimal substructure property.\\n\\nThese factors make the problem unsuitable for a straightforward DP solution. However, a more advanced technique, such as using DP with bitmasking to keep track of which cookies have been distributed, might be possible but would be far more complex than simpler approaches like backtracking or binary search."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Binary Search + 0/1Kp ??"
                    }
                ]
            },
            {
                "id": 1951536,
                "content": [
                    {
                        "username": "Hatsoff",
                        "content": "Don\\'t overthink, check constraints."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Speaking of the importance of the right test cases selection.\nJust adding simple check for two edge cases reduces the runtime from 600ms to **0**\n```\nlet n = cookies.count\n\n// edge cases\nif n == k { return cookies.max()! } // one-to-one distribution\nelse if n == k + 1\n{   // find 2 smallest cookie bags and give them both to some kid\n    var indices = Set(cookies.indices)\n    let minInd1 = indices.min { cookies[$0] < cookies[$1] }!\n    indices.remove(minInd1)\n    let minInd2 = indices.min { cookies[$0] < cookies[$1] }!\n    let maxCookieBag = cookies.max()!\n    return max(maxCookieBag, (cookies[minInd1] + cookies[minInd2]))\n}\n```\n[640ms submission](https://leetcode.com/problems/fair-distribution-of-cookies/submissions/983773575/)\n[0ms submission](https://leetcode.com/problems/fair-distribution-of-cookies/submissions/983769578/)\n\n[@LeetCode](/LeetCode), does that seem ok to you?\n\nUPD: Oh, come on. I found yet another way to 0ms.\nConsider the fact that if there are currently several kids with the same cookie value, we only need to check one of them, as giving cookie to others will lead to the same state. This optimization alone reduces runtime to 0:\n[0 ms submission](https://leetcode.com/problems/fair-distribution-of-cookies/submissions/983896552/)"
                    },
                    {
                        "username": "gopal_0208",
                        "content": "Can\\'t we do it with minimum subset problem approach?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem of distributing cookies among children such that the maximum number of cookies received by any child is minimized can be thought of as a variation of the subset sum problem. However, there are some key differences that make this problem more complex and prevent a direct application of the subset sum approach.\\n\\nIn the subset sum problem, we\\'re given a set of numbers and we have to determine whether there is a subset whose sum is a particular target value. It\\'s a binary problem: either such a subset exists or it doesn\\'t.\\n\\nIn this problem, we\\'re given a set of numbers (the cookies) and a number of subsets (the children), and we have to divide the numbers among the subsets such that the maximum sum in any subset is minimized. This is an optimization problem rather than a binary one.\\n\\nFurthermore, in the subset sum problem, we only need to find one subset that meets the criteria. In this problem, we need to find a distribution of the entire set across multiple subsets.\\n\\nWhile there are some similarities between the problems, they are different in key ways. In particular, this problem has additional constraints and a different objective, which make it more complex. You would likely need a more advanced algorithm, such as backtracking or binary search, to solve it effectively."
                    },
                    {
                        "username": "rmtngdr",
                        "content": "I came up with the backtracking idea within 10 minutes, but i was sure there must be a more efficient solution. So I wasted another hour looking for a more optimal solution :("
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "kind of ez question\\n"
                    },
                    {
                        "username": "PrakharUniyal",
                        "content": "Where does it say that a child must be given non-zero cookies? You people don't understand the meaning of \"unfairness\".\n(Just kidding)"
                    },
                    {
                        "username": "ixeridium",
                        "content": "Sure, but the condition 2 <= k <= cookies.length implies that each child gets some cookies in the optimal solution. I.e., if there is a child without cookies then one can take a bag from the child with the most cookies and give that to the former one. This would lead to a better solution."
                    },
                    {
                        "username": "abhiMikasa",
                        "content": " ```\nclass Solution {\n    public static int maximaxi = Integer.MAX_VALUE;\n    public static int distributeCookies(int[] cookies, int k) {\n        distidfs(cookies,k,0,new int[k]);\n        int a = maximaxi;\n        maximaxi = Integer.MAX_VALUE;\n        return a;\n    }\n     public static  void  distidfs(int[] cookies, int k , int index , int[] child){\n        if(index == cookies.length){\n            int max = 0;\n            for(int i = 0; i < child.length; i++){\n                max = Math.max(max,child[i]);\n            }\n            maximaxi = Math.min(max,maximaxi);\n            return;\n        }\n        for(int i = 0; i < child.length; i++){\n            child[i] += cookies[index];\n            distidfs(cookies,k,index + 1,child);\n            child[i] -= cookies[index];\n            if(child[i] == 0) break;\n        }\n     }\n}\n```\n\n\nhow the statement :- `if(child[i] == 0) break;` \nincreases the efficiency of code."
                    },
                    {
                        "username": "bparanj",
                        "content": "The statement `if(child[i] == 0) break;` is a pruning operation that helps to eliminate some unnecessary recursive calls, thereby increasing the efficiency of the code.\\n\\nIn the context of this problem, it\\'s saying that if a child hasn\\'t received any cookies yet (`child[i] == 0`), we don\\'t need to consider giving cookies to the rest of the children for the current distribution. This is because we\\'re trying to minimize the maximum number of cookies any child gets, and giving more cookies to children who have already received cookies will only increase the maximum.\\n\\nBy breaking early when we encounter a child who hasn\\'t received any cookies yet, we eliminate the possibility of distributing cookies in a way that is guaranteed to be suboptimal (i.e., a way that results in a larger maximum number of cookies for any child). This pruning operation helps to reduce the size of the search space that the backtracking algorithm needs to explore, thereby increasing its efficiency.\\n\\nHowever, please note that this type of optimization is problem-specific and depends on the problem\\'s unique requirements and constraints. It may not be applicable or beneficial in all situations."
                    },
                    {
                        "username": "bhruti1",
                        "content": "Interesting problem statement."
                    },
                    {
                        "username": "Master_Floppa",
                        "content": "Why is the dp solution failing here? Isn\\'t there a repetitive subproblem?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem of distributing cookies to children might initially seem like it could be solved using a dynamic programming (DP) approach, especially given that there seems to be overlapping subproblems (i.e., the distribution of remaining cookies after giving some to a child). \\n\\nHowever, there are a few reasons why a traditional DP solution could fail or be inefficient for this problem:\\n\\n1. **State definition is complex**: In a DP problem, we typically define the state in terms of a few variables, like the current index or remaining value, and we base our subproblems around these states. However, in this case, to define a state, we need to keep track of the remaining cookies, the number of children left, and also how much each child has already received to maintain the \"minimum unfairness\" constraint. This leads to a very high-dimensional DP table, which can be challenging to handle and reason about.\\n\\n2. **No optimal substructure**: DP relies on the principle of optimal substructure, which says that the optimal solution to a problem can be constructed efficiently from the optimal solutions of its subproblems. However, in this problem, giving more cookies to a child in an attempt to optimize the current distribution does not guarantee that this will lead to the optimal solution in the end, as we are trying to minimize the maximum number of cookies a child can get. The choice at one step depends on choices at other steps, which does not adhere strictly to the optimal substructure property.\\n\\nThese factors make the problem unsuitable for a straightforward DP solution. However, a more advanced technique, such as using DP with bitmasking to keep track of which cookies have been distributed, might be possible but would be far more complex than simpler approaches like backtracking or binary search."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Binary Search + 0/1Kp ??"
                    }
                ]
            },
            {
                "id": 1951516,
                "content": [
                    {
                        "username": "Hatsoff",
                        "content": "Don\\'t overthink, check constraints."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Speaking of the importance of the right test cases selection.\nJust adding simple check for two edge cases reduces the runtime from 600ms to **0**\n```\nlet n = cookies.count\n\n// edge cases\nif n == k { return cookies.max()! } // one-to-one distribution\nelse if n == k + 1\n{   // find 2 smallest cookie bags and give them both to some kid\n    var indices = Set(cookies.indices)\n    let minInd1 = indices.min { cookies[$0] < cookies[$1] }!\n    indices.remove(minInd1)\n    let minInd2 = indices.min { cookies[$0] < cookies[$1] }!\n    let maxCookieBag = cookies.max()!\n    return max(maxCookieBag, (cookies[minInd1] + cookies[minInd2]))\n}\n```\n[640ms submission](https://leetcode.com/problems/fair-distribution-of-cookies/submissions/983773575/)\n[0ms submission](https://leetcode.com/problems/fair-distribution-of-cookies/submissions/983769578/)\n\n[@LeetCode](/LeetCode), does that seem ok to you?\n\nUPD: Oh, come on. I found yet another way to 0ms.\nConsider the fact that if there are currently several kids with the same cookie value, we only need to check one of them, as giving cookie to others will lead to the same state. This optimization alone reduces runtime to 0:\n[0 ms submission](https://leetcode.com/problems/fair-distribution-of-cookies/submissions/983896552/)"
                    },
                    {
                        "username": "gopal_0208",
                        "content": "Can\\'t we do it with minimum subset problem approach?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem of distributing cookies among children such that the maximum number of cookies received by any child is minimized can be thought of as a variation of the subset sum problem. However, there are some key differences that make this problem more complex and prevent a direct application of the subset sum approach.\\n\\nIn the subset sum problem, we\\'re given a set of numbers and we have to determine whether there is a subset whose sum is a particular target value. It\\'s a binary problem: either such a subset exists or it doesn\\'t.\\n\\nIn this problem, we\\'re given a set of numbers (the cookies) and a number of subsets (the children), and we have to divide the numbers among the subsets such that the maximum sum in any subset is minimized. This is an optimization problem rather than a binary one.\\n\\nFurthermore, in the subset sum problem, we only need to find one subset that meets the criteria. In this problem, we need to find a distribution of the entire set across multiple subsets.\\n\\nWhile there are some similarities between the problems, they are different in key ways. In particular, this problem has additional constraints and a different objective, which make it more complex. You would likely need a more advanced algorithm, such as backtracking or binary search, to solve it effectively."
                    },
                    {
                        "username": "rmtngdr",
                        "content": "I came up with the backtracking idea within 10 minutes, but i was sure there must be a more efficient solution. So I wasted another hour looking for a more optimal solution :("
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "kind of ez question\\n"
                    },
                    {
                        "username": "PrakharUniyal",
                        "content": "Where does it say that a child must be given non-zero cookies? You people don't understand the meaning of \"unfairness\".\n(Just kidding)"
                    },
                    {
                        "username": "ixeridium",
                        "content": "Sure, but the condition 2 <= k <= cookies.length implies that each child gets some cookies in the optimal solution. I.e., if there is a child without cookies then one can take a bag from the child with the most cookies and give that to the former one. This would lead to a better solution."
                    },
                    {
                        "username": "abhiMikasa",
                        "content": " ```\nclass Solution {\n    public static int maximaxi = Integer.MAX_VALUE;\n    public static int distributeCookies(int[] cookies, int k) {\n        distidfs(cookies,k,0,new int[k]);\n        int a = maximaxi;\n        maximaxi = Integer.MAX_VALUE;\n        return a;\n    }\n     public static  void  distidfs(int[] cookies, int k , int index , int[] child){\n        if(index == cookies.length){\n            int max = 0;\n            for(int i = 0; i < child.length; i++){\n                max = Math.max(max,child[i]);\n            }\n            maximaxi = Math.min(max,maximaxi);\n            return;\n        }\n        for(int i = 0; i < child.length; i++){\n            child[i] += cookies[index];\n            distidfs(cookies,k,index + 1,child);\n            child[i] -= cookies[index];\n            if(child[i] == 0) break;\n        }\n     }\n}\n```\n\n\nhow the statement :- `if(child[i] == 0) break;` \nincreases the efficiency of code."
                    },
                    {
                        "username": "bparanj",
                        "content": "The statement `if(child[i] == 0) break;` is a pruning operation that helps to eliminate some unnecessary recursive calls, thereby increasing the efficiency of the code.\\n\\nIn the context of this problem, it\\'s saying that if a child hasn\\'t received any cookies yet (`child[i] == 0`), we don\\'t need to consider giving cookies to the rest of the children for the current distribution. This is because we\\'re trying to minimize the maximum number of cookies any child gets, and giving more cookies to children who have already received cookies will only increase the maximum.\\n\\nBy breaking early when we encounter a child who hasn\\'t received any cookies yet, we eliminate the possibility of distributing cookies in a way that is guaranteed to be suboptimal (i.e., a way that results in a larger maximum number of cookies for any child). This pruning operation helps to reduce the size of the search space that the backtracking algorithm needs to explore, thereby increasing its efficiency.\\n\\nHowever, please note that this type of optimization is problem-specific and depends on the problem\\'s unique requirements and constraints. It may not be applicable or beneficial in all situations."
                    },
                    {
                        "username": "bhruti1",
                        "content": "Interesting problem statement."
                    },
                    {
                        "username": "Master_Floppa",
                        "content": "Why is the dp solution failing here? Isn\\'t there a repetitive subproblem?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem of distributing cookies to children might initially seem like it could be solved using a dynamic programming (DP) approach, especially given that there seems to be overlapping subproblems (i.e., the distribution of remaining cookies after giving some to a child). \\n\\nHowever, there are a few reasons why a traditional DP solution could fail or be inefficient for this problem:\\n\\n1. **State definition is complex**: In a DP problem, we typically define the state in terms of a few variables, like the current index or remaining value, and we base our subproblems around these states. However, in this case, to define a state, we need to keep track of the remaining cookies, the number of children left, and also how much each child has already received to maintain the \"minimum unfairness\" constraint. This leads to a very high-dimensional DP table, which can be challenging to handle and reason about.\\n\\n2. **No optimal substructure**: DP relies on the principle of optimal substructure, which says that the optimal solution to a problem can be constructed efficiently from the optimal solutions of its subproblems. However, in this problem, giving more cookies to a child in an attempt to optimize the current distribution does not guarantee that this will lead to the optimal solution in the end, as we are trying to minimize the maximum number of cookies a child can get. The choice at one step depends on choices at other steps, which does not adhere strictly to the optimal substructure property.\\n\\nThese factors make the problem unsuitable for a straightforward DP solution. However, a more advanced technique, such as using DP with bitmasking to keep track of which cookies have been distributed, might be possible but would be far more complex than simpler approaches like backtracking or binary search."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Binary Search + 0/1Kp ??"
                    }
                ]
            },
            {
                "id": 1951440,
                "content": [
                    {
                        "username": "Hatsoff",
                        "content": "Don\\'t overthink, check constraints."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Speaking of the importance of the right test cases selection.\nJust adding simple check for two edge cases reduces the runtime from 600ms to **0**\n```\nlet n = cookies.count\n\n// edge cases\nif n == k { return cookies.max()! } // one-to-one distribution\nelse if n == k + 1\n{   // find 2 smallest cookie bags and give them both to some kid\n    var indices = Set(cookies.indices)\n    let minInd1 = indices.min { cookies[$0] < cookies[$1] }!\n    indices.remove(minInd1)\n    let minInd2 = indices.min { cookies[$0] < cookies[$1] }!\n    let maxCookieBag = cookies.max()!\n    return max(maxCookieBag, (cookies[minInd1] + cookies[minInd2]))\n}\n```\n[640ms submission](https://leetcode.com/problems/fair-distribution-of-cookies/submissions/983773575/)\n[0ms submission](https://leetcode.com/problems/fair-distribution-of-cookies/submissions/983769578/)\n\n[@LeetCode](/LeetCode), does that seem ok to you?\n\nUPD: Oh, come on. I found yet another way to 0ms.\nConsider the fact that if there are currently several kids with the same cookie value, we only need to check one of them, as giving cookie to others will lead to the same state. This optimization alone reduces runtime to 0:\n[0 ms submission](https://leetcode.com/problems/fair-distribution-of-cookies/submissions/983896552/)"
                    },
                    {
                        "username": "gopal_0208",
                        "content": "Can\\'t we do it with minimum subset problem approach?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem of distributing cookies among children such that the maximum number of cookies received by any child is minimized can be thought of as a variation of the subset sum problem. However, there are some key differences that make this problem more complex and prevent a direct application of the subset sum approach.\\n\\nIn the subset sum problem, we\\'re given a set of numbers and we have to determine whether there is a subset whose sum is a particular target value. It\\'s a binary problem: either such a subset exists or it doesn\\'t.\\n\\nIn this problem, we\\'re given a set of numbers (the cookies) and a number of subsets (the children), and we have to divide the numbers among the subsets such that the maximum sum in any subset is minimized. This is an optimization problem rather than a binary one.\\n\\nFurthermore, in the subset sum problem, we only need to find one subset that meets the criteria. In this problem, we need to find a distribution of the entire set across multiple subsets.\\n\\nWhile there are some similarities between the problems, they are different in key ways. In particular, this problem has additional constraints and a different objective, which make it more complex. You would likely need a more advanced algorithm, such as backtracking or binary search, to solve it effectively."
                    },
                    {
                        "username": "rmtngdr",
                        "content": "I came up with the backtracking idea within 10 minutes, but i was sure there must be a more efficient solution. So I wasted another hour looking for a more optimal solution :("
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "kind of ez question\\n"
                    },
                    {
                        "username": "PrakharUniyal",
                        "content": "Where does it say that a child must be given non-zero cookies? You people don't understand the meaning of \"unfairness\".\n(Just kidding)"
                    },
                    {
                        "username": "ixeridium",
                        "content": "Sure, but the condition 2 <= k <= cookies.length implies that each child gets some cookies in the optimal solution. I.e., if there is a child without cookies then one can take a bag from the child with the most cookies and give that to the former one. This would lead to a better solution."
                    },
                    {
                        "username": "abhiMikasa",
                        "content": " ```\nclass Solution {\n    public static int maximaxi = Integer.MAX_VALUE;\n    public static int distributeCookies(int[] cookies, int k) {\n        distidfs(cookies,k,0,new int[k]);\n        int a = maximaxi;\n        maximaxi = Integer.MAX_VALUE;\n        return a;\n    }\n     public static  void  distidfs(int[] cookies, int k , int index , int[] child){\n        if(index == cookies.length){\n            int max = 0;\n            for(int i = 0; i < child.length; i++){\n                max = Math.max(max,child[i]);\n            }\n            maximaxi = Math.min(max,maximaxi);\n            return;\n        }\n        for(int i = 0; i < child.length; i++){\n            child[i] += cookies[index];\n            distidfs(cookies,k,index + 1,child);\n            child[i] -= cookies[index];\n            if(child[i] == 0) break;\n        }\n     }\n}\n```\n\n\nhow the statement :- `if(child[i] == 0) break;` \nincreases the efficiency of code."
                    },
                    {
                        "username": "bparanj",
                        "content": "The statement `if(child[i] == 0) break;` is a pruning operation that helps to eliminate some unnecessary recursive calls, thereby increasing the efficiency of the code.\\n\\nIn the context of this problem, it\\'s saying that if a child hasn\\'t received any cookies yet (`child[i] == 0`), we don\\'t need to consider giving cookies to the rest of the children for the current distribution. This is because we\\'re trying to minimize the maximum number of cookies any child gets, and giving more cookies to children who have already received cookies will only increase the maximum.\\n\\nBy breaking early when we encounter a child who hasn\\'t received any cookies yet, we eliminate the possibility of distributing cookies in a way that is guaranteed to be suboptimal (i.e., a way that results in a larger maximum number of cookies for any child). This pruning operation helps to reduce the size of the search space that the backtracking algorithm needs to explore, thereby increasing its efficiency.\\n\\nHowever, please note that this type of optimization is problem-specific and depends on the problem\\'s unique requirements and constraints. It may not be applicable or beneficial in all situations."
                    },
                    {
                        "username": "bhruti1",
                        "content": "Interesting problem statement."
                    },
                    {
                        "username": "Master_Floppa",
                        "content": "Why is the dp solution failing here? Isn\\'t there a repetitive subproblem?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem of distributing cookies to children might initially seem like it could be solved using a dynamic programming (DP) approach, especially given that there seems to be overlapping subproblems (i.e., the distribution of remaining cookies after giving some to a child). \\n\\nHowever, there are a few reasons why a traditional DP solution could fail or be inefficient for this problem:\\n\\n1. **State definition is complex**: In a DP problem, we typically define the state in terms of a few variables, like the current index or remaining value, and we base our subproblems around these states. However, in this case, to define a state, we need to keep track of the remaining cookies, the number of children left, and also how much each child has already received to maintain the \"minimum unfairness\" constraint. This leads to a very high-dimensional DP table, which can be challenging to handle and reason about.\\n\\n2. **No optimal substructure**: DP relies on the principle of optimal substructure, which says that the optimal solution to a problem can be constructed efficiently from the optimal solutions of its subproblems. However, in this problem, giving more cookies to a child in an attempt to optimize the current distribution does not guarantee that this will lead to the optimal solution in the end, as we are trying to minimize the maximum number of cookies a child can get. The choice at one step depends on choices at other steps, which does not adhere strictly to the optimal substructure property.\\n\\nThese factors make the problem unsuitable for a straightforward DP solution. However, a more advanced technique, such as using DP with bitmasking to keep track of which cookies have been distributed, might be possible but would be far more complex than simpler approaches like backtracking or binary search."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Binary Search + 0/1Kp ??"
                    }
                ]
            },
            {
                "id": 1951424,
                "content": [
                    {
                        "username": "Hatsoff",
                        "content": "Don\\'t overthink, check constraints."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Speaking of the importance of the right test cases selection.\nJust adding simple check for two edge cases reduces the runtime from 600ms to **0**\n```\nlet n = cookies.count\n\n// edge cases\nif n == k { return cookies.max()! } // one-to-one distribution\nelse if n == k + 1\n{   // find 2 smallest cookie bags and give them both to some kid\n    var indices = Set(cookies.indices)\n    let minInd1 = indices.min { cookies[$0] < cookies[$1] }!\n    indices.remove(minInd1)\n    let minInd2 = indices.min { cookies[$0] < cookies[$1] }!\n    let maxCookieBag = cookies.max()!\n    return max(maxCookieBag, (cookies[minInd1] + cookies[minInd2]))\n}\n```\n[640ms submission](https://leetcode.com/problems/fair-distribution-of-cookies/submissions/983773575/)\n[0ms submission](https://leetcode.com/problems/fair-distribution-of-cookies/submissions/983769578/)\n\n[@LeetCode](/LeetCode), does that seem ok to you?\n\nUPD: Oh, come on. I found yet another way to 0ms.\nConsider the fact that if there are currently several kids with the same cookie value, we only need to check one of them, as giving cookie to others will lead to the same state. This optimization alone reduces runtime to 0:\n[0 ms submission](https://leetcode.com/problems/fair-distribution-of-cookies/submissions/983896552/)"
                    },
                    {
                        "username": "gopal_0208",
                        "content": "Can\\'t we do it with minimum subset problem approach?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem of distributing cookies among children such that the maximum number of cookies received by any child is minimized can be thought of as a variation of the subset sum problem. However, there are some key differences that make this problem more complex and prevent a direct application of the subset sum approach.\\n\\nIn the subset sum problem, we\\'re given a set of numbers and we have to determine whether there is a subset whose sum is a particular target value. It\\'s a binary problem: either such a subset exists or it doesn\\'t.\\n\\nIn this problem, we\\'re given a set of numbers (the cookies) and a number of subsets (the children), and we have to divide the numbers among the subsets such that the maximum sum in any subset is minimized. This is an optimization problem rather than a binary one.\\n\\nFurthermore, in the subset sum problem, we only need to find one subset that meets the criteria. In this problem, we need to find a distribution of the entire set across multiple subsets.\\n\\nWhile there are some similarities between the problems, they are different in key ways. In particular, this problem has additional constraints and a different objective, which make it more complex. You would likely need a more advanced algorithm, such as backtracking or binary search, to solve it effectively."
                    },
                    {
                        "username": "rmtngdr",
                        "content": "I came up with the backtracking idea within 10 minutes, but i was sure there must be a more efficient solution. So I wasted another hour looking for a more optimal solution :("
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "kind of ez question\\n"
                    },
                    {
                        "username": "PrakharUniyal",
                        "content": "Where does it say that a child must be given non-zero cookies? You people don't understand the meaning of \"unfairness\".\n(Just kidding)"
                    },
                    {
                        "username": "ixeridium",
                        "content": "Sure, but the condition 2 <= k <= cookies.length implies that each child gets some cookies in the optimal solution. I.e., if there is a child without cookies then one can take a bag from the child with the most cookies and give that to the former one. This would lead to a better solution."
                    },
                    {
                        "username": "abhiMikasa",
                        "content": " ```\nclass Solution {\n    public static int maximaxi = Integer.MAX_VALUE;\n    public static int distributeCookies(int[] cookies, int k) {\n        distidfs(cookies,k,0,new int[k]);\n        int a = maximaxi;\n        maximaxi = Integer.MAX_VALUE;\n        return a;\n    }\n     public static  void  distidfs(int[] cookies, int k , int index , int[] child){\n        if(index == cookies.length){\n            int max = 0;\n            for(int i = 0; i < child.length; i++){\n                max = Math.max(max,child[i]);\n            }\n            maximaxi = Math.min(max,maximaxi);\n            return;\n        }\n        for(int i = 0; i < child.length; i++){\n            child[i] += cookies[index];\n            distidfs(cookies,k,index + 1,child);\n            child[i] -= cookies[index];\n            if(child[i] == 0) break;\n        }\n     }\n}\n```\n\n\nhow the statement :- `if(child[i] == 0) break;` \nincreases the efficiency of code."
                    },
                    {
                        "username": "bparanj",
                        "content": "The statement `if(child[i] == 0) break;` is a pruning operation that helps to eliminate some unnecessary recursive calls, thereby increasing the efficiency of the code.\\n\\nIn the context of this problem, it\\'s saying that if a child hasn\\'t received any cookies yet (`child[i] == 0`), we don\\'t need to consider giving cookies to the rest of the children for the current distribution. This is because we\\'re trying to minimize the maximum number of cookies any child gets, and giving more cookies to children who have already received cookies will only increase the maximum.\\n\\nBy breaking early when we encounter a child who hasn\\'t received any cookies yet, we eliminate the possibility of distributing cookies in a way that is guaranteed to be suboptimal (i.e., a way that results in a larger maximum number of cookies for any child). This pruning operation helps to reduce the size of the search space that the backtracking algorithm needs to explore, thereby increasing its efficiency.\\n\\nHowever, please note that this type of optimization is problem-specific and depends on the problem\\'s unique requirements and constraints. It may not be applicable or beneficial in all situations."
                    },
                    {
                        "username": "bhruti1",
                        "content": "Interesting problem statement."
                    },
                    {
                        "username": "Master_Floppa",
                        "content": "Why is the dp solution failing here? Isn\\'t there a repetitive subproblem?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem of distributing cookies to children might initially seem like it could be solved using a dynamic programming (DP) approach, especially given that there seems to be overlapping subproblems (i.e., the distribution of remaining cookies after giving some to a child). \\n\\nHowever, there are a few reasons why a traditional DP solution could fail or be inefficient for this problem:\\n\\n1. **State definition is complex**: In a DP problem, we typically define the state in terms of a few variables, like the current index or remaining value, and we base our subproblems around these states. However, in this case, to define a state, we need to keep track of the remaining cookies, the number of children left, and also how much each child has already received to maintain the \"minimum unfairness\" constraint. This leads to a very high-dimensional DP table, which can be challenging to handle and reason about.\\n\\n2. **No optimal substructure**: DP relies on the principle of optimal substructure, which says that the optimal solution to a problem can be constructed efficiently from the optimal solutions of its subproblems. However, in this problem, giving more cookies to a child in an attempt to optimize the current distribution does not guarantee that this will lead to the optimal solution in the end, as we are trying to minimize the maximum number of cookies a child can get. The choice at one step depends on choices at other steps, which does not adhere strictly to the optimal substructure property.\\n\\nThese factors make the problem unsuitable for a straightforward DP solution. However, a more advanced technique, such as using DP with bitmasking to keep track of which cookies have been distributed, might be possible but would be far more complex than simpler approaches like backtracking or binary search."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Binary Search + 0/1Kp ??"
                    }
                ]
            },
            {
                "id": 1951404,
                "content": [
                    {
                        "username": "Hatsoff",
                        "content": "Don\\'t overthink, check constraints."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Speaking of the importance of the right test cases selection.\nJust adding simple check for two edge cases reduces the runtime from 600ms to **0**\n```\nlet n = cookies.count\n\n// edge cases\nif n == k { return cookies.max()! } // one-to-one distribution\nelse if n == k + 1\n{   // find 2 smallest cookie bags and give them both to some kid\n    var indices = Set(cookies.indices)\n    let minInd1 = indices.min { cookies[$0] < cookies[$1] }!\n    indices.remove(minInd1)\n    let minInd2 = indices.min { cookies[$0] < cookies[$1] }!\n    let maxCookieBag = cookies.max()!\n    return max(maxCookieBag, (cookies[minInd1] + cookies[minInd2]))\n}\n```\n[640ms submission](https://leetcode.com/problems/fair-distribution-of-cookies/submissions/983773575/)\n[0ms submission](https://leetcode.com/problems/fair-distribution-of-cookies/submissions/983769578/)\n\n[@LeetCode](/LeetCode), does that seem ok to you?\n\nUPD: Oh, come on. I found yet another way to 0ms.\nConsider the fact that if there are currently several kids with the same cookie value, we only need to check one of them, as giving cookie to others will lead to the same state. This optimization alone reduces runtime to 0:\n[0 ms submission](https://leetcode.com/problems/fair-distribution-of-cookies/submissions/983896552/)"
                    },
                    {
                        "username": "gopal_0208",
                        "content": "Can\\'t we do it with minimum subset problem approach?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem of distributing cookies among children such that the maximum number of cookies received by any child is minimized can be thought of as a variation of the subset sum problem. However, there are some key differences that make this problem more complex and prevent a direct application of the subset sum approach.\\n\\nIn the subset sum problem, we\\'re given a set of numbers and we have to determine whether there is a subset whose sum is a particular target value. It\\'s a binary problem: either such a subset exists or it doesn\\'t.\\n\\nIn this problem, we\\'re given a set of numbers (the cookies) and a number of subsets (the children), and we have to divide the numbers among the subsets such that the maximum sum in any subset is minimized. This is an optimization problem rather than a binary one.\\n\\nFurthermore, in the subset sum problem, we only need to find one subset that meets the criteria. In this problem, we need to find a distribution of the entire set across multiple subsets.\\n\\nWhile there are some similarities between the problems, they are different in key ways. In particular, this problem has additional constraints and a different objective, which make it more complex. You would likely need a more advanced algorithm, such as backtracking or binary search, to solve it effectively."
                    },
                    {
                        "username": "rmtngdr",
                        "content": "I came up with the backtracking idea within 10 minutes, but i was sure there must be a more efficient solution. So I wasted another hour looking for a more optimal solution :("
                    },
                    {
                        "username": "aryan12sonwani",
                        "content": "kind of ez question\\n"
                    },
                    {
                        "username": "PrakharUniyal",
                        "content": "Where does it say that a child must be given non-zero cookies? You people don't understand the meaning of \"unfairness\".\n(Just kidding)"
                    },
                    {
                        "username": "ixeridium",
                        "content": "Sure, but the condition 2 <= k <= cookies.length implies that each child gets some cookies in the optimal solution. I.e., if there is a child without cookies then one can take a bag from the child with the most cookies and give that to the former one. This would lead to a better solution."
                    },
                    {
                        "username": "abhiMikasa",
                        "content": " ```\nclass Solution {\n    public static int maximaxi = Integer.MAX_VALUE;\n    public static int distributeCookies(int[] cookies, int k) {\n        distidfs(cookies,k,0,new int[k]);\n        int a = maximaxi;\n        maximaxi = Integer.MAX_VALUE;\n        return a;\n    }\n     public static  void  distidfs(int[] cookies, int k , int index , int[] child){\n        if(index == cookies.length){\n            int max = 0;\n            for(int i = 0; i < child.length; i++){\n                max = Math.max(max,child[i]);\n            }\n            maximaxi = Math.min(max,maximaxi);\n            return;\n        }\n        for(int i = 0; i < child.length; i++){\n            child[i] += cookies[index];\n            distidfs(cookies,k,index + 1,child);\n            child[i] -= cookies[index];\n            if(child[i] == 0) break;\n        }\n     }\n}\n```\n\n\nhow the statement :- `if(child[i] == 0) break;` \nincreases the efficiency of code."
                    },
                    {
                        "username": "bparanj",
                        "content": "The statement `if(child[i] == 0) break;` is a pruning operation that helps to eliminate some unnecessary recursive calls, thereby increasing the efficiency of the code.\\n\\nIn the context of this problem, it\\'s saying that if a child hasn\\'t received any cookies yet (`child[i] == 0`), we don\\'t need to consider giving cookies to the rest of the children for the current distribution. This is because we\\'re trying to minimize the maximum number of cookies any child gets, and giving more cookies to children who have already received cookies will only increase the maximum.\\n\\nBy breaking early when we encounter a child who hasn\\'t received any cookies yet, we eliminate the possibility of distributing cookies in a way that is guaranteed to be suboptimal (i.e., a way that results in a larger maximum number of cookies for any child). This pruning operation helps to reduce the size of the search space that the backtracking algorithm needs to explore, thereby increasing its efficiency.\\n\\nHowever, please note that this type of optimization is problem-specific and depends on the problem\\'s unique requirements and constraints. It may not be applicable or beneficial in all situations."
                    },
                    {
                        "username": "bhruti1",
                        "content": "Interesting problem statement."
                    },
                    {
                        "username": "Master_Floppa",
                        "content": "Why is the dp solution failing here? Isn\\'t there a repetitive subproblem?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem of distributing cookies to children might initially seem like it could be solved using a dynamic programming (DP) approach, especially given that there seems to be overlapping subproblems (i.e., the distribution of remaining cookies after giving some to a child). \\n\\nHowever, there are a few reasons why a traditional DP solution could fail or be inefficient for this problem:\\n\\n1. **State definition is complex**: In a DP problem, we typically define the state in terms of a few variables, like the current index or remaining value, and we base our subproblems around these states. However, in this case, to define a state, we need to keep track of the remaining cookies, the number of children left, and also how much each child has already received to maintain the \"minimum unfairness\" constraint. This leads to a very high-dimensional DP table, which can be challenging to handle and reason about.\\n\\n2. **No optimal substructure**: DP relies on the principle of optimal substructure, which says that the optimal solution to a problem can be constructed efficiently from the optimal solutions of its subproblems. However, in this problem, giving more cookies to a child in an attempt to optimize the current distribution does not guarantee that this will lead to the optimal solution in the end, as we are trying to minimize the maximum number of cookies a child can get. The choice at one step depends on choices at other steps, which does not adhere strictly to the optimal substructure property.\\n\\nThese factors make the problem unsuitable for a straightforward DP solution. However, a more advanced technique, such as using DP with bitmasking to keep track of which cookies have been distributed, might be possible but would be far more complex than simpler approaches like backtracking or binary search."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Binary Search + 0/1Kp ??"
                    }
                ]
            },
            {
                "id": 1951391,
                "content": [
                    {
                        "username": "Jeya_Mathesh_Ganesh",
                        "content": "Why can\\'t all the cookies go to a same person??"
                    },
                    {
                        "username": "Novice69",
                        "content": "as k is not always 1"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "can it be done using min priority queue ??\\n"
                    },
                    {
                        "username": "Dhairya_Vardhan_Chauhan",
                        "content": "very simple problem coz of constraints"
                    },
                    {
                        "username": "codedreamer911",
                        "content": "Is the distribution continuous or it may be random"
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "it can be random too as they didn\\'t mention it should not be, and the first example can explain it"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Thought, it would be solved using greedy approach by sorting and all at first glance. But that\\'s not the case. "
                    },
                    {
                        "username": "ixeridium",
                        "content": "Just wondering what would happen if you went into an interview and said, that all the exact dp and backtrack solutions would not scale because of exponential complexity and that a greedy approach is fast, typically good enough in practice and hence should be used here."
                    },
                    {
                        "username": "coder_birappan",
                        "content": "Can anyone pls tell for lager N what should we do....we cant use backtracking so how we solve?"
                    },
                    {
                        "username": "21Cash",
                        "content": "Guyz read the constraints carefully, my dumbass read them wrong and i was perplexed thinking how can we solve this with the cookies.leng <= 10^5, its cookies[i] <= 10^5"
                    },
                    {
                        "username": "Ganes123",
                        "content": "Can anyone provide with the contradictory example ,\nWhen actually greedy fails for the above problem?"
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "[@bparanj](/bparanj) how is 12 better than 10?"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@bparanj](/bparanj)  this is wrong tho? the minimum unfairness is 10-8=2 while 12-6=6"
                    },
                    {
                        "username": "bparanj",
                        "content": "A simple scenario where a greedy approach could fail in this problem would be the following:\\n\\nSuppose we have `cookies = [5, 10, 2]` and `k = 2`.\\n\\nThe greedy approach would be to always give the largest available cookie to the child who currently has the least total cookies. This means we first give cookie 10 to child 1 (cookies now: child 1 = 10, child 2 = 0), then cookie 5 to child 2 (cookies now: child 1 = 10, child 2 = 5), and finally cookie 2 to child 2 (cookies now: child 1 = 10, child 2 = 7).\\n\\nSo the maximum number of cookies any child has (the unfairness) is 10. But we could do better.\\n\\nInstead, if we distributed the cookies like this: first give cookie 10 to child 1, then cookie 5 to child 2, and then cookie 2 to child 1 (cookies now: child 1 = 12, child 2 = 5), the maximum number of cookies any child has is 12, which is worse than the greedy solution.\\n\\nHowever, if we distributed the cookies like this: first give cookie 5 to child 1, then cookie 2 to child 1 (cookies now: child 1 = 7, child 2 = 0), and finally cookie 10 to child 2 (cookies now: child 1 = 7, child 2 = 10), the maximum number of cookies any child has is only 10, which is equal to the greedy solution and doesn\\'t demonstrate the failure of the greedy approach.\\n\\nThus, to demonstrate the failure of the greedy approach, let\\'s add a fourth cookie: `cookies = [5, 10, 2, 1]` and `k = 2`.\\n\\nNow, if we distributed the cookies like this: first give cookie 10 to child 1, then cookie 5 to child 2, then cookie 2 to child 2, and finally cookie 1 to child 2 (cookies now: child 1 = 10, child 2 = 8), the maximum number of cookies any child has is 10.\\n\\nHowever, the optimal distribution is: first give cookie 10 to child 1, then cookie 5 to child 2, then cookie 2 to child 1, and finally cookie 1 to child 2 (cookies now: child 1 = 12, child 2 = 6), the maximum number of cookies any child has is 12, which is better than the greedy solution. Hence, this example demonstrates a case where the greedy approach fails to find the optimal solution."
                    },
                    {
                        "username": "ixeridium",
                        "content": "Maybe [3,3,2,2,2] and k= 2. If a greedy algorithm distributed the two bags with three cookies to each of the two kids first, then one would end up with a distribution [3,2,2] and [3,2], instead of the optimal solution [3,3] and [2,2,2]. This assumes of course that the greedy algorithm distributes the largest bags first."
                    },
                    {
                        "username": "CodeFact",
                        "content": "All the cookies in the same bag must go to the same child and cannot be split up.     what it means ?"
                    },
                    {
                        "username": "las1_uchiha",
                        "content": "it means arr[i] cannot be split up; should be taken as a whole"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Why i\\'m so dumb!"
                    }
                ]
            },
            {
                "id": 1951378,
                "content": [
                    {
                        "username": "Jeya_Mathesh_Ganesh",
                        "content": "Why can\\'t all the cookies go to a same person??"
                    },
                    {
                        "username": "Novice69",
                        "content": "as k is not always 1"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "can it be done using min priority queue ??\\n"
                    },
                    {
                        "username": "Dhairya_Vardhan_Chauhan",
                        "content": "very simple problem coz of constraints"
                    },
                    {
                        "username": "codedreamer911",
                        "content": "Is the distribution continuous or it may be random"
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "it can be random too as they didn\\'t mention it should not be, and the first example can explain it"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Thought, it would be solved using greedy approach by sorting and all at first glance. But that\\'s not the case. "
                    },
                    {
                        "username": "ixeridium",
                        "content": "Just wondering what would happen if you went into an interview and said, that all the exact dp and backtrack solutions would not scale because of exponential complexity and that a greedy approach is fast, typically good enough in practice and hence should be used here."
                    },
                    {
                        "username": "coder_birappan",
                        "content": "Can anyone pls tell for lager N what should we do....we cant use backtracking so how we solve?"
                    },
                    {
                        "username": "21Cash",
                        "content": "Guyz read the constraints carefully, my dumbass read them wrong and i was perplexed thinking how can we solve this with the cookies.leng <= 10^5, its cookies[i] <= 10^5"
                    },
                    {
                        "username": "Ganes123",
                        "content": "Can anyone provide with the contradictory example ,\nWhen actually greedy fails for the above problem?"
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "[@bparanj](/bparanj) how is 12 better than 10?"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@bparanj](/bparanj)  this is wrong tho? the minimum unfairness is 10-8=2 while 12-6=6"
                    },
                    {
                        "username": "bparanj",
                        "content": "A simple scenario where a greedy approach could fail in this problem would be the following:\\n\\nSuppose we have `cookies = [5, 10, 2]` and `k = 2`.\\n\\nThe greedy approach would be to always give the largest available cookie to the child who currently has the least total cookies. This means we first give cookie 10 to child 1 (cookies now: child 1 = 10, child 2 = 0), then cookie 5 to child 2 (cookies now: child 1 = 10, child 2 = 5), and finally cookie 2 to child 2 (cookies now: child 1 = 10, child 2 = 7).\\n\\nSo the maximum number of cookies any child has (the unfairness) is 10. But we could do better.\\n\\nInstead, if we distributed the cookies like this: first give cookie 10 to child 1, then cookie 5 to child 2, and then cookie 2 to child 1 (cookies now: child 1 = 12, child 2 = 5), the maximum number of cookies any child has is 12, which is worse than the greedy solution.\\n\\nHowever, if we distributed the cookies like this: first give cookie 5 to child 1, then cookie 2 to child 1 (cookies now: child 1 = 7, child 2 = 0), and finally cookie 10 to child 2 (cookies now: child 1 = 7, child 2 = 10), the maximum number of cookies any child has is only 10, which is equal to the greedy solution and doesn\\'t demonstrate the failure of the greedy approach.\\n\\nThus, to demonstrate the failure of the greedy approach, let\\'s add a fourth cookie: `cookies = [5, 10, 2, 1]` and `k = 2`.\\n\\nNow, if we distributed the cookies like this: first give cookie 10 to child 1, then cookie 5 to child 2, then cookie 2 to child 2, and finally cookie 1 to child 2 (cookies now: child 1 = 10, child 2 = 8), the maximum number of cookies any child has is 10.\\n\\nHowever, the optimal distribution is: first give cookie 10 to child 1, then cookie 5 to child 2, then cookie 2 to child 1, and finally cookie 1 to child 2 (cookies now: child 1 = 12, child 2 = 6), the maximum number of cookies any child has is 12, which is better than the greedy solution. Hence, this example demonstrates a case where the greedy approach fails to find the optimal solution."
                    },
                    {
                        "username": "ixeridium",
                        "content": "Maybe [3,3,2,2,2] and k= 2. If a greedy algorithm distributed the two bags with three cookies to each of the two kids first, then one would end up with a distribution [3,2,2] and [3,2], instead of the optimal solution [3,3] and [2,2,2]. This assumes of course that the greedy algorithm distributes the largest bags first."
                    },
                    {
                        "username": "CodeFact",
                        "content": "All the cookies in the same bag must go to the same child and cannot be split up.     what it means ?"
                    },
                    {
                        "username": "las1_uchiha",
                        "content": "it means arr[i] cannot be split up; should be taken as a whole"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Why i\\'m so dumb!"
                    }
                ]
            },
            {
                "id": 1951369,
                "content": [
                    {
                        "username": "Jeya_Mathesh_Ganesh",
                        "content": "Why can\\'t all the cookies go to a same person??"
                    },
                    {
                        "username": "Novice69",
                        "content": "as k is not always 1"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "can it be done using min priority queue ??\\n"
                    },
                    {
                        "username": "Dhairya_Vardhan_Chauhan",
                        "content": "very simple problem coz of constraints"
                    },
                    {
                        "username": "codedreamer911",
                        "content": "Is the distribution continuous or it may be random"
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "it can be random too as they didn\\'t mention it should not be, and the first example can explain it"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Thought, it would be solved using greedy approach by sorting and all at first glance. But that\\'s not the case. "
                    },
                    {
                        "username": "ixeridium",
                        "content": "Just wondering what would happen if you went into an interview and said, that all the exact dp and backtrack solutions would not scale because of exponential complexity and that a greedy approach is fast, typically good enough in practice and hence should be used here."
                    },
                    {
                        "username": "coder_birappan",
                        "content": "Can anyone pls tell for lager N what should we do....we cant use backtracking so how we solve?"
                    },
                    {
                        "username": "21Cash",
                        "content": "Guyz read the constraints carefully, my dumbass read them wrong and i was perplexed thinking how can we solve this with the cookies.leng <= 10^5, its cookies[i] <= 10^5"
                    },
                    {
                        "username": "Ganes123",
                        "content": "Can anyone provide with the contradictory example ,\nWhen actually greedy fails for the above problem?"
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "[@bparanj](/bparanj) how is 12 better than 10?"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@bparanj](/bparanj)  this is wrong tho? the minimum unfairness is 10-8=2 while 12-6=6"
                    },
                    {
                        "username": "bparanj",
                        "content": "A simple scenario where a greedy approach could fail in this problem would be the following:\\n\\nSuppose we have `cookies = [5, 10, 2]` and `k = 2`.\\n\\nThe greedy approach would be to always give the largest available cookie to the child who currently has the least total cookies. This means we first give cookie 10 to child 1 (cookies now: child 1 = 10, child 2 = 0), then cookie 5 to child 2 (cookies now: child 1 = 10, child 2 = 5), and finally cookie 2 to child 2 (cookies now: child 1 = 10, child 2 = 7).\\n\\nSo the maximum number of cookies any child has (the unfairness) is 10. But we could do better.\\n\\nInstead, if we distributed the cookies like this: first give cookie 10 to child 1, then cookie 5 to child 2, and then cookie 2 to child 1 (cookies now: child 1 = 12, child 2 = 5), the maximum number of cookies any child has is 12, which is worse than the greedy solution.\\n\\nHowever, if we distributed the cookies like this: first give cookie 5 to child 1, then cookie 2 to child 1 (cookies now: child 1 = 7, child 2 = 0), and finally cookie 10 to child 2 (cookies now: child 1 = 7, child 2 = 10), the maximum number of cookies any child has is only 10, which is equal to the greedy solution and doesn\\'t demonstrate the failure of the greedy approach.\\n\\nThus, to demonstrate the failure of the greedy approach, let\\'s add a fourth cookie: `cookies = [5, 10, 2, 1]` and `k = 2`.\\n\\nNow, if we distributed the cookies like this: first give cookie 10 to child 1, then cookie 5 to child 2, then cookie 2 to child 2, and finally cookie 1 to child 2 (cookies now: child 1 = 10, child 2 = 8), the maximum number of cookies any child has is 10.\\n\\nHowever, the optimal distribution is: first give cookie 10 to child 1, then cookie 5 to child 2, then cookie 2 to child 1, and finally cookie 1 to child 2 (cookies now: child 1 = 12, child 2 = 6), the maximum number of cookies any child has is 12, which is better than the greedy solution. Hence, this example demonstrates a case where the greedy approach fails to find the optimal solution."
                    },
                    {
                        "username": "ixeridium",
                        "content": "Maybe [3,3,2,2,2] and k= 2. If a greedy algorithm distributed the two bags with three cookies to each of the two kids first, then one would end up with a distribution [3,2,2] and [3,2], instead of the optimal solution [3,3] and [2,2,2]. This assumes of course that the greedy algorithm distributes the largest bags first."
                    },
                    {
                        "username": "CodeFact",
                        "content": "All the cookies in the same bag must go to the same child and cannot be split up.     what it means ?"
                    },
                    {
                        "username": "las1_uchiha",
                        "content": "it means arr[i] cannot be split up; should be taken as a whole"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Why i\\'m so dumb!"
                    }
                ]
            },
            {
                "id": 1951360,
                "content": [
                    {
                        "username": "Jeya_Mathesh_Ganesh",
                        "content": "Why can\\'t all the cookies go to a same person??"
                    },
                    {
                        "username": "Novice69",
                        "content": "as k is not always 1"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "can it be done using min priority queue ??\\n"
                    },
                    {
                        "username": "Dhairya_Vardhan_Chauhan",
                        "content": "very simple problem coz of constraints"
                    },
                    {
                        "username": "codedreamer911",
                        "content": "Is the distribution continuous or it may be random"
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "it can be random too as they didn\\'t mention it should not be, and the first example can explain it"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Thought, it would be solved using greedy approach by sorting and all at first glance. But that\\'s not the case. "
                    },
                    {
                        "username": "ixeridium",
                        "content": "Just wondering what would happen if you went into an interview and said, that all the exact dp and backtrack solutions would not scale because of exponential complexity and that a greedy approach is fast, typically good enough in practice and hence should be used here."
                    },
                    {
                        "username": "coder_birappan",
                        "content": "Can anyone pls tell for lager N what should we do....we cant use backtracking so how we solve?"
                    },
                    {
                        "username": "21Cash",
                        "content": "Guyz read the constraints carefully, my dumbass read them wrong and i was perplexed thinking how can we solve this with the cookies.leng <= 10^5, its cookies[i] <= 10^5"
                    },
                    {
                        "username": "Ganes123",
                        "content": "Can anyone provide with the contradictory example ,\nWhen actually greedy fails for the above problem?"
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "[@bparanj](/bparanj) how is 12 better than 10?"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@bparanj](/bparanj)  this is wrong tho? the minimum unfairness is 10-8=2 while 12-6=6"
                    },
                    {
                        "username": "bparanj",
                        "content": "A simple scenario where a greedy approach could fail in this problem would be the following:\\n\\nSuppose we have `cookies = [5, 10, 2]` and `k = 2`.\\n\\nThe greedy approach would be to always give the largest available cookie to the child who currently has the least total cookies. This means we first give cookie 10 to child 1 (cookies now: child 1 = 10, child 2 = 0), then cookie 5 to child 2 (cookies now: child 1 = 10, child 2 = 5), and finally cookie 2 to child 2 (cookies now: child 1 = 10, child 2 = 7).\\n\\nSo the maximum number of cookies any child has (the unfairness) is 10. But we could do better.\\n\\nInstead, if we distributed the cookies like this: first give cookie 10 to child 1, then cookie 5 to child 2, and then cookie 2 to child 1 (cookies now: child 1 = 12, child 2 = 5), the maximum number of cookies any child has is 12, which is worse than the greedy solution.\\n\\nHowever, if we distributed the cookies like this: first give cookie 5 to child 1, then cookie 2 to child 1 (cookies now: child 1 = 7, child 2 = 0), and finally cookie 10 to child 2 (cookies now: child 1 = 7, child 2 = 10), the maximum number of cookies any child has is only 10, which is equal to the greedy solution and doesn\\'t demonstrate the failure of the greedy approach.\\n\\nThus, to demonstrate the failure of the greedy approach, let\\'s add a fourth cookie: `cookies = [5, 10, 2, 1]` and `k = 2`.\\n\\nNow, if we distributed the cookies like this: first give cookie 10 to child 1, then cookie 5 to child 2, then cookie 2 to child 2, and finally cookie 1 to child 2 (cookies now: child 1 = 10, child 2 = 8), the maximum number of cookies any child has is 10.\\n\\nHowever, the optimal distribution is: first give cookie 10 to child 1, then cookie 5 to child 2, then cookie 2 to child 1, and finally cookie 1 to child 2 (cookies now: child 1 = 12, child 2 = 6), the maximum number of cookies any child has is 12, which is better than the greedy solution. Hence, this example demonstrates a case where the greedy approach fails to find the optimal solution."
                    },
                    {
                        "username": "ixeridium",
                        "content": "Maybe [3,3,2,2,2] and k= 2. If a greedy algorithm distributed the two bags with three cookies to each of the two kids first, then one would end up with a distribution [3,2,2] and [3,2], instead of the optimal solution [3,3] and [2,2,2]. This assumes of course that the greedy algorithm distributes the largest bags first."
                    },
                    {
                        "username": "CodeFact",
                        "content": "All the cookies in the same bag must go to the same child and cannot be split up.     what it means ?"
                    },
                    {
                        "username": "las1_uchiha",
                        "content": "it means arr[i] cannot be split up; should be taken as a whole"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Why i\\'m so dumb!"
                    }
                ]
            },
            {
                "id": 1951284,
                "content": [
                    {
                        "username": "Jeya_Mathesh_Ganesh",
                        "content": "Why can\\'t all the cookies go to a same person??"
                    },
                    {
                        "username": "Novice69",
                        "content": "as k is not always 1"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "can it be done using min priority queue ??\\n"
                    },
                    {
                        "username": "Dhairya_Vardhan_Chauhan",
                        "content": "very simple problem coz of constraints"
                    },
                    {
                        "username": "codedreamer911",
                        "content": "Is the distribution continuous or it may be random"
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "it can be random too as they didn\\'t mention it should not be, and the first example can explain it"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Thought, it would be solved using greedy approach by sorting and all at first glance. But that\\'s not the case. "
                    },
                    {
                        "username": "ixeridium",
                        "content": "Just wondering what would happen if you went into an interview and said, that all the exact dp and backtrack solutions would not scale because of exponential complexity and that a greedy approach is fast, typically good enough in practice and hence should be used here."
                    },
                    {
                        "username": "coder_birappan",
                        "content": "Can anyone pls tell for lager N what should we do....we cant use backtracking so how we solve?"
                    },
                    {
                        "username": "21Cash",
                        "content": "Guyz read the constraints carefully, my dumbass read them wrong and i was perplexed thinking how can we solve this with the cookies.leng <= 10^5, its cookies[i] <= 10^5"
                    },
                    {
                        "username": "Ganes123",
                        "content": "Can anyone provide with the contradictory example ,\nWhen actually greedy fails for the above problem?"
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "[@bparanj](/bparanj) how is 12 better than 10?"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@bparanj](/bparanj)  this is wrong tho? the minimum unfairness is 10-8=2 while 12-6=6"
                    },
                    {
                        "username": "bparanj",
                        "content": "A simple scenario where a greedy approach could fail in this problem would be the following:\\n\\nSuppose we have `cookies = [5, 10, 2]` and `k = 2`.\\n\\nThe greedy approach would be to always give the largest available cookie to the child who currently has the least total cookies. This means we first give cookie 10 to child 1 (cookies now: child 1 = 10, child 2 = 0), then cookie 5 to child 2 (cookies now: child 1 = 10, child 2 = 5), and finally cookie 2 to child 2 (cookies now: child 1 = 10, child 2 = 7).\\n\\nSo the maximum number of cookies any child has (the unfairness) is 10. But we could do better.\\n\\nInstead, if we distributed the cookies like this: first give cookie 10 to child 1, then cookie 5 to child 2, and then cookie 2 to child 1 (cookies now: child 1 = 12, child 2 = 5), the maximum number of cookies any child has is 12, which is worse than the greedy solution.\\n\\nHowever, if we distributed the cookies like this: first give cookie 5 to child 1, then cookie 2 to child 1 (cookies now: child 1 = 7, child 2 = 0), and finally cookie 10 to child 2 (cookies now: child 1 = 7, child 2 = 10), the maximum number of cookies any child has is only 10, which is equal to the greedy solution and doesn\\'t demonstrate the failure of the greedy approach.\\n\\nThus, to demonstrate the failure of the greedy approach, let\\'s add a fourth cookie: `cookies = [5, 10, 2, 1]` and `k = 2`.\\n\\nNow, if we distributed the cookies like this: first give cookie 10 to child 1, then cookie 5 to child 2, then cookie 2 to child 2, and finally cookie 1 to child 2 (cookies now: child 1 = 10, child 2 = 8), the maximum number of cookies any child has is 10.\\n\\nHowever, the optimal distribution is: first give cookie 10 to child 1, then cookie 5 to child 2, then cookie 2 to child 1, and finally cookie 1 to child 2 (cookies now: child 1 = 12, child 2 = 6), the maximum number of cookies any child has is 12, which is better than the greedy solution. Hence, this example demonstrates a case where the greedy approach fails to find the optimal solution."
                    },
                    {
                        "username": "ixeridium",
                        "content": "Maybe [3,3,2,2,2] and k= 2. If a greedy algorithm distributed the two bags with three cookies to each of the two kids first, then one would end up with a distribution [3,2,2] and [3,2], instead of the optimal solution [3,3] and [2,2,2]. This assumes of course that the greedy algorithm distributes the largest bags first."
                    },
                    {
                        "username": "CodeFact",
                        "content": "All the cookies in the same bag must go to the same child and cannot be split up.     what it means ?"
                    },
                    {
                        "username": "las1_uchiha",
                        "content": "it means arr[i] cannot be split up; should be taken as a whole"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Why i\\'m so dumb!"
                    }
                ]
            },
            {
                "id": 1951273,
                "content": [
                    {
                        "username": "Jeya_Mathesh_Ganesh",
                        "content": "Why can\\'t all the cookies go to a same person??"
                    },
                    {
                        "username": "Novice69",
                        "content": "as k is not always 1"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "can it be done using min priority queue ??\\n"
                    },
                    {
                        "username": "Dhairya_Vardhan_Chauhan",
                        "content": "very simple problem coz of constraints"
                    },
                    {
                        "username": "codedreamer911",
                        "content": "Is the distribution continuous or it may be random"
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "it can be random too as they didn\\'t mention it should not be, and the first example can explain it"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Thought, it would be solved using greedy approach by sorting and all at first glance. But that\\'s not the case. "
                    },
                    {
                        "username": "ixeridium",
                        "content": "Just wondering what would happen if you went into an interview and said, that all the exact dp and backtrack solutions would not scale because of exponential complexity and that a greedy approach is fast, typically good enough in practice and hence should be used here."
                    },
                    {
                        "username": "coder_birappan",
                        "content": "Can anyone pls tell for lager N what should we do....we cant use backtracking so how we solve?"
                    },
                    {
                        "username": "21Cash",
                        "content": "Guyz read the constraints carefully, my dumbass read them wrong and i was perplexed thinking how can we solve this with the cookies.leng <= 10^5, its cookies[i] <= 10^5"
                    },
                    {
                        "username": "Ganes123",
                        "content": "Can anyone provide with the contradictory example ,\nWhen actually greedy fails for the above problem?"
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "[@bparanj](/bparanj) how is 12 better than 10?"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@bparanj](/bparanj)  this is wrong tho? the minimum unfairness is 10-8=2 while 12-6=6"
                    },
                    {
                        "username": "bparanj",
                        "content": "A simple scenario where a greedy approach could fail in this problem would be the following:\\n\\nSuppose we have `cookies = [5, 10, 2]` and `k = 2`.\\n\\nThe greedy approach would be to always give the largest available cookie to the child who currently has the least total cookies. This means we first give cookie 10 to child 1 (cookies now: child 1 = 10, child 2 = 0), then cookie 5 to child 2 (cookies now: child 1 = 10, child 2 = 5), and finally cookie 2 to child 2 (cookies now: child 1 = 10, child 2 = 7).\\n\\nSo the maximum number of cookies any child has (the unfairness) is 10. But we could do better.\\n\\nInstead, if we distributed the cookies like this: first give cookie 10 to child 1, then cookie 5 to child 2, and then cookie 2 to child 1 (cookies now: child 1 = 12, child 2 = 5), the maximum number of cookies any child has is 12, which is worse than the greedy solution.\\n\\nHowever, if we distributed the cookies like this: first give cookie 5 to child 1, then cookie 2 to child 1 (cookies now: child 1 = 7, child 2 = 0), and finally cookie 10 to child 2 (cookies now: child 1 = 7, child 2 = 10), the maximum number of cookies any child has is only 10, which is equal to the greedy solution and doesn\\'t demonstrate the failure of the greedy approach.\\n\\nThus, to demonstrate the failure of the greedy approach, let\\'s add a fourth cookie: `cookies = [5, 10, 2, 1]` and `k = 2`.\\n\\nNow, if we distributed the cookies like this: first give cookie 10 to child 1, then cookie 5 to child 2, then cookie 2 to child 2, and finally cookie 1 to child 2 (cookies now: child 1 = 10, child 2 = 8), the maximum number of cookies any child has is 10.\\n\\nHowever, the optimal distribution is: first give cookie 10 to child 1, then cookie 5 to child 2, then cookie 2 to child 1, and finally cookie 1 to child 2 (cookies now: child 1 = 12, child 2 = 6), the maximum number of cookies any child has is 12, which is better than the greedy solution. Hence, this example demonstrates a case where the greedy approach fails to find the optimal solution."
                    },
                    {
                        "username": "ixeridium",
                        "content": "Maybe [3,3,2,2,2] and k= 2. If a greedy algorithm distributed the two bags with three cookies to each of the two kids first, then one would end up with a distribution [3,2,2] and [3,2], instead of the optimal solution [3,3] and [2,2,2]. This assumes of course that the greedy algorithm distributes the largest bags first."
                    },
                    {
                        "username": "CodeFact",
                        "content": "All the cookies in the same bag must go to the same child and cannot be split up.     what it means ?"
                    },
                    {
                        "username": "las1_uchiha",
                        "content": "it means arr[i] cannot be split up; should be taken as a whole"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Why i\\'m so dumb!"
                    }
                ]
            },
            {
                "id": 1951244,
                "content": [
                    {
                        "username": "Jeya_Mathesh_Ganesh",
                        "content": "Why can\\'t all the cookies go to a same person??"
                    },
                    {
                        "username": "Novice69",
                        "content": "as k is not always 1"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "can it be done using min priority queue ??\\n"
                    },
                    {
                        "username": "Dhairya_Vardhan_Chauhan",
                        "content": "very simple problem coz of constraints"
                    },
                    {
                        "username": "codedreamer911",
                        "content": "Is the distribution continuous or it may be random"
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "it can be random too as they didn\\'t mention it should not be, and the first example can explain it"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Thought, it would be solved using greedy approach by sorting and all at first glance. But that\\'s not the case. "
                    },
                    {
                        "username": "ixeridium",
                        "content": "Just wondering what would happen if you went into an interview and said, that all the exact dp and backtrack solutions would not scale because of exponential complexity and that a greedy approach is fast, typically good enough in practice and hence should be used here."
                    },
                    {
                        "username": "coder_birappan",
                        "content": "Can anyone pls tell for lager N what should we do....we cant use backtracking so how we solve?"
                    },
                    {
                        "username": "21Cash",
                        "content": "Guyz read the constraints carefully, my dumbass read them wrong and i was perplexed thinking how can we solve this with the cookies.leng <= 10^5, its cookies[i] <= 10^5"
                    },
                    {
                        "username": "Ganes123",
                        "content": "Can anyone provide with the contradictory example ,\nWhen actually greedy fails for the above problem?"
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "[@bparanj](/bparanj) how is 12 better than 10?"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@bparanj](/bparanj)  this is wrong tho? the minimum unfairness is 10-8=2 while 12-6=6"
                    },
                    {
                        "username": "bparanj",
                        "content": "A simple scenario where a greedy approach could fail in this problem would be the following:\\n\\nSuppose we have `cookies = [5, 10, 2]` and `k = 2`.\\n\\nThe greedy approach would be to always give the largest available cookie to the child who currently has the least total cookies. This means we first give cookie 10 to child 1 (cookies now: child 1 = 10, child 2 = 0), then cookie 5 to child 2 (cookies now: child 1 = 10, child 2 = 5), and finally cookie 2 to child 2 (cookies now: child 1 = 10, child 2 = 7).\\n\\nSo the maximum number of cookies any child has (the unfairness) is 10. But we could do better.\\n\\nInstead, if we distributed the cookies like this: first give cookie 10 to child 1, then cookie 5 to child 2, and then cookie 2 to child 1 (cookies now: child 1 = 12, child 2 = 5), the maximum number of cookies any child has is 12, which is worse than the greedy solution.\\n\\nHowever, if we distributed the cookies like this: first give cookie 5 to child 1, then cookie 2 to child 1 (cookies now: child 1 = 7, child 2 = 0), and finally cookie 10 to child 2 (cookies now: child 1 = 7, child 2 = 10), the maximum number of cookies any child has is only 10, which is equal to the greedy solution and doesn\\'t demonstrate the failure of the greedy approach.\\n\\nThus, to demonstrate the failure of the greedy approach, let\\'s add a fourth cookie: `cookies = [5, 10, 2, 1]` and `k = 2`.\\n\\nNow, if we distributed the cookies like this: first give cookie 10 to child 1, then cookie 5 to child 2, then cookie 2 to child 2, and finally cookie 1 to child 2 (cookies now: child 1 = 10, child 2 = 8), the maximum number of cookies any child has is 10.\\n\\nHowever, the optimal distribution is: first give cookie 10 to child 1, then cookie 5 to child 2, then cookie 2 to child 1, and finally cookie 1 to child 2 (cookies now: child 1 = 12, child 2 = 6), the maximum number of cookies any child has is 12, which is better than the greedy solution. Hence, this example demonstrates a case where the greedy approach fails to find the optimal solution."
                    },
                    {
                        "username": "ixeridium",
                        "content": "Maybe [3,3,2,2,2] and k= 2. If a greedy algorithm distributed the two bags with three cookies to each of the two kids first, then one would end up with a distribution [3,2,2] and [3,2], instead of the optimal solution [3,3] and [2,2,2]. This assumes of course that the greedy algorithm distributes the largest bags first."
                    },
                    {
                        "username": "CodeFact",
                        "content": "All the cookies in the same bag must go to the same child and cannot be split up.     what it means ?"
                    },
                    {
                        "username": "las1_uchiha",
                        "content": "it means arr[i] cannot be split up; should be taken as a whole"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Why i\\'m so dumb!"
                    }
                ]
            },
            {
                "id": 1951212,
                "content": [
                    {
                        "username": "Jeya_Mathesh_Ganesh",
                        "content": "Why can\\'t all the cookies go to a same person??"
                    },
                    {
                        "username": "Novice69",
                        "content": "as k is not always 1"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "can it be done using min priority queue ??\\n"
                    },
                    {
                        "username": "Dhairya_Vardhan_Chauhan",
                        "content": "very simple problem coz of constraints"
                    },
                    {
                        "username": "codedreamer911",
                        "content": "Is the distribution continuous or it may be random"
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "it can be random too as they didn\\'t mention it should not be, and the first example can explain it"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Thought, it would be solved using greedy approach by sorting and all at first glance. But that\\'s not the case. "
                    },
                    {
                        "username": "ixeridium",
                        "content": "Just wondering what would happen if you went into an interview and said, that all the exact dp and backtrack solutions would not scale because of exponential complexity and that a greedy approach is fast, typically good enough in practice and hence should be used here."
                    },
                    {
                        "username": "coder_birappan",
                        "content": "Can anyone pls tell for lager N what should we do....we cant use backtracking so how we solve?"
                    },
                    {
                        "username": "21Cash",
                        "content": "Guyz read the constraints carefully, my dumbass read them wrong and i was perplexed thinking how can we solve this with the cookies.leng <= 10^5, its cookies[i] <= 10^5"
                    },
                    {
                        "username": "Ganes123",
                        "content": "Can anyone provide with the contradictory example ,\nWhen actually greedy fails for the above problem?"
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "[@bparanj](/bparanj) how is 12 better than 10?"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@bparanj](/bparanj)  this is wrong tho? the minimum unfairness is 10-8=2 while 12-6=6"
                    },
                    {
                        "username": "bparanj",
                        "content": "A simple scenario where a greedy approach could fail in this problem would be the following:\\n\\nSuppose we have `cookies = [5, 10, 2]` and `k = 2`.\\n\\nThe greedy approach would be to always give the largest available cookie to the child who currently has the least total cookies. This means we first give cookie 10 to child 1 (cookies now: child 1 = 10, child 2 = 0), then cookie 5 to child 2 (cookies now: child 1 = 10, child 2 = 5), and finally cookie 2 to child 2 (cookies now: child 1 = 10, child 2 = 7).\\n\\nSo the maximum number of cookies any child has (the unfairness) is 10. But we could do better.\\n\\nInstead, if we distributed the cookies like this: first give cookie 10 to child 1, then cookie 5 to child 2, and then cookie 2 to child 1 (cookies now: child 1 = 12, child 2 = 5), the maximum number of cookies any child has is 12, which is worse than the greedy solution.\\n\\nHowever, if we distributed the cookies like this: first give cookie 5 to child 1, then cookie 2 to child 1 (cookies now: child 1 = 7, child 2 = 0), and finally cookie 10 to child 2 (cookies now: child 1 = 7, child 2 = 10), the maximum number of cookies any child has is only 10, which is equal to the greedy solution and doesn\\'t demonstrate the failure of the greedy approach.\\n\\nThus, to demonstrate the failure of the greedy approach, let\\'s add a fourth cookie: `cookies = [5, 10, 2, 1]` and `k = 2`.\\n\\nNow, if we distributed the cookies like this: first give cookie 10 to child 1, then cookie 5 to child 2, then cookie 2 to child 2, and finally cookie 1 to child 2 (cookies now: child 1 = 10, child 2 = 8), the maximum number of cookies any child has is 10.\\n\\nHowever, the optimal distribution is: first give cookie 10 to child 1, then cookie 5 to child 2, then cookie 2 to child 1, and finally cookie 1 to child 2 (cookies now: child 1 = 12, child 2 = 6), the maximum number of cookies any child has is 12, which is better than the greedy solution. Hence, this example demonstrates a case where the greedy approach fails to find the optimal solution."
                    },
                    {
                        "username": "ixeridium",
                        "content": "Maybe [3,3,2,2,2] and k= 2. If a greedy algorithm distributed the two bags with three cookies to each of the two kids first, then one would end up with a distribution [3,2,2] and [3,2], instead of the optimal solution [3,3] and [2,2,2]. This assumes of course that the greedy algorithm distributes the largest bags first."
                    },
                    {
                        "username": "CodeFact",
                        "content": "All the cookies in the same bag must go to the same child and cannot be split up.     what it means ?"
                    },
                    {
                        "username": "las1_uchiha",
                        "content": "it means arr[i] cannot be split up; should be taken as a whole"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Why i\\'m so dumb!"
                    }
                ]
            },
            {
                "id": 1951209,
                "content": [
                    {
                        "username": "Jeya_Mathesh_Ganesh",
                        "content": "Why can\\'t all the cookies go to a same person??"
                    },
                    {
                        "username": "Novice69",
                        "content": "as k is not always 1"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "can it be done using min priority queue ??\\n"
                    },
                    {
                        "username": "Dhairya_Vardhan_Chauhan",
                        "content": "very simple problem coz of constraints"
                    },
                    {
                        "username": "codedreamer911",
                        "content": "Is the distribution continuous or it may be random"
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "it can be random too as they didn\\'t mention it should not be, and the first example can explain it"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Thought, it would be solved using greedy approach by sorting and all at first glance. But that\\'s not the case. "
                    },
                    {
                        "username": "ixeridium",
                        "content": "Just wondering what would happen if you went into an interview and said, that all the exact dp and backtrack solutions would not scale because of exponential complexity and that a greedy approach is fast, typically good enough in practice and hence should be used here."
                    },
                    {
                        "username": "coder_birappan",
                        "content": "Can anyone pls tell for lager N what should we do....we cant use backtracking so how we solve?"
                    },
                    {
                        "username": "21Cash",
                        "content": "Guyz read the constraints carefully, my dumbass read them wrong and i was perplexed thinking how can we solve this with the cookies.leng <= 10^5, its cookies[i] <= 10^5"
                    },
                    {
                        "username": "Ganes123",
                        "content": "Can anyone provide with the contradictory example ,\nWhen actually greedy fails for the above problem?"
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "[@bparanj](/bparanj) how is 12 better than 10?"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@bparanj](/bparanj)  this is wrong tho? the minimum unfairness is 10-8=2 while 12-6=6"
                    },
                    {
                        "username": "bparanj",
                        "content": "A simple scenario where a greedy approach could fail in this problem would be the following:\\n\\nSuppose we have `cookies = [5, 10, 2]` and `k = 2`.\\n\\nThe greedy approach would be to always give the largest available cookie to the child who currently has the least total cookies. This means we first give cookie 10 to child 1 (cookies now: child 1 = 10, child 2 = 0), then cookie 5 to child 2 (cookies now: child 1 = 10, child 2 = 5), and finally cookie 2 to child 2 (cookies now: child 1 = 10, child 2 = 7).\\n\\nSo the maximum number of cookies any child has (the unfairness) is 10. But we could do better.\\n\\nInstead, if we distributed the cookies like this: first give cookie 10 to child 1, then cookie 5 to child 2, and then cookie 2 to child 1 (cookies now: child 1 = 12, child 2 = 5), the maximum number of cookies any child has is 12, which is worse than the greedy solution.\\n\\nHowever, if we distributed the cookies like this: first give cookie 5 to child 1, then cookie 2 to child 1 (cookies now: child 1 = 7, child 2 = 0), and finally cookie 10 to child 2 (cookies now: child 1 = 7, child 2 = 10), the maximum number of cookies any child has is only 10, which is equal to the greedy solution and doesn\\'t demonstrate the failure of the greedy approach.\\n\\nThus, to demonstrate the failure of the greedy approach, let\\'s add a fourth cookie: `cookies = [5, 10, 2, 1]` and `k = 2`.\\n\\nNow, if we distributed the cookies like this: first give cookie 10 to child 1, then cookie 5 to child 2, then cookie 2 to child 2, and finally cookie 1 to child 2 (cookies now: child 1 = 10, child 2 = 8), the maximum number of cookies any child has is 10.\\n\\nHowever, the optimal distribution is: first give cookie 10 to child 1, then cookie 5 to child 2, then cookie 2 to child 1, and finally cookie 1 to child 2 (cookies now: child 1 = 12, child 2 = 6), the maximum number of cookies any child has is 12, which is better than the greedy solution. Hence, this example demonstrates a case where the greedy approach fails to find the optimal solution."
                    },
                    {
                        "username": "ixeridium",
                        "content": "Maybe [3,3,2,2,2] and k= 2. If a greedy algorithm distributed the two bags with three cookies to each of the two kids first, then one would end up with a distribution [3,2,2] and [3,2], instead of the optimal solution [3,3] and [2,2,2]. This assumes of course that the greedy algorithm distributes the largest bags first."
                    },
                    {
                        "username": "CodeFact",
                        "content": "All the cookies in the same bag must go to the same child and cannot be split up.     what it means ?"
                    },
                    {
                        "username": "las1_uchiha",
                        "content": "it means arr[i] cannot be split up; should be taken as a whole"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Why i\\'m so dumb!"
                    }
                ]
            },
            {
                "id": 1951155,
                "content": [
                    {
                        "username": "Jeya_Mathesh_Ganesh",
                        "content": "Why can\\'t all the cookies go to a same person??"
                    },
                    {
                        "username": "Novice69",
                        "content": "as k is not always 1"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "can it be done using min priority queue ??\\n"
                    },
                    {
                        "username": "Dhairya_Vardhan_Chauhan",
                        "content": "very simple problem coz of constraints"
                    },
                    {
                        "username": "codedreamer911",
                        "content": "Is the distribution continuous or it may be random"
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "it can be random too as they didn\\'t mention it should not be, and the first example can explain it"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Thought, it would be solved using greedy approach by sorting and all at first glance. But that\\'s not the case. "
                    },
                    {
                        "username": "ixeridium",
                        "content": "Just wondering what would happen if you went into an interview and said, that all the exact dp and backtrack solutions would not scale because of exponential complexity and that a greedy approach is fast, typically good enough in practice and hence should be used here."
                    },
                    {
                        "username": "coder_birappan",
                        "content": "Can anyone pls tell for lager N what should we do....we cant use backtracking so how we solve?"
                    },
                    {
                        "username": "21Cash",
                        "content": "Guyz read the constraints carefully, my dumbass read them wrong and i was perplexed thinking how can we solve this with the cookies.leng <= 10^5, its cookies[i] <= 10^5"
                    },
                    {
                        "username": "Ganes123",
                        "content": "Can anyone provide with the contradictory example ,\nWhen actually greedy fails for the above problem?"
                    },
                    {
                        "username": "nikhilnyalakanti2003",
                        "content": "[@bparanj](/bparanj) how is 12 better than 10?"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@bparanj](/bparanj)  this is wrong tho? the minimum unfairness is 10-8=2 while 12-6=6"
                    },
                    {
                        "username": "bparanj",
                        "content": "A simple scenario where a greedy approach could fail in this problem would be the following:\\n\\nSuppose we have `cookies = [5, 10, 2]` and `k = 2`.\\n\\nThe greedy approach would be to always give the largest available cookie to the child who currently has the least total cookies. This means we first give cookie 10 to child 1 (cookies now: child 1 = 10, child 2 = 0), then cookie 5 to child 2 (cookies now: child 1 = 10, child 2 = 5), and finally cookie 2 to child 2 (cookies now: child 1 = 10, child 2 = 7).\\n\\nSo the maximum number of cookies any child has (the unfairness) is 10. But we could do better.\\n\\nInstead, if we distributed the cookies like this: first give cookie 10 to child 1, then cookie 5 to child 2, and then cookie 2 to child 1 (cookies now: child 1 = 12, child 2 = 5), the maximum number of cookies any child has is 12, which is worse than the greedy solution.\\n\\nHowever, if we distributed the cookies like this: first give cookie 5 to child 1, then cookie 2 to child 1 (cookies now: child 1 = 7, child 2 = 0), and finally cookie 10 to child 2 (cookies now: child 1 = 7, child 2 = 10), the maximum number of cookies any child has is only 10, which is equal to the greedy solution and doesn\\'t demonstrate the failure of the greedy approach.\\n\\nThus, to demonstrate the failure of the greedy approach, let\\'s add a fourth cookie: `cookies = [5, 10, 2, 1]` and `k = 2`.\\n\\nNow, if we distributed the cookies like this: first give cookie 10 to child 1, then cookie 5 to child 2, then cookie 2 to child 2, and finally cookie 1 to child 2 (cookies now: child 1 = 10, child 2 = 8), the maximum number of cookies any child has is 10.\\n\\nHowever, the optimal distribution is: first give cookie 10 to child 1, then cookie 5 to child 2, then cookie 2 to child 1, and finally cookie 1 to child 2 (cookies now: child 1 = 12, child 2 = 6), the maximum number of cookies any child has is 12, which is better than the greedy solution. Hence, this example demonstrates a case where the greedy approach fails to find the optimal solution."
                    },
                    {
                        "username": "ixeridium",
                        "content": "Maybe [3,3,2,2,2] and k= 2. If a greedy algorithm distributed the two bags with three cookies to each of the two kids first, then one would end up with a distribution [3,2,2] and [3,2], instead of the optimal solution [3,3] and [2,2,2]. This assumes of course that the greedy algorithm distributes the largest bags first."
                    },
                    {
                        "username": "CodeFact",
                        "content": "All the cookies in the same bag must go to the same child and cannot be split up.     what it means ?"
                    },
                    {
                        "username": "las1_uchiha",
                        "content": "it means arr[i] cannot be split up; should be taken as a whole"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Why i\\'m so dumb!"
                    }
                ]
            },
            {
                "id": 1951151,
                "content": [
                    {
                        "username": "dumb_me",
                        "content": "i think we will get backtracking questions this week \\uD83E\\uDD74\\uD83E\\uDD74"
                    },
                    {
                        "username": "CoolBud",
                        "content": "Just an addon. How do we solve it if the k was a big value."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Tip: k<sup>n</sup> is OK."
                    },
                    {
                        "username": "emilmohan24",
                        "content": "Really. You would get 8^8 operations in worst case , given the constraints of the problem. "
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Try to think from the cookies\\' perspective, not from the children\\'s. Don\\'t make my mistake."
                    },
                    {
                        "username": "marco_seven",
                        "content": "can anyone explain this question please"
                    },
                    {
                        "username": "bparanj",
                        "content": "## Abstract Representation of the Problem\\n\\nLet\\'s present this problem in a more abstract way:\\n\\nYou have an array of integers where each integer represents a quantity grouped together. You\\'re also given another integer which represents the number of distinct groups you have to distribute these quantities into. Each quantity must belong to a single group entirely and cannot be divided.\\n\\nThe disparity of a distribution is defined as the maximum total quantity of a single group in the distribution.\\n\\nYour task is to find the minimum disparity possible in all possible distributions.\\n\\nConstraints:\\n\\n- The array has a length between 2 and 8 (inclusive)\\n- Each element in the array is between 1 and 105 (inclusive)\\n- The number of groups is between 2 and the length of the array (inclusive)\\n"
                    },
                    {
                        "username": "ixeridium",
                        "content": "Maybe easier to understand is the following equivalent problem: You have k computers  to run a list of jobs. Each job must run entirely on a single computer. The array cookies contains the duration of each job. You must find a distribution of the jobs, where the last job finishes as early as possible."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "let\\'s start warriors"
                    },
                    {
                        "username": "hbhutta",
                        "content": "Do we have to use DP here? I\\'ve not very familiar with DP or greedy. I just tried this following approach and I fail a test case:\\n\\nMy approach:\\n1. Find total number of cookies $T$\\n2. Return $\\\\frac{T}{k} + T \\\\text{ (mod } k)$\\n\\nWhy do I fail for this test case:\\n$\\\\text{arr} = [20, 13, 18], k = 2$\\nI am returning 26, because we can do $(26, 25)$ as our distribution but the expected answer is 31. Can someone explain why 31 is better than 26?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@AllenJue](/AllenJue) That makes sense, I think I understand now, thanks."
                    },
                    {
                        "username": "AllenJue",
                        "content": "You can\\'t split the bags. So the optimal would we [20], [13, 18]. You don\\'t need greedy or DP. solved with just backtracking."
                    },
                    {
                        "username": "Ved07",
                        "content": "A new Beginning!"
                    },
                    {
                        "username": "hydra324",
                        "content": "Mind the constraints and you\\'ll get an idea!"
                    },
                    {
                        "username": "vin36",
                        "content": "Is it just me or is testcase 38/38 empty?"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "testcase can\\'t be empty.\\nIt\\'s a glitch, optimize more."
                    }
                ]
            },
            {
                "id": 1951150,
                "content": [
                    {
                        "username": "dumb_me",
                        "content": "i think we will get backtracking questions this week \\uD83E\\uDD74\\uD83E\\uDD74"
                    },
                    {
                        "username": "CoolBud",
                        "content": "Just an addon. How do we solve it if the k was a big value."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Tip: k<sup>n</sup> is OK."
                    },
                    {
                        "username": "emilmohan24",
                        "content": "Really. You would get 8^8 operations in worst case , given the constraints of the problem. "
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Try to think from the cookies\\' perspective, not from the children\\'s. Don\\'t make my mistake."
                    },
                    {
                        "username": "marco_seven",
                        "content": "can anyone explain this question please"
                    },
                    {
                        "username": "bparanj",
                        "content": "## Abstract Representation of the Problem\\n\\nLet\\'s present this problem in a more abstract way:\\n\\nYou have an array of integers where each integer represents a quantity grouped together. You\\'re also given another integer which represents the number of distinct groups you have to distribute these quantities into. Each quantity must belong to a single group entirely and cannot be divided.\\n\\nThe disparity of a distribution is defined as the maximum total quantity of a single group in the distribution.\\n\\nYour task is to find the minimum disparity possible in all possible distributions.\\n\\nConstraints:\\n\\n- The array has a length between 2 and 8 (inclusive)\\n- Each element in the array is between 1 and 105 (inclusive)\\n- The number of groups is between 2 and the length of the array (inclusive)\\n"
                    },
                    {
                        "username": "ixeridium",
                        "content": "Maybe easier to understand is the following equivalent problem: You have k computers  to run a list of jobs. Each job must run entirely on a single computer. The array cookies contains the duration of each job. You must find a distribution of the jobs, where the last job finishes as early as possible."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "let\\'s start warriors"
                    },
                    {
                        "username": "hbhutta",
                        "content": "Do we have to use DP here? I\\'ve not very familiar with DP or greedy. I just tried this following approach and I fail a test case:\\n\\nMy approach:\\n1. Find total number of cookies $T$\\n2. Return $\\\\frac{T}{k} + T \\\\text{ (mod } k)$\\n\\nWhy do I fail for this test case:\\n$\\\\text{arr} = [20, 13, 18], k = 2$\\nI am returning 26, because we can do $(26, 25)$ as our distribution but the expected answer is 31. Can someone explain why 31 is better than 26?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@AllenJue](/AllenJue) That makes sense, I think I understand now, thanks."
                    },
                    {
                        "username": "AllenJue",
                        "content": "You can\\'t split the bags. So the optimal would we [20], [13, 18]. You don\\'t need greedy or DP. solved with just backtracking."
                    },
                    {
                        "username": "Ved07",
                        "content": "A new Beginning!"
                    },
                    {
                        "username": "hydra324",
                        "content": "Mind the constraints and you\\'ll get an idea!"
                    },
                    {
                        "username": "vin36",
                        "content": "Is it just me or is testcase 38/38 empty?"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "testcase can\\'t be empty.\\nIt\\'s a glitch, optimize more."
                    }
                ]
            },
            {
                "id": 1951122,
                "content": [
                    {
                        "username": "dumb_me",
                        "content": "i think we will get backtracking questions this week \\uD83E\\uDD74\\uD83E\\uDD74"
                    },
                    {
                        "username": "CoolBud",
                        "content": "Just an addon. How do we solve it if the k was a big value."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Tip: k<sup>n</sup> is OK."
                    },
                    {
                        "username": "emilmohan24",
                        "content": "Really. You would get 8^8 operations in worst case , given the constraints of the problem. "
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Try to think from the cookies\\' perspective, not from the children\\'s. Don\\'t make my mistake."
                    },
                    {
                        "username": "marco_seven",
                        "content": "can anyone explain this question please"
                    },
                    {
                        "username": "bparanj",
                        "content": "## Abstract Representation of the Problem\\n\\nLet\\'s present this problem in a more abstract way:\\n\\nYou have an array of integers where each integer represents a quantity grouped together. You\\'re also given another integer which represents the number of distinct groups you have to distribute these quantities into. Each quantity must belong to a single group entirely and cannot be divided.\\n\\nThe disparity of a distribution is defined as the maximum total quantity of a single group in the distribution.\\n\\nYour task is to find the minimum disparity possible in all possible distributions.\\n\\nConstraints:\\n\\n- The array has a length between 2 and 8 (inclusive)\\n- Each element in the array is between 1 and 105 (inclusive)\\n- The number of groups is between 2 and the length of the array (inclusive)\\n"
                    },
                    {
                        "username": "ixeridium",
                        "content": "Maybe easier to understand is the following equivalent problem: You have k computers  to run a list of jobs. Each job must run entirely on a single computer. The array cookies contains the duration of each job. You must find a distribution of the jobs, where the last job finishes as early as possible."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "let\\'s start warriors"
                    },
                    {
                        "username": "hbhutta",
                        "content": "Do we have to use DP here? I\\'ve not very familiar with DP or greedy. I just tried this following approach and I fail a test case:\\n\\nMy approach:\\n1. Find total number of cookies $T$\\n2. Return $\\\\frac{T}{k} + T \\\\text{ (mod } k)$\\n\\nWhy do I fail for this test case:\\n$\\\\text{arr} = [20, 13, 18], k = 2$\\nI am returning 26, because we can do $(26, 25)$ as our distribution but the expected answer is 31. Can someone explain why 31 is better than 26?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@AllenJue](/AllenJue) That makes sense, I think I understand now, thanks."
                    },
                    {
                        "username": "AllenJue",
                        "content": "You can\\'t split the bags. So the optimal would we [20], [13, 18]. You don\\'t need greedy or DP. solved with just backtracking."
                    },
                    {
                        "username": "Ved07",
                        "content": "A new Beginning!"
                    },
                    {
                        "username": "hydra324",
                        "content": "Mind the constraints and you\\'ll get an idea!"
                    },
                    {
                        "username": "vin36",
                        "content": "Is it just me or is testcase 38/38 empty?"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "testcase can\\'t be empty.\\nIt\\'s a glitch, optimize more."
                    }
                ]
            },
            {
                "id": 1951115,
                "content": [
                    {
                        "username": "dumb_me",
                        "content": "i think we will get backtracking questions this week \\uD83E\\uDD74\\uD83E\\uDD74"
                    },
                    {
                        "username": "CoolBud",
                        "content": "Just an addon. How do we solve it if the k was a big value."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Tip: k<sup>n</sup> is OK."
                    },
                    {
                        "username": "emilmohan24",
                        "content": "Really. You would get 8^8 operations in worst case , given the constraints of the problem. "
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Try to think from the cookies\\' perspective, not from the children\\'s. Don\\'t make my mistake."
                    },
                    {
                        "username": "marco_seven",
                        "content": "can anyone explain this question please"
                    },
                    {
                        "username": "bparanj",
                        "content": "## Abstract Representation of the Problem\\n\\nLet\\'s present this problem in a more abstract way:\\n\\nYou have an array of integers where each integer represents a quantity grouped together. You\\'re also given another integer which represents the number of distinct groups you have to distribute these quantities into. Each quantity must belong to a single group entirely and cannot be divided.\\n\\nThe disparity of a distribution is defined as the maximum total quantity of a single group in the distribution.\\n\\nYour task is to find the minimum disparity possible in all possible distributions.\\n\\nConstraints:\\n\\n- The array has a length between 2 and 8 (inclusive)\\n- Each element in the array is between 1 and 105 (inclusive)\\n- The number of groups is between 2 and the length of the array (inclusive)\\n"
                    },
                    {
                        "username": "ixeridium",
                        "content": "Maybe easier to understand is the following equivalent problem: You have k computers  to run a list of jobs. Each job must run entirely on a single computer. The array cookies contains the duration of each job. You must find a distribution of the jobs, where the last job finishes as early as possible."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "let\\'s start warriors"
                    },
                    {
                        "username": "hbhutta",
                        "content": "Do we have to use DP here? I\\'ve not very familiar with DP or greedy. I just tried this following approach and I fail a test case:\\n\\nMy approach:\\n1. Find total number of cookies $T$\\n2. Return $\\\\frac{T}{k} + T \\\\text{ (mod } k)$\\n\\nWhy do I fail for this test case:\\n$\\\\text{arr} = [20, 13, 18], k = 2$\\nI am returning 26, because we can do $(26, 25)$ as our distribution but the expected answer is 31. Can someone explain why 31 is better than 26?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@AllenJue](/AllenJue) That makes sense, I think I understand now, thanks."
                    },
                    {
                        "username": "AllenJue",
                        "content": "You can\\'t split the bags. So the optimal would we [20], [13, 18]. You don\\'t need greedy or DP. solved with just backtracking."
                    },
                    {
                        "username": "Ved07",
                        "content": "A new Beginning!"
                    },
                    {
                        "username": "hydra324",
                        "content": "Mind the constraints and you\\'ll get an idea!"
                    },
                    {
                        "username": "vin36",
                        "content": "Is it just me or is testcase 38/38 empty?"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "testcase can\\'t be empty.\\nIt\\'s a glitch, optimize more."
                    }
                ]
            },
            {
                "id": 1951091,
                "content": [
                    {
                        "username": "dumb_me",
                        "content": "i think we will get backtracking questions this week \\uD83E\\uDD74\\uD83E\\uDD74"
                    },
                    {
                        "username": "CoolBud",
                        "content": "Just an addon. How do we solve it if the k was a big value."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Tip: k<sup>n</sup> is OK."
                    },
                    {
                        "username": "emilmohan24",
                        "content": "Really. You would get 8^8 operations in worst case , given the constraints of the problem. "
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Try to think from the cookies\\' perspective, not from the children\\'s. Don\\'t make my mistake."
                    },
                    {
                        "username": "marco_seven",
                        "content": "can anyone explain this question please"
                    },
                    {
                        "username": "bparanj",
                        "content": "## Abstract Representation of the Problem\\n\\nLet\\'s present this problem in a more abstract way:\\n\\nYou have an array of integers where each integer represents a quantity grouped together. You\\'re also given another integer which represents the number of distinct groups you have to distribute these quantities into. Each quantity must belong to a single group entirely and cannot be divided.\\n\\nThe disparity of a distribution is defined as the maximum total quantity of a single group in the distribution.\\n\\nYour task is to find the minimum disparity possible in all possible distributions.\\n\\nConstraints:\\n\\n- The array has a length between 2 and 8 (inclusive)\\n- Each element in the array is between 1 and 105 (inclusive)\\n- The number of groups is between 2 and the length of the array (inclusive)\\n"
                    },
                    {
                        "username": "ixeridium",
                        "content": "Maybe easier to understand is the following equivalent problem: You have k computers  to run a list of jobs. Each job must run entirely on a single computer. The array cookies contains the duration of each job. You must find a distribution of the jobs, where the last job finishes as early as possible."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "let\\'s start warriors"
                    },
                    {
                        "username": "hbhutta",
                        "content": "Do we have to use DP here? I\\'ve not very familiar with DP or greedy. I just tried this following approach and I fail a test case:\\n\\nMy approach:\\n1. Find total number of cookies $T$\\n2. Return $\\\\frac{T}{k} + T \\\\text{ (mod } k)$\\n\\nWhy do I fail for this test case:\\n$\\\\text{arr} = [20, 13, 18], k = 2$\\nI am returning 26, because we can do $(26, 25)$ as our distribution but the expected answer is 31. Can someone explain why 31 is better than 26?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@AllenJue](/AllenJue) That makes sense, I think I understand now, thanks."
                    },
                    {
                        "username": "AllenJue",
                        "content": "You can\\'t split the bags. So the optimal would we [20], [13, 18]. You don\\'t need greedy or DP. solved with just backtracking."
                    },
                    {
                        "username": "Ved07",
                        "content": "A new Beginning!"
                    },
                    {
                        "username": "hydra324",
                        "content": "Mind the constraints and you\\'ll get an idea!"
                    },
                    {
                        "username": "vin36",
                        "content": "Is it just me or is testcase 38/38 empty?"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "testcase can\\'t be empty.\\nIt\\'s a glitch, optimize more."
                    }
                ]
            },
            {
                "id": 1951067,
                "content": [
                    {
                        "username": "dumb_me",
                        "content": "i think we will get backtracking questions this week \\uD83E\\uDD74\\uD83E\\uDD74"
                    },
                    {
                        "username": "CoolBud",
                        "content": "Just an addon. How do we solve it if the k was a big value."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Tip: k<sup>n</sup> is OK."
                    },
                    {
                        "username": "emilmohan24",
                        "content": "Really. You would get 8^8 operations in worst case , given the constraints of the problem. "
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Try to think from the cookies\\' perspective, not from the children\\'s. Don\\'t make my mistake."
                    },
                    {
                        "username": "marco_seven",
                        "content": "can anyone explain this question please"
                    },
                    {
                        "username": "bparanj",
                        "content": "## Abstract Representation of the Problem\\n\\nLet\\'s present this problem in a more abstract way:\\n\\nYou have an array of integers where each integer represents a quantity grouped together. You\\'re also given another integer which represents the number of distinct groups you have to distribute these quantities into. Each quantity must belong to a single group entirely and cannot be divided.\\n\\nThe disparity of a distribution is defined as the maximum total quantity of a single group in the distribution.\\n\\nYour task is to find the minimum disparity possible in all possible distributions.\\n\\nConstraints:\\n\\n- The array has a length between 2 and 8 (inclusive)\\n- Each element in the array is between 1 and 105 (inclusive)\\n- The number of groups is between 2 and the length of the array (inclusive)\\n"
                    },
                    {
                        "username": "ixeridium",
                        "content": "Maybe easier to understand is the following equivalent problem: You have k computers  to run a list of jobs. Each job must run entirely on a single computer. The array cookies contains the duration of each job. You must find a distribution of the jobs, where the last job finishes as early as possible."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "let\\'s start warriors"
                    },
                    {
                        "username": "hbhutta",
                        "content": "Do we have to use DP here? I\\'ve not very familiar with DP or greedy. I just tried this following approach and I fail a test case:\\n\\nMy approach:\\n1. Find total number of cookies $T$\\n2. Return $\\\\frac{T}{k} + T \\\\text{ (mod } k)$\\n\\nWhy do I fail for this test case:\\n$\\\\text{arr} = [20, 13, 18], k = 2$\\nI am returning 26, because we can do $(26, 25)$ as our distribution but the expected answer is 31. Can someone explain why 31 is better than 26?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@AllenJue](/AllenJue) That makes sense, I think I understand now, thanks."
                    },
                    {
                        "username": "AllenJue",
                        "content": "You can\\'t split the bags. So the optimal would we [20], [13, 18]. You don\\'t need greedy or DP. solved with just backtracking."
                    },
                    {
                        "username": "Ved07",
                        "content": "A new Beginning!"
                    },
                    {
                        "username": "hydra324",
                        "content": "Mind the constraints and you\\'ll get an idea!"
                    },
                    {
                        "username": "vin36",
                        "content": "Is it just me or is testcase 38/38 empty?"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "testcase can\\'t be empty.\\nIt\\'s a glitch, optimize more."
                    }
                ]
            },
            {
                "id": 1951061,
                "content": [
                    {
                        "username": "dumb_me",
                        "content": "i think we will get backtracking questions this week \\uD83E\\uDD74\\uD83E\\uDD74"
                    },
                    {
                        "username": "CoolBud",
                        "content": "Just an addon. How do we solve it if the k was a big value."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Tip: k<sup>n</sup> is OK."
                    },
                    {
                        "username": "emilmohan24",
                        "content": "Really. You would get 8^8 operations in worst case , given the constraints of the problem. "
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Try to think from the cookies\\' perspective, not from the children\\'s. Don\\'t make my mistake."
                    },
                    {
                        "username": "marco_seven",
                        "content": "can anyone explain this question please"
                    },
                    {
                        "username": "bparanj",
                        "content": "## Abstract Representation of the Problem\\n\\nLet\\'s present this problem in a more abstract way:\\n\\nYou have an array of integers where each integer represents a quantity grouped together. You\\'re also given another integer which represents the number of distinct groups you have to distribute these quantities into. Each quantity must belong to a single group entirely and cannot be divided.\\n\\nThe disparity of a distribution is defined as the maximum total quantity of a single group in the distribution.\\n\\nYour task is to find the minimum disparity possible in all possible distributions.\\n\\nConstraints:\\n\\n- The array has a length between 2 and 8 (inclusive)\\n- Each element in the array is between 1 and 105 (inclusive)\\n- The number of groups is between 2 and the length of the array (inclusive)\\n"
                    },
                    {
                        "username": "ixeridium",
                        "content": "Maybe easier to understand is the following equivalent problem: You have k computers  to run a list of jobs. Each job must run entirely on a single computer. The array cookies contains the duration of each job. You must find a distribution of the jobs, where the last job finishes as early as possible."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "let\\'s start warriors"
                    },
                    {
                        "username": "hbhutta",
                        "content": "Do we have to use DP here? I\\'ve not very familiar with DP or greedy. I just tried this following approach and I fail a test case:\\n\\nMy approach:\\n1. Find total number of cookies $T$\\n2. Return $\\\\frac{T}{k} + T \\\\text{ (mod } k)$\\n\\nWhy do I fail for this test case:\\n$\\\\text{arr} = [20, 13, 18], k = 2$\\nI am returning 26, because we can do $(26, 25)$ as our distribution but the expected answer is 31. Can someone explain why 31 is better than 26?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@AllenJue](/AllenJue) That makes sense, I think I understand now, thanks."
                    },
                    {
                        "username": "AllenJue",
                        "content": "You can\\'t split the bags. So the optimal would we [20], [13, 18]. You don\\'t need greedy or DP. solved with just backtracking."
                    },
                    {
                        "username": "Ved07",
                        "content": "A new Beginning!"
                    },
                    {
                        "username": "hydra324",
                        "content": "Mind the constraints and you\\'ll get an idea!"
                    },
                    {
                        "username": "vin36",
                        "content": "Is it just me or is testcase 38/38 empty?"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "testcase can\\'t be empty.\\nIt\\'s a glitch, optimize more."
                    }
                ]
            },
            {
                "id": 1951048,
                "content": [
                    {
                        "username": "dumb_me",
                        "content": "i think we will get backtracking questions this week \\uD83E\\uDD74\\uD83E\\uDD74"
                    },
                    {
                        "username": "CoolBud",
                        "content": "Just an addon. How do we solve it if the k was a big value."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Tip: k<sup>n</sup> is OK."
                    },
                    {
                        "username": "emilmohan24",
                        "content": "Really. You would get 8^8 operations in worst case , given the constraints of the problem. "
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Try to think from the cookies\\' perspective, not from the children\\'s. Don\\'t make my mistake."
                    },
                    {
                        "username": "marco_seven",
                        "content": "can anyone explain this question please"
                    },
                    {
                        "username": "bparanj",
                        "content": "## Abstract Representation of the Problem\\n\\nLet\\'s present this problem in a more abstract way:\\n\\nYou have an array of integers where each integer represents a quantity grouped together. You\\'re also given another integer which represents the number of distinct groups you have to distribute these quantities into. Each quantity must belong to a single group entirely and cannot be divided.\\n\\nThe disparity of a distribution is defined as the maximum total quantity of a single group in the distribution.\\n\\nYour task is to find the minimum disparity possible in all possible distributions.\\n\\nConstraints:\\n\\n- The array has a length between 2 and 8 (inclusive)\\n- Each element in the array is between 1 and 105 (inclusive)\\n- The number of groups is between 2 and the length of the array (inclusive)\\n"
                    },
                    {
                        "username": "ixeridium",
                        "content": "Maybe easier to understand is the following equivalent problem: You have k computers  to run a list of jobs. Each job must run entirely on a single computer. The array cookies contains the duration of each job. You must find a distribution of the jobs, where the last job finishes as early as possible."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "let\\'s start warriors"
                    },
                    {
                        "username": "hbhutta",
                        "content": "Do we have to use DP here? I\\'ve not very familiar with DP or greedy. I just tried this following approach and I fail a test case:\\n\\nMy approach:\\n1. Find total number of cookies $T$\\n2. Return $\\\\frac{T}{k} + T \\\\text{ (mod } k)$\\n\\nWhy do I fail for this test case:\\n$\\\\text{arr} = [20, 13, 18], k = 2$\\nI am returning 26, because we can do $(26, 25)$ as our distribution but the expected answer is 31. Can someone explain why 31 is better than 26?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@AllenJue](/AllenJue) That makes sense, I think I understand now, thanks."
                    },
                    {
                        "username": "AllenJue",
                        "content": "You can\\'t split the bags. So the optimal would we [20], [13, 18]. You don\\'t need greedy or DP. solved with just backtracking."
                    },
                    {
                        "username": "Ved07",
                        "content": "A new Beginning!"
                    },
                    {
                        "username": "hydra324",
                        "content": "Mind the constraints and you\\'ll get an idea!"
                    },
                    {
                        "username": "vin36",
                        "content": "Is it just me or is testcase 38/38 empty?"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "testcase can\\'t be empty.\\nIt\\'s a glitch, optimize more."
                    }
                ]
            },
            {
                "id": 1951029,
                "content": [
                    {
                        "username": "dumb_me",
                        "content": "i think we will get backtracking questions this week \\uD83E\\uDD74\\uD83E\\uDD74"
                    },
                    {
                        "username": "CoolBud",
                        "content": "Just an addon. How do we solve it if the k was a big value."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Tip: k<sup>n</sup> is OK."
                    },
                    {
                        "username": "emilmohan24",
                        "content": "Really. You would get 8^8 operations in worst case , given the constraints of the problem. "
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Try to think from the cookies\\' perspective, not from the children\\'s. Don\\'t make my mistake."
                    },
                    {
                        "username": "marco_seven",
                        "content": "can anyone explain this question please"
                    },
                    {
                        "username": "bparanj",
                        "content": "## Abstract Representation of the Problem\\n\\nLet\\'s present this problem in a more abstract way:\\n\\nYou have an array of integers where each integer represents a quantity grouped together. You\\'re also given another integer which represents the number of distinct groups you have to distribute these quantities into. Each quantity must belong to a single group entirely and cannot be divided.\\n\\nThe disparity of a distribution is defined as the maximum total quantity of a single group in the distribution.\\n\\nYour task is to find the minimum disparity possible in all possible distributions.\\n\\nConstraints:\\n\\n- The array has a length between 2 and 8 (inclusive)\\n- Each element in the array is between 1 and 105 (inclusive)\\n- The number of groups is between 2 and the length of the array (inclusive)\\n"
                    },
                    {
                        "username": "ixeridium",
                        "content": "Maybe easier to understand is the following equivalent problem: You have k computers  to run a list of jobs. Each job must run entirely on a single computer. The array cookies contains the duration of each job. You must find a distribution of the jobs, where the last job finishes as early as possible."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "let\\'s start warriors"
                    },
                    {
                        "username": "hbhutta",
                        "content": "Do we have to use DP here? I\\'ve not very familiar with DP or greedy. I just tried this following approach and I fail a test case:\\n\\nMy approach:\\n1. Find total number of cookies $T$\\n2. Return $\\\\frac{T}{k} + T \\\\text{ (mod } k)$\\n\\nWhy do I fail for this test case:\\n$\\\\text{arr} = [20, 13, 18], k = 2$\\nI am returning 26, because we can do $(26, 25)$ as our distribution but the expected answer is 31. Can someone explain why 31 is better than 26?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@AllenJue](/AllenJue) That makes sense, I think I understand now, thanks."
                    },
                    {
                        "username": "AllenJue",
                        "content": "You can\\'t split the bags. So the optimal would we [20], [13, 18]. You don\\'t need greedy or DP. solved with just backtracking."
                    },
                    {
                        "username": "Ved07",
                        "content": "A new Beginning!"
                    },
                    {
                        "username": "hydra324",
                        "content": "Mind the constraints and you\\'ll get an idea!"
                    },
                    {
                        "username": "vin36",
                        "content": "Is it just me or is testcase 38/38 empty?"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "testcase can\\'t be empty.\\nIt\\'s a glitch, optimize more."
                    }
                ]
            },
            {
                "id": 1951023,
                "content": [
                    {
                        "username": "dumb_me",
                        "content": "i think we will get backtracking questions this week \\uD83E\\uDD74\\uD83E\\uDD74"
                    },
                    {
                        "username": "CoolBud",
                        "content": "Just an addon. How do we solve it if the k was a big value."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Tip: k<sup>n</sup> is OK."
                    },
                    {
                        "username": "emilmohan24",
                        "content": "Really. You would get 8^8 operations in worst case , given the constraints of the problem. "
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Try to think from the cookies\\' perspective, not from the children\\'s. Don\\'t make my mistake."
                    },
                    {
                        "username": "marco_seven",
                        "content": "can anyone explain this question please"
                    },
                    {
                        "username": "bparanj",
                        "content": "## Abstract Representation of the Problem\\n\\nLet\\'s present this problem in a more abstract way:\\n\\nYou have an array of integers where each integer represents a quantity grouped together. You\\'re also given another integer which represents the number of distinct groups you have to distribute these quantities into. Each quantity must belong to a single group entirely and cannot be divided.\\n\\nThe disparity of a distribution is defined as the maximum total quantity of a single group in the distribution.\\n\\nYour task is to find the minimum disparity possible in all possible distributions.\\n\\nConstraints:\\n\\n- The array has a length between 2 and 8 (inclusive)\\n- Each element in the array is between 1 and 105 (inclusive)\\n- The number of groups is between 2 and the length of the array (inclusive)\\n"
                    },
                    {
                        "username": "ixeridium",
                        "content": "Maybe easier to understand is the following equivalent problem: You have k computers  to run a list of jobs. Each job must run entirely on a single computer. The array cookies contains the duration of each job. You must find a distribution of the jobs, where the last job finishes as early as possible."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "let\\'s start warriors"
                    },
                    {
                        "username": "hbhutta",
                        "content": "Do we have to use DP here? I\\'ve not very familiar with DP or greedy. I just tried this following approach and I fail a test case:\\n\\nMy approach:\\n1. Find total number of cookies $T$\\n2. Return $\\\\frac{T}{k} + T \\\\text{ (mod } k)$\\n\\nWhy do I fail for this test case:\\n$\\\\text{arr} = [20, 13, 18], k = 2$\\nI am returning 26, because we can do $(26, 25)$ as our distribution but the expected answer is 31. Can someone explain why 31 is better than 26?\\n"
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@AllenJue](/AllenJue) That makes sense, I think I understand now, thanks."
                    },
                    {
                        "username": "AllenJue",
                        "content": "You can\\'t split the bags. So the optimal would we [20], [13, 18]. You don\\'t need greedy or DP. solved with just backtracking."
                    },
                    {
                        "username": "Ved07",
                        "content": "A new Beginning!"
                    },
                    {
                        "username": "hydra324",
                        "content": "Mind the constraints and you\\'ll get an idea!"
                    },
                    {
                        "username": "vin36",
                        "content": "Is it just me or is testcase 38/38 empty?"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "testcase can\\'t be empty.\\nIt\\'s a glitch, optimize more."
                    }
                ]
            }
        ]
    }
]