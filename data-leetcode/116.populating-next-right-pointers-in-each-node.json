[
    {
        "title": "3Sum Closest",
        "question_content": "Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.\nReturn the sum of the three integers.\nYou may assume that each input would have exactly one solution.\n&nbsp;\nExample 1:\n\nInput: nums = [-1,2,1,-4], target = 1\nOutput: 2\nExplanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\n\nExample 2:\n\nInput: nums = [0,0,0], target = 1\nOutput: 0\nExplanation: The sum that is closest to the target is 0. (0 + 0 + 0 = 0).\n\n&nbsp;\nConstraints:\n\n\t3 <= nums.length <= 500\n\t-1000 <= nums[i] <= 1000\n\t-104 <= target <= 104",
        "solutions": [
            {
                "id": 7883,
                "title": "c-solution-o-n-2-using-sort",
                "content": "Sort the vector and then no need to run *O(N^3)* algorithm as each index has a direction to move.\\n\\nThe code starts from this formation.\\n\\n    ----------------------------------------------------\\n    ^  ^                                               ^\\n    |  |                                               |\\n    |  +- second                                     third\\n    +-first\\n\\nif  *nums[first] + nums[second] + nums[third]* is smaller than the *target*, we know we have to increase the sum. so only choice is moving the second index forward.\\n\\n    ----------------------------------------------------\\n    ^    ^                                             ^\\n    |    |                                             |\\n    |    +- second                                   third\\n    +-first\\n\\n\\nif the *sum* is bigger than the *target*, we know that we need to reduce the *sum*. so only choice is moving '*third*' to backward. of course if the *sum* equals to *target*, we can immediately return the *sum*.\\n\\n    ----------------------------------------------------\\n    ^    ^                                          ^\\n    |    |                                          |\\n    |    +- second                                third\\n    +-first\\n\\n\\nwhen *second* and *third* cross, the round is done so start next round by moving '*first*' and resetting *second* and *third*.\\n\\n    ----------------------------------------------------\\n      ^    ^                                           ^\\n      |    |                                           |\\n      |    +- second                                 third\\n      +-first\\n\\nwhile doing this, collect the *closest sum* of each stage by calculating and comparing delta. Compare *abs(target-newSum)* and *abs(target-closest)*. At the end of the process the three indexes will eventually be gathered at the end of the array.\\n\\n    ----------------------------------------------------\\n                                             ^    ^    ^\\n                                             |    |    `- third\\n                                             |    +- second\\n                                             +-first\\n\\nif no exactly matching *sum* has been found so far, the value in *closest* will be the answer.\\n\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        if(nums.size() < 3) return 0;\\n        int closest = nums[0]+nums[1]+nums[2];\\n        sort(nums.begin(), nums.end());\\n        for(int first = 0 ; first < nums.size()-2 ; ++first) {\\n            if(first > 0 && nums[first] == nums[first-1]) continue;\\n            int second = first+1;\\n            int third = nums.size()-1;            \\n            while(second < third) {\\n                int curSum = nums[first]+nums[second]+nums[third];\\n                if(curSum == target) return curSum;\\n                if(abs(target-curSum)<abs(target-closest)) {\\n                    closest = curSum;\\n                }\\n                if(curSum > target) {\\n                    --third;\\n                } else {\\n                    ++second;\\n                }\\n            }\\n        }\\n        return closest;\\n    }",
                "solutionTags": [],
                "code": "Sort the vector and then no need to run *O(N^3)* algorithm as each index has a direction to move.\\n\\nThe code starts from this formation.\\n\\n    ----------------------------------------------------\\n    ^  ^                                               ^\\n    |  |                                               |\\n    |  +- second                                     third\\n    +-first\\n\\nif  *nums[first] + nums[second] + nums[third]* is smaller than the *target*, we know we have to increase the sum. so only choice is moving the second index forward.\\n\\n    ----------------------------------------------------\\n    ^    ^                                             ^\\n    |    |                                             |\\n    |    +- second                                   third\\n    +-first\\n\\n\\nif the *sum* is bigger than the *target*, we know that we need to reduce the *sum*. so only choice is moving '*third*' to backward. of course if the *sum* equals to *target*, we can immediately return the *sum*.\\n\\n    ----------------------------------------------------\\n    ^    ^                                          ^\\n    |    |                                          |\\n    |    +- second                                third\\n    +-first\\n\\n\\nwhen *second* and *third* cross, the round is done so start next round by moving '*first*' and resetting *second* and *third*.\\n\\n    ----------------------------------------------------\\n      ^    ^                                           ^\\n      |    |                                           |\\n      |    +- second                                 third\\n      +-first\\n\\nwhile doing this, collect the *closest sum* of each stage by calculating and comparing delta. Compare *abs(target-newSum)* and *abs(target-closest)*. At the end of the process the three indexes will eventually be gathered at the end of the array.\\n\\n    ----------------------------------------------------\\n                                             ^    ^    ^\\n                                             |    |    `- third\\n                                             |    +- second\\n                                             +-first\\n\\nif no exactly matching *sum* has been found so far, the value in *closest* will be the answer.\\n\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        if(nums.size() < 3) return 0;\\n        int closest = nums[0]+nums[1]+nums[2];\\n        sort(nums.begin(), nums.end());\\n        for(int first = 0 ; first < nums.size()-2 ; ++first) {\\n            if(first > 0 && nums[first] == nums[first-1]) continue;\\n            int second = first+1;\\n            int third = nums.size()-1;            \\n            while(second < third) {\\n                int curSum = nums[first]+nums[second]+nums[third];\\n                if(curSum == target) return curSum;\\n                if(abs(target-curSum)<abs(target-closest)) {\\n                    closest = curSum;\\n                }\\n                if(curSum > target) {\\n                    --third;\\n                } else {\\n                    ++second;\\n                }\\n            }\\n        }\\n        return closest;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 7871,
                "title": "python-o-n-2-solution",
                "content": "    class Solution:\\n        # @return an integer\\n        def threeSumClosest(self, num, target):\\n            num.sort()\\n            result = num[0] + num[1] + num[2]\\n            for i in range(len(num) - 2):\\n                j, k = i+1, len(num) - 1\\n                while j < k:\\n                    sum = num[i] + num[j] + num[k]\\n                    if sum == target:\\n                        return sum\\n                    \\n                    if abs(sum - target) < abs(result - target):\\n                        result = sum\\n                    \\n                    if sum < target:\\n                        j += 1\\n                    elif sum > target:\\n                        k -= 1\\n                \\n            return result",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        # @return an integer\\n        def threeSumClosest(self, num, target):\\n            num.sort()\\n            result = num[0] + num[1] + num[2]\\n            for i in range(len(num) - 2):\\n                j, k = i+1, len(num) - 1\\n                while j < k:\\n                    sum = num[i] + num[j] + num[k]\\n                    if sum == target:\\n                        return sum\\n                    \\n                    if abs(sum - target) < abs(result - target):\\n                        result = sum\\n                    \\n                    if sum < target:\\n                        j += 1\\n                    elif sum > target:\\n                        k -= 1\\n                \\n            return result",
                "codeTag": "Java"
            },
            {
                "id": 7873,
                "title": "a-n-2-solution-can-we-do-better",
                "content": "Here is a solution in Order(N^2). I got help from this post on \\n[stackoverflow][1] <br>\\nCan we improve this time complexity ?\\n\\n    int threeSumClosest(vector<int> &num, int target) {        \\n        vector<int> v(num.begin(), num.end()); // I didn't wanted to disturb original array.\\n        int n = 0;\\n        int ans = 0;\\n        int sum;\\n        \\n        sort(v.begin(), v.end());\\n        \\n        // If less then 3 elements then return their sum\\n        while (v.size() <= 3) {\\n            return accumulate(v.begin(), v.end(), 0);\\n        }\\n        \\n        n = v.size();\\n        \\n        /* v[0] v[1] v[2] ... v[i] .... v[j] ... v[k] ... v[n-2] v[n-1]\\n         *                    v[i]  <=  v[j]  <= v[k] always, because we sorted our array. \\n         * Now, for each number, v[i] : we look for pairs v[j] & v[k] such that \\n         * absolute value of (target - (v[i] + v[j] + v[k]) is minimised.\\n         * if the sum of the triplet is greater then the target it implies\\n         * we need to reduce our sum, so we do K = K - 1, that is we reduce\\n         * our sum by taking a smaller number.\\n         * Simillarly if sum of the triplet is less then the target then we\\n         * increase out sum by taking a larger number, i.e. J = J + 1.\\n         */\\n        ans = v[0] + v[1] + v[2];\\n        for (int i = 0; i < n-2; i++) {\\n            int j = i + 1;\\n            int k = n - 1;\\n            while (j < k) {\\n                sum = v[i] + v[j] + v[k];\\n                if (abs(target - ans) > abs(target - sum)) {\\n                    ans = sum;\\n                    if (ans == target) return ans;\\n                }\\n                (sum > target) ? k-- : j++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n<b>Edit:</b>Thanks @thr for pointing out that. I have corrected it and also renamed 'mx' by 'ans'.\\n  [1]: http://stackoverflow.com/questions/2070359/finding-three-elements-in-an-array-whose-sum-is-closest-to-an-given-number",
                "solutionTags": [],
                "code": "Here is a solution in Order(N^2). I got help from this post on \\n[stackoverflow][1] <br>\\nCan we improve this time complexity ?\\n\\n    int threeSumClosest(vector<int> &num, int target) {        \\n        vector<int> v(num.begin(), num.end()); // I didn't wanted to disturb original array.\\n        int n = 0;\\n        int ans = 0;\\n        int sum;\\n        \\n        sort(v.begin(), v.end());\\n        \\n        // If less then 3 elements then return their sum\\n        while (v.size() <= 3) {\\n            return accumulate(v.begin(), v.end(), 0);\\n        }\\n        \\n        n = v.size();\\n        \\n        /* v[0] v[1] v[2] ... v[i] .... v[j] ... v[k] ... v[n-2] v[n-1]\\n         *                    v[i]  <=  v[j]  <= v[k] always, because we sorted our array. \\n         * Now, for each number, v[i] : we look for pairs v[j] & v[k] such that \\n         * absolute value of (target - (v[i] + v[j] + v[k]) is minimised.\\n         * if the sum of the triplet is greater then the target it implies\\n         * we need to reduce our sum, so we do K = K - 1, that is we reduce\\n         * our sum by taking a smaller number.\\n         * Simillarly if sum of the triplet is less then the target then we\\n         * increase out sum by taking a larger number, i.e. J = J + 1.\\n         */\\n        ans = v[0] + v[1] + v[2];\\n        for (int i = 0; i < n-2; i++) {\\n            int j = i + 1;\\n            int k = n - 1;\\n            while (j < k) {\\n                sum = v[i] + v[j] + v[k];\\n                if (abs(target - ans) > abs(target - sum)) {\\n                    ans = sum;\\n                    if (ans == target) return ans;\\n                }\\n                (sum > target) ? k-- : j++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n<b>Edit:</b>Thanks @thr for pointing out that. I have corrected it and also renamed 'mx' by 'ans'.\\n  [1]: http://stackoverflow.com/questions/2070359/finding-three-elements-in-an-array-whose-sum-is-closest-to-an-given-number",
                "codeTag": "Unknown"
            },
            {
                "id": 8026,
                "title": "python-solution-two-pointer",
                "content": "        \\n    def threeSumClosest(self, nums, target):\\n        nums.sort()\\n        res = sum(nums[:3])\\n        for i in xrange(len(nums)):\\n            l, r = i+1, len(nums)-1\\n            while l < r:\\n                s = sum((nums[i], nums[l], nums[r]))\\n                if abs(s-target) < abs(res-target):\\n                    res = s\\n                if s < target:\\n                    l += 1\\n                elif s > target:\\n                    r -= 1\\n                else: # break early \\n                    return res\\n        return res",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "        \\n    def threeSumClosest(self, nums, target):\\n        nums.sort()\\n        res = sum(nums[:3])\\n        for i in xrange(len(nums)):\\n            l, r = i+1, len(nums)-1\\n            while l < r:\\n                s = sum((nums[i], nums[l], nums[r]))\\n                if abs(s-target) < abs(res-target):\\n                    res = s\\n                if s < target:\\n                    l += 1\\n                elif s > target:\\n                    r -= 1\\n                else: # break early \\n                    return res\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 1042348,
                "title": "faster-solution-about-95-faster-and-easy-solution-with-comments",
                "content": "![image](https://assets.leetcode.com/users/images/9acbb0ae-649b-4891-bdb3-21d55ae09a3e_1612031949.8420494.png)\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());//I am going to use Two pointer for that i\\'m sorting it if you want to use some other approch feel free to do that;\\n        int n=nums.size();\\n\\n        int sum=nums[0]+nums[1]+nums[2];//Our Intial sum or assuption that intial three values are the closet sum\\n        for(int i=0;i<n-2;i++){ //n-2 Since we have taken n-1 in our point so no need to go beyond that\\n            //Implementing Two pointer technique\\n            int j=i+1;\\n            int k=n-1;\\n            while(j<k){\\n                int temp=nums[i]+nums[j]+nums[k];//Temparory sum for comaprison\\n                if(abs(temp-target) < abs(sum-target) ) sum=temp;//if we find batter or closer sum then we update the above sum value\\n                if(temp>target){\\n                    k--;                  // if value is greater than target one just come one point right to left\\n                } else if(temp<target){\\n                    j++;             //if value is lower than target just come one point left to right \\n                    \\n                }else return target;// if value already found no need to go for other just return \\n            }\\n            \\n        }\\n        return sum;\\n    }\\n};\\n```Hey Folk I\\'m using Two Pointer technique technique if you really want to appreciate and fount it batter*** please Up vote Thank You:)***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());//I am going to use Two pointer for that i\\'m sorting it if you want to use some other approch feel free to do that;\\n        int n=nums.size();\\n\\n        int sum=nums[0]+nums[1]+nums[2];//Our Intial sum or assuption that intial three values are the closet sum\\n        for(int i=0;i<n-2;i++){ //n-2 Since we have taken n-1 in our point so no need to go beyond that\\n            //Implementing Two pointer technique\\n            int j=i+1;\\n            int k=n-1;\\n            while(j<k){\\n                int temp=nums[i]+nums[j]+nums[k];//Temparory sum for comaprison\\n                if(abs(temp-target) < abs(sum-target) ) sum=temp;//if we find batter or closer sum then we update the above sum value\\n                if(temp>target){\\n                    k--;                  // if value is greater than target one just come one point right to left\\n                } else if(temp<target){\\n                    j++;             //if value is lower than target just come one point left to right \\n                    \\n                }else return target;// if value already found no need to go for other just return \\n            }\\n            \\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 778177,
                "title": "python3-runtime-52-ms-faster-than-99-77",
                "content": "Easy recursive solution, works for any k, not only for 3\\n\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        return self.KSumClosest(nums, 3, target)\\n\\n    def KSumClosest(self, nums: List[int], k: int, target: int) -> int:\\n        N = len(nums)\\n        if N == k:\\n            return sum(nums[:k])\\n\\n        # target too small\\n        current = sum(nums[:k])\\n        if current >= target:\\n            return current\\n\\n        # target too big\\n        current = sum(nums[-k:])\\n        if current <= target:\\n            return current\\n        \\n        if k == 1:\\n            return min([(x, abs(target - x)) for x in nums], key = lambda x: x[1])[0]\\n\\n        closest = sum(nums[:k])\\n        for i, x in enumerate(nums[:-k+1]):\\n            if i>0 and x == nums[i-1]:\\n                continue\\n            current = self.KSumClosest(nums[i+1:], k-1, target - x) + x\\n            if abs(target - current) < abs(target - closest):\\n                if current == target:\\n                    return target\\n                else:\\n                    closest = current\\n\\n        return closest\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        return self.KSumClosest(nums, 3, target)\\n\\n    def KSumClosest(self, nums: List[int], k: int, target: int) -> int:\\n        N = len(nums)\\n        if N == k:\\n            return sum(nums[:k])\\n\\n        # target too small\\n        current = sum(nums[:k])\\n        if current >= target:\\n            return current\\n\\n        # target too big\\n        current = sum(nums[-k:])\\n        if current <= target:\\n            return current\\n        \\n        if k == 1:\\n            return min([(x, abs(target - x)) for x in nums], key = lambda x: x[1])[0]\\n\\n        closest = sum(nums[:k])\\n        for i, x in enumerate(nums[:-k+1]):\\n            if i>0 and x == nums[i-1]:\\n                continue\\n            current = self.KSumClosest(nums[i+1:], k-1, target - x) + x\\n            if abs(target - current) < abs(target - closest):\\n                if current == target:\\n                    return target\\n                else:\\n                    closest = current\\n\\n        return closest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1365626,
                "title": "c-python-two-pointers-clean-concise",
                "content": "**Idea**\\n- Sort `nums` in increasing order.\\n- Let\\'s fix `nums[i]` by iterating `i` in range `[0..n-2]`, we using 2 pointers to find 2 elements in range `[i+1..n-1]`, so that `nums[i] + nums[l] + nums[r]` will have minimum difference with our `target`.\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        ans = nums[0] + nums[1] + nums[2]\\n        for i in range(n-2):\\n            l, r = i + 1, n - 1\\n            while l < r:\\n                sum3 = nums[i] + nums[l] + nums[r]\\n                if abs(ans - target) > abs(sum3 - target):\\n                    ans = sum3\\n                if sum3 == target: return target\\n                if sum3 > target:\\n                    r -= 1  # Sum3 is greater than the target, to minimize the difference, we have to decrease our sum3\\n                else:\\n                    l += 1  # Sum3 is lesser than the target, to minimize the difference, we have to increase our sum3\\n        return ans\\n```\\n\\n**C++**\\n```c++\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size(), ans = nums[0] + nums[1] + nums[2];\\n        for (int i = 0; i < n-2; ++i) {\\n            int l = i + 1, r = n - 1;\\n            while (l < r) {\\n                int sum3 = nums[i] + nums[l] + nums[r];\\n                if (abs(ans - target) > abs(sum3 - target)) // Update better ans\\n                    ans = sum3;\\n                if (sum3 == target) break;\\n                if (sum3 > target)\\n                    --r; // Sum3 is greater than the target, to minimize the difference, we have to decrease our sum3\\n                else\\n                    ++l; // Sum3 is lesser than the target, to minimize the difference, we have to increase our sum3\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Complexity**\\n- Time: `O(N^2)`, where `N <= 10^3` is number of elements in array `nums`.\\n- Space: from `O(sorting)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        ans = nums[0] + nums[1] + nums[2]\\n        for i in range(n-2):\\n            l, r = i + 1, n - 1\\n            while l < r:\\n                sum3 = nums[i] + nums[l] + nums[r]\\n                if abs(ans - target) > abs(sum3 - target):\\n                    ans = sum3\\n                if sum3 == target: return target\\n                if sum3 > target:\\n                    r -= 1  # Sum3 is greater than the target, to minimize the difference, we have to decrease our sum3\\n                else:\\n                    l += 1  # Sum3 is lesser than the target, to minimize the difference, we have to increase our sum3\\n        return ans\\n```\n```c++\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size(), ans = nums[0] + nums[1] + nums[2];\\n        for (int i = 0; i < n-2; ++i) {\\n            int l = i + 1, r = n - 1;\\n            while (l < r) {\\n                int sum3 = nums[i] + nums[l] + nums[r];\\n                if (abs(ans - target) > abs(sum3 - target)) // Update better ans\\n                    ans = sum3;\\n                if (sum3 == target) break;\\n                if (sum3 > target)\\n                    --r; // Sum3 is greater than the target, to minimize the difference, we have to decrease our sum3\\n                else\\n                    ++l; // Sum3 is lesser than the target, to minimize the difference, we have to increase our sum3\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1147500,
                "title": "accepted-solution-for-swift",
                "content": "<blockquote>\\n<b>Disclaimer:</b> By using any content from this post or thread, you release the author(s) from all liability and warranty of any kind. You are free to use the content freely and as you see fit. Any suggestions for improvement are welcome and greatly appreciated! Happy coding!\\n</blockquote>\\n\\n```swift\\nclass Solution {\\n    func threeSumClosest(_ nums: [Int], _ target: Int) -> Int {\\n        \\n        let sorted = nums.sorted()\\n        let length = sorted.count\\n        \\n        var diff: Int = .max\\n        var result = 0\\n        \\n        for i in 0..<length - 2 {\\n            var n = i + 1, q = length - 1\\n            while n < q {\\n                let sum = sorted[i] + sorted[n] + sorted[q]\\n                \\n                sum > target ? (q -= 1) : (n += 1)\\n                \\n                let value =  abs(sum - target)\\n                \\n                if value < diff {\\n                    diff = value\\n                    result = sum\\n                }\\n            }\\n        }\\n        return result\\n    }\\n}\\n```\\n\\n---\\n\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<pre>\\n<b>Result:</b> Executed 1 test, with 0 failures (0 unexpected) in 0.004 (0.006) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test() {\\n        let value = solution.threeSumClosest([-1,2,1,-4], 1)\\n        XCTAssertEqual(value, 2)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func threeSumClosest(_ nums: [Int], _ target: Int) -> Int {\\n        \\n        let sorted = nums.sorted()\\n        let length = sorted.count\\n        \\n        var diff: Int = .max\\n        var result = 0\\n        \\n        for i in 0..<length - 2 {\\n            var n = i + 1, q = length - 1\\n            while n < q {\\n                let sum = sorted[i] + sorted[n] + sorted[q]\\n                \\n                sum > target ? (q -= 1) : (n += 1)\\n                \\n                let value =  abs(sum - target)\\n                \\n                if value < diff {\\n                    diff = value\\n                    result = sum\\n                }\\n            }\\n        }\\n        return result\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test() {\\n        let value = solution.threeSumClosest([-1,2,1,-4], 1)\\n        XCTAssertEqual(value, 2)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 352747,
                "title": "java-3-pointers-explained",
                "content": "**Idea:** Similar to [LC 15. 3Sum](https://leetcode.com/problems/3sum/discuss/339850/Java-or-Two-pointers-or-Time-beats-100-or-Memory-beats-93)\\n* Sort the array and have 3 pointers: at start, at end of the array and one moving from start + 1 to end - 1\\n* If sum of numbers at these 3 pointers equals target, then exit with target\\n* Else if sum < target, it means you need to add more to the sum, so move middle pointer forward\\n* Else move the end pointer backwards because the sum is too high\\n* Keep a running minimum difference to find the closest the sum gets to target\\n>**T/S:** O(n\\xB2)/O(n), where n = size(nums)\\nArrays.sort uses dual pivot quick sort which takes extra O(n) space\\n```\\npublic int threeSumClosest(int[] nums, int target) {\\n\\tvar closest = 0;\\n\\tvar n = nums.length;\\n\\tvar minDiff = Integer.MAX_VALUE;\\n\\tArrays.sort(nums);\\n\\n\\tfor (var i = 0; i < n - 2; i++) {\\n\\t\\tvar k = n - 1;\\n\\n\\t\\tfor (var j = i + 1; j < k;) {\\n\\t\\t\\tvar sum = nums[i] + nums[j] + nums[k];\\n\\n\\t\\t\\tif (sum == target)\\n\\t\\t\\t\\treturn target;\\n\\t\\t\\tif (sum < target)\\n\\t\\t\\t\\tj++;\\n\\t\\t\\telse\\n\\t\\t\\t\\tk--;\\n\\n\\t\\t\\tvar diff = Math.abs(target - sum);\\n\\t\\t\\tif (diff < minDiff) {\\n\\t\\t\\t\\tminDiff = diff;\\n\\t\\t\\t\\tclosest = sum;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn closest;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int threeSumClosest(int[] nums, int target) {\\n\\tvar closest = 0;\\n\\tvar n = nums.length;\\n\\tvar minDiff = Integer.MAX_VALUE;\\n\\tArrays.sort(nums);\\n\\n\\tfor (var i = 0; i < n - 2; i++) {\\n\\t\\tvar k = n - 1;\\n\\n\\t\\tfor (var j = i + 1; j < k;) {\\n\\t\\t\\tvar sum = nums[i] + nums[j] + nums[k];\\n\\n\\t\\t\\tif (sum == target)\\n\\t\\t\\t\\treturn target;\\n\\t\\t\\tif (sum < target)\\n\\t\\t\\t\\tj++;\\n\\t\\t\\telse\\n\\t\\t\\t\\tk--;\\n\\n\\t\\t\\tvar diff = Math.abs(target - sum);\\n\\t\\t\\tif (diff < minDiff) {\\n\\t\\t\\t\\tminDiff = diff;\\n\\t\\t\\t\\tclosest = sum;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn closest;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 7987,
                "title": "12-lines-concise-and-easy-understand-c-solultion",
                "content": "    class Solution {\\n    public:\\n        int threeSumClosest(vector<int>& nums, int target) {\\n            sort(nums.begin(), nums.end());\\n            int res = nums[0] + nums[1] + nums[2];\\n            for(int i = 0; i < nums.size() - 2; i++){\\n                int j = i + 1, k = nums.size() - 1;\\n                while(j < k){\\n                    int num = nums[i] + nums[j] + nums[k];\\n                    if(abs(num - target) < abs(res - target)) res = num;\\n                    if(num < target) j++;\\n                    else k--;\\n                }\\n            }\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int threeSumClosest(vector<int>& nums, int target) {\\n            sort(nums.begin(), nums.end());\\n            int res = nums[0] + nums[1] + nums[2];\\n            for(int i = 0; i < nums.size() - 2; i++){\\n                int j = i + 1, k = nums.size() - 1;\\n                while(j < k){\\n                    int num = nums[i] + nums[j] + nums[k];\\n                    if(abs(num - target) < abs(res - target)) res = num;\\n                    if(num < target) j++;\\n                    else k--;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2194572,
                "title": "python-accepted-solution-getting-tle-now",
                "content": "It seems like ~250 new test cases have been added to the problem recently which are now causing TLEs to previously accepted programs. See this submission of mine from March 2022 - https://leetcode.com/submissions/detail/666408027/. The same is now getting a TLE even after adding the optimization of skipping computations for duplicate elements.  \\n\\n**Solution which got accepted before but now giving TLE**\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        if len(nums) == 3:\\n            return sum(nums)\\n        \\n        nums = sorted(nums)\\n        minSum, minDiff = None, float(\\'inf\\')\\n        \\n        for i in range(len(nums)-2):\\n            left, right = i+1, len(nums)-1\\n            \\n            while left < right:\\n                currSum = nums[i] + nums[left] + nums[right]\\n                currDiff = abs(target - currSum)\\n\\n                if currDiff < minDiff:\\n                    minDiff = currDiff\\n                    minSum = currSum\\n\\n                if minDiff == 0:\\n                    return minSum\\n\\n                if target > currSum:\\n                    left += 1\\n                else:\\n                    right -= 1\\n        \\n        return minSum\\n```\\n\\n\\n**Optimized solution - also giving TLE**\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        N = len(nums)\\n        if N == 3:\\n            return sum(nums)\\n        \\n        nums = sorted(nums)\\n        minSum, minDiff = None, inf\\n        \\n        for i in range(N-2):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n\\n            left, right = i+1, N-1\\n            \\n            while left < right:\\n                currSum = sum([nums[i], nums[left], nums[right]])\\n                currDiff = abs(target - currSum)\\n\\n                if currDiff < minDiff:\\n                    minDiff = currDiff\\n                    minSum = currSum\\n\\n                    if minDiff == 0:\\n                        return minSum\\n\\n                if target > currSum:\\n                    left += 1\\n                    while left < right and nums[left] == nums[left-1]:\\n                        left += 1\\n                else:\\n                    right -= 1\\n                    while left < right and nums[right] == nums[right+1]:\\n                        right -= 1\\n        \\n        return minSum\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        if len(nums) == 3:\\n            return sum(nums)\\n        \\n        nums = sorted(nums)\\n        minSum, minDiff = None, float(\\'inf\\')\\n        \\n        for i in range(len(nums)-2):\\n            left, right = i+1, len(nums)-1\\n            \\n            while left < right:\\n                currSum = nums[i] + nums[left] + nums[right]\\n                currDiff = abs(target - currSum)\\n\\n                if currDiff < minDiff:\\n                    minDiff = currDiff\\n                    minSum = currSum\\n\\n                if minDiff == 0:\\n                    return minSum\\n\\n                if target > currSum:\\n                    left += 1\\n                else:\\n                    right -= 1\\n        \\n        return minSum\\n```\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        N = len(nums)\\n        if N == 3:\\n            return sum(nums)\\n        \\n        nums = sorted(nums)\\n        minSum, minDiff = None, inf\\n        \\n        for i in range(N-2):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n\\n            left, right = i+1, N-1\\n            \\n            while left < right:\\n                currSum = sum([nums[i], nums[left], nums[right]])\\n                currDiff = abs(target - currSum)\\n\\n                if currDiff < minDiff:\\n                    minDiff = currDiff\\n                    minSum = currSum\\n\\n                    if minDiff == 0:\\n                        return minSum\\n\\n                if target > currSum:\\n                    left += 1\\n                    while left < right and nums[left] == nums[left-1]:\\n                        left += 1\\n                else:\\n                    right -= 1\\n                    while left < right and nums[right] == nums[right+1]:\\n                        right -= 1\\n        \\n        return minSum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 7913,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**3Sum Closest** https://leetcode.com/problems/3sum-closest/\\n\\n**Brute-force: O(N^3)**\\n* Brute force solution will be O(N^3). We end up testing every subset and update the closest sum in every iteration.\\n\\n**Two Pointer Solution: O(N^2)**\\n* We can use the two pointer method to reduce complexity to O(N^2). We begin by sorting the array.\\n* Now we use three indices i,j and k. We iterate i from 0 to N (actually till N-2 is fine). We initialize j to i+1 and k to N-1.\\n* Now we compute curr_sum = nums[i]+nums[j]+nums[k]. If this equals target, we have the closest sum.\\n* Otherwise update closest_sum using the rule abs(curr_sum-target) < abs(closest_sum-target).\\n* Now what if curr_sum is less than target. Should we test (nums[i]+nums[j]+nums[k-1]), (nums[i]+nums[j]+nums[k-2]), (nums[i]+nums[j]+nums[k-3]) ? The answer is NO. All of these triplets will be less than curr_sum. And curr_sum is less than target - so there is no point testing these triplets. We must move forward by advancing j to j + 1 in the hope to get a larger triplet. This is the main intuition in this problem.\\n* You can visualize (6) by thinking all possible triplet sums sorted and arranged on a number line. When you find a curr_sum less than target, you increase curr_sum by increasing j. When you find a curr_sum less more than target, you reduce curr_sum by reducing k\\n```\\nclass Solution(object):\\n    def threeSumClosest(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        nums.sort()\\n        closest_sum = 2**31-1\\n        for i in range(len(nums)):\\n            j,k = i+1, len(nums)-1\\n            while j<k:\\n                curr_sum = nums[i] + nums[j] + nums[k]\\n                if curr_sum == target:\\n                    return curr_sum\\n                if abs(curr_sum-target) < abs(closest_sum-target):\\n                    closest_sum = curr_sum\\n                if curr_sum < target:\\n                    j = j+1\\n                else:\\n                    k = k-1\\n        return closest_sum\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def threeSumClosest(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        nums.sort()\\n        closest_sum = 2**31-1\\n        for i in range(len(nums)):\\n            j,k = i+1, len(nums)-1\\n            while j<k:\\n                curr_sum = nums[i] + nums[j] + nums[k]\\n                if curr_sum == target:\\n                    return curr_sum\\n                if abs(curr_sum-target) < abs(closest_sum-target):\\n                    closest_sum = curr_sum\\n                if curr_sum < target:\\n                    j = j+1\\n                else:\\n                    k = k-1\\n        return closest_sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1365711,
                "title": "c-simple-and-concise-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n = nums.size(), j, k, res = nums[0] + nums[1] + nums[2], curr;\\n        sort(nums.begin(), nums.end());\\n        \\n        for (int i = 0; i < n; i++) {\\n            j = i + 1, k = n - 1;\\n            \\n            while (j < k) {\\n                curr = nums[i] + nums[j] + nums[k];\\n                if (abs(curr - target) < abs(res - target)) \\n                    res = curr;\\n                \\n                if (curr < target) j++;\\n                else k--;\\n                    \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n = nums.size(), j, k, res = nums[0] + nums[1] + nums[2], curr;\\n        sort(nums.begin(), nums.end());\\n        \\n        for (int i = 0; i < n; i++) {\\n            j = i + 1, k = n - 1;\\n            \\n            while (j < k) {\\n                curr = nums[i] + nums[j] + nums[k];\\n                if (abs(curr - target) < abs(res - target)) \\n                    res = curr;\\n                \\n                if (curr < target) j++;\\n                else k--;\\n                    \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 481580,
                "title": "javascript-solution",
                "content": "### The idea\\n1. Sort the input array\\n2. Use two pointers `left` & `right` to calculate a local sum, compare the target with the local sum\\n``` javascript\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a,b)=>a-b);\\n    let closest = Infinity;\\n    for (let i=0;i<nums.length-2;i++) {\\n        let left = i+1; right = nums.length-1;\\n        while (left < right) {\\n            let localSum = nums[i] + nums[left] + nums[right];\\n            if (Math.abs(localSum - target) < Math.abs(closest - target)) closest = localSum;\\n            if (localSum > target) right--;\\n            else left++;\\n        }\\n    }\\n    return closest;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a,b)=>a-b);\\n    let closest = Infinity;\\n    for (let i=0;i<nums.length-2;i++) {\\n        let left = i+1; right = nums.length-1;\\n        while (left < right) {\\n            let localSum = nums[i] + nums[left] + nums[right];\\n            if (Math.abs(localSum - target) < Math.abs(closest - target)) closest = localSum;\\n            if (localSum > target) right--;\\n            else left++;\\n        }\\n    }\\n    return closest;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3736495,
                "title": "java-fastest-and-easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/5c5c0ba7-1c0d-4826-9c1e-c86de4dcb9db_1688821081.4729018.png)\\n\\n\\n# Code\\n```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int closestSum = nums[0] + nums[1] + nums[2]; // Initialize closest sum with the sum of the first three elements\\n\\n        for (int i = 0; i < nums.length - 2; i++) {\\n            int j = i + 1;\\n            int k = nums.length - 1;\\n\\n            while (j < k) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n\\n                if (Math.abs(target - sum) < Math.abs(target - closestSum)) {\\n                    closestSum = sum; // Update closest sum if the current sum is closer to the target\\n                }\\n\\n                if (sum < target) {\\n                    j++; // Increment j to increase the sum\\n                } else {\\n                    k--; // Decrement k to decrease the sum\\n                }\\n            }\\n        }\\n\\n        return closestSum;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int closestSum = nums[0] + nums[1] + nums[2]; // Initialize closest sum with the sum of the first three elements\\n\\n        for (int i = 0; i < nums.length - 2; i++) {\\n            int j = i + 1;\\n            int k = nums.length - 1;\\n\\n            while (j < k) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n\\n                if (Math.abs(target - sum) < Math.abs(target - closestSum)) {\\n                    closestSum = sum; // Update closest sum if the current sum is closer to the target\\n                }\\n\\n                if (sum < target) {\\n                    j++; // Increment j to increase the sum\\n                } else {\\n                    k--; // Decrement k to decrease the sum\\n                }\\n            }\\n        }\\n\\n        return closestSum;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 164611,
                "title": "logical-thinking-with-code-beats-99-33",
                "content": "**Logical Thinking**\\nIf a candidate number `nums[pre]` is given, the problem is decreased to the **Two-sum Closest** problem -  find two integers in nums such that the sum is closest to `target - nums[pre]`. We need to try all possible `nums[pre]`.\\nWe\\'d better sort `nums[]` first. In this way, we can apply **Binary Search** in `2Sum Closest` rather than **Exhaustive Search**.\\n\\n**Trick**\\nThe condition to terminate **Binary Search** is not \\'`no searching space`\\' but \\'`not enough searching space`\\' for we need to maintain two valid candidates in the searching space `[lo, hi]` both inclusive.\\n\\n**Clear Code**\\n```\\n    public int threeSumClosest(int[] nums, int target) {\\n        \\n        if (nums == null || nums.length < 3) {\\n            throw new IllegalArgumentException();\\n        }\\n\\n        Arrays.sort(nums);\\n        int n = nums.length, minDiff = Integer.MAX_VALUE, sumClosest = -1;\\n        \\n        for (int pre = 0; pre < n; pre++) {\\n            int lo = pre + 1;\\n            int hi = n - 1;\\n            while (lo < hi) {\\n                int curTarget = target - nums[pre];\\n                int curSum = nums[lo] + nums[hi];\\n                if (curSum < curTarget) { \\n                    if (curTarget - curSum < minDiff) {\\n                        minDiff = curTarget - curSum;\\n                        sumClosest = curSum + nums[pre];\\n                    }\\n                    lo++;\\n                    continue;\\n                }\\n                if (curSum > curTarget) {\\n                    if (curSum - curTarget < minDiff) {\\n                        minDiff = curSum - curTarget;\\n                        sumClosest = curSum + nums[pre];\\n                    }\\n                    hi--;\\n                    continue;\\n                }\\n                return curSum + nums[pre];\\n            }\\n        }\\n        \\n        return sumClosest;\\n    }\\n```\\n**I would appreciate your VOTE UP ;)**",
                "solutionTags": [],
                "code": "```\\n    public int threeSumClosest(int[] nums, int target) {\\n        \\n        if (nums == null || nums.length < 3) {\\n            throw new IllegalArgumentException();\\n        }\\n\\n        Arrays.sort(nums);\\n        int n = nums.length, minDiff = Integer.MAX_VALUE, sumClosest = -1;\\n        \\n        for (int pre = 0; pre < n; pre++) {\\n            int lo = pre + 1;\\n            int hi = n - 1;\\n            while (lo < hi) {\\n                int curTarget = target - nums[pre];\\n                int curSum = nums[lo] + nums[hi];\\n                if (curSum < curTarget) { \\n                    if (curTarget - curSum < minDiff) {\\n                        minDiff = curTarget - curSum;\\n                        sumClosest = curSum + nums[pre];\\n                    }\\n                    lo++;\\n                    continue;\\n                }\\n                if (curSum > curTarget) {\\n                    if (curSum - curTarget < minDiff) {\\n                        minDiff = curSum - curTarget;\\n                        sumClosest = curSum + nums[pre];\\n                    }\\n                    hi--;\\n                    continue;\\n                }\\n                return curSum + nums[pre];\\n            }\\n        }\\n        \\n        return sumClosest;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1179560,
                "title": "c-two-pointer-approach-3-sum-variation",
                "content": "\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        \\n        int res = 0;\\n        int min_diff = INT_MAX;\\n        \\n        for(int i = 0; i < n - 2; i++)\\n        {\\n            int j = i + 1;\\n            int k = n - 1;\\n            \\n            while(j < k)\\n            {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                if(abs(target - sum) < min_diff)\\n                {\\n                    min_diff = abs(target - sum);\\n                    res = sum;\\n                }\\n                if(sum > target)\\n                    k--;\\n                else \\n                    j++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        \\n        int res = 0;\\n        int min_diff = INT_MAX;\\n        \\n        for(int i = 0; i < n - 2; i++)\\n        {\\n            int j = i + 1;\\n            int k = n - 1;\\n            \\n            while(j < k)\\n            {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                if(abs(target - sum) < min_diff)\\n                {\\n                    min_diff = abs(target - sum);\\n                    res = sum;\\n                }\\n                if(sum > target)\\n                    k--;\\n                else \\n                    j++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3116265,
                "title": "easily-understandable-solution-beats-99-30",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int diff=INT_MAX;\\n        int ans=0;\\n     sort(nums.begin(), nums.end());\\n for(int i=0;i<nums.size()-2;i++){\\n     int low=i+1;\\n     int high=nums.size()-1;\\n     int first=nums[i];\\n     while(low<high){\\n         if(first+nums[low]+nums[high]==target){\\n             return target;\\n         }\\n         else if(abs(first+nums[low]+nums[high]-target)<diff){\\n             diff=abs(first+nums[low]+nums[high]-target);\\n             ans=first+nums[low]+nums[high];\\n         }\\n         if(first+nums[low]+nums[high]<target){\\n             low++; \\n         }\\n        else{ high--;\\n            }\\n     }\\n }              \\n        return ans;\\n    }\\n};\\n```\\nPlease upvote to motivate me to write more solutions\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int diff=INT_MAX;\\n        int ans=0;\\n     sort(nums.begin(), nums.end());\\n for(int i=0;i<nums.size()-2;i++){\\n     int low=i+1;\\n     int high=nums.size()-1;\\n     int first=nums[i];\\n     while(low<high){\\n         if(first+nums[low]+nums[high]==target){\\n             return target;\\n         }\\n         else if(abs(first+nums[low]+nums[high]-target)<diff){\\n             diff=abs(first+nums[low]+nums[high]-target);\\n             ans=first+nums[low]+nums[high];\\n         }\\n         if(first+nums[low]+nums[high]<target){\\n             low++; \\n         }\\n        else{ high--;\\n            }\\n     }\\n }              \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2159984,
                "title": "something-wrong-with-python3-interpreter",
                "content": "Something is wrong with the way the leetcode environment is processing python3 code! It is executing most code in far longer than it should.\\n\\nAt first I thought I just had a poor solution, but then I noticed that mine was functionally identical to the \\'correct\\' ones. I then copy and pasted previous examples of middle of the road times (~300ms): now they are exceeding time limit or are in the 9000ms+ range!\\n\\nConsider the following - its not my code, but an \"example 290ms\" one:\\n\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        res = float(\\'inf\\')\\n        for i in range(len(nums)):\\n            l, r = i + 1, len(nums) - 1\\n            while l < r:\\n                s = nums[i] + nums[l] + nums[r]\\n                if abs(s - target) < abs(res - target):\\n                    res = s\\n                if s == target:\\n                    return target\\n                elif s < target:\\n                    l += 1\\n                else:\\n                    r -= 1\\n        return res\\n```\\n\\nThis code copy pasted in exceeds the time limit, rather than being in the ~300ms range.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        res = float(\\'inf\\')\\n        for i in range(len(nums)):\\n            l, r = i + 1, len(nums) - 1\\n            while l < r:\\n                s = nums[i] + nums[l] + nums[r]\\n                if abs(s - target) < abs(res - target):\\n                    res = s\\n                if s == target:\\n                    return target\\n                elif s < target:\\n                    l += 1\\n                else:\\n                    r -= 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 7963,
                "title": "u3010python-u3011beating-95-solution-with-two-pointers-u3010o-n-2-u3011",
                "content": "Same algorithm as 3sum problem, where we sort `nums`, then use two pointers to check all the possible combinations, while fixing one element. \\n\\nIn this problem, we just need to add a new variable `diff` to track the difference between target and current best result. In addition, we move the pointers in terms of `diff` (be careful with the sign)\\n\\n    \\n    def threeSumClosest(self, nums, target):\\n        result, diff = 0, sys.maxint\\n        nums.sort()\\n        \\n        for i in xrange(len(nums) - 2):\\n            if i > 0 and nums[i] == nums[i - 1]:\\n                continue\\n            \\n            left, right = i + 1, len(nums) - 1\\n            \\n            while left < right:\\n                total = nums[i] + nums[left] + nums[right]\\n                hold_diff = abs (total - target)\\n                \\n                if not hold_diff:\\n                    return total\\n                    \\n                if hold_diff  < diff:\\n                    result = total\\n                    diff = hold_diff\\n                    \\n                if total < target:\\n                    left += 1\\n                \\n                else:\\n                    right -= 1\\n                    \\n        return result",
                "solutionTags": [
                    "Python"
                ],
                "code": "Same algorithm as 3sum problem, where we sort `nums`, then use two pointers to check all the possible combinations, while fixing one element. \\n\\nIn this problem, we just need to add a new variable `diff` to track the difference between target and current best result. In addition, we move the pointers in terms of `diff` (be careful with the sign)\\n\\n    \\n    def threeSumClosest(self, nums, target):\\n        result, diff = 0, sys.maxint\\n        nums.sort()\\n        \\n        for i in xrange(len(nums) - 2):\\n            if i > 0 and nums[i] == nums[i - 1]:\\n                continue\\n            \\n            left, right = i + 1, len(nums) - 1\\n            \\n            while left < right:\\n                total = nums[i] + nums[left] + nums[right]\\n                hold_diff = abs (total - target)\\n                \\n                if not hold_diff:\\n                    return total\\n                    \\n                if hold_diff  < diff:\\n                    result = total\\n                    diff = hold_diff\\n                    \\n                if total < target:\\n                    left += 1\\n                \\n                else:\\n                    right -= 1\\n                    \\n        return result",
                "codeTag": "Python3"
            },
            {
                "id": 2674627,
                "title": "java-sorting-two-pointers-approach",
                "content": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int n=nums.length;\\n        int minDiff=Integer.MAX_VALUE;\\n        int ans=0;\\n        for(int i=0;i<n-2;i++){\\n            int low=i+1,high=n-1;\\n            while(low<high){\\n                int temp=nums[i]+nums[low]+nums[high];\\n                if(Math.abs(target-temp)<minDiff){\\n                    ans=temp;\\n                    minDiff=Math.abs(target-temp);\\n                }\\n                if(temp==target){\\n                    return target;\\n                }\\n                else if(temp>target){\\n                        high--;\\n                }\\n                else{\\n                    low++;\\n                }\\n            }\\n        }\\n        return ans;\\n            \\n    }       \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int n=nums.length;\\n        int minDiff=Integer.MAX_VALUE;\\n        int ans=0;\\n        for(int i=0;i<n-2;i++){\\n            int low=i+1,high=n-1;\\n            while(low<high){\\n                int temp=nums[i]+nums[low]+nums[high];\\n                if(Math.abs(target-temp)<minDiff){\\n                    ans=temp;\\n                    minDiff=Math.abs(target-temp);\\n                }\\n                if(temp==target){\\n                    return target;\\n                }\\n                else if(temp>target){\\n                        high--;\\n                }\\n                else{\\n                    low++;\\n                }\\n            }\\n        }\\n        return ans;\\n            \\n    }       \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1938326,
                "title": "most-efficient-python-code-that-beats-90-submissions-with-easiest-explanation",
                "content": "**Intution:**\\nWe\\'ll use **Three-pointer** approach in this question.\\nSort the given list in ascending order.\\nA pointer lets say \\'i\\' will be used to iterate through the given list nums.\\nWithin that loop, two more pointers lets say \\'start\\' and \\'end\\' would be initialised as follows:\\n\\tstart=i+1\\n\\tend=len(nums)-1\\nNow within this loop we will run another loop until the value of start in less than end.\\nTake a variable lets say \\'sum\\' to store value of nums[i]+nums[start]+nums[end].\\nIn this loop we would be checking for **3 conditions**.\\n**Condition 1:**\\nif **sum==target**, the sum contains the required answer as the minimum possible difference between any two numbers is 0 and sum-target will also give 0 in this case.\\n**Condition 2:**\\nif difference in target and sum is less than value contained by our \\'diff\\' variable(initialized with maximum possible value) the the diff would become equal to the absolute difference in target and sum and answer variable \\'ans\\' would be assigned the value of \\'sum\\', as this sum gives the minimum difference till now.\\n**Condition 3:\"**\\nWe\\'ll check if the value of sum is greater than target then the end will be decremented by one or else the start in incremented by one in case the sum is less than target.\\n**Code:**\\n\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums=sorted(nums)\\n        diff=float(\\'inf\\')\\n        for i in range(len(nums)-1):\\n            start=i+1\\n            end=len(nums)-1\\n            while(start<end):\\n                sum=nums[i]+nums[start]+nums[end]\\n                if sum==target:\\n                    return target\\n                elif abs(target-sum)<diff:\\n                    diff=abs(target-sum)\\n                    ans=sum\\n                if sum>target:\\n                    end-=1\\n                else:\\n                    start+=1\\n        return ans\\n```\\n\\n**Complexity Analysis:**\\nTime Complexity:\\nO(n^2)\\nSpace Complexity:\\nO(1) [constant]\\n**PLEASE UPVOTE THE ANSWER TO MOTIVATE ME FOR CONTINUING THE COMMUNITY SUPPORT**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums=sorted(nums)\\n        diff=float(\\'inf\\')\\n        for i in range(len(nums)-1):\\n            start=i+1\\n            end=len(nums)-1\\n            while(start<end):\\n                sum=nums[i]+nums[start]+nums[end]\\n                if sum==target:\\n                    return target\\n                elif abs(target-sum)<diff:\\n                    diff=abs(target-sum)\\n                    ans=sum\\n                if sum>target:\\n                    end-=1\\n                else:\\n                    start+=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3493316,
                "title": "c-java-python-javascript-o-n-2logn-using-two-pointers",
                "content": "# Intuition:\\n\\nThe problem requires us to find a triplet of numbers in the given array, such that their sum is closest to the given target. We can use the two-pointer approach along with sorting the array to solve this problem.\\n\\n# Approach:\\n\\n1. Sort the given array in non-descending order.\\n2. Initialize a variable closest_sum to store the closest sum found so far. Set it initially to the sum of first three elements in the sorted array.\\n3. Loop over the array from i=0 to i=n-3, where n is the size of the array.\\n4. For each i, initialize two pointers, left and right, to i+1 and n-1 respectively.\\n5. While left < right, calculate the sum of the current triplet, sum = nums[i] + nums[left] + nums[right].\\n6. If sum is equal to the target, we have found the closest sum possible, so we can return it immediately.\\n7. If sum is less than target, increment left by 1. This will increase the sum, and we may get a closer sum.\\n8. If sum is greater than target, decrement right by 1. This will decrease the sum, and we may get a closer sum.\\n9. After each iteration of the inner loop, check if the absolute difference between sum and target is less than the absolute difference between closest_sum and target. If it is, update closest_sum to sum.\\n10. Return closest_sum after the loop ends.\\n# Complexity:\\n- Time Complexity: Sorting the array takes O(nlogn) time. The two-pointer approach runs in O(n^2) time. Therefore, the overall time complexity of the solution is O(n^2logn).\\n\\n- Space Complexity: We are not using any extra space in the solution. Therefore, the space complexity of the solution is O(1).\\n\\n---\\n\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        int closest_sum = nums[0] + nums[1] + nums[2]; // initialize closest sum\\n        for (int i = 0; i < n - 2; i++) {\\n            int left = i + 1, right = n - 1;\\n            while (left < right) { // two-pointer approach\\n                int sum = nums[i] + nums[left] + nums[right];\\n                if (sum == target) { // sum equals target, return immediately\\n                    return sum;\\n                } else if (sum < target) {\\n                    left++;\\n                } else {\\n                    right--;\\n                }\\n                if (abs(sum - target) < abs(closest_sum - target)) { // update closest sum\\n                    closest_sum = sum;\\n                }\\n            }\\n        }\\n        return closest_sum;\\n    }\\n};\\n\\n```\\n\\n---\\n# JAVA\\n```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int closest_sum = nums[0] + nums[1] + nums[2]; // initialize closest sum\\n        for (int i = 0; i < n - 2; i++) {\\n            int left = i + 1, right = n - 1;\\n            while (left < right) { // two-pointer approach\\n                int sum = nums[i] + nums[left] + nums[right];\\n                if (sum == target) { // sum equals target, return immediately\\n                    return sum;\\n                } else if (sum < target) {\\n                    left++;\\n                } else {\\n                    right--;\\n                }\\n                if (Math.abs(sum - target) < Math.abs(closest_sum - target)) { // update closest sum\\n                    closest_sum = sum;\\n                }\\n            }\\n        }\\n        return closest_sum;\\n    }\\n}\\n\\n```\\n\\n---\\n# Python\\n```\\nclass Solution(object):\\n    def threeSumClosest(self, nums, target):\\n        nums.sort()\\n        n = len(nums)\\n        closest_sum = nums[0] + nums[1] + nums[2] # initialize closest sum\\n        for i in range(n - 2):\\n            left, right = i + 1, n - 1\\n            while left < right: # two-pointer approach\\n                sum = nums[i] + nums[left] + nums[right]\\n                if sum == target: # sum equals target, return immediately\\n                    return sum\\n                elif sum < target:\\n                    left += 1\\n                else:\\n                    right -= 1\\n                if abs(sum - target) < abs(closest_sum - target): # update closest sum\\n                    closest_sum = sum\\n        return closest_sum\\n\\n```\\n\\n---\\n# JavaScript\\n```\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a, b) => a - b);\\n    let n = nums.length;\\n    let closest_sum = nums[0] + nums[1] + nums[2]; // initialize closest sum\\n    for (let i = 0; i < n - 2; i++) {\\n        let left = i + 1, right = n - 1;\\n        while (left < right) { // two-pointer approach\\n            let sum = nums[i] + nums[left] + nums[right];\\n            if (sum == target) { // sum equals target, return immediately\\n                return sum;\\n            } else if (sum < target) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n            if (Math.abs(sum - target) < Math.abs(closest_sum - target)) { // update closest sum\\n                closest_sum = sum;\\n            }\\n        }\\n    }\\n    return closest_sum;\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        int closest_sum = nums[0] + nums[1] + nums[2]; // initialize closest sum\\n        for (int i = 0; i < n - 2; i++) {\\n            int left = i + 1, right = n - 1;\\n            while (left < right) { // two-pointer approach\\n                int sum = nums[i] + nums[left] + nums[right];\\n                if (sum == target) { // sum equals target, return immediately\\n                    return sum;\\n                } else if (sum < target) {\\n                    left++;\\n                } else {\\n                    right--;\\n                }\\n                if (abs(sum - target) < abs(closest_sum - target)) { // update closest sum\\n                    closest_sum = sum;\\n                }\\n            }\\n        }\\n        return closest_sum;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int closest_sum = nums[0] + nums[1] + nums[2]; // initialize closest sum\\n        for (int i = 0; i < n - 2; i++) {\\n            int left = i + 1, right = n - 1;\\n            while (left < right) { // two-pointer approach\\n                int sum = nums[i] + nums[left] + nums[right];\\n                if (sum == target) { // sum equals target, return immediately\\n                    return sum;\\n                } else if (sum < target) {\\n                    left++;\\n                } else {\\n                    right--;\\n                }\\n                if (Math.abs(sum - target) < Math.abs(closest_sum - target)) { // update closest sum\\n                    closest_sum = sum;\\n                }\\n            }\\n        }\\n        return closest_sum;\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def threeSumClosest(self, nums, target):\\n        nums.sort()\\n        n = len(nums)\\n        closest_sum = nums[0] + nums[1] + nums[2] # initialize closest sum\\n        for i in range(n - 2):\\n            left, right = i + 1, n - 1\\n            while left < right: # two-pointer approach\\n                sum = nums[i] + nums[left] + nums[right]\\n                if sum == target: # sum equals target, return immediately\\n                    return sum\\n                elif sum < target:\\n                    left += 1\\n                else:\\n                    right -= 1\\n                if abs(sum - target) < abs(closest_sum - target): # update closest sum\\n                    closest_sum = sum\\n        return closest_sum\\n\\n```\n```\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a, b) => a - b);\\n    let n = nums.length;\\n    let closest_sum = nums[0] + nums[1] + nums[2]; // initialize closest sum\\n    for (let i = 0; i < n - 2; i++) {\\n        let left = i + 1, right = n - 1;\\n        while (left < right) { // two-pointer approach\\n            let sum = nums[i] + nums[left] + nums[right];\\n            if (sum == target) { // sum equals target, return immediately\\n                return sum;\\n            } else if (sum < target) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n            if (Math.abs(sum - target) < Math.abs(closest_sum - target)) { // update closest sum\\n                closest_sum = sum;\\n            }\\n        }\\n    }\\n    return closest_sum;\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1365598,
                "title": "3sum-closest-easy-w-approach-c-java",
                "content": "# **APPROACH:**\\n* Given an `array nums with n integers` and `one target`. We have to find `three integers` in nums such that the **sum is closest to the target**. We will return the sum of the three integers. \\n* We can take one assumption that each input would have exactly one solution. \\n\\n**TESTCASE:**\\nIf the given array is like `[-1,2,1,-4]` and the target is `1`, then the triplet will be `[-1,2,1]` this has the closest sum, that is `2`.\\n\\n# **ALGORITHM:**\\n\\n* Sort the array nums, ans := 0, diff := Infinity, n := size of nums\\n* for i in range 0 to n \\u2013 1\\n\\t* left := i + 1, right := n \\u2013 1\\n\\t* while left < right\\n\\t\\t* temp := nums[left] + nums[right] + nums[i]\\n\\t\\t* If `|target \\u2013 temp| < diff`, then ans := temp and diff := |target \\u2013 temp|\\n\\t\\t* If `temp = target`, then return temp, \\n\\t\\t* Otherwise when `temp > target`, then decrease right by 1, else increase left by 1\\n* return ans\\n\\n# **SOLUTION:**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int ans = 0;\\n        int diff = INT_MAX ;\\n        int n = nums.size() ;\\n        for(int i = 0; i < n; i++)\\n        {\\n            int left = i + 1;\\n            int right = n - 1;\\n            while(left < right)\\n            {\\n                int temp = nums[left] + nums[right] + nums[i];\\n                if(abs(target - temp) < diff)\\n                {\\n                   ans = temp;\\n                   diff = abs(target - temp);\\n                }\\n                if(temp == target) return temp;\\n                else if(temp > target) right--;\\n                else left++;\\n            }\\n        }\\n      return ans;\\n    }\\n};\\n```\\n`In Java`\\n```\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a,b) => a-b)\\n    let diff = Infinity;\\n\\n    for(var i = 0; i < nums.length; i++) {\\n        let j = i + 1;\\n        let k = nums.length - 1\\n    \\n        while(j < k) {\\n            let sum = nums[i]+nums[j]+nums[k]\\n        \\n            if(Math.abs(diff) > Math.abs(target-sum)) \\n\\t\\t\\t{\\n                diff = target - sum\\n            }\\n        \\n            if(sum < target) \\n\\t\\t\\t{\\n                j++\\n            } \\n\\t\\t\\telse \\n\\t\\t\\t{\\n                k--\\n            }\\n        }\\n    }\\n    return target - diff\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int ans = 0;\\n        int diff = INT_MAX ;\\n        int n = nums.size() ;\\n        for(int i = 0; i < n; i++)\\n        {\\n            int left = i + 1;\\n            int right = n - 1;\\n            while(left < right)\\n            {\\n                int temp = nums[left] + nums[right] + nums[i];\\n                if(abs(target - temp) < diff)\\n                {\\n                   ans = temp;\\n                   diff = abs(target - temp);\\n                }\\n                if(temp == target) return temp;\\n                else if(temp > target) right--;\\n                else left++;\\n            }\\n        }\\n      return ans;\\n    }\\n};\\n```\n```\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a,b) => a-b)\\n    let diff = Infinity;\\n\\n    for(var i = 0; i < nums.length; i++) {\\n        let j = i + 1;\\n        let k = nums.length - 1\\n    \\n        while(j < k) {\\n            let sum = nums[i]+nums[j]+nums[k]\\n        \\n            if(Math.abs(diff) > Math.abs(target-sum)) \\n\\t\\t\\t{\\n                diff = target - sum\\n            }\\n        \\n            if(sum < target) \\n\\t\\t\\t{\\n                j++\\n            } \\n\\t\\t\\telse \\n\\t\\t\\t{\\n                k--\\n            }\\n        }\\n    }\\n    return target - diff\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 848622,
                "title": "java-simple-and-readable-solution-two-pointer",
                "content": "We can regard this quesiton as : \\na+b+c+min(difference) ? target \\nsum = a+b+c\\nthen we transferred the question sucessfully as Two Pointers.\\n\\nSo what we need now is the minimum diff and return sum(which is target - diff) at last\\nWatch out that diff could be both positive and negative, thus just comparing diff is meaningless.\\nWe can slove this by updating the diff original value IFF its absolute value smaller.\\n\\n```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int diff = Integer.MAX_VALUE;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            int left = i + 1;\\n            int right = nums.length - 1;\\n            \\n            while (left < right) {\\n                int sum  = nums[i] + nums[left] + nums[right];\\n                \\n                if (Math.abs(target - sum) < Math.abs(diff)) {\\n                    diff = target - sum;\\n                }\\n                \\n                if (sum > target) {\\n                    right--;\\n                }\\n                else {\\n                    left++;\\n                }\\n            }\\n        }\\n        return (target-diff);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int diff = Integer.MAX_VALUE;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            int left = i + 1;\\n            int right = nums.length - 1;\\n            \\n            while (left < right) {\\n                int sum  = nums[i] + nums[left] + nums[right];\\n                \\n                if (Math.abs(target - sum) < Math.abs(diff)) {\\n                    diff = target - sum;\\n                }\\n                \\n                if (sum > target) {\\n                    right--;\\n                }\\n                else {\\n                    left++;\\n                }\\n            }\\n        }\\n        return (target-diff);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1430115,
                "title": "7-lines-code-with-detailed-explanation-of-approach-for-beginners-o-n-2-beginner-coders",
                "content": "**First of all the approach of this problem is very similar of 3 sum so i request you all to aleast try this problem.**\\nFirst of all sort the array because without sorting this array two pointer approach has no meaning.\\nuse two pointer approach\\nmake a left pointing next to i and a right pointer at the last element of the array\\nmake a sum variable also make a mini_diffrence variable which keep account of absolute diffrence of sum and target. \\ncheck for the condition if absolute value of \\n**abs**(target - curr_sum) < mini_diff\\nthen assign  target - curr_sum  to mini_diffrence\\n**if sum > target than decrement the right pointer\\nthis this this is the benifit of sorting of array because we can\\'t write this unless the array is sorted**\\n**else increment left pointer.\\nthis this this is the benifit of sorting of array because we can\\'t write this unless the array is sorted**\\n\\n**Time complexity - O(N^2)\\nspace complexity - O(1) as no extra space required**\\n**where N is the number of element in the array**\\n\\n\\n int threeSumClosest(vector<int>& nums, int target) {\\n      \\n     \\n    sort(nums.begin(), nums.end());\\n    \\n    int res = 0 ,  n = nums.size() ,  mini_diff = INT_MAX;\\n  \\n    \\n    for(int i = 0; i < n-2; i++)\\n    {\\n        int left = i + 1 , right = n - 1;\\n        \\n        \\n        while(left < right)\\n        {\\n            int sum = nums[i] + nums[left] + nums[right];\\n    if(abs(target - sum) < mini_diff)  mini_diff = abs(target - sum), res = sum;\\n            \\n            if(sum > target)  right--;\\n              \\n            else   left++;\\n              \\n        }\\n    }\\n    \\n    return res;\\n}\\n\\n\\n//Guys plz plz plz upvote my solution if you really like it and understand it.and comment here if there is any doubt or new suggestion.\\n//Stay Safe and Keep Coding Guys!!!!\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "**First of all the approach of this problem is very similar of 3 sum so i request you all to aleast try this problem.**\\nFirst of all sort the array because without sorting this array two pointer approach has no meaning.\\nuse two pointer approach\\nmake a left pointing next to i and a right pointer at the last element of the array\\nmake a sum variable also make a mini_diffrence variable which keep account of absolute diffrence of sum and target. \\ncheck for the condition if absolute value of \\n**abs**(target - curr_sum) < mini_diff\\nthen assign  target - curr_sum  to mini_diffrence\\n**if sum > target than decrement the right pointer\\nthis this this is the benifit of sorting of array because we can\\'t write this unless the array is sorted**\\n**else increment left pointer.\\nthis this this is the benifit of sorting of array because we can\\'t write this unless the array is sorted**\\n\\n**Time complexity - O(N^2)\\nspace complexity - O(1) as no extra space required**\\n**where N is the number of element in the array**\\n\\n\\n int threeSumClosest(vector<int>& nums, int target) {\\n      \\n     \\n    sort(nums.begin(), nums.end());\\n    \\n    int res = 0 ,  n = nums.size() ,  mini_diff = INT_MAX;\\n  \\n    \\n    for(int i = 0; i < n-2; i++)\\n    {\\n        int left = i + 1 , right = n - 1;\\n        \\n        \\n        while(left < right)\\n        {\\n            int sum = nums[i] + nums[left] + nums[right];\\n    if(abs(target - sum) < mini_diff)  mini_diff = abs(target - sum), res = sum;\\n            \\n            if(sum > target)  right--;\\n              \\n            else   left++;\\n              \\n        }\\n    }\\n    \\n    return res;\\n}\\n\\n\\n//Guys plz plz plz upvote my solution if you really like it and understand it.and comment here if there is any doubt or new suggestion.\\n//Stay Safe and Keep Coding Guys!!!!\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 7906,
                "title": "7ms-and-o-n-2-java-solution",
                "content": "My solution does not need compare each sum ,just need to compare possible sum ,so can save time.\\n\\n    public class Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int closest=nums[0]+nums[1]+nums[2];\\n        int low,high;\\n        for(int i=0;i<nums.length-1;i++){\\n            low=i+1;\\n            high=nums.length-1;\\n            while(low<high){\\n                if(nums[low]+nums[high]==target-nums[i]) return target;\\n                else if(nums[low]+nums[high]>target-nums[i]){\\n                    while(low<high&&nums[low]+nums[high]>target-nums[i]) high--;\\n                    if(Math.abs(nums[i]+nums[low]+nums[high+1]-target)<Math.abs(closest-target))\\n                        closest=nums[i]+nums[low]+nums[high+1];\\n                }\\n                else{\\n                    while(low<high&&nums[low]+nums[high]<target-nums[i]) low++;\\n                    if(Math.abs(nums[i]+nums[low-1]+nums[high]-target)<Math.abs(closest-target))\\n                        closest=nums[i]+nums[low-1]+nums[high];\\n                }\\n            }\\n        }\\n        return closest;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int closest=nums[0]+nums[1]+nums[2];\\n        int low,high;\\n        for(int i=0;i<nums.length-1;i++){\\n            low=i+1;\\n            high=nums.length-1;\\n            while(low<high){\\n                if(nums[low]+nums[high]==target-nums[i]) return target;\\n                else if(nums[low]+nums[high]>target-nums[i]){\\n                    while(low<high&&nums[low]+nums[high]>target-nums[i]) high--;\\n                    if(Math.abs(nums[i]+nums[low]+nums[high+1]-target)<Math.abs(closest-target))\\n                        closest=nums[i]+nums[low]+nums[high+1];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3067315,
                "title": "faster-c-solution-o-n-3-o-n-2-40ms-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem is a variation of 2Sum and especially 3Sum problem. In 3Sum, we choose a triplet and checks its sum equal to 0(target). here we have to find the sum of triplet closest to target. so use the same approach as we have used in 3Sum problem.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirst thing is to think how you can get closest sum. For this sort the vector for easiness. \\nif sum is greater then target, but we need sum closest, that is ,**the minimum sum greater than equal to target** declare min1 variable with **min1 = INT_MAX - 10000;** we did -10000 so that we can get rid of TLE.  and same for when sum is smaller than target , that is, **the greatest sum smaller than equal to target** for this declare, **max1 = INT_MIN + 10000** . if sum is equal to target return the sum. \\n\\nnow the question is which variale min1, max1 we have to return, for this, find the absolute difference of min1, max1 with target and return min1 or max1 as per the minimum diff obtained.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n        int  n= nums.size();\\n        int sum=0, j=0,k=0;\\n        int max1 = INT_MIN + 10000, min1 = INT_MAX - 10000;\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i< (n-2); i++)\\n        {\\n            j= i+1;\\n            k= n-1;\\n            while(j < k)\\n            {\\n                sum= nums[i] + nums[j] + nums[k];\\n                \\n                if(sum == target)\\n                    return sum;\\n                \\n                else if(sum>target)\\n                {\\n                    min1= min(min1, sum);\\n                    k--;\\n                }\\n                else if(sum < target)\\n                {\\n                    max1= max( max1, sum);\\n                    j++;\\n                }\\n            }\\n        }\\n        // target =10, a=2, b=1;\\n\\n        int a= min1 - target;\\n        int b= target - max1;\\n\\n        if(a < b)\\n        return min1;\\n        else\\n        return max1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n        int  n= nums.size();\\n        int sum=0, j=0,k=0;\\n        int max1 = INT_MIN + 10000, min1 = INT_MAX - 10000;\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i< (n-2); i++)\\n        {\\n            j= i+1;\\n            k= n-1;\\n            while(j < k)\\n            {\\n                sum= nums[i] + nums[j] + nums[k];\\n                \\n                if(sum == target)\\n                    return sum;\\n                \\n                else if(sum>target)\\n                {\\n                    min1= min(min1, sum);\\n                    k--;\\n                }\\n                else if(sum < target)\\n                {\\n                    max1= max( max1, sum);\\n                    j++;\\n                }\\n            }\\n        }\\n        // target =10, a=2, b=1;\\n\\n        int a= min1 - target;\\n        int b= target - max1;\\n\\n        if(a < b)\\n        return min1;\\n        else\\n        return max1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173514,
                "title": "java-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Fix one var\\n- iterate the other two pointers nested\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        int diff = Integer.MAX_VALUE;\\n        int sum = 0;\\n        Arrays.sort(nums);\\n        // make i fixed\\n        for (int i = 0; i < nums.length; i++) {\\n            // two pointers for comparing values greater than i \\n            int j = i+1;\\n            int k = nums.length-1;\\n            \\n            // use two pointers j and k for every i\\n            while (j < k) {\\n                sum = nums[i] + nums[j] + nums[k];\\n                if (Math.abs(target-sum) < Math.abs(diff)) {\\n                    diff = target-sum;\\n                }\\n                if (sum < target) { // if our sum is lower than target, we want to move closer\\n                    j++;\\n                }\\n                else{ // if our sum is farther than target, we want to move closer\\n                    k--;\\n                }          \\n            }\\n\\n        }\\n        return target-diff; // target - diff is the most optimal sum, or we can use extra variable to store Best sum\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        int diff = Integer.MAX_VALUE;\\n        int sum = 0;\\n        Arrays.sort(nums);\\n        // make i fixed\\n        for (int i = 0; i < nums.length; i++) {\\n            // two pointers for comparing values greater than i \\n            int j = i+1;\\n            int k = nums.length-1;\\n            \\n            // use two pointers j and k for every i\\n            while (j < k) {\\n                sum = nums[i] + nums[j] + nums[k];\\n                if (Math.abs(target-sum) < Math.abs(diff)) {\\n                    diff = target-sum;\\n                }\\n                if (sum < target) { // if our sum is lower than target, we want to move closer\\n                    j++;\\n                }\\n                else{ // if our sum is farther than target, we want to move closer\\n                    k--;\\n                }          \\n            }\\n\\n        }\\n        return target-diff; // target - diff is the most optimal sum, or we can use extra variable to store Best sum\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1899603,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func threeSumClosest(_ nums: [Int], _ target: Int) -> Int {\\n        let sorted = nums.sorted()\\n        var i = 0\\n        var min = Int.max\\n        var res = Int.max\\n\\n        while i < sorted.count - 2 {\\n            var j = i + 1\\n            var k = sorted.count - 1\\n            while j < k {\\n                let sum = sorted[i] + sorted[j] + sorted[k]\\n                if sum == target {\\n                    return target\\n                }\\n                if sum < target {\\n                    j += 1\\n                } else {\\n                    k -= 1\\n                }\\n                let diff = abs(sum - target)\\n                if diff < min {\\n                    min = diff\\n                    res = sum\\n                }\\n            }\\n            i += 1\\n        }\\n        \\n        return res\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func threeSumClosest(_ nums: [Int], _ target: Int) -> Int {\\n        let sorted = nums.sorted()\\n        var i = 0\\n        var min = Int.max\\n        var res = Int.max\\n\\n        while i < sorted.count - 2 {\\n            var j = i + 1\\n            var k = sorted.count - 1\\n            while j < k {\\n                let sum = sorted[i] + sorted[j] + sorted[k]\\n                if sum == target {\\n                    return target\\n                }\\n                if sum < target {\\n                    j += 1\\n                } else {\\n                    k -= 1\\n                }\\n                let diff = abs(sum - target)\\n                if diff < min {\\n                    min = diff\\n                    res = sum\\n                }\\n            }\\n            i += 1\\n        }\\n        \\n        return res\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1675008,
                "title": "c-solution-with-explanations-brute-force-to-optimal-solution-explained",
                "content": "\\n> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- A basic approach using 3loops.\\n- We calculate the sum of 3 elements & store the difference of sum and target.\\n- If the difference is less than the minimum value we expected, then we\\u2019ll store the sum as ans.\\n- **Time complexity:** O(n^3).\\n\\n### Solution 02\\n\\n- Here we sort the array & will use 2 pointers to get the sum.\\n- Fix an index ***i*** & ***left=i+1, right=n-1.***\\n- If the sum of the 3 elements is less than the target, then we\\u2019ll shift the left pointer which will increase the value.\\n- Else we will shift right to decrease sum value.\\n- Also, we\\u2019ll calculate the difference and store in ***mn*** & update ***ans.***\\n- **Time complexity:** O(n^2).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        int sum, diff, ans, i=0, j=0, k=0, x=INT_MAX;\\n        while(i<n-2){\\n            sum = nums[i];\\n            j=i+1;\\n            while(j<n-1){\\n                sum += nums[j];\\n                k=j+1;\\n                while(k<n){\\n                    sum += nums[k];\\n                    diff = abs(target-sum);\\n                    if(diff<x){\\n                        x = diff;\\n                        ans = sum;\\n                    }\\n                    sum -= nums[k];\\n                    k++;\\n                }\\n                sum -= nums[j];\\n                j++;\\n            }i++;\\n        }\\n       \\n        return ans;\\n    }\\n};**\\n\\n//Solution 02:\\n**class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n= nums.size();\\n        int ans, sum, mn= INT_MAX;\\n        sort(nums.begin(), nums.end());\\n        \\n        for(int i=0; i<n-2; i++){\\n            int left = i+1;\\n            int right = n-1;\\n            while(left < right){\\n                sum = nums[i] + nums[left] + nums[right];\\n                if(sum == target)\\n                    return sum;\\n                else if(sum < target)\\n                    left++;\\n                else\\n                    right--;\\n                if( abs(sum - target) < mn){\\n                    ans = sum;\\n                    mn = abs(sum - target);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};**\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        int sum, diff, ans, i=0, j=0, k=0, x=INT_MAX;\\n        while(i<n-2){\\n            sum = nums[i];\\n            j=i+1;\\n            while(j<n-1){\\n                sum += nums[j];\\n                k=j+1;\\n                while(k<n){\\n                    sum += nums[k];\\n                    diff = abs(target-sum);\\n                    if(diff<x){\\n                        x = diff;\\n                        ans = sum;\\n                    }\\n                    sum -= nums[k];\\n                    k++;\\n                }\\n                sum -= nums[j];\\n                j++;\\n            }i++;\\n        }\\n       \\n        return ans;\\n    }\\n};**\\n\\n//Solution 02:\\n**class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n= nums.size();\\n        int ans, sum, mn= INT_MAX;\\n        sort(nums.begin(), nums.end());\\n        \\n        for(int i=0; i<n-2; i++){\\n            int left = i+1;\\n            int right = n-1;\\n            while(left < right){\\n                sum = nums[i] + nums[left] + nums[right];\\n                if(sum == target)\\n                    return sum;\\n                else if(sum < target)\\n                    left++;\\n                else\\n                    right--;\\n                if( abs(sum - target) < mn){\\n                    ans = sum;\\n                    mn = abs(sum - target);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1365863,
                "title": "python3-detailed-explanation-of-naive-2-pointer-solutions",
                "content": "## 0. Understanding the Problem\\nGiven:\\n- an array `nums`\\n- an integer `target`\\n\\nGoal: To find the sum of 3 numbers in `nums` that is closest to `target`.\\n\\nExample explaination:\\nnums = [-1,2,1,-4], target = 1\\n\\nThere are multiple possible combinations of which we have to find the minimum summing case. Infact there are nC3 total combinations.\\n\\nFor the given case, 2 is the solution, given by (-1, 2, 1).\\n\\n\\n## 1. Naive Solution\\nSince there are 3 numbers we need to take the sum of, we can simply loop and find the answer.\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        n = len(nums)\\n        ans = float(\\'inf\\')\\n        \\n        # three loops of O(N) each, giving \\n        # O(N^3) total time complexity\\n        # Space complexity is O(1)\\n        for i in range(n):\\n            for j in range(i+1, n):\\n                for k in range(j+1, n):\\n                    temp_sum = nums[i]+nums[j]+nums[k]\\n                    ans = min(ans, temp_sum, key=lambda x: abs(target-x))\\n        \\n        return ans\\n```\\n\\n## 2. Observations\\n- The question asks for the `sum` and not the three numbers/indices themselves, this means operations like **sorting** could help us.\\n- The sort function takes `O(Nlog(N))` time. (The space complexity depends on what algorithm you choose to use. Heap sort takes `O(1)` space (its in-place). Merge sort takes `O(N)` space.) This time is also lesser than `O(N^3)` and `O(N^2)`.\\n- Considering the array sorted, what more can we derive?\\n\\nOne possible Solution:\\nInstead of 3 nested loops, we can have two nested loops and one binary search running, taking time complexity `O(N^2log(N) + Nlog(N))`. Which is the same as `O(N^2log(N))`. This is clearly better than `O(N^3).`\\n\\nThere\\'s one last observation needed for the best solution. \\nThe purpose of the loop is to \"specify\" one variable. When we do `for i in range(n)`, we specify the value for `i` for the loops nested inside of it (think about it, its trivial). Once we specify three of the values, we can make a comparison with `target` and decide whether to make it answer or not. This is the logic behind the three nested loops of the naive solution.\\n\\nBUT, note how once the array is sorted, we have a definite measurement of how the elements are palced. We can reuse this fact and have **two pointers**. One from `i+1`, called `l` and the other from `n-1`, called `r`, both going in the opposite directions. `l` goes to the right and `r` to the left. We can **greedily search for the answer**!\\n\\n*Since the array is sorted, we can always decide whether to move the `l` or the `r` pointer.*\\n\\nHow? Let\\'s see below!\\n\\n## 3. Optimal Solution\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        n = len(nums)\\n        nums.sort()\\n        ans = float(\\'inf\\')\\n        for i in range(n-1):\\n            l, r = i+1, n-1 # starting the search\\n            while l < r:\\n                temp_sum = nums[l] + nums[r] + nums[i]\\n                # if we are above the target, reduce the bigger element\\n                if temp_sum > target: r -= 1\\n                # if we are below the target, increase the smaller element\\n                elif temp_sum < target: l += 1\\n                # if we are *at* the target, we have the best possible answer.\\n                else: return temp_sum\\n                ans = min(ans, temp_sum, key=lambda x: abs(target-x))\\n        return ans\\n```\\n\\nTime complexity: `O(Nlog(N) + N^2)`. `Nlog(N)` for the merge sort operation and `N^2` for the for loop & then the search from `l` to `r` (this will take up the entire range from `[i+1, n-1]`).\\n\\nSpace complexity: `O(N)` for the merge sort.\\n\\nQuestions? Feel free to ask below! Comments and criticisms are greatly appreciated. An upvote means this explaination helped you out :D\\n",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        n = len(nums)\\n        ans = float(\\'inf\\')\\n        \\n        # three loops of O(N) each, giving \\n        # O(N^3) total time complexity\\n        # Space complexity is O(1)\\n        for i in range(n):\\n            for j in range(i+1, n):\\n                for k in range(j+1, n):\\n                    temp_sum = nums[i]+nums[j]+nums[k]\\n                    ans = min(ans, temp_sum, key=lambda x: abs(target-x))\\n        \\n        return ans\\n```\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        n = len(nums)\\n        nums.sort()\\n        ans = float(\\'inf\\')\\n        for i in range(n-1):\\n            l, r = i+1, n-1 # starting the search\\n            while l < r:\\n                temp_sum = nums[l] + nums[r] + nums[i]\\n                # if we are above the target, reduce the bigger element\\n                if temp_sum > target: r -= 1\\n                # if we are below the target, increase the smaller element\\n                elif temp_sum < target: l += 1\\n                # if we are *at* the target, we have the best possible answer.\\n                else: return temp_sum\\n                ans = min(ans, temp_sum, key=lambda x: abs(target-x))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 7972,
                "title": "share-my-24-line-java-code-beats-94-57-run-times",
                "content": "    public class Solution {\\n        public int threeSumClosest(int[] nums, int target) {\\n            Arrays.sort(nums);\\n            int diff = Integer.MAX_VALUE, closest = 0;\\n            for (int k=0; k<nums.length-2; ++k) {\\n                for (int i=k+1, j=nums.length-1; i<j; ) {\\n                    int sum = nums[k] + nums[i] + nums[j];\\n                    if (sum == target) { return target; }\\n                    else if (sum > target) {\\n                        if (sum-target < diff) {\\n                            diff = sum-target;\\n                            closest = sum;\\n                        }\\n                        --j;\\n                    } else {\\n                        if (target-sum < diff) {\\n                            diff = target-sum;\\n                            closest = sum;\\n                        }\\n                        ++i;\\n                    }\\n                }\\n            }\\n            return closest;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int threeSumClosest(int[] nums, int target) {\\n            Arrays.sort(nums);\\n            int diff = Integer.MAX_VALUE, closest = 0;\\n            for (int k=0; k<nums.length-2; ++k) {\\n                for (int i=k+1, j=nums.length-1; i<j; ) {\\n                    int sum = nums[k] + nums[i] + nums[j];\\n                    if (sum == target) { return target; }",
                "codeTag": "Java"
            },
            {
                "id": 3471166,
                "title": "beats-93-beginner-friendly-cpp-and-python-code-easy-to-understand",
                "content": "# Intuition\\nPLZ upvote if you like this\\n\\n# Python Code\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n\\n        n=len(nums)\\n        nums.sort()\\n        diff=20001\\n        val=0\\n        for i in range(n):\\n            a=i+1\\n            b=n-1\\n            while(a<b):\\n                cc=nums[i]+nums[a]+nums[b]\\n                kk=abs(cc-target)\\n                if(kk<diff):\\n                    diff=kk\\n                    val=cc\\n                if(cc==target):\\n                    return target\\n                elif(cc<target):\\n                    a+=1\\n                else:\\n                    b-=1\\n            \\n        return val\\n```\\n\\n# CPP Code\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int diff=INT_MAX;\\n        int val=0;\\n        for (int i=0;i<n;i++){\\n            int a=i+1;\\n            int b=n-1;\\n            while(a<b){\\n                int cc=nums[i]+nums[a]+nums[b];\\n                int kk=abs(cc-target);\\n                if(kk<diff){\\n                    diff=kk;\\n                    val=cc;\\n                }\\n                if(cc==target){\\n                    return target;\\n                }\\n                else if(cc<target){\\n                    a++;\\n                }\\n                else{\\n                    b--;\\n                }\\n            }\\n        }\\n        return val;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n\\n        n=len(nums)\\n        nums.sort()\\n        diff=20001\\n        val=0\\n        for i in range(n):\\n            a=i+1\\n            b=n-1\\n            while(a<b):\\n                cc=nums[i]+nums[a]+nums[b]\\n                kk=abs(cc-target)\\n                if(kk<diff):\\n                    diff=kk\\n                    val=cc\\n                if(cc==target):\\n                    return target\\n                elif(cc<target):\\n                    a+=1\\n                else:\\n                    b-=1\\n            \\n        return val\\n```\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int diff=INT_MAX;\\n        int val=0;\\n        for (int i=0;i<n;i++){\\n            int a=i+1;\\n            int b=n-1;\\n            while(a<b){\\n                int cc=nums[i]+nums[a]+nums[b];\\n                int kk=abs(cc-target);\\n                if(kk<diff){\\n                    diff=kk;\\n                    val=cc;\\n                }\\n                if(cc==target){\\n                    return target;\\n                }\\n                else if(cc<target){\\n                    a++;\\n                }\\n                else{\\n                    b--;\\n                }\\n            }\\n        }\\n        return val;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381792,
                "title": "easy-java-approach-two-pointer-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort the input array nums to enable the two-pointer approach, which helps in efficiently finding the three integers with the closest sum to the target value.\\n\\nInitialize closestSum and minDiff to large values, as placeholders for the closest sum and minimum difference between sum and target, respectively.\\n\\nLoop through the array from index 0 to nums.length - 2, as the three-pointer approach requires at least three elements to find a sum.\\n\\nInside the loop, set up two pointers, left and right, to the elements immediately after the current element and the last element of the array, respectively.\\n\\nUse a while loop to continuously move the left and right pointers towards each other until they meet or cross each other.\\n\\nCalculate the current sum by adding the values at the current element, nums[left], and nums[right].\\n\\nCalculate the absolute difference between the current sum and the target value, and update minDiff and closestSum if the current difference is smaller than the previous minimum difference.\\n\\nIf the current sum is less than the target, increment the left pointer to consider a larger value.\\n\\nIf the current sum is greater than the target, decrement the right pointer to consider a smaller value.\\n\\nIf the current sum is equal to the target, return it as the closest sum.\\n\\nAfter the loop completes, return the closestSum as the final result, which represents the three integers in the array whose sum is closest to the target value. Note that the returned value may be greater or smaller than the target, depending on the input array and target value. Thus, the caller can check the actual difference between the returned sum and the target value if needed. Also, note that this code assumes that the input array nums has at least three elements. If that\\'s not guaranteed, appropriate error handling or input validation should be added. Additionally, the code assumes that the\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums); // Sort the array to enable two-pointer approach\\n        int closestSum = Integer.MAX_VALUE; // Initialize closest sum to a large value\\n        int minDiff = Integer.MAX_VALUE; // Initialize minimum difference to a large value\\n\\n        for (int i = 0; i < nums.length - 2; i++) {\\n            int left = i + 1; // Pointer for the element on the left\\n            int right = nums.length - 1; // Pointer for the element on the right\\n\\n            while (left < right) {\\n                int sum = nums[i] + nums[left] + nums[right]; // Calculate the current sum\\n\\n                int diff = Math.abs(sum - target); // Calculate the absolute difference between current sum and target\\n                if (diff < minDiff) { // Update the minimum difference and closest sum if necessary\\n                    minDiff = diff;\\n                    closestSum = sum;\\n                }\\n\\n                if (sum < target) {\\n                    left++; // If current sum is less than target, increment the left pointer\\n                } else if (sum > target) {\\n                    right--; // If current sum is greater than target, decrement the right pointer\\n                } else {\\n                    return sum; // If current sum is equal to target, return it as the closest sum\\n                }\\n            }\\n        }\\n\\n        return closestSum; // Return the closest sum after traversing the entire array\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\n\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums); // Sort the array to enable two-pointer approach\\n        int closestSum = Integer.MAX_VALUE; // Initialize closest sum to a large value\\n        int minDiff = Integer.MAX_VALUE; // Initialize minimum difference to a large value\\n\\n        for (int i = 0; i < nums.length - 2; i++) {\\n            int left = i + 1; // Pointer for the element on the left\\n            int right = nums.length - 1; // Pointer for the element on the right\\n\\n            while (left < right) {\\n                int sum = nums[i] + nums[left] + nums[right]; // Calculate the current sum\\n\\n                int diff = Math.abs(sum - target); // Calculate the absolute difference between current sum and target\\n                if (diff < minDiff) { // Update the minimum difference and closest sum if necessary\\n                    minDiff = diff;\\n                    closestSum = sum;\\n                }\\n\\n                if (sum < target) {\\n                    left++; // If current sum is less than target, increment the left pointer\\n                } else if (sum > target) {\\n                    right--; // If current sum is greater than target, decrement the right pointer\\n                } else {\\n                    return sum; // If current sum is equal to target, return it as the closest sum\\n                }\\n            }\\n        }\\n\\n        return closestSum; // Return the closest sum after traversing the entire array\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070001,
                "title": "easiest-c-solution-using-for-loop-and-binary-search",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\nsort(nums.begin(), nums.end());\\nint n=nums.size();\\nint mn=INT_MAX;\\nint ans=0;\\n\\nfor(int i=0; i<nums.size(); i++){\\n    int start=i+1;\\n    int end=n-1;\\n    while(start<end){\\nint sum=nums[i]+nums[start]+nums[end];\\nint diff=abs(sum-target);\\n\\nif(diff<mn){\\nmn=diff;\\nans=sum;\\n    }\\nif(sum>target)\\nend--;\\n\\nelse start++;\\n\\n} \\n}\\n   return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\nsort(nums.begin(), nums.end());\\nint n=nums.size();\\nint mn=INT_MAX;\\nint ans=0;\\n\\nfor(int i=0; i<nums.size(); i++){\\n    int start=i+1;\\n    int end=n-1;\\n    while(start<end){\\nint sum=nums[i]+nums[start]+nums[end];\\nint diff=abs(sum-target);\\n\\nif(diff<mn){\\nmn=diff;\\nans=sum;\\n    }\\nif(sum>target)\\nend--;\\n\\nelse start++;\\n\\n} \\n}\\n   return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2297535,
                "title": "python-two-pointer-solution-sped-up-with-binary-search-avoiding-tle",
                "content": "This solution runs in around 250ms to 300ms (faster than 80%) https://leetcode.com/submissions/detail/749879788/. Other two two-pointer solutions tend to be TLE since the new test cases were added. \\nIn the 3sum solution the update rule starts with\\n```\\nk = i+1\\nj = len(nums) - 1\\n```\\nand then increments these:\\n```\\nif nums[i] + nums[k] + nums[j] < target:\\n  k+=1\\nelse:\\n  j-=1\\n```\\nHowever, instead of updating these incrementally we can directly fast-forward them using binary search. i.e. at minimum nums[k] would have to be to flip the if statement is target - num[i] - nums[j]. The same logic can be applied to update j using binary search. \\n```\\ndef threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n \\n        best = None\\n        \\n        # The window is: [i, k, j]\\n        # Valid range for i:\\n        for i in range(0, len(nums) - 2):\\n            # Instead of incrementaly updating the j and k,\\n            # we can use binary search to find the next viable value\\n            # for each.\\n            # We pingpong between updating j and k\\n            pingpong = 0\\n            \\n            # Pick a k (j will be overriden on first pass)\\n            k = i+1\\n            j = len(nums)\\n\\n            while j > i + 2:\\n                if pingpong%2 == 0:\\n                    # Decrease j until sum can be less than target\\n                    targetVal = target - nums[i] - nums[k]\\n                    newj = bisect_left(nums, targetVal, k+1, j-1)\\n                    # There is no possible update to j, can stop\\n                    # searching\\n                    if newj == j:\\n                        break\\n                    j = newj\\n                    pingpong += 1\\n                else:\\n                    # Increase k until sum can exceed target\\n                    targetVal = target - nums[i] - nums[j]\\n                    k = bisect_left(nums, targetVal, i+1, j-1)\\n                    if nums[k] > targetVal and k > i+1:\\n                        k = k - 1\\n                    pingpong += 1\\n\\n                new = nums[i] + nums[k] + nums[j]\\n                if best is None or (abs(best - target) > abs(target - new)):\\n                    best = new\\n\\n                if best == target:\\n                    return target\\n\\n        return best",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nk = i+1\\nj = len(nums) - 1\\n```\n```\\nif nums[i] + nums[k] + nums[j] < target:\\n  k+=1\\nelse:\\n  j-=1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2674384,
                "title": "python-solution-defeat-the-new-test-cases",
                "content": "```\\nfrom typing import List\\n\\n\\nclass Solution:\\n    \\'\\'\\'\\n    First sort the nums\\n    Then use two pointer algorithm to find the closest 3 sum\\n    We can optimize the code by first checking the smallest and largest within the testing window [i+1:n]: nums[i] + (nums[i+1] + nums[i+2]) and nums[i] + (nums[n-2] + nums[n-1]) actually envelope target\\n    Otherwise we just proceed to the next i    \\n    \\'\\'\\'\\n\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        result, n = float(\\'inf\\'), len(nums)\\n        for i in range(n-2):\\n            S1 = nums[i] + nums[i+1] + nums[i+2]\\n            S2 = nums[i] + nums[n-2] + nums[n-1]\\n            candidates = [result, S1, S2]\\n            result = min(candidates, key = lambda x: abs(x-target))            \\n            if S1 <= target <= S2:\\n                left, right = i+1, n-1\\n                while left < right:\\n                    S = nums[i] + nums[left] + nums[right]\\n                    candidates = [result, S]\\n                    result = min(candidates, key = lambda x: abs(x-target))\\n                    if S == target:\\n                        return target\\n                    elif S < target:\\n                        left += 1\\n                    else:\\n                        right -= 1\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom typing import List\\n\\n\\nclass Solution:\\n    \\'\\'\\'\\n    First sort the nums\\n    Then use two pointer algorithm to find the closest 3 sum\\n    We can optimize the code by first checking the smallest and largest within the testing window [i+1:n]: nums[i] + (nums[i+1] + nums[i+2]) and nums[i] + (nums[n-2] + nums[n-1]) actually envelope target\\n    Otherwise we just proceed to the next i    \\n    \\'\\'\\'\\n\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        result, n = float(\\'inf\\'), len(nums)\\n        for i in range(n-2):\\n            S1 = nums[i] + nums[i+1] + nums[i+2]\\n            S2 = nums[i] + nums[n-2] + nums[n-1]\\n            candidates = [result, S1, S2]\\n            result = min(candidates, key = lambda x: abs(x-target))            \\n            if S1 <= target <= S2:\\n                left, right = i+1, n-1\\n                while left < right:\\n                    S = nums[i] + nums[left] + nums[right]\\n                    candidates = [result, S]\\n                    result = min(candidates, key = lambda x: abs(x-target))\\n                    if S == target:\\n                        return target\\n                    elif S < target:\\n                        left += 1\\n                    else:\\n                        right -= 1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1467590,
                "title": "javascript-99",
                "content": "Doing the Blind 75 List and posting all solutions.\\n\\n```\\nvar threeSumClosest = function(nums, target) {\\n  nums.sort((x, y) => x - y);\\n  let closest = Infinity;\\n  \\n  //Iterate through until 2 from end because there will be two pointers after\\n  //this idx to find threesums.\\n  for (let i = 0; i < nums.length - 2; i++) {\\n  \\n\\t//Stops us from doing repeat work.  If i is same as last, we have\\n\\t//Already checked all perms.\\n    if (i > 0 && nums[i] === nums[i - 1]) continue;\\n    let left = i + 1, right = nums.length - 1;\\n    while (left < right) {\\n      const total = nums[i] + nums[left] + nums[right];\\n\\t  \\n\\t  //If found, return target.\\n      if (total === target) return target;\\n\\t  \\n\\t  //Otherwise set closest to min of distance between current total and target, or \\n\\t  //previous closest.\\n      closest = Math.abs(target - closest) < Math.abs(target - total) ? closest : total;\\n\\t  \\n\\t  //If current total is less than target, we know we need a higher number and arr\\n\\t  //is sorted.  Incrementing left pointer and looping until we find a unique val\\n\\t  //gives us the next highest number.  Side Note:  For this problem and the LC tests,\\n\\t  //we do not need the loop in this block.  For larger data sets, it could save us from\\n\\t  //a lot of repeat work though.  I left it in because I think it\\'s a nice addition.  Feel free\\n\\t  //to remove if you want though.  Won\\'t change performance on LC test cases much.\\n      if (total < target) {\\n        left++;\\n        while(left < right && nums[i] === nums[i - 1]) left++;\\n      } else {\\n        right--;\\n        while (left < right && nums[right] === nums[right + 1]) right--;\\n      }\\n    }\\n  }\\n  return closest;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar threeSumClosest = function(nums, target) {\\n  nums.sort((x, y) => x - y);\\n  let closest = Infinity;\\n  \\n  //Iterate through until 2 from end because there will be two pointers after\\n  //this idx to find threesums.\\n  for (let i = 0; i < nums.length - 2; i++) {\\n  \\n\\t//Stops us from doing repeat work.  If i is same as last, we have\\n\\t//Already checked all perms.\\n    if (i > 0 && nums[i] === nums[i - 1]) continue;\\n    let left = i + 1, right = nums.length - 1;\\n    while (left < right) {\\n      const total = nums[i] + nums[left] + nums[right];\\n\\t  \\n\\t  //If found, return target.\\n      if (total === target) return target;\\n\\t  \\n\\t  //Otherwise set closest to min of distance between current total and target, or \\n\\t  //previous closest.\\n      closest = Math.abs(target - closest) < Math.abs(target - total) ? closest : total;\\n\\t  \\n\\t  //If current total is less than target, we know we need a higher number and arr\\n\\t  //is sorted.  Incrementing left pointer and looping until we find a unique val\\n\\t  //gives us the next highest number.  Side Note:  For this problem and the LC tests,\\n\\t  //we do not need the loop in this block.  For larger data sets, it could save us from\\n\\t  //a lot of repeat work though.  I left it in because I think it\\'s a nice addition.  Feel free\\n\\t  //to remove if you want though.  Won\\'t change performance on LC test cases much.\\n      if (total < target) {\\n        left++;\\n        while(left < right && nums[i] === nums[i - 1]) left++;\\n      } else {\\n        right--;\\n        while (left < right && nums[right] === nums[right + 1]) right--;\\n      }\\n    }\\n  }\\n  return closest;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1365667,
                "title": "python-two-pointers-2sum-explained",
                "content": "Very similar to the problem **15**, also 2 pointers idea. Now, instead of looking for sums equal to `target`, we perform 2 pointers and look for sums which are around `target`, that is if sum becomes bigger than `target` we move end pointer and in opposite case we move beg pointer. \\n\\n#### Complexity\\nTime complexity is `O(n^2)`, space is `O(n)` or `O(log n)` depening on sort function.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def threeSumClosest(self, nums, target):\\n        nums.sort()\\n        n, ans = len(nums), float(\"inf\")\\n\\n        for i in range(n):\\n            beg, end = i + 1, n - 1\\n\\n            while beg < end:\\n                sm = nums[beg] + nums[end] + nums[i]\\n                ans = min(ans, sm, key = lambda x: abs(x - target))\\n        \\n                if sm <= target:\\n                    beg += 1\\n                elif sm > target:\\n                    end -= 1\\n\\n        return ans\\n```\\n\\n#### Remark\\nThere are couple of optimization to make it work faster: `if ans == target: break` before the last return statement, and not using lambda functions to get min.\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**\\n",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```python\\nclass Solution:\\n    def threeSumClosest(self, nums, target):\\n        nums.sort()\\n        n, ans = len(nums), float(\"inf\")\\n\\n        for i in range(n):\\n            beg, end = i + 1, n - 1\\n\\n            while beg < end:\\n                sm = nums[beg] + nums[end] + nums[i]\\n                ans = min(ans, sm, key = lambda x: abs(x - target))\\n        \\n                if sm <= target:\\n                    beg += 1\\n                elif sm > target:\\n                    end -= 1\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1317287,
                "title": "c-solution-with-proper-explaination",
                "content": "This problem is variation of **2 sum**  poblem where we need to find the pairs equivalent to the given target.\\nThe 2 sum problem is further extended to **3 sum** where we need to return the tripet of array which is equal to 0.\\nHow this problem 3 sum closest is extension of 3 sum : \\nhere we just need to find three integers of nums vector that has closest sum to the given target.**\\n\\n**Steps to find closest 3 sum to the given target:**\\n1) sort the array(through sorting we can increase the efficiency of the solution)\\n   unless and until the array is sorted applying two pointer doesn\\'t make sense.\\n2)  use two pointer approach \\n3)  make a left pointing next to i and a right pointer at the end of it\\n4)  make a curr_sum variable \\n5)  check for the condition if target - curr_sum < min_diff\\n6)  if curr_sum > target than decrement the right pointer \\n7)  else increment left pointer.\\n **Time complexity - O(N^2)** \\n **space complexity - O(1)** as no extra space required\\n\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        \\n        int min_difference = INT_MAX;\\n        int result =0;\\n        for(int i =0; i< nums.size() ; i++){\\n           int left = i +1; \\n            int right = nums.size()-1;\\n            \\n            while(left < right){\\n                \\n                int curr_sum = nums[i] + nums[left]+ nums[right];\\n                if(abs(target - curr_sum) < min_difference ){\\n                      min_difference = abs(target - curr_sum);\\n                      result = curr_sum;\\n                }\\n                if( curr_sum > target) right--;\\n                else{\\n                    left++;\\n                }\\n               if(target == curr_sum) return result;\\n            }\\n        }\\n        return result;\\n    }\\n    \\n};\\n```\\n**please upvote if you like the  solution and do comment if have doubts**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        \\n        int min_difference = INT_MAX;\\n        int result =0;\\n        for(int i =0; i< nums.size() ; i++){\\n           int left = i +1; \\n            int right = nums.size()-1;\\n            \\n            while(left < right){\\n                \\n                int curr_sum = nums[i] + nums[left]+ nums[right];\\n                if(abs(target - curr_sum) < min_difference ){\\n                      min_difference = abs(target - curr_sum);\\n                      result = curr_sum;\\n                }\\n                if( curr_sum > target) right--;\\n                else{\\n                    left++;\\n                }\\n               if(target == curr_sum) return result;\\n            }\\n        }\\n        return result;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 159459,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def threeSumClosest(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        nums = sorted(nums)\\n        curr = nums[0] + nums[1] + nums[len(nums)-1]\\n        for i in range(len(nums)-2):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            l = i+1\\n            r = len(nums) - 1\\n            while l < r:\\n                val = nums[i] + nums[l] + nums[r]\\n                if abs(val - target) < abs(curr - target):\\n                    curr = val\\n                if val == target:\\n                    return target\\n                elif val < target:\\n                    l += 1\\n                else:\\n                    r -= 1\\n        return curr\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def threeSumClosest(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        nums = sorted(nums)\\n        curr = nums[0] + nums[1] + nums[len(nums)-1]\\n        for i in range(len(nums)-2):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            l = i+1\\n            r = len(nums) - 1\\n            while l < r:\\n                val = nums[i] + nums[l] + nums[r]\\n                if abs(val - target) < abs(curr - target):\\n                    curr = val\\n                if val == target:\\n                    return target\\n                elif val < target:\\n                    l += 1\\n                else:\\n                    r -= 1\\n        return curr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 8022,
                "title": "4-ms-c-solution-sample",
                "content": "    #define ABS(x) ((x)<0?-(x):(x))\\n    \\n    int comparefn( const void* a, const void* b)\\n    {\\n         int int_a = * ( (int*) a );\\n         int int_b = * ( (int*) b );\\n    \\n         if ( int_a == int_b ) return 0;\\n         else if ( int_a < int_b ) return -1;\\n         else return 1;\\n    }\\n    \\n    int threeSumClosest(int* nums, int numsSize, int target) {\\n        // sort the array\\n        qsort(nums, numsSize, sizeof(int), comparefn);\\n        int i, j, k, diff, min_diff = INT_MAX;\\n        for(i = 0 ; i < numsSize ; i++)\\n        {\\n            j = i + 1;\\n            k = numsSize - 1;\\n            while(j < k)\\n            {\\n                diff = nums[i] + nums[j] + nums[k] - target;\\n                //temp = ABS(temp);\\n                if(diff == 0)\\n                {\\n                    return target;\\n                }\\n                else\\n                {\\n                    if(ABS(diff) < ABS(min_diff))\\n                    {\\n                        min_diff = diff;\\n                    }\\n                    if(diff < 0)\\n                    {// increase value\\n                        j++;\\n                    }\\n                    else//>0\\n                    {\\n                        k--;\\n                    }\\n                }\\n            }\\n        }\\n        return target + min_diff;\\n    }",
                "solutionTags": [],
                "code": "    #define ABS(x) ((x)<0?-(x):(x))\\n    \\n    int comparefn( const void* a, const void* b)\\n    {\\n         int int_a = * ( (int*) a );\\n         int int_b = * ( (int*) b );\\n    \\n         if ( int_a == int_b ) return 0;\\n         else if ( int_a < int_b ) return -1;\\n         else return 1;\\n    }\\n    \\n    int threeSumClosest(int* nums, int numsSize, int target) {\\n        // sort the array\\n        qsort(nums, numsSize, sizeof(int), comparefn);\\n        int i, j, k, diff, min_diff = INT_MAX;\\n        for(i = 0 ; i < numsSize ; i++)\\n        {\\n            j = i + 1;\\n            k = numsSize - 1;\\n            while(j < k)\\n            {\\n                diff = nums[i] + nums[j] + nums[k] - target;\\n                //temp = ABS(temp);\\n                if(diff == 0)\\n                {\\n                    return target;\\n                }\\n                else\\n                {\\n                    if(ABS(diff) < ABS(min_diff))\\n                    {\\n                        min_diff = diff;\\n                    }\\n                    if(diff < 0)\\n                    {// increase value\\n                        j++;\\n                    }\\n                    else//>0\\n                    {\\n                        k--;\\n                    }\\n                }\\n            }\\n        }\\n        return target + min_diff;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3448416,
                "title": "c-very-easy-solution-beginner-friendly-two-pointers",
                "content": "<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int calcu = INT_MAX;\\n        int ans = 0;\\n        int n = nums.size() ;\\n        sort( nums.begin() , nums.end() );\\n        for( int i=0 ; i<n-2 ; i++ )\\n        {\\n            int l = i+1 ;\\n            int r = n-1 ;\\n            while( l<r )\\n            {\\n                int sum = nums[i]+nums[l]+nums[r];\\n                int temp = abs( sum - target );\\n                if( temp<calcu )\\n                {\\n                    calcu = temp ;\\n                    ans = sum;\\n                }\\n                if( sum==target )\\n                {\\n                    return sum;\\n                }\\n                else if( sum<target )\\n                {\\n                    l++;\\n                }\\n                else\\n                {\\n                    r--;\\n                }\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n//<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int calcu = INT_MAX;\\n        int ans = 0;\\n        int n = nums.size() ;\\n        sort( nums.begin() , nums.end() );\\n        for( int i=0 ; i<n-2 ; i++ )\\n        {\\n            int l = i+1 ;\\n            int r = n-1 ;\\n            while( l<r )\\n            {\\n                int sum = nums[i]+nums[l]+nums[r];\\n                int temp = abs( sum - target );\\n                if( temp<calcu )\\n                {\\n                    calcu = temp ;\\n                    ans = sum;\\n                }\\n                if( sum==target )\\n                {\\n                    return sum;\\n                }\\n                else if( sum<target )\\n                {\\n                    l++;\\n                }\\n                else\\n                {\\n                    r--;\\n                }\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n//<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404344,
                "title": "java-solution-two-pointer",
                "content": "# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int minDistance = Integer.MAX_VALUE;\\n        int closestSum = 0;\\n\\n        for(int i = 0; i < nums.length - 2; i++) {\\n            int start = i + 1;\\n            int end = nums.length - 1;\\n\\n            while(start < end) {\\n                int sum = nums[i] + nums[start] + nums[end];\\n                int distance = Math.abs(target - sum);\\n\\n                if(sum == target) {\\n                    return sum;\\n                }  \\n\\n                if(distance < minDistance) {\\n                    minDistance = distance;\\n                    closestSum = sum;\\n                }\\n\\n                if(sum < target) {\\n                    start++;\\n                } else {\\n                    end--;\\n                }\\n            }\\n        }\\n        return closestSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int minDistance = Integer.MAX_VALUE;\\n        int closestSum = 0;\\n\\n        for(int i = 0; i < nums.length - 2; i++) {\\n            int start = i + 1;\\n            int end = nums.length - 1;\\n\\n            while(start < end) {\\n                int sum = nums[i] + nums[start] + nums[end];\\n                int distance = Math.abs(target - sum);\\n\\n                if(sum == target) {\\n                    return sum;\\n                }  \\n\\n                if(distance < minDistance) {\\n                    minDistance = distance;\\n                    closestSum = sum;\\n                }\\n\\n                if(sum < target) {\\n                    start++;\\n                } else {\\n                    end--;\\n                }\\n            }\\n        }\\n        return closestSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678631,
                "title": "this-brute-force-solution-is-fast-and-here-is-why",
                "content": "## The solution\\n\\nMost solutions in the discussion are O(n^2) and take about 500ms+ in python3, some even got TLE if it lacks some early-stopping checks. However, the solution from here https://leetcode.com/problems/3sum-closest/discuss/778177/Python3-%3A-Runtime%3A-52-ms-faster-than-99.77, while using a brute-force approach, can reach under 200ms, which is significantly faster than other theoretically better O(n^2) solutions. His solution is as follow:\\n\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        return self.KSumClosest(nums, 3, target)\\n\\n    def KSumClosest(self, nums: List[int], k: int, target: int) -> int:\\n        N = len(nums)\\n        if N == k:\\n            return sum(nums[:k])\\n\\n        # target too small\\n        current = sum(nums[:k])\\n        if current >= target:\\n            return current\\n\\n        # target too big\\n        current = sum(nums[-k:])\\n        if current <= target:\\n            return current\\n        \\n        if k == 1:\\n            return min([(x, abs(target - x)) for x in nums], key = lambda x: x[1])[0]\\n\\n        closest = sum(nums[:k])\\n        for i, x in enumerate(nums[:-k+1]):\\n            if i>0 and x == nums[i-1]:\\n                continue\\n            current = self.KSumClosest(nums[i+1:], k-1, target - x) + x\\n            if abs(target - current) < abs(target - closest):\\n                if current == target:\\n                    return target\\n                else:\\n                    closest = current\\n\\n        return closest\\n```\\n\\n## Why on earth it is so fast ?\\nThe reason is smart prunning, more specifially these 2 checks speed up the code significantly:\\n```\\n        # target too small\\n        current = sum(nums[:k])\\n        if current >= target:\\n            return current\\n\\n        # target too big\\n        current = sum(nums[-k:])\\n        if current <= target:\\n            return current\\n```\\nAnd to understand this, let\\'s look at some math. \\n\\nMathematically, if elements in nums are uniformly distributed then the distribution of all possible 3sum would be a bell curve that looks look like this. This is called [Irwin\\u2013Hall distribution or uniform sum distribution.](https://en.wikipedia.org/wiki/Irwin\\u2013Hall_distribution)\\n\\n![image](https://assets.leetcode.com/users/images/9349442b-52d4-4d30-80c5-e82f93ffd73e_1665281362.0298378.png)\\n \\nSo a random target would likely to be close to the mean of all possible 3sum, which means it would lie near the middle of the bell curve. So these 2 above checks essentially bypass many candidates that are too big (sum of numbers near the end) or too small (sum of numbers near the start). And by using recursion, this logic is applied at every k, effectively pruning a lot of cases. \\n\\nYou can check this by counting the number of times these 2 checks help the function return early.\\n\\n## Make it even faster\\n\\nBut that\\'s not all, the solution can be further optimized by changing the linear search in the base case\\n```\\n        if k == 1:\\n            return min([(x, abs(target - x)) for x in nums], key = lambda x: x[1])[0]\\n```\\nto binary search\\n```\\n        if k == 1:\\n            idx = bisect.bisect_right(nums, target)\\n            if idx == len(nums) or idx > 0 and nums[idx] - target > target - nums[idx - 1]:\\n                return nums[idx - 1]\\n            return nums[idx]\\n```\\nThis in theory is faster than the original solution. However for `len(nums) < 1000` which is small, the improvement is neligible.  \\n\\n## Final words\\nI think it is important to understand thoroughly why a solution is fast, rather than just judging it based solely on the big-O upper bound. \\n\\nIf you find this helpful, please leave  an upvote. Thank you",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        return self.KSumClosest(nums, 3, target)\\n\\n    def KSumClosest(self, nums: List[int], k: int, target: int) -> int:\\n        N = len(nums)\\n        if N == k:\\n            return sum(nums[:k])\\n\\n        # target too small\\n        current = sum(nums[:k])\\n        if current >= target:\\n            return current\\n\\n        # target too big\\n        current = sum(nums[-k:])\\n        if current <= target:\\n            return current\\n        \\n        if k == 1:\\n            return min([(x, abs(target - x)) for x in nums], key = lambda x: x[1])[0]\\n\\n        closest = sum(nums[:k])\\n        for i, x in enumerate(nums[:-k+1]):\\n            if i>0 and x == nums[i-1]:\\n                continue\\n            current = self.KSumClosest(nums[i+1:], k-1, target - x) + x\\n            if abs(target - current) < abs(target - closest):\\n                if current == target:\\n                    return target\\n                else:\\n                    closest = current\\n\\n        return closest\\n```\n```\\n        # target too small\\n        current = sum(nums[:k])\\n        if current >= target:\\n            return current\\n\\n        # target too big\\n        current = sum(nums[-k:])\\n        if current <= target:\\n            return current\\n```\n```\\n        if k == 1:\\n            return min([(x, abs(target - x)) for x in nums], key = lambda x: x[1])[0]\\n```\n```\\n        if k == 1:\\n            idx = bisect.bisect_right(nums, target)\\n            if idx == len(nums) or idx > 0 and nums[idx] - target > target - nums[idx - 1]:\\n                return nums[idx - 1]\\n            return nums[idx]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2677097,
                "title": "java-sort-and-two-pointers",
                "content": "# Intuition\\nWe need to find the closest triplet that sums to target.\\n\\nThe brute force way is to iterate `O(n^3)` and to try all triplets. We can do better.\\n\\nIf we were working with pairs instead, we could do this with a two pointer technique if we had a monotonic order array. For example if our array is `[-2,0,1,3,4,6,7]` and our target is `2` we can initialize two pointers in the beginning and in the end. Then we would move left pointer up (increase sum) or move right pointer down (decrease sum) this way we would iterate over the search space trying to converge to target in `O(n)`.\\n\\nWe can extend this algorithm to search a triplet. To do this, we will iterate our array and by doing this we will fix an element `i` at every iteration. Then all we have to do is find a pair(+ the fixed element) that sum closest to the target. This is exactly the process we described above.\\n\\nTo make the two pointer technique work we need to sort our array, otherwise we can\\'t rely on getting closer to the target by moving the pointers left or right.\\n\\n# Code\\n```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        int n = nums.length;\\n        \\n        // Sort - nlogn\\n        Arrays.sort(nums);\\n        \\n        // Two pointer closing with fixed element\\n        int closest = Integer.MAX_VALUE;\\n        \\n        for (int i = 0; i <= n - 3; i++) {\\n            int left = i + 1;\\n            int right = n - 1;\\n            \\n            while (left < right) {\\n                int current_triplet_sum = nums[i] + nums[left] + nums[right];\\n                \\n                // Update\\n                if (Math.abs(target - closest) > Math.abs(target - current_triplet_sum)) {\\n                    closest = current_triplet_sum;\\n                }\\n                \\n                // Move pointers\\n                if (current_triplet_sum < target) {\\n                    left++;\\n                }\\n                else {\\n                    right--;\\n                }\\n            }\\n        }\\n        \\n        return closest;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        int n = nums.length;\\n        \\n        // Sort - nlogn\\n        Arrays.sort(nums);\\n        \\n        // Two pointer closing with fixed element\\n        int closest = Integer.MAX_VALUE;\\n        \\n        for (int i = 0; i <= n - 3; i++) {\\n            int left = i + 1;\\n            int right = n - 1;\\n            \\n            while (left < right) {\\n                int current_triplet_sum = nums[i] + nums[left] + nums[right];\\n                \\n                // Update\\n                if (Math.abs(target - closest) > Math.abs(target - current_triplet_sum)) {\\n                    closest = current_triplet_sum;\\n                }\\n                \\n                // Move pointers\\n                if (current_triplet_sum < target) {\\n                    left++;\\n                }\\n                else {\\n                    right--;\\n                }\\n            }\\n        }\\n        \\n        return closest;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1810579,
                "title": "c-easy-to-understand-simple-tc-o-n-2-sc-o-1-100",
                "content": "**upvote if you like the solution**\\n````\\nint threeSumClosest(vector<int>& nums, int target) {\\n        int ans=0,mn=INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=nums.size()-1;i>1;--i){\\n            int j=0,k=i-1;\\n            while(j<k){\\n                int sm=nums[i]+nums[j]+nums[k];\\n                if(abs(target-sm)<mn){\\n                    mn=abs(target-sm);\\n                    ans=sm;\\n                }\\n                if(sm>target) k--;\\n                else if(sm<target) j++;\\n                else return ans;\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "**upvote if you like the solution**\\n````\\nint threeSumClosest(vector<int>& nums, int target) {\\n        int ans=0,mn=INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=nums.size()-1;i>1;--i){\\n            int j=0,k=i-1;\\n            while(j<k){\\n                int sm=nums[i]+nums[j]+nums[k];\\n                if(abs(target-sm)<mn){\\n                    mn=abs(target-sm);\\n                    ans=sm;\\n                }\\n                if(sm>target) k--;\\n                else if(sm<target) j++;\\n                else return ans;\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 451359,
                "title": "python-easy-approach-beats-100-memory",
                "content": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        if not nums:\\n            return None\\n        \\n        diff=float(\\'inf\\')\\n        nums.sort()\\n        \\n        for i in range(len(nums)-2):\\n            p1=i+1\\n            p2=len(nums)-1\\n            \\n            while p1<p2:\\n                s=nums[i]+nums[p1]+nums[p2]\\n                if abs(s-target) < diff:\\n                    diff=abs(s-target)\\n                    output=s\\n                \\n                if s<target:\\n                    p1+=1\\n                elif s>target:\\n                    p2-=1\\n                else:\\n                    return target\\n        return output        \\n    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        if not nums:\\n            return None\\n        \\n        diff=float(\\'inf\\')\\n        nums.sort()\\n        \\n        for i in range(len(nums)-2):\\n            p1=i+1\\n            p2=len(nums)-1\\n            \\n            while p1<p2:\\n                s=nums[i]+nums[p1]+nums[p2]\\n                if abs(s-target) < diff:\\n                    diff=abs(s-target)\\n                    output=s\\n                \\n                if s<target:\\n                    p1+=1\\n                elif s>target:\\n                    p2-=1\\n                else:\\n                    return target\\n        return output        \\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 278202,
                "title": "c-two-pointers",
                "content": "```\\npublic class Solution {\\n    public int ThreeSumClosest(int[] nums, int target) {\\n        Array.Sort(nums);\\n        var n = nums.Length;\\n\\n        var globalClosest = int.MaxValue;\\n        var globalSum = 0;\\n        for (int i = 0; i < n; i++) {\\n            var left = i + 1;\\n            var right = n - 1;\\n\\n            while (left < right) {\\n                var sum = nums[i] + nums[left] + nums[right];\\n                var localClosest = Math.Abs(sum - target);\\n                if (sum == target) {\\n                    return target;\\n                } else if (sum < target) {\\n                    left++;\\n                } else {\\n                    right--;\\n                }\\n\\n                if (globalClosest > localClosest) {\\n                    globalClosest = localClosest;\\n                    globalSum = sum;\\n                }\\n            }\\n\\n        }\\n\\n        return globalSum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int ThreeSumClosest(int[] nums, int target) {\\n        Array.Sort(nums);\\n        var n = nums.Length;\\n\\n        var globalClosest = int.MaxValue;\\n        var globalSum = 0;\\n        for (int i = 0; i < n; i++) {\\n            var left = i + 1;\\n            var right = n - 1;\\n\\n            while (left < right) {\\n                var sum = nums[i] + nums[left] + nums[right];\\n                var localClosest = Math.Abs(sum - target);\\n                if (sum == target) {\\n                    return target;\\n                } else if (sum < target) {\\n                    left++;\\n                } else {\\n                    right--;\\n                }\\n\\n                if (globalClosest > localClosest) {\\n                    globalClosest = localClosest;\\n                    globalSum = sum;\\n                }\\n            }\\n\\n        }\\n\\n        return globalSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4083996,
                "title": "best-o-n-2-solution",
                "content": "# Approach\\nSorting & Two Pointer \\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        sort (nums.begin(), nums.end());\\n        int sum = 0, prevDiff = INT_MAX;\\n        for (int i = 0; i < n - 2; i++) {\\n            int left = i + 1, right = n - 1;\\n            while (left < right) {\\n                int curSum = nums[i] + nums[left] + nums[right];\\n                int diff = abs (target - curSum);\\n                if (diff < prevDiff) {\\n                    sum = curSum;\\n                    prevDiff = diff;\\n                }\\n                if (target > curSum)\\n                    left++;\\n                else\\n                    right--;    \\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        sort (nums.begin(), nums.end());\\n        int sum = 0, prevDiff = INT_MAX;\\n        for (int i = 0; i < n - 2; i++) {\\n            int left = i + 1, right = n - 1;\\n            while (left < right) {\\n                int curSum = nums[i] + nums[left] + nums[right];\\n                int diff = abs (target - curSum);\\n                if (diff < prevDiff) {\\n                    sum = curSum;\\n                    prevDiff = diff;\\n                }\\n                if (target > curSum)\\n                    left++;\\n                else\\n                    right--;    \\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3812696,
                "title": "c-java-python-javascript",
                "content": "![Screenshot 2023-07-25 at 10.14.24 AM.png](https://assets.leetcode.com/users/images/7c652887-773d-4629-8591-0183ac74f26b_1690260281.8217592.png)\\n\\n\\n## \\uD83C\\uDF38\\uD83E\\uDDE9 Problem Statement \\uD83E\\uDDE9\\uD83C\\uDF38\\n- Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.\\n\\n- Return the sum of the three integers.\\n\\n- *You may assume that each input would have **exactly one solution**.*\\n\\n#### \\uD83D\\uDD2E Example 1 :- \\n```\\nInput: nums = [-1,2,1,-4], target = 1\\nOutput: 2\\nExplanation: The sum that is closest to the target is \\n2. (-1 + 2 + 1 = 2).\\n\\n```\\n#### \\uD83D\\uDD2E Example 2 :- \\n```\\nInput: nums = [0,0,0], target = 1\\nOutput: 0\\nExplanation: The sum that is closest to the target is \\n0. (0 + 0 + 0 = 0).\\n\\n```\\n\\n## \\uD83E\\uDDE0 Optimal Approach Based on Sorting and Two Pointer\\n<!-- Describe your approach to solving the problem. -->\\n- The threeSumClosest function takes a vector nums and an integer target as input and returns an integer representing the sum of three elements closest to the target.\\n- It starts by sorting the input vector nums in ascending order using sort.\\n- Then, it iterates through the vector using a for-loop for each index i from 0 to n - 2, where n is the size of the vector.\\n- Inside the loop, it calls the Solve function, which uses a two-pointer approach to find the closest sum for the current index i.\\n- The Solve function uses two pointers, L and R, initialized to i + 1 and n - 1, respectively. It moves the pointers towards each other while calculating the sum of three elements (nums[x] + nums[L] + nums[R]) and updating the ans and mx variables based on the difference from the target.\\n- After iterating through all possible combinations of three elements, the function returns the final ans, which represents the sum of three elements closest to the target value.\\n\\n## \\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB Code \\n```\\nclass Solution\\n{\\n\\tpublic: int ans = 0;\\n\\tint mx = INT_MAX;\\n\\tvoid Solve(vector<int> &nums, int x, int i, int T)\\n\\t{\\n\\t\\tint n = nums.size();\\n\\t\\tint L = i;\\n\\t\\tint R = n - 1;\\n\\t\\twhile (L < R)\\n\\t\\t{\\n\\t\\t\\tint val = (nums[x] + nums[L] + nums[R]);\\n\\t\\t\\tif (abs(T - val) < mx)\\n\\t\\t\\t{\\n\\t\\t\\t\\tans = val;\\n\\t\\t\\t\\tmx = abs(T - val);\\n\\t\\t\\t}\\n\\t\\t\\telse if (val > T) R--;\\n\\t\\t\\telse L++;\\n\\t\\t}\\n\\t}\\n\\n\\tint threeSumClosest(vector<int> &nums, int target)\\n\\t{\\n\\t\\tint n = nums.size();\\n\\t\\tsort(nums.begin(), nums.end());\\n\\t\\tfor (int i = 0; i < n - 2; i++)\\n\\t\\t{\\n\\t\\t\\tif (i == 0 || nums[i - 1] != nums[i])\\n\\t\\t\\t{\\n\\t\\t\\t\\tSolve(nums, i, i + 1, target);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n};\\n\\n```\\n\\n#### \\uD83C\\uDF38 Complexity\\n- Time complexity : $$O(n^2)$$\\n- Space complexity : $$O(1)$$\\n\\n## \\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB All Code \\n\\n- Java\\n```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    private int ans = 0;\\n    private int mx = Integer.MAX_VALUE;\\n    \\n    private void Solve(int[] nums, int x, int i, int T) {\\n        int n = nums.length;\\n        int L = i;\\n        int R = n - 1;\\n        while (L < R) {\\n            int val = (nums[x] + nums[L] + nums[R]);\\n            if (Math.abs(T - val) < mx) {\\n                ans = val;\\n                mx = Math.abs(T - val);\\n            } else if (val > T) {\\n                R--;\\n            } else {\\n                L++;\\n            }\\n        }\\n    }\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        for (int i = 0; i < n - 2; i++) {\\n            if (i == 0 || nums[i - 1] != nums[i]) {\\n                Solve(nums, i, i + 1, target);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\\n- Python\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.ans = 0\\n        self.mx = float(\\'inf\\')\\n\\n    def Solve(self, nums, x, i, T):\\n        n = len(nums)\\n        L = i\\n        R = n - 1\\n        while L < R:\\n            val = nums[x] + nums[L] + nums[R]\\n            if abs(T - val) < self.mx:\\n                self.ans = val\\n                self.mx = abs(T - val)\\n            elif val > T:\\n                R -= 1\\n            else:\\n                L += 1\\n\\n    def threeSumClosest(self, nums, target):\\n        n = len(nums)\\n        nums.sort()\\n        for i in range(n - 2):\\n            if i == 0 or nums[i - 1] != nums[i]:\\n                self.Solve(nums, i, i + 1, target)\\n        return self.ans\\n\\n```\\n- Javascript\\n```\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a, b) => a - b);\\n    let n = nums.length;\\n    let closest_sum = nums[0] + nums[1] + nums[2]; \\n    for (let i = 0; i < n - 2; i++) {\\n        let left = i + 1, right = n - 1;\\n        while (left < right) { \\n            let sum = nums[i] + nums[left] + nums[right];\\n            if (sum == target) { \\n                return sum;\\n            } else if (sum < target) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n            if (Math.abs(sum - target) < Math.abs(closest_sum - target)) { \\n                closest_sum = sum;\\n            }\\n        }\\n    }\\n    return closest_sum;\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nInput: nums = [-1,2,1,-4], target = 1\\nOutput: 2\\nExplanation: The sum that is closest to the target is \\n2. (-1 + 2 + 1 = 2).\\n\\n```\n```\\nInput: nums = [0,0,0], target = 1\\nOutput: 0\\nExplanation: The sum that is closest to the target is \\n0. (0 + 0 + 0 = 0).\\n\\n```\n```\\nclass Solution\\n{\\n\\tpublic: int ans = 0;\\n\\tint mx = INT_MAX;\\n\\tvoid Solve(vector<int> &nums, int x, int i, int T)\\n\\t{\\n\\t\\tint n = nums.size();\\n\\t\\tint L = i;\\n\\t\\tint R = n - 1;\\n\\t\\twhile (L < R)\\n\\t\\t{\\n\\t\\t\\tint val = (nums[x] + nums[L] + nums[R]);\\n\\t\\t\\tif (abs(T - val) < mx)\\n\\t\\t\\t{\\n\\t\\t\\t\\tans = val;\\n\\t\\t\\t\\tmx = abs(T - val);\\n\\t\\t\\t}\\n\\t\\t\\telse if (val > T) R--;\\n\\t\\t\\telse L++;\\n\\t\\t}\\n\\t}\\n\\n\\tint threeSumClosest(vector<int> &nums, int target)\\n\\t{\\n\\t\\tint n = nums.size();\\n\\t\\tsort(nums.begin(), nums.end());\\n\\t\\tfor (int i = 0; i < n - 2; i++)\\n\\t\\t{\\n\\t\\t\\tif (i == 0 || nums[i - 1] != nums[i])\\n\\t\\t\\t{\\n\\t\\t\\t\\tSolve(nums, i, i + 1, target);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n};\\n\\n```\n```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    private int ans = 0;\\n    private int mx = Integer.MAX_VALUE;\\n    \\n    private void Solve(int[] nums, int x, int i, int T) {\\n        int n = nums.length;\\n        int L = i;\\n        int R = n - 1;\\n        while (L < R) {\\n            int val = (nums[x] + nums[L] + nums[R]);\\n            if (Math.abs(T - val) < mx) {\\n                ans = val;\\n                mx = Math.abs(T - val);\\n            } else if (val > T) {\\n                R--;\\n            } else {\\n                L++;\\n            }\\n        }\\n    }\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        for (int i = 0; i < n - 2; i++) {\\n            if (i == 0 || nums[i - 1] != nums[i]) {\\n                Solve(nums, i, i + 1, target);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\n```\\nclass Solution:\\n    def __init__(self):\\n        self.ans = 0\\n        self.mx = float(\\'inf\\')\\n\\n    def Solve(self, nums, x, i, T):\\n        n = len(nums)\\n        L = i\\n        R = n - 1\\n        while L < R:\\n            val = nums[x] + nums[L] + nums[R]\\n            if abs(T - val) < self.mx:\\n                self.ans = val\\n                self.mx = abs(T - val)\\n            elif val > T:\\n                R -= 1\\n            else:\\n                L += 1\\n\\n    def threeSumClosest(self, nums, target):\\n        n = len(nums)\\n        nums.sort()\\n        for i in range(n - 2):\\n            if i == 0 or nums[i - 1] != nums[i]:\\n                self.Solve(nums, i, i + 1, target)\\n        return self.ans\\n\\n```\n```\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a, b) => a - b);\\n    let n = nums.length;\\n    let closest_sum = nums[0] + nums[1] + nums[2]; \\n    for (let i = 0; i < n - 2; i++) {\\n        let left = i + 1, right = n - 1;\\n        while (left < right) { \\n            let sum = nums[i] + nums[left] + nums[right];\\n            if (sum == target) { \\n                return sum;\\n            } else if (sum < target) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n            if (Math.abs(sum - target) < Math.abs(closest_sum - target)) { \\n                closest_sum = sum;\\n            }\\n        }\\n    }\\n    return closest_sum;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2675029,
                "title": "optimal-o-n-2-o-n-two-sum-technique",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& arr, int t) {\\n        int n = arr.size();\\n        sort(arr.begin(), arr.end());\\n        int ans = INT_MIN;\\n        for(int first = 0;first<=n-3;first++){\\n            int sec = first+1, third = n-1;\\n\\t\\t\\t// Two sum technique for second and third element\\n            while(sec < third){\\n                int sumtemp = arr[first] + arr[sec] + arr[third];\\n                if(sumtemp == t){\\n                    return sumtemp;\\n                }\\n                if(sumtemp < t ){\\n                    if(ans == INT_MIN) ans = sumtemp;\\n                    else{\\n                        if(abs(ans-t) > abs(sumtemp-t)) ans = sumtemp;\\n                    }\\n                    sec++;\\n                }\\n                else{\\n                    third--;\\n                    if(ans == INT_MIN) ans = sumtemp;\\n                    else{\\n                        if(abs(ans-t) > abs(sumtemp-t)) ans = sumtemp;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& arr, int t) {\\n        int n = arr.size();\\n        sort(arr.begin(), arr.end());\\n        int ans = INT_MIN;\\n        for(int first = 0;first<=n-3;first++){\\n            int sec = first+1, third = n-1;\\n\\t\\t\\t// Two sum technique for second and third element\\n            while(sec < third){\\n                int sumtemp = arr[first] + arr[sec] + arr[third];\\n                if(sumtemp == t){\\n                    return sumtemp;\\n                }\\n                if(sumtemp < t ){\\n                    if(ans == INT_MIN) ans = sumtemp;\\n                    else{\\n                        if(abs(ans-t) > abs(sumtemp-t)) ans = sumtemp;\\n                    }\\n                    sec++;\\n                }\\n                else{\\n                    third--;\\n                    if(ans == INT_MIN) ans = sumtemp;\\n                    else{\\n                        if(abs(ans-t) > abs(sumtemp-t)) ans = sumtemp;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2282243,
                "title": "to-avoid-tle-in-python-optimization-tricks",
                "content": "You can optimize the classic approach to avoid TLE in Python. \\n\\nGiven the value of k, I pick the two rightmost numbers (which means it\\'s the largest value possible given k) and see if it\\'s still less than target. Ff it is, we use continue to avoid having the while loop run because it won\\'t get closer to the target than that.\\nSame logic can be applied to the other case where we pick the two left most points and if it\\'s greater than the target, we continue, but we can actually use break this time because we don\\'t need to even check larger values of k.\\n```\\nclass Solution:\\n   \\n   def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        res = float(\\'inf\\')\\n        for k in range(len(nums)-2):\\n            # largest 3sum given k\\n            s1 = nums[k] + nums[-2] + nums[-1]\\n            if s1 < target:\\n                if abs(s1-target) < abs(res-target):\\n                    res = s1\\n                continue\\n            \\n            # smallest 3sum given k\\n            s2 = nums[k] + nums[k+1] + nums[k+2]\\n            if s2 > target:\\n                if abs(s2-target) < abs(res-target):\\n                    res = s2\\n\\t\\t\\t\\tbreak\\n            \\n            i,j = k+1, len(nums)-1\\n            while i < j:\\n                s = nums[k] + nums[i] + nums[j]\\n                if abs(s-target) < abs(res-target):\\n                    res = s\\n                if s == target:\\n                    return target\\n                if s < target:\\n                    i += 1\\n                else:\\n                    j -= 1\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n   \\n   def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        res = float(\\'inf\\')\\n        for k in range(len(nums)-2):\\n            # largest 3sum given k\\n            s1 = nums[k] + nums[-2] + nums[-1]\\n            if s1 < target:\\n                if abs(s1-target) < abs(res-target):\\n                    res = s1\\n                continue\\n            \\n            # smallest 3sum given k\\n            s2 = nums[k] + nums[k+1] + nums[k+2]\\n            if s2 > target:\\n                if abs(s2-target) < abs(res-target):\\n                    res = s2\\n\\t\\t\\t\\tbreak\\n            \\n            i,j = k+1, len(nums)-1\\n            while i < j:\\n                s = nums[k] + nums[i] + nums[j]\\n                if abs(s-target) < abs(res-target):\\n                    res = s\\n                if s == target:\\n                    return target\\n                if s < target:\\n                    i += 1\\n                else:\\n                    j -= 1\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2109008,
                "title": "python-easy-o-n-2",
                "content": "We assign the max and minimum value that we need to get.\\n**Sort the array.**\\n\\nWe iterate once to get one value. Then we put tw pointers , one at start and other at end.\\n\\n* If present value is in between min and max values we take that as answer and update min max.\\n* If value is less than min , increase the starting pointer\\n* If value is more than max, decrease the end pointer.\\n\\n```\\nclass Solution:\\n    def threeSumClosest(self, a: List[int], x: int) -> int:\\n        \\n        def find(i,j,k):\\n            if i>=j:\\n                return \\n            s=a[i]+a[j]+a[k]\\n            if s>=t[0]:\\n                find(i,j-1,k)\\n            elif s<t[1]:\\n                find(i+1,j,k)\\n            else:\\n                t[0]=x+abs(s-x)\\n                t[1]=x-abs(s-x)\\n                res[0]=s\\n                find(i+1,j,k)\\n                find(i,j-1,k)\\n                \\n        \\n        n=len(a)\\n        a.sort()\\n        res=[0]\\n        t=[math.inf,-math.inf]\\n        for k in range(n-2):\\n            i=k+1\\n            j=n-1\\n            find(i,j,k)\\n        return res[0]\\n```\\n\\n![image](https://assets.leetcode.com/users/images/2af13d6a-eaf0-491c-b710-ce227b31a353_1654332780.6307957.jpeg)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, a: List[int], x: int) -> int:\\n        \\n        def find(i,j,k):\\n            if i>=j:\\n                return \\n            s=a[i]+a[j]+a[k]\\n            if s>=t[0]:\\n                find(i,j-1,k)\\n            elif s<t[1]:\\n                find(i+1,j,k)\\n            else:\\n                t[0]=x+abs(s-x)\\n                t[1]=x-abs(s-x)\\n                res[0]=s\\n                find(i+1,j,k)\\n                find(i,j-1,k)\\n                \\n        \\n        n=len(a)\\n        a.sort()\\n        res=[0]\\n        t=[math.inf,-math.inf]\\n        for k in range(n-2):\\n            i=k+1\\n            j=n-1\\n            find(i,j,k)\\n        return res[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 498887,
                "title": "c-8-ms-faster-than-82-29",
                "content": "**Runtime: 8 ms, faster than 82.29% of C++ online submissions for 3Sum Closest.\\nMemory Usage: 8.7 MB, less than 77.36% of C++ online submissions for 3Sum Closest.**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int threeSumClosest(vector<int>& nums, int target) {\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        int fix = 0 ;\\n        int tmp = nums[0]+nums[1]+nums[2] ;\\n        \\n        while( fix < nums.size() - 2 ){\\n            \\n            int left = fix + 1;\\n            int right = nums.size() - 1 ;\\n            \\n            while ( left < right ){\\n                \\n                int sum = nums[fix] + nums[left] + nums[right];\\n                if ( abs(sum-target) < abs(tmp-target) ) tmp = sum;\\n                if ( sum > target ) right -= 1;\\n                else if ( sum < target ) left += 1;\\n                else return target;\\n                \\n            }\\n            \\n            fix += 1;\\n            \\n        }\\n        return tmp;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int threeSumClosest(vector<int>& nums, int target) {\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        int fix = 0 ;\\n        int tmp = nums[0]+nums[1]+nums[2] ;\\n        \\n        while( fix < nums.size() - 2 ){\\n            \\n            int left = fix + 1;\\n            int right = nums.size() - 1 ;\\n            \\n            while ( left < right ){\\n                \\n                int sum = nums[fix] + nums[left] + nums[right];\\n                if ( abs(sum-target) < abs(tmp-target) ) tmp = sum;\\n                if ( sum > target ) right -= 1;\\n                else if ( sum < target ) left += 1;\\n                else return target;\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 7961,
                "title": "simple-code-c",
                "content": "here is my code which is just similar to the code for previous problem 3Sum . but here we don't need to take consideration of duplicates.\\n\\n**threeSumClosest**\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n            sort(nums.begin(),nums.end());\\n            int n=nums.size(),ans;\\n            int min=INT_MAX;\\n            for(int i=0;i<n-2;i++){\\n                   int l=i+1, r= n-1;\\n                   while(l<r){\\n                       int sum =nums[i]+nums[l]+nums[r];\\n                       if(abs(sum-target)<min){  // updating the sum if sum  so far. is closest to target\\n                          min=abs(sum-target);\\n                          ans=sum;\\n                       }\\n                       if(sum<target) l++;        //\\n                       else if(sum>target)r--;\\n                       else {\\n                           return sum;  // we have sum equal to target which is closest so no need to check further \\n                       }\\n                   }\\n            }\\n            return ans;\\n        }\\n\\n**threeSum**\\n\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n            sort(nums.begin(),nums.end());\\n            int n=nums.size();\\n            vector<vector<int>> res;\\n            for(int i=0;i<n-2;i++){\\n                   if(i>0 && (nums[i]==nums[i-1]) )continue;   // to avoid duplicates\\n                   int l=i+1, r= n-1;\\n                   while(l<r){\\n                       int sum =nums[i]+nums[l]+nums[r];\\n    \\n                       if(sum<0) l++;\\n                       else if(sum>0)r--;\\n                       else {\\n                           res.push_back(vector<int>{nums[i],nums[l],nums[r]});\\n                           while(l+1<r && nums[l]==nums[l+1])l++;    // to avoid duplicates\\n                           while(l<r-1 && nums[r]==nums[r-1]) r--;     // to avoid duplicates\\n                           l++; r--;\\n                       }\\n                   }\\n            }\\n    \\n            return res;\\n        }",
                "solutionTags": [],
                "code": "here is my code which is just similar to the code for previous problem 3Sum . but here we don't need to take consideration of duplicates.\\n\\n**threeSumClosest**\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n            sort(nums.begin(),nums.end());\\n            int n=nums.size(),ans;\\n            int min=INT_MAX;\\n            for(int i=0;i<n-2;i++){\\n                   int l=i+1, r= n-1;\\n                   while(l<r){\\n                       int sum =nums[i]+nums[l]+nums[r];\\n                       if(abs(sum-target)<min){  // updating the sum if sum  so far. is closest to target\\n                          min=abs(sum-target);\\n                          ans=sum;\\n                       }\\n                       if(sum<target) l++;        //\\n                       else if(sum>target)r--;\\n                       else {\\n                           return sum;  // we have sum equal to target which is closest so no need to check further \\n                       }\\n                   }\\n            }\\n            return ans;\\n        }\\n\\n**threeSum**\\n\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n            sort(nums.begin(),nums.end());\\n            int n=nums.size();\\n            vector<vector<int>> res;\\n            for(int i=0;i<n-2;i++){\\n                   if(i>0 && (nums[i]==nums[i-1]) )continue;   // to avoid duplicates\\n                   int l=i+1, r= n-1;\\n                   while(l<r){\\n                       int sum =nums[i]+nums[l]+nums[r];\\n    \\n                       if(sum<0) l++;\\n                       else if(sum>0)r--;\\n                       else {\\n                           res.push_back(vector<int>{nums[i],nums[l],nums[r]});\\n                           while(l+1<r && nums[l]==nums[l+1])l++;    // to avoid duplicates\\n                           while(l<r-1 && nums[r]==nums[r-1]) r--;     // to avoid duplicates\\n                           l++; r--;\\n                       }\\n                   }\\n            }\\n    \\n            return res;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 7915,
                "title": "sharing-my-java-optimized-solution-5ms-beats-99-9",
                "content": "It is just some optimized work after basic 3Sum structure.\\n\\n    public int threeSumClosest(int[] nums, int target) {\\n        if(nums.length<3) return 0;\\n        Arrays.sort(nums);\\n        int min = Integer.MAX_VALUE;int result =Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length-2;i++)\\n        {\\n            if(3*nums[i]>target) \\n            {\\n                int sum3 = nums[i]+nums[i+1]+nums[i+2];\\n                if(Math.abs(sum3-target)<min)  return sum3;\\n                //break;           //should break here but seems slower after adding it\\n            }\\n            int left = i+1; \\n            int right = nums.length-1;\\n            int sum = target - nums[i];\\n            if(2*nums[right]<sum) {\\n                int sum2 = nums[i]+nums[right]+nums[right-1];\\n                 if(Math.abs(sum2-target)<min){\\n                     min = Math.abs(target-sum2);\\n                     result = sum2;\\n                 }\\n               continue;\\n            }\\n            while(left<right)\\n            {\\n                int temp = nums[i] + nums[left]+nums[right];\\n                if(temp==target) return target;\\n                if(2*nums[left]>sum) \\n                {\\n                  int sumsum = nums[i]+nums[left]+nums[left+1];\\n                  if(Math.abs(sumsum-target)<min){\\n                      min = Math.abs(target-sumsum);\\n                      result = sumsum;\\n                    }\\n                   break;\\n                }\\n                else if(Math.abs(target-temp)<min)\\n                {\\n                    min = Math.abs(target-temp);\\n                    result = temp;\\n                }\\n                if(temp<target) \\n                   left++;\\n                else right --;\\n            }\\n        }\\n        return result;\\n        }",
                "solutionTags": [],
                "code": "It is just some optimized work after basic 3Sum structure.\\n\\n    public int threeSumClosest(int[] nums, int target) {\\n        if(nums.length<3) return 0;\\n        Arrays.sort(nums);\\n        int min = Integer.MAX_VALUE;int result =Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length-2;i++)\\n        {\\n            if(3*nums[i]>target) \\n            {\\n                int sum3 = nums[i]+nums[i+1]+nums[i+2];\\n                if(Math.abs(sum3-target)<min)  return sum3;\\n                //break;           //should break here but seems slower after adding it\\n            }\\n            int left = i+1; \\n            int right = nums.length-1;\\n            int sum = target - nums[i];\\n            if(2*nums[right]<sum) {\\n                int sum2 = nums[i]+nums[right]+nums[right-1];\\n                 if(Math.abs(sum2-target)<min){\\n                     min = Math.abs(target-sum2);\\n                     result = sum2;\\n                 }\\n               continue;\\n            }\\n            while(left<right)\\n            {\\n                int temp = nums[i] + nums[left]+nums[right];\\n                if(temp==target) return target;\\n                if(2*nums[left]>sum) \\n                {\\n                  int sumsum = nums[i]+nums[left]+nums[left+1];\\n                  if(Math.abs(sumsum-target)<min){\\n                      min = Math.abs(target-sumsum);\\n                      result = sumsum;\\n                    }\\n                   break;\\n                }\\n                else if(Math.abs(target-temp)<min)\\n                {\\n                    min = Math.abs(target-temp);\\n                    result = temp;\\n                }\\n                if(temp<target) \\n                   left++;\\n                else right --;\\n            }\\n        }\\n        return result;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3678639,
                "title": "shortest-sol-using-python-professional-code",
                "content": "\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        closet = float(\\'inf\\')\\n        nums.sort()\\n        for i in range(len(nums) - 2):\\n            l, r = i + 1, len(nums) - 1\\n            while l < r:\\n                sum3 = nums[i] + nums[l] + nums[r]\\n                print(sum3)\\n                if sum3 < target:\\n                    l += 1\\n                else:\\n                    r -=1\\n                if abs(sum3 - target) < abs(closet - target):\\n                    closet = sum3\\n        return closet\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        closet = float(\\'inf\\')\\n        nums.sort()\\n        for i in range(len(nums) - 2):\\n            l, r = i + 1, len(nums) - 1\\n            while l < r:\\n                sum3 = nums[i] + nums[l] + nums[r]\\n                print(sum3)\\n                if sum3 < target:\\n                    l += 1\\n                else:\\n                    r -=1\\n                if abs(sum3 - target) < abs(closet - target):\\n                    closet = sum3\\n        return closet\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2953872,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int df=INT_MAX;\\n        int ans;\\n        for(int i=0;i<nums.size()-2;i++)\\n        {\\n            int s=i+1;\\n            int e=nums.size()-1;\\n            int sum=nums[i]+nums[s]+nums[e];\\n            while(s<e)\\n            {\\n                sum=nums[i]+nums[s]+nums[e];\\n                if(abs(sum-target)<df)\\n                {\\n                    df=abs(sum-target);\\n                    ans=sum;\\n                }\\n                    \\n                else if(sum<target)\\n                    s++;\\n                else\\n                    e--;    \\n            }\\n            while(i+1<nums.size() && nums[i+1]==nums[i])\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int df=INT_MAX;\\n        int ans;\\n        for(int i=0;i<nums.size()-2;i++)\\n        {\\n            int s=i+1;\\n            int e=nums.size()-1;\\n            int sum=nums[i]+nums[s]+nums[e];\\n            while(s<e)\\n            {\\n                sum=nums[i]+nums[s]+nums[e];\\n                if(abs(sum-target)<df)\\n                {\\n                    df=abs(sum-target);\\n                    ans=sum;\\n                }\\n                    \\n                else if(sum<target)\\n                    s++;\\n                else\\n                    e--;    \\n            }\\n            while(i+1<nums.size() && nums[i+1]==nums[i])\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792491,
                "title": "c-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int min_sum = INT_MAX, ans;\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<nums.size(); i++) {\\n            int l = i + 1, r = nums.size() - 1; \\n            while (l < r) {\\n                int sum = nums[i] + nums[l] + nums[r];\\n                if(sum == target) {\\n                    return sum;\\n                }\\n                else if(sum < target) {\\n                    if(target - sum < min_sum) {\\n                        min_sum = target - sum;\\n                        ans = sum;\\n                    }\\n                    l++;\\n                }\\n                else if(sum > target) {\\n                    if(sum - target < min_sum) {\\n                        min_sum = sum - target;\\n                        ans = sum;\\n                    }\\n                    r--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int min_sum = INT_MAX, ans;\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<nums.size(); i++) {\\n            int l = i + 1, r = nums.size() - 1; \\n            while (l < r) {\\n                int sum = nums[i] + nums[l] + nums[r];\\n                if(sum == target) {\\n                    return sum;\\n                }\\n                else if(sum < target) {\\n                    if(target - sum < min_sum) {\\n                        min_sum = target - sum;\\n                        ans = sum;\\n                    }\\n                    l++;\\n                }\\n                else if(sum > target) {\\n                    if(sum - target < min_sum) {\\n                        min_sum = sum - target;\\n                        ans = sum;\\n                    }\\n                    r--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693054,
                "title": "simple-java-solution-easy-to-understand",
                "content": "Upvote if you liked the solution\\n```\\n// We need to find the closest triplet that sums to target.\\n\\n// The brute force way is to iterate O(n^3) and to try all triplets. We can do better.\\n\\n// If we were working with pairs instead, we could do this with a two pointer technique if we had a monotonic order array. For example if our array is [-2,0,1,3,4,6,7] and our target is 2 we can initialize two pointers in the beginning and in the end. Then we would move left pointer up (increase sum) or move right pointer down (decrease sum) this way we would iterate over the search space trying to converge to target in O(n).\\n\\n// We can extend this algorithm to search a triplet. To do this, we will iterate our array and by doing this we will fix an element i at every iteration. Then all we have to do is find a pair(+ the fixed element) that sum closest to the target. This is exactly the process we described above.\\n\\n// To make the two pointer technique work we need to sort our array, otherwise we can\\'t rely on getting closer to the target by moving the pointers left or right.\\n\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n       \\n        Arrays.sort(nums);\\n        \\n        int closest=Integer.MAX_VALUE;\\n        \\n        for(int i=0;i<nums.length-2;i++)\\n        {\\n            \\n            int low=i+1,high=nums.length-1;\\n            \\n            while(low<high)\\n            {\\n                int triplet=nums[i]+nums[low]+nums[high];\\n                if(Math.abs(target-closest)>Math.abs(target-triplet))\\n                    closest=triplet;\\n                \\n                if(triplet<target) low++;\\n                else high--;\\n            }\\n            \\n        }\\n        \\n        return closest;\\n    }\\n}",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n       \\n        Arrays.sort(nums);\\n        \\n        int closest=Integer.MAX_VALUE;\\n        \\n        for(int i=0;i<nums.length-2;i++)\\n        {\\n            \\n            int low=i+1,high=nums.length-1;\\n            \\n            while(low<high)\\n            {\\n                int triplet=nums[i]+nums[low]+nums[high];\\n                if(Math.abs(target-closest)>Math.abs(target-triplet))\\n                    closest=triplet;\\n                \\n                if(triplet<target) low++;\\n                else high--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2674362,
                "title": "python-implementation-with-two-pointers-open-question-about-runtime",
                "content": "**Python Implementation**\\nTwo pointers approach, similar with the solution of Question [_**3Sum**_](https://leetcode.com/problems/3sum/)\\n\\n```Python\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        \\n        result = sum(nums[:3])\\n        for i in range(len(nums)-2):\\n            if i==0 and nums[i] == nums[i-1]:\\n                continue\\n            \\n            l, r = i+1, len(nums)-1\\n            while l < r:\\n                curr = nums[i] + nums[l] + nums[r]\\n                diff = curr - target\\n                if diff < 0:\\n                    l += 1\\n                elif diff > 0:\\n                    r -= 1\\n                else:\\n                    return curr\\n                \"\"\"\\n                TLE for block if statement\\n                \\n                if abs(result-target) > abs(diff):\\n                    result = curr\\n                \"\"\"\\n                result = curr if abs(result-target) > abs(diff) else result\\n\\n        \\n        return result\\n```\\n\\nBefore post this solution, I want to use the block if-statement to improve the readibility of the one-line statement. But it failed with TLE.\\n```\\nif abs(result-target) > abs(diff):\\n    result = curr\\n```\\n\\n### Open questions\\n - Do you have any idea on this?\\n - What\\'s the difference between the runtime of one-line if-statement and block if-statement in Python?\\n\\n![image](https://assets.leetcode.com/users/images/940686eb-abbd-42e0-91e3-cff4d8f88682_1665191244.2602255.png)\\n",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```Python\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        \\n        result = sum(nums[:3])\\n        for i in range(len(nums)-2):\\n            if i==0 and nums[i] == nums[i-1]:\\n                continue\\n            \\n            l, r = i+1, len(nums)-1\\n            while l < r:\\n                curr = nums[i] + nums[l] + nums[r]\\n                diff = curr - target\\n                if diff < 0:\\n                    l += 1\\n                elif diff > 0:\\n                    r -= 1\\n                else:\\n                    return curr\\n                \"\"\"\\n                TLE for block if statement\\n                \\n                if abs(result-target) > abs(diff):\\n                    result = curr\\n                \"\"\"\\n                result = curr if abs(result-target) > abs(diff) else result\\n\\n        \\n        return result\\n```\n```\\nif abs(result-target) > abs(diff):\\n    result = curr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674295,
                "title": "daily-leetcoding-challenge-october-day-8",
                "content": "This problem is the Daily LeetCoding Challenge for October, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/3sum-closest/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n**Approach 2:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/3sum-closest/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2253091,
                "title": "c-fully-explained-with-intuition-and-steps",
                "content": "**Intuition** \\n\\nThe first thing which comes to our mind is taking the sum of all possible triplets and finding which sum is nearest to the target. However, this method is brute force and hence time consuming. It has a time complexity of O(n^3).\\n\\nNow, let\\'s try to optimise it. \\n\\nForget about 3 sum closest, think about 2 sum closest first. If we had to find pair whose sum is closest to target, what would we have done? Again the brute force approach would have been to find all possible pairs and comparing the sums with the target. It will have time complexity  of O(n^2). However, we could solve it by just sorting the array and using double pointer approach. We could take 2 pointers and find the sum of those and then change the position of pointers by comparing the sum with target. This will cost us O(nlogn) time complexity. \\n\\nBetter, isn\\'t it?\\n\\nWhy not do the same thing in 3 sum closest? The worst time it could take is O(n^2)\\n\\n**Steps**\\n1. Sort the nums vector\\n2. Fix a particular element say ```nums[i]```\\n2. Now every time you fix one element in nums, take a starting pointer ```i+1``` and ending pointer ```nums.size()-1```\\n3. While the starting pointer is less than ending pointer, keep comparing the absolute difference of sum (```sum = nums[i] + nums[start] + nums[end]```) with target.\\n3. If  ```sum > target``` decrement end pointer ```end--```\\n4. If  ```sum < target``` increment start pointer ```start++```\\n5. If ```sum==target``` just return target\\n6. Keep a variable ans to store the sum which is closest to target and keep updating the ans in each iteration\\n\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n        sort (nums.begin(), nums.end());\\n        \\n        int mini = INT_MAX,ans, n = nums.size();\\n        \\n        for (int i=0; i<n-2; i++)\\n        {\\n            int comp = nums[i];\\n            \\n            int start = i+1, end = n-1;\\n            \\n            while(start<end)\\n            {\\n                int sum = nums[start]+nums[end]+comp;\\n                \\n                if (abs(sum - target)<mini)\\n                {\\n                    mini = abs(sum-target);\\n                    ans = sum;                \\n                }\\n                \\n                if (sum > target)\\n                    end--;\\n                else if (sum < target)\\n                    start++;\\n                else\\n                    return target;\\n                    \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nFeel free to ask any question in the comment section.\\nI hope that you found the solution useful.\\nIf so, please do upvote and encourage me. \\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```nums[i]```\n```i+1```\n```nums.size()-1```\n```sum = nums[i] + nums[start] + nums[end]```\n```sum > target```\n```end--```\n```sum < target```\n```start++```\n```sum==target```\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n        sort (nums.begin(), nums.end());\\n        \\n        int mini = INT_MAX,ans, n = nums.size();\\n        \\n        for (int i=0; i<n-2; i++)\\n        {\\n            int comp = nums[i];\\n            \\n            int start = i+1, end = n-1;\\n            \\n            while(start<end)\\n            {\\n                int sum = nums[start]+nums[end]+comp;\\n                \\n                if (abs(sum - target)<mini)\\n                {\\n                    mini = abs(sum-target);\\n                    ans = sum;                \\n                }\\n                \\n                if (sum > target)\\n                    end--;\\n                else if (sum < target)\\n                    start++;\\n                else\\n                    return target;\\n                    \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2227046,
                "title": "python-tle-for-o-n2-new-test-cases",
                "content": "Last time I did this question was on 16-06-2022, there were 132 cases. Leetcode has added new cases (current total = 381) since then and now my same solution is TLE.\\n\\nI am using the sort + two-pointer approach, and there is proof by contradiction, there is no better solution possible. The question is giving TLE for other submitted (top-votes discussion) solutions as well.\\nMy Python Solution\\n```\\ndef threeSumClosest(self, nums: List[int], k: int) -> int:\\n        ans=float(\\'inf\\')\\n        nums.sort()\\n        a2=0\\n        for i in range(len(nums)):\\n            l=i+1\\n            r=len(nums)-1\\n            while l<r:\\n                x=nums[i]+nums[l]+nums[r]\\n                z=abs(k-x)\\n                if z<ans:\\n                    ans=z\\n                    a2=x\\n                if x<k:\\n                    l+=1\\n                else:\\n                    r-=1\\n        return a2\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\ndef threeSumClosest(self, nums: List[int], k: int) -> int:\\n        ans=float(\\'inf\\')\\n        nums.sort()\\n        a2=0\\n        for i in range(len(nums)):\\n            l=i+1\\n            r=len(nums)-1\\n            while l<r:\\n                x=nums[i]+nums[l]+nums[r]\\n                z=abs(k-x)\\n                if z<ans:\\n                    ans=z\\n                    a2=x\\n                if x<k:\\n                    l+=1\\n                else:\\n                    r-=1\\n        return a2\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2193901,
                "title": "python-modified-3sum-approach",
                "content": "![image](https://assets.leetcode.com/users/images/10e73d09-7878-4a90-867d-fdf00e56ebc2_1656379823.6041436.jpeg)\\n\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort();\\n        res=sum(nums[:3])\\n        for i in range(0,len(nums)):\\n            j=i+1\\n            k=len(nums)-1\\n            while(j<k):\\n                s = sum((nums[i], nums[j], nums[k]))\\n                if(abs(s-target) <abs(res-target)):\\n                    res=s\\n                if(s<target):\\n                    j+=1\\n                elif(s>target):\\n                    k-=1\\n                else:\\n                    return res\\n        return res\\n```\\n***Pls upvote if you find it helpful***",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort();\\n        res=sum(nums[:3])\\n        for i in range(0,len(nums)):\\n            j=i+1\\n            k=len(nums)-1\\n            while(j<k):\\n                s = sum((nums[i], nums[j], nums[k]))\\n                if(abs(s-target) <abs(res-target)):\\n                    res=s\\n                if(s<target):\\n                    j+=1\\n                elif(s>target):\\n                    k-=1\\n                else:\\n                    return res\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2169868,
                "title": "python-solution-beats-83-240ms",
                "content": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        return self.KSumClosest(nums, 3, target)\\n\\n    def KSumClosest(self, nums: List[int], k: int, target: int) -> int:\\n        N = len(nums)\\n        if N == k:\\n            return sum(nums[:k])\\n\\n        current = sum(nums[:k])\\n        if current >= target:\\n            return current\\n\\n        current = sum(nums[-k:])\\n        if current <= target:\\n            return current\\n        \\n        if k == 1:\\n            return min([(x, abs(target - x)) for x in nums], key = lambda x: x[1])[0]\\n\\n        closest = sum(nums[:k])\\n        for i, x in enumerate(nums[:-k+1]):\\n            if i>0 and x == nums[i-1]:\\n                continue\\n            current = self.KSumClosest(nums[i+1:], k-1, target - x) + x\\n            if abs(target - current) < abs(target - closest):\\n                if current == target:\\n                    return target\\n                else:\\n                    closest = current\\n\\n        return closest",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        return self.KSumClosest(nums, 3, target)\\n\\n    def KSumClosest(self, nums: List[int], k: int, target: int) -> int:\\n        N = len(nums)\\n        if N == k:\\n            return sum(nums[:k])\\n\\n        current = sum(nums[:k])\\n        if current >= target:\\n            return current\\n\\n        current = sum(nums[-k:])\\n        if current <= target:\\n            return current\\n        \\n        if k == 1:\\n            return min([(x, abs(target - x)) for x in nums], key = lambda x: x[1])[0]\\n\\n        closest = sum(nums[:k])\\n        for i, x in enumerate(nums[:-k+1]):\\n            if i>0 and x == nums[i-1]:\\n                continue\\n            current = self.KSumClosest(nums[i+1:], k-1, target - x) + x\\n            if abs(target - current) < abs(target - closest):\\n                if current == target:\\n                    return target\\n                else:\\n                    closest = current\\n\\n        return closest",
                "codeTag": "Java"
            },
            {
                "id": 1447243,
                "title": "c-solution-4ms-98-63-5-7mb-92-88",
                "content": "```\\n\\nint compare(const void *a, const void *b){\\n  return *(int*)a - *(int*)b;\\n}\\nint threeSumClosest(int* nums, int numsSize, int target){\\n  int result = nums[0] + nums[1] + nums[2];\\n  int limit = numsSize - 1, second, third, dis = abs(result - target), temp1, temp2;\\n  \\n  qsort(nums, numsSize, sizeof(int), compare);\\n  for(int first = 0; first < limit; first++){\\n    second = first + 1;\\n    third = limit;\\n    while(second < third){\\n      temp1 = nums[first] + nums[second] + nums[third];\\n      temp2 = abs(temp1 - target);\\n      if (temp2 < dis) {\\n        dis = temp2;\\n        result = temp1;\\n      }\\n      if (result == target) return result;\\n      else if (temp1 > target) third--;\\n      else if (temp1 < target) second++;\\n    }\\n  }\\n  return result;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nint compare(const void *a, const void *b){\\n  return *(int*)a - *(int*)b;\\n}\\nint threeSumClosest(int* nums, int numsSize, int target){\\n  int result = nums[0] + nums[1] + nums[2];\\n  int limit = numsSize - 1, second, third, dis = abs(result - target), temp1, temp2;\\n  \\n  qsort(nums, numsSize, sizeof(int), compare);\\n  for(int first = 0; first < limit; first++){\\n    second = first + 1;\\n    third = limit;\\n    while(second < third){\\n      temp1 = nums[first] + nums[second] + nums[third];\\n      temp2 = abs(temp1 - target);\\n      if (temp2 < dis) {\\n        dis = temp2;\\n        result = temp1;\\n      }\\n      if (result == target) return result;\\n      else if (temp1 > target) third--;\\n      else if (temp1 < target) second++;\\n    }\\n  }\\n  return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1366451,
                "title": "c-3-clean-approaches-go-from-naive-to-best",
                "content": "```\\n//Approach-1 (The first approach that comes to our mind) Time : O(n^3)\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int minDiff = INT_MAX;\\n        int result = 0;\\n        \\n        for(int i = 0; i<n-2; i++) {\\n            for(int j = i+1; j<n-1; j++) {\\n                for(int k = j+1; k<n; k++) {\\n                    int sum  = nums[i]+nums[j]+nums[k];\\n                    int diff = abs(target-sum);\\n                    if(diff < minDiff) {\\n                        minDiff = diff;\\n                        result = sum;\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n\\n```\\n//Approach-2 (Using Binary Search) (Time : O(n^2 logn))\\n//Think about fixing two numbers and finding best 3rd number using Binary Search\\nclass Solution {\\npublic:\\n    int n;\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        n = nums.size();\\n        sort(begin(nums), end(nums));\\n        \\n        int minDiff = INT_MAX;\\n        int sum     = 0;\\n        \\n        for(int i = 0; i<n-2; i++) {\\n            for(int j = i + 1; j<n-1; j++) {\\n                int remain = target - (nums[i] + nums[j]);\\n                auto it    = upper_bound(begin(nums)+j+1, end(nums), remain); //returns iterator to a number > remain\\n                \\n                int r = it-begin(nums), l = r-1;\\n                \\n                if(r < n && abs(remain - nums[r]) < minDiff) {\\n                    minDiff = abs(remain - nums[r]);\\n                    sum     = nums[i] + nums[j] + nums[r];\\n                }\\n                \\n                if(l > j && abs(remain - nums[l]) < minDiff) {\\n                    minDiff = abs(remain - nums[l]);\\n                    sum     = nums[i] + nums[j] + nums[l];\\n                }\\n            }\\n        }\\n        \\n        return sum;\\n        \\n    }\\n};\\n```\\n\\n```\\n/*Approach-2 (Using two pointers approach) Time : O(n^2)\\nSince we have to find closest sum, we can\\'t use hash map to our benefit. 2-pointers approach suits the best for this problem and it\\'s the best one\\n*/\\nclass Solution {\\npublic:\\n    int n;\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        n = nums.size();\\n        sort(begin(nums), end(nums));\\n        \\n        int minDiff = INT_MAX;\\n        int sum     = 0;\\n        \\n        for(int i = 0; i<n-2; i++) {\\n            int l = i+1, r = n-1;\\n            \\n            while(l < r) {\\n                int temp = nums[i] + nums[l] + nums[r];\\n                int diff = abs(target-temp);\\n                \\n                if(diff < minDiff) {\\n                    minDiff = diff;\\n                    sum     = temp;\\n                    if(minDiff == 0) return sum;\\n                }\\n                \\n                if(temp < target) l++;\\n                else r--;\\n            }\\n        }\\n        \\n        return sum;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (The first approach that comes to our mind) Time : O(n^3)\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int minDiff = INT_MAX;\\n        int result = 0;\\n        \\n        for(int i = 0; i<n-2; i++) {\\n            for(int j = i+1; j<n-1; j++) {\\n                for(int k = j+1; k<n; k++) {\\n                    int sum  = nums[i]+nums[j]+nums[k];\\n                    int diff = abs(target-sum);\\n                    if(diff < minDiff) {\\n                        minDiff = diff;\\n                        result = sum;\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\n```\\n//Approach-2 (Using Binary Search) (Time : O(n^2 logn))\\n//Think about fixing two numbers and finding best 3rd number using Binary Search\\nclass Solution {\\npublic:\\n    int n;\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        n = nums.size();\\n        sort(begin(nums), end(nums));\\n        \\n        int minDiff = INT_MAX;\\n        int sum     = 0;\\n        \\n        for(int i = 0; i<n-2; i++) {\\n            for(int j = i + 1; j<n-1; j++) {\\n                int remain = target - (nums[i] + nums[j]);\\n                auto it    = upper_bound(begin(nums)+j+1, end(nums), remain); //returns iterator to a number > remain\\n                \\n                int r = it-begin(nums), l = r-1;\\n                \\n                if(r < n && abs(remain - nums[r]) < minDiff) {\\n                    minDiff = abs(remain - nums[r]);\\n                    sum     = nums[i] + nums[j] + nums[r];\\n                }\\n                \\n                if(l > j && abs(remain - nums[l]) < minDiff) {\\n                    minDiff = abs(remain - nums[l]);\\n                    sum     = nums[i] + nums[j] + nums[l];\\n                }\\n            }\\n        }\\n        \\n        return sum;\\n        \\n    }\\n};\\n```\n```\\n/*Approach-2 (Using two pointers approach) Time : O(n^2)\\nSince we have to find closest sum, we can\\'t use hash map to our benefit. 2-pointers approach suits the best for this problem and it\\'s the best one\\n*/\\nclass Solution {\\npublic:\\n    int n;\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        n = nums.size();\\n        sort(begin(nums), end(nums));\\n        \\n        int minDiff = INT_MAX;\\n        int sum     = 0;\\n        \\n        for(int i = 0; i<n-2; i++) {\\n            int l = i+1, r = n-1;\\n            \\n            while(l < r) {\\n                int temp = nums[i] + nums[l] + nums[r];\\n                int diff = abs(target-temp);\\n                \\n                if(diff < minDiff) {\\n                    minDiff = diff;\\n                    sum     = temp;\\n                    if(minDiff == 0) return sum;\\n                }\\n                \\n                if(temp < target) l++;\\n                else r--;\\n            }\\n        }\\n        \\n        return sum;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1362223,
                "title": "javascript-easy-clean-solution",
                "content": "\\n\\n    var threeSumClosest = function(nums, target) {\\n        nums.sort((a,b) => a-b)\\n        let diff = Infinity;\\n    \\n        for(var i = 0; i < nums.length; i++) {\\n            let j = i + 1;\\n            let k = nums.length - 1\\n        \\n            while(j < k) {\\n                let sum = nums[i]+nums[j]+nums[k]\\n            \\n                if(Math.abs(diff) > Math.abs(target-sum)) {\\n                    diff = target - sum\\n                }\\n            \\n                if(sum < target) {\\n                    j++\\n                } else {\\n                    k--\\n                }\\n            }\\n        }\\n        return target - diff\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\n\\n    var threeSumClosest = function(nums, target) {\\n        nums.sort((a,b) => a-b)\\n        let diff = Infinity;\\n    \\n        for(var i = 0; i < nums.length; i++) {\\n            let j = i + 1;\\n            let k = nums.length - 1\\n        \\n            while(j < k) {\\n                let sum = nums[i]+nums[j]+nums[k]\\n            \\n                if(Math.abs(diff) > Math.abs(target-sum)) {\\n                    diff = target - sum\\n                }\\n            \\n                if(sum < target) {\\n                    j++\\n                } else {\\n                    k--\\n                }\\n            }\\n        }\\n        return target - diff\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 447655,
                "title": "java-6ms-o-n-2-solution",
                "content": "```\\npublic int threeSumClosest(int[] nums, int target) {\\n        if(nums.length==3) return nums[0]+nums[1]+nums[2];\\n        Arrays.sort(nums);\\n\\t\\tint res = 0, diff = Integer.MAX_VALUE;\\n\\t\\tfor (int i = 0; i < nums.length - 2; i++) {\\n\\t\\t\\tint j = i + 1;\\n\\t\\t\\tint k = nums.length - 1;\\n\\t\\t\\twhile (j < k) {\\n\\t\\t\\t\\tint sum = nums[i] + nums[j] + nums[k];\\n\\t\\t\\t\\tif (Math.abs(sum - target) < diff) {\\n\\t\\t\\t\\t\\tdiff = Math.abs(sum - target);\\n\\t\\t\\t\\t\\tres = sum;\\n\\t\\t\\t\\t}\\n                if(sum > target){\\n                    k--;\\n                }else{\\n                    j++;\\n                }\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int threeSumClosest(int[] nums, int target) {\\n        if(nums.length==3) return nums[0]+nums[1]+nums[2];\\n        Arrays.sort(nums);\\n\\t\\tint res = 0, diff = Integer.MAX_VALUE;\\n\\t\\tfor (int i = 0; i < nums.length - 2; i++) {\\n\\t\\t\\tint j = i + 1;\\n\\t\\t\\tint k = nums.length - 1;\\n\\t\\t\\twhile (j < k) {\\n\\t\\t\\t\\tint sum = nums[i] + nums[j] + nums[k];\\n\\t\\t\\t\\tif (Math.abs(sum - target) < diff) {\\n\\t\\t\\t\\t\\tdiff = Math.abs(sum - target);\\n\\t\\t\\t\\t\\tres = sum;\\n\\t\\t\\t\\t}\\n                if(sum > target){\\n                    k--;\\n                }else{\\n                    j++;\\n                }\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 260076,
                "title": "python-clear-solution-with-comments-o-n-2",
                "content": "```python\\nclass Solution:\\n    def threeSumClosest(self, nums, target: int) -> int:\\n        nums.sort()\\n\\n        # result cant be worse than sum of random 3 nums\\n        res = sum(nums[0: 3])\\n        diff = abs(res - target)\\n\\n        for i in range(len(nums) - 2):\\n            j, k = i + 1, len(nums) - 1\\n\\n            # if 3 * smallest num - target > diff, the rest bigger sum can be skipped\\n            if nums[i] * 3 - target > diff:\\n                break\\n\\n            while j < k:\\n                r = nums[i] + nums[j] + nums[k]\\n\\n                # if closer, update\\n                if abs(r - target) < diff:\\n                    res = r\\n                    diff = abs(r - target)\\n                \\n                # if larger than target, decrease\\n                if r > target:\\n                    k = k - 1\\n                \\n                # if smaller than target, increase\\n                elif r < target:\\n                    j = j + 1\\n                \\n                # just target\\n                else:\\n                    return r\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def threeSumClosest(self, nums, target: int) -> int:\\n        nums.sort()\\n\\n        # result cant be worse than sum of random 3 nums\\n        res = sum(nums[0: 3])\\n        diff = abs(res - target)\\n\\n        for i in range(len(nums) - 2):\\n            j, k = i + 1, len(nums) - 1\\n\\n            # if 3 * smallest num - target > diff, the rest bigger sum can be skipped\\n            if nums[i] * 3 - target > diff:\\n                break\\n\\n            while j < k:\\n                r = nums[i] + nums[j] + nums[k]\\n\\n                # if closer, update\\n                if abs(r - target) < diff:\\n                    res = r\\n                    diff = abs(r - target)\\n                \\n                # if larger than target, decrease\\n                if r > target:\\n                    k = k - 1\\n                \\n                # if smaller than target, increase\\n                elif r < target:\\n                    j = j + 1\\n                \\n                # just target\\n                else:\\n                    return r\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 7885,
                "title": "12-lines-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int diff = INT_MAX, res = 0;\\n        for(int i = 0; i < nums.size() - 2; i++){\\n            int lo = i + 1, hi = nums.size() - 1;\\n            while(lo < hi){\\n                int sum = nums[i] + nums[lo] + nums[hi];\\n                if(sum == target) return target;\\n                if(abs(sum - target) < diff) diff = abs(sum - target), res = sum;\\n                (sum > target) ? hi-- : lo++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int diff = INT_MAX, res = 0;\\n        for(int i = 0; i < nums.size() - 2; i++){\\n            int lo = i + 1, hi = nums.size() - 1;\\n            while(lo < hi){\\n                int sum = nums[i] + nums[lo] + nums[hi];\\n                if(sum == target) return target;\\n                if(abs(sum - target) < diff) diff = abs(sum - target), res = sum;\\n                (sum > target) ? hi-- : lo++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 8004,
                "title": "self-explanatory-java-solution-using-two-pointers",
                "content": "      public int threeSumClosest(int[] nums, int target) {\\n            if(nums==null || nums.length<3)\\n                return -1;\\n            Arrays.sort(nums);\\n            int result = 0;\\n            int diff = Integer.MAX_VALUE;\\n            for(int i=0; i<nums.length-1; i++){\\n                if(i>0 && nums[i] == nums[i-1])\\n                    continue;\\n                int j = i+1;\\n                int k = nums.length-1;\\n                while(j<k){\\n                    int sum = nums[i]+nums[j]+nums[k];\\n                    if(diff> Math.abs(target-sum)){\\n                        result=sum;\\n                        diff = Math.abs(target-sum);\\n                    }if(sum==target){\\n                        return sum;\\n                    }else if(sum<target){\\n                        j++;\\n                    }else\\n                        k--;\\n                }\\n                \\n            }\\n            return result;\\n        }",
                "solutionTags": [],
                "code": "      public int threeSumClosest(int[] nums, int target) {\\n            if(nums==null || nums.length<3)\\n                return -1;\\n            Arrays.sort(nums);\\n            int result = 0;\\n            int diff = Integer.MAX_VALUE;\\n            for(int i=0; i<nums.length-1; i++){\\n                if(i>0 && nums[i] == nums[i-1])\\n                    continue;\\n                int j = i+1;\\n                int k = nums.length-1;\\n                while(j<k){\\n                    int sum = nums[i]+nums[j]+nums[k];\\n                    if(diff> Math.abs(target-sum)){\\n                        result=sum;\\n                        diff = Math.abs(target-sum);\\n                    }if(sum==target){\\n                        return sum;\\n                    }else if(sum<target){\\n                        j++;\\n                    }else\\n                        k--;\\n                }\\n                \\n            }\\n            return result;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 7921,
                "title": "my-enhanced-n-2-answer-could-be-n-logn-minimum-time-12ms",
                "content": "The outer loop is same as most people;\\nFor the inner while loop, instead of gradually doing left++, right--, I use binary search to find the closest match.  Binary search interval should be [left+1, right-1].  I use STL <algorithm> lower_bound function.\\n\\nIf current num[left]+num[right] is greater than target, then we want to move \"right\" to the left, because num[right] is too big.\\n\\nWe use lower_bound to find a number that is closest to the \"final target\". i.e., target - num[i] - num[left], \\nIf lower_bound return  the iterator points to num[right], then we simply do right--, because that means the biggest number we can try next is num[right-1]\\n\\nIf current num[left]+num[right] is less than target, then we want to move \"left\" to the right, because num[left] is too small. \\nSearch  the \"final target\". i.e., target - num[i] - num[right], \\nIf lower_bound return  the iterator points to num[right], then that means all numbers in interval [left+1, right-1] are all too small to meet the target. Thus, we only need to calculate num[i]+num[right-1]+num[right] and see how close it is to the target. Then we break the while loop.\\n\\n    class Solution {\\n    public:\\n        int threeSumClosest(vector<int> &num, int target) {\\n            if(num.size() == 0) return 0;\\n            if(num.size() == 1) return num[0];\\n            if(num.size() == 2) return num[0]+num[1];\\n            int closest = num[0]+num[1]+num[2];\\n            if(num.size() == 3) return closest;\\n            \\n            sort(num.begin(), num.end());\\n    \\n            for(int i = 0; i < num.size()-2; i++) {\\n                int new_target = target - num[i];\\n                int left = i+1, right = num.size()-1;\\n                \\n                while(right>left) {\\n                    int sum = num[left] + num[right];\\n                    if (sum == new_target)\\n                       return target;\\n                    \\n                    if ( std::abs(sum+num[i] - target) < std::abs(closest-target) ) {\\n                        closest = sum + num[i];\\n                    } \\n                    if(sum > new_target) {\\n                        vector<int>::iterator it = lower_bound(num.begin()+left+1, num.begin()+right, new_target-num[left]);\\n                        if (it == num.begin()+right) {\\n                            right--;\\n                        } else {\\n                          right = distance(num.begin(), it);\\n                        }\\n                      //  right--;     //original code\\n                    } else if (sum < new_target) {\\n                        vector<int>::iterator it = lower_bound(num.begin()+left+1, num.begin()+right, new_target-num[right]);\\n                        if( it == num.begin()+right) {  //cannot find anything big enough\\n                            left = right -1;\\n                            if ( std::abs(num[left]+num[right]+num[i] - target) < std::abs(closest-target) ) {\\n                                closest = num[left]+num[right]+num[i];\\n                            }                         \\n                            break;\\n                        } else {\\n                            left = distance(num.begin(), it);\\n                        }\\n                        \\n                        //  left++;   //original code\\n                    }\\n                    \\n                }\\n            }\\n            return closest;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int threeSumClosest(vector<int> &num, int target) {\\n            if(num.size() == 0) return 0;\\n            if(num.size() == 1) return num[0];\\n            if(num.size() == 2) return num[0]+num[1];\\n            int closest = num[0]+num[1]+num[2];\\n            if(num.size() == 3) return closest;\\n            \\n            sort(num.begin(), num.end());\\n    \\n            for(int i = 0; i < num.size()-2; i++) {\\n                int new_target = target - num[i];\\n                int left = i+1, right = num.size()-1;\\n                \\n                while(right>left) {\\n                    int sum = num[left] + num[right];\\n                    if (sum == new_target)\\n                       return target;\\n                    \\n                    if ( std::abs(sum+num[i] - target) < std::abs(closest-target) ) {\\n                        closest = sum + num[i];\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3938010,
                "title": "swift-c-python-java-easy-to-understand-and-simple-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(|ans|)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Swift\\n```\\nclass Solution {\\n    func threeSumClosest(_ nums: [Int], _ target: Int) -> Int {\\n        var ans = nums[0] + nums[1] + nums[2]\\n        var (nums, len) = (nums.sorted(), nums.count)\\n\\n        for i in 0..<len - 2{\\n            if i > 0 && nums[i] == nums[i - 1] { continue }\\n            var (l, r) = (i + 1, len - 1)\\n\\n            while l < r {\\n                var sum = nums[i] + nums[l] + nums[r]\\n\\n                if sum == target { return sum }\\n                if abs(sum - target) < abs(ans - target) { ans = sum }\\n\\n                sum < target ? (l += 1) : (r -= 1)\\n            }\\n        }\\n\\n        return ans\\n    }\\n}\\n```\\n\\n# C++\\n```\\nclass Solution {\\n public:\\n  int threeSumClosest(vector<int>& nums, int target) {\\n    int ans = nums[0] + nums[1] + nums[2];\\n    sort(nums.begin(), nums.end());\\n\\n    for (int i = 0; i + 2 < nums.size(); ++i) {\\n      if (i > 0 && nums[i] == nums[i - 1])\\n        continue;\\n\\n      int l = i + 1;\\n      int r = nums.size() - 1;\\n\\n      while (l < r) {\\n        const int sum = nums[i] + nums[l] + nums[r];\\n        if (sum == target)\\n          return sum;\\n        if (abs(sum - target) < abs(ans - target))\\n          ans = sum;\\n        if (sum < target)\\n          ++l;\\n        else\\n          --r;\\n      }\\n    }\\n\\n    return ans;\\n  }\\n};\\n```\\n# Python\\n```\\nclass Solution:\\n  def threeSumClosest(self, nums: List[int], target: int) -> int:\\n    ans = nums[0] + nums[1] + nums[2]\\n    nums.sort()\\n\\n    for i in range(len(nums) - 2):\\n      if i > 0 and nums[i] == nums[i - 1]:\\n        continue\\n\\n      l = i + 1\\n      r = len(nums) - 1\\n\\n      while l < r:\\n        summ = nums[i] + nums[l] + nums[r]\\n        if summ == target:\\n          return summ\\n        if abs(summ - target) < abs(ans - target):\\n          ans = summ\\n        if summ < target:\\n          l += 1\\n        else:\\n          r -= 1\\n\\n    return ans\\n```\\n# Java\\n```\\nclass Solution {\\n  public int threeSumClosest(int[] nums, int target) {\\n    int ans = nums[0] + nums[1] + nums[2];\\n    Arrays.sort(nums);\\n\\n    for (int i = 0; i + 2 < nums.length; ++i) {\\n      if (i > 0 && nums[i] == nums[i - 1])\\n        continue;\\n\\n      int l = i + 1;\\n      int r = nums.length - 1;\\n\\n      while (l < r) {\\n        final int sum = nums[i] + nums[l] + nums[r];\\n        if (sum == target)\\n          return sum;\\n        if (Math.abs(sum - target) < Math.abs(ans - target))\\n          ans = sum;\\n        if (sum < target)\\n          ++l;\\n        else\\n          --r;\\n      }\\n    }\\n\\n    return ans;\\n  }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Swift",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    func threeSumClosest(_ nums: [Int], _ target: Int) -> Int {\\n        var ans = nums[0] + nums[1] + nums[2]\\n        var (nums, len) = (nums.sorted(), nums.count)\\n\\n        for i in 0..<len - 2{\\n            if i > 0 && nums[i] == nums[i - 1] { continue }\\n            var (l, r) = (i + 1, len - 1)\\n\\n            while l < r {\\n                var sum = nums[i] + nums[l] + nums[r]\\n\\n                if sum == target { return sum }\\n                if abs(sum - target) < abs(ans - target) { ans = sum }\\n\\n                sum < target ? (l += 1) : (r -= 1)\\n            }\\n        }\\n\\n        return ans\\n    }\\n}\\n```\n```\\nclass Solution {\\n public:\\n  int threeSumClosest(vector<int>& nums, int target) {\\n    int ans = nums[0] + nums[1] + nums[2];\\n    sort(nums.begin(), nums.end());\\n\\n    for (int i = 0; i + 2 < nums.size(); ++i) {\\n      if (i > 0 && nums[i] == nums[i - 1])\\n        continue;\\n\\n      int l = i + 1;\\n      int r = nums.size() - 1;\\n\\n      while (l < r) {\\n        const int sum = nums[i] + nums[l] + nums[r];\\n        if (sum == target)\\n          return sum;\\n        if (abs(sum - target) < abs(ans - target))\\n          ans = sum;\\n        if (sum < target)\\n          ++l;\\n        else\\n          --r;\\n      }\\n    }\\n\\n    return ans;\\n  }\\n};\\n```\n```\\nclass Solution:\\n  def threeSumClosest(self, nums: List[int], target: int) -> int:\\n    ans = nums[0] + nums[1] + nums[2]\\n    nums.sort()\\n\\n    for i in range(len(nums) - 2):\\n      if i > 0 and nums[i] == nums[i - 1]:\\n        continue\\n\\n      l = i + 1\\n      r = len(nums) - 1\\n\\n      while l < r:\\n        summ = nums[i] + nums[l] + nums[r]\\n        if summ == target:\\n          return summ\\n        if abs(summ - target) < abs(ans - target):\\n          ans = summ\\n        if summ < target:\\n          l += 1\\n        else:\\n          r -= 1\\n\\n    return ans\\n```\n```\\nclass Solution {\\n  public int threeSumClosest(int[] nums, int target) {\\n    int ans = nums[0] + nums[1] + nums[2];\\n    Arrays.sort(nums);\\n\\n    for (int i = 0; i + 2 < nums.length; ++i) {\\n      if (i > 0 && nums[i] == nums[i - 1])\\n        continue;\\n\\n      int l = i + 1;\\n      int r = nums.length - 1;\\n\\n      while (l < r) {\\n        final int sum = nums[i] + nums[l] + nums[r];\\n        if (sum == target)\\n          return sum;\\n        if (Math.abs(sum - target) < Math.abs(ans - target))\\n          ans = sum;\\n        if (sum < target)\\n          ++l;\\n        else\\n          --r;\\n      }\\n    }\\n\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889785,
                "title": "simple-solution-beats-95-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int ans;\\n        int dif;\\n        int n=0;\\n        for(int i=0;i<nums.size();i++){\\n            int j=i+1;\\n            int k=nums.size()-1;\\n            while(j<k){\\n                int sum=nums[i]+nums[j]+nums[k];\\n                if(sum==target){\\n                    return sum;\\n                }\\n                int m=abs(target-sum);\\n                if(i==0||m<dif){\\n                    dif=m;\\n                    ans=sum;\\n                }\\n                if(sum<target)\\n                j++;\\n                else \\n                k--;\\n                if(ans+1==target||ans-1==target)\\n                n=ans;\\n            }\\n        }\\n        if(n!=0)\\n        return n;\\n        else\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int ans;\\n        int dif;\\n        int n=0;\\n        for(int i=0;i<nums.size();i++){\\n            int j=i+1;\\n            int k=nums.size()-1;\\n            while(j<k){\\n                int sum=nums[i]+nums[j]+nums[k];\\n                if(sum==target){\\n                    return sum;\\n                }\\n                int m=abs(target-sum);\\n                if(i==0||m<dif){\\n                    dif=m;\\n                    ans=sum;\\n                }\\n                if(sum<target)\\n                j++;\\n                else \\n                k--;\\n                if(ans+1==target||ans-1==target)\\n                n=ans;\\n            }\\n        }\\n        if(n!=0)\\n        return n;\\n        else\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586091,
                "title": "three-sum-closest-c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe approach is same as the three sum which is by using three pointers,the only difference here to find the closest sum to target is to check if the absolute difference between the sum and the target is smaller than the absolute difference between closest and the target. If so, update closest to the current sum.\\n\\n# Complexity\\n- Time complexity:\\n O(n^2)\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n       \\n       int closest= nums[0]+nums[1]+nums[2];\\n       sort(nums.begin(),nums.end());\\n        if(nums.size()<3)\\n        {\\n            return 0;\\n        }\\n       for(int i=0;i<nums.size();i++)\\n       {\\n           int j=i+1;\\n           int k=nums.size()-1;\\n           while(j<k){\\n               int sum=nums[i]+nums[j]+nums[k];\\n               if(sum==target)\\n               {\\n                   j++;\\n                   k--;\\n               }\\n               if(abs(target-sum)<abs(target-closest))\\n               {\\n                   closest=sum;\\n               }\\n               if(sum<target){\\n                   j++;\\n               }\\n               else{\\n                   k--;\\n               }\\n           }\\n       }\\n\\n        return closest;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n       \\n       int closest= nums[0]+nums[1]+nums[2];\\n       sort(nums.begin(),nums.end());\\n        if(nums.size()<3)\\n        {\\n            return 0;\\n        }\\n       for(int i=0;i<nums.size();i++)\\n       {\\n           int j=i+1;\\n           int k=nums.size()-1;\\n           while(j<k){\\n               int sum=nums[i]+nums[j]+nums[k];\\n               if(sum==target)\\n               {\\n                   j++;\\n                   k--;\\n               }\\n               if(abs(target-sum)<abs(target-closest))\\n               {\\n                   closest=sum;\\n               }\\n               if(sum<target){\\n                   j++;\\n               }\\n               else{\\n                   k--;\\n               }\\n           }\\n       }\\n\\n        return closest;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3335232,
                "title": "easy-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n\\n        int closest = nums[0] + nums[1] + nums[2];\\n        for (int i = 0; i < n - 2; i++){\\n            int l = i + 1;\\n            int r = n - 1;\\n            while (l < r) {\\n                int curSum = nums[i] + nums[l] + nums[r];\\n                if (curSum == target) return curSum;\\n                if (abs(target - curSum) < abs(target - closest)) {\\n                    closest = curSum;\\n                }\\n\\n                if (target < curSum) {\\n                    r--;\\n                } else {\\n                    l++;\\n                }\\n            }\\n        }\\n\\n        return closest;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n\\n        int closest = nums[0] + nums[1] + nums[2];\\n        for (int i = 0; i < n - 2; i++){\\n            int l = i + 1;\\n            int r = n - 1;\\n            while (l < r) {\\n                int curSum = nums[i] + nums[l] + nums[r];\\n                if (curSum == target) return curSum;\\n                if (abs(target - curSum) < abs(target - closest)) {\\n                    closest = curSum;\\n                }\\n\\n                if (target < curSum) {\\n                    r--;\\n                } else {\\n                    l++;\\n                }\\n            }\\n        }\\n\\n        return closest;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2695684,
                "title": "c-binary-search-o-nlogn-faster-than-99",
                "content": "* Firstly, sort the vector.\\n* Then, take first and last pointers(here, i and j) as first and last elements of the vector.\\n* Now, binary search over the remaining vector and find when the difference of the target and the sum -- (nums[i] + nums[j] + nums[mid] ), where mid is from the binary search. \\n* Now, likewise increase or decrease the mid acc to requirement (less or more than target).\\n* Fix, where the abs dif. is least. Store it. \\n* Now, acc to the sign of dif., increment or decrement i or j. Continue until i>j. \\n\\nThe code - \\n\\n```\\n class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int i,j;\\n        int near=0;\\n        int dif=INT_MAX;\\n        int act=INT_MAX;\\n        i=0;\\n        j=nums.size()-1;\\n        while (i<j){\\n            int low=i+1;\\n            int high= j-1;\\n            while (low<=high){\\n                int mid=(low+high)/2;\\n                near=nums[i]+nums[j]+nums[mid];\\n                if (near==target){\\n                    return target;\\n                }\\n                else if (near < target){\\n                    low=mid+1;\\n                    if (abs(dif)>abs(near-target)) dif=near-target;\\n                }\\n                else {\\n                    high=mid-1;\\n                    if (abs(dif)>abs(near-target)) dif=near-target;\\n                }\\n            }\\n            act=abs(act)<abs(dif)?act:dif;\\n            if (dif>0){\\n                j--;\\n            }\\n            else i++;\\n            dif=INT_MAX;\\n        }\\n        return act+target;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Math",
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "```\\n class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int i,j;\\n        int near=0;\\n        int dif=INT_MAX;\\n        int act=INT_MAX;\\n        i=0;\\n        j=nums.size()-1;\\n        while (i<j){\\n            int low=i+1;\\n            int high= j-1;\\n            while (low<=high){\\n                int mid=(low+high)/2;\\n                near=nums[i]+nums[j]+nums[mid];\\n                if (near==target){\\n                    return target;\\n                }\\n                else if (near < target){\\n                    low=mid+1;\\n                    if (abs(dif)>abs(near-target)) dif=near-target;\\n                }\\n                else {\\n                    high=mid-1;\\n                    if (abs(dif)>abs(near-target)) dif=near-target;\\n                }\\n            }\\n            act=abs(act)<abs(dif)?act:dif;\\n            if (dif>0){\\n                j--;\\n            }\\n            else i++;\\n            dif=INT_MAX;\\n        }\\n        return act+target;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2676920,
                "title": "python-99-62-faster-with-comments",
                "content": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        return self.kSumClosest(nums, 3, target)\\n        \\n    def kSumClosest(self, nums, k, target):\\n        N = len(nums)\\n        # Special case where we only have k elements in nums. Return only option\\n        if N == k:\\n            return sum(nums[:k])\\n        \\n        # special case where the target is way too low\\n        # we give the lowest we can\\n        if sum(nums[:k]) >= target:\\n            return sum(nums[:k])\\n        \\n        # special case where the target is too high\\n        # we give the largest we can\\n        if sum(nums[-k:]) <= target:\\n            return sum(nums[-k:])\\n        \\n        # base case. look for the closest element\\n        if k == 1:\\n            # the element is the first and the delta is the second\\n            deltas = [(x, abs(target-x)) for x in nums]\\n            return min(deltas, key = lambda x: x[1])[0]\\n        \\n        # pick one element out and recursively search for closest match with k being one less\\n        closest = sum(nums[:k])\\n        for i,x in enumerate(nums):\\n            # small optimization to handle duplicate x values\\n            if i>0 and nums[i-1] == x:\\n                continue\\n                \\n            bestMatch = self.kSumClosest(nums[i+1:], k-1, target-x)\\n            current = x + bestMatch\\n            if abs(target-current) < abs(target-closest):\\n                if target == current:\\n                    return current\\n                else:\\n                    closest = current\\n                    \\n        return closest\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        return self.kSumClosest(nums, 3, target)\\n        \\n    def kSumClosest(self, nums, k, target):\\n        N = len(nums)\\n        # Special case where we only have k elements in nums. Return only option\\n        if N == k:\\n            return sum(nums[:k])\\n        \\n        # special case where the target is way too low\\n        # we give the lowest we can\\n        if sum(nums[:k]) >= target:\\n            return sum(nums[:k])\\n        \\n        # special case where the target is too high\\n        # we give the largest we can\\n        if sum(nums[-k:]) <= target:\\n            return sum(nums[-k:])\\n        \\n        # base case. look for the closest element\\n        if k == 1:\\n            # the element is the first and the delta is the second\\n            deltas = [(x, abs(target-x)) for x in nums]\\n            return min(deltas, key = lambda x: x[1])[0]\\n        \\n        # pick one element out and recursively search for closest match with k being one less\\n        closest = sum(nums[:k])\\n        for i,x in enumerate(nums):\\n            # small optimization to handle duplicate x values\\n            if i>0 and nums[i-1] == x:\\n                continue\\n                \\n            bestMatch = self.kSumClosest(nums[i+1:], k-1, target-x)\\n            current = x + bestMatch\\n            if abs(target-current) < abs(target-closest):\\n                if target == current:\\n                    return current\\n                else:\\n                    closest = current\\n                    \\n        return closest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2676452,
                "title": "c-two-pointer-o-n-n-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int diff = INT_MAX;\\n        int ans = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int first = nums[i];  //first element\\n            int start = i+1;\\n            int end  = nums.size()-1;\\n            while(start < end){\\n                if(first + nums[start] + nums[end] == target) return target;\\n                else if(abs(first + nums[start]+nums[end] - target) < diff)\\n                {\\n                    diff = abs(first + nums[start]+nums[end] - target);\\n                    ans = first + nums[start]+nums[end];\\n                }\\n                \\n                if(first + nums[start] + nums[end] > target)\\n                {\\n                    end--;\\n                }\\n                else{\\n                    start++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Don\\'t forget to Upvote the post, if it\\'s been any help to you**",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int diff = INT_MAX;\\n        int ans = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int first = nums[i];  //first element\\n            int start = i+1;\\n            int end  = nums.size()-1;\\n            while(start < end){\\n                if(first + nums[start] + nums[end] == target) return target;\\n                else if(abs(first + nums[start]+nums[end] - target) < diff)\\n                {\\n                    diff = abs(first + nums[start]+nums[end] - target);\\n                    ans = first + nums[start]+nums[end];\\n                }\\n                \\n                if(first + nums[start] + nums[end] > target)\\n                {\\n                    end--;\\n                }\\n                else{\\n                    start++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2676281,
                "title": "java-98-23-two-pointers-binary-search",
                "content": "**Upvote  if you\\'re not greedy)))**\\n# Complexity\\n- Time complexity: n*log(n)\\n```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length - 1;\\n        Arrays.sort(nums);\\n\\n        int bestRes = Integer.MAX_VALUE;\\n        int minDif = Integer.MAX_VALUE;\\n        while (left < right - 1) {\\n            int tempSum = nums[left] + nums[right];\\n            int midValue = binary(nums, target - tempSum, left+1, right-1);\\n            tempSum += midValue;\\n            int dif = Math.abs(target - tempSum);\\n\\n            if (dif < minDif) {\\n                minDif = dif;\\n                bestRes = tempSum;\\n            }\\n\\n            if (tempSum == target) {\\n                return tempSum;\\n            } else if (tempSum < target) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n        }\\n        return bestRes;\\n    }\\n\\n    private int binary(int[] nums, int target, int left, int right) {\\n        int bestRes = Integer.MAX_VALUE;\\n        int minDif = Integer.MAX_VALUE;\\n        while (left <= right) {\\n            int mid = (right + left) / 2;\\n            int dif = Math.abs(target - nums[mid]);\\n            if (dif < minDif) {\\n                minDif = dif;\\n                bestRes = nums[mid];\\n            }\\n            if (target == nums[mid]) {\\n                return nums[mid];\\n            } else if (nums[mid] < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        return bestRes;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length - 1;\\n        Arrays.sort(nums);\\n\\n        int bestRes = Integer.MAX_VALUE;\\n        int minDif = Integer.MAX_VALUE;\\n        while (left < right - 1) {\\n            int tempSum = nums[left] + nums[right];\\n            int midValue = binary(nums, target - tempSum, left+1, right-1);\\n            tempSum += midValue;\\n            int dif = Math.abs(target - tempSum);\\n\\n            if (dif < minDif) {\\n                minDif = dif;\\n                bestRes = tempSum;\\n            }\\n\\n            if (tempSum == target) {\\n                return tempSum;\\n            } else if (tempSum < target) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n        }\\n        return bestRes;\\n    }\\n\\n    private int binary(int[] nums, int target, int left, int right) {\\n        int bestRes = Integer.MAX_VALUE;\\n        int minDif = Integer.MAX_VALUE;\\n        while (left <= right) {\\n            int mid = (right + left) / 2;\\n            int dif = Math.abs(target - nums[mid]);\\n            if (dif < minDif) {\\n                minDif = dif;\\n                bestRes = nums[mid];\\n            }\\n            if (target == nums[mid]) {\\n                return nums[mid];\\n            } else if (nums[mid] < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        return bestRes;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2675165,
                "title": "python-95-fast-with-binary-search-fewer-steps-in-the-inner-loop-still-o-n-2-in-time",
                "content": "Determine the initial pointers at the value of half of \\'target\\' - \\'nums[i]\\' by binary search, instead of two edges. This should have fewer inner loop steps.\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        n = len(nums)\\n        ans = 10**5\\n        nums.sort()\\n        for i in range(n-2):\\n            t = target - nums[i]\\n            left = bisect.bisect_left(nums[i+1:], t//2) + i+1\\n            if left >= n-1:\\n                left = n-2\\n            right = left + 1\\n            while left > i and right < n:\\n                eq = nums[left] + nums[right] - t\\n                if eq == 0:\\n                    return target\\n                elif eq > 0:\\n                    left -= 1\\n                else:\\n                    right += 1\\n                if abs(eq) < abs(ans):\\n                    ans = eq\\n        return target + ans\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        n = len(nums)\\n        ans = 10**5\\n        nums.sort()\\n        for i in range(n-2):\\n            t = target - nums[i]\\n            left = bisect.bisect_left(nums[i+1:], t//2) + i+1\\n            if left >= n-1:\\n                left = n-2\\n            right = left + 1\\n            while left > i and right < n:\\n                eq = nums[left] + nums[right] - t\\n                if eq == 0:\\n                    return target\\n                elif eq > 0:\\n                    left -= 1\\n                else:\\n                    right += 1\\n                if abs(eq) < abs(ans):\\n                    ans = eq\\n        return target + ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674477,
                "title": "java-98-faster-code-easy-solution",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\npublic int threeSumClosest(int[] nums, int target) {\\nArrays.sort(nums);\\nint closestSum = nums[0] + nums[1] + nums[2];\\nint leastDifference = Math.abs(target - closestSum);\\nif (leastDifference == 0) {\\nreturn closestSum;\\n}\\nint length = nums.length - 1;\\nint i = 0;\\nint maxSum = nums[length] + nums[length - 1];\\nint len = length - 3;\\nwhile (i < len && maxSum + nums[i] < target) {\\nclosestSum = maxSum + nums[i];\\nleastDifference = Math.abs(target - closestSum);\\ni++;\\n}\\nfor (; i <= length; i++) {\\nint small = i + 1;\\nint large = length;\\nwhile (small < large) {\\nint sum = nums[i] + nums[small] + nums[large];\\nint difference = target - sum;\\nint absDiff = Math.abs(difference);\\nif (absDiff < leastDifference) {\\nleastDifference = absDiff;\\nclosestSum = sum;\\nif (leastDifference == 0) {\\nreturn closestSum;\\n}\\n}\\nif (sum > target) {\\nlarge--;\\n} else {\\nsmall++;\\n}\\n}\\nif (i < len && nums[i] + nums[i + 1] + nums[i + 2] > target) {\\nbreak;\\n}\\n}\\nreturn closestSum;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic int threeSumClosest(int[] nums, int target) {\\nArrays.sort(nums);\\nint closestSum = nums[0] + nums[1] + nums[2];\\nint leastDifference = Math.abs(target - closestSum);\\nif (leastDifference == 0) {\\nreturn closestSum;\\n}\\nint length = nums.length - 1;\\nint i = 0;\\nint maxSum = nums[length] + nums[length - 1];\\nint len = length - 3;\\nwhile (i < len && maxSum + nums[i] < target) {\\nclosestSum = maxSum + nums[i];\\nleastDifference = Math.abs(target - closestSum);\\ni++;\\n}\\nfor (; i <= length; i++) {\\nint small = i + 1;\\nint large = length;\\nwhile (small < large) {\\nint sum = nums[i] + nums[small] + nums[large];\\nint difference = target - sum;\\nint absDiff = Math.abs(difference);\\nif (absDiff < leastDifference) {\\nleastDifference = absDiff;\\nclosestSum = sum;\\nif (leastDifference == 0) {\\nreturn closestSum;\\n}\\n}\\nif (sum > target) {\\nlarge--;\\n} else {\\nsmall++;\\n}\\n}\\nif (i < len && nums[i] + nums[i + 1] + nums[i + 2] > target) {\\nbreak;\\n}\\n}\\nreturn closestSum;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674375,
                "title": "c-python-short-concise",
                "content": "# C++\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int d = INT_MAX, ans;\\n        for(int i=0; i<nums.size(); i++) {\\n            int s = i + 1, e = nums.size() - 1;\\n            while(s < e) {\\n                int sum = nums[i] + nums[s] + nums[e];\\n                if(sum == target) return sum;\\n                if(abs(sum - target) < d) d = abs(sum - target), ans = sum;\\n                sum < target ? s++ : e--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n# Python\\n```\\nclass Solution(object):\\n    def threeSumClosest(self, nums, target):\\n        nums.sort()\\n        d, ans = float(\"inf\"), 0\\n        for i in range(len(nums) - 2):\\n            s, e = i + 1, len(nums) - 1\\n            while(s < e):\\n                sum = nums[i] + nums[s] + nums[e]\\n                if sum == target: return sum\\n                if abs(sum - target) < d:\\n                    d = abs(sum - target)\\n                    ans = sum\\n                if sum < target: s += 1\\n                else: e -= 1\\n        \\n        return ans\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Two Pointers",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int d = INT_MAX, ans;\\n        for(int i=0; i<nums.size(); i++) {\\n            int s = i + 1, e = nums.size() - 1;\\n            while(s < e) {\\n                int sum = nums[i] + nums[s] + nums[e];\\n                if(sum == target) return sum;\\n                if(abs(sum - target) < d) d = abs(sum - target), ans = sum;\\n                sum < target ? s++ : e--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\n```\\nclass Solution(object):\\n    def threeSumClosest(self, nums, target):\\n        nums.sort()\\n        d, ans = float(\"inf\"), 0\\n        for i in range(len(nums) - 2):\\n            s, e = i + 1, len(nums) - 1\\n            while(s < e):\\n                sum = nums[i] + nums[s] + nums[e]\\n                if sum == target: return sum\\n                if abs(sum - target) < d:\\n                    d = abs(sum - target)\\n                    ans = sum\\n                if sum < target: s += 1\\n                else: e -= 1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2546678,
                "title": "python-beginner-friendly-fast-two-pointers",
                "content": "Upvote if it helped. Thanks\\n\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        ans = 0\\n        diff = 10000\\n        for cur_ind in range (len (nums)-1):\\n            left, right = cur_ind + 1, len(nums)-1 \\n            while left < right :\\n                threesum = nums[cur_ind] + nums[left] + nums[right]\\n                if threesum == target :\\n                    return threesum\\n                if abs(threesum - target) < diff:\\n                    diff = abs(threesum - target)\\n                    ans = threesum\\n                if threesum < target :\\n                    left += 1\\n                elif threesum > target:\\n                    right -= 1\\n        return ans\\n    \\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        ans = 0\\n        diff = 10000\\n        for cur_ind in range (len (nums)-1):\\n            left, right = cur_ind + 1, len(nums)-1 \\n            while left < right :\\n                threesum = nums[cur_ind] + nums[left] + nums[right]\\n                if threesum == target :\\n                    return threesum\\n                if abs(threesum - target) < diff:\\n                    diff = abs(threesum - target)\\n                    ans = threesum\\n                if threesum < target :\\n                    left += 1\\n                elif threesum > target:\\n                    right -= 1\\n        return ans\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2431292,
                "title": "python-c-java-kotlin-beginner-level-as-simple-as-u-think-simple-short-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome*.**\\n___________________\\n_________________\\n***Q16. 3Sum Closest***\\nGiven an integer array `nums` of length `n` and an integer `targe`t, find three integers in nums such that the sum is closest to `target`.\\n\\nReturn the sum of the three integers.\\n\\nYou may assume that each input would have exactly one solution.\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Python  Code** :\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        res = sum(nums[:3])\\n        for i in range(len(nums)):\\n            l, r = i+1, len(nums)-1\\n            while l < r:\\n                s = sum((nums[i], nums[l], nums[r]))\\n                if abs(s-target) < abs(res-target):\\n                    res = s\\n                if s < target:\\n                    l += 1\\n                elif s > target:\\n                    r -= 1\\n                else: # break early \\n                    return res\\n        return res\\n```\\n**Runtime:**  53 ms\\t\\n**Memory Usage:**  13.9 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\n\\u2705 **Java Code** :\\n```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int output = nums[0] + nums[1] + nums[nums.length - 1];\\n        for(int i = 0; i < nums.length - 2; i++)\\n        {\\n            int j = i + 1;\\n            int k = nums.length - 1;\\n            while(j < k)\\n            {\\n                int currSum = nums[i] + nums[j] + nums[k];\\n                if(currSum > target)\\n                    k--;\\n                else\\n                    j++;\\n                \\n                if(Math.abs(currSum - target) < Math.abs(output - target))\\n                    output = currSum;\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```\\n**Runtime:**  174 ms\\t\\n**Memory Usage:**  48.6 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **C++  Code** :\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n            int l,r,f=0,ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int t=target-nums[i];\\n            l=i+1;\\n            r=nums.size()-1;\\n            int sum=0;\\n            while(l<r)\\n            {\\n                sum=nums[l]+nums[r];\\n                if(abs(target-sum-nums[i])<abs(target-ans))\\n                    ans=sum+nums[i];\\n                if(sum==t)\\n                {\\n                    f=1;\\n                    break;\\n                }\\n                else if(sum>t)\\n                    r--;\\n                else\\n                    l++;\\n            }\\n            if(f)\\n                break;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Runtime:**  247 ms\\t\\n**Memory Usage:**  16.4 MB\\t\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Kotlin  Code** :\\n**Your runtime beats 89.21 % of kotlin submissions.**\\n```\\nclass Solution {\\n    fun threeSumClosest(nums: IntArray, target: Int): Int {\\n        var closest = nums.first() + nums[1] + nums.last()\\n        val list = nums.sorted()\\n        (0..list.size - 2).forEach {\\n            var second = it + 1\\n            var end = list.size - 1\\n            while (second < end) {\\n                var sum = list[it] + list[second] + list[end]\\n                if (sum > target) end-- else second++\\n                if (Math.abs(sum - target) < Math.abs(closest - target)) closest = sum\\n            }\\n        }\\n\\n        return closest\\n    }\\n}\\n```\\n**Runtime:**  971 ms\\t\\n**Memory Usage:**  51.1 MB\\t\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Kotlin",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        res = sum(nums[:3])\\n        for i in range(len(nums)):\\n            l, r = i+1, len(nums)-1\\n            while l < r:\\n                s = sum((nums[i], nums[l], nums[r]))\\n                if abs(s-target) < abs(res-target):\\n                    res = s\\n                if s < target:\\n                    l += 1\\n                elif s > target:\\n                    r -= 1\\n                else: # break early \\n                    return res\\n        return res\\n```\n```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int output = nums[0] + nums[1] + nums[nums.length - 1];\\n        for(int i = 0; i < nums.length - 2; i++)\\n        {\\n            int j = i + 1;\\n            int k = nums.length - 1;\\n            while(j < k)\\n            {\\n                int currSum = nums[i] + nums[j] + nums[k];\\n                if(currSum > target)\\n                    k--;\\n                else\\n                    j++;\\n                \\n                if(Math.abs(currSum - target) < Math.abs(output - target))\\n                    output = currSum;\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n            int l,r,f=0,ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int t=target-nums[i];\\n            l=i+1;\\n            r=nums.size()-1;\\n            int sum=0;\\n            while(l<r)\\n            {\\n                sum=nums[l]+nums[r];\\n                if(abs(target-sum-nums[i])<abs(target-ans))\\n                    ans=sum+nums[i];\\n                if(sum==t)\\n                {\\n                    f=1;\\n                    break;\\n                }\\n                else if(sum>t)\\n                    r--;\\n                else\\n                    l++;\\n            }\\n            if(f)\\n                break;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    fun threeSumClosest(nums: IntArray, target: Int): Int {\\n        var closest = nums.first() + nums[1] + nums.last()\\n        val list = nums.sorted()\\n        (0..list.size - 2).forEach {\\n            var second = it + 1\\n            var end = list.size - 1\\n            while (second < end) {\\n                var sum = list[it] + list[second] + list[end]\\n                if (sum > target) end-- else second++\\n                if (Math.abs(sum - target) < Math.abs(closest - target)) closest = sum\\n            }\\n        }\\n\\n        return closest\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424972,
                "title": "c",
                "content": "```\\npublic class Solution\\n{\\n    public int ThreeSumClosest(int[] nums, int target) \\n    {\\n        Array.Sort(nums);\\n\\n        int closest = int.MaxValue, diff = int.MaxValue;\\n\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            int l = i + 1, r = nums.Length - 1;\\n\\n            while (l < r)\\n            {\\n                int s = nums[i] + nums[l] + nums[r];\\n                if (Math.Abs(s - target) < diff)\\n                {\\n                    diff = Math.Abs(s - target);\\n                    closest = s;\\n                }\\n\\n                if (s > target)\\n                {\\n                    r--;\\n                }\\n                else\\n                {\\n                    l++;\\n                }\\n            }                \\n        }\\n\\n        return closest;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public int ThreeSumClosest(int[] nums, int target) \\n    {\\n        Array.Sort(nums);\\n\\n        int closest = int.MaxValue, diff = int.MaxValue;\\n\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            int l = i + 1, r = nums.Length - 1;\\n\\n            while (l < r)\\n            {\\n                int s = nums[i] + nums[l] + nums[r];\\n                if (Math.Abs(s - target) < diff)\\n                {\\n                    diff = Math.Abs(s - target);\\n                    closest = s;\\n                }\\n\\n                if (s > target)\\n                {\\n                    r--;\\n                }\\n                else\\n                {\\n                    l++;\\n                }\\n            }                \\n        }\\n\\n        return closest;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2125533,
                "title": "easy-c-solution-0-n-2-two-pointer-approach",
                "content": "The Naive approach of this is used a three pointers and calculate the diff i.e` target-(nums[i] +nums[j] +nums[k])` and check if this is closet to target if yes then `update `else check another index...\\nIn this way We take 0(n^3) time complexity...\\n\\nCan We do better?? .......\\nYes We can\\n\\nNow suppose if i give u a problem to find the two integer which is closest to target and the array is sorted then how can you solve.......?\\n**Ans**- Obviously first thing come in my mind is use of two pointer `si,ei` where `si=0` and` ei=n-1`\\nand it takes 0(n) time complexity;...................Algo(1)\\n\\nNow we use two pointer approach in given array for every array index element how.? Lets understand..\\n\\nsuppose `target=x`\\nand i want to find three integers sum which is closest to target..\\nnow we break this into subproblem..\\nie. if at` index i` then our new target is find` target-(nums[i)` from `si=i+1` to `ei=n-1` by using Algo(1) we disscused previously \\nInitially our global` clsdiff `variable is used update when we find` diff` which is less than our` clsdiff` \\nand when we update then we store three integers in `a,b,c`\\n\\nHere is code...\\n\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n      int a,b,c;\\n      int clsdiff=INT_MAX;\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n-2;i++){\\n            int si=i+1;\\n            int ei=n-1;\\n            int ntarget=target-nums[i];\\n            int na=nums[i];\\n            int nb,nc;\\n            int diff=INT_MAX;\\n            while(si<ei){\\n                if(abs(ntarget-(nums[si]+nums[ei]))<diff){\\n                    diff=abs(ntarget-(nums[si]+nums[ei]));\\n                    nb=nums[si];\\n                    nc=nums[ei];\\n                }\\n                \\n                if(nums[si]+nums[ei]>ntarget){\\n                    ei--;\\n                }\\n                else{\\n                    si++;\\n                }      \\n            }\\n            if(diff<clsdiff){\\n                clsdiff=diff;\\n                a=na;\\n                b=nb;\\n                c=nc;\\n            }\\n        } \\n        return a+b+c;\\n    }\\n};\\n```\\n** Time Complextiy-0(n^2) space complexity-0(1)**\\n\\n***Please upvote if you find helpful***\\n",
                "solutionTags": [
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n      int a,b,c;\\n      int clsdiff=INT_MAX;\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n-2;i++){\\n            int si=i+1;\\n            int ei=n-1;\\n            int ntarget=target-nums[i];\\n            int na=nums[i];\\n            int nb,nc;\\n            int diff=INT_MAX;\\n            while(si<ei){\\n                if(abs(ntarget-(nums[si]+nums[ei]))<diff){\\n                    diff=abs(ntarget-(nums[si]+nums[ei]));\\n                    nb=nums[si];\\n                    nc=nums[ei];\\n                }\\n                \\n                if(nums[si]+nums[ei]>ntarget){\\n                    ei--;\\n                }\\n                else{\\n                    si++;\\n                }      \\n            }\\n            if(diff<clsdiff){\\n                clsdiff=diff;\\n                a=na;\\n                b=nb;\\n                c=nc;\\n            }\\n        } \\n        return a+b+c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1899763,
                "title": "python-easy-to-read-and-understand-sorting",
                "content": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        ans, diff = 0, float(\"inf\")\\n        n = len(nums)\\n        \\n        for i in range(n-2):\\n            j, k = i+1, n-1\\n            while j < k:\\n                sums = nums[i] + nums[j] + nums[k]\\n                if sums == target:\\n                    return sums\\n                if abs(sums-target) <= diff:\\n                    diff = abs(sums-target)\\n                    ans = sums\\n                if sums < target:\\n                    j += 1\\n                else:\\n                    k -= 1\\n        \\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        ans, diff = 0, float(\"inf\")\\n        n = len(nums)\\n        \\n        for i in range(n-2):\\n            j, k = i+1, n-1\\n            while j < k:\\n                sums = nums[i] + nums[j] + nums[k]\\n                if sums == target:\\n                    return sums\\n                if abs(sums-target) <= diff:\\n                    diff = abs(sums-target)\\n                    ans = sums\\n                if sums < target:\\n                    j += 1\\n                else:\\n                    k -= 1\\n        \\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1541433,
                "title": "c-simple-solution-beats-90",
                "content": "class Solution {\\npublic:\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int n = nums.size();\\n        int closest, min = INT_MAX;\\n        \\n        for(int i=0 ; i<n-2 ; ++i)\\n        {\\n            if(i==0 || nums[i]!=nums[i-1])\\n            {\\n                int low = i+1;\\n                int high = n-1;\\n                while(low<high)\\n                {\\n                    int sum = nums[i] + nums[low] + nums[high];\\n                    if(sum == target) return sum;\\n                    else if(sum > target) high--;\\n                    else low++;\\n                    \\n                    if(abs(sum-target)<min)\\n                    {\\n                        closest = sum;\\n                        min = abs(sum-target);\\n                    }\\n                }\\n            }\\n        }\\n        return closest;\\n    }\\n};\\n**leave a like.**",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int n = nums.size();\\n        int closest, min = INT_MAX;\\n        \\n        for(int i=0 ; i<n-2 ; ++i)\\n        {\\n            if(i==0 || nums[i]!=nums[i-1])\\n            {\\n                int low = i+1;\\n                int high = n-1;\\n                while(low<high)\\n                {\\n                    int sum = nums[i] + nums[low] + nums[high];\\n                    if(sum == target) return sum;\\n                    else if(sum > target) high--;\\n                    else low++;\\n                    \\n                    if(abs(sum-target)<min)\\n                    {\\n                        closest = sum;\\n                        min = abs(sum-target);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1453442,
                "title": "beginner-friendly-java-javascript-solution",
                "content": "**Java**\\n```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int closestsum = Integer.MAX_VALUE;\\n        for(int i=0; i < nums.length - 2; i++) {\\n            int l = i+1;\\n            int r = nums.length - 1;\\n            int sum = 0;\\n            while(l < r) {\\n                sum = nums[i] + nums[l] + nums[r];\\n                if(Math.abs(target - sum) < Math.abs(closestsum))\\n                    closestsum = target - sum;\\n                if( sum < target )\\n                    l++;\\n                else\\n                    r--;\\n            }\\n        }\\n        return target - closestsum;\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a,b) => a-b)\\n    let closestSum = Number.MAX_VALUE\\n    for(let i=0; i<nums.length-2; i++){\\n        let l = i+1, r = nums.length-1, sum = 0\\n        while(l < r){\\n            sum = nums[i] + nums[l] + nums[r]\\n            if(Math.abs(target - sum) < Math.abs(closestSum))    closestSum = target - sum\\n            if(sum < target)    l++\\n            else    r--\\n        }\\n    }\\n    return target - closestSum\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int closestsum = Integer.MAX_VALUE;\\n        for(int i=0; i < nums.length - 2; i++) {\\n            int l = i+1;\\n            int r = nums.length - 1;\\n            int sum = 0;\\n            while(l < r) {\\n                sum = nums[i] + nums[l] + nums[r];\\n                if(Math.abs(target - sum) < Math.abs(closestsum))\\n                    closestsum = target - sum;\\n                if( sum < target )\\n                    l++;\\n                else\\n                    r--;\\n            }\\n        }\\n        return target - closestsum;\\n    }\\n}\\n```\n```\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a,b) => a-b)\\n    let closestSum = Number.MAX_VALUE\\n    for(let i=0; i<nums.length-2; i++){\\n        let l = i+1, r = nums.length-1, sum = 0\\n        while(l < r){\\n            sum = nums[i] + nums[l] + nums[r]\\n            if(Math.abs(target - sum) < Math.abs(closestSum))    closestSum = target - sum\\n            if(sum < target)    l++\\n            else    r--\\n        }\\n    }\\n    return target - closestSum\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186601,
                "title": "javascript-beats-99-60",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a,b)=>a-b);\\n    let min = Infinity;\\n    for (let i = 0; i < nums.length; i ++) {\\n        let left = i + 1,\\n            right = nums.length -1;\\n        while (left < right) {\\n            let sum = nums[i] + nums[left] + nums[right];\\n            if (Math.abs(sum - target) < Math.abs(min - target)) min = sum;\\n            if (sum > target) {\\n                right --\\n            } else {\\n                left ++\\n            }\\n        }\\n    }\\n    return min;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a,b)=>a-b);\\n    let min = Infinity;\\n    for (let i = 0; i < nums.length; i ++) {\\n        let left = i + 1,\\n            right = nums.length -1;\\n        while (left < right) {\\n            let sum = nums[i] + nums[left] + nums[right];\\n            if (Math.abs(sum - target) < Math.abs(min - target)) min = sum;\\n            if (sum > target) {\\n                right --\\n            } else {\\n                left ++\\n            }\\n        }\\n    }\\n    return min;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 553528,
                "title": "java-o-n-2-solution-using-sort-adds-on-twosum",
                "content": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        //base case\\n        if (nums == null) return -1;\\n        \\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int ans = Integer.MAX_VALUE;\\n        int minDiff = Integer.MAX_VALUE;\\n        for(int i=0; i<n-2; i++){\\n            int sum = twoSum(nums, i, target, ans, minDiff);\\n            if(Math.abs(target - sum) == 0) return sum;\\n            if(Math.abs(target - sum) <= minDiff)\\n            {\\n                ans = sum;\\n                minDiff = Math.abs(target - sum);\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    private int twoSum(int[] nums, int rootIndex, int target, int summ, int minDiff){\\n        int left = rootIndex + 1;\\n        int right = nums.length - 1;\\n        while(left < right){\\n            int sum = nums[rootIndex] + nums[left] + nums[right];\\n            int diff = Math.abs(target - sum);\\n            if(diff <= minDiff) {\\n                minDiff = diff;\\n                summ = sum;\\n            }\\n            if(minDiff == 0)\\n                return sum;\\n            if(sum > target){\\n                right--;\\n            }\\n            else{\\n                left++;\\n            }\\n        }\\n        return summ;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        //base case\\n        if (nums == null) return -1;\\n        \\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int ans = Integer.MAX_VALUE;\\n        int minDiff = Integer.MAX_VALUE;\\n        for(int i=0; i<n-2; i++){\\n            int sum = twoSum(nums, i, target, ans, minDiff);\\n            if(Math.abs(target - sum) == 0) return sum;\\n            if(Math.abs(target - sum) <= minDiff)\\n            {\\n                ans = sum;\\n                minDiff = Math.abs(target - sum);\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    private int twoSum(int[] nums, int rootIndex, int target, int summ, int minDiff){\\n        int left = rootIndex + 1;\\n        int right = nums.length - 1;\\n        while(left < right){\\n            int sum = nums[rootIndex] + nums[left] + nums[right];\\n            int diff = Math.abs(target - sum);\\n            if(diff <= minDiff) {\\n                minDiff = diff;\\n                summ = sum;\\n            }\\n            if(minDiff == 0)\\n                return sum;\\n            if(sum > target){\\n                right--;\\n            }\\n            else{\\n                left++;\\n            }\\n        }\\n        return summ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 550566,
                "title": "python-o-n-2-easy-to-follow-solution",
                "content": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        closest = nums[0] + nums[1] + nums[2]\\n        nums.sort()\\n        \\n        for i in range(len(nums) - 2):\\n            l = i + 1\\n            r = len(nums) - 1\\n            \\n            while l < r:\\n                total = nums[i] + nums[l] + nums[r]\\n                if abs(target - total) < abs(target - closest):\\n                    closest = total\\n                    \\n                if total < target:\\n                    l += 1\\n                elif total > target:\\n                    r -= 1\\n                else:\\n                    return closest\\n                \\n        return closest \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        closest = nums[0] + nums[1] + nums[2]\\n        nums.sort()\\n        \\n        for i in range(len(nums) - 2):\\n            l = i + 1\\n            r = len(nums) - 1\\n            \\n            while l < r:\\n                total = nums[i] + nums[l] + nums[r]\\n                if abs(target - total) < abs(target - closest):\\n                    closest = total\\n                    \\n                if total < target:\\n                    l += 1\\n                elif total > target:\\n                    r -= 1\\n                else:\\n                    return closest\\n                \\n        return closest \\n```",
                "codeTag": "Java"
            },
            {
                "id": 419093,
                "title": "multiple-approaches-with-explanation",
                "content": "##### Approach 1: Brute Force Solution\\n```java\\n public int threeSumClosest(int[] nums, int target) {\\n        int min = nums[0] + nums[1] + nums[2];\\n        int len = nums.length;\\n        for(int i=0; i<len; i++) {\\n            for(int j=i+1; j<len; j++) {\\n                for(int k=j+1; k<len; k++) {\\n                    int sum = nums[i] + nums[j] + nums[k];\\n                    if(Math.abs(target - min) >  Math.abs(target - sum)) {\\n                        min = sum;\\n                    }\\n                }\\n            }\\n        }\\n        return min;\\n    }\\n```\\n#####\\tAssumption: \\n- The min value is the sum of the first three elements in the given array and we use this as our starting point to look for the minimum value that is closest to the target\\n##### Complexity\\n- Time Complexity: O(n^3)\\n- Space Complexity: O(n)\\n\\n##### Approach 2:  Two Pointer Solution\\n```java\\n    public int threeSumClosest(int[] nums, int target) {\\n\\t    // sort the given input to make use of the two pointer solution\\n        Arrays.sort(nums);\\n\\t\\t// assumping our min value to be the sum of the first three elements\\n        int min = nums[0] + nums[1] + nums[2];\\n        for(int i=0; i<nums.length; i++) {\\n            int start = i+1;\\n            int end = nums.length-1;\\n            while(start < end) {\\n                int sum = nums[i] + nums[start] + nums[end];\\n\\t\\t\\t\\t// if the diff between the target and sum is minimum than the assumed then update the value with new minimum value\\n                if(Math.abs(target - min) > Math.abs(target - sum)) {\\n                    min = sum;\\n                }\\n                \\n\\t\\t\\t\\t// increment or decrement the pointers based on the sum that we found in the previous steps, return the result if the sum is neither greater than nor lesser than the target meaning that we found our closest value to the target\\n                if(sum > target) {\\n                    end--;\\n                } else if(sum < target){\\n                    start++;\\n                } else {\\n                    return target;\\n                }\\n            }\\n        }\\n        return min;\\n    }\\n```\\n##### Complexity\\n- Time Complexity: O(n^2)\\n- Space Complexity: O(n)\\n\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```java\\n public int threeSumClosest(int[] nums, int target) {\\n        int min = nums[0] + nums[1] + nums[2];\\n        int len = nums.length;\\n        for(int i=0; i<len; i++) {\\n            for(int j=i+1; j<len; j++) {\\n                for(int k=j+1; k<len; k++) {\\n                    int sum = nums[i] + nums[j] + nums[k];\\n                    if(Math.abs(target - min) >  Math.abs(target - sum)) {\\n                        min = sum;\\n                    }\\n                }\\n            }\\n        }\\n        return min;\\n    }\\n```\n```java\\n    public int threeSumClosest(int[] nums, int target) {\\n\\t    // sort the given input to make use of the two pointer solution\\n        Arrays.sort(nums);\\n\\t\\t// assumping our min value to be the sum of the first three elements\\n        int min = nums[0] + nums[1] + nums[2];\\n        for(int i=0; i<nums.length; i++) {\\n            int start = i+1;\\n            int end = nums.length-1;\\n            while(start < end) {\\n                int sum = nums[i] + nums[start] + nums[end];\\n\\t\\t\\t\\t// if the diff between the target and sum is minimum than the assumed then update the value with new minimum value\\n                if(Math.abs(target - min) > Math.abs(target - sum)) {\\n                    min = sum;\\n                }\\n                \\n\\t\\t\\t\\t// increment or decrement the pointers based on the sum that we found in the previous steps, return the result if the sum is neither greater than nor lesser than the target meaning that we found our closest value to the target\\n                if(sum > target) {\\n                    end--;\\n                } else if(sum < target){\\n                    start++;\\n                } else {\\n                    return target;\\n                }\\n            }\\n        }\\n        return min;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 395240,
                "title": "python-2-pointer-solution",
                "content": "```python\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        ans = sum(nums[:3])\\n        \\n        for i in range(len(nums)-2):\\n            k = len(nums)-1 \\n            j = i + 1 \\n          \\n            while j < k:\\n                close_sum = nums[i] + nums[j] + nums[k]\\n                \\n                if close_sum == target:\\n                    return close_sum\\n                \\n                if abs(close_sum - target) < abs(ans - target):\\n                    ans = close_sum\\n                \\n                if close_sum < target:\\n                    j += 1\\n                elif close_sum > target: \\n                    k -= 1\\n                else: \\n                    break\\n                          \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```python\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        ans = sum(nums[:3])\\n        \\n        for i in range(len(nums)-2):\\n            k = len(nums)-1 \\n            j = i + 1 \\n          \\n            while j < k:\\n                close_sum = nums[i] + nums[j] + nums[k]\\n                \\n                if close_sum == target:\\n                    return close_sum\\n                \\n                if abs(close_sum - target) < abs(ans - target):\\n                    ans = close_sum\\n                \\n                if close_sum < target:\\n                    j += 1\\n                elif close_sum > target: \\n                    k -= 1\\n                else: \\n                    break\\n                          \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 301562,
                "title": "python-solution-40ms-beat-99",
                "content": "```python\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        res = sum(nums[:3])\\n        # ensure diff as a postive integer, so don\\'t need use abs().\\n        diff = target - res if target > res else res - target\\n        \\n        \\n        for i in range(len(nums) - 2):\\n\\n            if i > 0 and nums[i] == nums[i - 1]:\\n                # skip adjadcent duplicates\\n                continue\\n                \\n            l, r = i + 1, len(nums) - 1\\n            if nums[i] + nums[r-1] + nums[r] <= target:\\n                # compare with the largest subset\\n                \\n                s = nums[i] + nums[r-1] + nums[r]\\n                if s == target:\\n                    return s\\n\\n                if target - s < diff:\\n                    res = s\\n                    diff = target - s\\n\\n            elif nums[i] + nums[l] + nums[l+1] >= target:\\n                # compare with the smallest subset\\n                \\n                s = nums[i] + nums[l] + nums[l+1]\\n                if s == target:\\n                    return s\\n\\n                if s - target < diff:\\n                    res = s\\n                    diff = s - target\\n            else:\\n                while l < r:\\n                    s = nums[i] + nums[l] + nums[r]\\n\\n                    if s == target:\\n                        return s\\n                    elif s < target:\\n                        l += 1\\n                        if target - s < diff:\\n                            res = s\\n                            diff = target - s\\n                    else:\\n                        r -= 1\\n                        if s - target < diff:\\n                            res = s\\n                            diff = s - target\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        res = sum(nums[:3])\\n        # ensure diff as a postive integer, so don\\'t need use abs().\\n        diff = target - res if target > res else res - target\\n        \\n        \\n        for i in range(len(nums) - 2):\\n\\n            if i > 0 and nums[i] == nums[i - 1]:\\n                # skip adjadcent duplicates\\n                continue\\n                \\n            l, r = i + 1, len(nums) - 1\\n            if nums[i] + nums[r-1] + nums[r] <= target:\\n                # compare with the largest subset\\n                \\n                s = nums[i] + nums[r-1] + nums[r]\\n                if s == target:\\n                    return s\\n\\n                if target - s < diff:\\n                    res = s\\n                    diff = target - s\\n\\n            elif nums[i] + nums[l] + nums[l+1] >= target:\\n                # compare with the smallest subset\\n                \\n                s = nums[i] + nums[l] + nums[l+1]\\n                if s == target:\\n                    return s\\n\\n                if s - target < diff:\\n                    res = s\\n                    diff = s - target\\n            else:\\n                while l < r:\\n                    s = nums[i] + nums[l] + nums[r]\\n\\n                    if s == target:\\n                        return s\\n                    elif s < target:\\n                        l += 1\\n                        if target - s < diff:\\n                            res = s\\n                            diff = target - s\\n                    else:\\n                        r -= 1\\n                        if s - target < diff:\\n                            res = s\\n                            diff = s - target\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 229111,
                "title": "rust-0ms",
                "content": "Unfortunately with range iterators it\\'s much slower.\\n\\n```rust\\nimpl Solution {\\n    pub fn three_sum_closest(nums: Vec<i32>, target: i32) -> i32 {\\n        if nums.len() <= 3 {\\n            return nums.into_iter().sum();\\n        }\\n\\n        let mut nums = nums;\\n        nums.sort();\\n\\n        let mut closest = nums[0] + nums[1] + nums[2];\\n        let mut min_diff = (closest - target).abs();\\n        \\n        let mut a = 0;\\n\\t\\t\\n        while a < nums.len() - 2 {\\n\\t\\t\\n            let mut b = nums.len() - 1;\\n            let mut c = a + 1;\\n\\t\\t\\t\\n            while c < b {\\n                let sum = nums[a] + nums[b] + nums[c];\\n                let diff = (sum - target).abs();\\n\\n                if diff < min_diff {\\n                    closest = sum;\\n                    min_diff = diff;\\n                }\\n\\n                if sum > target {\\n                    b -= 1;\\n                } else if sum < target {\\n                    c += 1;\\n                } else {\\n                    return closest\\n                }\\n                \\n            }\\n                \\n            a += 1;\\n        }\\n\\n        closest\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn three_sum_closest(nums: Vec<i32>, target: i32) -> i32 {\\n        if nums.len() <= 3 {\\n            return nums.into_iter().sum();\\n        }\\n\\n        let mut nums = nums;\\n        nums.sort();\\n\\n        let mut closest = nums[0] + nums[1] + nums[2];\\n        let mut min_diff = (closest - target).abs();\\n        \\n        let mut a = 0;\\n\\t\\t\\n        while a < nums.len() - 2 {\\n\\t\\t\\n            let mut b = nums.len() - 1;\\n            let mut c = a + 1;\\n\\t\\t\\t\\n            while c < b {\\n                let sum = nums[a] + nums[b] + nums[c];\\n                let diff = (sum - target).abs();\\n\\n                if diff < min_diff {\\n                    closest = sum;\\n                    min_diff = diff;\\n                }\\n\\n                if sum > target {\\n                    b -= 1;\\n                } else if sum < target {\\n                    c += 1;\\n                } else {\\n                    return closest\\n                }\\n                \\n            }\\n                \\n            a += 1;\\n        }\\n\\n        closest\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 128797,
                "title": "python-44ms-beats-100-00",
                "content": "In each loop,\\nI judge if current number plus two largest numbers less than target,\\nor current number plus two lowest numbers greater than target.\\n\\n```python\\n        nums.sort()\\n        length = len(nums)\\n        closest = []\\n        \\n        for i, num in enumerate(nums[0:-2]):\\n            l,r = i+1, length-1\\n\\t\\t\\t\\t\\t\\t\\n            # different with others\\' solution\\n\\t\\t\\t\\t\\t\\t\\n            if num+nums[r]+nums[r-1] < target:\\n                closest.append(num+nums[r]+nums[r-1])\\n            elif num+nums[l]+nums[l+1] > target:\\n                closest.append(num+nums[l]+nums[l+1])\\n            else:\\n                while l < r:\\n                    closest.append(num+nums[l]+nums[r])\\n                    if num+nums[l]+nums[r] < target:\\n                        l += 1\\n                    elif num+nums[l]+nums[r] > target:\\n                        r -= 1\\n                    else:\\n                        return target\\n                    \\n        closest.sort(key=lambda x:abs(x-target))\\n        return closest[0]\\n```",
                "solutionTags": [],
                "code": "```python\\n        nums.sort()\\n        length = len(nums)\\n        closest = []\\n        \\n        for i, num in enumerate(nums[0:-2]):\\n            l,r = i+1, length-1\\n\\t\\t\\t\\t\\t\\t\\n            # different with others\\' solution\\n\\t\\t\\t\\t\\t\\t\\n            if num+nums[r]+nums[r-1] < target:\\n                closest.append(num+nums[r]+nums[r-1])\\n            elif num+nums[l]+nums[l+1] > target:\\n                closest.append(num+nums[l]+nums[l+1])\\n            else:\\n                while l < r:\\n                    closest.append(num+nums[l]+nums[r])\\n                    if num+nums[l]+nums[r] < target:\\n                        l += 1\\n                    elif num+nums[l]+nums[r] > target:\\n                        r -= 1\\n                    else:\\n                        return target\\n                    \\n        closest.sort(key=lambda x:abs(x-target))\\n        return closest[0]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 7971,
                "title": "a-12ms-easy-understanding-solution",
                "content": "    class Solution {\\n    public:\\n        int threeSumClosest(vector<int>& nums, int target) {\\n            int len = nums.size();\\n            int sum = 0, minsum = 0;;\\n            int dif = INT_MAX;\\n            if(len < 3) {\\n                for(int i = 0; i < len; i++) sum += nums[i];\\n                return sum;\\n            }\\n            \\n            int left, right;\\n            sort(nums.begin(),nums.end());\\n            \\n            for(int i = 0; i < (len - 2); i++) {\\n                left = i + 1;\\n                right = len - 1;\\n                while(left < right) {\\n                    sum = nums[i] + nums[left] + nums[right];\\n                    if(abs(sum - target) <= dif) {\\n                        dif = abs(sum - target);\\n                        minsum = sum;\\n                    }\\n                    if(sum > target) right--;\\n                    if(sum < target) left++;\\n                    if(sum == target) return minsum;\\n                }\\n            }\\n            return minsum;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n    public:\\n        int threeSumClosest(vector<int>& nums, int target) {\\n            int len = nums.size();\\n            int sum = 0, minsum = 0;;\\n            int dif = INT_MAX;\\n            if(len < 3) {\\n                for(int i = 0; i < len; i++) sum += nums[i];\\n                return sum;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 8011,
                "title": "java-o-n-2-clean-and-clear-solution",
                "content": "    public class Solution {\\n        public int threeSumClosest(int[] nums, int target) {\\n            Arrays.sort(nums);\\n            int min_diff = Integer.MAX_VALUE;\\n            for(int i=0; i<nums.length-2; ++i){\\n                int p = i+1, q = nums.length-1;\\n                while(p<q){\\n                    int diff = nums[i]+nums[p]+nums[q] - target;\\n                    if(diff == 0)   return target;\\n                    min_diff = Math.abs(diff)<Math.abs(min_diff) ? diff: min_diff;\\n                    if(diff>0)  --q;\\n                    else    ++p;\\n                }\\n            }\\n            return target + min_diff;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n        public int threeSumClosest(int[] nums, int target) {\\n            Arrays.sort(nums);\\n            int min_diff = Integer.MAX_VALUE;\\n            for(int i=0; i<nums.length-2; ++i){\\n                int p = i+1, q = nums.length-1;\\n                while(p<q){\\n                    int diff = nums[i]+nums[p]+nums[q] - target;\\n                    if(diff == 0)   return target;\\n                    min_diff = Math.abs(diff)<Math.abs(min_diff) ? diff: min_diff;\\n                    if(diff>0)  --q;\\n                    else    ++p;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 8044,
                "title": "my-aceepted-o-n-2-solution-in-c",
                "content": "    class Solution {\\n    public:\\n        int threeSumClosest(vector<int> &num, int target)\\n        {\\n    \\t\\tint clostAbs=INT_MAX;\\n    \\t\\tint clostSum=num[0]+num[1]+num[2];\\n    \\t\\tint low;\\n        \\tint high;\\n        \\tint sum=0;\\n        \\tsort(num.begin(),num.end());\\n        \\tfor(int i=0;i<num.size()-2;i++)\\n        \\t{\\n        \\t\\tlow=i+1;\\n        \\t\\thigh=num.size()-1;\\n        \\t\\twhile(low<high)\\n        \\t\\t{\\n        \\t\\t\\tsum=num[low]+num[high];\\n    \\t\\t\\t\\tif(abs(sum+num[i]-target)<clostAbs)\\n    \\t\\t\\t\\t{\\n    \\t\\t\\t\\t\\tclostAbs=abs(sum+num[i]-target);\\n    \\t\\t\\t\\t\\tclostSum=sum+num[i];\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\t\\n        \\t\\t\\tif(sum>(target-num[i]))\\n    \\t\\t\\t\\t{\\n        \\t\\t\\t\\thigh--;\\n    \\t\\t\\t\\t}\\n        \\t\\t\\telse\\n    \\t\\t\\t\\t{\\n        \\t\\t\\t\\tlow++;\\n    \\t\\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        \\treturn clostSum;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int threeSumClosest(vector<int> &num, int target)\\n        {\\n    \\t\\tint clostAbs=INT_MAX;\\n    \\t\\tint clostSum=num[0]+num[1]+num[2];\\n    \\t\\tint low;\\n        \\tint high;\\n        \\tint sum=0;\\n        \\tsort(num.begin(),num.end());\\n        \\tfor(int i=0;i<num.size()-2;i++)\\n        \\t{\\n        \\t\\tlow=i+1;\\n        \\t\\thigh=num.size()-1;\\n        \\t\\twhile(low<high)\\n        \\t\\t{\\n        \\t\\t\\tsum=num[low]+num[high];\\n    \\t\\t\\t\\tif(abs(sum+num[i]-target)<clostAbs)\\n    \\t\\t\\t\\t{\\n    \\t\\t\\t\\t\\tclostAbs=abs(sum+num[i]-target);\\n    \\t\\t\\t\\t\\tclostSum=sum+num[i];\\n    \\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3823730,
                "title": "java-python-c-js-solution-simple-and-explained-commented-multiple-language",
                "content": "# Intuition\\nOur aim is to find the three integers whose sum is closest to the given target value. To achieve this, the array is first sorted in ascending order, and then two pointers (j and k) are used to scan the array from the start and end while maintaining a variable closestSum to track the closest sum found so far.\\n\\n# Approach\\n1. Sort the input array nums in ascending order using Arrays.sort(nums).\\n2. Initialize the variable closestSum to store the closest sum of three integers found so far. Set it to the sum of the first three elements of the sorted array (nums[0] + nums[1] + nums[2]).\\n3. Iterate through the array using a loop with an index variable \\'i\\'. The loop runs from index 0 to \\'nums.length - 2\\' to ensure enough elements are available for forming triplets.\\n4. For each \\'i\\' index, initialize two pointers \\'j\\' and \\'k\\'. \\'j\\' starts from \\'i+1\\', and \\'k\\' starts from \\'nums.length - 1\\'.\\n5. Use a while loop with conditions \\'j < k\\' to explore all possible combinations of triplets.\\n6. Calculate the sum of elements at indices \\'i\\', \\'j\\', and \\'k\\'.\\n7. Check if the current sum is closer to the target than the previous closest sum using the helper function compare.\\n8. If the current sum is closer to the target, update the closestSum to the current sum.\\n9. If the sum is less than the target, increment \\'j\\' to move towards higher values and potentially get closer to the target sum.\\n10. If the sum is greater than the target, decrement \\'k\\' to move towards lower values and potentially get closer to the target sum.\\n11. Continue this process until \\'j\\' becomes greater than or equal to \\'k\\'.\\n12. The process is repeated for all \\'i\\' indices to find the three integers whose sum is closest to the target.\\n13. Return the closestSum, which represents the sum of the three integers that have the closest sum to the given target value.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\nwhere n is number of elements in array\\n\\n- Space complexity:\\nO(1)\\n\\n# Request\\n![LeetCode Upvote Request.webp](https://assets.leetcode.com/users/images/2798aaa4-6440-43bb-9d13-a925e5491c2f_1690459953.7107084.webp)\\n\\n\\n# Code\\n- JAVA\\n```\\nclass Solution \\n{\\n    public int threeSumClosest(int[] nums, int target) \\n    {\\n        // Sort the input array in ascending order to use two pointers.\\n        Arrays.sort(nums);\\n        \\n        // Initialize a variable to store the closest sum of three integers found so far.\\n        int closestSum = nums[0] + nums[1] + nums[2];\\n\\n        // Iterate through the array to find the closest sum to the target.\\n        for (int i = 0; i < nums.length - 2; i++) \\n        {\\n            // Initialize two pointers \\'j\\' and \\'k\\'.\\n            int j = i + 1;\\n            int k = nums.length - 1;\\n\\n            // Use a while loop with two pointers to explore all possible combinations of triplets.\\n            while (j < k) \\n            {\\n                // Calculate the sum of elements at indices \\'i\\', \\'j\\', and \\'k\\'.\\n                int sum = nums[i] + nums[j] + nums[k];\\n\\n                // Update the closest sum if the current sum is closer to the target.\\n                if (compare(target, sum, closestSum))\\n                    closestSum = sum; \\n\\n                // Adjust pointers based on the current sum compared to the target.\\n                if (sum < target)\\n                    j++; // Increment \\'j\\' to potentially get closer to the target sum.\\n                else\\n                    k--; // Decrement \\'k\\' to potentially get closer to the target sum.\\n            }\\n        }\\n\\n        // Return the closest sum of three integers to the target.\\n        return closestSum;\\n    }\\n\\n    // Helper function to compare the distance of two sums to the target and return true if the current sum is closer.\\n    private boolean compare(int target, int sum, int closestSum)\\n    {\\n        return Math.abs(target - sum) < Math.abs(target - closestSum);\\n    }\\n}\\n```\\n\\n- Python\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums, target):\\n        # Sort the input list in ascending order to use two pointers.\\n        nums.sort()\\n\\n        # Initialize a variable to store the closest sum of three integers found so far.\\n        closest_sum = nums[0] + nums[1] + nums[2]\\n\\n        # Iterate through the list to find the closest sum to the target.\\n        for i in range(len(nums) - 2):\\n            # Initialize two pointers \\'j\\' and \\'k\\'.\\n            j = i + 1\\n            k = len(nums) - 1\\n\\n            # Use a while loop with two pointers to explore all possible combinations of triplets.\\n            while j < k:\\n                # Calculate the sum of elements at indices \\'i\\', \\'j\\', and \\'k\\'.\\n                _sum = nums[i] + nums[j] + nums[k]\\n\\n                # Update the closest sum if the current sum is closer to the target.\\n                if self.compare(target, _sum, closest_sum):\\n                    closest_sum = _sum\\n\\n                # Adjust pointers based on the current sum compared to the target.\\n                if _sum < target:\\n                    j += 1  # Increment \\'j\\' to potentially get closer to the target sum.\\n                else:\\n                    k -= 1  # Decrement \\'k\\' to potentially get closer to the target sum.\\n\\n        # Return the closest sum of three integers to the target.\\n        return closest_sum\\n\\n    # Helper function to compare the distance of two sums to the target and return True if the current sum is closer.\\n    def compare(self, target, _sum, closest_sum):\\n        return abs(target - _sum) < abs(target - closest_sum)\\n\\n```\\n\\n- C++\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(std::vector<int>& nums, int target) {\\n        // Sort the input vector in ascending order to use two pointers.\\n        std::sort(nums.begin(), nums.end());\\n        \\n        // Initialize a variable to store the closest sum of three integers found so far.\\n        int closestSum = nums[0] + nums[1] + nums[2];\\n\\n        // Iterate through the vector to find the closest sum to the target.\\n        for (int i = 0; i < nums.size() - 2; i++) {\\n            // Initialize two pointers \\'j\\' and \\'k\\'.\\n            int j = i + 1;\\n            int k = nums.size() - 1;\\n\\n            // Use a while loop with two pointers to explore all possible combinations of triplets.\\n            while (j < k) {\\n                // Calculate the sum of elements at indices \\'i\\', \\'j\\', and \\'k\\'.\\n                int sum = nums[i] + nums[j] + nums[k];\\n\\n                // Update the closest sum if the current sum is closer to the target.\\n                if (compare(target, sum, closestSum))\\n                    closestSum = sum; \\n\\n                // Adjust pointers based on the current sum compared to the target.\\n                if (sum < target)\\n                    j++; // Increment \\'j\\' to potentially get closer to the target sum.\\n                else\\n                    k--; // Decrement \\'k\\' to potentially get closer to the target sum.\\n            }\\n        }\\n\\n        // Return the closest sum of three integers to the target.\\n        return closestSum;\\n    }\\n\\nprivate:\\n    // Helper function to compare the distance of two sums to the target and return true if the current sum is closer.\\n    bool compare(int target, int sum, int closestSum) {\\n        return abs(target - sum) < abs(target - closestSum);\\n    }\\n};\\n\\n```\\n\\n- JavaScript\\n```\\nclass Solution {\\n    threeSumClosest(nums, target) {\\n        // Sort the input array in ascending order to use two pointers.\\n        nums.sort((a, b) => a - b);\\n\\n        // Initialize a variable to store the closest sum of three integers found so far.\\n        let closestSum = nums[0] + nums[1] + nums[2];\\n\\n        // Iterate through the array to find the closest sum to the target.\\n        for (let i = 0; i < nums.length - 2; i++) {\\n            // Initialize two pointers \\'j\\' and \\'k\\'.\\n            let j = i + 1;\\n            let k = nums.length - 1;\\n\\n            // Use a while loop with two pointers to explore all possible combinations of triplets.\\n            while (j < k) {\\n                // Calculate the sum of elements at indices \\'i\\', \\'j\\', and \\'k\\'.\\n                const sum = nums[i] + nums[j] + nums[k];\\n\\n                // Update the closest sum if the current sum is closer to the target.\\n                if (this.compare(target, sum, closestSum))\\n                    closestSum = sum;\\n\\n                // Adjust pointers based on the current sum compared to the target.\\n                if (sum < target)\\n                    j++; // Increment \\'j\\' to potentially get closer to the target sum.\\n                else\\n                    k--; // Decrement \\'k\\' to potentially get closer to the target sum.\\n            }\\n        }\\n\\n        // Return the closest sum of three integers to the target.\\n        return closestSum;\\n    }\\n\\n    // Helper function to compare the distance of two sums to the target and return true if the current sum is closer.\\n    compare(target, sum, closestSum) {\\n        return Math.abs(target - sum) < Math.abs(target - closestSum);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int threeSumClosest(int[] nums, int target) \\n    {\\n        // Sort the input array in ascending order to use two pointers.\\n        Arrays.sort(nums);\\n        \\n        // Initialize a variable to store the closest sum of three integers found so far.\\n        int closestSum = nums[0] + nums[1] + nums[2];\\n\\n        // Iterate through the array to find the closest sum to the target.\\n        for (int i = 0; i < nums.length - 2; i++) \\n        {\\n            // Initialize two pointers \\'j\\' and \\'k\\'.\\n            int j = i + 1;\\n            int k = nums.length - 1;\\n\\n            // Use a while loop with two pointers to explore all possible combinations of triplets.\\n            while (j < k) \\n            {\\n                // Calculate the sum of elements at indices \\'i\\', \\'j\\', and \\'k\\'.\\n                int sum = nums[i] + nums[j] + nums[k];\\n\\n                // Update the closest sum if the current sum is closer to the target.\\n                if (compare(target, sum, closestSum))\\n                    closestSum = sum; \\n\\n                // Adjust pointers based on the current sum compared to the target.\\n                if (sum < target)\\n                    j++; // Increment \\'j\\' to potentially get closer to the target sum.\\n                else\\n                    k--; // Decrement \\'k\\' to potentially get closer to the target sum.\\n            }\\n        }\\n\\n        // Return the closest sum of three integers to the target.\\n        return closestSum;\\n    }\\n\\n    // Helper function to compare the distance of two sums to the target and return true if the current sum is closer.\\n    private boolean compare(int target, int sum, int closestSum)\\n    {\\n        return Math.abs(target - sum) < Math.abs(target - closestSum);\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def threeSumClosest(self, nums, target):\\n        # Sort the input list in ascending order to use two pointers.\\n        nums.sort()\\n\\n        # Initialize a variable to store the closest sum of three integers found so far.\\n        closest_sum = nums[0] + nums[1] + nums[2]\\n\\n        # Iterate through the list to find the closest sum to the target.\\n        for i in range(len(nums) - 2):\\n            # Initialize two pointers \\'j\\' and \\'k\\'.\\n            j = i + 1\\n            k = len(nums) - 1\\n\\n            # Use a while loop with two pointers to explore all possible combinations of triplets.\\n            while j < k:\\n                # Calculate the sum of elements at indices \\'i\\', \\'j\\', and \\'k\\'.\\n                _sum = nums[i] + nums[j] + nums[k]\\n\\n                # Update the closest sum if the current sum is closer to the target.\\n                if self.compare(target, _sum, closest_sum):\\n                    closest_sum = _sum\\n\\n                # Adjust pointers based on the current sum compared to the target.\\n                if _sum < target:\\n                    j += 1  # Increment \\'j\\' to potentially get closer to the target sum.\\n                else:\\n                    k -= 1  # Decrement \\'k\\' to potentially get closer to the target sum.\\n\\n        # Return the closest sum of three integers to the target.\\n        return closest_sum\\n\\n    # Helper function to compare the distance of two sums to the target and return True if the current sum is closer.\\n    def compare(self, target, _sum, closest_sum):\\n        return abs(target - _sum) < abs(target - closest_sum)\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(std::vector<int>& nums, int target) {\\n        // Sort the input vector in ascending order to use two pointers.\\n        std::sort(nums.begin(), nums.end());\\n        \\n        // Initialize a variable to store the closest sum of three integers found so far.\\n        int closestSum = nums[0] + nums[1] + nums[2];\\n\\n        // Iterate through the vector to find the closest sum to the target.\\n        for (int i = 0; i < nums.size() - 2; i++) {\\n            // Initialize two pointers \\'j\\' and \\'k\\'.\\n            int j = i + 1;\\n            int k = nums.size() - 1;\\n\\n            // Use a while loop with two pointers to explore all possible combinations of triplets.\\n            while (j < k) {\\n                // Calculate the sum of elements at indices \\'i\\', \\'j\\', and \\'k\\'.\\n                int sum = nums[i] + nums[j] + nums[k];\\n\\n                // Update the closest sum if the current sum is closer to the target.\\n                if (compare(target, sum, closestSum))\\n                    closestSum = sum; \\n\\n                // Adjust pointers based on the current sum compared to the target.\\n                if (sum < target)\\n                    j++; // Increment \\'j\\' to potentially get closer to the target sum.\\n                else\\n                    k--; // Decrement \\'k\\' to potentially get closer to the target sum.\\n            }\\n        }\\n\\n        // Return the closest sum of three integers to the target.\\n        return closestSum;\\n    }\\n\\nprivate:\\n    // Helper function to compare the distance of two sums to the target and return true if the current sum is closer.\\n    bool compare(int target, int sum, int closestSum) {\\n        return abs(target - sum) < abs(target - closestSum);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\n    threeSumClosest(nums, target) {\\n        // Sort the input array in ascending order to use two pointers.\\n        nums.sort((a, b) => a - b);\\n\\n        // Initialize a variable to store the closest sum of three integers found so far.\\n        let closestSum = nums[0] + nums[1] + nums[2];\\n\\n        // Iterate through the array to find the closest sum to the target.\\n        for (let i = 0; i < nums.length - 2; i++) {\\n            // Initialize two pointers \\'j\\' and \\'k\\'.\\n            let j = i + 1;\\n            let k = nums.length - 1;\\n\\n            // Use a while loop with two pointers to explore all possible combinations of triplets.\\n            while (j < k) {\\n                // Calculate the sum of elements at indices \\'i\\', \\'j\\', and \\'k\\'.\\n                const sum = nums[i] + nums[j] + nums[k];\\n\\n                // Update the closest sum if the current sum is closer to the target.\\n                if (this.compare(target, sum, closestSum))\\n                    closestSum = sum;\\n\\n                // Adjust pointers based on the current sum compared to the target.\\n                if (sum < target)\\n                    j++; // Increment \\'j\\' to potentially get closer to the target sum.\\n                else\\n                    k--; // Decrement \\'k\\' to potentially get closer to the target sum.\\n            }\\n        }\\n\\n        // Return the closest sum of three integers to the target.\\n        return closestSum;\\n    }\\n\\n    // Helper function to compare the distance of two sums to the target and return true if the current sum is closer.\\n    compare(target, sum, closestSum) {\\n        return Math.abs(target - sum) < Math.abs(target - closestSum);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3748757,
                "title": "easy-solution-using-sorting-and-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int prev=nums[0]+nums[1]+nums[2];\\n        for(int i=0;i<nums.size()-1;i++){\\n            int j=i+1;\\n            int k=nums.size()-1;\\n            while(j<k){\\n                int sum=nums[i]+nums[j]+nums[k];\\n                if(abs(sum-target)<abs(prev-target))\\n                prev=sum;\\n                \\n                if(sum<target)\\n                j++;\\n                else\\n                k--;\\n            }\\n        }\\n        return prev;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int prev=nums[0]+nums[1]+nums[2];\\n        for(int i=0;i<nums.size()-1;i++){\\n            int j=i+1;\\n            int k=nums.size()-1;\\n            while(j<k){\\n                int sum=nums[i]+nums[j]+nums[k];\\n                if(abs(sum-target)<abs(prev-target))\\n                prev=sum;\\n                \\n                if(sum<target)\\n                j++;\\n                else\\n                k--;\\n            }\\n        }\\n        return prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682363,
                "title": "c-easy-solutions-simple-explanation-two-pointer-approach",
                "content": "# Intuition\\n- Sorting the array is crucial for applying the two-pointer technique. It allows us to efficiently move the pointers towards each other, converging on the closest sum to the target.\\n- By iterating over each element as the first element of the triplet, we ensure that we explore all possible combinations and find the closest sum.\\n- The two-pointer technique helps us explore different combinations of elements without having to consider every possible triplet, significantly reducing the time complexity.\\n- By updating the minimum difference (diff) and the closest sum (ans) whenever a closer sum is found, we ensure that we have the correct answer when the algorithm finishes.\\n- Overall, the intuition behind this approach is to use the sorted nature of the array and the two-pointer technique to efficiently explore different combinations of elements and find the closest sum to the target.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Sort the array in ascending order.\\n- Initialize variables for the minimum difference (diff) and the closest triplet sum (ans).\\n- Iterate over each element in the array.\\n- Use two pointers (left and right) to find the closest triplet sum to the target.\\n- Calculate the current triplet sum.\\n- Update diff and ans if the current sum is closer to the target.\\n- Adjust the pointers based on the value of the current sum.\\n- Repeat steps 5-7 until the pointers meet.\\n- Return the closest triplet sum (ans).\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: The time complexity is O(n^2) due to the nested loops, where n is the size of the input array.\\n{ Sorting the array using sort(nums.begin(), nums.end()) takes O(n log n) time, where n is the size of the input array nums.\\nThe main part of the code consists of nested loops. The outer loop iterates n times, and the inner while loop, in the worst case, iterates n/2 times (when j and k start from the opposite ends of the array).\\nThus, the overall time complexity is O(n log n + n^2), which simplifies to O(n^2) since n^2 dominates n log n. }\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: The space complexity is O(1) because the code uses a constant amount of additional space to store variables (diff, ans, n, i, j, k, and sum). The space required does not depend on the size of the input array.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        \\n        // Step 1: Sort the array in ascending order\\n        sort(nums.begin(), nums.end());\\n        \\n        int diff = INT_MAX; // Initialize the minimum difference to a large value\\n        int ans; // Variable to store the closest triplet sum\\n        \\n        // Step 4: Iterate over each element in the array\\n        for(int i=0; i<n; i++){\\n            int j = i+1; // Initialize the left pointer\\n            int k = n-1; // Initialize the right pointer\\n            \\n            // Step 6: Find the closest triplet sum using two pointers\\n            while(j < k){\\n                int sum = nums[i] + nums[j] + nums[k]; // Calculate the current triplet sum\\n                \\n                // Step 8: Update the minimum difference and the closest sum if the current sum is closer to the target\\n                if(abs(sum - target) < diff){\\n                    diff = abs(sum - target);\\n                    ans = sum;\\n                }\\n                // If equal to sum, end function\\n                if(sum == target) return sum;\\n\\n                // Step 9: Adjust the pointers based on the value of the current sum\\n                if(sum < target) {\\n                    j++; // Increment the left pointer to consider a larger element\\n                } else {\\n                    k--; // Decrement the right pointer to consider a smaller element\\n                }\\n            }\\n        }\\n        \\n        // Step 11: Return the closest triplet sum\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        \\n        // Step 1: Sort the array in ascending order\\n        sort(nums.begin(), nums.end());\\n        \\n        int diff = INT_MAX; // Initialize the minimum difference to a large value\\n        int ans; // Variable to store the closest triplet sum\\n        \\n        // Step 4: Iterate over each element in the array\\n        for(int i=0; i<n; i++){\\n            int j = i+1; // Initialize the left pointer\\n            int k = n-1; // Initialize the right pointer\\n            \\n            // Step 6: Find the closest triplet sum using two pointers\\n            while(j < k){\\n                int sum = nums[i] + nums[j] + nums[k]; // Calculate the current triplet sum\\n                \\n                // Step 8: Update the minimum difference and the closest sum if the current sum is closer to the target\\n                if(abs(sum - target) < diff){\\n                    diff = abs(sum - target);\\n                    ans = sum;\\n                }\\n                // If equal to sum, end function\\n                if(sum == target) return sum;\\n\\n                // Step 9: Adjust the pointers based on the value of the current sum\\n                if(sum < target) {\\n                    j++; // Increment the left pointer to consider a larger element\\n                } else {\\n                    k--; // Decrement the right pointer to consider a smaller element\\n                }\\n            }\\n        }\\n        \\n        // Step 11: Return the closest triplet sum\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633271,
                "title": "easy-to-understand-c-solution-two-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        int diff = INT_MAX, ans;\\n        for(int i=0; i<n; i++){\\n            int j = i+1;\\n            int k = n-1;\\n            while(j < k){\\n                int sum = nums[i] + nums[j] + nums[k];\\n                if(abs(sum - target) < diff){\\n                    diff = abs(sum - target);\\n                    ans = sum;\\n                }\\n                if(sum <= target) j++;\\n                else k--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        int diff = INT_MAX, ans;\\n        for(int i=0; i<n; i++){\\n            int j = i+1;\\n            int k = n-1;\\n            while(j < k){\\n                int sum = nums[i] + nums[j] + nums[k];\\n                if(abs(sum - target) < diff){\\n                    diff = abs(sum - target);\\n                    ans = sum;\\n                }\\n                if(sum <= target) j++;\\n                else k--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567201,
                "title": "bruteforce-o-n-3-to-optimized-o-nlog-n-n-2-code",
                "content": "# 1. Brute Force Code\\n### Approach\\nBrute Force Approach - Checking for all the possible triplets and then finding the closestSum be analysing the closeness of the currentSum by target. \\n\\n### Complexity\\n- Time complexity: O(n^3)\\n\\n- Space complexity: O(1)\\n\\n```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        int closest = Integer.MAX_VALUE, closestSum = Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length-2;i++){\\n            for(int j=i+1;j<nums.length-1;j++){\\n                for(int k=j+1;k<nums.length;k++){\\n                    int sum = nums[i] + nums[j] + nums[k];\\n                    int close = Math.abs(sum-target);\\n                    if(close < closest){\\n                        closest = close;\\n                        closestSum = sum;\\n                    }\\n                }\\n            }\\n        }\\n        return closestSum;\\n    }\\n}\\n\\n// Brute Force Code \\n// Time Complexity : O(N^3)\\n// Space Complexity : O(1)\\n```\\n\\n# 2. Optimized 2 Pointers Code\\n### Approach\\n- Sort the array and have 3 pointers: at start, at end of the array and one moving from start + 1 to end - 1\\n- If sum of numbers at these 3 pointers equals target, then exit with target\\n- Else if sum < target, it means you need to add more to the sum, so move middle pointer forward\\n- Else move the end pointer backwards because the sum is too high\\n- Keep a running minimum difference to find the closest the sum gets to target \\n\\n### Complexity\\n- Time complexity: O(nlog(n) + n^2)\\n\\n- Space complexity: O(1)\\n\\n```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        int closest = Integer.MAX_VALUE, closestSum = Integer.MAX_VALUE,i=-1,j=-1,k=-1;\\n        Arrays.sort(nums);                               // nlog(n)\\n        for(i=0;i<nums.length-2;i++){                    // O(n)\\n            j = i+1;\\n            k = nums.length-1;\\n            while(j < k){                                // O(n)\\n                int sum = nums[i] + nums[j] + nums[k];\\n                if(sum==target){return target;}\\n                else if(sum<target) {j++;}\\n                else {k--;}\\n                // Updating closestSum according to closest\\n                int close = Math.abs(sum - target);\\n                if(close<closest){\\n                    closest = close;\\n                    closestSum = sum;\\n                }               \\n            }\\n        }\\n        return closestSum;\\n    }\\n}\\n\\n// Optimized 2 Pointer Code \\n// Time Complexity : O(nlog(n) + n^2)\\n// Space Complexity : O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        int closest = Integer.MAX_VALUE, closestSum = Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length-2;i++){\\n            for(int j=i+1;j<nums.length-1;j++){\\n                for(int k=j+1;k<nums.length;k++){\\n                    int sum = nums[i] + nums[j] + nums[k];\\n                    int close = Math.abs(sum-target);\\n                    if(close < closest){\\n                        closest = close;\\n                        closestSum = sum;\\n                    }\\n                }\\n            }\\n        }\\n        return closestSum;\\n    }\\n}\\n\\n// Brute Force Code \\n// Time Complexity : O(N^3)\\n// Space Complexity : O(1)\\n```\n```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        int closest = Integer.MAX_VALUE, closestSum = Integer.MAX_VALUE,i=-1,j=-1,k=-1;\\n        Arrays.sort(nums);                               // nlog(n)\\n        for(i=0;i<nums.length-2;i++){                    // O(n)\\n            j = i+1;\\n            k = nums.length-1;\\n            while(j < k){                                // O(n)\\n                int sum = nums[i] + nums[j] + nums[k];\\n                if(sum==target){return target;}\\n                else if(sum<target) {j++;}\\n                else {k--;}\\n                // Updating closestSum according to closest\\n                int close = Math.abs(sum - target);\\n                if(close<closest){\\n                    closest = close;\\n                    closestSum = sum;\\n                }               \\n            }\\n        }\\n        return closestSum;\\n    }\\n}\\n\\n// Optimized 2 Pointer Code \\n// Time Complexity : O(nlog(n) + n^2)\\n// Space Complexity : O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282146,
                "title": "java-runtime-17ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\n    public int threeSumClosest(int[] nums, int target) \\n    {\\n        Arrays.sort(nums);\\n        int sum=0;\\n        int temp=0;\\n        int temp1 = Integer.MAX_VALUE;\\n        int res=Integer.MAX_VALUE;\\n        int out=0;\\n        for (int i = 0; i < nums.length-1; i++)\\n        {\\n           int j=i+1;\\n           int k= nums.length-1;\\n           while(j<k)\\n           {\\n                sum = nums[i] + nums[j] + nums[k];\\n               temp = Math.abs((sum - target));\\n               if (temp < res)\\n               {\\n                   res = temp;\\n                   out = sum; \\n               }\\n               if (temp1<temp)\\n               {\\n                   j++;\\n                   k= nums.length-1;\\n                   temp1=Integer.MAX_VALUE;\\n               }\\n               else\\n               {\\n                   k--;\\n                   temp1 = temp;\\n               }\\n           }\\n           if (out==target) break;  \\n        }\\n        return out;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Sort"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int threeSumClosest(int[] nums, int target) \\n    {\\n        Arrays.sort(nums);\\n        int sum=0;\\n        int temp=0;\\n        int temp1 = Integer.MAX_VALUE;\\n        int res=Integer.MAX_VALUE;\\n        int out=0;\\n        for (int i = 0; i < nums.length-1; i++)\\n        {\\n           int j=i+1;\\n           int k= nums.length-1;\\n           while(j<k)\\n           {\\n                sum = nums[i] + nums[j] + nums[k];\\n               temp = Math.abs((sum - target));\\n               if (temp < res)\\n               {\\n                   res = temp;\\n                   out = sum; \\n               }\\n               if (temp1<temp)\\n               {\\n                   j++;\\n                   k= nums.length-1;\\n                   temp1=Integer.MAX_VALUE;\\n               }\\n               else\\n               {\\n                   k--;\\n                   temp1 = temp;\\n               }\\n           }\\n           if (out==target) break;  \\n        }\\n        return out;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3275736,
                "title": "easy-intuitive-approach",
                "content": "# Code\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        ans,cdiff,pdiff=0,0,100000\\n        for n,i in enumerate(nums):\\n            j,k=n+1,len(nums)-1\\n            if(n>0 and i==nums[n-1]): continue\\n            while(j<k):\\n                    summ=i+nums[j]+nums[k]\\n                    cdiff=abs(summ-target)\\n                    if pdiff>cdiff:\\n                        ans=summ\\n                        pdiff=cdiff\\n                    if(summ==target): return target\\n                    elif(summ<target):  \\n                        j+=1\\n                    else:\\n                        k-=1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        ans,cdiff,pdiff=0,0,100000\\n        for n,i in enumerate(nums):\\n            j,k=n+1,len(nums)-1\\n            if(n>0 and i==nums[n-1]): continue\\n            while(j<k):\\n                    summ=i+nums[j]+nums[k]\\n                    cdiff=abs(summ-target)\\n                    if pdiff>cdiff:\\n                        ans=summ\\n                        pdiff=cdiff\\n                    if(summ==target): return target\\n                    elif(summ<target):  \\n                        j+=1\\n                    else:\\n                        k-=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3237073,
                "title": "javascript-best-way-explanation-easy-to-solve",
                "content": "\\n# Approach\\n i Use a two-pointer approach to find the three integers in nums that add up to the closest sum to target. The algorithm first sorts the input array in ascending order. It then initializes the closest sum to the sum of the first three elements in the sorted array.\\n\\nThe algorithm then iterates through each element of the array, treating it as the first element of a possible three-sum combination. For each first element, it uses two pointers, left and right, to search for the two other elements that sum to the closest possible value to target. The pointers start at the first element after the first element and at the last element of the array, respectively. The pointers move towards each other until they meet. For each combination of `nums[i]`, `nums[left`], and `nums[right]`, the algorithm computes the sum and checks if it is closer to target than the current closest sum. If it is, the closest sum is updated. Finally, the algorithm returns the closest sum found.\\n\\ni assume that the input array nums has at least three elements. If the input array has fewer than three elements, the implementation may produce incorrect results. To handle this case, additional logic would be needed to check the length of the input array before attempting to find the closest three-sum.\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar threeSumClosest = function(nums, target) {\\n     nums.sort((a, b) => a - b); // sort the array in ascending order\\n  let closestSum = nums[0] + nums[1] + nums[2]; // initialize closest sum to the sum of the first three elements\\n\\n  for (let i = 0; i < nums.length - 2; i++) {\\n    let left = i + 1;\\n    let right = nums.length - 1;\\n\\n    while (left < right) {\\n      const sum = nums[i] + nums[left] + nums[right];\\n\\n      if (Math.abs(sum - target) < Math.abs(closestSum - target)) {\\n        closestSum = sum;\\n      }\\n\\n      if (sum < target) {\\n        left++;\\n      } else {\\n        right--;\\n      }\\n    }\\n  }\\n\\n  return closestSum\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar threeSumClosest = function(nums, target) {\\n     nums.sort((a, b) => a - b); // sort the array in ascending order\\n  let closestSum = nums[0] + nums[1] + nums[2]; // initialize closest sum to the sum of the first three elements\\n\\n  for (let i = 0; i < nums.length - 2; i++) {\\n    let left = i + 1;\\n    let right = nums.length - 1;\\n\\n    while (left < right) {\\n      const sum = nums[i] + nums[left] + nums[right];\\n\\n      if (Math.abs(sum - target) < Math.abs(closestSum - target)) {\\n        closestSum = sum;\\n      }\\n\\n      if (sum < target) {\\n        left++;\\n      } else {\\n        right--;\\n      }\\n    }\\n  }\\n\\n  return closestSum\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3220908,
                "title": "triple-threat-finding-the-closest-three-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo solve this problem, we can use a similar approach to the three sum problem. We first sort the input array and fix the first element in the triplet. Then, we use two pointers to search for the remaining two elements such that the sum is closest to the target.\\n# Algorithm\\n<!-- Describe your approach to solving the problem. -->\\n- Sort the input array nums.\\n\\n- Initialize a variable diff to store the difference between the target and the sum of the triplet. Initialize a variable res to store the sum of the closest triplet found so far.\\n\\n- Loop over the input array nums from the first element to the second last element.\\n\\n- Initialize two pointers left and right to search for the remaining two elements such that the sum is closest to the target.\\n\\n- While left < right, calculate the sum of the triplet nums[i] + nums[left] + nums[right].\\n\\n- If the absolute difference between the target and the sum is less than the absolute difference between the target and the current value of res, update res to the sum.\\n\\n- If the sum is less than the target, increment the left pointer. Otherwise, decrement the right pointer.\\n- Return the value of res.\\n# Complexity\\n- Time complexity: The time complexity of the above algorithm is $$O(n^2)$$, where n is the length of the input array nums. This is because we have two nested loops to search for the remaining two elements such that the sum is closest to the target.\\n\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: The space complexity of the above algorithm is $$O(1)$$ because we are using constant extra space to store the variables diff and res.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        diff = float(\\'inf\\')\\n        res = 0\\n        for i in range(n - 2):\\n            left = i + 1\\n            right = n - 1\\n            while left < right:\\n                s = nums[i] + nums[left] + nums[right]\\n                if abs(target - s) < diff:\\n                    diff = abs(target - s)\\n                    res = s\\n                if s < target:\\n                    left += 1\\n                else:\\n                    right -= 1\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        diff = float(\\'inf\\')\\n        res = 0\\n        for i in range(n - 2):\\n            left = i + 1\\n            right = n - 1\\n            while left < right:\\n                s = nums[i] + nums[left] + nums[right]\\n                if abs(target - s) < diff:\\n                    diff = abs(target - s)\\n                    res = s\\n                if s < target:\\n                    left += 1\\n                else:\\n                    right -= 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2811774,
                "title": "c-easy-to-understand-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int front;\\n        int sum=nums[0]+nums[1]+nums[2],sum1=0;\\n        for(int i=0;i<nums.size();i++){\\n            front=i+1;\\n            int back=nums.size()-1;\\n            while(front<back){\\n            sum1=nums[front]+nums[back]+nums[i];\\n            if(abs(sum1-target)<=abs(sum-target)){\\n                sum=sum1;\\n            }\\n            if(sum1>target) \\n                back--;\\n            else if(sum1<target) \\n               front++;\\n            else return sum1;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int front;\\n        int sum=nums[0]+nums[1]+nums[2],sum1=0;\\n        for(int i=0;i<nums.size();i++){\\n            front=i+1;\\n            int back=nums.size()-1;\\n            while(front<back){\\n            sum1=nums[front]+nums[back]+nums[i];\\n            if(abs(sum1-target)<=abs(sum-target)){\\n                sum=sum1;\\n            }\\n            if(sum1>target) \\n                back--;\\n            else if(sum1<target) \\n               front++;\\n            else return sum1;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2811445,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        int ans=nums[0]+nums[1]+nums[nums.length-1];\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-2;i++){\\n            int left=i+1;\\n            int right=nums.length-1;\\n             while(left<right){\\n                 int sum=nums[i]+nums[left]+nums[right];\\n                 if(sum>target){\\n                     right--;\\n                 }else{\\n                     left++;\\n                 }\\n                 if(Math.abs(sum-target)<Math.abs(ans-target))\\n                     ans=sum;\\n             }\\n            \\n            }\\n        return ans;\\n        }\\n    }\\n\\t```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        int ans=nums[0]+nums[1]+nums[nums.length-1];\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-2;i++){\\n            int left=i+1;\\n            int right=nums.length-1;\\n             while(left<right){\\n                 int sum=nums[i]+nums[left]+nums[right];\\n                 if(sum>target){\\n                     right--;\\n                 }else{\\n                     left++;\\n                 }\\n                 if(Math.abs(sum-target)<Math.abs(ans-target))\\n                     ans=sum;\\n             }\\n            \\n            }\\n        return ans;\\n        }\\n    }\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2753073,
                "title": "python-solution-two-pointers",
                "content": "class Solution:\\n\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        \\n        min_dif = math.inf\\n        \\n        \\n        for i in range(len(nums)-2):\\n            left = i + 1\\n            right = len(nums)-1\\n            while left < right:\\n                current_diff = target - nums[i] - nums[left]-nums[right]\\n\\n                if current_diff == 0:\\n                    return target\\n\\n                if abs(min_dif) > abs(current_diff) or (abs(min_dif) == abs(current_diff) and current_diff>min_dif):\\n                    min_dif = current_diff\\n\\n\\n                if current_diff >0:\\n                    left += 1\\n                else:\\n                    right -=1\\n                                                    \\n        return target - min_dif\\n",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        \\n        min_dif = math.inf\\n        \\n        \\n        for i in range(len(nums)-2):\\n            left = i + 1\\n            right = len(nums)-1\\n            while left < right:\\n                current_diff = target - nums[i] - nums[left]-nums[right]\\n\\n                if current_diff == 0:\\n                    return target\\n\\n                if abs(min_dif) > abs(current_diff) or (abs(min_dif) == abs(current_diff) and current_diff>min_dif):\\n                    min_dif = current_diff\\n\\n\\n                if current_diff >0:\\n                    left += 1\\n                else:\\n                    right -=1\\n                                                    \\n        return target - min_dif\\n",
                "codeTag": "Java"
            },
            {
                "id": 2677030,
                "title": "brute-force-optimized-faster-than-98",
                "content": "## Brute Force Solution: O(n^3)\\n```\\nvar threeSumClosest = function(nums, target) {\\n\\n    let closestSum = 9999999;\\n    nums.sort((a,b) => a-b);\\n    \\n    for(let i=0;i<nums.length-2;i++){\\n         for(let j=i+1;j<nums.length-1;j++){\\n             for(let k=j+1;k<nums.length;k++){\\n                 if(Math.abs(closestSum) > Math.abs(nums[i] + nums[j] + nums[k] - target)){\\n                     closestSum = nums[i] + nums[j] + nums[k] - target;\\n                 }\\n             }\\n         }\\n     }\\n}\\n```\\n\\n## Optimized Solution. Break problem into two sum. O(n^2)\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\n\\nvar threeSumClosest = function(nums, target) {\\n    let closestSum = 9999999;\\n    nums.sort((a,b) => a-b);\\n\\t\\n    for(let i=0; i<nums.length-2; i++){\\n        let j = i+1;\\n        let k = nums.length - 1;\\n        let closest = 9999999999;\\n        while(j<k){\\n            let x = nums[i];\\n            let y = nums[j];\\n            let z = nums[k];\\n            \\n            let currSum = x+y+z;\\n            if(Math.abs(currSum - target) < Math.abs(closest - target)){\\n                closest = currSum;\\n            }\\n            //means increase the current sum\\n            if(currSum > target){\\n                k--;\\n            } else if(currSum < target){//decrease the sum\\n                j++;\\n            } else {\\n                closest = currSum;\\n                return closest;\\n            }\\n        }\\n        if(Math.abs(closest - target) < Math.abs(closestSum - target)){\\n            closestSum = closest\\n        }\\n    }\\n    \\n    return closestSum;\\n};\\n```\\n\\n**Do give a rep if you find the solution helpful ^_^**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar threeSumClosest = function(nums, target) {\\n\\n    let closestSum = 9999999;\\n    nums.sort((a,b) => a-b);\\n    \\n    for(let i=0;i<nums.length-2;i++){\\n         for(let j=i+1;j<nums.length-1;j++){\\n             for(let k=j+1;k<nums.length;k++){\\n                 if(Math.abs(closestSum) > Math.abs(nums[i] + nums[j] + nums[k] - target)){\\n                     closestSum = nums[i] + nums[j] + nums[k] - target;\\n                 }\\n             }\\n         }\\n     }\\n}\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\n\\nvar threeSumClosest = function(nums, target) {\\n    let closestSum = 9999999;\\n    nums.sort((a,b) => a-b);\\n\\t\\n    for(let i=0; i<nums.length-2; i++){\\n        let j = i+1;\\n        let k = nums.length - 1;\\n        let closest = 9999999999;\\n        while(j<k){\\n            let x = nums[i];\\n            let y = nums[j];\\n            let z = nums[k];\\n            \\n            let currSum = x+y+z;\\n            if(Math.abs(currSum - target) < Math.abs(closest - target)){\\n                closest = currSum;\\n            }\\n            //means increase the current sum\\n            if(currSum > target){\\n                k--;\\n            } else if(currSum < target){//decrease the sum\\n                j++;\\n            } else {\\n                closest = currSum;\\n                return closest;\\n            }\\n        }\\n        if(Math.abs(closest - target) < Math.abs(closestSum - target)){\\n            closestSum = closest\\n        }\\n    }\\n    \\n    return closestSum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2676496,
                "title": "python",
                "content": "**The Logic**:\\nFirst we sort `nums` in O(nLogn).\\nThen, we fix one number by looping through the `nums`. As soon as one number is fixed - we can iterate two other numbers simultaneously. How? Let `hi = len(nums) - 1` and `lo = i + 1` where `i` is fixed (first out of three numbers).\\nWe sum the numbers - `s`. If it is lower than the `target` - what can we do? We can only increase `lo` by one - because `nums` are sorted. By that, we are trying to increase the sum `s`. We keep moving `lo` by one until `s` is lower than the `target`. As soon as we got a number higher than the `target`, we can try to decrease it. Either we decrease `lo` by one - but we already had it before. Or we can decrease `hi` by one. So, the total sum should be decreased, because the array is sorted.\\nThus we have one loop and one nested loop - O(N^2).\\n\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        ans = float(\\'inf\\')\\n        for i in range(len(nums) - 2):\\n            lo, hi = i + 1, len(nums) - 1\\n            \\n            while lo < hi:\\n                s = nums[i] + nums[lo] + nums[hi]\\n                if s == target:\\n                    return s\\n                elif s > target:\\n                    hi -= 1\\n                else:\\n                    lo += 1\\n                if abs(s - target) < abs(ans - target):\\n                    ans = s\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        ans = float(\\'inf\\')\\n        for i in range(len(nums) - 2):\\n            lo, hi = i + 1, len(nums) - 1\\n            \\n            while lo < hi:\\n                s = nums[i] + nums[lo] + nums[hi]\\n                if s == target:\\n                    return s\\n                elif s > target:\\n                    hi -= 1\\n                else:\\n                    lo += 1\\n                if abs(s - target) < abs(ans - target):\\n                    ans = s\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2675865,
                "title": "rust-33-ms-fastest-100-two-pointers-solution-with-detailed-comments",
                "content": "This [**solution**](https://leetcode.com/submissions/detail/817764364/) employs a two-pointers approach with sorting. It demonstrated **33 ms runtime (100.00%)** and used **2.2 MB memory (15.46%)**. Time complexity is quadratic: **O(N\\\\*N)**. Space complexity is constant: **O(1)**. Detailed comments are provided.\\n\\n**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n```\\nimpl Solution \\n{\\n    pub fn three_sum_closest(mut nums: Vec<i32>, target: i32) -> i32 \\n    {\\n        // [1] sorting would allow us to use two pointers\\n        nums.sort_unstable();\\n        let mut best_diff: i32 = i32::MAX;\\n        \\n        // [2] use two pointers \\'l\\' and \\'r\\' that converge towards \\n        //     one another for each first element \\'i\\'\\n        for i in 0..nums.len()\\n        {\\n            let mut l = i + 1;\\n            let mut r = nums.len() - 1;\\n            let pre_diff = nums[i] - target;\\n            while l < r\\n            {\\n                let diff = pre_diff + nums[l] + nums[r];\\n                if diff.abs() < best_diff.abs() { best_diff = diff; }\\n                match diff.signum()\\n                {\\n                    1  => r -= 1,\\n                    -1 => l += 1,\\n                    0  => return target,\\n                    _  => unreachable!()\\n                }\\n            }\\n        }\\n        \\n        return target + best_diff;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Rust",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nimpl Solution \\n{\\n    pub fn three_sum_closest(mut nums: Vec<i32>, target: i32) -> i32 \\n    {\\n        // [1] sorting would allow us to use two pointers\\n        nums.sort_unstable();\\n        let mut best_diff: i32 = i32::MAX;\\n        \\n        // [2] use two pointers \\'l\\' and \\'r\\' that converge towards \\n        //     one another for each first element \\'i\\'\\n        for i in 0..nums.len()\\n        {\\n            let mut l = i + 1;\\n            let mut r = nums.len() - 1;\\n            let pre_diff = nums[i] - target;\\n            while l < r\\n            {\\n                let diff = pre_diff + nums[l] + nums[r];\\n                if diff.abs() < best_diff.abs() { best_diff = diff; }\\n                match diff.signum()\\n                {\\n                    1  => r -= 1,\\n                    -1 => l += 1,\\n                    0  => return target,\\n                    _  => unreachable!()\\n                }\\n            }\\n        }\\n        \\n        return target + best_diff;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2675826,
                "title": "easy-cpp-2-pointer-simple-approach",
                "content": "```\\n   int threeSumClosest(vector<int>& nums, int target) {\\n            sort(nums.begin(),nums.end());\\n        int ans = 0,n=nums.size();\\n        int diff = INT_MAX;\\n            for(int i=0;i<n;i++)\\n            {\\n                    int first = nums[i];\\n                    int s=i+1,e=n-1;\\n                    while(s<e)\\n                    {\\n                            if(first+nums[s]+nums[e]==target)\\n                                    return target;\\n                            else if(abs(first+nums[s]+nums[e]-target)<diff)\\n                            {\\n                                    diff = abs(first+nums[s]+nums[e]-target);\\n                                    ans = first+nums[s]+nums[e];\\n                            }\\n                            if(first+nums[s]+nums[e]>target)\\n                                    e--;\\n                            else\\n                                    s++;\\n                    }\\n            }\\n            return ans;\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n   int threeSumClosest(vector<int>& nums, int target) {\\n            sort(nums.begin(),nums.end());\\n        int ans = 0,n=nums.size();\\n        int diff = INT_MAX;\\n            for(int i=0;i<n;i++)\\n            {\\n                    int first = nums[i];\\n                    int s=i+1,e=n-1;\\n                    while(s<e)\\n                    {\\n                            if(first+nums[s]+nums[e]==target)\\n                                    return target;\\n                            else if(abs(first+nums[s]+nums[e]-target)<diff)\\n                            {\\n                                    diff = abs(first+nums[s]+nums[e]-target);\\n                                    ans = first+nums[s]+nums[e];\\n                            }\\n                            if(first+nums[s]+nums[e]>target)\\n                                    e--;\\n                            else\\n                                    s++;\\n                    }\\n            }\\n            return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2675529,
                "title": "python-two-pointer-solution-with-explanation",
                "content": "sort ```nums``` first, we can check the largest three and smallest three values,\\n\\nif the sum of smallest three values is greater than or equal to ```target```, return it\\nif the sum of largest three values is smaller than or equal to ```target```, return it\\n\\nand fix one value```pivot```, and find the other two value is the closet to the ``` target ``` in the ```[l, r]```.\\n\\nbecause ```nums``` is sorted,\\n\\nif the sum of the smallest two value ```nums[l] + nums[l+1]``` is greater than or equal to ```delta```, which means all the pair in the current and next iteration are greater than ```delta```, no need to check them, just return ```ans```\\n\\nif the sum of the largest two value ```nums[r-1] + nums[r]``` is smaller than or equal to ```delta```, which means all the pair in the current iteration are smaller than ```delta```, no need to check them, just go to the next iteration\\n\\ntc is ```O(N^2)```, sc is ```O(1)```\\n```python\\n# Runtime: 133 ms, faster than 99.96% of Python3 online submissions for 3Sum Closest.\\n# Memory Usage: 14.3 MB, less than 12.36% of Python3 online submissions for 3Sum Closest.\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        max3, min3 = sum(nums[-3:]), sum(nums[:3])\\n        if min3 >= target: return min3\\n        elif max3 <= target: return max3\\n        pivot, leng, ans = 0, len(nums), float(\\'inf\\')\\n        \\n        for pivot in range(leng-2):\\n            delta = target - nums[pivot]\\n            l, r = pivot+1, leng-1\\n            if nums[l] + nums[l+1] == delta:\\n                return nums[l] + nums[l+1] + nums[pivot]\\n            elif nums[r] + nums[r-1] == delta:\\n                 return nums[r] + nums[r-1] + nums[pivot]\\n            elif nums[l] + nums[l+1] > delta:\\n                if abs(target - ans) > abs(delta - nums[l] - nums[l+1]):\\n                    ans = nums[l] + nums[l+1] + nums[pivot]\\n                return ans\\n            elif nums[r] + nums[r-1] < delta:\\n                if abs(target - ans) > abs(delta - nums[r] - nums[r-1]):\\n                    ans = nums[r] + nums[r-1] + nums[pivot]\\n                continue\\n            while l < r:\\n                v = nums[l] + nums[r]\\n                if abs(target - ans) > abs(delta - v):\\n                    ans = v + nums[pivot]\\n                if v > delta:\\n                    r-=1\\n                elif v < delta:\\n                    l+=1\\n                else:\\n                    return ans\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```nums```\n```target```\n```target```\n```pivot```\n``` target ```\n```[l, r]```\n```nums```\n```nums[l] + nums[l+1]```\n```delta```\n```delta```\n```ans```\n```nums[r-1] + nums[r]```\n```delta```\n```delta```\n```O(N^2)```\n```O(1)```\n```python\\n# Runtime: 133 ms, faster than 99.96% of Python3 online submissions for 3Sum Closest.\\n# Memory Usage: 14.3 MB, less than 12.36% of Python3 online submissions for 3Sum Closest.\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        max3, min3 = sum(nums[-3:]), sum(nums[:3])\\n        if min3 >= target: return min3\\n        elif max3 <= target: return max3\\n        pivot, leng, ans = 0, len(nums), float(\\'inf\\')\\n        \\n        for pivot in range(leng-2):\\n            delta = target - nums[pivot]\\n            l, r = pivot+1, leng-1\\n            if nums[l] + nums[l+1] == delta:\\n                return nums[l] + nums[l+1] + nums[pivot]\\n            elif nums[r] + nums[r-1] == delta:\\n                 return nums[r] + nums[r-1] + nums[pivot]\\n            elif nums[l] + nums[l+1] > delta:\\n                if abs(target - ans) > abs(delta - nums[l] - nums[l+1]):\\n                    ans = nums[l] + nums[l+1] + nums[pivot]\\n                return ans\\n            elif nums[r] + nums[r-1] < delta:\\n                if abs(target - ans) > abs(delta - nums[r] - nums[r-1]):\\n                    ans = nums[r] + nums[r-1] + nums[pivot]\\n                continue\\n            while l < r:\\n                v = nums[l] + nums[r]\\n                if abs(target - ans) > abs(delta - v):\\n                    ans = v + nums[pivot]\\n                if v > delta:\\n                    r-=1\\n                elif v < delta:\\n                    l+=1\\n                else:\\n                    return ans\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2675440,
                "title": "python-easy-o-n-2-solution-with-removed-iteration-for-same-set-of-3-values",
                "content": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        n = len(nums)\\n        nums.sort()\\n        result = float(\\'inf\\')\\n        for i in range(n-2):\\n\\t\\t\\t#  improve is to skip the i if i appears in the loop already. The runtime can be reduced to ~3000ms.\\n            if i!=0 and nums[i]==nums[i-1]:\\n                continue\\n            j, k = i+1, n-1\\n            while j<k:\\n                add = nums[i]+nums[j]+nums[k]\\n                if add==target:\\n                    return add\\n                elif abs(add-target)<abs(result-target):\\n                    result = add\\n                if add>target:\\n                    k-=1\\n                else:\\n                    j+=1\\n                \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        n = len(nums)\\n        nums.sort()\\n        result = float(\\'inf\\')\\n        for i in range(n-2):\\n\\t\\t\\t#  improve is to skip the i if i appears in the loop already. The runtime can be reduced to ~3000ms.\\n            if i!=0 and nums[i]==nums[i-1]:\\n                continue\\n            j, k = i+1, n-1\\n            while j<k:\\n                add = nums[i]+nums[j]+nums[k]\\n                if add==target:\\n                    return add\\n                elif abs(add-target)<abs(result-target):\\n                    result = add\\n                if add>target:\\n                    k-=1\\n                else:\\n                    j+=1\\n                \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2675018,
                "title": "cpp-solution-notes-video-explanation-how-to-approach-this-problem",
                "content": "Please visit my channel, and support me by liking, sharing, and subscribing my channel.\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/CclNyWEnp2Y\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\\n# Notes:\\n\\n![image](https://assets.leetcode.com/users/images/d40168a9-8bde-4a33-a0a6-cf43e25fa7b2_1665209465.7496073.png)\\n![image](https://assets.leetcode.com/users/images/6af06b4f-60f2-4326-afb0-114902c92b05_1665209488.0175567.png)\\n** second ++;\\n\\n\\n# Code:\\n\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int first = 0;\\n        int second = 1;\\n        int third = nums.size()-1;\\n        \\n        int sum = nums[0]+nums[1]+nums[2];\\n        \\n        for(; first<nums.size()-2 ; first++){\\n            second = first + 1;\\n            third = nums.size()-1;\\n            \\n            while(second<third){\\n                int curr_sum = nums[first] + nums[second] + nums[third];\\n                \\n                if(abs(target-curr_sum)< abs(target-sum)){\\n                    sum = curr_sum;\\n                }\\n                if(curr_sum > target){\\n                    third--;\\n                }\\n                else if(curr_sum < target){\\n                    second++;\\n                }\\n                else {\\n                    return curr_sum;\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int first = 0;\\n        int second = 1;\\n        int third = nums.size()-1;\\n        \\n        int sum = nums[0]+nums[1]+nums[2];\\n        \\n        for(; first<nums.size()-2 ; first++){\\n            second = first + 1;\\n            third = nums.size()-1;\\n            \\n            while(second<third){\\n                int curr_sum = nums[first] + nums[second] + nums[third];\\n                \\n                if(abs(target-curr_sum)< abs(target-sum)){\\n                    sum = curr_sum;\\n                }\\n                if(curr_sum > target){\\n                    third--;\\n                }\\n                else if(curr_sum < target){\\n                    second++;\\n                }\\n                else {\\n                    return curr_sum;\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674491,
                "title": "c-python-short-concise-solution",
                "content": "**C++**\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& arr, int sum) {\\n        int n = arr.size();\\n        sort(arr.begin(), arr.end());\\n        int diff = INT_MAX;\\n        int ans = 0;\\n\\t    for(int i=0; i<n-2; i++)\\n\\t    {\\n\\t        int j = i+1;\\n\\t        int k = n-1;\\n\\t        while(j<k)\\n\\t        {\\n                int res = arr[i] + arr[j] + arr[k];\\n                if(abs(res - sum) < diff){\\n                   ans = res;\\n                   diff = abs(sum - res);\\n                }\\n\\t            if(res < sum){\\n\\t                j++;\\n\\t            }\\n\\t            else if(res >= sum){\\n\\t                k--;\\n\\t            }\\n\\t        }\\n\\t    }\\n        \\n\\t  return ans;\\n    }\\n};\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def threeSumClosest(self, nums, target):\\n        n = len(nums)\\n        nums.sort()\\n        ans = nums[0] + nums[1] + nums[2]\\n        diff = float(\"inf\")\\n        \\n        for i in range(0, n - 2):\\n            j = i + 1\\n            k = n - 1\\n            while j < k:\\n                sum = nums[i] + nums[j] + nums[k]\\n                if sum == target:\\n                    return sum\\n                \\n                if abs(sum - target) < diff:\\n                    ans = sum\\n                    diff = abs(sum - target)\\n                \\n                if sum > target:\\n                    k -= 1\\n                elif sum < target:\\n                    j += 1\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& arr, int sum) {\\n        int n = arr.size();\\n        sort(arr.begin(), arr.end());\\n        int diff = INT_MAX;\\n        int ans = 0;\\n\\t    for(int i=0; i<n-2; i++)\\n\\t    {\\n\\t        int j = i+1;\\n\\t        int k = n-1;\\n\\t        while(j<k)\\n\\t        {\\n                int res = arr[i] + arr[j] + arr[k];\\n                if(abs(res - sum) < diff){\\n                   ans = res;\\n                   diff = abs(sum - res);\\n                }\\n\\t            if(res < sum){\\n\\t                j++;\\n\\t            }\\n\\t            else if(res >= sum){\\n\\t                k--;\\n\\t            }\\n\\t        }\\n\\t    }\\n        \\n\\t  return ans;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def threeSumClosest(self, nums, target):\\n        n = len(nums)\\n        nums.sort()\\n        ans = nums[0] + nums[1] + nums[2]\\n        diff = float(\"inf\")\\n        \\n        for i in range(0, n - 2):\\n            j = i + 1\\n            k = n - 1\\n            while j < k:\\n                sum = nums[i] + nums[j] + nums[k]\\n                if sum == target:\\n                    return sum\\n                \\n                if abs(sum - target) < diff:\\n                    ans = sum\\n                    diff = abs(sum - target)\\n                \\n                if sum > target:\\n                    k -= 1\\n                elif sum < target:\\n                    j += 1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674469,
                "title": "daily-leetcode-solution-3-sum-closest",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int ans=INT_MAX;\\n        int prevdiff=INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i>0&&nums[i]==nums[i-1])\\n            {\\n                continue;\\n            }\\n            int lo=i+1,hi=n-1;\\n            while(lo<hi)\\n            {\\n                if(abs(nums[hi]+nums[lo]+nums[i]-target)<prevdiff)\\n                {\\n                    ans=nums[hi]+nums[lo]+nums[i];\\n                    prevdiff=abs(nums[hi]+nums[lo]+nums[i]-target);\\n                }\\n                else if(nums[hi]+nums[lo]+nums[i]<target) lo++;\\n                else hi--;\\n            }\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int ans=INT_MAX;\\n        int prevdiff=INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i>0&&nums[i]==nums[i-1])\\n            {\\n                continue;\\n            }\\n            int lo=i+1,hi=n-1;\\n            while(lo<hi)\\n            {\\n                if(abs(nums[hi]+nums[lo]+nums[i]-target)<prevdiff)\\n                {\\n                    ans=nums[hi]+nums[lo]+nums[i];\\n                    prevdiff=abs(nums[hi]+nums[lo]+nums[i]-target);\\n                }\\n                else if(nums[hi]+nums[lo]+nums[i]<target) lo++;\\n                else hi--;\\n            }\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674460,
                "title": "16-python-java-c-javascript-solutions",
                "content": "Python:\\n```\\ndef threeSumClosest(self, nums, target):\\n    nums.sort()\\n    res = sum(nums[:3])\\n    for i in xrange(len(nums)):\\n        l, r = i+1, len(nums)-1\\n        while l < r:\\n            s = sum((nums[i], nums[l], nums[r]))\\n            if abs(s-target) < abs(res-target):\\n                res = s\\n            if s < target:\\n                l += 1\\n            elif s > target:\\n                r -= 1\\n            else: # break early \\n                return res\\n    return res\\n```\\nJava:\\n```\\npublic int threeSumClosest(int[] nums, int target) {\\n\\tArrays.sort(nums);\\n\\tvar closest = 0;\\n\\n\\tfor (int i = 0, n = nums.length, minDiff = Integer.MAX_VALUE; i < n - 2; i++)\\n\\t\\tfor (int j = i + 1, k = n - 1; j < k;) {\\n\\t\\t\\tvar sum = nums[i] + nums[j] + nums[k];\\n\\t\\t\\tif (sum == target)\\n\\t\\t\\t\\treturn target;\\n\\t\\t\\tif (sum < target)\\n\\t\\t\\t\\tj++;\\n\\t\\t\\telse\\n\\t\\t\\t\\tk--;\\n\\n\\t\\t\\tvar diff = Math.abs(target - sum);\\n\\t\\t\\tif (diff < minDiff) {\\n\\t\\t\\t\\tminDiff = diff;\\n\\t\\t\\t\\tclosest = sum;\\n\\t\\t\\t}\\n\\t\\t}\\n\\treturn closest;\\n}\\n```\\nC++:\\n```\\nint threeSumClosest(vector<int>& nums, int target) {\\n    if(nums.size() < 3) return 0;\\n    int closest = nums[0]+nums[1]+nums[2];\\n    sort(nums.begin(), nums.end());\\n    for(int first = 0 ; first < nums.size()-2 ; ++first) {\\n        if(first > 0 && nums[first] == nums[first-1]) continue;\\n        int second = first+1;\\n        int third = nums.size()-1;            \\n        while(second < third) {\\n            int curSum = nums[first]+nums[second]+nums[third];\\n            if(curSum == target) return curSum;\\n            if(abs(target-curSum)<abs(target-closest)) {\\n                closest = curSum;\\n            }\\n            if(curSum > target) {\\n                --third;\\n            } else {\\n                ++second;\\n            }\\n        }\\n    }\\n    return closest;\\n}\\n```\\nJavascript:\\n```\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a,b)=>a-b);\\n    let closest = Infinity;\\n    for (let i=0;i<nums.length-2;i++) {\\n        let left = i+1; right = nums.length-1;\\n        while (left < right) {\\n            let localSum = nums[i] + nums[left] + nums[right];\\n            if (Math.abs(localSum - target) < Math.abs(closest - target)) closest = localSum;\\n            if (localSum > target) right--;\\n            else left++;\\n        }\\n    }\\n    return closest;\\n};\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Two Pointers",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\ndef threeSumClosest(self, nums, target):\\n    nums.sort()\\n    res = sum(nums[:3])\\n    for i in xrange(len(nums)):\\n        l, r = i+1, len(nums)-1\\n        while l < r:\\n            s = sum((nums[i], nums[l], nums[r]))\\n            if abs(s-target) < abs(res-target):\\n                res = s\\n            if s < target:\\n                l += 1\\n            elif s > target:\\n                r -= 1\\n            else: # break early \\n                return res\\n    return res\\n```\n```\\npublic int threeSumClosest(int[] nums, int target) {\\n\\tArrays.sort(nums);\\n\\tvar closest = 0;\\n\\n\\tfor (int i = 0, n = nums.length, minDiff = Integer.MAX_VALUE; i < n - 2; i++)\\n\\t\\tfor (int j = i + 1, k = n - 1; j < k;) {\\n\\t\\t\\tvar sum = nums[i] + nums[j] + nums[k];\\n\\t\\t\\tif (sum == target)\\n\\t\\t\\t\\treturn target;\\n\\t\\t\\tif (sum < target)\\n\\t\\t\\t\\tj++;\\n\\t\\t\\telse\\n\\t\\t\\t\\tk--;\\n\\n\\t\\t\\tvar diff = Math.abs(target - sum);\\n\\t\\t\\tif (diff < minDiff) {\\n\\t\\t\\t\\tminDiff = diff;\\n\\t\\t\\t\\tclosest = sum;\\n\\t\\t\\t}\\n\\t\\t}\\n\\treturn closest;\\n}\\n```\n```\\nint threeSumClosest(vector<int>& nums, int target) {\\n    if(nums.size() < 3) return 0;\\n    int closest = nums[0]+nums[1]+nums[2];\\n    sort(nums.begin(), nums.end());\\n    for(int first = 0 ; first < nums.size()-2 ; ++first) {\\n        if(first > 0 && nums[first] == nums[first-1]) continue;\\n        int second = first+1;\\n        int third = nums.size()-1;            \\n        while(second < third) {\\n            int curSum = nums[first]+nums[second]+nums[third];\\n            if(curSum == target) return curSum;\\n            if(abs(target-curSum)<abs(target-closest)) {\\n                closest = curSum;\\n            }\\n            if(curSum > target) {\\n                --third;\\n            } else {\\n                ++second;\\n            }\\n        }\\n    }\\n    return closest;\\n}\\n```\n```\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a,b)=>a-b);\\n    let closest = Infinity;\\n    for (let i=0;i<nums.length-2;i++) {\\n        let left = i+1; right = nums.length-1;\\n        while (left < right) {\\n            let localSum = nums[i] + nums[left] + nums[right];\\n            if (Math.abs(localSum - target) < Math.abs(closest - target)) closest = localSum;\\n            if (localSum > target) right--;\\n            else left++;\\n        }\\n    }\\n    return closest;\\n};\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2674413,
                "title": "c-two-pointer-beginner-friendly",
                "content": "class Solution {\\npublic:\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        \\n        int n=nums.size();\\n        int Res;\\n        int diff=INT_MAX;\\n        \\n        if(n<3) return {};\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int j=i+1;\\n            int k=n-1;\\n        \\n            while(j<k)\\n            {\\n                 int sum=nums[i]+nums[j]+nums[k];\\n                \\n                if(abs(sum-target) < diff)\\n                {\\n                    diff=abs(sum-target);\\n                    Res=sum;\\n                }\\n                \\n                if(sum > target) k--;\\n                \\n                else j++;\\n            }\\n        }        \\n        \\n       return Res;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        \\n        int n=nums.size();\\n        int Res;\\n        int diff=INT_MAX;\\n        \\n        if(n<3) return {}",
                "codeTag": "Java"
            },
            {
                "id": 2594279,
                "title": "python-2-pointer-binary-search-beats-95",
                "content": "2 pointer solution with binary search in between both pointers:\\n\\n\\tdef threeSumClosest(self, nums: List[int], target: int) -> int:\\n\\n        nums.sort()\\n    \\n        left, right = 0, len(nums) - 1\\n        mid = left + 1\\n        \\n        result = nums[left] + nums[right] + nums[mid]\\n        \\n        while right - left > 1:\\n                        \\n            currSum = self.binSearch(nums, target, left, right)  \\n\\n            if currSum == target: return currSum\\n            \\n            if abs(currSum - target) < abs(result - target): result = currSum     \\n            \\n            if currSum < target: left += 1\\n            else: right -= 1\\n                \\n        return result\\n        \\n        \\n    def binSearch(self, nums, target, left, right):\\n        \\n        originalDistance = nums[left] + nums[right]\\n                \\n        left += 1\\n        right -= 1\\n        mid = (left + right)//2\\n        \\n        result = originalDistance + nums[mid]\\n                \\n        while left < right:\\n            mid = (left + right)//2\\n            \\n            currSum = originalDistance + nums[mid]\\n            \\n            if abs(currSum - target) < abs(result - target): result = currSum\\n                \\n            if currSum == target: return currSum\\n            elif currSum < target: left = mid + 1\\n            else: right = mid - 1\\n                \\n        return result",
                "solutionTags": [
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "2 pointer solution with binary search in between both pointers:\\n\\n\\tdef threeSumClosest(self, nums: List[int], target: int) -> int:\\n\\n        nums.sort()\\n    \\n        left, right = 0, len(nums) - 1\\n        mid = left + 1\\n        \\n        result = nums[left] + nums[right] + nums[mid]\\n        \\n        while right - left > 1:\\n                        \\n            currSum = self.binSearch(nums, target, left, right)  \\n\\n            if currSum == target: return currSum\\n            \\n            if abs(currSum - target) < abs(result - target): result = currSum     \\n            \\n            if currSum < target: left += 1\\n            else: right -= 1\\n                \\n        return result\\n        \\n        \\n    def binSearch(self, nums, target, left, right):\\n        \\n        originalDistance = nums[left] + nums[right]\\n                \\n        left += 1\\n        right -= 1\\n        mid = (left + right)//2\\n        \\n        result = originalDistance + nums[mid]\\n                \\n        while left < right:\\n            mid = (left + right)//2\\n            \\n            currSum = originalDistance + nums[mid]\\n            \\n            if abs(currSum - target) < abs(result - target): result = currSum\\n                \\n            if currSum == target: return currSum\\n            elif currSum < target: left = mid + 1\\n            else: right = mid - 1\\n                \\n        return result",
                "codeTag": "Python3"
            },
            {
                "id": 2540163,
                "title": "java-simple-solution",
                "content": "https://www.youtube.com/watch?v=FJr3UfwtOKQ",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=FJr3UfwtOKQ",
                "codeTag": "Unknown"
            },
            {
                "id": 2437125,
                "title": "easy-to-understand-c-two-pointer-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        //BRUTE FORCE APPROACH...(but a little improved)\\n        //Applying two pointers on the sorted array for target-currnumber\\n        //time complexity O(N^2)\\n        \\n        \\n        int ans; //...Our Final sum(of all three integers) will be stored here\\n        int prevDiff = INT_MAX; //...this will be the closest difference between target and the sum we calculated...this will be changed each time it is compared with a sum that is found to be lower than the previous closest sum\\n        int temp = target;\\n        sort(nums.begin(),nums.end()); //sorting the array inorder to carry out our two pointer approach\\n        for(int i =0;i<nums.size()-2;i++){  //loop till nums.size()-2 because we always play with three pointers two of which we don\\'t want to get out of the array\\n                temp = target-nums[i]; //reducing the target to target-curr value(this curr value is one of the three integers we take into consideration)\\n                int start = i+1;        // starting from one index ahead of curr index\\n                int end = nums.size()-1;\\n                int x;                  // for calculating and comparing with the new target value(temp)...this is similar as two sum problem..\\n            \\n        // so the idea here is to get the sum of two integers as closest as (or equal to ) the new target(temp) which is done by \\n        // keeping two pointers and changing their positions so as to get as close as possible to our new target value.\\n                while(start<end){       \\n                     x = nums[start]+nums[end];\\n                    if(x==temp) break;      //breaking here ... cuz can\\'t get any closer than the TARGET ITSELF!\\n                    if(x<temp) start++;     //incase the sum is lower we shift start to right side so as to increase sum and get closer to our target value(temp)\\n                    else end--; \\n                }\\n            \\n            //now here after this traversal we have obtained a value of sum of three integers as close to temp as possible\\n            //this value is x + nums[i]\\n            //we take the difference of target value (original) with this sum and compare this difference with previous difference(because we need to be as close to target as possible right!)\\n            //if difference is less than prev diff we update our ans and prevDifference gets equal to this difference value..\\n                if(abs(target-(x+nums[i]))<prevDiff){   \\n                    ans = x+nums[i];\\n                    prevDiff = abs(target-(x+nums[i]));\\n                }\\n\\n        }\\n        return ans; //hooray!\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        //BRUTE FORCE APPROACH...(but a little improved)\\n        //Applying two pointers on the sorted array for target-currnumber\\n        //time complexity O(N^2)\\n        \\n        \\n        int ans; //...Our Final sum(of all three integers) will be stored here\\n        int prevDiff = INT_MAX; //...this will be the closest difference between target and the sum we calculated...this will be changed each time it is compared with a sum that is found to be lower than the previous closest sum\\n        int temp = target;\\n        sort(nums.begin(),nums.end()); //sorting the array inorder to carry out our two pointer approach\\n        for(int i =0;i<nums.size()-2;i++){  //loop till nums.size()-2 because we always play with three pointers two of which we don\\'t want to get out of the array\\n                temp = target-nums[i]; //reducing the target to target-curr value(this curr value is one of the three integers we take into consideration)\\n                int start = i+1;        // starting from one index ahead of curr index\\n                int end = nums.size()-1;\\n                int x;                  // for calculating and comparing with the new target value(temp)...this is similar as two sum problem..\\n            \\n        // so the idea here is to get the sum of two integers as closest as (or equal to ) the new target(temp) which is done by \\n        // keeping two pointers and changing their positions so as to get as close as possible to our new target value.\\n                while(start<end){       \\n                     x = nums[start]+nums[end];\\n                    if(x==temp) break;      //breaking here ... cuz can\\'t get any closer than the TARGET ITSELF!\\n                    if(x<temp) start++;     //incase the sum is lower we shift start to right side so as to increase sum and get closer to our target value(temp)\\n                    else end--; \\n                }\\n            \\n            //now here after this traversal we have obtained a value of sum of three integers as close to temp as possible\\n            //this value is x + nums[i]\\n            //we take the difference of target value (original) with this sum and compare this difference with previous difference(because we need to be as close to target as possible right!)\\n            //if difference is less than prev diff we update our ans and prevDifference gets equal to this difference value..\\n                if(abs(target-(x+nums[i]))<prevDiff){   \\n                    ans = x+nums[i];\\n                    prevDiff = abs(target-(x+nums[i]));\\n                }\\n\\n        }\\n        return ans; //hooray!\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2372577,
                "title": "c-two-pointers-approach-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n                \\n        int mini = 1e8;\\n\\t\\t\\n        sort(nums.begin(), nums.end());\\n        \\n        int n = nums.size();\\n        int start, end, tgt;\\n        \\n        for(int i=0;i<n-2;i++){\\n            \\n            start = i+1;\\n            end = n-1;\\n            \\n            while(start<end){\\n                 \\n                int cur_sum = nums[i] + nums[start] + nums[end];\\n                \\n                if(cur_sum==target)\\n                    return cur_sum;\\n                \\n                if(abs(cur_sum-target)<abs(target-mini))\\n                    mini = cur_sum;\\n                \\n                if(cur_sum > target) end--;\\n                else start++;\\n            }\\n            \\n        }\\n        \\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n                \\n        int mini = 1e8;\\n\\t\\t\\n        sort(nums.begin(), nums.end());\\n        \\n        int n = nums.size();\\n        int start, end, tgt;\\n        \\n        for(int i=0;i<n-2;i++){\\n            \\n            start = i+1;\\n            end = n-1;\\n            \\n            while(start<end){\\n                 \\n                int cur_sum = nums[i] + nums[start] + nums[end];\\n                \\n                if(cur_sum==target)\\n                    return cur_sum;\\n                \\n                if(abs(cur_sum-target)<abs(target-mini))\\n                    mini = cur_sum;\\n                \\n                if(cur_sum > target) end--;\\n                else start++;\\n            }\\n            \\n        }\\n        \\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2361234,
                "title": "easy-c-solution-with-explanation-two-pointers-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());    // Sort the given array to find sum easily. It is useful in last two statements of for loop.\\n        int min_diff = INT_MAX;          // To store the difference of target and sum of three integers\\n        int ans = 0;                     // to store sum of three Integers\\n        for(int i =0; i < nums.size(); i++)\\n        {\\n            if((i>0) && nums[i] == nums[i-1]) continue;      // If there are copied values continue;\\n            int l = i+1, h = nums.size()-1;   // Take two pointers\\n            while(l < h)\\n            {\\n                int final_sum = nums[i]+nums[l]+nums[h];      \\n                if(final_sum == target){          \\n                    return target;\\n                }\\n                if(abs(final_sum - target) < min_diff){     //if the difference between new sum value and target is lesser than previous one\\n                    min_diff = abs(final_sum - target);     // Change the main difference value\\n                    ans = final_sum;        // Make ans = sum of three integers\\n                } \\n                if( l < h && final_sum > target) h--;         // If sum is greater than target decrease high pointer as it is making the sum greater than target\\n                else if(l < h && final_sum < target) l++;    // If sum is lesser than target increase low pointer as it is making the sum lesser than target;             \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nPlease upvote if you find it useful.",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());    // Sort the given array to find sum easily. It is useful in last two statements of for loop.\\n        int min_diff = INT_MAX;          // To store the difference of target and sum of three integers\\n        int ans = 0;                     // to store sum of three Integers\\n        for(int i =0; i < nums.size(); i++)\\n        {\\n            if((i>0) && nums[i] == nums[i-1]) continue;      // If there are copied values continue;\\n            int l = i+1, h = nums.size()-1;   // Take two pointers\\n            while(l < h)\\n            {\\n                int final_sum = nums[i]+nums[l]+nums[h];      \\n                if(final_sum == target){          \\n                    return target;\\n                }\\n                if(abs(final_sum - target) < min_diff){     //if the difference between new sum value and target is lesser than previous one\\n                    min_diff = abs(final_sum - target);     // Change the main difference value\\n                    ans = final_sum;        // Make ans = sum of three integers\\n                } \\n                if( l < h && final_sum > target) h--;         // If sum is greater than target decrease high pointer as it is making the sum greater than target\\n                else if(l < h && final_sum < target) l++;    // If sum is lesser than target increase low pointer as it is making the sum lesser than target;             \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2319319,
                "title": "java-runtime-6ms-faster-than-99-65",
                "content": "When we add two mathematical properties, we can shorten the time to reach the target.\\n```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        if (nums.length == 3) {\\n            return nums[0] + nums[1] + nums[2];\\n        }\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int sum = nums[0] + nums[1] + nums[2];\\n        for (int i = 0; i < n - 2; i++) {\\n            //This means the smallest element with two biggest elements can\\'t satisfity the target. There is no need to move the right pointer.\\n            if (nums[i] + nums[n - 1] + nums[n - 2] < target) {\\n                sum = nums[i] + nums[n - 1] + nums[n - 2];\\n                continue;\\n            }\\n            //These three smallest elements in the sums are the closest elements to target. We can\\'t find another possible.\\n            if (nums[i] + nums[i + 1] + nums[i + 2] > target) {\\n                int temp = nums[i] + nums[i + 1] + nums[i + 2];\\n                if(Math.abs(sum - target) < Math.abs(temp - target)){\\n                    return sum;\\n                }else{\\n                    return temp;\\n                }\\n            }\\n            //The ordinary seek with three pointers.\\n            int left = i + 1;\\n            int right = n - 1;\\n            while (left < right) {\\n                int temp = nums[i] + nums[left] + nums[right];\\n                if (temp == target) {\\n                    return target;\\n                }\\n                if (temp < target) {\\n                    left++;\\n                } else {\\n                    right--;\\n                }\\n                \\n                if(Math.abs(sum - target) >= Math.abs(temp - target)){\\n                    sum = temp;\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/4e41cbb9-f0db-441d-bd5d-bb8847d546d1_1658521667.3858693.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        if (nums.length == 3) {\\n            return nums[0] + nums[1] + nums[2];\\n        }\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int sum = nums[0] + nums[1] + nums[2];\\n        for (int i = 0; i < n - 2; i++) {\\n            //This means the smallest element with two biggest elements can\\'t satisfity the target. There is no need to move the right pointer.\\n            if (nums[i] + nums[n - 1] + nums[n - 2] < target) {\\n                sum = nums[i] + nums[n - 1] + nums[n - 2];\\n                continue;\\n            }\\n            //These three smallest elements in the sums are the closest elements to target. We can\\'t find another possible.\\n            if (nums[i] + nums[i + 1] + nums[i + 2] > target) {\\n                int temp = nums[i] + nums[i + 1] + nums[i + 2];\\n                if(Math.abs(sum - target) < Math.abs(temp - target)){\\n                    return sum;\\n                }else{\\n                    return temp;\\n                }\\n            }\\n            //The ordinary seek with three pointers.\\n            int left = i + 1;\\n            int right = n - 1;\\n            while (left < right) {\\n                int temp = nums[i] + nums[left] + nums[right];\\n                if (temp == target) {\\n                    return target;\\n                }\\n                if (temp < target) {\\n                    left++;\\n                } else {\\n                    right--;\\n                }\\n                \\n                if(Math.abs(sum - target) >= Math.abs(temp - target)){\\n                    sum = temp;\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2257327,
                "title": "c-n-2-two-pointer",
                "content": "\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint threeSumClosest(vector<int>& nums, int target) {\\n\\t\\t\\tlong long int sum = INT_MAX;\\n\\t\\t\\tsort(nums.begin(), nums.end());\\n\\t\\t\\tint n = nums.size();\\n\\n\\t\\t\\tfor(int i=0;i<n;i++) {\\n\\t\\t\\t\\tint j = i+1;\\n\\t\\t\\t\\tint k = n-1;\\n\\n\\t\\t\\t\\twhile(j < k) {\\n\\t\\t\\t\\t\\tint curr_sum = nums[i] + nums[j] + nums[k];\\n\\t\\t\\t\\t\\tif(curr_sum == target) return target;\\n\\t\\t\\t\\t\\telse if(curr_sum < target) j++;\\n\\t\\t\\t\\t\\telse k--;\\n\\t\\t\\t\\t\\tsum = abs(curr_sum - target) > abs(sum - target) ? sum : curr_sum;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn sum;\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint threeSumClosest(vector<int>& nums, int target) {\\n\\t\\t\\tlong long int sum = INT_MAX;\\n\\t\\t\\tsort(nums.begin(), nums.end());\\n\\t\\t\\tint n = nums.size();\\n\\n\\t\\t\\tfor(int i=0;i<n;i++) {\\n\\t\\t\\t\\tint j = i+1;\\n\\t\\t\\t\\tint k = n-1;\\n\\n\\t\\t\\t\\twhile(j < k) {\\n\\t\\t\\t\\t\\tint curr_sum = nums[i] + nums[j] + nums[k];\\n\\t\\t\\t\\t\\tif(curr_sum == target) return target;\\n\\t\\t\\t\\t\\telse if(curr_sum < target) j++;\\n\\t\\t\\t\\t\\telse k--;\\n\\t\\t\\t\\t\\tsum = abs(curr_sum - target) > abs(sum - target) ? sum : curr_sum;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2227280,
                "title": "python-solution-for-381-test-cases",
                "content": "I got around 960 ms runtime for this solution with 381 test cases. I tried to handle some edge cases such as if target is less than sum of first 3 digits and if target is greater than sum of last 3 digits.\\nMy solution:\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        length = len(nums)\\n        closest_diff = 10000000\\n        closest_sum = 0\\n        nums.sort()\\n        if (x := sum(nums[:3])) >= target:\\n            return x\\n        if (x := sum(nums[-3:])) <= target:\\n            return x\\n        for left in range(length-2):\\n            if left > 0 and nums[left] == nums[left-1]:\\n                continue\\n            mid = left + 1\\n            right = length - 1\\n            while mid < right:\\n                curr_sum = nums[left] + nums[mid] + nums[right]\\n                diff = abs(target-curr_sum)\\n                if diff < closest_diff:\\n                    closest_diff = diff\\n                    closest_sum = curr_sum\\n                if curr_sum < target:\\n                    mid += 1\\n                elif curr_sum > target:\\n                    right -= 1\\n                else:\\n                    return target\\n        return closest_sum\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        length = len(nums)\\n        closest_diff = 10000000\\n        closest_sum = 0\\n        nums.sort()\\n        if (x := sum(nums[:3])) >= target:\\n            return x\\n        if (x := sum(nums[-3:])) <= target:\\n            return x\\n        for left in range(length-2):\\n            if left > 0 and nums[left] == nums[left-1]:\\n                continue\\n            mid = left + 1\\n            right = length - 1\\n            while mid < right:\\n                curr_sum = nums[left] + nums[mid] + nums[right]\\n                diff = abs(target-curr_sum)\\n                if diff < closest_diff:\\n                    closest_diff = diff\\n                    closest_sum = curr_sum\\n                if curr_sum < target:\\n                    mid += 1\\n                elif curr_sum > target:\\n                    right -= 1\\n                else:\\n                    return target\\n        return closest_sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2183372,
                "title": "go-o-n-2-clean-with-explanation",
                "content": "```\\nfunc threeSumClosest(nums []int, target int) int {\\n    if len(nums) < 3 {return -1}\\n    \\n    sort.Ints(nums)\\n    smallestDiff := 1 << 31\\n    \\n    for i := 0; i < len(nums) - 2; i++ {\\n        left, right := i + 1, len(nums) - 1\\n        \\n        for left < right {\\n            diff := target - nums[i] - nums[left] - nums[right]\\n            if diff == 0 {return target}\\n            \\n            if abs(diff) < abs(smallestDiff) || (abs(diff) == abs(smallestDiff) && diff > smallestDiff) {\\n                smallestDiff = diff\\n            }\\n            \\n            if diff > 0 {\\n                left++\\n            } else {\\n                right--\\n            }\\n        }\\n    }\\n    \\n    return target - smallestDiff\\n}\\n\\nfunc abs(x int) int {\\n    if x > 0 {\\n        return x\\n    }\\n    \\n    return -x\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc threeSumClosest(nums []int, target int) int {\\n    if len(nums) < 3 {return -1}\\n    \\n    sort.Ints(nums)\\n    smallestDiff := 1 << 31\\n    \\n    for i := 0; i < len(nums) - 2; i++ {\\n        left, right := i + 1, len(nums) - 1\\n        \\n        for left < right {\\n            diff := target - nums[i] - nums[left] - nums[right]\\n            if diff == 0 {return target}\\n            \\n            if abs(diff) < abs(smallestDiff) || (abs(diff) == abs(smallestDiff) && diff > smallestDiff) {\\n                smallestDiff = diff\\n            }\\n            \\n            if diff > 0 {\\n                left++\\n            } else {\\n                right--\\n            }\\n        }\\n    }\\n    \\n    return target - smallestDiff\\n}\\n\\nfunc abs(x int) int {\\n    if x > 0 {\\n        return x\\n    }\\n    \\n    return -x\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2138304,
                "title": "simple-c-solution-using-two-pointer",
                "content": "```\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int sum=0;\\n        int ans=nums[0]+nums[1]+nums[2];\\n        for(int i=0;i<n;i++){\\n            int l=i+1,r=n-1;\\n            while(l<r){\\n                sum=nums[i]+nums[l]+nums[r];\\n                if(sum==target){\\n                    ans=target;\\n                    return ans;\\n                }\\n                else if(sum<target){\\n                    if(abs(target-ans)>abs(target-sum)){\\n                        ans=sum;\\n                    }\\n                    l++;\\n                }\\n                else{\\n                    if(abs(target-ans)>abs(target-sum)){\\n                        ans=sum;\\n                    }\\n                    r--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int sum=0;\\n        int ans=nums[0]+nums[1]+nums[2];\\n        for(int i=0;i<n;i++){\\n            int l=i+1,r=n-1;\\n            while(l<r){\\n                sum=nums[i]+nums[l]+nums[r];\\n                if(sum==target){\\n                    ans=target;\\n                    return ans;\\n                }\\n                else if(sum<target){\\n                    if(abs(target-ans)>abs(target-sum)){\\n                        ans=sum;\\n                    }\\n                    l++;\\n                }\\n                else{\\n                    if(abs(target-ans)>abs(target-sum)){\\n                        ans=sum;\\n                    }\\n                    r--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2137805,
                "title": "javascript-solution",
                "content": "\\tvar threeSumClosest = function(nums, tar) {\\n\\t   let closest=Infinity;\\n\\tnums= nums.sort((a,b)=> {return a-b})\\n\\tfor (let i = 0; i < nums.length-2; i++) {\\n\\t\\t\\tlet  a=i+1,b=nums.length-1;\\n\\t\\t\\twhile(a<b){\\n\\t\\t\\t\\t\\t  let target =nums[i]+nums[a]+nums[b];  \\n\\t\\t\\t\\t\\t  if(Math.abs(target - tar) < Math.abs(closest - tar))closest=target;\\n\\t\\t\\t\\t\\t  (target<tar)? a++:b--               \\n\\t\\t\\t} \\n\\t}\\n\\t\\treturn closest; \\n\\t};",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "\\tvar threeSumClosest = function(nums, tar) {\\n\\t   let closest=Infinity;\\n\\tnums= nums.sort((a,b)=> {return a-b})\\n\\tfor (let i = 0; i < nums.length-2; i++) {\\n\\t\\t\\tlet  a=i+1,b=nums.length-1;\\n\\t\\t\\twhile(a<b){\\n\\t\\t\\t\\t\\t  let target =nums[i]+nums[a]+nums[b];  \\n\\t\\t\\t\\t\\t  if(Math.abs(target - tar) < Math.abs(closest - tar))closest=target;\\n\\t\\t\\t\\t\\t  (target<tar)? a++:b--               \\n\\t\\t\\t} \\n\\t}\\n\\t\\treturn closest; \\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 2133259,
                "title": "best-solution-fastest-easy-efficient-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int ans = nums[0] + nums[1] + nums[2];\\n        int closest = abs(target-ans);\\n         for(int i = 0 ; i< nums.size() ; i++){\\n             int start = i+1;\\n             int end = nums.size()-1;\\n             while(start<end){\\n                int sum = nums[start]+ nums[end] + nums[i];\\n                 if(sum == target){\\n                     return sum;\\n                 }\\n                 else if(sum>target ){\\n                     int temp =abs(target-sum);\\n                     if(temp<closest){\\n                         closest = temp;\\n                         ans = sum;\\n                     }\\n                     end--;\\n                 }\\n                 else{\\n                    int temp =abs(target-sum);\\n                     if(temp<closest){\\n                         closest = temp;\\n                         ans = sum;\\n                     }\\n                     start++;\\n                 }\\n             }\\n         }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int ans = nums[0] + nums[1] + nums[2];\\n        int closest = abs(target-ans);\\n         for(int i = 0 ; i< nums.size() ; i++){\\n             int start = i+1;\\n             int end = nums.size()-1;\\n             while(start<end){\\n                int sum = nums[start]+ nums[end] + nums[i];\\n                 if(sum == target){\\n                     return sum;\\n                 }\\n                 else if(sum>target ){\\n                     int temp =abs(target-sum);\\n                     if(temp<closest){\\n                         closest = temp;\\n                         ans = sum;\\n                     }\\n                     end--;\\n                 }\\n                 else{\\n                    int temp =abs(target-sum);\\n                     if(temp<closest){\\n                         closest = temp;\\n                         ans = sum;\\n                     }\\n                     start++;\\n                 }\\n             }\\n         }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1989154,
                "title": "java-two-pointers-solution",
                "content": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        \\n        int closest = nums[0] + nums[1] + nums[2];\\n        \\n        Arrays.sort(nums);\\n        \\n        for(int i=0; i<nums.length; i++) {\\n            \\n            int l = i+1, r = nums.length - 1;\\n            \\n            while(l < r) {\\n                \\n                int threeSum = nums[i] + nums[l] + nums[r];\\n                \\n                if(threeSum > target)\\n                    r--;\\n                \\n                else\\n                    l++;\\n                \\n                if(Math.abs(threeSum - target) < Math.abs(closest - target))\\n                    closest = threeSum;\\n            }\\n        }\\n        \\n        return closest;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        \\n        int closest = nums[0] + nums[1] + nums[2];\\n        \\n        Arrays.sort(nums);\\n        \\n        for(int i=0; i<nums.length; i++) {\\n            \\n            int l = i+1, r = nums.length - 1;\\n            \\n            while(l < r) {\\n                \\n                int threeSum = nums[i] + nums[l] + nums[r];\\n                \\n                if(threeSum > target)\\n                    r--;\\n                \\n                else\\n                    l++;\\n                \\n                if(Math.abs(threeSum - target) < Math.abs(closest - target))\\n                    closest = threeSum;\\n            }\\n        }\\n        \\n        return closest;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1985131,
                "title": "clean-python-solution-self-explained-easy-to-understand",
                "content": "```python\\n\"\"\"\\nTime: O(N^2)\\nSpace: O(1)\\n\"\"\"\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        \\n        N = len(nums)\\n        ans = float(\\'inf\\')\\n        \\n        for i in range(N):\\n            j = i+1\\n            k = N-1\\n            \\n            while j<k:\\n                total = nums[i]+nums[j]+nums[k]\\n                if total==target: return total\\n                if abs(target-ans)>abs(target-total): ans = total\\n\\t\\t\\t\\t\\n                if total>target:\\n                    k -= 1\\n                elif total<target:\\n                    j += 1\\n        return ans\\n\\t\\t\\n\"\"\"\\nFor interview preparation, similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "solutionTags": [],
                "code": "```python\\n\"\"\"\\nTime: O(N^2)\\nSpace: O(1)\\n\"\"\"\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        \\n        N = len(nums)\\n        ans = float(\\'inf\\')\\n        \\n        for i in range(N):\\n            j = i+1\\n            k = N-1\\n            \\n            while j<k:\\n                total = nums[i]+nums[j]+nums[k]\\n                if total==target: return total\\n                if abs(target-ans)>abs(target-total): ans = total\\n\\t\\t\\t\\t\\n                if total>target:\\n                    k -= 1\\n                elif total<target:\\n                    j += 1\\n        return ans\\n\\t\\t\\n\"\"\"\\nFor interview preparation, similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957202,
                "title": "c-easy-to-understand-solution-o-n-2-two-pointer",
                "content": "***Please upvote if you find the solution helpful to keep me motivated. : )***\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());         //sorting the elements\\n        \\n        int l, r, f=0, ans;\\n        for(int i=0;i<nums.size();i++)\\n        {  \\n\\t\\t    //making one element fixed and setting a target for other two elements\\n\\t\\t\\t// a + b + c = target    ->    a + b = target - c = t\\n            int t = target - nums[i];              \\n\\t\\t\\t\\n\\t\\t\\t//considering all elements after the current one because if we\\'ll take all elements then many operations will be repeated\\n            l=i+1; r=nums.size()-1;\\n            int sum = 0;\\n            \\n            while(l<r)\\n            {\\n                sum=nums[l]+nums[r];         //sum of two elements\\n                \\n\\t\\t\\t\\t//update the ans if current closet of 3 elements make the sum nearest to target than previous ans \\n                if(abs(target - sum - nums[i]) < abs(target - ans))\\n                        ans=sum+nums[i];\\n                \\n                if(sum==t)        //we get the sum = target, hence no need to proceed further\\n                {\\n                    f=1;\\n                    break;\\n                }\\n                else if(sum > t)     //if sum is greater than target then move right pointer 1 step back\\n                    r--;\\n                else                      //if sum is smaller then move left pointer 1 step ahead\\n                    l++;\\n            }\\n            \\n            if(f)\\n                break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());         //sorting the elements\\n        \\n        int l, r, f=0, ans;\\n        for(int i=0;i<nums.size();i++)\\n        {  \\n\\t\\t    //making one element fixed and setting a target for other two elements\\n\\t\\t\\t// a + b + c = target    ->    a + b = target - c = t\\n            int t = target - nums[i];              \\n\\t\\t\\t\\n\\t\\t\\t//considering all elements after the current one because if we\\'ll take all elements then many operations will be repeated\\n            l=i+1; r=nums.size()-1;\\n            int sum = 0;\\n            \\n            while(l<r)\\n            {\\n                sum=nums[l]+nums[r];         //sum of two elements\\n                \\n\\t\\t\\t\\t//update the ans if current closet of 3 elements make the sum nearest to target than previous ans \\n                if(abs(target - sum - nums[i]) < abs(target - ans))\\n                        ans=sum+nums[i];\\n                \\n                if(sum==t)        //we get the sum = target, hence no need to proceed further\\n                {\\n                    f=1;\\n                    break;\\n                }\\n                else if(sum > t)     //if sum is greater than target then move right pointer 1 step back\\n                    r--;\\n                else                      //if sum is smaller then move left pointer 1 step ahead\\n                    l++;\\n            }\\n            \\n            if(f)\\n                break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955777,
                "title": "clean-commented-java-solution",
                "content": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        // insert any value in nearest\\n        // it will get corrected in the end\\n        int nearest = nums[0] + nums[1] + nums[2];\\n        \\n        for (int i = 0; i < nums.length - 2; i++) {\\n            int lo = i + 1;\\n            int hi = nums.length - 1;\\n                \\n            while (lo < hi) {\\n                int sum = nums[i] + nums[lo] + nums[hi];\\n                if (sum == target) return target;\\n\\n                // need to inc val as on lo-- it will keep going farther\\n                if (sum < target) lo++;\\n                // similar for hi\\n                else hi--;\\n\\n                // compare abs diff and update result\\n                if (Math.abs(sum - target) < Math.abs(nearest - target))\\n                    nearest = sum;\\n            }\\n        }\\n        return nearest;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        // insert any value in nearest\\n        // it will get corrected in the end\\n        int nearest = nums[0] + nums[1] + nums[2];\\n        \\n        for (int i = 0; i < nums.length - 2; i++) {\\n            int lo = i + 1;\\n            int hi = nums.length - 1;\\n                \\n            while (lo < hi) {\\n                int sum = nums[i] + nums[lo] + nums[hi];\\n                if (sum == target) return target;\\n\\n                // need to inc val as on lo-- it will keep going farther\\n                if (sum < target) lo++;\\n                // similar for hi\\n                else hi--;\\n\\n                // compare abs diff and update result\\n                if (Math.abs(sum - target) < Math.abs(nearest - target))\\n                    nearest = sum;\\n            }\\n        }\\n        return nearest;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1619838,
                "title": "python-3-pointer-solution-simple-explanation-96-faster-96-ms",
                "content": "![image](https://assets.leetcode.com/users/images/5c780459-a159-4be4-978c-72a4ec4609ab_1639058651.4989543.png)\\nFix one of the pointers at index `i` then do the typical two-sum problem with indices `j` and `k` on the remaining elements that is not at index `i`. After `i` loops through the entire array once or when you find a difference of `0`, then you have the 3sum solution.\\n```\\nclass Solution:\\n    def threeSumClosest(self, A: List[int], target: int) -> int:\\n        A = sorted(A)\\n        smallestDiff = 10001\\n        closestSum = 0\\n        \\n        for i in range(len(A)-2):\\n            j = i + 1\\n            k = len(A) - 1\\n            \\n            while j < k:\\n                threeSum = A[i] + A[j] + A[k]\\n                \\n                if abs(threeSum - target) < smallestDiff:\\n                    smallestDiff = abs(threeSum - target)\\n                    closestSum = threeSum\\n                    \\n                if threeSum < target:\\n                    j += 1\\n                elif threeSum > target:\\n                    k -= 1\\n                else:\\n                    return threeSum\\n                \\n        return closestSum\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, A: List[int], target: int) -> int:\\n        A = sorted(A)\\n        smallestDiff = 10001\\n        closestSum = 0\\n        \\n        for i in range(len(A)-2):\\n            j = i + 1\\n            k = len(A) - 1\\n            \\n            while j < k:\\n                threeSum = A[i] + A[j] + A[k]\\n                \\n                if abs(threeSum - target) < smallestDiff:\\n                    smallestDiff = abs(threeSum - target)\\n                    closestSum = threeSum\\n                    \\n                if threeSum < target:\\n                    j += 1\\n                elif threeSum > target:\\n                    k -= 1\\n                else:\\n                    return threeSum\\n                \\n        return closestSum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1609485,
                "title": "c-similar-to-3sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        int ans=INT_MAX,diff=INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n;i++){\\n            if(i>0 and nums[i]==nums[i-1])continue;\\n            int j=i+1,k=n-1;\\n            while(j<k){\\n                int sum=nums[i]+nums[j]+nums[k];\\n                if(abs(sum-target)<diff){\\n                    diff=abs(sum-target);\\n                    ans=sum;\\n                }\\n                \\n                if(sum==target){\\n                    return sum;\\n                }\\n                else if(sum>target)k--;\\n                else j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        int ans=INT_MAX,diff=INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n;i++){\\n            if(i>0 and nums[i]==nums[i-1])continue;\\n            int j=i+1,k=n-1;\\n            while(j<k){\\n                int sum=nums[i]+nums[j]+nums[k];\\n                if(abs(sum-target)<diff){\\n                    diff=abs(sum-target);\\n                    ans=sum;\\n                }\\n                \\n                if(sum==target){\\n                    return sum;\\n                }\\n                else if(sum>target)k--;\\n                else j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1546228,
                "title": "simple-to-understand-using-2-pointer-with-comments",
                "content": "**Thumbs up if you find this helpful** \\uD83D\\uDC4D\\n\\n```\\npublic class Solution {\\n    public int ThreeSumClosest(int[] nums, int target) { \\n        var result = 0;\\n        \\n        // Keep track of the solution closest to the target\\n        var closestDifference = int.MaxValue;        \\n        \\n        // Sort the array\\n        Array.Sort(nums);\\n        \\n        // Loop through numbers\\n        for (int index = 0; index < nums.Length; ++index) {     \\n            // Skip duplicates\\n            if (index > 0 && nums[index] == nums[index - 1]) {\\n                continue;\\n            }\\n            \\n            // Find 3 sum combination closest to the target value\\n            var startIndex = index + 1;\\n            var endIndex = nums.Length - 1;\\n            while (startIndex < endIndex) {\\n                // Get the sum\\n                var sum = nums[index] + nums[startIndex] + nums[endIndex];\\n                \\n                // Determine how close the sum is to the target value\\n                var difference = Math.Abs(target - sum);\\n                if (difference < closestDifference) {\\n                    closestDifference = difference;\\n                    result = sum;\\n                }\\n                \\n                // An exact match is found, exit\\n                if (difference == 0) {\\n                    break;\\n                    \\n                // Sum is less than target\\n                } else if (sum < target) {                \\n                    ++startIndex;\\n                    \\n                // Sum is greater than target\\n                } else {               \\n                    --endIndex;\\n                }                 \\n            }\\n            \\n            // An exact match is found, exit\\n            if (closestDifference == 0) {\\n                break;\\n            }\\n        }\\n                \\n        return result;\\n    }   \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int ThreeSumClosest(int[] nums, int target) { \\n        var result = 0;\\n        \\n        // Keep track of the solution closest to the target\\n        var closestDifference = int.MaxValue;        \\n        \\n        // Sort the array\\n        Array.Sort(nums);\\n        \\n        // Loop through numbers\\n        for (int index = 0; index < nums.Length; ++index) {     \\n            // Skip duplicates\\n            if (index > 0 && nums[index] == nums[index - 1]) {\\n                continue;\\n            }\\n            \\n            // Find 3 sum combination closest to the target value\\n            var startIndex = index + 1;\\n            var endIndex = nums.Length - 1;\\n            while (startIndex < endIndex) {\\n                // Get the sum\\n                var sum = nums[index] + nums[startIndex] + nums[endIndex];\\n                \\n                // Determine how close the sum is to the target value\\n                var difference = Math.Abs(target - sum);\\n                if (difference < closestDifference) {\\n                    closestDifference = difference;\\n                    result = sum;\\n                }\\n                \\n                // An exact match is found, exit\\n                if (difference == 0) {\\n                    break;\\n                    \\n                // Sum is less than target\\n                } else if (sum < target) {                \\n                    ++startIndex;\\n                    \\n                // Sum is greater than target\\n                } else {               \\n                    --endIndex;\\n                }                 \\n            }\\n            \\n            // An exact match is found, exit\\n            if (closestDifference == 0) {\\n                break;\\n            }\\n        }\\n                \\n        return result;\\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1542595,
                "title": "very-easy-js-solution",
                "content": "TC: O(N*N)\\nSC: O(1)\\n\\n```\\nvar threeSumClosest = function(A, target) {\\n    A.sort((a, b) => a - b);\\n    \\n    let closestSum = 0;\\n    let minSoFar = Infinity;\\n\\n    for(let i = 0; i <A.length -2; i++) {\\n        let j = i + 1;\\n        let k = A.length - 1;\\n        \\n        while(j < k) {\\n            const sum = A[i] + A[j] + A[k];\\n            \\n            const diff = Math.abs(sum - target);\\n\\t\\t\\t//If minimum is found, update it in \"minSoFar\".\\n            if (diff < minSoFar) {\\n                minSoFar = diff;\\n                closestSum = sum;\\n            } \\n            \\n            if(sum < target) {\\n               j++;\\n             } else {\\n                k--;\\n            }\\n        }\\n    }\\n    \\n    return closestSum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nvar threeSumClosest = function(A, target) {\\n    A.sort((a, b) => a - b);\\n    \\n    let closestSum = 0;\\n    let minSoFar = Infinity;\\n\\n    for(let i = 0; i <A.length -2; i++) {\\n        let j = i + 1;\\n        let k = A.length - 1;\\n        \\n        while(j < k) {\\n            const sum = A[i] + A[j] + A[k];\\n            \\n            const diff = Math.abs(sum - target);\\n\\t\\t\\t//If minimum is found, update it in \"minSoFar\".\\n            if (diff < minSoFar) {\\n                minSoFar = diff;\\n                closestSum = sum;\\n            } \\n            \\n            if(sum < target) {\\n               j++;\\n             } else {\\n                k--;\\n            }\\n        }\\n    }\\n    \\n    return closestSum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1402681,
                "title": "3sum-closest-two-pointers-python3",
                "content": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        minDiff = 4001\\n        minSum = sum(nums[:3])\\n        for i in range(n-2):\\n            l=i+1\\n            r=n-1\\n            while l<r:\\n                currSum = nums[i]+nums[l]+nums[r]\\n                if currSum > target:r-=1\\n                elif currSum == target: return currSum\\n                else: l+=1\\n                    \\n                if minDiff>abs(currSum-target):\\n                    minDiff = abs(currSum-target)\\n                    minSum = currSum\\n        return minSum\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        minDiff = 4001\\n        minSum = sum(nums[:3])\\n        for i in range(n-2):\\n            l=i+1\\n            r=n-1\\n            while l<r:\\n                currSum = nums[i]+nums[l]+nums[r]\\n                if currSum > target:r-=1\\n                elif currSum == target: return currSum\\n                else: l+=1\\n                    \\n                if minDiff>abs(currSum-target):\\n                    minDiff = abs(currSum-target)\\n                    minSum = currSum\\n        return minSum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1366055,
                "title": "3sum-closest-easy-to-understand-c",
                "content": "Store all possible sum and then find the answer\\'s index using upperbound.\\nTime Complexity O(n^2)\\nwhere n = size of the nums vector.\\n\\nclass Solution {\\npublic:\\nint threeSumClosest(vector<int>& nums, int target) {\\n\\n    vector<int>store;\\n    sort(nums.begin(),nums.end());\\t\\t\\n    for(int i=0;i<nums.size();i++){\\n        int first = nums[i];\\n        int low = i+1;\\n        int high = nums.size()-1;\\n        while(low<high){\\n            int sum = nums[low]+nums[high]+first;\\n            store.push_back(sum);\\n            if(sum<target) low++;\\n            else high--;\\n        }\\n    }\\n    sort(store.begin(),store.end());\\n    int ind = upper_bound(store.begin(),store.end(),target)-store.begin();\\n\\t\\n    if(ind==store.size())  return store[ind-1];\\n    if(ind==0) return store[0];\\n    int dif1 = abs(store[ind]-target);\\n    int dif2 = abs(target-store[ind-1]);\\n    if(min(dif1,dif2)==dif1) return store[ind];\\n    return store[ind-1];\\n}\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\nint threeSumClosest(vector<int>& nums, int target) {\\n\\n    vector<int>store;\\n    sort(nums.begin(),nums.end());\\t\\t\\n    for(int i=0;i<nums.size();i++){\\n        int first = nums[i];\\n        int low = i+1;\\n        int high = nums.size()-1;\\n        while(low<high){\\n            int sum = nums[low]+nums[high]+first;\\n            store.push_back(sum);\\n            if(sum<target) low++;\\n            else high--;\\n        }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1575345,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as Iam now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels and I must now accept that I realized this only after finishing a full implementation\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1572344,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as Iam now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels and I must now accept that I realized this only after finishing a full implementation\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1571044,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as Iam now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels and I must now accept that I realized this only after finishing a full implementation\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1567805,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as Iam now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels and I must now accept that I realized this only after finishing a full implementation\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1572237,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as Iam now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels and I must now accept that I realized this only after finishing a full implementation\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1803731,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as Iam now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels and I must now accept that I realized this only after finishing a full implementation\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1636149,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as Iam now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels and I must now accept that I realized this only after finishing a full implementation\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1574774,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as Iam now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels and I must now accept that I realized this only after finishing a full implementation\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1575058,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as Iam now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels and I must now accept that I realized this only after finishing a full implementation\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1786501,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as Iam now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels and I must now accept that I realized this only after finishing a full implementation\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1575345,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as Iam now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels and I must now accept that I realized this only after finishing a full implementation\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1572344,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as Iam now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels and I must now accept that I realized this only after finishing a full implementation\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1571044,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as Iam now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels and I must now accept that I realized this only after finishing a full implementation\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1567805,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as Iam now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels and I must now accept that I realized this only after finishing a full implementation\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1572237,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as Iam now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels and I must now accept that I realized this only after finishing a full implementation\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1803731,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as Iam now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels and I must now accept that I realized this only after finishing a full implementation\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1636149,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as Iam now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels and I must now accept that I realized this only after finishing a full implementation\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1574774,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as Iam now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels and I must now accept that I realized this only after finishing a full implementation\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1575058,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as Iam now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels and I must now accept that I realized this only after finishing a full implementation\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1786501,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as Iam now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels and I must now accept that I realized this only after finishing a full implementation\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1744801,
                "content": [
                    {
                        "username": "drash99",
                        "content": "Python3 n^2 log n with little optimization solution accepted\\nMay need stronger testcases"
                    },
                    {
                        "username": "austinsparky1",
                        "content": "lmao, that\\'s the type of solution I have now and I\\'ve been getting consistent TLE\\'s -- if only I did this problem earlier "
                    },
                    {
                        "username": "maxmustermann",
                        "content": "can someone please explain why sorting is necessary for the two pointer solution?"
                    },
                    {
                        "username": "Normal_Coder",
                        "content": "It helps for the increment of left and decrement of right pointers. If the sum is less then incrementing left pointer in a sorted array  guarantees you to get higher sum than the previous sum and if the sum is more then decrementing the right pointer helps you  to get lower sum than the previous one.\\nThis is why we set the left to second element and and right to last element. The same approach can be used in container with most water problem. \\nThis is not possible in an unsorted array"
                    },
                    {
                        "username": "adrian_marcelo",
                        "content": "Huge tip: I think you should solve 3Sum before this one. It will help a lot"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Does this include duplicates or not??"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am i dumb? or everyone looked at the answer?\\n"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "nums =\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget =\\n-2\\nUse Testcase\\nOutput\\n-1\\nExpected\\n-2\\nthe above test case is wrong we can not find -2 but we can find closet -1 but compiler give wrong answer\\n "
                    },
                    {
                        "username": "manasi2510",
                        "content": "[@gulllak](/gulllak) But 0, -5, 3  are not in sequence, so we have to use combination here?"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "[@gulllak](/gulllak)  but there is double 3\\n"
                    },
                    {
                        "username": "gulllak",
                        "content": "0, -5, 3 = -2"
                    },
                    {
                        "username": "yaduwanshib650",
                        "content": "my code for this question giving TLE.. how can i improve it??\\n int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int closestsum=1000000000;\\n        for(int i =0 ; nums.size()-2; i++){\\n            int low = i+1;\\n            int high = nums.size()-1;\\n            while(low<high){\\n                int sum =nums[i]+nums[low]+nums[high];\\n            if(sum==target) return sum;\\n            if(abs(target-sum)< abs(target-closestsum)){\\n                closestsum = sum;\\n            }\\n            else if(sum>target)high--;\\n            else low++;\\n\\n            }\\n        }\\n        return closestsum;\\n    }"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "I did the same thing but I didn\\'t get TLE...\\uD83D\\uDE05\\uD83E\\uDD14"
                    },
                    {
                        "username": "Viacheslav1985",
                        "content": "I have got this:\\nTime Limit Exceeded\\n98 / 98 testcases passed\\nLast Executed Input\\nnums =\\n\\nWhat does it mean ?"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It means, you passed all test cases individually but total time of all test cases is more than expected."
                    },
                    {
                        "username": "dhruvpatel0401",
                        "content": "=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000500 at pc 0x000000346525 bp 0x7ffeed331a50 sp 0x7ffeed331a48\nREAD of size 4 at 0x602000000500 thread T0\n    #2 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000500 is located 0 bytes to the right of 16-byte region [0x6020000004f0,0x602000000500)\nallocated by thread T0 here:\n    #6 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa 00 00\n=>0x0c047fff80a0:[fa]fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING\n\n\n\n\n\nclass Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        sort(nums.begin(),nums.end());\n\n        int comp=INT_MAX,n=nums.size(),res=0;\n        \n        for(int i=0; i<n-2; i++)\n        {\n            int j = i+1, k = n-1;\n\n            while(j<k)\n            {\n                int sum = nums[i]+nums[j]+nums[k];\n                if(comp > abs(sum-target))\n                {\n                    comp = abs(sum-target);\n                    res = sum;\n                }\n\n                if(sum < target)\n                {\n                    j++;\n                }\n                else if(sum > target)\n                {\n                    k--;\n                }\n                else\n                {\n                    return res;\n                }\n            }\n            while(nums[i+1] == nums[i] && i+1 < n) i++;\n        }\n        return res;\n    }\n};\n\n\nWhy am I getting this error?"
                    },
                    {
                        "username": "Himanshu_Singh11",
                        "content": "same error"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    }
                ]
            },
            {
                "id": 1729330,
                "content": [
                    {
                        "username": "drash99",
                        "content": "Python3 n^2 log n with little optimization solution accepted\\nMay need stronger testcases"
                    },
                    {
                        "username": "austinsparky1",
                        "content": "lmao, that\\'s the type of solution I have now and I\\'ve been getting consistent TLE\\'s -- if only I did this problem earlier "
                    },
                    {
                        "username": "maxmustermann",
                        "content": "can someone please explain why sorting is necessary for the two pointer solution?"
                    },
                    {
                        "username": "Normal_Coder",
                        "content": "It helps for the increment of left and decrement of right pointers. If the sum is less then incrementing left pointer in a sorted array  guarantees you to get higher sum than the previous sum and if the sum is more then decrementing the right pointer helps you  to get lower sum than the previous one.\\nThis is why we set the left to second element and and right to last element. The same approach can be used in container with most water problem. \\nThis is not possible in an unsorted array"
                    },
                    {
                        "username": "adrian_marcelo",
                        "content": "Huge tip: I think you should solve 3Sum before this one. It will help a lot"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Does this include duplicates or not??"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am i dumb? or everyone looked at the answer?\\n"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "nums =\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget =\\n-2\\nUse Testcase\\nOutput\\n-1\\nExpected\\n-2\\nthe above test case is wrong we can not find -2 but we can find closet -1 but compiler give wrong answer\\n "
                    },
                    {
                        "username": "manasi2510",
                        "content": "[@gulllak](/gulllak) But 0, -5, 3  are not in sequence, so we have to use combination here?"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "[@gulllak](/gulllak)  but there is double 3\\n"
                    },
                    {
                        "username": "gulllak",
                        "content": "0, -5, 3 = -2"
                    },
                    {
                        "username": "yaduwanshib650",
                        "content": "my code for this question giving TLE.. how can i improve it??\\n int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int closestsum=1000000000;\\n        for(int i =0 ; nums.size()-2; i++){\\n            int low = i+1;\\n            int high = nums.size()-1;\\n            while(low<high){\\n                int sum =nums[i]+nums[low]+nums[high];\\n            if(sum==target) return sum;\\n            if(abs(target-sum)< abs(target-closestsum)){\\n                closestsum = sum;\\n            }\\n            else if(sum>target)high--;\\n            else low++;\\n\\n            }\\n        }\\n        return closestsum;\\n    }"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "I did the same thing but I didn\\'t get TLE...\\uD83D\\uDE05\\uD83E\\uDD14"
                    },
                    {
                        "username": "Viacheslav1985",
                        "content": "I have got this:\\nTime Limit Exceeded\\n98 / 98 testcases passed\\nLast Executed Input\\nnums =\\n\\nWhat does it mean ?"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It means, you passed all test cases individually but total time of all test cases is more than expected."
                    },
                    {
                        "username": "dhruvpatel0401",
                        "content": "=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000500 at pc 0x000000346525 bp 0x7ffeed331a50 sp 0x7ffeed331a48\nREAD of size 4 at 0x602000000500 thread T0\n    #2 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000500 is located 0 bytes to the right of 16-byte region [0x6020000004f0,0x602000000500)\nallocated by thread T0 here:\n    #6 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa 00 00\n=>0x0c047fff80a0:[fa]fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING\n\n\n\n\n\nclass Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        sort(nums.begin(),nums.end());\n\n        int comp=INT_MAX,n=nums.size(),res=0;\n        \n        for(int i=0; i<n-2; i++)\n        {\n            int j = i+1, k = n-1;\n\n            while(j<k)\n            {\n                int sum = nums[i]+nums[j]+nums[k];\n                if(comp > abs(sum-target))\n                {\n                    comp = abs(sum-target);\n                    res = sum;\n                }\n\n                if(sum < target)\n                {\n                    j++;\n                }\n                else if(sum > target)\n                {\n                    k--;\n                }\n                else\n                {\n                    return res;\n                }\n            }\n            while(nums[i+1] == nums[i] && i+1 < n) i++;\n        }\n        return res;\n    }\n};\n\n\nWhy am I getting this error?"
                    },
                    {
                        "username": "Himanshu_Singh11",
                        "content": "same error"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    }
                ]
            },
            {
                "id": 2017604,
                "content": [
                    {
                        "username": "drash99",
                        "content": "Python3 n^2 log n with little optimization solution accepted\\nMay need stronger testcases"
                    },
                    {
                        "username": "austinsparky1",
                        "content": "lmao, that\\'s the type of solution I have now and I\\'ve been getting consistent TLE\\'s -- if only I did this problem earlier "
                    },
                    {
                        "username": "maxmustermann",
                        "content": "can someone please explain why sorting is necessary for the two pointer solution?"
                    },
                    {
                        "username": "Normal_Coder",
                        "content": "It helps for the increment of left and decrement of right pointers. If the sum is less then incrementing left pointer in a sorted array  guarantees you to get higher sum than the previous sum and if the sum is more then decrementing the right pointer helps you  to get lower sum than the previous one.\\nThis is why we set the left to second element and and right to last element. The same approach can be used in container with most water problem. \\nThis is not possible in an unsorted array"
                    },
                    {
                        "username": "adrian_marcelo",
                        "content": "Huge tip: I think you should solve 3Sum before this one. It will help a lot"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Does this include duplicates or not??"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am i dumb? or everyone looked at the answer?\\n"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "nums =\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget =\\n-2\\nUse Testcase\\nOutput\\n-1\\nExpected\\n-2\\nthe above test case is wrong we can not find -2 but we can find closet -1 but compiler give wrong answer\\n "
                    },
                    {
                        "username": "manasi2510",
                        "content": "[@gulllak](/gulllak) But 0, -5, 3  are not in sequence, so we have to use combination here?"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "[@gulllak](/gulllak)  but there is double 3\\n"
                    },
                    {
                        "username": "gulllak",
                        "content": "0, -5, 3 = -2"
                    },
                    {
                        "username": "yaduwanshib650",
                        "content": "my code for this question giving TLE.. how can i improve it??\\n int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int closestsum=1000000000;\\n        for(int i =0 ; nums.size()-2; i++){\\n            int low = i+1;\\n            int high = nums.size()-1;\\n            while(low<high){\\n                int sum =nums[i]+nums[low]+nums[high];\\n            if(sum==target) return sum;\\n            if(abs(target-sum)< abs(target-closestsum)){\\n                closestsum = sum;\\n            }\\n            else if(sum>target)high--;\\n            else low++;\\n\\n            }\\n        }\\n        return closestsum;\\n    }"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "I did the same thing but I didn\\'t get TLE...\\uD83D\\uDE05\\uD83E\\uDD14"
                    },
                    {
                        "username": "Viacheslav1985",
                        "content": "I have got this:\\nTime Limit Exceeded\\n98 / 98 testcases passed\\nLast Executed Input\\nnums =\\n\\nWhat does it mean ?"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It means, you passed all test cases individually but total time of all test cases is more than expected."
                    },
                    {
                        "username": "dhruvpatel0401",
                        "content": "=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000500 at pc 0x000000346525 bp 0x7ffeed331a50 sp 0x7ffeed331a48\nREAD of size 4 at 0x602000000500 thread T0\n    #2 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000500 is located 0 bytes to the right of 16-byte region [0x6020000004f0,0x602000000500)\nallocated by thread T0 here:\n    #6 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa 00 00\n=>0x0c047fff80a0:[fa]fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING\n\n\n\n\n\nclass Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        sort(nums.begin(),nums.end());\n\n        int comp=INT_MAX,n=nums.size(),res=0;\n        \n        for(int i=0; i<n-2; i++)\n        {\n            int j = i+1, k = n-1;\n\n            while(j<k)\n            {\n                int sum = nums[i]+nums[j]+nums[k];\n                if(comp > abs(sum-target))\n                {\n                    comp = abs(sum-target);\n                    res = sum;\n                }\n\n                if(sum < target)\n                {\n                    j++;\n                }\n                else if(sum > target)\n                {\n                    k--;\n                }\n                else\n                {\n                    return res;\n                }\n            }\n            while(nums[i+1] == nums[i] && i+1 < n) i++;\n        }\n        return res;\n    }\n};\n\n\nWhy am I getting this error?"
                    },
                    {
                        "username": "Himanshu_Singh11",
                        "content": "same error"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    }
                ]
            },
            {
                "id": 2010783,
                "content": [
                    {
                        "username": "drash99",
                        "content": "Python3 n^2 log n with little optimization solution accepted\\nMay need stronger testcases"
                    },
                    {
                        "username": "austinsparky1",
                        "content": "lmao, that\\'s the type of solution I have now and I\\'ve been getting consistent TLE\\'s -- if only I did this problem earlier "
                    },
                    {
                        "username": "maxmustermann",
                        "content": "can someone please explain why sorting is necessary for the two pointer solution?"
                    },
                    {
                        "username": "Normal_Coder",
                        "content": "It helps for the increment of left and decrement of right pointers. If the sum is less then incrementing left pointer in a sorted array  guarantees you to get higher sum than the previous sum and if the sum is more then decrementing the right pointer helps you  to get lower sum than the previous one.\\nThis is why we set the left to second element and and right to last element. The same approach can be used in container with most water problem. \\nThis is not possible in an unsorted array"
                    },
                    {
                        "username": "adrian_marcelo",
                        "content": "Huge tip: I think you should solve 3Sum before this one. It will help a lot"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Does this include duplicates or not??"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am i dumb? or everyone looked at the answer?\\n"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "nums =\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget =\\n-2\\nUse Testcase\\nOutput\\n-1\\nExpected\\n-2\\nthe above test case is wrong we can not find -2 but we can find closet -1 but compiler give wrong answer\\n "
                    },
                    {
                        "username": "manasi2510",
                        "content": "[@gulllak](/gulllak) But 0, -5, 3  are not in sequence, so we have to use combination here?"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "[@gulllak](/gulllak)  but there is double 3\\n"
                    },
                    {
                        "username": "gulllak",
                        "content": "0, -5, 3 = -2"
                    },
                    {
                        "username": "yaduwanshib650",
                        "content": "my code for this question giving TLE.. how can i improve it??\\n int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int closestsum=1000000000;\\n        for(int i =0 ; nums.size()-2; i++){\\n            int low = i+1;\\n            int high = nums.size()-1;\\n            while(low<high){\\n                int sum =nums[i]+nums[low]+nums[high];\\n            if(sum==target) return sum;\\n            if(abs(target-sum)< abs(target-closestsum)){\\n                closestsum = sum;\\n            }\\n            else if(sum>target)high--;\\n            else low++;\\n\\n            }\\n        }\\n        return closestsum;\\n    }"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "I did the same thing but I didn\\'t get TLE...\\uD83D\\uDE05\\uD83E\\uDD14"
                    },
                    {
                        "username": "Viacheslav1985",
                        "content": "I have got this:\\nTime Limit Exceeded\\n98 / 98 testcases passed\\nLast Executed Input\\nnums =\\n\\nWhat does it mean ?"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It means, you passed all test cases individually but total time of all test cases is more than expected."
                    },
                    {
                        "username": "dhruvpatel0401",
                        "content": "=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000500 at pc 0x000000346525 bp 0x7ffeed331a50 sp 0x7ffeed331a48\nREAD of size 4 at 0x602000000500 thread T0\n    #2 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000500 is located 0 bytes to the right of 16-byte region [0x6020000004f0,0x602000000500)\nallocated by thread T0 here:\n    #6 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa 00 00\n=>0x0c047fff80a0:[fa]fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING\n\n\n\n\n\nclass Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        sort(nums.begin(),nums.end());\n\n        int comp=INT_MAX,n=nums.size(),res=0;\n        \n        for(int i=0; i<n-2; i++)\n        {\n            int j = i+1, k = n-1;\n\n            while(j<k)\n            {\n                int sum = nums[i]+nums[j]+nums[k];\n                if(comp > abs(sum-target))\n                {\n                    comp = abs(sum-target);\n                    res = sum;\n                }\n\n                if(sum < target)\n                {\n                    j++;\n                }\n                else if(sum > target)\n                {\n                    k--;\n                }\n                else\n                {\n                    return res;\n                }\n            }\n            while(nums[i+1] == nums[i] && i+1 < n) i++;\n        }\n        return res;\n    }\n};\n\n\nWhy am I getting this error?"
                    },
                    {
                        "username": "Himanshu_Singh11",
                        "content": "same error"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    }
                ]
            },
            {
                "id": 1946972,
                "content": [
                    {
                        "username": "drash99",
                        "content": "Python3 n^2 log n with little optimization solution accepted\\nMay need stronger testcases"
                    },
                    {
                        "username": "austinsparky1",
                        "content": "lmao, that\\'s the type of solution I have now and I\\'ve been getting consistent TLE\\'s -- if only I did this problem earlier "
                    },
                    {
                        "username": "maxmustermann",
                        "content": "can someone please explain why sorting is necessary for the two pointer solution?"
                    },
                    {
                        "username": "Normal_Coder",
                        "content": "It helps for the increment of left and decrement of right pointers. If the sum is less then incrementing left pointer in a sorted array  guarantees you to get higher sum than the previous sum and if the sum is more then decrementing the right pointer helps you  to get lower sum than the previous one.\\nThis is why we set the left to second element and and right to last element. The same approach can be used in container with most water problem. \\nThis is not possible in an unsorted array"
                    },
                    {
                        "username": "adrian_marcelo",
                        "content": "Huge tip: I think you should solve 3Sum before this one. It will help a lot"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Does this include duplicates or not??"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am i dumb? or everyone looked at the answer?\\n"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "nums =\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget =\\n-2\\nUse Testcase\\nOutput\\n-1\\nExpected\\n-2\\nthe above test case is wrong we can not find -2 but we can find closet -1 but compiler give wrong answer\\n "
                    },
                    {
                        "username": "manasi2510",
                        "content": "[@gulllak](/gulllak) But 0, -5, 3  are not in sequence, so we have to use combination here?"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "[@gulllak](/gulllak)  but there is double 3\\n"
                    },
                    {
                        "username": "gulllak",
                        "content": "0, -5, 3 = -2"
                    },
                    {
                        "username": "yaduwanshib650",
                        "content": "my code for this question giving TLE.. how can i improve it??\\n int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int closestsum=1000000000;\\n        for(int i =0 ; nums.size()-2; i++){\\n            int low = i+1;\\n            int high = nums.size()-1;\\n            while(low<high){\\n                int sum =nums[i]+nums[low]+nums[high];\\n            if(sum==target) return sum;\\n            if(abs(target-sum)< abs(target-closestsum)){\\n                closestsum = sum;\\n            }\\n            else if(sum>target)high--;\\n            else low++;\\n\\n            }\\n        }\\n        return closestsum;\\n    }"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "I did the same thing but I didn\\'t get TLE...\\uD83D\\uDE05\\uD83E\\uDD14"
                    },
                    {
                        "username": "Viacheslav1985",
                        "content": "I have got this:\\nTime Limit Exceeded\\n98 / 98 testcases passed\\nLast Executed Input\\nnums =\\n\\nWhat does it mean ?"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It means, you passed all test cases individually but total time of all test cases is more than expected."
                    },
                    {
                        "username": "dhruvpatel0401",
                        "content": "=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000500 at pc 0x000000346525 bp 0x7ffeed331a50 sp 0x7ffeed331a48\nREAD of size 4 at 0x602000000500 thread T0\n    #2 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000500 is located 0 bytes to the right of 16-byte region [0x6020000004f0,0x602000000500)\nallocated by thread T0 here:\n    #6 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa 00 00\n=>0x0c047fff80a0:[fa]fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING\n\n\n\n\n\nclass Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        sort(nums.begin(),nums.end());\n\n        int comp=INT_MAX,n=nums.size(),res=0;\n        \n        for(int i=0; i<n-2; i++)\n        {\n            int j = i+1, k = n-1;\n\n            while(j<k)\n            {\n                int sum = nums[i]+nums[j]+nums[k];\n                if(comp > abs(sum-target))\n                {\n                    comp = abs(sum-target);\n                    res = sum;\n                }\n\n                if(sum < target)\n                {\n                    j++;\n                }\n                else if(sum > target)\n                {\n                    k--;\n                }\n                else\n                {\n                    return res;\n                }\n            }\n            while(nums[i+1] == nums[i] && i+1 < n) i++;\n        }\n        return res;\n    }\n};\n\n\nWhy am I getting this error?"
                    },
                    {
                        "username": "Himanshu_Singh11",
                        "content": "same error"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    }
                ]
            },
            {
                "id": 1838611,
                "content": [
                    {
                        "username": "drash99",
                        "content": "Python3 n^2 log n with little optimization solution accepted\\nMay need stronger testcases"
                    },
                    {
                        "username": "austinsparky1",
                        "content": "lmao, that\\'s the type of solution I have now and I\\'ve been getting consistent TLE\\'s -- if only I did this problem earlier "
                    },
                    {
                        "username": "maxmustermann",
                        "content": "can someone please explain why sorting is necessary for the two pointer solution?"
                    },
                    {
                        "username": "Normal_Coder",
                        "content": "It helps for the increment of left and decrement of right pointers. If the sum is less then incrementing left pointer in a sorted array  guarantees you to get higher sum than the previous sum and if the sum is more then decrementing the right pointer helps you  to get lower sum than the previous one.\\nThis is why we set the left to second element and and right to last element. The same approach can be used in container with most water problem. \\nThis is not possible in an unsorted array"
                    },
                    {
                        "username": "adrian_marcelo",
                        "content": "Huge tip: I think you should solve 3Sum before this one. It will help a lot"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Does this include duplicates or not??"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am i dumb? or everyone looked at the answer?\\n"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "nums =\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget =\\n-2\\nUse Testcase\\nOutput\\n-1\\nExpected\\n-2\\nthe above test case is wrong we can not find -2 but we can find closet -1 but compiler give wrong answer\\n "
                    },
                    {
                        "username": "manasi2510",
                        "content": "[@gulllak](/gulllak) But 0, -5, 3  are not in sequence, so we have to use combination here?"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "[@gulllak](/gulllak)  but there is double 3\\n"
                    },
                    {
                        "username": "gulllak",
                        "content": "0, -5, 3 = -2"
                    },
                    {
                        "username": "yaduwanshib650",
                        "content": "my code for this question giving TLE.. how can i improve it??\\n int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int closestsum=1000000000;\\n        for(int i =0 ; nums.size()-2; i++){\\n            int low = i+1;\\n            int high = nums.size()-1;\\n            while(low<high){\\n                int sum =nums[i]+nums[low]+nums[high];\\n            if(sum==target) return sum;\\n            if(abs(target-sum)< abs(target-closestsum)){\\n                closestsum = sum;\\n            }\\n            else if(sum>target)high--;\\n            else low++;\\n\\n            }\\n        }\\n        return closestsum;\\n    }"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "I did the same thing but I didn\\'t get TLE...\\uD83D\\uDE05\\uD83E\\uDD14"
                    },
                    {
                        "username": "Viacheslav1985",
                        "content": "I have got this:\\nTime Limit Exceeded\\n98 / 98 testcases passed\\nLast Executed Input\\nnums =\\n\\nWhat does it mean ?"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It means, you passed all test cases individually but total time of all test cases is more than expected."
                    },
                    {
                        "username": "dhruvpatel0401",
                        "content": "=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000500 at pc 0x000000346525 bp 0x7ffeed331a50 sp 0x7ffeed331a48\nREAD of size 4 at 0x602000000500 thread T0\n    #2 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000500 is located 0 bytes to the right of 16-byte region [0x6020000004f0,0x602000000500)\nallocated by thread T0 here:\n    #6 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa 00 00\n=>0x0c047fff80a0:[fa]fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING\n\n\n\n\n\nclass Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        sort(nums.begin(),nums.end());\n\n        int comp=INT_MAX,n=nums.size(),res=0;\n        \n        for(int i=0; i<n-2; i++)\n        {\n            int j = i+1, k = n-1;\n\n            while(j<k)\n            {\n                int sum = nums[i]+nums[j]+nums[k];\n                if(comp > abs(sum-target))\n                {\n                    comp = abs(sum-target);\n                    res = sum;\n                }\n\n                if(sum < target)\n                {\n                    j++;\n                }\n                else if(sum > target)\n                {\n                    k--;\n                }\n                else\n                {\n                    return res;\n                }\n            }\n            while(nums[i+1] == nums[i] && i+1 < n) i++;\n        }\n        return res;\n    }\n};\n\n\nWhy am I getting this error?"
                    },
                    {
                        "username": "Himanshu_Singh11",
                        "content": "same error"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    }
                ]
            },
            {
                "id": 1749948,
                "content": [
                    {
                        "username": "drash99",
                        "content": "Python3 n^2 log n with little optimization solution accepted\\nMay need stronger testcases"
                    },
                    {
                        "username": "austinsparky1",
                        "content": "lmao, that\\'s the type of solution I have now and I\\'ve been getting consistent TLE\\'s -- if only I did this problem earlier "
                    },
                    {
                        "username": "maxmustermann",
                        "content": "can someone please explain why sorting is necessary for the two pointer solution?"
                    },
                    {
                        "username": "Normal_Coder",
                        "content": "It helps for the increment of left and decrement of right pointers. If the sum is less then incrementing left pointer in a sorted array  guarantees you to get higher sum than the previous sum and if the sum is more then decrementing the right pointer helps you  to get lower sum than the previous one.\\nThis is why we set the left to second element and and right to last element. The same approach can be used in container with most water problem. \\nThis is not possible in an unsorted array"
                    },
                    {
                        "username": "adrian_marcelo",
                        "content": "Huge tip: I think you should solve 3Sum before this one. It will help a lot"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Does this include duplicates or not??"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am i dumb? or everyone looked at the answer?\\n"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "nums =\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget =\\n-2\\nUse Testcase\\nOutput\\n-1\\nExpected\\n-2\\nthe above test case is wrong we can not find -2 but we can find closet -1 but compiler give wrong answer\\n "
                    },
                    {
                        "username": "manasi2510",
                        "content": "[@gulllak](/gulllak) But 0, -5, 3  are not in sequence, so we have to use combination here?"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "[@gulllak](/gulllak)  but there is double 3\\n"
                    },
                    {
                        "username": "gulllak",
                        "content": "0, -5, 3 = -2"
                    },
                    {
                        "username": "yaduwanshib650",
                        "content": "my code for this question giving TLE.. how can i improve it??\\n int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int closestsum=1000000000;\\n        for(int i =0 ; nums.size()-2; i++){\\n            int low = i+1;\\n            int high = nums.size()-1;\\n            while(low<high){\\n                int sum =nums[i]+nums[low]+nums[high];\\n            if(sum==target) return sum;\\n            if(abs(target-sum)< abs(target-closestsum)){\\n                closestsum = sum;\\n            }\\n            else if(sum>target)high--;\\n            else low++;\\n\\n            }\\n        }\\n        return closestsum;\\n    }"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "I did the same thing but I didn\\'t get TLE...\\uD83D\\uDE05\\uD83E\\uDD14"
                    },
                    {
                        "username": "Viacheslav1985",
                        "content": "I have got this:\\nTime Limit Exceeded\\n98 / 98 testcases passed\\nLast Executed Input\\nnums =\\n\\nWhat does it mean ?"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It means, you passed all test cases individually but total time of all test cases is more than expected."
                    },
                    {
                        "username": "dhruvpatel0401",
                        "content": "=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000500 at pc 0x000000346525 bp 0x7ffeed331a50 sp 0x7ffeed331a48\nREAD of size 4 at 0x602000000500 thread T0\n    #2 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000500 is located 0 bytes to the right of 16-byte region [0x6020000004f0,0x602000000500)\nallocated by thread T0 here:\n    #6 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa 00 00\n=>0x0c047fff80a0:[fa]fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING\n\n\n\n\n\nclass Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        sort(nums.begin(),nums.end());\n\n        int comp=INT_MAX,n=nums.size(),res=0;\n        \n        for(int i=0; i<n-2; i++)\n        {\n            int j = i+1, k = n-1;\n\n            while(j<k)\n            {\n                int sum = nums[i]+nums[j]+nums[k];\n                if(comp > abs(sum-target))\n                {\n                    comp = abs(sum-target);\n                    res = sum;\n                }\n\n                if(sum < target)\n                {\n                    j++;\n                }\n                else if(sum > target)\n                {\n                    k--;\n                }\n                else\n                {\n                    return res;\n                }\n            }\n            while(nums[i+1] == nums[i] && i+1 < n) i++;\n        }\n        return res;\n    }\n};\n\n\nWhy am I getting this error?"
                    },
                    {
                        "username": "Himanshu_Singh11",
                        "content": "same error"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    }
                ]
            },
            {
                "id": 1746883,
                "content": [
                    {
                        "username": "drash99",
                        "content": "Python3 n^2 log n with little optimization solution accepted\\nMay need stronger testcases"
                    },
                    {
                        "username": "austinsparky1",
                        "content": "lmao, that\\'s the type of solution I have now and I\\'ve been getting consistent TLE\\'s -- if only I did this problem earlier "
                    },
                    {
                        "username": "maxmustermann",
                        "content": "can someone please explain why sorting is necessary for the two pointer solution?"
                    },
                    {
                        "username": "Normal_Coder",
                        "content": "It helps for the increment of left and decrement of right pointers. If the sum is less then incrementing left pointer in a sorted array  guarantees you to get higher sum than the previous sum and if the sum is more then decrementing the right pointer helps you  to get lower sum than the previous one.\\nThis is why we set the left to second element and and right to last element. The same approach can be used in container with most water problem. \\nThis is not possible in an unsorted array"
                    },
                    {
                        "username": "adrian_marcelo",
                        "content": "Huge tip: I think you should solve 3Sum before this one. It will help a lot"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Does this include duplicates or not??"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am i dumb? or everyone looked at the answer?\\n"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "nums =\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget =\\n-2\\nUse Testcase\\nOutput\\n-1\\nExpected\\n-2\\nthe above test case is wrong we can not find -2 but we can find closet -1 but compiler give wrong answer\\n "
                    },
                    {
                        "username": "manasi2510",
                        "content": "[@gulllak](/gulllak) But 0, -5, 3  are not in sequence, so we have to use combination here?"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "[@gulllak](/gulllak)  but there is double 3\\n"
                    },
                    {
                        "username": "gulllak",
                        "content": "0, -5, 3 = -2"
                    },
                    {
                        "username": "yaduwanshib650",
                        "content": "my code for this question giving TLE.. how can i improve it??\\n int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int closestsum=1000000000;\\n        for(int i =0 ; nums.size()-2; i++){\\n            int low = i+1;\\n            int high = nums.size()-1;\\n            while(low<high){\\n                int sum =nums[i]+nums[low]+nums[high];\\n            if(sum==target) return sum;\\n            if(abs(target-sum)< abs(target-closestsum)){\\n                closestsum = sum;\\n            }\\n            else if(sum>target)high--;\\n            else low++;\\n\\n            }\\n        }\\n        return closestsum;\\n    }"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "I did the same thing but I didn\\'t get TLE...\\uD83D\\uDE05\\uD83E\\uDD14"
                    },
                    {
                        "username": "Viacheslav1985",
                        "content": "I have got this:\\nTime Limit Exceeded\\n98 / 98 testcases passed\\nLast Executed Input\\nnums =\\n\\nWhat does it mean ?"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It means, you passed all test cases individually but total time of all test cases is more than expected."
                    },
                    {
                        "username": "dhruvpatel0401",
                        "content": "=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000500 at pc 0x000000346525 bp 0x7ffeed331a50 sp 0x7ffeed331a48\nREAD of size 4 at 0x602000000500 thread T0\n    #2 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000500 is located 0 bytes to the right of 16-byte region [0x6020000004f0,0x602000000500)\nallocated by thread T0 here:\n    #6 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa 00 00\n=>0x0c047fff80a0:[fa]fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING\n\n\n\n\n\nclass Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        sort(nums.begin(),nums.end());\n\n        int comp=INT_MAX,n=nums.size(),res=0;\n        \n        for(int i=0; i<n-2; i++)\n        {\n            int j = i+1, k = n-1;\n\n            while(j<k)\n            {\n                int sum = nums[i]+nums[j]+nums[k];\n                if(comp > abs(sum-target))\n                {\n                    comp = abs(sum-target);\n                    res = sum;\n                }\n\n                if(sum < target)\n                {\n                    j++;\n                }\n                else if(sum > target)\n                {\n                    k--;\n                }\n                else\n                {\n                    return res;\n                }\n            }\n            while(nums[i+1] == nums[i] && i+1 < n) i++;\n        }\n        return res;\n    }\n};\n\n\nWhy am I getting this error?"
                    },
                    {
                        "username": "Himanshu_Singh11",
                        "content": "same error"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    }
                ]
            },
            {
                "id": 1733038,
                "content": [
                    {
                        "username": "drash99",
                        "content": "Python3 n^2 log n with little optimization solution accepted\\nMay need stronger testcases"
                    },
                    {
                        "username": "austinsparky1",
                        "content": "lmao, that\\'s the type of solution I have now and I\\'ve been getting consistent TLE\\'s -- if only I did this problem earlier "
                    },
                    {
                        "username": "maxmustermann",
                        "content": "can someone please explain why sorting is necessary for the two pointer solution?"
                    },
                    {
                        "username": "Normal_Coder",
                        "content": "It helps for the increment of left and decrement of right pointers. If the sum is less then incrementing left pointer in a sorted array  guarantees you to get higher sum than the previous sum and if the sum is more then decrementing the right pointer helps you  to get lower sum than the previous one.\\nThis is why we set the left to second element and and right to last element. The same approach can be used in container with most water problem. \\nThis is not possible in an unsorted array"
                    },
                    {
                        "username": "adrian_marcelo",
                        "content": "Huge tip: I think you should solve 3Sum before this one. It will help a lot"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Does this include duplicates or not??"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am i dumb? or everyone looked at the answer?\\n"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "nums =\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget =\\n-2\\nUse Testcase\\nOutput\\n-1\\nExpected\\n-2\\nthe above test case is wrong we can not find -2 but we can find closet -1 but compiler give wrong answer\\n "
                    },
                    {
                        "username": "manasi2510",
                        "content": "[@gulllak](/gulllak) But 0, -5, 3  are not in sequence, so we have to use combination here?"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "[@gulllak](/gulllak)  but there is double 3\\n"
                    },
                    {
                        "username": "gulllak",
                        "content": "0, -5, 3 = -2"
                    },
                    {
                        "username": "yaduwanshib650",
                        "content": "my code for this question giving TLE.. how can i improve it??\\n int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int closestsum=1000000000;\\n        for(int i =0 ; nums.size()-2; i++){\\n            int low = i+1;\\n            int high = nums.size()-1;\\n            while(low<high){\\n                int sum =nums[i]+nums[low]+nums[high];\\n            if(sum==target) return sum;\\n            if(abs(target-sum)< abs(target-closestsum)){\\n                closestsum = sum;\\n            }\\n            else if(sum>target)high--;\\n            else low++;\\n\\n            }\\n        }\\n        return closestsum;\\n    }"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "I did the same thing but I didn\\'t get TLE...\\uD83D\\uDE05\\uD83E\\uDD14"
                    },
                    {
                        "username": "Viacheslav1985",
                        "content": "I have got this:\\nTime Limit Exceeded\\n98 / 98 testcases passed\\nLast Executed Input\\nnums =\\n\\nWhat does it mean ?"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It means, you passed all test cases individually but total time of all test cases is more than expected."
                    },
                    {
                        "username": "dhruvpatel0401",
                        "content": "=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000500 at pc 0x000000346525 bp 0x7ffeed331a50 sp 0x7ffeed331a48\nREAD of size 4 at 0x602000000500 thread T0\n    #2 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000500 is located 0 bytes to the right of 16-byte region [0x6020000004f0,0x602000000500)\nallocated by thread T0 here:\n    #6 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa 00 00\n=>0x0c047fff80a0:[fa]fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING\n\n\n\n\n\nclass Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        sort(nums.begin(),nums.end());\n\n        int comp=INT_MAX,n=nums.size(),res=0;\n        \n        for(int i=0; i<n-2; i++)\n        {\n            int j = i+1, k = n-1;\n\n            while(j<k)\n            {\n                int sum = nums[i]+nums[j]+nums[k];\n                if(comp > abs(sum-target))\n                {\n                    comp = abs(sum-target);\n                    res = sum;\n                }\n\n                if(sum < target)\n                {\n                    j++;\n                }\n                else if(sum > target)\n                {\n                    k--;\n                }\n                else\n                {\n                    return res;\n                }\n            }\n            while(nums[i+1] == nums[i] && i+1 < n) i++;\n        }\n        return res;\n    }\n};\n\n\nWhy am I getting this error?"
                    },
                    {
                        "username": "Himanshu_Singh11",
                        "content": "same error"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    }
                ]
            },
            {
                "id": 1576653,
                "content": [
                    {
                        "username": "drash99",
                        "content": "Python3 n^2 log n with little optimization solution accepted\\nMay need stronger testcases"
                    },
                    {
                        "username": "austinsparky1",
                        "content": "lmao, that\\'s the type of solution I have now and I\\'ve been getting consistent TLE\\'s -- if only I did this problem earlier "
                    },
                    {
                        "username": "maxmustermann",
                        "content": "can someone please explain why sorting is necessary for the two pointer solution?"
                    },
                    {
                        "username": "Normal_Coder",
                        "content": "It helps for the increment of left and decrement of right pointers. If the sum is less then incrementing left pointer in a sorted array  guarantees you to get higher sum than the previous sum and if the sum is more then decrementing the right pointer helps you  to get lower sum than the previous one.\\nThis is why we set the left to second element and and right to last element. The same approach can be used in container with most water problem. \\nThis is not possible in an unsorted array"
                    },
                    {
                        "username": "adrian_marcelo",
                        "content": "Huge tip: I think you should solve 3Sum before this one. It will help a lot"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Does this include duplicates or not??"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am i dumb? or everyone looked at the answer?\\n"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "nums =\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget =\\n-2\\nUse Testcase\\nOutput\\n-1\\nExpected\\n-2\\nthe above test case is wrong we can not find -2 but we can find closet -1 but compiler give wrong answer\\n "
                    },
                    {
                        "username": "manasi2510",
                        "content": "[@gulllak](/gulllak) But 0, -5, 3  are not in sequence, so we have to use combination here?"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "[@gulllak](/gulllak)  but there is double 3\\n"
                    },
                    {
                        "username": "gulllak",
                        "content": "0, -5, 3 = -2"
                    },
                    {
                        "username": "yaduwanshib650",
                        "content": "my code for this question giving TLE.. how can i improve it??\\n int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int closestsum=1000000000;\\n        for(int i =0 ; nums.size()-2; i++){\\n            int low = i+1;\\n            int high = nums.size()-1;\\n            while(low<high){\\n                int sum =nums[i]+nums[low]+nums[high];\\n            if(sum==target) return sum;\\n            if(abs(target-sum)< abs(target-closestsum)){\\n                closestsum = sum;\\n            }\\n            else if(sum>target)high--;\\n            else low++;\\n\\n            }\\n        }\\n        return closestsum;\\n    }"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "I did the same thing but I didn\\'t get TLE...\\uD83D\\uDE05\\uD83E\\uDD14"
                    },
                    {
                        "username": "Viacheslav1985",
                        "content": "I have got this:\\nTime Limit Exceeded\\n98 / 98 testcases passed\\nLast Executed Input\\nnums =\\n\\nWhat does it mean ?"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It means, you passed all test cases individually but total time of all test cases is more than expected."
                    },
                    {
                        "username": "dhruvpatel0401",
                        "content": "=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000500 at pc 0x000000346525 bp 0x7ffeed331a50 sp 0x7ffeed331a48\nREAD of size 4 at 0x602000000500 thread T0\n    #2 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000500 is located 0 bytes to the right of 16-byte region [0x6020000004f0,0x602000000500)\nallocated by thread T0 here:\n    #6 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa 00 00\n=>0x0c047fff80a0:[fa]fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING\n\n\n\n\n\nclass Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        sort(nums.begin(),nums.end());\n\n        int comp=INT_MAX,n=nums.size(),res=0;\n        \n        for(int i=0; i<n-2; i++)\n        {\n            int j = i+1, k = n-1;\n\n            while(j<k)\n            {\n                int sum = nums[i]+nums[j]+nums[k];\n                if(comp > abs(sum-target))\n                {\n                    comp = abs(sum-target);\n                    res = sum;\n                }\n\n                if(sum < target)\n                {\n                    j++;\n                }\n                else if(sum > target)\n                {\n                    k--;\n                }\n                else\n                {\n                    return res;\n                }\n            }\n            while(nums[i+1] == nums[i] && i+1 < n) i++;\n        }\n        return res;\n    }\n};\n\n\nWhy am I getting this error?"
                    },
                    {
                        "username": "Himanshu_Singh11",
                        "content": "same error"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    }
                ]
            },
            {
                "id": 2039112,
                "content": [
                    {
                        "username": "hanzlasaqib2023",
                        "content": "How to know that this specific sum is closest number?"
                    },
                    {
                        "username": "cjdcoy",
                        "content": "can someone tell me the difference between \n1:\n`diff := abs(target - tmp)\n            if diff == 0 {\n                return tmp\n            }\n            if diff < minDiff {\n                minDiff = diff\n                closest = tmp\n            }`\n\nand 2:\n`diff := target - tmp\n            if diff == 0 {\n                return tmp\n            }\n            if abs(diff) < abs(minDiff) {\n                minDiff = diff\n                closest = tmp\n            }`\n\nI was stuck for a while using 1 and when I swtiched to 2 it worked but i don't understand why shouldn't they provide the same result ? @"
                    },
                    {
                        "username": "astra29",
                        "content": "instead comparing differences could we use\\nsum == target || sum == ++target || sum == --target\\nin if statement? what are your views???\\n"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "My time limit is exceeded for very large inputs ,can anyone suggest some amendments in my code so time should not be exceeded in large datasets."
                    },
                    {
                        "username": "apjo2009",
                        "content": "do we need to define for ourselves what \"closeness\" means? is there a threshold?"
                    },
                    {
                        "username": "vishal_2806",
                        "content": "//why i am not able to access that  threeSum[it] value\\n sort(threeSum.begin(),threeSum.end());\\n       auto it = lower_bound(threeSum.begin(),threeSum.end(),target) - threeSum.begin();\\n       cout<<it<<endl;\\n       cout<<threeSum[it]; ///only threeSum[0] will not showing the erroe other value will give me runtime erroe why\\n"
                    },
                    {
                        "username": "Jain0804",
                        "content": "for input  {1,1,1,1} and target 0 , why the output is coming 3 ?"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "imt2022073",
                        "content": "what should be the time complexity"
                    },
                    {
                        "username": "Blatogh",
                        "content": "A easy version of 15"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Can anyone say when will be target equals to output??"
                    },
                    {
                        "username": "manasi2510",
                        "content": "When sum of 3 integers will be equal to target value"
                    }
                ]
            },
            {
                "id": 2018257,
                "content": [
                    {
                        "username": "hanzlasaqib2023",
                        "content": "How to know that this specific sum is closest number?"
                    },
                    {
                        "username": "cjdcoy",
                        "content": "can someone tell me the difference between \n1:\n`diff := abs(target - tmp)\n            if diff == 0 {\n                return tmp\n            }\n            if diff < minDiff {\n                minDiff = diff\n                closest = tmp\n            }`\n\nand 2:\n`diff := target - tmp\n            if diff == 0 {\n                return tmp\n            }\n            if abs(diff) < abs(minDiff) {\n                minDiff = diff\n                closest = tmp\n            }`\n\nI was stuck for a while using 1 and when I swtiched to 2 it worked but i don't understand why shouldn't they provide the same result ? @"
                    },
                    {
                        "username": "astra29",
                        "content": "instead comparing differences could we use\\nsum == target || sum == ++target || sum == --target\\nin if statement? what are your views???\\n"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "My time limit is exceeded for very large inputs ,can anyone suggest some amendments in my code so time should not be exceeded in large datasets."
                    },
                    {
                        "username": "apjo2009",
                        "content": "do we need to define for ourselves what \"closeness\" means? is there a threshold?"
                    },
                    {
                        "username": "vishal_2806",
                        "content": "//why i am not able to access that  threeSum[it] value\\n sort(threeSum.begin(),threeSum.end());\\n       auto it = lower_bound(threeSum.begin(),threeSum.end(),target) - threeSum.begin();\\n       cout<<it<<endl;\\n       cout<<threeSum[it]; ///only threeSum[0] will not showing the erroe other value will give me runtime erroe why\\n"
                    },
                    {
                        "username": "Jain0804",
                        "content": "for input  {1,1,1,1} and target 0 , why the output is coming 3 ?"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "imt2022073",
                        "content": "what should be the time complexity"
                    },
                    {
                        "username": "Blatogh",
                        "content": "A easy version of 15"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Can anyone say when will be target equals to output??"
                    },
                    {
                        "username": "manasi2510",
                        "content": "When sum of 3 integers will be equal to target value"
                    }
                ]
            },
            {
                "id": 2008595,
                "content": [
                    {
                        "username": "hanzlasaqib2023",
                        "content": "How to know that this specific sum is closest number?"
                    },
                    {
                        "username": "cjdcoy",
                        "content": "can someone tell me the difference between \n1:\n`diff := abs(target - tmp)\n            if diff == 0 {\n                return tmp\n            }\n            if diff < minDiff {\n                minDiff = diff\n                closest = tmp\n            }`\n\nand 2:\n`diff := target - tmp\n            if diff == 0 {\n                return tmp\n            }\n            if abs(diff) < abs(minDiff) {\n                minDiff = diff\n                closest = tmp\n            }`\n\nI was stuck for a while using 1 and when I swtiched to 2 it worked but i don't understand why shouldn't they provide the same result ? @"
                    },
                    {
                        "username": "astra29",
                        "content": "instead comparing differences could we use\\nsum == target || sum == ++target || sum == --target\\nin if statement? what are your views???\\n"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "My time limit is exceeded for very large inputs ,can anyone suggest some amendments in my code so time should not be exceeded in large datasets."
                    },
                    {
                        "username": "apjo2009",
                        "content": "do we need to define for ourselves what \"closeness\" means? is there a threshold?"
                    },
                    {
                        "username": "vishal_2806",
                        "content": "//why i am not able to access that  threeSum[it] value\\n sort(threeSum.begin(),threeSum.end());\\n       auto it = lower_bound(threeSum.begin(),threeSum.end(),target) - threeSum.begin();\\n       cout<<it<<endl;\\n       cout<<threeSum[it]; ///only threeSum[0] will not showing the erroe other value will give me runtime erroe why\\n"
                    },
                    {
                        "username": "Jain0804",
                        "content": "for input  {1,1,1,1} and target 0 , why the output is coming 3 ?"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "imt2022073",
                        "content": "what should be the time complexity"
                    },
                    {
                        "username": "Blatogh",
                        "content": "A easy version of 15"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Can anyone say when will be target equals to output??"
                    },
                    {
                        "username": "manasi2510",
                        "content": "When sum of 3 integers will be equal to target value"
                    }
                ]
            },
            {
                "id": 2005976,
                "content": [
                    {
                        "username": "hanzlasaqib2023",
                        "content": "How to know that this specific sum is closest number?"
                    },
                    {
                        "username": "cjdcoy",
                        "content": "can someone tell me the difference between \n1:\n`diff := abs(target - tmp)\n            if diff == 0 {\n                return tmp\n            }\n            if diff < minDiff {\n                minDiff = diff\n                closest = tmp\n            }`\n\nand 2:\n`diff := target - tmp\n            if diff == 0 {\n                return tmp\n            }\n            if abs(diff) < abs(minDiff) {\n                minDiff = diff\n                closest = tmp\n            }`\n\nI was stuck for a while using 1 and when I swtiched to 2 it worked but i don't understand why shouldn't they provide the same result ? @"
                    },
                    {
                        "username": "astra29",
                        "content": "instead comparing differences could we use\\nsum == target || sum == ++target || sum == --target\\nin if statement? what are your views???\\n"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "My time limit is exceeded for very large inputs ,can anyone suggest some amendments in my code so time should not be exceeded in large datasets."
                    },
                    {
                        "username": "apjo2009",
                        "content": "do we need to define for ourselves what \"closeness\" means? is there a threshold?"
                    },
                    {
                        "username": "vishal_2806",
                        "content": "//why i am not able to access that  threeSum[it] value\\n sort(threeSum.begin(),threeSum.end());\\n       auto it = lower_bound(threeSum.begin(),threeSum.end(),target) - threeSum.begin();\\n       cout<<it<<endl;\\n       cout<<threeSum[it]; ///only threeSum[0] will not showing the erroe other value will give me runtime erroe why\\n"
                    },
                    {
                        "username": "Jain0804",
                        "content": "for input  {1,1,1,1} and target 0 , why the output is coming 3 ?"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "imt2022073",
                        "content": "what should be the time complexity"
                    },
                    {
                        "username": "Blatogh",
                        "content": "A easy version of 15"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Can anyone say when will be target equals to output??"
                    },
                    {
                        "username": "manasi2510",
                        "content": "When sum of 3 integers will be equal to target value"
                    }
                ]
            },
            {
                "id": 1975228,
                "content": [
                    {
                        "username": "hanzlasaqib2023",
                        "content": "How to know that this specific sum is closest number?"
                    },
                    {
                        "username": "cjdcoy",
                        "content": "can someone tell me the difference between \n1:\n`diff := abs(target - tmp)\n            if diff == 0 {\n                return tmp\n            }\n            if diff < minDiff {\n                minDiff = diff\n                closest = tmp\n            }`\n\nand 2:\n`diff := target - tmp\n            if diff == 0 {\n                return tmp\n            }\n            if abs(diff) < abs(minDiff) {\n                minDiff = diff\n                closest = tmp\n            }`\n\nI was stuck for a while using 1 and when I swtiched to 2 it worked but i don't understand why shouldn't they provide the same result ? @"
                    },
                    {
                        "username": "astra29",
                        "content": "instead comparing differences could we use\\nsum == target || sum == ++target || sum == --target\\nin if statement? what are your views???\\n"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "My time limit is exceeded for very large inputs ,can anyone suggest some amendments in my code so time should not be exceeded in large datasets."
                    },
                    {
                        "username": "apjo2009",
                        "content": "do we need to define for ourselves what \"closeness\" means? is there a threshold?"
                    },
                    {
                        "username": "vishal_2806",
                        "content": "//why i am not able to access that  threeSum[it] value\\n sort(threeSum.begin(),threeSum.end());\\n       auto it = lower_bound(threeSum.begin(),threeSum.end(),target) - threeSum.begin();\\n       cout<<it<<endl;\\n       cout<<threeSum[it]; ///only threeSum[0] will not showing the erroe other value will give me runtime erroe why\\n"
                    },
                    {
                        "username": "Jain0804",
                        "content": "for input  {1,1,1,1} and target 0 , why the output is coming 3 ?"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "imt2022073",
                        "content": "what should be the time complexity"
                    },
                    {
                        "username": "Blatogh",
                        "content": "A easy version of 15"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Can anyone say when will be target equals to output??"
                    },
                    {
                        "username": "manasi2510",
                        "content": "When sum of 3 integers will be equal to target value"
                    }
                ]
            },
            {
                "id": 1965422,
                "content": [
                    {
                        "username": "hanzlasaqib2023",
                        "content": "How to know that this specific sum is closest number?"
                    },
                    {
                        "username": "cjdcoy",
                        "content": "can someone tell me the difference between \n1:\n`diff := abs(target - tmp)\n            if diff == 0 {\n                return tmp\n            }\n            if diff < minDiff {\n                minDiff = diff\n                closest = tmp\n            }`\n\nand 2:\n`diff := target - tmp\n            if diff == 0 {\n                return tmp\n            }\n            if abs(diff) < abs(minDiff) {\n                minDiff = diff\n                closest = tmp\n            }`\n\nI was stuck for a while using 1 and when I swtiched to 2 it worked but i don't understand why shouldn't they provide the same result ? @"
                    },
                    {
                        "username": "astra29",
                        "content": "instead comparing differences could we use\\nsum == target || sum == ++target || sum == --target\\nin if statement? what are your views???\\n"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "My time limit is exceeded for very large inputs ,can anyone suggest some amendments in my code so time should not be exceeded in large datasets."
                    },
                    {
                        "username": "apjo2009",
                        "content": "do we need to define for ourselves what \"closeness\" means? is there a threshold?"
                    },
                    {
                        "username": "vishal_2806",
                        "content": "//why i am not able to access that  threeSum[it] value\\n sort(threeSum.begin(),threeSum.end());\\n       auto it = lower_bound(threeSum.begin(),threeSum.end(),target) - threeSum.begin();\\n       cout<<it<<endl;\\n       cout<<threeSum[it]; ///only threeSum[0] will not showing the erroe other value will give me runtime erroe why\\n"
                    },
                    {
                        "username": "Jain0804",
                        "content": "for input  {1,1,1,1} and target 0 , why the output is coming 3 ?"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "imt2022073",
                        "content": "what should be the time complexity"
                    },
                    {
                        "username": "Blatogh",
                        "content": "A easy version of 15"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Can anyone say when will be target equals to output??"
                    },
                    {
                        "username": "manasi2510",
                        "content": "When sum of 3 integers will be equal to target value"
                    }
                ]
            },
            {
                "id": 1902008,
                "content": [
                    {
                        "username": "hanzlasaqib2023",
                        "content": "How to know that this specific sum is closest number?"
                    },
                    {
                        "username": "cjdcoy",
                        "content": "can someone tell me the difference between \n1:\n`diff := abs(target - tmp)\n            if diff == 0 {\n                return tmp\n            }\n            if diff < minDiff {\n                minDiff = diff\n                closest = tmp\n            }`\n\nand 2:\n`diff := target - tmp\n            if diff == 0 {\n                return tmp\n            }\n            if abs(diff) < abs(minDiff) {\n                minDiff = diff\n                closest = tmp\n            }`\n\nI was stuck for a while using 1 and when I swtiched to 2 it worked but i don't understand why shouldn't they provide the same result ? @"
                    },
                    {
                        "username": "astra29",
                        "content": "instead comparing differences could we use\\nsum == target || sum == ++target || sum == --target\\nin if statement? what are your views???\\n"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "My time limit is exceeded for very large inputs ,can anyone suggest some amendments in my code so time should not be exceeded in large datasets."
                    },
                    {
                        "username": "apjo2009",
                        "content": "do we need to define for ourselves what \"closeness\" means? is there a threshold?"
                    },
                    {
                        "username": "vishal_2806",
                        "content": "//why i am not able to access that  threeSum[it] value\\n sort(threeSum.begin(),threeSum.end());\\n       auto it = lower_bound(threeSum.begin(),threeSum.end(),target) - threeSum.begin();\\n       cout<<it<<endl;\\n       cout<<threeSum[it]; ///only threeSum[0] will not showing the erroe other value will give me runtime erroe why\\n"
                    },
                    {
                        "username": "Jain0804",
                        "content": "for input  {1,1,1,1} and target 0 , why the output is coming 3 ?"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "imt2022073",
                        "content": "what should be the time complexity"
                    },
                    {
                        "username": "Blatogh",
                        "content": "A easy version of 15"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Can anyone say when will be target equals to output??"
                    },
                    {
                        "username": "manasi2510",
                        "content": "When sum of 3 integers will be equal to target value"
                    }
                ]
            },
            {
                "id": 1900256,
                "content": [
                    {
                        "username": "hanzlasaqib2023",
                        "content": "How to know that this specific sum is closest number?"
                    },
                    {
                        "username": "cjdcoy",
                        "content": "can someone tell me the difference between \n1:\n`diff := abs(target - tmp)\n            if diff == 0 {\n                return tmp\n            }\n            if diff < minDiff {\n                minDiff = diff\n                closest = tmp\n            }`\n\nand 2:\n`diff := target - tmp\n            if diff == 0 {\n                return tmp\n            }\n            if abs(diff) < abs(minDiff) {\n                minDiff = diff\n                closest = tmp\n            }`\n\nI was stuck for a while using 1 and when I swtiched to 2 it worked but i don't understand why shouldn't they provide the same result ? @"
                    },
                    {
                        "username": "astra29",
                        "content": "instead comparing differences could we use\\nsum == target || sum == ++target || sum == --target\\nin if statement? what are your views???\\n"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "My time limit is exceeded for very large inputs ,can anyone suggest some amendments in my code so time should not be exceeded in large datasets."
                    },
                    {
                        "username": "apjo2009",
                        "content": "do we need to define for ourselves what \"closeness\" means? is there a threshold?"
                    },
                    {
                        "username": "vishal_2806",
                        "content": "//why i am not able to access that  threeSum[it] value\\n sort(threeSum.begin(),threeSum.end());\\n       auto it = lower_bound(threeSum.begin(),threeSum.end(),target) - threeSum.begin();\\n       cout<<it<<endl;\\n       cout<<threeSum[it]; ///only threeSum[0] will not showing the erroe other value will give me runtime erroe why\\n"
                    },
                    {
                        "username": "Jain0804",
                        "content": "for input  {1,1,1,1} and target 0 , why the output is coming 3 ?"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "imt2022073",
                        "content": "what should be the time complexity"
                    },
                    {
                        "username": "Blatogh",
                        "content": "A easy version of 15"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Can anyone say when will be target equals to output??"
                    },
                    {
                        "username": "manasi2510",
                        "content": "When sum of 3 integers will be equal to target value"
                    }
                ]
            },
            {
                "id": 1898570,
                "content": [
                    {
                        "username": "hanzlasaqib2023",
                        "content": "How to know that this specific sum is closest number?"
                    },
                    {
                        "username": "cjdcoy",
                        "content": "can someone tell me the difference between \n1:\n`diff := abs(target - tmp)\n            if diff == 0 {\n                return tmp\n            }\n            if diff < minDiff {\n                minDiff = diff\n                closest = tmp\n            }`\n\nand 2:\n`diff := target - tmp\n            if diff == 0 {\n                return tmp\n            }\n            if abs(diff) < abs(minDiff) {\n                minDiff = diff\n                closest = tmp\n            }`\n\nI was stuck for a while using 1 and when I swtiched to 2 it worked but i don't understand why shouldn't they provide the same result ? @"
                    },
                    {
                        "username": "astra29",
                        "content": "instead comparing differences could we use\\nsum == target || sum == ++target || sum == --target\\nin if statement? what are your views???\\n"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "My time limit is exceeded for very large inputs ,can anyone suggest some amendments in my code so time should not be exceeded in large datasets."
                    },
                    {
                        "username": "apjo2009",
                        "content": "do we need to define for ourselves what \"closeness\" means? is there a threshold?"
                    },
                    {
                        "username": "vishal_2806",
                        "content": "//why i am not able to access that  threeSum[it] value\\n sort(threeSum.begin(),threeSum.end());\\n       auto it = lower_bound(threeSum.begin(),threeSum.end(),target) - threeSum.begin();\\n       cout<<it<<endl;\\n       cout<<threeSum[it]; ///only threeSum[0] will not showing the erroe other value will give me runtime erroe why\\n"
                    },
                    {
                        "username": "Jain0804",
                        "content": "for input  {1,1,1,1} and target 0 , why the output is coming 3 ?"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "imt2022073",
                        "content": "what should be the time complexity"
                    },
                    {
                        "username": "Blatogh",
                        "content": "A easy version of 15"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Can anyone say when will be target equals to output??"
                    },
                    {
                        "username": "manasi2510",
                        "content": "When sum of 3 integers will be equal to target value"
                    }
                ]
            },
            {
                "id": 1835746,
                "content": [
                    {
                        "username": "hanzlasaqib2023",
                        "content": "How to know that this specific sum is closest number?"
                    },
                    {
                        "username": "cjdcoy",
                        "content": "can someone tell me the difference between \n1:\n`diff := abs(target - tmp)\n            if diff == 0 {\n                return tmp\n            }\n            if diff < minDiff {\n                minDiff = diff\n                closest = tmp\n            }`\n\nand 2:\n`diff := target - tmp\n            if diff == 0 {\n                return tmp\n            }\n            if abs(diff) < abs(minDiff) {\n                minDiff = diff\n                closest = tmp\n            }`\n\nI was stuck for a while using 1 and when I swtiched to 2 it worked but i don't understand why shouldn't they provide the same result ? @"
                    },
                    {
                        "username": "astra29",
                        "content": "instead comparing differences could we use\\nsum == target || sum == ++target || sum == --target\\nin if statement? what are your views???\\n"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "My time limit is exceeded for very large inputs ,can anyone suggest some amendments in my code so time should not be exceeded in large datasets."
                    },
                    {
                        "username": "apjo2009",
                        "content": "do we need to define for ourselves what \"closeness\" means? is there a threshold?"
                    },
                    {
                        "username": "vishal_2806",
                        "content": "//why i am not able to access that  threeSum[it] value\\n sort(threeSum.begin(),threeSum.end());\\n       auto it = lower_bound(threeSum.begin(),threeSum.end(),target) - threeSum.begin();\\n       cout<<it<<endl;\\n       cout<<threeSum[it]; ///only threeSum[0] will not showing the erroe other value will give me runtime erroe why\\n"
                    },
                    {
                        "username": "Jain0804",
                        "content": "for input  {1,1,1,1} and target 0 , why the output is coming 3 ?"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "imt2022073",
                        "content": "what should be the time complexity"
                    },
                    {
                        "username": "Blatogh",
                        "content": "A easy version of 15"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Can anyone say when will be target equals to output??"
                    },
                    {
                        "username": "manasi2510",
                        "content": "When sum of 3 integers will be equal to target value"
                    }
                ]
            },
            {
                "id": 1819662,
                "content": [
                    {
                        "username": "Kinszs",
                        "content": "For this problem would the output be the closest number to the target? I would assume that 0 would be the closest number to 1 and not 2. "
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on my IDE but the Same Test Cases Fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on IDE but the same test cases fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "best beat 100%"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n\\n    \\nint threeSumClosest(vector<int>&nums,int target)\\n{\\n    sort(nums.begin(),nums.end());\\n\\n    int closedifff = INT_MAX;\\n    int closesum;\\n\\n    for(int i=0;i<nums.size()-2;i++)\\n    {\\n        int sum =0;\\n        int j=i+1,k=nums.size()-1;\\n        sum+=nums[i]+nums[j]+nums[k];\\n        \\n        while(j<k)\\n        {\\n            if(abs(sum-target)<closedifff)\\n            {\\n                closedifff = abs(sum-target);\\n                closesum=sum;\\n            }\\n            if(sum<target)\\n            {\\n                sum -=nums[j];\\n                j++;\\n                sum+=nums[j];\\n            }\\n            else if(sum > target){\\n                   sum -=nums[k];\\n                k--;\\n                sum+=nums[k];\\n            }\\n             else\\n             {\\n                 break;\\n             }\\n        }\\n    }\\n    return closesum;\\n\\n}\\n\\n    \\n};"
                    },
                    {
                        "username": "sanjaykumardas7399008072",
                        "content": "Procedure to Solve 3 Sum Closest\\n\\n1. Sort the array in ascending order\\n2. variables : arraySize, i, start, end, difference, temp, ans\\n3. i=0, difference = intMax\\n4. \\nwhile(i<arraySize) \\n{\\n____ start = i+1; end = arraySize-1;\\n____ while(start<end)\\n____ {\\n________ temp = arr[i] + arr[start]+arr[end];\\n________if( |target-temp| <difference)\\n________ {\\n____________ ans = temp;\\n____________ difference = |target-temp|\\n________ }\\n________ if(temp == target)\\n________ {\\n____________ return target\\n________ }\\n________ if(target<temp)\\n________ {\\n____________ end--;\\n________ }\\n________ else\\n________ {\\n____________ start ++\\n________ }\\n____ }\\n}\\nreturn ans;"
                    },
                    {
                        "username": "ankush920",
                        "content": "Best and easiest solution of this problem \\nS.C. =O(1) , T.C. =O(1)\\njust like 3sum problem :-\\nclass Solution {\\npublic:\\n\\n int mod (int a)\\n {\\n     if( a<0)\\n     {\\n          return (-a);\\n     }\\n\\n     return a;\\n  }\\n\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n\\n\\n         int ans =0 ;\\n         int minima= INT_MAX;\\n        int n =nums.size();\\n        int result=0;  \\n           \\n      sort(nums.begin() ,nums.end()); //sorting array to use two pointer approach \\n\\n\\n      for( int i = 0; i< n-1; i++)\\n      { \\n         \\n              \\n          int sum = nums[i];\\n           int p1 =i+1;\\n           int p2= n-1 ;\\n\\n         while(p1<p2)\\n          {\\n           \\n\\n            sum =nums[i]+nums[p1]+nums[p2];    \\n\\n            int diff =target-sum;\\n\\n             \\n             if(mod(diff) < mod(minima) )  /////for finding nearst greater or lower \\n             {\\n                \\n                 minima=diff;\\n                  result= sum;\\n             }\\n\\n            if(sum > target)\\n            {\\n                 p2--;\\n                 continue;\\n            }\\n\\n            if(sum <target )\\n            {\\n                p1++;\\n                continue;\\n            }\\n            \\n      \\n            ans++; ///// if the taget hit we return it \\n               p1++;\\n            p2--;\\n              break; \\n           \\n          }\\n     \\n\\n      }\\n\\n     if(! ans)\\n     {\\n          return result;\\n     }  \\n        \\n    \\n      return target;\\n      }\\n};"
                    },
                    {
                        "username": "08sahil_lamba",
                        "content": "\"I have recently solved a problem using the traditional two-pointer approach, but I am not satisfied with its time complexity of O(n^2). Can you please provide suggestions on how I can improve it?\"\\nThis is my solution : --->\\n `class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int ans = 0;\\n        int min = INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size(); i++){\\n            int start=i+1;\\n            int end = nums.size()-1;\\n            while(start < end){\\n                int sum = nums[i]+nums[start]+nums[end];\\n                if( abs(sum - target) < min ){\\n                    min = abs(sum - target);\\n                    ans = sum;\\n                    cout<<min<<\" \"<<ans<<endl;\\n                }\\n                if( sum == target )return sum;\\n                else if ( sum  < target )start++;\\n                else end--;\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "can someone tell the issue in my code , it is failing on input [-1,2,1,-4] target =1\\ncode:\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n         sort(nums.begin(),nums.end());\\n        int n1,n2,n3,gap=INT_MAX,t_gap,sum;\\n        int size = nums.size();\\n        int count =1;\\n        int i =0,j=1,k=2;\\n         n1= nums[i];\\n         n2= nums[j];\\n         n3= nums[k];\\n         sum = n1+n2+n3;\\n         int ans;\\n         t_gap= abs(target - sum);\\n         if (n1+n2+n3==target)\\n         {\\n             return target;\\n         }\\n        while(count<=size/2)\\n        {\\n            if (t_gap<gap)\\n            {\\n                gap = t_gap;\\n                ans= sum;\\n            }\\n            if(sum!=target)\\n            {\\n                while(k<=size-1)\\n                {\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    k++;\\n                }\\n                k=j+1;\\n                while(j<=size-1)\\n                {\\n                    if (j==k)\\n                    {\\n                        j++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    j++;\\n                }\\n                j=i+1;\\n                while(i<=size-1)\\n                {\\n                    if (i==j || i==k)\\n                    {\\n                        i++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    i++;\\n                }\\n                i=j-1;\\n                count++;\\n                i++;\\n                j++;\\n                k++;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sachingg",
                        "content": "1) How is difference counted. Is it on the number Line or by Actual subtraction\\nfor eg. if target is 1 and 2 diffs are -1 and 5. Which is closest\\n\\n2) How should the difference be calculated. target-sum or sum-target"
                    }
                ]
            },
            {
                "id": 1807387,
                "content": [
                    {
                        "username": "Kinszs",
                        "content": "For this problem would the output be the closest number to the target? I would assume that 0 would be the closest number to 1 and not 2. "
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on my IDE but the Same Test Cases Fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on IDE but the same test cases fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "best beat 100%"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n\\n    \\nint threeSumClosest(vector<int>&nums,int target)\\n{\\n    sort(nums.begin(),nums.end());\\n\\n    int closedifff = INT_MAX;\\n    int closesum;\\n\\n    for(int i=0;i<nums.size()-2;i++)\\n    {\\n        int sum =0;\\n        int j=i+1,k=nums.size()-1;\\n        sum+=nums[i]+nums[j]+nums[k];\\n        \\n        while(j<k)\\n        {\\n            if(abs(sum-target)<closedifff)\\n            {\\n                closedifff = abs(sum-target);\\n                closesum=sum;\\n            }\\n            if(sum<target)\\n            {\\n                sum -=nums[j];\\n                j++;\\n                sum+=nums[j];\\n            }\\n            else if(sum > target){\\n                   sum -=nums[k];\\n                k--;\\n                sum+=nums[k];\\n            }\\n             else\\n             {\\n                 break;\\n             }\\n        }\\n    }\\n    return closesum;\\n\\n}\\n\\n    \\n};"
                    },
                    {
                        "username": "sanjaykumardas7399008072",
                        "content": "Procedure to Solve 3 Sum Closest\\n\\n1. Sort the array in ascending order\\n2. variables : arraySize, i, start, end, difference, temp, ans\\n3. i=0, difference = intMax\\n4. \\nwhile(i<arraySize) \\n{\\n____ start = i+1; end = arraySize-1;\\n____ while(start<end)\\n____ {\\n________ temp = arr[i] + arr[start]+arr[end];\\n________if( |target-temp| <difference)\\n________ {\\n____________ ans = temp;\\n____________ difference = |target-temp|\\n________ }\\n________ if(temp == target)\\n________ {\\n____________ return target\\n________ }\\n________ if(target<temp)\\n________ {\\n____________ end--;\\n________ }\\n________ else\\n________ {\\n____________ start ++\\n________ }\\n____ }\\n}\\nreturn ans;"
                    },
                    {
                        "username": "ankush920",
                        "content": "Best and easiest solution of this problem \\nS.C. =O(1) , T.C. =O(1)\\njust like 3sum problem :-\\nclass Solution {\\npublic:\\n\\n int mod (int a)\\n {\\n     if( a<0)\\n     {\\n          return (-a);\\n     }\\n\\n     return a;\\n  }\\n\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n\\n\\n         int ans =0 ;\\n         int minima= INT_MAX;\\n        int n =nums.size();\\n        int result=0;  \\n           \\n      sort(nums.begin() ,nums.end()); //sorting array to use two pointer approach \\n\\n\\n      for( int i = 0; i< n-1; i++)\\n      { \\n         \\n              \\n          int sum = nums[i];\\n           int p1 =i+1;\\n           int p2= n-1 ;\\n\\n         while(p1<p2)\\n          {\\n           \\n\\n            sum =nums[i]+nums[p1]+nums[p2];    \\n\\n            int diff =target-sum;\\n\\n             \\n             if(mod(diff) < mod(minima) )  /////for finding nearst greater or lower \\n             {\\n                \\n                 minima=diff;\\n                  result= sum;\\n             }\\n\\n            if(sum > target)\\n            {\\n                 p2--;\\n                 continue;\\n            }\\n\\n            if(sum <target )\\n            {\\n                p1++;\\n                continue;\\n            }\\n            \\n      \\n            ans++; ///// if the taget hit we return it \\n               p1++;\\n            p2--;\\n              break; \\n           \\n          }\\n     \\n\\n      }\\n\\n     if(! ans)\\n     {\\n          return result;\\n     }  \\n        \\n    \\n      return target;\\n      }\\n};"
                    },
                    {
                        "username": "08sahil_lamba",
                        "content": "\"I have recently solved a problem using the traditional two-pointer approach, but I am not satisfied with its time complexity of O(n^2). Can you please provide suggestions on how I can improve it?\"\\nThis is my solution : --->\\n `class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int ans = 0;\\n        int min = INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size(); i++){\\n            int start=i+1;\\n            int end = nums.size()-1;\\n            while(start < end){\\n                int sum = nums[i]+nums[start]+nums[end];\\n                if( abs(sum - target) < min ){\\n                    min = abs(sum - target);\\n                    ans = sum;\\n                    cout<<min<<\" \"<<ans<<endl;\\n                }\\n                if( sum == target )return sum;\\n                else if ( sum  < target )start++;\\n                else end--;\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "can someone tell the issue in my code , it is failing on input [-1,2,1,-4] target =1\\ncode:\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n         sort(nums.begin(),nums.end());\\n        int n1,n2,n3,gap=INT_MAX,t_gap,sum;\\n        int size = nums.size();\\n        int count =1;\\n        int i =0,j=1,k=2;\\n         n1= nums[i];\\n         n2= nums[j];\\n         n3= nums[k];\\n         sum = n1+n2+n3;\\n         int ans;\\n         t_gap= abs(target - sum);\\n         if (n1+n2+n3==target)\\n         {\\n             return target;\\n         }\\n        while(count<=size/2)\\n        {\\n            if (t_gap<gap)\\n            {\\n                gap = t_gap;\\n                ans= sum;\\n            }\\n            if(sum!=target)\\n            {\\n                while(k<=size-1)\\n                {\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    k++;\\n                }\\n                k=j+1;\\n                while(j<=size-1)\\n                {\\n                    if (j==k)\\n                    {\\n                        j++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    j++;\\n                }\\n                j=i+1;\\n                while(i<=size-1)\\n                {\\n                    if (i==j || i==k)\\n                    {\\n                        i++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    i++;\\n                }\\n                i=j-1;\\n                count++;\\n                i++;\\n                j++;\\n                k++;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sachingg",
                        "content": "1) How is difference counted. Is it on the number Line or by Actual subtraction\\nfor eg. if target is 1 and 2 diffs are -1 and 5. Which is closest\\n\\n2) How should the difference be calculated. target-sum or sum-target"
                    }
                ]
            },
            {
                "id": 1807374,
                "content": [
                    {
                        "username": "Kinszs",
                        "content": "For this problem would the output be the closest number to the target? I would assume that 0 would be the closest number to 1 and not 2. "
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on my IDE but the Same Test Cases Fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on IDE but the same test cases fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "best beat 100%"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n\\n    \\nint threeSumClosest(vector<int>&nums,int target)\\n{\\n    sort(nums.begin(),nums.end());\\n\\n    int closedifff = INT_MAX;\\n    int closesum;\\n\\n    for(int i=0;i<nums.size()-2;i++)\\n    {\\n        int sum =0;\\n        int j=i+1,k=nums.size()-1;\\n        sum+=nums[i]+nums[j]+nums[k];\\n        \\n        while(j<k)\\n        {\\n            if(abs(sum-target)<closedifff)\\n            {\\n                closedifff = abs(sum-target);\\n                closesum=sum;\\n            }\\n            if(sum<target)\\n            {\\n                sum -=nums[j];\\n                j++;\\n                sum+=nums[j];\\n            }\\n            else if(sum > target){\\n                   sum -=nums[k];\\n                k--;\\n                sum+=nums[k];\\n            }\\n             else\\n             {\\n                 break;\\n             }\\n        }\\n    }\\n    return closesum;\\n\\n}\\n\\n    \\n};"
                    },
                    {
                        "username": "sanjaykumardas7399008072",
                        "content": "Procedure to Solve 3 Sum Closest\\n\\n1. Sort the array in ascending order\\n2. variables : arraySize, i, start, end, difference, temp, ans\\n3. i=0, difference = intMax\\n4. \\nwhile(i<arraySize) \\n{\\n____ start = i+1; end = arraySize-1;\\n____ while(start<end)\\n____ {\\n________ temp = arr[i] + arr[start]+arr[end];\\n________if( |target-temp| <difference)\\n________ {\\n____________ ans = temp;\\n____________ difference = |target-temp|\\n________ }\\n________ if(temp == target)\\n________ {\\n____________ return target\\n________ }\\n________ if(target<temp)\\n________ {\\n____________ end--;\\n________ }\\n________ else\\n________ {\\n____________ start ++\\n________ }\\n____ }\\n}\\nreturn ans;"
                    },
                    {
                        "username": "ankush920",
                        "content": "Best and easiest solution of this problem \\nS.C. =O(1) , T.C. =O(1)\\njust like 3sum problem :-\\nclass Solution {\\npublic:\\n\\n int mod (int a)\\n {\\n     if( a<0)\\n     {\\n          return (-a);\\n     }\\n\\n     return a;\\n  }\\n\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n\\n\\n         int ans =0 ;\\n         int minima= INT_MAX;\\n        int n =nums.size();\\n        int result=0;  \\n           \\n      sort(nums.begin() ,nums.end()); //sorting array to use two pointer approach \\n\\n\\n      for( int i = 0; i< n-1; i++)\\n      { \\n         \\n              \\n          int sum = nums[i];\\n           int p1 =i+1;\\n           int p2= n-1 ;\\n\\n         while(p1<p2)\\n          {\\n           \\n\\n            sum =nums[i]+nums[p1]+nums[p2];    \\n\\n            int diff =target-sum;\\n\\n             \\n             if(mod(diff) < mod(minima) )  /////for finding nearst greater or lower \\n             {\\n                \\n                 minima=diff;\\n                  result= sum;\\n             }\\n\\n            if(sum > target)\\n            {\\n                 p2--;\\n                 continue;\\n            }\\n\\n            if(sum <target )\\n            {\\n                p1++;\\n                continue;\\n            }\\n            \\n      \\n            ans++; ///// if the taget hit we return it \\n               p1++;\\n            p2--;\\n              break; \\n           \\n          }\\n     \\n\\n      }\\n\\n     if(! ans)\\n     {\\n          return result;\\n     }  \\n        \\n    \\n      return target;\\n      }\\n};"
                    },
                    {
                        "username": "08sahil_lamba",
                        "content": "\"I have recently solved a problem using the traditional two-pointer approach, but I am not satisfied with its time complexity of O(n^2). Can you please provide suggestions on how I can improve it?\"\\nThis is my solution : --->\\n `class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int ans = 0;\\n        int min = INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size(); i++){\\n            int start=i+1;\\n            int end = nums.size()-1;\\n            while(start < end){\\n                int sum = nums[i]+nums[start]+nums[end];\\n                if( abs(sum - target) < min ){\\n                    min = abs(sum - target);\\n                    ans = sum;\\n                    cout<<min<<\" \"<<ans<<endl;\\n                }\\n                if( sum == target )return sum;\\n                else if ( sum  < target )start++;\\n                else end--;\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "can someone tell the issue in my code , it is failing on input [-1,2,1,-4] target =1\\ncode:\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n         sort(nums.begin(),nums.end());\\n        int n1,n2,n3,gap=INT_MAX,t_gap,sum;\\n        int size = nums.size();\\n        int count =1;\\n        int i =0,j=1,k=2;\\n         n1= nums[i];\\n         n2= nums[j];\\n         n3= nums[k];\\n         sum = n1+n2+n3;\\n         int ans;\\n         t_gap= abs(target - sum);\\n         if (n1+n2+n3==target)\\n         {\\n             return target;\\n         }\\n        while(count<=size/2)\\n        {\\n            if (t_gap<gap)\\n            {\\n                gap = t_gap;\\n                ans= sum;\\n            }\\n            if(sum!=target)\\n            {\\n                while(k<=size-1)\\n                {\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    k++;\\n                }\\n                k=j+1;\\n                while(j<=size-1)\\n                {\\n                    if (j==k)\\n                    {\\n                        j++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    j++;\\n                }\\n                j=i+1;\\n                while(i<=size-1)\\n                {\\n                    if (i==j || i==k)\\n                    {\\n                        i++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    i++;\\n                }\\n                i=j-1;\\n                count++;\\n                i++;\\n                j++;\\n                k++;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sachingg",
                        "content": "1) How is difference counted. Is it on the number Line or by Actual subtraction\\nfor eg. if target is 1 and 2 diffs are -1 and 5. Which is closest\\n\\n2) How should the difference be calculated. target-sum or sum-target"
                    }
                ]
            },
            {
                "id": 1798513,
                "content": [
                    {
                        "username": "Kinszs",
                        "content": "For this problem would the output be the closest number to the target? I would assume that 0 would be the closest number to 1 and not 2. "
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on my IDE but the Same Test Cases Fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on IDE but the same test cases fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "best beat 100%"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n\\n    \\nint threeSumClosest(vector<int>&nums,int target)\\n{\\n    sort(nums.begin(),nums.end());\\n\\n    int closedifff = INT_MAX;\\n    int closesum;\\n\\n    for(int i=0;i<nums.size()-2;i++)\\n    {\\n        int sum =0;\\n        int j=i+1,k=nums.size()-1;\\n        sum+=nums[i]+nums[j]+nums[k];\\n        \\n        while(j<k)\\n        {\\n            if(abs(sum-target)<closedifff)\\n            {\\n                closedifff = abs(sum-target);\\n                closesum=sum;\\n            }\\n            if(sum<target)\\n            {\\n                sum -=nums[j];\\n                j++;\\n                sum+=nums[j];\\n            }\\n            else if(sum > target){\\n                   sum -=nums[k];\\n                k--;\\n                sum+=nums[k];\\n            }\\n             else\\n             {\\n                 break;\\n             }\\n        }\\n    }\\n    return closesum;\\n\\n}\\n\\n    \\n};"
                    },
                    {
                        "username": "sanjaykumardas7399008072",
                        "content": "Procedure to Solve 3 Sum Closest\\n\\n1. Sort the array in ascending order\\n2. variables : arraySize, i, start, end, difference, temp, ans\\n3. i=0, difference = intMax\\n4. \\nwhile(i<arraySize) \\n{\\n____ start = i+1; end = arraySize-1;\\n____ while(start<end)\\n____ {\\n________ temp = arr[i] + arr[start]+arr[end];\\n________if( |target-temp| <difference)\\n________ {\\n____________ ans = temp;\\n____________ difference = |target-temp|\\n________ }\\n________ if(temp == target)\\n________ {\\n____________ return target\\n________ }\\n________ if(target<temp)\\n________ {\\n____________ end--;\\n________ }\\n________ else\\n________ {\\n____________ start ++\\n________ }\\n____ }\\n}\\nreturn ans;"
                    },
                    {
                        "username": "ankush920",
                        "content": "Best and easiest solution of this problem \\nS.C. =O(1) , T.C. =O(1)\\njust like 3sum problem :-\\nclass Solution {\\npublic:\\n\\n int mod (int a)\\n {\\n     if( a<0)\\n     {\\n          return (-a);\\n     }\\n\\n     return a;\\n  }\\n\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n\\n\\n         int ans =0 ;\\n         int minima= INT_MAX;\\n        int n =nums.size();\\n        int result=0;  \\n           \\n      sort(nums.begin() ,nums.end()); //sorting array to use two pointer approach \\n\\n\\n      for( int i = 0; i< n-1; i++)\\n      { \\n         \\n              \\n          int sum = nums[i];\\n           int p1 =i+1;\\n           int p2= n-1 ;\\n\\n         while(p1<p2)\\n          {\\n           \\n\\n            sum =nums[i]+nums[p1]+nums[p2];    \\n\\n            int diff =target-sum;\\n\\n             \\n             if(mod(diff) < mod(minima) )  /////for finding nearst greater or lower \\n             {\\n                \\n                 minima=diff;\\n                  result= sum;\\n             }\\n\\n            if(sum > target)\\n            {\\n                 p2--;\\n                 continue;\\n            }\\n\\n            if(sum <target )\\n            {\\n                p1++;\\n                continue;\\n            }\\n            \\n      \\n            ans++; ///// if the taget hit we return it \\n               p1++;\\n            p2--;\\n              break; \\n           \\n          }\\n     \\n\\n      }\\n\\n     if(! ans)\\n     {\\n          return result;\\n     }  \\n        \\n    \\n      return target;\\n      }\\n};"
                    },
                    {
                        "username": "08sahil_lamba",
                        "content": "\"I have recently solved a problem using the traditional two-pointer approach, but I am not satisfied with its time complexity of O(n^2). Can you please provide suggestions on how I can improve it?\"\\nThis is my solution : --->\\n `class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int ans = 0;\\n        int min = INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size(); i++){\\n            int start=i+1;\\n            int end = nums.size()-1;\\n            while(start < end){\\n                int sum = nums[i]+nums[start]+nums[end];\\n                if( abs(sum - target) < min ){\\n                    min = abs(sum - target);\\n                    ans = sum;\\n                    cout<<min<<\" \"<<ans<<endl;\\n                }\\n                if( sum == target )return sum;\\n                else if ( sum  < target )start++;\\n                else end--;\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "can someone tell the issue in my code , it is failing on input [-1,2,1,-4] target =1\\ncode:\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n         sort(nums.begin(),nums.end());\\n        int n1,n2,n3,gap=INT_MAX,t_gap,sum;\\n        int size = nums.size();\\n        int count =1;\\n        int i =0,j=1,k=2;\\n         n1= nums[i];\\n         n2= nums[j];\\n         n3= nums[k];\\n         sum = n1+n2+n3;\\n         int ans;\\n         t_gap= abs(target - sum);\\n         if (n1+n2+n3==target)\\n         {\\n             return target;\\n         }\\n        while(count<=size/2)\\n        {\\n            if (t_gap<gap)\\n            {\\n                gap = t_gap;\\n                ans= sum;\\n            }\\n            if(sum!=target)\\n            {\\n                while(k<=size-1)\\n                {\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    k++;\\n                }\\n                k=j+1;\\n                while(j<=size-1)\\n                {\\n                    if (j==k)\\n                    {\\n                        j++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    j++;\\n                }\\n                j=i+1;\\n                while(i<=size-1)\\n                {\\n                    if (i==j || i==k)\\n                    {\\n                        i++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    i++;\\n                }\\n                i=j-1;\\n                count++;\\n                i++;\\n                j++;\\n                k++;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sachingg",
                        "content": "1) How is difference counted. Is it on the number Line or by Actual subtraction\\nfor eg. if target is 1 and 2 diffs are -1 and 5. Which is closest\\n\\n2) How should the difference be calculated. target-sum or sum-target"
                    }
                ]
            },
            {
                "id": 1798512,
                "content": [
                    {
                        "username": "Kinszs",
                        "content": "For this problem would the output be the closest number to the target? I would assume that 0 would be the closest number to 1 and not 2. "
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on my IDE but the Same Test Cases Fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on IDE but the same test cases fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "best beat 100%"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n\\n    \\nint threeSumClosest(vector<int>&nums,int target)\\n{\\n    sort(nums.begin(),nums.end());\\n\\n    int closedifff = INT_MAX;\\n    int closesum;\\n\\n    for(int i=0;i<nums.size()-2;i++)\\n    {\\n        int sum =0;\\n        int j=i+1,k=nums.size()-1;\\n        sum+=nums[i]+nums[j]+nums[k];\\n        \\n        while(j<k)\\n        {\\n            if(abs(sum-target)<closedifff)\\n            {\\n                closedifff = abs(sum-target);\\n                closesum=sum;\\n            }\\n            if(sum<target)\\n            {\\n                sum -=nums[j];\\n                j++;\\n                sum+=nums[j];\\n            }\\n            else if(sum > target){\\n                   sum -=nums[k];\\n                k--;\\n                sum+=nums[k];\\n            }\\n             else\\n             {\\n                 break;\\n             }\\n        }\\n    }\\n    return closesum;\\n\\n}\\n\\n    \\n};"
                    },
                    {
                        "username": "sanjaykumardas7399008072",
                        "content": "Procedure to Solve 3 Sum Closest\\n\\n1. Sort the array in ascending order\\n2. variables : arraySize, i, start, end, difference, temp, ans\\n3. i=0, difference = intMax\\n4. \\nwhile(i<arraySize) \\n{\\n____ start = i+1; end = arraySize-1;\\n____ while(start<end)\\n____ {\\n________ temp = arr[i] + arr[start]+arr[end];\\n________if( |target-temp| <difference)\\n________ {\\n____________ ans = temp;\\n____________ difference = |target-temp|\\n________ }\\n________ if(temp == target)\\n________ {\\n____________ return target\\n________ }\\n________ if(target<temp)\\n________ {\\n____________ end--;\\n________ }\\n________ else\\n________ {\\n____________ start ++\\n________ }\\n____ }\\n}\\nreturn ans;"
                    },
                    {
                        "username": "ankush920",
                        "content": "Best and easiest solution of this problem \\nS.C. =O(1) , T.C. =O(1)\\njust like 3sum problem :-\\nclass Solution {\\npublic:\\n\\n int mod (int a)\\n {\\n     if( a<0)\\n     {\\n          return (-a);\\n     }\\n\\n     return a;\\n  }\\n\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n\\n\\n         int ans =0 ;\\n         int minima= INT_MAX;\\n        int n =nums.size();\\n        int result=0;  \\n           \\n      sort(nums.begin() ,nums.end()); //sorting array to use two pointer approach \\n\\n\\n      for( int i = 0; i< n-1; i++)\\n      { \\n         \\n              \\n          int sum = nums[i];\\n           int p1 =i+1;\\n           int p2= n-1 ;\\n\\n         while(p1<p2)\\n          {\\n           \\n\\n            sum =nums[i]+nums[p1]+nums[p2];    \\n\\n            int diff =target-sum;\\n\\n             \\n             if(mod(diff) < mod(minima) )  /////for finding nearst greater or lower \\n             {\\n                \\n                 minima=diff;\\n                  result= sum;\\n             }\\n\\n            if(sum > target)\\n            {\\n                 p2--;\\n                 continue;\\n            }\\n\\n            if(sum <target )\\n            {\\n                p1++;\\n                continue;\\n            }\\n            \\n      \\n            ans++; ///// if the taget hit we return it \\n               p1++;\\n            p2--;\\n              break; \\n           \\n          }\\n     \\n\\n      }\\n\\n     if(! ans)\\n     {\\n          return result;\\n     }  \\n        \\n    \\n      return target;\\n      }\\n};"
                    },
                    {
                        "username": "08sahil_lamba",
                        "content": "\"I have recently solved a problem using the traditional two-pointer approach, but I am not satisfied with its time complexity of O(n^2). Can you please provide suggestions on how I can improve it?\"\\nThis is my solution : --->\\n `class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int ans = 0;\\n        int min = INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size(); i++){\\n            int start=i+1;\\n            int end = nums.size()-1;\\n            while(start < end){\\n                int sum = nums[i]+nums[start]+nums[end];\\n                if( abs(sum - target) < min ){\\n                    min = abs(sum - target);\\n                    ans = sum;\\n                    cout<<min<<\" \"<<ans<<endl;\\n                }\\n                if( sum == target )return sum;\\n                else if ( sum  < target )start++;\\n                else end--;\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "can someone tell the issue in my code , it is failing on input [-1,2,1,-4] target =1\\ncode:\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n         sort(nums.begin(),nums.end());\\n        int n1,n2,n3,gap=INT_MAX,t_gap,sum;\\n        int size = nums.size();\\n        int count =1;\\n        int i =0,j=1,k=2;\\n         n1= nums[i];\\n         n2= nums[j];\\n         n3= nums[k];\\n         sum = n1+n2+n3;\\n         int ans;\\n         t_gap= abs(target - sum);\\n         if (n1+n2+n3==target)\\n         {\\n             return target;\\n         }\\n        while(count<=size/2)\\n        {\\n            if (t_gap<gap)\\n            {\\n                gap = t_gap;\\n                ans= sum;\\n            }\\n            if(sum!=target)\\n            {\\n                while(k<=size-1)\\n                {\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    k++;\\n                }\\n                k=j+1;\\n                while(j<=size-1)\\n                {\\n                    if (j==k)\\n                    {\\n                        j++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    j++;\\n                }\\n                j=i+1;\\n                while(i<=size-1)\\n                {\\n                    if (i==j || i==k)\\n                    {\\n                        i++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    i++;\\n                }\\n                i=j-1;\\n                count++;\\n                i++;\\n                j++;\\n                k++;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sachingg",
                        "content": "1) How is difference counted. Is it on the number Line or by Actual subtraction\\nfor eg. if target is 1 and 2 diffs are -1 and 5. Which is closest\\n\\n2) How should the difference be calculated. target-sum or sum-target"
                    }
                ]
            },
            {
                "id": 1797041,
                "content": [
                    {
                        "username": "Kinszs",
                        "content": "For this problem would the output be the closest number to the target? I would assume that 0 would be the closest number to 1 and not 2. "
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on my IDE but the Same Test Cases Fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on IDE but the same test cases fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "best beat 100%"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n\\n    \\nint threeSumClosest(vector<int>&nums,int target)\\n{\\n    sort(nums.begin(),nums.end());\\n\\n    int closedifff = INT_MAX;\\n    int closesum;\\n\\n    for(int i=0;i<nums.size()-2;i++)\\n    {\\n        int sum =0;\\n        int j=i+1,k=nums.size()-1;\\n        sum+=nums[i]+nums[j]+nums[k];\\n        \\n        while(j<k)\\n        {\\n            if(abs(sum-target)<closedifff)\\n            {\\n                closedifff = abs(sum-target);\\n                closesum=sum;\\n            }\\n            if(sum<target)\\n            {\\n                sum -=nums[j];\\n                j++;\\n                sum+=nums[j];\\n            }\\n            else if(sum > target){\\n                   sum -=nums[k];\\n                k--;\\n                sum+=nums[k];\\n            }\\n             else\\n             {\\n                 break;\\n             }\\n        }\\n    }\\n    return closesum;\\n\\n}\\n\\n    \\n};"
                    },
                    {
                        "username": "sanjaykumardas7399008072",
                        "content": "Procedure to Solve 3 Sum Closest\\n\\n1. Sort the array in ascending order\\n2. variables : arraySize, i, start, end, difference, temp, ans\\n3. i=0, difference = intMax\\n4. \\nwhile(i<arraySize) \\n{\\n____ start = i+1; end = arraySize-1;\\n____ while(start<end)\\n____ {\\n________ temp = arr[i] + arr[start]+arr[end];\\n________if( |target-temp| <difference)\\n________ {\\n____________ ans = temp;\\n____________ difference = |target-temp|\\n________ }\\n________ if(temp == target)\\n________ {\\n____________ return target\\n________ }\\n________ if(target<temp)\\n________ {\\n____________ end--;\\n________ }\\n________ else\\n________ {\\n____________ start ++\\n________ }\\n____ }\\n}\\nreturn ans;"
                    },
                    {
                        "username": "ankush920",
                        "content": "Best and easiest solution of this problem \\nS.C. =O(1) , T.C. =O(1)\\njust like 3sum problem :-\\nclass Solution {\\npublic:\\n\\n int mod (int a)\\n {\\n     if( a<0)\\n     {\\n          return (-a);\\n     }\\n\\n     return a;\\n  }\\n\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n\\n\\n         int ans =0 ;\\n         int minima= INT_MAX;\\n        int n =nums.size();\\n        int result=0;  \\n           \\n      sort(nums.begin() ,nums.end()); //sorting array to use two pointer approach \\n\\n\\n      for( int i = 0; i< n-1; i++)\\n      { \\n         \\n              \\n          int sum = nums[i];\\n           int p1 =i+1;\\n           int p2= n-1 ;\\n\\n         while(p1<p2)\\n          {\\n           \\n\\n            sum =nums[i]+nums[p1]+nums[p2];    \\n\\n            int diff =target-sum;\\n\\n             \\n             if(mod(diff) < mod(minima) )  /////for finding nearst greater or lower \\n             {\\n                \\n                 minima=diff;\\n                  result= sum;\\n             }\\n\\n            if(sum > target)\\n            {\\n                 p2--;\\n                 continue;\\n            }\\n\\n            if(sum <target )\\n            {\\n                p1++;\\n                continue;\\n            }\\n            \\n      \\n            ans++; ///// if the taget hit we return it \\n               p1++;\\n            p2--;\\n              break; \\n           \\n          }\\n     \\n\\n      }\\n\\n     if(! ans)\\n     {\\n          return result;\\n     }  \\n        \\n    \\n      return target;\\n      }\\n};"
                    },
                    {
                        "username": "08sahil_lamba",
                        "content": "\"I have recently solved a problem using the traditional two-pointer approach, but I am not satisfied with its time complexity of O(n^2). Can you please provide suggestions on how I can improve it?\"\\nThis is my solution : --->\\n `class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int ans = 0;\\n        int min = INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size(); i++){\\n            int start=i+1;\\n            int end = nums.size()-1;\\n            while(start < end){\\n                int sum = nums[i]+nums[start]+nums[end];\\n                if( abs(sum - target) < min ){\\n                    min = abs(sum - target);\\n                    ans = sum;\\n                    cout<<min<<\" \"<<ans<<endl;\\n                }\\n                if( sum == target )return sum;\\n                else if ( sum  < target )start++;\\n                else end--;\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "can someone tell the issue in my code , it is failing on input [-1,2,1,-4] target =1\\ncode:\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n         sort(nums.begin(),nums.end());\\n        int n1,n2,n3,gap=INT_MAX,t_gap,sum;\\n        int size = nums.size();\\n        int count =1;\\n        int i =0,j=1,k=2;\\n         n1= nums[i];\\n         n2= nums[j];\\n         n3= nums[k];\\n         sum = n1+n2+n3;\\n         int ans;\\n         t_gap= abs(target - sum);\\n         if (n1+n2+n3==target)\\n         {\\n             return target;\\n         }\\n        while(count<=size/2)\\n        {\\n            if (t_gap<gap)\\n            {\\n                gap = t_gap;\\n                ans= sum;\\n            }\\n            if(sum!=target)\\n            {\\n                while(k<=size-1)\\n                {\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    k++;\\n                }\\n                k=j+1;\\n                while(j<=size-1)\\n                {\\n                    if (j==k)\\n                    {\\n                        j++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    j++;\\n                }\\n                j=i+1;\\n                while(i<=size-1)\\n                {\\n                    if (i==j || i==k)\\n                    {\\n                        i++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    i++;\\n                }\\n                i=j-1;\\n                count++;\\n                i++;\\n                j++;\\n                k++;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sachingg",
                        "content": "1) How is difference counted. Is it on the number Line or by Actual subtraction\\nfor eg. if target is 1 and 2 diffs are -1 and 5. Which is closest\\n\\n2) How should the difference be calculated. target-sum or sum-target"
                    }
                ]
            },
            {
                "id": 1779724,
                "content": [
                    {
                        "username": "Kinszs",
                        "content": "For this problem would the output be the closest number to the target? I would assume that 0 would be the closest number to 1 and not 2. "
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on my IDE but the Same Test Cases Fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on IDE but the same test cases fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "best beat 100%"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n\\n    \\nint threeSumClosest(vector<int>&nums,int target)\\n{\\n    sort(nums.begin(),nums.end());\\n\\n    int closedifff = INT_MAX;\\n    int closesum;\\n\\n    for(int i=0;i<nums.size()-2;i++)\\n    {\\n        int sum =0;\\n        int j=i+1,k=nums.size()-1;\\n        sum+=nums[i]+nums[j]+nums[k];\\n        \\n        while(j<k)\\n        {\\n            if(abs(sum-target)<closedifff)\\n            {\\n                closedifff = abs(sum-target);\\n                closesum=sum;\\n            }\\n            if(sum<target)\\n            {\\n                sum -=nums[j];\\n                j++;\\n                sum+=nums[j];\\n            }\\n            else if(sum > target){\\n                   sum -=nums[k];\\n                k--;\\n                sum+=nums[k];\\n            }\\n             else\\n             {\\n                 break;\\n             }\\n        }\\n    }\\n    return closesum;\\n\\n}\\n\\n    \\n};"
                    },
                    {
                        "username": "sanjaykumardas7399008072",
                        "content": "Procedure to Solve 3 Sum Closest\\n\\n1. Sort the array in ascending order\\n2. variables : arraySize, i, start, end, difference, temp, ans\\n3. i=0, difference = intMax\\n4. \\nwhile(i<arraySize) \\n{\\n____ start = i+1; end = arraySize-1;\\n____ while(start<end)\\n____ {\\n________ temp = arr[i] + arr[start]+arr[end];\\n________if( |target-temp| <difference)\\n________ {\\n____________ ans = temp;\\n____________ difference = |target-temp|\\n________ }\\n________ if(temp == target)\\n________ {\\n____________ return target\\n________ }\\n________ if(target<temp)\\n________ {\\n____________ end--;\\n________ }\\n________ else\\n________ {\\n____________ start ++\\n________ }\\n____ }\\n}\\nreturn ans;"
                    },
                    {
                        "username": "ankush920",
                        "content": "Best and easiest solution of this problem \\nS.C. =O(1) , T.C. =O(1)\\njust like 3sum problem :-\\nclass Solution {\\npublic:\\n\\n int mod (int a)\\n {\\n     if( a<0)\\n     {\\n          return (-a);\\n     }\\n\\n     return a;\\n  }\\n\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n\\n\\n         int ans =0 ;\\n         int minima= INT_MAX;\\n        int n =nums.size();\\n        int result=0;  \\n           \\n      sort(nums.begin() ,nums.end()); //sorting array to use two pointer approach \\n\\n\\n      for( int i = 0; i< n-1; i++)\\n      { \\n         \\n              \\n          int sum = nums[i];\\n           int p1 =i+1;\\n           int p2= n-1 ;\\n\\n         while(p1<p2)\\n          {\\n           \\n\\n            sum =nums[i]+nums[p1]+nums[p2];    \\n\\n            int diff =target-sum;\\n\\n             \\n             if(mod(diff) < mod(minima) )  /////for finding nearst greater or lower \\n             {\\n                \\n                 minima=diff;\\n                  result= sum;\\n             }\\n\\n            if(sum > target)\\n            {\\n                 p2--;\\n                 continue;\\n            }\\n\\n            if(sum <target )\\n            {\\n                p1++;\\n                continue;\\n            }\\n            \\n      \\n            ans++; ///// if the taget hit we return it \\n               p1++;\\n            p2--;\\n              break; \\n           \\n          }\\n     \\n\\n      }\\n\\n     if(! ans)\\n     {\\n          return result;\\n     }  \\n        \\n    \\n      return target;\\n      }\\n};"
                    },
                    {
                        "username": "08sahil_lamba",
                        "content": "\"I have recently solved a problem using the traditional two-pointer approach, but I am not satisfied with its time complexity of O(n^2). Can you please provide suggestions on how I can improve it?\"\\nThis is my solution : --->\\n `class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int ans = 0;\\n        int min = INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size(); i++){\\n            int start=i+1;\\n            int end = nums.size()-1;\\n            while(start < end){\\n                int sum = nums[i]+nums[start]+nums[end];\\n                if( abs(sum - target) < min ){\\n                    min = abs(sum - target);\\n                    ans = sum;\\n                    cout<<min<<\" \"<<ans<<endl;\\n                }\\n                if( sum == target )return sum;\\n                else if ( sum  < target )start++;\\n                else end--;\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "can someone tell the issue in my code , it is failing on input [-1,2,1,-4] target =1\\ncode:\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n         sort(nums.begin(),nums.end());\\n        int n1,n2,n3,gap=INT_MAX,t_gap,sum;\\n        int size = nums.size();\\n        int count =1;\\n        int i =0,j=1,k=2;\\n         n1= nums[i];\\n         n2= nums[j];\\n         n3= nums[k];\\n         sum = n1+n2+n3;\\n         int ans;\\n         t_gap= abs(target - sum);\\n         if (n1+n2+n3==target)\\n         {\\n             return target;\\n         }\\n        while(count<=size/2)\\n        {\\n            if (t_gap<gap)\\n            {\\n                gap = t_gap;\\n                ans= sum;\\n            }\\n            if(sum!=target)\\n            {\\n                while(k<=size-1)\\n                {\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    k++;\\n                }\\n                k=j+1;\\n                while(j<=size-1)\\n                {\\n                    if (j==k)\\n                    {\\n                        j++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    j++;\\n                }\\n                j=i+1;\\n                while(i<=size-1)\\n                {\\n                    if (i==j || i==k)\\n                    {\\n                        i++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    i++;\\n                }\\n                i=j-1;\\n                count++;\\n                i++;\\n                j++;\\n                k++;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sachingg",
                        "content": "1) How is difference counted. Is it on the number Line or by Actual subtraction\\nfor eg. if target is 1 and 2 diffs are -1 and 5. Which is closest\\n\\n2) How should the difference be calculated. target-sum or sum-target"
                    }
                ]
            },
            {
                "id": 1767723,
                "content": [
                    {
                        "username": "Kinszs",
                        "content": "For this problem would the output be the closest number to the target? I would assume that 0 would be the closest number to 1 and not 2. "
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on my IDE but the Same Test Cases Fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on IDE but the same test cases fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "best beat 100%"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n\\n    \\nint threeSumClosest(vector<int>&nums,int target)\\n{\\n    sort(nums.begin(),nums.end());\\n\\n    int closedifff = INT_MAX;\\n    int closesum;\\n\\n    for(int i=0;i<nums.size()-2;i++)\\n    {\\n        int sum =0;\\n        int j=i+1,k=nums.size()-1;\\n        sum+=nums[i]+nums[j]+nums[k];\\n        \\n        while(j<k)\\n        {\\n            if(abs(sum-target)<closedifff)\\n            {\\n                closedifff = abs(sum-target);\\n                closesum=sum;\\n            }\\n            if(sum<target)\\n            {\\n                sum -=nums[j];\\n                j++;\\n                sum+=nums[j];\\n            }\\n            else if(sum > target){\\n                   sum -=nums[k];\\n                k--;\\n                sum+=nums[k];\\n            }\\n             else\\n             {\\n                 break;\\n             }\\n        }\\n    }\\n    return closesum;\\n\\n}\\n\\n    \\n};"
                    },
                    {
                        "username": "sanjaykumardas7399008072",
                        "content": "Procedure to Solve 3 Sum Closest\\n\\n1. Sort the array in ascending order\\n2. variables : arraySize, i, start, end, difference, temp, ans\\n3. i=0, difference = intMax\\n4. \\nwhile(i<arraySize) \\n{\\n____ start = i+1; end = arraySize-1;\\n____ while(start<end)\\n____ {\\n________ temp = arr[i] + arr[start]+arr[end];\\n________if( |target-temp| <difference)\\n________ {\\n____________ ans = temp;\\n____________ difference = |target-temp|\\n________ }\\n________ if(temp == target)\\n________ {\\n____________ return target\\n________ }\\n________ if(target<temp)\\n________ {\\n____________ end--;\\n________ }\\n________ else\\n________ {\\n____________ start ++\\n________ }\\n____ }\\n}\\nreturn ans;"
                    },
                    {
                        "username": "ankush920",
                        "content": "Best and easiest solution of this problem \\nS.C. =O(1) , T.C. =O(1)\\njust like 3sum problem :-\\nclass Solution {\\npublic:\\n\\n int mod (int a)\\n {\\n     if( a<0)\\n     {\\n          return (-a);\\n     }\\n\\n     return a;\\n  }\\n\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n\\n\\n         int ans =0 ;\\n         int minima= INT_MAX;\\n        int n =nums.size();\\n        int result=0;  \\n           \\n      sort(nums.begin() ,nums.end()); //sorting array to use two pointer approach \\n\\n\\n      for( int i = 0; i< n-1; i++)\\n      { \\n         \\n              \\n          int sum = nums[i];\\n           int p1 =i+1;\\n           int p2= n-1 ;\\n\\n         while(p1<p2)\\n          {\\n           \\n\\n            sum =nums[i]+nums[p1]+nums[p2];    \\n\\n            int diff =target-sum;\\n\\n             \\n             if(mod(diff) < mod(minima) )  /////for finding nearst greater or lower \\n             {\\n                \\n                 minima=diff;\\n                  result= sum;\\n             }\\n\\n            if(sum > target)\\n            {\\n                 p2--;\\n                 continue;\\n            }\\n\\n            if(sum <target )\\n            {\\n                p1++;\\n                continue;\\n            }\\n            \\n      \\n            ans++; ///// if the taget hit we return it \\n               p1++;\\n            p2--;\\n              break; \\n           \\n          }\\n     \\n\\n      }\\n\\n     if(! ans)\\n     {\\n          return result;\\n     }  \\n        \\n    \\n      return target;\\n      }\\n};"
                    },
                    {
                        "username": "08sahil_lamba",
                        "content": "\"I have recently solved a problem using the traditional two-pointer approach, but I am not satisfied with its time complexity of O(n^2). Can you please provide suggestions on how I can improve it?\"\\nThis is my solution : --->\\n `class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int ans = 0;\\n        int min = INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size(); i++){\\n            int start=i+1;\\n            int end = nums.size()-1;\\n            while(start < end){\\n                int sum = nums[i]+nums[start]+nums[end];\\n                if( abs(sum - target) < min ){\\n                    min = abs(sum - target);\\n                    ans = sum;\\n                    cout<<min<<\" \"<<ans<<endl;\\n                }\\n                if( sum == target )return sum;\\n                else if ( sum  < target )start++;\\n                else end--;\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "can someone tell the issue in my code , it is failing on input [-1,2,1,-4] target =1\\ncode:\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n         sort(nums.begin(),nums.end());\\n        int n1,n2,n3,gap=INT_MAX,t_gap,sum;\\n        int size = nums.size();\\n        int count =1;\\n        int i =0,j=1,k=2;\\n         n1= nums[i];\\n         n2= nums[j];\\n         n3= nums[k];\\n         sum = n1+n2+n3;\\n         int ans;\\n         t_gap= abs(target - sum);\\n         if (n1+n2+n3==target)\\n         {\\n             return target;\\n         }\\n        while(count<=size/2)\\n        {\\n            if (t_gap<gap)\\n            {\\n                gap = t_gap;\\n                ans= sum;\\n            }\\n            if(sum!=target)\\n            {\\n                while(k<=size-1)\\n                {\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    k++;\\n                }\\n                k=j+1;\\n                while(j<=size-1)\\n                {\\n                    if (j==k)\\n                    {\\n                        j++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    j++;\\n                }\\n                j=i+1;\\n                while(i<=size-1)\\n                {\\n                    if (i==j || i==k)\\n                    {\\n                        i++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    i++;\\n                }\\n                i=j-1;\\n                count++;\\n                i++;\\n                j++;\\n                k++;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sachingg",
                        "content": "1) How is difference counted. Is it on the number Line or by Actual subtraction\\nfor eg. if target is 1 and 2 diffs are -1 and 5. Which is closest\\n\\n2) How should the difference be calculated. target-sum or sum-target"
                    }
                ]
            },
            {
                "id": 1761945,
                "content": [
                    {
                        "username": "Kinszs",
                        "content": "For this problem would the output be the closest number to the target? I would assume that 0 would be the closest number to 1 and not 2. "
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on my IDE but the Same Test Cases Fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on IDE but the same test cases fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "best beat 100%"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n\\n    \\nint threeSumClosest(vector<int>&nums,int target)\\n{\\n    sort(nums.begin(),nums.end());\\n\\n    int closedifff = INT_MAX;\\n    int closesum;\\n\\n    for(int i=0;i<nums.size()-2;i++)\\n    {\\n        int sum =0;\\n        int j=i+1,k=nums.size()-1;\\n        sum+=nums[i]+nums[j]+nums[k];\\n        \\n        while(j<k)\\n        {\\n            if(abs(sum-target)<closedifff)\\n            {\\n                closedifff = abs(sum-target);\\n                closesum=sum;\\n            }\\n            if(sum<target)\\n            {\\n                sum -=nums[j];\\n                j++;\\n                sum+=nums[j];\\n            }\\n            else if(sum > target){\\n                   sum -=nums[k];\\n                k--;\\n                sum+=nums[k];\\n            }\\n             else\\n             {\\n                 break;\\n             }\\n        }\\n    }\\n    return closesum;\\n\\n}\\n\\n    \\n};"
                    },
                    {
                        "username": "sanjaykumardas7399008072",
                        "content": "Procedure to Solve 3 Sum Closest\\n\\n1. Sort the array in ascending order\\n2. variables : arraySize, i, start, end, difference, temp, ans\\n3. i=0, difference = intMax\\n4. \\nwhile(i<arraySize) \\n{\\n____ start = i+1; end = arraySize-1;\\n____ while(start<end)\\n____ {\\n________ temp = arr[i] + arr[start]+arr[end];\\n________if( |target-temp| <difference)\\n________ {\\n____________ ans = temp;\\n____________ difference = |target-temp|\\n________ }\\n________ if(temp == target)\\n________ {\\n____________ return target\\n________ }\\n________ if(target<temp)\\n________ {\\n____________ end--;\\n________ }\\n________ else\\n________ {\\n____________ start ++\\n________ }\\n____ }\\n}\\nreturn ans;"
                    },
                    {
                        "username": "ankush920",
                        "content": "Best and easiest solution of this problem \\nS.C. =O(1) , T.C. =O(1)\\njust like 3sum problem :-\\nclass Solution {\\npublic:\\n\\n int mod (int a)\\n {\\n     if( a<0)\\n     {\\n          return (-a);\\n     }\\n\\n     return a;\\n  }\\n\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n\\n\\n         int ans =0 ;\\n         int minima= INT_MAX;\\n        int n =nums.size();\\n        int result=0;  \\n           \\n      sort(nums.begin() ,nums.end()); //sorting array to use two pointer approach \\n\\n\\n      for( int i = 0; i< n-1; i++)\\n      { \\n         \\n              \\n          int sum = nums[i];\\n           int p1 =i+1;\\n           int p2= n-1 ;\\n\\n         while(p1<p2)\\n          {\\n           \\n\\n            sum =nums[i]+nums[p1]+nums[p2];    \\n\\n            int diff =target-sum;\\n\\n             \\n             if(mod(diff) < mod(minima) )  /////for finding nearst greater or lower \\n             {\\n                \\n                 minima=diff;\\n                  result= sum;\\n             }\\n\\n            if(sum > target)\\n            {\\n                 p2--;\\n                 continue;\\n            }\\n\\n            if(sum <target )\\n            {\\n                p1++;\\n                continue;\\n            }\\n            \\n      \\n            ans++; ///// if the taget hit we return it \\n               p1++;\\n            p2--;\\n              break; \\n           \\n          }\\n     \\n\\n      }\\n\\n     if(! ans)\\n     {\\n          return result;\\n     }  \\n        \\n    \\n      return target;\\n      }\\n};"
                    },
                    {
                        "username": "08sahil_lamba",
                        "content": "\"I have recently solved a problem using the traditional two-pointer approach, but I am not satisfied with its time complexity of O(n^2). Can you please provide suggestions on how I can improve it?\"\\nThis is my solution : --->\\n `class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int ans = 0;\\n        int min = INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size(); i++){\\n            int start=i+1;\\n            int end = nums.size()-1;\\n            while(start < end){\\n                int sum = nums[i]+nums[start]+nums[end];\\n                if( abs(sum - target) < min ){\\n                    min = abs(sum - target);\\n                    ans = sum;\\n                    cout<<min<<\" \"<<ans<<endl;\\n                }\\n                if( sum == target )return sum;\\n                else if ( sum  < target )start++;\\n                else end--;\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "can someone tell the issue in my code , it is failing on input [-1,2,1,-4] target =1\\ncode:\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n         sort(nums.begin(),nums.end());\\n        int n1,n2,n3,gap=INT_MAX,t_gap,sum;\\n        int size = nums.size();\\n        int count =1;\\n        int i =0,j=1,k=2;\\n         n1= nums[i];\\n         n2= nums[j];\\n         n3= nums[k];\\n         sum = n1+n2+n3;\\n         int ans;\\n         t_gap= abs(target - sum);\\n         if (n1+n2+n3==target)\\n         {\\n             return target;\\n         }\\n        while(count<=size/2)\\n        {\\n            if (t_gap<gap)\\n            {\\n                gap = t_gap;\\n                ans= sum;\\n            }\\n            if(sum!=target)\\n            {\\n                while(k<=size-1)\\n                {\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    k++;\\n                }\\n                k=j+1;\\n                while(j<=size-1)\\n                {\\n                    if (j==k)\\n                    {\\n                        j++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    j++;\\n                }\\n                j=i+1;\\n                while(i<=size-1)\\n                {\\n                    if (i==j || i==k)\\n                    {\\n                        i++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    i++;\\n                }\\n                i=j-1;\\n                count++;\\n                i++;\\n                j++;\\n                k++;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sachingg",
                        "content": "1) How is difference counted. Is it on the number Line or by Actual subtraction\\nfor eg. if target is 1 and 2 diffs are -1 and 5. Which is closest\\n\\n2) How should the difference be calculated. target-sum or sum-target"
                    }
                ]
            },
            {
                "id": 1753078,
                "content": [
                    {
                        "username": "Kinszs",
                        "content": "For this problem would the output be the closest number to the target? I would assume that 0 would be the closest number to 1 and not 2. "
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on my IDE but the Same Test Cases Fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on IDE but the same test cases fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "best beat 100%"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n\\n    \\nint threeSumClosest(vector<int>&nums,int target)\\n{\\n    sort(nums.begin(),nums.end());\\n\\n    int closedifff = INT_MAX;\\n    int closesum;\\n\\n    for(int i=0;i<nums.size()-2;i++)\\n    {\\n        int sum =0;\\n        int j=i+1,k=nums.size()-1;\\n        sum+=nums[i]+nums[j]+nums[k];\\n        \\n        while(j<k)\\n        {\\n            if(abs(sum-target)<closedifff)\\n            {\\n                closedifff = abs(sum-target);\\n                closesum=sum;\\n            }\\n            if(sum<target)\\n            {\\n                sum -=nums[j];\\n                j++;\\n                sum+=nums[j];\\n            }\\n            else if(sum > target){\\n                   sum -=nums[k];\\n                k--;\\n                sum+=nums[k];\\n            }\\n             else\\n             {\\n                 break;\\n             }\\n        }\\n    }\\n    return closesum;\\n\\n}\\n\\n    \\n};"
                    },
                    {
                        "username": "sanjaykumardas7399008072",
                        "content": "Procedure to Solve 3 Sum Closest\\n\\n1. Sort the array in ascending order\\n2. variables : arraySize, i, start, end, difference, temp, ans\\n3. i=0, difference = intMax\\n4. \\nwhile(i<arraySize) \\n{\\n____ start = i+1; end = arraySize-1;\\n____ while(start<end)\\n____ {\\n________ temp = arr[i] + arr[start]+arr[end];\\n________if( |target-temp| <difference)\\n________ {\\n____________ ans = temp;\\n____________ difference = |target-temp|\\n________ }\\n________ if(temp == target)\\n________ {\\n____________ return target\\n________ }\\n________ if(target<temp)\\n________ {\\n____________ end--;\\n________ }\\n________ else\\n________ {\\n____________ start ++\\n________ }\\n____ }\\n}\\nreturn ans;"
                    },
                    {
                        "username": "ankush920",
                        "content": "Best and easiest solution of this problem \\nS.C. =O(1) , T.C. =O(1)\\njust like 3sum problem :-\\nclass Solution {\\npublic:\\n\\n int mod (int a)\\n {\\n     if( a<0)\\n     {\\n          return (-a);\\n     }\\n\\n     return a;\\n  }\\n\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n\\n\\n         int ans =0 ;\\n         int minima= INT_MAX;\\n        int n =nums.size();\\n        int result=0;  \\n           \\n      sort(nums.begin() ,nums.end()); //sorting array to use two pointer approach \\n\\n\\n      for( int i = 0; i< n-1; i++)\\n      { \\n         \\n              \\n          int sum = nums[i];\\n           int p1 =i+1;\\n           int p2= n-1 ;\\n\\n         while(p1<p2)\\n          {\\n           \\n\\n            sum =nums[i]+nums[p1]+nums[p2];    \\n\\n            int diff =target-sum;\\n\\n             \\n             if(mod(diff) < mod(minima) )  /////for finding nearst greater or lower \\n             {\\n                \\n                 minima=diff;\\n                  result= sum;\\n             }\\n\\n            if(sum > target)\\n            {\\n                 p2--;\\n                 continue;\\n            }\\n\\n            if(sum <target )\\n            {\\n                p1++;\\n                continue;\\n            }\\n            \\n      \\n            ans++; ///// if the taget hit we return it \\n               p1++;\\n            p2--;\\n              break; \\n           \\n          }\\n     \\n\\n      }\\n\\n     if(! ans)\\n     {\\n          return result;\\n     }  \\n        \\n    \\n      return target;\\n      }\\n};"
                    },
                    {
                        "username": "08sahil_lamba",
                        "content": "\"I have recently solved a problem using the traditional two-pointer approach, but I am not satisfied with its time complexity of O(n^2). Can you please provide suggestions on how I can improve it?\"\\nThis is my solution : --->\\n `class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int ans = 0;\\n        int min = INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size(); i++){\\n            int start=i+1;\\n            int end = nums.size()-1;\\n            while(start < end){\\n                int sum = nums[i]+nums[start]+nums[end];\\n                if( abs(sum - target) < min ){\\n                    min = abs(sum - target);\\n                    ans = sum;\\n                    cout<<min<<\" \"<<ans<<endl;\\n                }\\n                if( sum == target )return sum;\\n                else if ( sum  < target )start++;\\n                else end--;\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "can someone tell the issue in my code , it is failing on input [-1,2,1,-4] target =1\\ncode:\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n         sort(nums.begin(),nums.end());\\n        int n1,n2,n3,gap=INT_MAX,t_gap,sum;\\n        int size = nums.size();\\n        int count =1;\\n        int i =0,j=1,k=2;\\n         n1= nums[i];\\n         n2= nums[j];\\n         n3= nums[k];\\n         sum = n1+n2+n3;\\n         int ans;\\n         t_gap= abs(target - sum);\\n         if (n1+n2+n3==target)\\n         {\\n             return target;\\n         }\\n        while(count<=size/2)\\n        {\\n            if (t_gap<gap)\\n            {\\n                gap = t_gap;\\n                ans= sum;\\n            }\\n            if(sum!=target)\\n            {\\n                while(k<=size-1)\\n                {\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    k++;\\n                }\\n                k=j+1;\\n                while(j<=size-1)\\n                {\\n                    if (j==k)\\n                    {\\n                        j++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    j++;\\n                }\\n                j=i+1;\\n                while(i<=size-1)\\n                {\\n                    if (i==j || i==k)\\n                    {\\n                        i++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    i++;\\n                }\\n                i=j-1;\\n                count++;\\n                i++;\\n                j++;\\n                k++;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sachingg",
                        "content": "1) How is difference counted. Is it on the number Line or by Actual subtraction\\nfor eg. if target is 1 and 2 diffs are -1 and 5. Which is closest\\n\\n2) How should the difference be calculated. target-sum or sum-target"
                    }
                ]
            },
            {
                "id": 1752585,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "randeepbydesign",
                        "content": "As of right now, the N^3 solution can pass verification using Java.\\n```\\npublic int threeSumClosestN3(int[] nums, int target) {\\n    int distance = nums[0] + nums[1] + nums[2];\\n    for(int i=0; i<nums.length-2; i++) {\\n        for(int j = i+1; j<nums.length-1; j++) {\\n            for(int k = j + 1; k<nums.length; k++) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                distance = (Math.abs(distance-target) > Math.abs(sum-target)) ? sum : distance;\\n            }\\n        }\\n    }\\n    return distance;\\n}\\n```"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int threeSumClosest(int[] arr, int target) {\\n        \\n\\nint arr1=0;\\n\\n\\n\\n        // List<List<Integer>> arr1=new ArrayList<>();\\nHashMap<Integer,Integer> map= new HashMap<>();\\n\\nfor(int i=0;i<arr.length;i++){\\n    map.put(i,arr[i]);\\n}\\n\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                for(int k=j+1;k<arr.length;k++){\\n                    int ans=map.get(i)+map.get(j)+map.get(k);\\nif(Math.max(target-ans,ans-target)<Math.max(target-arr1,arr1-target)){\\n    //  List<Integer> arr2=new ArrayList<>();\\n    //  arr2.add(i);\\n    //  arr2.add(j);\\n    //  arr2.add(k);\\n    //  arr1.add(arr2);\\n  arr1=map.get(i)+map.get(j)+map.get(k);\\n}\\n            }\\n            }\\n        }\\n        return arr1;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n// plz somebody tell error in my code\\n"
                    },
                    {
                        "username": "Mohamad-Badr",
                        "content": "nums =[-1,2,1,-4]\\ntarget =1\\nOutput\\n-1 // the wrong is here in my IDE it is =2\\nExpected\\n2\\nin this test case, it gave me the output as -1 but I tested the code and the result with my IDE and the result was 2, not -1 so my code is right and there is a wrong in the test case of this case I don\\'t the why."
                    },
                    {
                        "username": "cosh_7411",
                        "content": "I got wrong test case.How is 2 nearer to -100 than 1??\\nnums =[1,1,1,0]\\ntarget =-100\\nOutput\\n1\\nExpected\\n2\\n\\nmore over for list with len 1 I tried list1[0] it gave index out error.\\n"
                    },
                    {
                        "username": "akm07",
                        "content": "the answer must be a sum of 3 numbers from the array 0+1+1"
                    },
                    {
                        "username": "vishal1810",
                        "content": "leetcode accepts only case sensitive solutions,\\nso remember to use curly braces.\\nwe can solve it by two approaches \\n   1) Bruttle force appr (T.C = O(n^3))\\n   2) Two pointers appr(T.C = O(n^2))"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and c programming.\\n[https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\n\\n\\nhttps://zeroplusfour.com/3sum-closest-leetcode-solution/"
                    },
                    {
                        "username": "Roshan_kumar_",
                        "content": "nums =[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2\\nOutput= -1\\nExpected = -2\\nwhy it is giving me the wrong answer \\n"
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The expected answer is indeed -2 because by taking the triplet (-5, 0, 3) and by adding them, it gives the output -2"
                    },
                    {
                        "username": "Raj_Gurjar",
                        "content": "nums =\\n[4,0,5,3,3,0,-4]\\ntarget =\\n-2\\nOutput\\n-4\\nExpected\\n-1\\n\\n\\nis the above test case correct ? I think it is wrong."
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The testcase is correct.\n\nThe result -1 is obtained by adding 0, 3 and -4 together; and the result -1 is closer to the target that is -2 than the result -4"
                    }
                ]
            },
            {
                "id": 1715276,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "randeepbydesign",
                        "content": "As of right now, the N^3 solution can pass verification using Java.\\n```\\npublic int threeSumClosestN3(int[] nums, int target) {\\n    int distance = nums[0] + nums[1] + nums[2];\\n    for(int i=0; i<nums.length-2; i++) {\\n        for(int j = i+1; j<nums.length-1; j++) {\\n            for(int k = j + 1; k<nums.length; k++) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                distance = (Math.abs(distance-target) > Math.abs(sum-target)) ? sum : distance;\\n            }\\n        }\\n    }\\n    return distance;\\n}\\n```"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int threeSumClosest(int[] arr, int target) {\\n        \\n\\nint arr1=0;\\n\\n\\n\\n        // List<List<Integer>> arr1=new ArrayList<>();\\nHashMap<Integer,Integer> map= new HashMap<>();\\n\\nfor(int i=0;i<arr.length;i++){\\n    map.put(i,arr[i]);\\n}\\n\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                for(int k=j+1;k<arr.length;k++){\\n                    int ans=map.get(i)+map.get(j)+map.get(k);\\nif(Math.max(target-ans,ans-target)<Math.max(target-arr1,arr1-target)){\\n    //  List<Integer> arr2=new ArrayList<>();\\n    //  arr2.add(i);\\n    //  arr2.add(j);\\n    //  arr2.add(k);\\n    //  arr1.add(arr2);\\n  arr1=map.get(i)+map.get(j)+map.get(k);\\n}\\n            }\\n            }\\n        }\\n        return arr1;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n// plz somebody tell error in my code\\n"
                    },
                    {
                        "username": "Mohamad-Badr",
                        "content": "nums =[-1,2,1,-4]\\ntarget =1\\nOutput\\n-1 // the wrong is here in my IDE it is =2\\nExpected\\n2\\nin this test case, it gave me the output as -1 but I tested the code and the result with my IDE and the result was 2, not -1 so my code is right and there is a wrong in the test case of this case I don\\'t the why."
                    },
                    {
                        "username": "cosh_7411",
                        "content": "I got wrong test case.How is 2 nearer to -100 than 1??\\nnums =[1,1,1,0]\\ntarget =-100\\nOutput\\n1\\nExpected\\n2\\n\\nmore over for list with len 1 I tried list1[0] it gave index out error.\\n"
                    },
                    {
                        "username": "akm07",
                        "content": "the answer must be a sum of 3 numbers from the array 0+1+1"
                    },
                    {
                        "username": "vishal1810",
                        "content": "leetcode accepts only case sensitive solutions,\\nso remember to use curly braces.\\nwe can solve it by two approaches \\n   1) Bruttle force appr (T.C = O(n^3))\\n   2) Two pointers appr(T.C = O(n^2))"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and c programming.\\n[https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\n\\n\\nhttps://zeroplusfour.com/3sum-closest-leetcode-solution/"
                    },
                    {
                        "username": "Roshan_kumar_",
                        "content": "nums =[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2\\nOutput= -1\\nExpected = -2\\nwhy it is giving me the wrong answer \\n"
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The expected answer is indeed -2 because by taking the triplet (-5, 0, 3) and by adding them, it gives the output -2"
                    },
                    {
                        "username": "Raj_Gurjar",
                        "content": "nums =\\n[4,0,5,3,3,0,-4]\\ntarget =\\n-2\\nOutput\\n-4\\nExpected\\n-1\\n\\n\\nis the above test case correct ? I think it is wrong."
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The testcase is correct.\n\nThe result -1 is obtained by adding 0, 3 and -4 together; and the result -1 is closer to the target that is -2 than the result -4"
                    }
                ]
            },
            {
                "id": 1714059,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "randeepbydesign",
                        "content": "As of right now, the N^3 solution can pass verification using Java.\\n```\\npublic int threeSumClosestN3(int[] nums, int target) {\\n    int distance = nums[0] + nums[1] + nums[2];\\n    for(int i=0; i<nums.length-2; i++) {\\n        for(int j = i+1; j<nums.length-1; j++) {\\n            for(int k = j + 1; k<nums.length; k++) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                distance = (Math.abs(distance-target) > Math.abs(sum-target)) ? sum : distance;\\n            }\\n        }\\n    }\\n    return distance;\\n}\\n```"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int threeSumClosest(int[] arr, int target) {\\n        \\n\\nint arr1=0;\\n\\n\\n\\n        // List<List<Integer>> arr1=new ArrayList<>();\\nHashMap<Integer,Integer> map= new HashMap<>();\\n\\nfor(int i=0;i<arr.length;i++){\\n    map.put(i,arr[i]);\\n}\\n\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                for(int k=j+1;k<arr.length;k++){\\n                    int ans=map.get(i)+map.get(j)+map.get(k);\\nif(Math.max(target-ans,ans-target)<Math.max(target-arr1,arr1-target)){\\n    //  List<Integer> arr2=new ArrayList<>();\\n    //  arr2.add(i);\\n    //  arr2.add(j);\\n    //  arr2.add(k);\\n    //  arr1.add(arr2);\\n  arr1=map.get(i)+map.get(j)+map.get(k);\\n}\\n            }\\n            }\\n        }\\n        return arr1;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n// plz somebody tell error in my code\\n"
                    },
                    {
                        "username": "Mohamad-Badr",
                        "content": "nums =[-1,2,1,-4]\\ntarget =1\\nOutput\\n-1 // the wrong is here in my IDE it is =2\\nExpected\\n2\\nin this test case, it gave me the output as -1 but I tested the code and the result with my IDE and the result was 2, not -1 so my code is right and there is a wrong in the test case of this case I don\\'t the why."
                    },
                    {
                        "username": "cosh_7411",
                        "content": "I got wrong test case.How is 2 nearer to -100 than 1??\\nnums =[1,1,1,0]\\ntarget =-100\\nOutput\\n1\\nExpected\\n2\\n\\nmore over for list with len 1 I tried list1[0] it gave index out error.\\n"
                    },
                    {
                        "username": "akm07",
                        "content": "the answer must be a sum of 3 numbers from the array 0+1+1"
                    },
                    {
                        "username": "vishal1810",
                        "content": "leetcode accepts only case sensitive solutions,\\nso remember to use curly braces.\\nwe can solve it by two approaches \\n   1) Bruttle force appr (T.C = O(n^3))\\n   2) Two pointers appr(T.C = O(n^2))"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and c programming.\\n[https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\n\\n\\nhttps://zeroplusfour.com/3sum-closest-leetcode-solution/"
                    },
                    {
                        "username": "Roshan_kumar_",
                        "content": "nums =[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2\\nOutput= -1\\nExpected = -2\\nwhy it is giving me the wrong answer \\n"
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The expected answer is indeed -2 because by taking the triplet (-5, 0, 3) and by adding them, it gives the output -2"
                    },
                    {
                        "username": "Raj_Gurjar",
                        "content": "nums =\\n[4,0,5,3,3,0,-4]\\ntarget =\\n-2\\nOutput\\n-4\\nExpected\\n-1\\n\\n\\nis the above test case correct ? I think it is wrong."
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The testcase is correct.\n\nThe result -1 is obtained by adding 0, 3 and -4 together; and the result -1 is closer to the target that is -2 than the result -4"
                    }
                ]
            },
            {
                "id": 1713632,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "randeepbydesign",
                        "content": "As of right now, the N^3 solution can pass verification using Java.\\n```\\npublic int threeSumClosestN3(int[] nums, int target) {\\n    int distance = nums[0] + nums[1] + nums[2];\\n    for(int i=0; i<nums.length-2; i++) {\\n        for(int j = i+1; j<nums.length-1; j++) {\\n            for(int k = j + 1; k<nums.length; k++) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                distance = (Math.abs(distance-target) > Math.abs(sum-target)) ? sum : distance;\\n            }\\n        }\\n    }\\n    return distance;\\n}\\n```"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int threeSumClosest(int[] arr, int target) {\\n        \\n\\nint arr1=0;\\n\\n\\n\\n        // List<List<Integer>> arr1=new ArrayList<>();\\nHashMap<Integer,Integer> map= new HashMap<>();\\n\\nfor(int i=0;i<arr.length;i++){\\n    map.put(i,arr[i]);\\n}\\n\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                for(int k=j+1;k<arr.length;k++){\\n                    int ans=map.get(i)+map.get(j)+map.get(k);\\nif(Math.max(target-ans,ans-target)<Math.max(target-arr1,arr1-target)){\\n    //  List<Integer> arr2=new ArrayList<>();\\n    //  arr2.add(i);\\n    //  arr2.add(j);\\n    //  arr2.add(k);\\n    //  arr1.add(arr2);\\n  arr1=map.get(i)+map.get(j)+map.get(k);\\n}\\n            }\\n            }\\n        }\\n        return arr1;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n// plz somebody tell error in my code\\n"
                    },
                    {
                        "username": "Mohamad-Badr",
                        "content": "nums =[-1,2,1,-4]\\ntarget =1\\nOutput\\n-1 // the wrong is here in my IDE it is =2\\nExpected\\n2\\nin this test case, it gave me the output as -1 but I tested the code and the result with my IDE and the result was 2, not -1 so my code is right and there is a wrong in the test case of this case I don\\'t the why."
                    },
                    {
                        "username": "cosh_7411",
                        "content": "I got wrong test case.How is 2 nearer to -100 than 1??\\nnums =[1,1,1,0]\\ntarget =-100\\nOutput\\n1\\nExpected\\n2\\n\\nmore over for list with len 1 I tried list1[0] it gave index out error.\\n"
                    },
                    {
                        "username": "akm07",
                        "content": "the answer must be a sum of 3 numbers from the array 0+1+1"
                    },
                    {
                        "username": "vishal1810",
                        "content": "leetcode accepts only case sensitive solutions,\\nso remember to use curly braces.\\nwe can solve it by two approaches \\n   1) Bruttle force appr (T.C = O(n^3))\\n   2) Two pointers appr(T.C = O(n^2))"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and c programming.\\n[https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\n\\n\\nhttps://zeroplusfour.com/3sum-closest-leetcode-solution/"
                    },
                    {
                        "username": "Roshan_kumar_",
                        "content": "nums =[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2\\nOutput= -1\\nExpected = -2\\nwhy it is giving me the wrong answer \\n"
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The expected answer is indeed -2 because by taking the triplet (-5, 0, 3) and by adding them, it gives the output -2"
                    },
                    {
                        "username": "Raj_Gurjar",
                        "content": "nums =\\n[4,0,5,3,3,0,-4]\\ntarget =\\n-2\\nOutput\\n-4\\nExpected\\n-1\\n\\n\\nis the above test case correct ? I think it is wrong."
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The testcase is correct.\n\nThe result -1 is obtained by adding 0, 3 and -4 together; and the result -1 is closer to the target that is -2 than the result -4"
                    }
                ]
            },
            {
                "id": 1701042,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "randeepbydesign",
                        "content": "As of right now, the N^3 solution can pass verification using Java.\\n```\\npublic int threeSumClosestN3(int[] nums, int target) {\\n    int distance = nums[0] + nums[1] + nums[2];\\n    for(int i=0; i<nums.length-2; i++) {\\n        for(int j = i+1; j<nums.length-1; j++) {\\n            for(int k = j + 1; k<nums.length; k++) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                distance = (Math.abs(distance-target) > Math.abs(sum-target)) ? sum : distance;\\n            }\\n        }\\n    }\\n    return distance;\\n}\\n```"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int threeSumClosest(int[] arr, int target) {\\n        \\n\\nint arr1=0;\\n\\n\\n\\n        // List<List<Integer>> arr1=new ArrayList<>();\\nHashMap<Integer,Integer> map= new HashMap<>();\\n\\nfor(int i=0;i<arr.length;i++){\\n    map.put(i,arr[i]);\\n}\\n\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                for(int k=j+1;k<arr.length;k++){\\n                    int ans=map.get(i)+map.get(j)+map.get(k);\\nif(Math.max(target-ans,ans-target)<Math.max(target-arr1,arr1-target)){\\n    //  List<Integer> arr2=new ArrayList<>();\\n    //  arr2.add(i);\\n    //  arr2.add(j);\\n    //  arr2.add(k);\\n    //  arr1.add(arr2);\\n  arr1=map.get(i)+map.get(j)+map.get(k);\\n}\\n            }\\n            }\\n        }\\n        return arr1;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n// plz somebody tell error in my code\\n"
                    },
                    {
                        "username": "Mohamad-Badr",
                        "content": "nums =[-1,2,1,-4]\\ntarget =1\\nOutput\\n-1 // the wrong is here in my IDE it is =2\\nExpected\\n2\\nin this test case, it gave me the output as -1 but I tested the code and the result with my IDE and the result was 2, not -1 so my code is right and there is a wrong in the test case of this case I don\\'t the why."
                    },
                    {
                        "username": "cosh_7411",
                        "content": "I got wrong test case.How is 2 nearer to -100 than 1??\\nnums =[1,1,1,0]\\ntarget =-100\\nOutput\\n1\\nExpected\\n2\\n\\nmore over for list with len 1 I tried list1[0] it gave index out error.\\n"
                    },
                    {
                        "username": "akm07",
                        "content": "the answer must be a sum of 3 numbers from the array 0+1+1"
                    },
                    {
                        "username": "vishal1810",
                        "content": "leetcode accepts only case sensitive solutions,\\nso remember to use curly braces.\\nwe can solve it by two approaches \\n   1) Bruttle force appr (T.C = O(n^3))\\n   2) Two pointers appr(T.C = O(n^2))"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and c programming.\\n[https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\n\\n\\nhttps://zeroplusfour.com/3sum-closest-leetcode-solution/"
                    },
                    {
                        "username": "Roshan_kumar_",
                        "content": "nums =[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2\\nOutput= -1\\nExpected = -2\\nwhy it is giving me the wrong answer \\n"
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The expected answer is indeed -2 because by taking the triplet (-5, 0, 3) and by adding them, it gives the output -2"
                    },
                    {
                        "username": "Raj_Gurjar",
                        "content": "nums =\\n[4,0,5,3,3,0,-4]\\ntarget =\\n-2\\nOutput\\n-4\\nExpected\\n-1\\n\\n\\nis the above test case correct ? I think it is wrong."
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The testcase is correct.\n\nThe result -1 is obtained by adding 0, 3 and -4 together; and the result -1 is closer to the target that is -2 than the result -4"
                    }
                ]
            },
            {
                "id": 1696065,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "randeepbydesign",
                        "content": "As of right now, the N^3 solution can pass verification using Java.\\n```\\npublic int threeSumClosestN3(int[] nums, int target) {\\n    int distance = nums[0] + nums[1] + nums[2];\\n    for(int i=0; i<nums.length-2; i++) {\\n        for(int j = i+1; j<nums.length-1; j++) {\\n            for(int k = j + 1; k<nums.length; k++) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                distance = (Math.abs(distance-target) > Math.abs(sum-target)) ? sum : distance;\\n            }\\n        }\\n    }\\n    return distance;\\n}\\n```"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int threeSumClosest(int[] arr, int target) {\\n        \\n\\nint arr1=0;\\n\\n\\n\\n        // List<List<Integer>> arr1=new ArrayList<>();\\nHashMap<Integer,Integer> map= new HashMap<>();\\n\\nfor(int i=0;i<arr.length;i++){\\n    map.put(i,arr[i]);\\n}\\n\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                for(int k=j+1;k<arr.length;k++){\\n                    int ans=map.get(i)+map.get(j)+map.get(k);\\nif(Math.max(target-ans,ans-target)<Math.max(target-arr1,arr1-target)){\\n    //  List<Integer> arr2=new ArrayList<>();\\n    //  arr2.add(i);\\n    //  arr2.add(j);\\n    //  arr2.add(k);\\n    //  arr1.add(arr2);\\n  arr1=map.get(i)+map.get(j)+map.get(k);\\n}\\n            }\\n            }\\n        }\\n        return arr1;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n// plz somebody tell error in my code\\n"
                    },
                    {
                        "username": "Mohamad-Badr",
                        "content": "nums =[-1,2,1,-4]\\ntarget =1\\nOutput\\n-1 // the wrong is here in my IDE it is =2\\nExpected\\n2\\nin this test case, it gave me the output as -1 but I tested the code and the result with my IDE and the result was 2, not -1 so my code is right and there is a wrong in the test case of this case I don\\'t the why."
                    },
                    {
                        "username": "cosh_7411",
                        "content": "I got wrong test case.How is 2 nearer to -100 than 1??\\nnums =[1,1,1,0]\\ntarget =-100\\nOutput\\n1\\nExpected\\n2\\n\\nmore over for list with len 1 I tried list1[0] it gave index out error.\\n"
                    },
                    {
                        "username": "akm07",
                        "content": "the answer must be a sum of 3 numbers from the array 0+1+1"
                    },
                    {
                        "username": "vishal1810",
                        "content": "leetcode accepts only case sensitive solutions,\\nso remember to use curly braces.\\nwe can solve it by two approaches \\n   1) Bruttle force appr (T.C = O(n^3))\\n   2) Two pointers appr(T.C = O(n^2))"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and c programming.\\n[https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\n\\n\\nhttps://zeroplusfour.com/3sum-closest-leetcode-solution/"
                    },
                    {
                        "username": "Roshan_kumar_",
                        "content": "nums =[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2\\nOutput= -1\\nExpected = -2\\nwhy it is giving me the wrong answer \\n"
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The expected answer is indeed -2 because by taking the triplet (-5, 0, 3) and by adding them, it gives the output -2"
                    },
                    {
                        "username": "Raj_Gurjar",
                        "content": "nums =\\n[4,0,5,3,3,0,-4]\\ntarget =\\n-2\\nOutput\\n-4\\nExpected\\n-1\\n\\n\\nis the above test case correct ? I think it is wrong."
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The testcase is correct.\n\nThe result -1 is obtained by adding 0, 3 and -4 together; and the result -1 is closer to the target that is -2 than the result -4"
                    }
                ]
            },
            {
                "id": 1671256,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "randeepbydesign",
                        "content": "As of right now, the N^3 solution can pass verification using Java.\\n```\\npublic int threeSumClosestN3(int[] nums, int target) {\\n    int distance = nums[0] + nums[1] + nums[2];\\n    for(int i=0; i<nums.length-2; i++) {\\n        for(int j = i+1; j<nums.length-1; j++) {\\n            for(int k = j + 1; k<nums.length; k++) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                distance = (Math.abs(distance-target) > Math.abs(sum-target)) ? sum : distance;\\n            }\\n        }\\n    }\\n    return distance;\\n}\\n```"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int threeSumClosest(int[] arr, int target) {\\n        \\n\\nint arr1=0;\\n\\n\\n\\n        // List<List<Integer>> arr1=new ArrayList<>();\\nHashMap<Integer,Integer> map= new HashMap<>();\\n\\nfor(int i=0;i<arr.length;i++){\\n    map.put(i,arr[i]);\\n}\\n\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                for(int k=j+1;k<arr.length;k++){\\n                    int ans=map.get(i)+map.get(j)+map.get(k);\\nif(Math.max(target-ans,ans-target)<Math.max(target-arr1,arr1-target)){\\n    //  List<Integer> arr2=new ArrayList<>();\\n    //  arr2.add(i);\\n    //  arr2.add(j);\\n    //  arr2.add(k);\\n    //  arr1.add(arr2);\\n  arr1=map.get(i)+map.get(j)+map.get(k);\\n}\\n            }\\n            }\\n        }\\n        return arr1;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n// plz somebody tell error in my code\\n"
                    },
                    {
                        "username": "Mohamad-Badr",
                        "content": "nums =[-1,2,1,-4]\\ntarget =1\\nOutput\\n-1 // the wrong is here in my IDE it is =2\\nExpected\\n2\\nin this test case, it gave me the output as -1 but I tested the code and the result with my IDE and the result was 2, not -1 so my code is right and there is a wrong in the test case of this case I don\\'t the why."
                    },
                    {
                        "username": "cosh_7411",
                        "content": "I got wrong test case.How is 2 nearer to -100 than 1??\\nnums =[1,1,1,0]\\ntarget =-100\\nOutput\\n1\\nExpected\\n2\\n\\nmore over for list with len 1 I tried list1[0] it gave index out error.\\n"
                    },
                    {
                        "username": "akm07",
                        "content": "the answer must be a sum of 3 numbers from the array 0+1+1"
                    },
                    {
                        "username": "vishal1810",
                        "content": "leetcode accepts only case sensitive solutions,\\nso remember to use curly braces.\\nwe can solve it by two approaches \\n   1) Bruttle force appr (T.C = O(n^3))\\n   2) Two pointers appr(T.C = O(n^2))"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and c programming.\\n[https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\n\\n\\nhttps://zeroplusfour.com/3sum-closest-leetcode-solution/"
                    },
                    {
                        "username": "Roshan_kumar_",
                        "content": "nums =[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2\\nOutput= -1\\nExpected = -2\\nwhy it is giving me the wrong answer \\n"
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The expected answer is indeed -2 because by taking the triplet (-5, 0, 3) and by adding them, it gives the output -2"
                    },
                    {
                        "username": "Raj_Gurjar",
                        "content": "nums =\\n[4,0,5,3,3,0,-4]\\ntarget =\\n-2\\nOutput\\n-4\\nExpected\\n-1\\n\\n\\nis the above test case correct ? I think it is wrong."
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The testcase is correct.\n\nThe result -1 is obtained by adding 0, 3 and -4 together; and the result -1 is closer to the target that is -2 than the result -4"
                    }
                ]
            },
            {
                "id": 1648663,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "randeepbydesign",
                        "content": "As of right now, the N^3 solution can pass verification using Java.\\n```\\npublic int threeSumClosestN3(int[] nums, int target) {\\n    int distance = nums[0] + nums[1] + nums[2];\\n    for(int i=0; i<nums.length-2; i++) {\\n        for(int j = i+1; j<nums.length-1; j++) {\\n            for(int k = j + 1; k<nums.length; k++) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                distance = (Math.abs(distance-target) > Math.abs(sum-target)) ? sum : distance;\\n            }\\n        }\\n    }\\n    return distance;\\n}\\n```"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int threeSumClosest(int[] arr, int target) {\\n        \\n\\nint arr1=0;\\n\\n\\n\\n        // List<List<Integer>> arr1=new ArrayList<>();\\nHashMap<Integer,Integer> map= new HashMap<>();\\n\\nfor(int i=0;i<arr.length;i++){\\n    map.put(i,arr[i]);\\n}\\n\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                for(int k=j+1;k<arr.length;k++){\\n                    int ans=map.get(i)+map.get(j)+map.get(k);\\nif(Math.max(target-ans,ans-target)<Math.max(target-arr1,arr1-target)){\\n    //  List<Integer> arr2=new ArrayList<>();\\n    //  arr2.add(i);\\n    //  arr2.add(j);\\n    //  arr2.add(k);\\n    //  arr1.add(arr2);\\n  arr1=map.get(i)+map.get(j)+map.get(k);\\n}\\n            }\\n            }\\n        }\\n        return arr1;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n// plz somebody tell error in my code\\n"
                    },
                    {
                        "username": "Mohamad-Badr",
                        "content": "nums =[-1,2,1,-4]\\ntarget =1\\nOutput\\n-1 // the wrong is here in my IDE it is =2\\nExpected\\n2\\nin this test case, it gave me the output as -1 but I tested the code and the result with my IDE and the result was 2, not -1 so my code is right and there is a wrong in the test case of this case I don\\'t the why."
                    },
                    {
                        "username": "cosh_7411",
                        "content": "I got wrong test case.How is 2 nearer to -100 than 1??\\nnums =[1,1,1,0]\\ntarget =-100\\nOutput\\n1\\nExpected\\n2\\n\\nmore over for list with len 1 I tried list1[0] it gave index out error.\\n"
                    },
                    {
                        "username": "akm07",
                        "content": "the answer must be a sum of 3 numbers from the array 0+1+1"
                    },
                    {
                        "username": "vishal1810",
                        "content": "leetcode accepts only case sensitive solutions,\\nso remember to use curly braces.\\nwe can solve it by two approaches \\n   1) Bruttle force appr (T.C = O(n^3))\\n   2) Two pointers appr(T.C = O(n^2))"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and c programming.\\n[https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\n\\n\\nhttps://zeroplusfour.com/3sum-closest-leetcode-solution/"
                    },
                    {
                        "username": "Roshan_kumar_",
                        "content": "nums =[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2\\nOutput= -1\\nExpected = -2\\nwhy it is giving me the wrong answer \\n"
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The expected answer is indeed -2 because by taking the triplet (-5, 0, 3) and by adding them, it gives the output -2"
                    },
                    {
                        "username": "Raj_Gurjar",
                        "content": "nums =\\n[4,0,5,3,3,0,-4]\\ntarget =\\n-2\\nOutput\\n-4\\nExpected\\n-1\\n\\n\\nis the above test case correct ? I think it is wrong."
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The testcase is correct.\n\nThe result -1 is obtained by adding 0, 3 and -4 together; and the result -1 is closer to the target that is -2 than the result -4"
                    }
                ]
            },
            {
                "id": 1637889,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "randeepbydesign",
                        "content": "As of right now, the N^3 solution can pass verification using Java.\\n```\\npublic int threeSumClosestN3(int[] nums, int target) {\\n    int distance = nums[0] + nums[1] + nums[2];\\n    for(int i=0; i<nums.length-2; i++) {\\n        for(int j = i+1; j<nums.length-1; j++) {\\n            for(int k = j + 1; k<nums.length; k++) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                distance = (Math.abs(distance-target) > Math.abs(sum-target)) ? sum : distance;\\n            }\\n        }\\n    }\\n    return distance;\\n}\\n```"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int threeSumClosest(int[] arr, int target) {\\n        \\n\\nint arr1=0;\\n\\n\\n\\n        // List<List<Integer>> arr1=new ArrayList<>();\\nHashMap<Integer,Integer> map= new HashMap<>();\\n\\nfor(int i=0;i<arr.length;i++){\\n    map.put(i,arr[i]);\\n}\\n\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                for(int k=j+1;k<arr.length;k++){\\n                    int ans=map.get(i)+map.get(j)+map.get(k);\\nif(Math.max(target-ans,ans-target)<Math.max(target-arr1,arr1-target)){\\n    //  List<Integer> arr2=new ArrayList<>();\\n    //  arr2.add(i);\\n    //  arr2.add(j);\\n    //  arr2.add(k);\\n    //  arr1.add(arr2);\\n  arr1=map.get(i)+map.get(j)+map.get(k);\\n}\\n            }\\n            }\\n        }\\n        return arr1;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n// plz somebody tell error in my code\\n"
                    },
                    {
                        "username": "Mohamad-Badr",
                        "content": "nums =[-1,2,1,-4]\\ntarget =1\\nOutput\\n-1 // the wrong is here in my IDE it is =2\\nExpected\\n2\\nin this test case, it gave me the output as -1 but I tested the code and the result with my IDE and the result was 2, not -1 so my code is right and there is a wrong in the test case of this case I don\\'t the why."
                    },
                    {
                        "username": "cosh_7411",
                        "content": "I got wrong test case.How is 2 nearer to -100 than 1??\\nnums =[1,1,1,0]\\ntarget =-100\\nOutput\\n1\\nExpected\\n2\\n\\nmore over for list with len 1 I tried list1[0] it gave index out error.\\n"
                    },
                    {
                        "username": "akm07",
                        "content": "the answer must be a sum of 3 numbers from the array 0+1+1"
                    },
                    {
                        "username": "vishal1810",
                        "content": "leetcode accepts only case sensitive solutions,\\nso remember to use curly braces.\\nwe can solve it by two approaches \\n   1) Bruttle force appr (T.C = O(n^3))\\n   2) Two pointers appr(T.C = O(n^2))"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and c programming.\\n[https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\n\\n\\nhttps://zeroplusfour.com/3sum-closest-leetcode-solution/"
                    },
                    {
                        "username": "Roshan_kumar_",
                        "content": "nums =[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2\\nOutput= -1\\nExpected = -2\\nwhy it is giving me the wrong answer \\n"
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The expected answer is indeed -2 because by taking the triplet (-5, 0, 3) and by adding them, it gives the output -2"
                    },
                    {
                        "username": "Raj_Gurjar",
                        "content": "nums =\\n[4,0,5,3,3,0,-4]\\ntarget =\\n-2\\nOutput\\n-4\\nExpected\\n-1\\n\\n\\nis the above test case correct ? I think it is wrong."
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The testcase is correct.\n\nThe result -1 is obtained by adding 0, 3 and -4 together; and the result -1 is closer to the target that is -2 than the result -4"
                    }
                ]
            },
            {
                "id": 1636388,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "randeepbydesign",
                        "content": "As of right now, the N^3 solution can pass verification using Java.\\n```\\npublic int threeSumClosestN3(int[] nums, int target) {\\n    int distance = nums[0] + nums[1] + nums[2];\\n    for(int i=0; i<nums.length-2; i++) {\\n        for(int j = i+1; j<nums.length-1; j++) {\\n            for(int k = j + 1; k<nums.length; k++) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                distance = (Math.abs(distance-target) > Math.abs(sum-target)) ? sum : distance;\\n            }\\n        }\\n    }\\n    return distance;\\n}\\n```"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int threeSumClosest(int[] arr, int target) {\\n        \\n\\nint arr1=0;\\n\\n\\n\\n        // List<List<Integer>> arr1=new ArrayList<>();\\nHashMap<Integer,Integer> map= new HashMap<>();\\n\\nfor(int i=0;i<arr.length;i++){\\n    map.put(i,arr[i]);\\n}\\n\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                for(int k=j+1;k<arr.length;k++){\\n                    int ans=map.get(i)+map.get(j)+map.get(k);\\nif(Math.max(target-ans,ans-target)<Math.max(target-arr1,arr1-target)){\\n    //  List<Integer> arr2=new ArrayList<>();\\n    //  arr2.add(i);\\n    //  arr2.add(j);\\n    //  arr2.add(k);\\n    //  arr1.add(arr2);\\n  arr1=map.get(i)+map.get(j)+map.get(k);\\n}\\n            }\\n            }\\n        }\\n        return arr1;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n// plz somebody tell error in my code\\n"
                    },
                    {
                        "username": "Mohamad-Badr",
                        "content": "nums =[-1,2,1,-4]\\ntarget =1\\nOutput\\n-1 // the wrong is here in my IDE it is =2\\nExpected\\n2\\nin this test case, it gave me the output as -1 but I tested the code and the result with my IDE and the result was 2, not -1 so my code is right and there is a wrong in the test case of this case I don\\'t the why."
                    },
                    {
                        "username": "cosh_7411",
                        "content": "I got wrong test case.How is 2 nearer to -100 than 1??\\nnums =[1,1,1,0]\\ntarget =-100\\nOutput\\n1\\nExpected\\n2\\n\\nmore over for list with len 1 I tried list1[0] it gave index out error.\\n"
                    },
                    {
                        "username": "akm07",
                        "content": "the answer must be a sum of 3 numbers from the array 0+1+1"
                    },
                    {
                        "username": "vishal1810",
                        "content": "leetcode accepts only case sensitive solutions,\\nso remember to use curly braces.\\nwe can solve it by two approaches \\n   1) Bruttle force appr (T.C = O(n^3))\\n   2) Two pointers appr(T.C = O(n^2))"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and c programming.\\n[https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\n\\n\\nhttps://zeroplusfour.com/3sum-closest-leetcode-solution/"
                    },
                    {
                        "username": "Roshan_kumar_",
                        "content": "nums =[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2\\nOutput= -1\\nExpected = -2\\nwhy it is giving me the wrong answer \\n"
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The expected answer is indeed -2 because by taking the triplet (-5, 0, 3) and by adding them, it gives the output -2"
                    },
                    {
                        "username": "Raj_Gurjar",
                        "content": "nums =\\n[4,0,5,3,3,0,-4]\\ntarget =\\n-2\\nOutput\\n-4\\nExpected\\n-1\\n\\n\\nis the above test case correct ? I think it is wrong."
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The testcase is correct.\n\nThe result -1 is obtained by adding 0, 3 and -4 together; and the result -1 is closer to the target that is -2 than the result -4"
                    }
                ]
            }
        ]
    },
    {
        "title": "Populating Next Right Pointers in Each Node",
        "question_content": "<p>You are given a <strong>perfect binary tree</strong> where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:</p>\n\n<pre>\nstruct Node {\n  int val;\n  Node *left;\n  Node *right;\n  Node *next;\n}\n</pre>\n\n<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p>\n\n<p>Initially, all next pointers are set to <code>NULL</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/02/14/116_sample.png\" style=\"width: 500px; height: 171px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3,4,5,6,7]\n<strong>Output:</strong> [1,#,2,3,#,4,5,6,7,#]\n<strong>Explanation: </strong>Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with &#39;#&#39; signifying the end of each level.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 2<sup>12</sup> - 1]</code>.</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow-up:</strong></p>\n\n<ul>\n\t<li>You may only use constant extra space.</li>\n\t<li>The recursive approach is fine. You may assume implicit stack space does not count as extra space for this problem.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 37472,
                "title": "a-simple-accepted-solution",
                "content": "    void connect(TreeLinkNode *root) {\\n        if (root == NULL) return;\\n        TreeLinkNode *pre = root;\\n        TreeLinkNode *cur = NULL;\\n        while(pre->left) {\\n            cur = pre;\\n            while(cur) {\\n                cur->left->next = cur->right;\\n                if(cur->next) cur->right->next = cur->next->left;\\n                cur = cur->next;\\n            }\\n            pre = pre->left;\\n        }\\n    }\\nyou need two additional pointer.",
                "solutionTags": [],
                "code": "    void connect(TreeLinkNode *root) {\\n        if (root == NULL) return;\\n        TreeLinkNode *pre = root;\\n        TreeLinkNode *cur = NULL;\\n        while(pre->left) {\\n            cur = pre;\\n            while(cur) {\\n                cur->left->next = cur->right;\\n                if(cur->next) cur->right->next = cur->next->left;\\n                cur = cur->next;\\n            }\\n            pre = pre->left;\\n        }\\n    }\\nyou need two additional pointer.",
                "codeTag": "Unknown"
            },
            {
                "id": 1654181,
                "title": "c-python-java-simple-solution-w-images-explanation-bfs-dfs-o-1-optimized-bfs",
                "content": "We are given a perfect binary tree and we need to populate next pointers in each node of the tree\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - I (BFS - Right to Left)***\\n\\nIt\\'s important to see that the given tree is a **perfect binary tree**. This means that each node will always have both children and only the last level of nodes will have no children.\\n\\n<p align=middle><img src=https://assets.leetcode.com/uploads/2019/02/14/116_sample.png width=500 />\\n\\nNow, we need to populate next pointers of each node with nodes that occur to its immediate right on the same level. This can easily be done with BFS. Since for each node, we require the right node on the same level, we will perform a **right-to-left BFS** instead of the standard left-to-right BFS.\\n\\nBefore starting the traversal of each level, we would initialize a `rightNode` variable set to NULL. Then, since we are performing right-to-left BFS, we would be starting at rightmost node of each level. We set the next node of `cur` as `rightNode` and update `rightNode = cur`. This would ensure that each node would be assigned its `rightNode` properly while traversing from right to left. \\nAlso, if `cur` has a child, we would first push its right child and only then its left child (since we are doing right-to-left BFS). Once BFS is completed (after queue becomes empty), all next node would be populated and we can finally return `root`.\\n\\nThe process is illustrated below -\\n\\n<table>\\n<tr>\\n<td colspan=4>\\n<p align=middle>\\n<img src=https://assets.leetcode.com/users/images/01e68f51-4905-4f58-b2dd-061aa64c8a91_1640764834.4913242.png width=350   />\\n</p>\\n</td>\\n</tr>\\n\\n<tr></tr>\\n\\n<tr>\\n<td colspan=4>\\n<p align=middle>\\n<img src=https://assets.leetcode.com/users/images/e2a49b2c-1493-4e3f-bb36-28b89153bf73_1640768916.6068268.png  width=350  />\\n<img src=https://assets.leetcode.com/users/images/67ff2271-2b5d-4b5f-8e31-6e14809146ad_1640765277.2783518.png  width=350   />\\n</p>\\n</td>\\n\\n</tr>\\n\\n<tr></tr>\\n\\n<tr>\\n<td colspan=4>\\n<p align=middle>\\n<img src=https://assets.leetcode.com/users/images/e1067d5d-3c94-4efc-b202-f4d18b93a0ac_1640765388.5706594.png  width=350  />\\n<img src=https://assets.leetcode.com/users/images/d8a07cf0-aa8c-44b9-ab35-98a2e1422d43_1640765420.4366648.png  width=350  />\\n<img src=https://assets.leetcode.com/users/images/ce1046fb-3212-46a5-b2f7-445ab32df816_1640765451.180103.png  width=350  />\\n<img src=https://assets.leetcode.com/users/images/bd5a4aff-19fe-4aad-b4e6-5dee5156536f_1640765483.7865818.png  width=350  />\\n</p>\\n\\n</tr>\\n\\n</table>\\n\\n\\n\\n\\n\\n\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root) return nullptr;\\n        queue<Node*> q;\\n        q.push(root);        \\n        while(size(q)) {\\n            Node* rightNode = nullptr;                    // set rightNode to null initially\\n            for(int i = size(q); i; i--) {                // traversing each level\\n                auto cur = q.front(); q.pop();            // pop a node from current level and,\\n                cur -> next = rightNode;                  // set its next pointer to rightNode\\n                rightNode = cur;                          // update rightNode as cur for next iteration\\n                if(cur -> right)                          // if a child exists\\n                    q.push(cur -> right),                 // IMP: push right first to do right-to-left BFS\\n                    q.push(cur -> left);                  // then push left\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def connect(self, root):\\n        if not root: return None\\n        q = deque([root])\\n        while q:\\n            rightNode = None\\n            for _ in range(len(q)):\\n                cur = q.popleft()\\n                cur.next, rightNode = rightNode, cur\\n                if cur.right:\\n                    q.extend([cur.right, cur.left])\\n        return root\\n```\\n\\n**Java**\\n```java\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return null;\\n        Queue<Node> q = new LinkedList<>();\\n        q.offer(root);\\n        while(!q.isEmpty()) {\\n            Node rightNode = null;\\n            for(int i = q.size(); i > 0; i--) {\\n                Node cur = q.poll();\\n                cur.next = rightNode;\\n                rightNode = cur;\\n                if(cur.right != null) {\\n                    q.offer(cur.right);\\n                    q.offer(cur.left);\\n                }\\n            }\\n        }\\n        return root;        \\n    }\\n}\\n```\\n\\n***Time Complexity :*** `O(N)`, where `N` is the number of nodes in the given tree. We only traverse the tree once using BFS which  requires `O(N)`.\\n***Space Complexity :*** `O(W) = O(N)`, where `W` is the width of given tree. This is required to store the nodes in queue. Since the given tree is a perfect binary tree, its width is given as `W = (N+1)/2 \\u2248 O(N)`\\n\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (DFS)***\\n\\nWe can also populate the next pointers recursively using DFS. This is slightly different logic than above but relies on the fact that the given tree is a perfect binary tree.\\n\\nIn the above solution, we had access to right nodes since we traversed in level-order. But in DFS, once we go to the next level, we cant get access to right node. So, we must update next pointers of the child of each node from the its parent\\'s level itself. Thus at each recursive call -\\n* If child node exists:\\n\\t* assign next of left child node as right child node: `root -> left -> next = root -> right`. Note that, if once child exists, the other exists as well.\\n\\t* assign next of right child node as left child of root\\'s next (if root\\'s next exists): `root -> right -> next = root -> next -> left`. \\n\\t**How?** We need right immediate node of right child. This wont exist if current root\\'s next node doesnt exists. If next node of current root is present (the next pointer of root would already be populated in above level) , the right immediate node of root\\'s right child must be root\\'s next\\'s left child because if child of root exists, then the child of root\\'s next must also exist.\\n\\n* If child node doesn\\'t exist, we have reached the last level, we can directly return since there\\'s no child nodes to populate their next pointers\\n\\nThe process is very similar to the one illustrated in the image below with just the difference that we are traversing with DFS instead of BFS shown below.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root) return nullptr;\\n        auto L = root -> left, R = root -> right, N = root -> next;\\n        if(L) {\\n            L -> next = R;                                // next of root\\'s left is assigned as root\\'s right\\n            if(N) R -> next = N -> left;                  // next of root\\'s right is assigned as root\\'s next\\'s left (if root\\'s next exist)\\n            connect(L);                                   // recurse left  - simple DFS \\n            connect(R);                                   // recurse right\\n        }\\n        return root;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def connect(self, root):\\n        if not root: return None\\n        L, R, N = root.left, root.right, root.next\\n        if L:\\n            L.next = R\\n            if N: R.next = N.left\\n            self.connect(L)\\n            self.connect(R)\\n        return root\\n```\\n\\n**Java**\\n```java\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return null;\\n        Node L = root.left, R = root.right, N = root.next;\\n        if(L != null) {\\n            L.next = R;\\n            if(N != null) R.next = N.left;\\n            connect(L);\\n            connect(R);\\n        }\\n        return root;\\n    }\\n}\\n```\\n\\n***Time Complexity :*** `O(N)`, each node is only traversed once\\n***Space Complexity :*** `O(logN)`, required for recursive stack. The maximum depth of recursion is equal to the height of tree which in this case of perfect binary tree is equal to `O(logN)`\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (BFS - Space-Optimized Appraoch)***\\n\\nThis is a combination of logic of above logics- we will traverse in BFS manner but populate the next pointers of bottom level just as we did in the DFS solution.\\n\\nUsually standard DFS/BFS takes `O(N)` space, but since we are given the next pointers in each node, we can use them to space-optimize our traversal to `O(1)`. \\n* We first populate the next pointers of child nodes of current level. This makes it possible to traverse the next level without using a queue. To populate next pointers of child, the exact same logic as above is used\\n* We simply traverse to root\\'s left child and repeat the process - traverse current level, fill next pointers of child nodes and then again update `root = root -> left`. So, we are basically performing standard BFS traversal in `O(1)` space by using next pointers to our advantage\\n* The process continues till we reach the last level of tree\\n\\n\\nThe process is illustrated in images below -\\n\\n\\n<table>\\n  <tr>\\n    <th>Image</th>\\n    <th>Description</th>\\n  </tr>\\n  \\n  <tr>\\n    <td><img src=https://assets.leetcode.com/users/images/b681da39-4c99-4e52-8cb8-779583022898_1640761933.124148.png  width=500 /></td>\\n    <td>We start with a perfect binary tree with all next pointers initially NULL</td>\\n  </tr>\\n  \\n  <tr></tr>\\n  \\n  <tr>\\n    <td>\\n<img src=https://assets.leetcode.com/users/images/ebbbfada-bd94-4432-ac4b-e0326fc34fd4_1640761979.3636644.png  width=500 /></td>\\n    <td>We start traversal level-by-level, from left to right on each level</br>\\n\\t\\n```cpp\\ncur = root\\n```\\t\\n\\nEvery iteration, the next pointers of a node\\'s child will be updated</br> \\n\\n```cpp\\nif(cur -> left) {\\n\\tcur -> left -> next = cur -> right;\\n\\tif(cur -> next) cur -> right -> next = cur -> next -> left;\\n}\\n```\\n\\n</td>\\n\\n  </tr>\\n  \\n  <tr></tr>\\n  \\n  <tr>\\n    <td><img src=https://assets.leetcode.com/users/images/4935430e-af1b-4fe1-9fc7-c5d35be45b90_1640761999.0506494.png  width=500 /></td>\\n    <td>Move to next level</br>\\n\\n```cpp\\nroot = root -> left\\n// next iteration\\ncur = root\\n```\\n\\n& repeat:</br>\\n\\t\\n```cpp\\nif(cur -> left) {\\n\\tcur -> left -> next = cur -> right;\\n\\tif(cur -> next) cur -> right -> next = cur -> next -> left;\\n}\\n```\\n\\t\\n</td>\\n  </tr>\\n  \\n  <tr></tr>\\n  \\n  <tr>\\n    <td><img src=https://assets.leetcode.com/users/images/9ada5f9e-34f7-4c0b-b513-2bd6ff758cbc_1640762014.5024235.png  width=500 /></td>\\n    <td>Continue the same process with all nodes on current level</br>\\n\\t\\n```cpp\\nfor(; cur; cur = cur -> next)\\n    // ...\\n```\\n\\t\\n</td>\\n  </tr>\\n  \\n  <tr></tr>\\n  \\n  <tr>\\n    <td><img src=https://assets.leetcode.com/users/images/8656dc5e-93fb-4260-87a7-a2261171b70d_1640762030.292751.png  width=500 /></td>\\n    <td>No child node exists</br>\\n\\n```cpp\\nif(cur -> left)\\n    // ...\\nelse break\\n```\\n\\nSo, we break here. On the next iteration, root becomes NULL as well and we stop the process.\\n</td>\\n  </tr>\\n</table>\\n\\n\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        auto head = root;\\n        for(; root; root = root -> left) \\n            for(auto cur = root; cur; cur = cur -> next)   // traverse each level - it\\'s just BFS taking advantage of next pointers          \\n                if(cur -> left) {                          // update next pointers of children if they exist               \\n                    cur -> left -> next = cur -> right;\\n                    if(cur -> next) cur -> right -> next = cur -> next -> left;\\n                }\\n                else break;                                // if no children exist, stop iteration                                                  \\n        \\n        return head;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def connect(self, root):\\n        head = root\\n        while root:\\n            cur, root = root, root.left\\n            while cur:\\n                if cur.left:\\n                    cur.left.next = cur.right\\n                    if cur.next: cur.right.next = cur.next.left\\n                else: break\\n                cur = cur.next\\n                \\n        return head\\n```\\n\\n**Java**\\n```java\\nclass Solution {\\n    public Node connect(Node root) {\\n        Node head = root;\\n        for(; root != null; root = root.left) \\n            for(Node cur = root; cur != null; cur = cur.next) \\n                if(cur.left != null) {\\n                    cur.left.next = cur.right;\\n                    if(cur.next != null) cur.right.next = cur.next.left;\\n                } else break;\\n        \\n        return head;\\n    }\\n}\\n```\\n\\n***Time Complexity :*** `O(N)`, we only traverse each node once, basically doing a standard BFS.\\n***Space Complexity :*** `O(1)`, only constant extra space is being used\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root) return nullptr;\\n        queue<Node*> q;\\n        q.push(root);        \\n        while(size(q)) {\\n            Node* rightNode = nullptr;                    // set rightNode to null initially\\n            for(int i = size(q); i; i--) {                // traversing each level\\n                auto cur = q.front(); q.pop();            // pop a node from current level and,\\n                cur -> next = rightNode;                  // set its next pointer to rightNode\\n                rightNode = cur;                          // update rightNode as cur for next iteration\\n                if(cur -> right)                          // if a child exists\\n                    q.push(cur -> right),                 // IMP: push right first to do right-to-left BFS\\n                    q.push(cur -> left);                  // then push left\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def connect(self, root):\\n        if not root: return None\\n        q = deque([root])\\n        while q:\\n            rightNode = None\\n            for _ in range(len(q)):\\n                cur = q.popleft()\\n                cur.next, rightNode = rightNode, cur\\n                if cur.right:\\n                    q.extend([cur.right, cur.left])\\n        return root\\n```\n```java\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return null;\\n        Queue<Node> q = new LinkedList<>();\\n        q.offer(root);\\n        while(!q.isEmpty()) {\\n            Node rightNode = null;\\n            for(int i = q.size(); i > 0; i--) {\\n                Node cur = q.poll();\\n                cur.next = rightNode;\\n                rightNode = cur;\\n                if(cur.right != null) {\\n                    q.offer(cur.right);\\n                    q.offer(cur.left);\\n                }\\n            }\\n        }\\n        return root;        \\n    }\\n}\\n```\n```cpp\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root) return nullptr;\\n        auto L = root -> left, R = root -> right, N = root -> next;\\n        if(L) {\\n            L -> next = R;                                // next of root\\'s left is assigned as root\\'s right\\n            if(N) R -> next = N -> left;                  // next of root\\'s right is assigned as root\\'s next\\'s left (if root\\'s next exist)\\n            connect(L);                                   // recurse left  - simple DFS \\n            connect(R);                                   // recurse right\\n        }\\n        return root;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def connect(self, root):\\n        if not root: return None\\n        L, R, N = root.left, root.right, root.next\\n        if L:\\n            L.next = R\\n            if N: R.next = N.left\\n            self.connect(L)\\n            self.connect(R)\\n        return root\\n```\n```java\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return null;\\n        Node L = root.left, R = root.right, N = root.next;\\n        if(L != null) {\\n            L.next = R;\\n            if(N != null) R.next = N.left;\\n            connect(L);\\n            connect(R);\\n        }\\n        return root;\\n    }\\n}\\n```\n```cpp\\ncur = root\\n```\n```cpp\\nif(cur -> left) {\\n\\tcur -> left -> next = cur -> right;\\n\\tif(cur -> next) cur -> right -> next = cur -> next -> left;\\n}\\n```\n```cpp\\nroot = root -> left\\n// next iteration\\ncur = root\\n```\n```cpp\\nif(cur -> left) {\\n\\tcur -> left -> next = cur -> right;\\n\\tif(cur -> next) cur -> right -> next = cur -> next -> left;\\n}\\n```\n```cpp\\nfor(; cur; cur = cur -> next)\\n    // ...\\n```\n```cpp\\nif(cur -> left)\\n    // ...\\nelse break\\n```\n```cpp\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        auto head = root;\\n        for(; root; root = root -> left) \\n            for(auto cur = root; cur; cur = cur -> next)   // traverse each level - it\\'s just BFS taking advantage of next pointers          \\n                if(cur -> left) {                          // update next pointers of children if they exist               \\n                    cur -> left -> next = cur -> right;\\n                    if(cur -> next) cur -> right -> next = cur -> next -> left;\\n                }\\n                else break;                                // if no children exist, stop iteration                                                  \\n        \\n        return head;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def connect(self, root):\\n        head = root\\n        while root:\\n            cur, root = root, root.left\\n            while cur:\\n                if cur.left:\\n                    cur.left.next = cur.right\\n                    if cur.next: cur.right.next = cur.next.left\\n                else: break\\n                cur = cur.next\\n                \\n        return head\\n```\n```java\\nclass Solution {\\n    public Node connect(Node root) {\\n        Node head = root;\\n        for(; root != null; root = root.left) \\n            for(Node cur = root; cur != null; cur = cur.next) \\n                if(cur.left != null) {\\n                    cur.left.next = cur.right;\\n                    if(cur.next != null) cur.right.next = cur.next.left;\\n                } else break;\\n        \\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 37461,
                "title": "java-solution-with-o-1-memory-o-n-time",
                "content": "\\n\\n    public class Solution {\\n        public void connect(TreeLinkNode root) {\\n            TreeLinkNode level_start=root;\\n            while(level_start!=null){\\n                TreeLinkNode cur=level_start;\\n                while(cur!=null){\\n                    if(cur.left!=null) cur.left.next=cur.right;\\n                    if(cur.right!=null && cur.next!=null) cur.right.next=cur.next.left;\\n                    \\n                    cur=cur.next;\\n                }\\n                level_start=level_start.left;\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public void connect(TreeLinkNode root) {\\n            TreeLinkNode level_start=root;\\n            while(level_start!=null){\\n                TreeLinkNode cur=level_start;\\n                while(cur!=null){\\n                    if(cur.left!=null) cur.left.next=cur.right;\\n                    if(cur.right!=null && cur.next!=null) cur.right.next=cur.next.left;\\n                    \\n                    cur=cur.next;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 37484,
                "title": "7-lines-iterative-real-o-1-space",
                "content": "Simply do it level by level, using the `next`-pointers of the current level to go through the current level and set the `next`-pointers of the next level.\\n\\nI say \"real\" O(1) space because of the many recursive solutions ignoring that recursion management needs space.\\n\\n    def connect(self, root):\\n        while root and root.left:\\n            next = root.left\\n            while root:\\n                root.left.next = root.right\\n                root.right.next = root.next and root.next.left\\n                root = root.next\\n            root = next",
                "solutionTags": [
                    "Python"
                ],
                "code": "Simply do it level by level, using the `next`-pointers of the current level to go through the current level and set the `next`-pointers of the next level.\\n\\nI say \"real\" O(1) space because of the many recursive solutions ignoring that recursion management needs space.\\n\\n    def connect(self, root):\\n        while root and root.left:\\n            next = root.left\\n            while root:\\n                root.left.next = root.right\\n                root.right.next = root.next and root.next.left\\n                root = root.next\\n            root = next",
                "codeTag": "Python3"
            },
            {
                "id": 37473,
                "title": "my-recursive-solution-java",
                "content": "\\n    public void connect(TreeLinkNode root) {\\n        if(root == null)\\n            return;\\n            \\n        if(root.left != null){\\n            root.left.next = root.right;\\n            if(root.next != null)\\n                root.right.next = root.next.left;\\n        }\\n        \\n        connect(root.left);\\n        connect(root.right);\\n    }",
                "solutionTags": [],
                "code": "\\n    public void connect(TreeLinkNode root) {\\n        if(root == null)\\n            return;\\n            \\n        if(root.left != null){\\n            root.left.next = root.right;\\n            if(root.next != null)\\n                root.right.next = root.next.left;\\n        }\\n        \\n        connect(root.left);\\n        connect(root.right);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 37578,
                "title": "my-simple-non-iterative-c-code-with-o-1-memory",
                "content": "    void connect(TreeLinkNode *root) {\\n        if(!root)\\n            return;\\n        while(root -> left)\\n        {\\n            TreeLinkNode *p = root;\\n            while(p)\\n            {\\n                p -> left -> next = p -> right;\\n                if(p -> next)\\n                    p -> right -> next = p -> next -> left;\\n                p = p -> next;\\n            }\\n            root = root -> left;\\n        }\\n    }",
                "solutionTags": [],
                "code": "    void connect(TreeLinkNode *root) {\\n        if(!root)\\n            return;\\n        while(root -> left)\\n        {\\n            TreeLinkNode *p = root;\\n            while(p)\\n            {\\n                p -> left -> next = p -> right;\\n                if(p -> next)\\n                    p -> right -> next = p -> next -> left;\\n                p = p -> next;\\n            }\\n            root = root -> left;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1653846,
                "title": "c-easy-to-solve-beginner-friendly-with-detailed-explanations-and-dry-run",
                "content": "> # **Behold the legendary battle between Recursive and Interative Approaches** \\n***\\n***Fight!!!***\\n***\\n**Intuition:-**\\n* We are given a prefect binary tree that means every parent has two children and all the    leaves are on the same level . \\n* This question is an superior version of binary level order traversal .\\n* In level order traversal you will traverse each level of binary tree while outputting the data in that form . So the only difference is that somehow we need to connect the previous levels rightmost node to the next level\\'s leftmost node and that\\'s it .\\n\\n**Algorithm:-**\\n1. Base case: if the root is null than return null\\n2. Now to connect the left subtree of same level with right subtree of that level \\n3. The only new line that differentiate from level order traversing is that we need to connect the rightmost node of a level to the leftmost node of the next level.\\n4. Now just repeat the steps over and over for every level of tree . \\n\\n![image](https://assets.leetcode.com/users/images/6a41f9e5-3ba0-4116-ac09-f7e4a4bfdb19_1640748379.9406984.png) *Image credit goes to @Stargarth*\\n\\n**We can code this approach by two methods:**\\n1. By recursive \\n2. Iterative\\n<mark>Both solution has time complexity and space complexity as O(n) and O(1) in a virtual manner but if we consider in a true sense than in recursion we use a recursive stack which has some space complexity .<mark>\\nSo in a real sense the iterative solution is the best since it has truly O(1) space complexity .\\n***\\n**Recursive Approach Code:-**\\n```\\n//Upvote and Comment \\n\\nclass Solution {\\npublic:\\nNode* connect(Node* root) {\\n    //base case\\n    if(root == NULL) return NULL;\\n    //connects the left subtree of same level with right subtree of that same level \\n    if(root->left != NULL) root->left->next = root->right;\\n    //connect the rightmost node of a level to the leftmost node of the next level.\\n    if(root->right != NULL && root->next != NULL) root->right->next = root->next->left;\\n    //recursive calls for left and right subtrees.\\n    connect(root->left);\\n    connect(root->right);\\n    return root;\\n   }\\n};\\n```\\n***\\n**Iterative Approach:-**\\nIn iterative approach we will be needing two more pointers named as `curr` and `prev` for linking of left and right nodes\\n```\\n//Upvote and Comment\\n\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        //Initialize pointers\\n        Node *prev = root, *curr;\\n        while (prev) {\\n            curr = prev;\\n            while (curr && curr->left) { \\n                //connects the left subtree of same level with right subtree of that same level \\n                curr->left->next = curr->right;\\n                //connect the rightmost node of a level to the leftmost node of the next level.\\n                if (curr -> next) curr->right->next = curr->next->left;\\n                curr = curr->next;\\n            }\\n            prev = prev -> left;\\n        }\\n        return root;\\n    }\\n};\\n```\\n**That was a intense battle and the winner is our iterative approach!!!** \\uD83C\\uDF8A\\uD83C\\uDF8A\\n***\\n\\n***\\n\\n**[My Github Repo](https://github.com/Jatin-Shihora/LeetCode-Solutions) where I keep track of my solutions :)))**\\n\\n***\\n\\n\\n>**Feel free to comment or upvote if you liked my post ;)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n//Upvote and Comment \\n\\nclass Solution {\\npublic:\\nNode* connect(Node* root) {\\n    //base case\\n    if(root == NULL) return NULL;\\n    //connects the left subtree of same level with right subtree of that same level \\n    if(root->left != NULL) root->left->next = root->right;\\n    //connect the rightmost node of a level to the leftmost node of the next level.\\n    if(root->right != NULL && root->next != NULL) root->right->next = root->next->left;\\n    //recursive calls for left and right subtrees.\\n    connect(root->left);\\n    connect(root->right);\\n    return root;\\n   }\\n};\\n```\n```\\n//Upvote and Comment\\n\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        //Initialize pointers\\n        Node *prev = root, *curr;\\n        while (prev) {\\n            curr = prev;\\n            while (curr && curr->left) { \\n                //connects the left subtree of same level with right subtree of that same level \\n                curr->left->next = curr->right;\\n                //connect the rightmost node of a level to the leftmost node of the next level.\\n                if (curr -> next) curr->right->next = curr->next->left;\\n                curr = curr->next;\\n            }\\n            prev = prev -> left;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 37715,
                "title": "python-solutions-recursively-bfs-queue-dfs-stack",
                "content": "    def connect1(self, root):\\n        if root and root.left and root.right:\\n            root.left.next = root.right\\n            if root.next:\\n                root.right.next = root.next.left\\n            self.connect(root.left)\\n            self.connect(root.right)\\n     \\n    # BFS       \\n    def connect2(self, root):\\n        if not root:\\n            return \\n        queue = [root]\\n        while queue:\\n            curr = queue.pop(0)\\n            if curr.left and curr.right:\\n                curr.left.next = curr.right\\n                if curr.next:\\n                    curr.right.next = curr.next.left\\n                queue.append(curr.left)\\n                queue.append(curr.right)\\n        \\n    # DFS \\n    def connect(self, root):\\n        if not root:\\n            return \\n        stack = [root]\\n        while stack:\\n            curr = stack.pop()\\n            if curr.left and curr.right:\\n                curr.left.next = curr.right\\n                if curr.next:\\n                    curr.right.next = curr.next.left\\n                stack.append(curr.right)\\n                stack.append(curr.left)",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "    def connect1(self, root):\\n        if root and root.left and root.right:\\n            root.left.next = root.right\\n            if root.next:\\n                root.right.next = root.next.left\\n            self.connect(root.left)\\n            self.connect(root.right)\\n     \\n    # BFS       \\n    def connect2(self, root):\\n        if not root:\\n            return \\n        queue = [root]\\n        while queue:\\n            curr = queue.pop(0)\\n            if curr.left and curr.right:\\n                curr.left.next = curr.right\\n                if curr.next:\\n                    curr.right.next = curr.next.left\\n                queue.append(curr.left)\\n                queue.append(curr.right)\\n        \\n    # DFS \\n    def connect(self, root):\\n        if not root:\\n            return \\n        stack = [root]\\n        while stack:\\n            curr = stack.pop()\\n            if curr.left and curr.right:\\n                curr.left.next = curr.right\\n                if curr.next:\\n                    curr.right.next = curr.next.left\\n                stack.append(curr.right)\\n                stack.append(curr.left)",
                "codeTag": "Python3"
            },
            {
                "id": 37465,
                "title": "python-solution-with-explaintion",
                "content": "I want to share how I come up with this solution with you:\\n\\nSince we are manipulating tree nodes on the same level, it's easy to come up with\\na very standard BFS solution using  queue.  But because of next pointer, we actually\\ndon't  need a queue to store the order of tree nodes at each level, we just use a next\\npointer like it's a link list at each level;  In addition, we can borrow the idea used  in\\nthe Binary Tree level order traversal problem, which use cur and next pointer to store \\nfirst node at each level; we exchange cur and next every time when cur is the last node\\nat each level. \\n\\n\\n      class Solution(object):\\n        def connect(self, root):\\n            \"\"\"\\n            :type root: TreeLinkNode\\n            :rtype: nothing\\n            \"\"\"\\n            \\n            if not root:\\n                return None\\n            cur  = root\\n            next = root.left\\n    \\n            while cur.left :\\n                cur.left.next = cur.right\\n                if cur.next:\\n                    cur.right.next = cur.next.left\\n                    cur = cur.next\\n                else:\\n                    cur = next\\n                    next = cur.left",
                "solutionTags": [
                    "Python"
                ],
                "code": "I want to share how I come up with this solution with you:\\n\\nSince we are manipulating tree nodes on the same level, it's easy to come up with\\na very standard BFS solution using  queue.  But because of next pointer, we actually\\ndon't  need a queue to store the order of tree nodes at each level, we just use a next\\npointer like it's a link list at each level;  In addition, we can borrow the idea used  in\\nthe Binary Tree level order traversal problem, which use cur and next pointer to store \\nfirst node at each level; we exchange cur and next every time when cur is the last node\\nat each level. \\n\\n\\n      class Solution(object):\\n        def connect(self, root):\\n            \"\"\"\\n            :type root: TreeLinkNode\\n            :rtype: nothing\\n            \"\"\"\\n            \\n            if not root:\\n                return None\\n            cur  = root\\n            next = root.left\\n    \\n            while cur.left :\\n                cur.left.next = cur.right\\n                if cur.next:\\n                    cur.right.next = cur.next.left\\n                    cur = cur.next\\n                else:\\n                    cur = next\\n                    next = cur.left",
                "codeTag": "Java"
            },
            {
                "id": 37503,
                "title": "c-iterative-recursive",
                "content": "**Recursive**\\n\\nSimilar to a level-order traversal, even you are not allowed to use a `queue`, the `next` pointer provides you with a way to move to the next node in the same level.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        Node *pre = root, *cur;\\n        while (pre) {\\n            cur = pre;\\n            while (cur && cur -> left) { \\n                cur -> left -> next = cur -> right;\\n                if (cur -> next) {\\n                    cur -> right -> next = cur -> next -> left;\\n                }\\n                cur = cur -> next;\\n            }\\n            pre = pre -> left;\\n        }\\n        return root;\\n    }\\n};\\n```\\n\\n**Recursive**\\n\\nRecursively connect the left and right subtrees.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if (!root) {\\n            return NULL;\\n        }\\n        if (root -> left) {\\n            root -> left -> next = root -> right;\\n            if (root -> next) {\\n                root -> right -> next = root -> next -> left;\\n            }\\n            connect(root -> left);\\n            connect(root -> right);\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        Node *pre = root, *cur;\\n        while (pre) {\\n            cur = pre;\\n            while (cur && cur -> left) { \\n                cur -> left -> next = cur -> right;\\n                if (cur -> next) {\\n                    cur -> right -> next = cur -> next -> left;\\n                }\\n                cur = cur -> next;\\n            }\\n            pre = pre -> left;\\n        }\\n        return root;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if (!root) {\\n            return NULL;\\n        }\\n        if (root -> left) {\\n            root -> left -> next = root -> right;\\n            if (root -> next) {\\n                root -> right -> next = root -> next -> left;\\n            }\\n            connect(root -> left);\\n            connect(root -> right);\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 962728,
                "title": "java-0ms-with-visual-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/a3197575-43d6-474a-b6b7-f7005723828e_1607299930.3256361.png)\\n\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return null;\\n        if(root.left != null) root.left.next = root.right;\\n        if(root.right != null && root.next != null) root.right.next = root.next.left;\\n        connect(root.left);\\n        connect(root.right);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return null;\\n        if(root.left != null) root.left.next = root.right;\\n        if(root.right != null && root.next != null) root.right.next = root.next.left;\\n        connect(root.left);\\n        connect(root.right);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 934111,
                "title": "c-bfs-iterative-queue",
                "content": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* left;\\n    Node* right;\\n    Node* next;\\n\\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val, Node* _left, Node* _right, Node* _next)\\n        : val(_val), left(_left), right(_right), next(_next) {}\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root)return root;\\n        queue<Node*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int n=q.size();\\n            for(int i=0;i<n;i++){\\n                Node* x=q.front();\\n                q.pop();\\n                if(i!=n-1)x->next=q.front();\\n                if(x->left)q.push(x->left);\\n                if(x->right)q.push(x->right);\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* left;\\n    Node* right;\\n    Node* next;\\n\\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val, Node* _left, Node* _right, Node* _next)\\n        : val(_val), left(_left), right(_right), next(_next) {}\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root)return root;\\n        queue<Node*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int n=q.size();\\n            for(int i=0;i<n;i++){\\n                Node* x=q.front();\\n                q.pop();\\n                if(i!=n-1)x->next=q.front();\\n                if(x->left)q.push(x->left);\\n                if(x->right)q.push(x->right);\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1654101,
                "title": "python-two-solutions-bfs-and-dfs-image-explanation-beginner-friendly",
                "content": "**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.** \\n* **Solution 1**\\n\\t* Standard BFS with mantaining `pre_level` and `pre_node` as the previous node in BFS sequence\\n\\t\\t* `level == pre_level` means current `node` is not the first node of `level`, then `pre_node.next = node` and update `pre_node = node`\\n\\t\\t* `else` means `pre_level < level` and `node` is the first node of `level`, then no need to update `pre_node.next`, leave it as `None`, update `pre_node = node` only.\\n\\t\\t* standard BFS, append `node.left` and `node.right` to the queue\\n\\t```\\n\\tTime  Complexity: O(N)\\n\\tSpace Complexity: O(N)\\n\\t```\\n\\t```\\n\\tclass Solution(object):\\n    def connect(self, root):\\n        if root is None: return None\\n        dq, pre_level, pre_node = deque([(1, root)]), 0, None\\n        while dq:\\n            level, node = dq.popleft()\\n            if level == pre_level:  # current node is not the first node of level\\n                pre_node.next = node\\n                pre_node = node\\n            else:  # pre_level < level and node is the first node of level, then no need to update pre_node.next, \\n                # leave it as None, update pre_node = node only.\\n                pre_level, pre_node = level, node\\n            if node.left:  # root is a perfect binary tree, once left exists, right must also exist\\n                dq.append((level + 1, node.left))\\n                dq.append((level + 1, node.right))\\n        return root\\n\\t```\\n\\n* **Solution 2**\\n\\t* Recursive DFS, the current root node is responsible for linking the nodes on both sides closest to the central axis for all levels.\\n\\t![image](https://assets.leetcode.com/users/images/4e546a8b-d11e-49a9-859d-6c7e5092e8cb_1640762771.0732064.jpeg)\\n\\n\\t\\n\\t```\\n\\tTime  Complexity: O(N)\\n\\tSpace Complexity: O(1)\\n\\t```\\n\\t```\\n\\tclass Solution(object):\\n    def connect(self, root):\\n        if not root: return root\\n        if root.left: \\n            left, right = root.left, root.right\\n            self.connect(left)\\n            self.connect(right)\\n            while left:\\n                left.next = right\\n                left, right = left.right, right.left\\n        return root\\n\\t```\\n\\t\\n**PLEASE UPVOTE if you like \\uD83D\\uDE01 If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n\\tTime  Complexity: O(N)\\n\\tSpace Complexity: O(N)\\n\\t```\n```\\n\\tclass Solution(object):\\n    def connect(self, root):\\n        if root is None: return None\\n        dq, pre_level, pre_node = deque([(1, root)]), 0, None\\n        while dq:\\n            level, node = dq.popleft()\\n            if level == pre_level:  # current node is not the first node of level\\n                pre_node.next = node\\n                pre_node = node\\n            else:  # pre_level < level and node is the first node of level, then no need to update pre_node.next, \\n                # leave it as None, update pre_node = node only.\\n                pre_level, pre_node = level, node\\n            if node.left:  # root is a perfect binary tree, once left exists, right must also exist\\n                dq.append((level + 1, node.left))\\n                dq.append((level + 1, node.right))\\n        return root\\n\\t```\n```\\n\\tTime  Complexity: O(N)\\n\\tSpace Complexity: O(1)\\n\\t```\n```\\n\\tclass Solution(object):\\n    def connect(self, root):\\n        if not root: return root\\n        if root.left: \\n            left, right = root.left, root.right\\n            self.connect(left)\\n            self.connect(right)\\n            while left:\\n                left.next = right\\n                left, right = left.right, right.left\\n        return root\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 934066,
                "title": "python-o-n-time-o-log-n-space-recursion-explained",
                "content": "In this problem we are given that our tree is perfect binary tree, which will help us a lot. Let us use recursion: imagine, that for left and right subtees we already make all connections, what we need to connect now? See the image and it will become very clear: we need to connect just `O(log n)` pairs now: we go the the left and to the right children. Then from left children we go as right as possible and from right children we go as left as possible.\\n\\n![image](https://assets.leetcode.com/users/images/b838445a-d58e-420b-889e-208d6813beec_1605257150.2922277.png)\\n\\n\\n**Complexity**: time complexity can be found, using Master theorem: `F(n) = 2*F(n/2) + log n`, from here `F(n) = O(n)`. Space complexity is `O(log n)`, because we use recursion. Note, that space complexity can be reduced to `O(1)`, because we know the structure of our tree!\\n\\n```\\nclass Solution:\\n    def connect(self, root):\\n        if not root or not root.left: return root\\n        \\n        self.connect(root.left)\\n        self.connect(root.right)\\n        \\n        lft = root.left\\n        rgh = root.right\\n        lft.next = rgh\\n\\n        while lft.right: \\n            lft = lft.right\\n            rgh = rgh.left\\n            lft.next = rgh\\n        \\n        return root\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def connect(self, root):\\n        if not root or not root.left: return root\\n        \\n        self.connect(root.left)\\n        self.connect(root.right)\\n        \\n        lft = root.left\\n        rgh = root.right\\n        lft.next = rgh\\n\\n        while lft.right: \\n            lft = lft.right\\n            rgh = rgh.left\\n            lft.next = rgh\\n        \\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 37603,
                "title": "java-solution-traversing-by-level-without-extra-space",
                "content": "    public class Solution {\\n        public void connect(TreeLinkNode root) {\\n            if(root==null) return;\\n            TreeLinkNode cur = root;\\n            TreeLinkNode nextLeftmost = null;\\n\\n            while(cur.left!=null){\\n                nextLeftmost = cur.left; // save the start of next level\\n                while(cur!=null){\\n                    cur.left.next=cur.right;\\n                    cur.right.next = cur.next==null? null : cur.next.left;\\n                    cur=cur.next;\\n                }\\n                cur=nextLeftmost;  // point to next level \\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public void connect(TreeLinkNode root) {\\n            if(root==null) return;\\n            TreeLinkNode cur = root;\\n            TreeLinkNode nextLeftmost = null;\\n\\n            while(cur.left!=null){\\n                nextLeftmost = cur.left; // save the start of next level\\n                while(cur!=null){\\n                    cur.left.next=cur.right;\\n                    cur.right.next = cur.next==null? null : cur.next.left;\\n                    cur=cur.next;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 420632,
                "title": "javascript-bfs-dfs-solution",
                "content": "#### The Idea - BFS\\n1. BFS using queue\\n2. as we are shifing node, connect it to the next in queue\\n``` javascript\\nvar connectBFS = function(root) {\\n    if (root == null) return root;\\n    let queue = [root];\\n    while(queue.length!=0) {\\n        let next = [];\\n        while(queue.length!=0) {\\n            let node = queue.shift();\\n            node.next = queue[0]||null;\\n            if (node.left!=null) {\\n                next.push(node.left);\\n                next.push(node.right);\\n            }\\n        }\\n        queue = next;\\n    }\\n    return root;\\n};\\n```\\n#### The Idea - DFS\\n1. pre order scan \\n2. set child nodes arrangement before resursion\\n``` javascript\\nvar connect = function(root) {\\n    if (root == null || root.left == null) return root;\\n    root.left.next = root.right;\\n    root.right.next = root.next ? root.next.left:null;\\n    connect(root.left);\\n    connect(root.right);\\n    return root;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\nvar connectBFS = function(root) {\\n    if (root == null) return root;\\n    let queue = [root];\\n    while(queue.length!=0) {\\n        let next = [];\\n        while(queue.length!=0) {\\n            let node = queue.shift();\\n            node.next = queue[0]||null;\\n            if (node.left!=null) {\\n                next.push(node.left);\\n                next.push(node.right);\\n            }\\n        }\\n        queue = next;\\n    }\\n    return root;\\n};\\n```\n``` javascript\\nvar connect = function(root) {\\n    if (root == null || root.left == null) return root;\\n    root.left.next = root.right;\\n    root.right.next = root.next ? root.next.left:null;\\n    connect(root.left);\\n    connect(root.right);\\n    return root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 515985,
                "title": "python-3-approaches-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: BFS**\\n```python\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if root == None: return None\\n\\n        q = deque([root])\\n        while q:\\n            prev = None\\n            for _ in range(len(q)):\\n                curr = q.popleft()\\n                if prev != None:\\n                    prev.next = curr\\n                prev = curr\\n\\n                if curr.left != None:\\n                    q.append(curr.left)\\n                if curr.right != None:\\n                    q.append(curr.right)\\n        return root\\n```\\n**Complexity**\\n- Time: `O(N)`, where `N` is number of nodes in the Perfect Binary Tree.\\n- Space: `O(N/2)`\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 2: DFS**\\n```python\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if root == None: return None\\n        self.connect2Nodes(root.left, root.right)\\n        self.connect(root.left)\\n        self.connect(root.right)\\n        return root\\n        \\n    def connect2Nodes(self, root1, root2):\\n        if root1 == None or root2 == None: return\\n        root1.next = root2\\n        self.connect2Nodes(root1.right, root2.left)\\n```\\n**Complexity**\\n- Time: `O(N)`, where `N` is number of nodes in the Perfect Binary Tree.\\n- Space: `O(logN)`\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 3: Using previously established next pointers**\\n```python\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if root == None: return None\\n        \\n        leftMost = root\\n        while leftMost.left:\\n            head = leftMost\\n            leftMost = head.left\\n            while head:\\n                head.left.next = head.right\\n                if head.next != None:\\n                    head.right.next = head.next.left\\n                head = head.next\\n        return root\\n```\\n**Complexity**\\n- Time: `O(N)`, where `N` is number of nodes in the Perfect Binary Tree.\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if root == None: return None\\n\\n        q = deque([root])\\n        while q:\\n            prev = None\\n            for _ in range(len(q)):\\n                curr = q.popleft()\\n                if prev != None:\\n                    prev.next = curr\\n                prev = curr\\n\\n                if curr.left != None:\\n                    q.append(curr.left)\\n                if curr.right != None:\\n                    q.append(curr.right)\\n        return root\\n```\n```python\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if root == None: return None\\n        self.connect2Nodes(root.left, root.right)\\n        self.connect(root.left)\\n        self.connect(root.right)\\n        return root\\n        \\n    def connect2Nodes(self, root1, root2):\\n        if root1 == None or root2 == None: return\\n        root1.next = root2\\n        self.connect2Nodes(root1.right, root2.left)\\n```\n```python\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if root == None: return None\\n        \\n        leftMost = root\\n        while leftMost.left:\\n            head = leftMost\\n            leftMost = head.left\\n            while head:\\n                head.left.next = head.right\\n                if head.next != None:\\n                    head.right.next = head.next.left\\n                head = head.next\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1195108,
                "title": "bfs-c-iterative-explanation-level-order-traversal",
                "content": "\\nBasically this is purely level order travsersal code with slight modification for the  root -> next value \\n\\nYou just have to think 2 things in this question.\\n\\n1.How to get the last val to NULL ?.\\n2.How to get connect with the current node to previous one ?.\\n\\nIf you are able to find the ans of these two questions mentioned above then you will reach the solution \\nalso if you are here to see the solution i would recommend you to pause for a while \\nand think about these questions i am sure you willl find the ans otherwise ans \\nis just right below you can see anytime you want just give it a though for a whlle.\\n\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n```\\nif(root == NULL) return NULL;\\n        queue<Node*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size = q.size(); // get size of queue \\n            for(int i=0 ; i < size ; i++){\\n                Node* item = q.front(); \\n                if(size - 1 == i) // checking the last value of the level\\n                     item -> next = NULL; \\n                \\n                q.pop();\\n                \\n                if(size - 1 != i) // if this is not the last value then previous value will point to next one\\n                     item -> next = q.front(); \\n                \\n                if(item -> left != NULL)\\n                    q.push(item -> left);\\n                if(item -> right != NULL)\\n                    q.push(item -> right);\\n            }\\n        } \\n        return root; \\n\\t\\t\\n\\n```\\n**In an interview there will be a follow up question in which you might be asked to solve this question with recursion so better be prepared for this bomb !!!!**\\n```\\n\\n\\nBefore you see the solution as per rituals please please please think of a solution by yourself you might be right or wrong doesn\\'t matter you fought hard with the question !!!\\n\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n\\n Node* connect(Node* root) {\\n        if(root == NULL) return NULL;\\n        \\n        //now part-1 - connect Left node with right node\\n        if(root->left!=NULL) root->left->next = root->right;\\n        \\n        //now part-2 - connect right node with next subtree left node\\n        if(root->right!=NULL && root->next!=NULL) root->right->next = root->next->left;\\n        \\n        //Now do the same job for subtrees\\n        connect(root->left); \\n        connect(root->right);\\n        \\n        return root; \\n        // every time return is made, but at last the same root is retured to main\\n    }\\n\\n\\n*** IF YOU LOVED THE SOLUTION PLEASE CLICK ON THE UPVOTE BUTTON ***\\n\\n\\n\\n\\t\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nif(root == NULL) return NULL;\\n        queue<Node*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size = q.size(); // get size of queue \\n            for(int i=0 ; i < size ; i++){\\n                Node* item = q.front(); \\n                if(size - 1 == i) // checking the last value of the level\\n                     item -> next = NULL; \\n                \\n                q.pop();\\n                \\n                if(size - 1 != i) // if this is not the last value then previous value will point to next one\\n                     item -> next = q.front(); \\n                \\n                if(item -> left != NULL)\\n                    q.push(item -> left);\\n                if(item -> right != NULL)\\n                    q.push(item -> right);\\n            }\\n        } \\n        return root; \\n\\t\\t\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 37520,
                "title": "simple-recursive-java-solution-o-1-space-o-n-time",
                "content": "    public void connect(TreeLinkNode root) {\\n        \\n        if(root==null) return ;\\n        \\n        link(root.left,root.right);\\n    }\\n    \\n    //HELPER FUNCTION TO LINK TWO NODES TOGETHER\\n    public void link(TreeLinkNode left, TreeLinkNode right){\\n        \\n        if(left==null && right==null) return ;\\n        \\n        left.next = right;\\n        link(left.left,left.right);\\n        link(left.right,right.left);\\n        link(right.left,right.right);\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "    public void connect(TreeLinkNode root) {\\n        \\n        if(root==null) return ;\\n        \\n        link(root.left,root.right);\\n    }\\n    \\n    //HELPER FUNCTION TO LINK TWO NODES TOGETHER\\n    public void link(TreeLinkNode left, TreeLinkNode right){\\n        \\n        if(left==null && right==null) return ;\\n        \\n        left.next = right;\\n        link(left.left,left.right);\\n        link(left.right,right.left);\\n        link(right.left,right.right);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 379177,
                "title": "python3-bfs-and-dfs",
                "content": "* BFS\\n```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val, left, right, next):\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n        self.next = next\\n\"\"\"\\nfrom collections import deque\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        \"\"\"\\n      1 (1)\\n    2 (2)->    3(1)\\n 4(4) -> 5(3) -> 6(2) -> 7(1)\\n\\n\"\"\"\\n        if root ==  None:\\n            return None\\n        q = deque([root])\\n        while q:  # [1] [3,4,5]\\n            size = len(q) # 1 2\\n            while size > 0: #  > 0\\n                node = q.popleft() # node =1,2,3\\n                if size > 1 :# \\n                    node.next = q[0] #  2.next = 3\\n                size -= 1          # size =1\\n                \\n                if node.left:         \\n                    q.append(node.left)\\n                if node.right:\\n                    q.append(node.right)\\n        return root\\n```\\n* DFS\\n```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val, left, right, next):\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n        self.next = next\\n\"\"\"\\nfrom collections import deque\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        \"\"\"\\n      1 (1)\\n    2 (2)->    3(1)\\n 4(4) -> 5(3) -> 6(2) -> 7(1)\\n\\n\"\"\"\\n        self.dfs(root)\\n        return root\\n    \\n    ## (1). left child -> right child\\n    ## (2). right child -> next.left child\\n    def dfs(self,root):\\n        if root == None or root.left == None:\\n            return\\n        root.left.next = root.right\\n        if root.next != None: \\n            root.right.next = root.next.left\\n        self.dfs(root.left)\\n        self.dfs(root.right)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val, left, right, next):\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n        self.next = next\\n\"\"\"\\nfrom collections import deque\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        \"\"\"\\n      1 (1)\\n    2 (2)->    3(1)\\n 4(4) -> 5(3) -> 6(2) -> 7(1)\\n\\n\"\"\"\\n        if root ==  None:\\n            return None\\n        q = deque([root])\\n        while q:  # [1] [3,4,5]\\n            size = len(q) # 1 2\\n            while size > 0: #  > 0\\n                node = q.popleft() # node =1,2,3\\n                if size > 1 :# \\n                    node.next = q[0] #  2.next = 3\\n                size -= 1          # size =1\\n                \\n                if node.left:         \\n                    q.append(node.left)\\n                if node.right:\\n                    q.append(node.right)\\n        return root\\n```\n```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val, left, right, next):\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n        self.next = next\\n\"\"\"\\nfrom collections import deque\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        \"\"\"\\n      1 (1)\\n    2 (2)->    3(1)\\n 4(4) -> 5(3) -> 6(2) -> 7(1)\\n\\n\"\"\"\\n        self.dfs(root)\\n        return root\\n    \\n    ## (1). left child -> right child\\n    ## (2). right child -> next.left child\\n    def dfs(self,root):\\n        if root == None or root.left == None:\\n            return\\n        root.left.next = root.right\\n        if root.next != None: \\n            root.right.next = root.next.left\\n        self.dfs(root.left)\\n        self.dfs(root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1634140,
                "title": "java-step-by-step-explanation",
                "content": "## Please upvote if this helps! Thx :D\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if (root == null) return null;\\n        connectTwoNodes(root.left, root.right);\\n        return root;\\n    }\\n    \\n    private void connectTwoNodes(Node n1, Node n2){\\n        if (n1 == null || n2 == null) return;\\n        n1.next = n2;\\n        //Connect two child nodes from the same parent node. \\n        connectTwoNodes(n1.left, n1.right);\\n        connectTwoNodes(n2.left, n2.right);\\n        //Connect two child nodes aside from each other but from different parent nodes . \\n        connectTwoNodes(n1.right, n2.left);\\n    } \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if (root == null) return null;\\n        connectTwoNodes(root.left, root.right);\\n        return root;\\n    }\\n    \\n    private void connectTwoNodes(Node n1, Node n2){\\n        if (n1 == null || n2 == null) return;\\n        n1.next = n2;\\n        //Connect two child nodes from the same parent node. \\n        connectTwoNodes(n1.left, n1.right);\\n        connectTwoNodes(n2.left, n2.right);\\n        //Connect two child nodes aside from each other but from different parent nodes . \\n        connectTwoNodes(n1.right, n2.left);\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 934042,
                "title": "java-clean-code-o-n-time-complexity-100-faster-solution",
                "content": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public Node left;\\n    public Node right;\\n    public Node next;\\n\\n    public Node() {}\\n    \\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, Node _left, Node _right, Node _next) {\\n        val = _val;\\n        left = _left;\\n        right = _right;\\n        next = _next;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public Node connect(Node root) {\\n        \\n        if (root == null || root.left == null) {\\n            return root;\\n        }\\n        \\n        root.left.next = root.right;\\n        if (root.next != null) {\\n            root.right.next = root.next.left;\\n        }\\n        \\n        connect (root.left);\\n        connect (root.right);\\n        \\n        return root;\\n    }\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**",
                "solutionTags": [],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public Node left;\\n    public Node right;\\n    public Node next;\\n\\n    public Node() {}\\n    \\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, Node _left, Node _right, Node _next) {\\n        val = _val;\\n        left = _left;\\n        right = _right;\\n        next = _next;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public Node connect(Node root) {\\n        \\n        if (root == null || root.left == null) {\\n            return root;\\n        }\\n        \\n        root.left.next = root.right;\\n        if (root.next != null) {\\n            root.right.next = root.next.left;\\n        }\\n        \\n        connect (root.left);\\n        connect (root.right);\\n        \\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1059966,
                "title": "c-short-recursive-solution-no-extra-space-needed",
                "content": "Key points:\\n* Use parent\\'s next arrow to find right children\\'s next buddy in the neighboring tree.\\n* In short: root->right->next = root->next->left.\\n* Take care of current level\\'s children\\'s next arrow problem before move down to children subtree.\\n```\\n  Node* connect(Node* root) {\\n    if (root) {\\n      if (root->left) {\\n        root->left->next = root->right;\\n        if (root->next)\\n          root->right->next = root->next->left;\\n        connect(root->left);\\n        connect(root->right);\\n      }\\n    }\\n    return root;\\n  }\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n  Node* connect(Node* root) {\\n    if (root) {\\n      if (root->left) {\\n        root->left->next = root->right;\\n        if (root->next)\\n          root->right->next = root->next->left;\\n        connect(root->left);\\n        connect(root->right);\\n      }\\n    }\\n    return root;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 37703,
                "title": "5-lines-c-simple-solution",
                "content": "    class Solution {\\n    public:\\n        void connect(TreeLinkNode *root) {\\n            if (!root) return;\\n            if (root->left) root->left->next = root->right;\\n            if (root->right && root->next) root->right->next = root->next->left;\\n            connect(root->left);\\n            connect(root->right);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void connect(TreeLinkNode *root) {\\n            if (!root) return;\\n            if (root->left) root->left->next = root->right;\\n            if (root->right && root->next) root->right->next = root->next->left;\\n            connect(root->left);\\n            connect(root->right);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 758779,
                "title": "javascript-o-1-space-o-n-time",
                "content": "We iteratively move from each node to the next node, while fixing the next pointers of their children. \\n```\\nvar connect = function(root) {\\n    let ptr = root;\\n    while(root && root.left){\\n        let temp = root;\\n        while(temp) {\\n            temp.left.next = temp.right;\\n            temp.right.next = temp.next ? temp.next.left : null;\\n            temp = temp.next;\\n        }\\n        root = root.left;\\n    }\\n    return ptr;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Iterator"
                ],
                "code": "```\\nvar connect = function(root) {\\n    let ptr = root;\\n    while(root && root.left){\\n        let temp = root;\\n        while(temp) {\\n            temp.left.next = temp.right;\\n            temp.right.next = temp.next ? temp.next.left : null;\\n            temp = temp.next;\\n        }\\n        root = root.left;\\n    }\\n    return ptr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 37469,
                "title": "another-simple-javascript-solution",
                "content": "Since it's a full binary tree, our job is much simpler, at each node, connects its left and right child, and try to connect the right child with the left child of node's next. A simple preorder traversal should be able to help us solve this problem.\\n```\\n/**\\n * @param {TreeLinkNode} root\\n * @return {void} Do not return anything, modify tree in-place instead.\\n */\\nvar connect = function(root) {\\n    if (!root || !root.left) { // sanity check\\n        return;\\n    }\\n    \\n    root.left.next = root.right;                         // connect left -> right\\n    root.right.next = root.next ? root.next.left : null; // connect right -> next's left\\n    \\n    connect(root.left);\\n    connect(root.right);\\n};\\n```\\nTime complexity: `O(n)`\\nSpace complexity: `O(1)`",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {TreeLinkNode} root\\n * @return {void} Do not return anything, modify tree in-place instead.\\n */\\nvar connect = function(root) {\\n    if (!root || !root.left) { // sanity check\\n        return;\\n    }\\n    \\n    root.left.next = root.right;                         // connect left -> right\\n    root.right.next = root.next ? root.next.left : null; // connect right -> next's left\\n    \\n    connect(root.left);\\n    connect(root.right);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 747756,
                "title": "very-easy-to-understand-recursive-method",
                "content": "Simple recursive solution accepted\\n```\\nclass Solution {\\npublic:\\n    \\n    void solve(Node* l, Node* r){\\n        \\n        if(l == NULL || r == NULL) return;\\n        \\n        l->next = r;\\n        r->next = NULL;\\n        \\n        solve(l->left, l->right);\\n        solve(l->right, r->left);\\n        solve(r->left, r->right);\\n    }\\n    \\n    \\n    Node* connect(Node* root) {\\n        if(root == NULL) return NULL;\\n        if(root->left == NULL) return root;\\n        \\n        solve(root->left, root->right);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void solve(Node* l, Node* r){\\n        \\n        if(l == NULL || r == NULL) return;\\n        \\n        l->next = r;\\n        r->next = NULL;\\n        \\n        solve(l->left, l->right);\\n        solve(l->right, r->left);\\n        solve(r->left, r->right);\\n    }\\n    \\n    \\n    Node* connect(Node* root) {\\n        if(root == NULL) return NULL;\\n        if(root->left == NULL) return root;\\n        \\n        solve(root->left, root->right);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 153086,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    # @param root, a tree link node\\n    # @return nothing\\n    def helper(self, left, right):\\n        if not left or not right:\\n            return\\n        \\n        left.next = right\\n        self.helper(left.right, right.left)\\n        self.helper(left.left, left.right)\\n        self.helper(right.left, right.right)\\n    \\n    def connect(self, root):\\n        if not root:\\n            return\\n    \\n        self.helper(root.left, root.right)\\n\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # @param root, a tree link node\\n    # @return nothing\\n    def helper(self, left, right):\\n        if not left or not right:\\n            return\\n        \\n        left.next = right\\n        self.helper(left.right, right.left)\\n        self.helper(left.left, left.right)\\n        self.helper(right.left, right.right)\\n    \\n    def connect(self, root):\\n        if not root:\\n            return\\n    \\n        self.helper(root.left, root.right)\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 37458,
                "title": "c-recursive-solution",
                "content": "```\\n    void connect(TreeLinkNode *root) {\\n        if(!root) return;\\n        if(root->left){\\n            root->left->next = root->right;\\n            root->right->next = root->next? root->next->left : NULL;\\n        }\\n        connect(root->left);\\n        connect(root->right);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    void connect(TreeLinkNode *root) {\\n        if(!root) return;\\n        if(root->left){\\n            root->left->next = root->right;\\n            root->right->next = root->next? root->next->left : NULL;\\n        }\\n        connect(root->left);\\n        connect(root->right);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 37705,
                "title": "python-accepted-code",
                "content": "    def connect(self, root):\\n        if not root: return\\n        while root.left:\\n            cur = root.left\\n            prev = None\\n            while root:\\n                if prev: prev.next = root.left\\n                root.left.next = root.right\\n                prev = root.right\\n                root = root.next\\n            root = cur",
                "solutionTags": [],
                "code": "    def connect(self, root):\\n        if not root: return\\n        while root.left:\\n            cur = root.left\\n            prev = None\\n            while root:\\n                if prev: prev.next = root.left\\n                root.left.next = root.right\\n                prev = root.right\\n                root = root.next\\n            root = cur",
                "codeTag": "Python3"
            },
            {
                "id": 37663,
                "title": "an-iterative-java-solution",
                "content": "    public void connect(TreeLinkNode root) {\\n        \\n        TreeLinkNode n = root;\\n        \\n        while(n != null && n.left != null) {\\n            TreeLinkNode pre = null;\\n            \\n            for(TreeLinkNode p = n; p != null; p = p.next) {\\n                if(pre != null) pre.next = p.left;\\n                p.left.next = p.right;\\n                pre = p.right;\\n            }\\n            n = n.left;\\n        }\\n    }",
                "solutionTags": [],
                "code": "    public void connect(TreeLinkNode root) {\\n        \\n        TreeLinkNode n = root;\\n        \\n        while(n != null && n.left != null) {\\n            TreeLinkNode pre = null;\\n            \\n            for(TreeLinkNode p = n; p != null; p = p.next) {\\n                if(pre != null) pre.next = p.left;\\n                p.left.next = p.right;\\n                pre = p.right;\\n            }\\n            n = n.left;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1480173,
                "title": "javascript-dfs-extremely-simple-and-understandable",
                "content": "DFS, pass down rightnode\\'s left pointer if it exists, otherwise null.\\n```\\nvar connect = function(root, rightNode = null) {\\n    if (!root) return root;\\n    \\n    root.next = rightNode;\\n    connect(root.left, root.right);\\n    connect(root.right, rightNode ? rightNode.left : null);\\n    \\n    return root;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar connect = function(root, rightNode = null) {\\n    if (!root) return root;\\n    \\n    root.next = rightNode;\\n    connect(root.left, root.right);\\n    connect(root.right, rightNode ? rightNode.left : null);\\n    \\n    return root;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 156384,
                "title": "javascript-bfs",
                "content": "```\\nvar connect = function(root) {\\n    if(!root) return;\\n    const queue = [root];\\n    \\n    while(queue.length) {\\n        const size  = queue.length;\\n        const level = queue.slice();\\n\\n        for(let i = 0; i < size; i++) {\\n            const currentNode = queue.shift();\\n            currentNode.next  = level[i + 1];\\n            if(currentNode.left)  queue.push(currentNode.left);\\n            if(currentNode.right) queue.push(currentNode.right);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar connect = function(root) {\\n    if(!root) return;\\n    const queue = [root];\\n    \\n    while(queue.length) {\\n        const size  = queue.length;\\n        const level = queue.slice();\\n\\n        for(let i = 0; i < size; i++) {\\n            const currentNode = queue.shift();\\n            currentNode.next  = level[i + 1];\\n            if(currentNode.left)  queue.push(currentNode.left);\\n            if(currentNode.right) queue.push(currentNode.right);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 37600,
                "title": "5-line-1ms-java-iterative-solution-o-n-time-o-1-space",
                "content": "    public class Solution {\\n        public void connect(TreeLinkNode root) {\\n            if (root == null) { return; }\\n            for (TreeLinkNode head=root; head.left!=null; head=head.left) {\\n                for (TreeLinkNode parent=head; parent!=null; parent=parent.next) {\\n                    parent.left.next = parent.right;\\n                    if (parent.next != null) { parent.right.next = parent.next.left; }\\n                }\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "class Solution {\\n        public void connect(TreeLinkNode root) {\\n            if (root == null) { return; }",
                "codeTag": "Java"
            },
            {
                "id": 1932092,
                "title": "100-fastest-swift-solution-time-o-n-space-o-1",
                "content": "```\\n/**\\n * Definition for a Node.\\n * public class Node {\\n *     public var val: Int\\n *     public var left: Node?\\n *     public var right: Node?\\n *\\t   public var next: Node?\\n *     public init(_ val: Int) {\\n *         self.val = val\\n *         self.left = nil\\n *         self.right = nil\\n *         self.next = nil\\n *     }\\n * }\\n */\\n\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the binary tree.\\n    //   - space: O(1), only constant space is used.\\n\\n    func connect(_ root: Node?) -> Node? {\\n        var leftMost = root\\n\\n        while leftMost?.left != nil {\\n            var head = leftMost\\n            while head != nil {\\n                head?.left?.next = head?.right\\n                if let next = head?.next {\\n                    head?.right?.next = next.left\\n                }\\n                head = head?.next\\n            }\\n            leftMost = leftMost?.left\\n        }\\n\\n        return root\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for a Node.\\n * public class Node {\\n *     public var val: Int\\n *     public var left: Node?\\n *     public var right: Node?\\n *\\t   public var next: Node?\\n *     public init(_ val: Int) {\\n *         self.val = val\\n *         self.left = nil\\n *         self.right = nil\\n *         self.next = nil\\n *     }\\n * }\\n */\\n\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the binary tree.\\n    //   - space: O(1), only constant space is used.\\n\\n    func connect(_ root: Node?) -> Node? {\\n        var leftMost = root\\n\\n        while leftMost?.left != nil {\\n            var head = leftMost\\n            while head != nil {\\n                head?.left?.next = head?.right\\n                if let next = head?.next {\\n                    head?.right?.next = next.left\\n                }\\n                head = head?.next\\n            }\\n            leftMost = leftMost?.left\\n        }\\n\\n        return root\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1653811,
                "title": "python-solution-recursive-elegant-solution",
                "content": "I thought that this solution was a little different to the others posted, most of them doing a level order search using the next pointer. However here, I have recursively split the tree into \\'pincer\\' segments (this is what I call them because I don\\'t know the name), at each level the pair is made up of 1. the right most node of that level in the left node\\'s subtree & 2. the left most node of that level in the right node\\'s subtree - and then connected node 1 to node 2 at each level.\\n\\n```\\nclass Solution:\\n    def connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if not root:\\n            return\\n        \\n        c1, c2 = root.left, root.right\\n        \\n        while c1 and c2:\\n            c1.next = c2\\n            c1, c2 = c1.right, c2.left\\n        \\n        self.connect(root.left)\\n        self.connect(root.right)\\n        \\n        return root\\n```\\n\\t\\nThe idea being, that I could simply connect a node\\'s left child to it\\'s right child, with the only difficulty being to find the \\'next\\' node of a right child. The \\'pincer\\' segments help resolve this issue, as the \\'next\\' node of a right child is simply the other node in that level of the \\'pincer\\'\\n\\nI\\'m not quite sure the if there is a specific name for this general idea, and would be very appreciative if anyone knows what it is Hope this helps!\\n\\nEDIT: A diagram illustrating the \\'pincer segments\\' of each of the first three nodes, and the pointers created by each - in red, blue and green respectively. Note that each node not on the left or right \\'boundary\\' is visited by two other \\'pincer segments\\', as is necessary since each node should have a pointer coming in and one coming out.\\n\\n![image](https://assets.leetcode.com/users/images/3e380898-de6f-4ab5-89e6-8a618ff56199_1640908417.4581368.jpeg)",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if not root:\\n            return\\n        \\n        c1, c2 = root.left, root.right\\n        \\n        while c1 and c2:\\n            c1.next = c2\\n            c1, c2 = c1.right, c2.left\\n        \\n        self.connect(root.left)\\n        self.connect(root.right)\\n        \\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 37719,
                "title": "accepted-java-recursive-solution",
                "content": "The recursive solution of my last post, although the space is not O(1) (due to recursion), the solution is still elegant.\\n\\n    public class Solution {\\n        public void connect(TreeLinkNode root) {\\n            if (root == null) return;\\n            \\n            if (root.left != null) {\\n                root.left.next = root.right;\\n            }\\n            \\n            if (root.right != null) {\\n                root.right.next = root.next != null ? root.next.left : null;\\n            }\\n            \\n            connect(root.left);\\n            connect(root.right);\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public void connect(TreeLinkNode root) {\\n            if (root == null) return;\\n            \\n            if (root.left != null) {\\n                root.left.next = root.right;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 37744,
                "title": "a-concise-o-1-space-complexity-solution",
                "content": "it fits problem 1 and 2, any comments will be welcome, thanks\\n\\n    void connect(TreeLinkNode *root) {\\n        TreeLinkNode *head = root; // the left first node in every level\\n        TreeLinkNode *cur = NULL;  // the current node in the upper level\\n        TreeLinkNode *pre = NULL;  // the prev node in the downer level\\n        \\n        while (head) {\\n            cur = head;\\n            head = pre = NULL;\\n            // travel one level in a loop\\n            while (cur) {\\n                // left child exist\\n                if (cur->left) {\\n                    if (pre) pre = pre->next = cur->left;\\n                    else head = pre = cur->left;\\n                    \\n                }\\n                // right child exist\\n                if (cur->right) {\\n                    if (pre) pre = pre->next = cur->right;\\n                    else head = pre = cur->right;\\n                }\\n                // next node in the same level\\n                cur = cur->next;\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "it fits problem 1 and 2, any comments will be welcome, thanks\\n\\n    void connect(TreeLinkNode *root) {\\n        TreeLinkNode *head = root; // the left first node in every level\\n        TreeLinkNode *cur = NULL;  // the current node in the upper level\\n        TreeLinkNode *pre = NULL;  // the prev node in the downer level\\n        \\n        while (head) {\\n            cur = head;\\n            head = pre = NULL;\\n            // travel one level in a loop\\n            while (cur) {\\n                // left child exist\\n                if (cur->left) {\\n                    if (pre) pre = pre->next = cur->left;\\n                    else head = pre = cur->left;\\n                    \\n                }\\n                // right child exist\\n                if (cur->right) {\\n                    if (pre) pre = pre->next = cur->right;\\n                    else head = pre = cur->right;\\n                }\\n                // next node in the same level\\n                cur = cur->next;\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2191294,
                "title": "java-solution-simple-bfs-traversal-very-easy-iterative-solution",
                "content": "```\\nclass Solution {\\n\\n    public Node connect(Node root) {\\n        if (root == null) return root;\\n        Queue<Node> q = new LinkedList<>();\\n        q.add(root);\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                Node curr = q.poll();\\n                if (curr.left != null) q.add(curr.left);\\n                if (curr.right != null) q.add(curr.right);\\n                if (i == size - 1) curr.next = null; else curr.next = q.peek();\\n            }\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n\\n    public Node connect(Node root) {\\n        if (root == null) return root;\\n        Queue<Node> q = new LinkedList<>();\\n        q.add(root);\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                Node curr = q.poll();\\n                if (curr.left != null) q.add(curr.left);\\n                if (curr.right != null) q.add(curr.right);\\n                if (i == size - 1) curr.next = null; else curr.next = q.peek();\\n            }\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2040150,
                "title": "o-n-time-beats-99-97-memory-speed-0ms-may-2022",
                "content": "```\\n```\\n\\n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 38.2MB*** (beats 92.04% / 24.00%).\\n* ***Java***\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return null;\\n        if(root.left != null) root.left.next = root.right;\\n        if(root.right != null && root.next != null) root.right.next = root.next.left;\\n        connect(root.left);\\n        connect(root.right);\\n        return root;\\n    }\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 7.0MB*** (beats 100.00% / 100.00%).\\n* ***C++***\\n```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root && root->left != NULL) {\\n            root->left->next = root->right;\\n            connect(root->left);\\n            if(root->next != NULL) root->right->next = root->next->left;\\n            connect(root->right);\\n        }\\n        \\n        return root;\\n    }\\n};\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n\\nThe best result for the code below is ***26ms / 12.2MB*** (beats 95.42% / 82.32%).\\n* ***Python***\\n```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        # edge case check\\n        if not root:\\n            return None\\n        \\n        node = root # create a pointer to the root node\\n        \\n        # iterate only until we have a new level (because the connections for Nth level are done when we are at N-1th level)\\n        while node.left:\\n            head = node\\n            while head:\\n                head.left.next = head.right\\n                if head.next:\\n                    head.right.next = head.next.left\\n                    \\n                head = head.next\\n                \\n            node = node.left\\n\\n        return root\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***51ms / 34.2MB*** (beats 100.00% / 84.12%).\\n* ***JavaScript***\\n```\\nvar connect = function(root) {\\n    let ptr = root;\\n    while(root && root.left){\\n        let temp = root;\\n        while(temp) {\\n            temp.left.next = temp.right;\\n            temp.right.next = temp.next ? temp.next.left : null;\\n            temp = temp.next;\\n        }\\n        root = root.left;\\n    }\\n    return ptr;\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***68ms / 44.2MB*** (beats 100.00% / 45.25%).\\n* ***Kotlin***\\n```\\nclass Solution {\\n    fun connect(root: Node?): Node? =\\n        if (root?.left == null && root?.right == null) root  //at bottom of tree      \\n        else root?.apply {  //connect next and recurse downwards\\n            left?.next = right\\n            right?.next = next?.left\\n            connect(left)\\n            connect(right)\\n        }\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***12ms / 32.2MB*** (beats 95% / 84%).\\n* ***Swift***\\n```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the binary tree.\\n    //   - space: O(1), only constant space is used.\\n\\n    func connect(_ root: Node?) -> Node? {\\n        var leftMost = root\\n\\n        while leftMost?.left != nil {\\n            var head = leftMost\\n            while head != nil {\\n                head?.left?.next = head?.right\\n                if let next = head?.next {\\n                    head?.right?.next = next.left\\n                }\\n                head = head?.next\\n            }\\n            leftMost = leftMost?.left\\n        }\\n\\n        return root\\n    }\\n\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n***\"Open your eyes. Expect us.\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin"
                ],
                "code": "```\\n```\n```\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return null;\\n        if(root.left != null) root.left.next = root.right;\\n        if(root.right != null && root.next != null) root.right.next = root.next.left;\\n        connect(root.left);\\n        connect(root.right);\\n        return root;\\n    }\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root && root->left != NULL) {\\n            root->left->next = root->right;\\n            connect(root->left);\\n            if(root->next != NULL) root->right->next = root->next->left;\\n            connect(root->right);\\n        }\\n        \\n        return root;\\n    }\\n};\\n```\n```\\n```\n```\\n```\n```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        # edge case check\\n        if not root:\\n            return None\\n        \\n        node = root # create a pointer to the root node\\n        \\n        # iterate only until we have a new level (because the connections for Nth level are done when we are at N-1th level)\\n        while node.left:\\n            head = node\\n            while head:\\n                head.left.next = head.right\\n                if head.next:\\n                    head.right.next = head.next.left\\n                    \\n                head = head.next\\n                \\n            node = node.left\\n\\n        return root\\n```\n```\\n```\n```\\n```\n```\\nvar connect = function(root) {\\n    let ptr = root;\\n    while(root && root.left){\\n        let temp = root;\\n        while(temp) {\\n            temp.left.next = temp.right;\\n            temp.right.next = temp.next ? temp.next.left : null;\\n            temp = temp.next;\\n        }\\n        root = root.left;\\n    }\\n    return ptr;\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    fun connect(root: Node?): Node? =\\n        if (root?.left == null && root?.right == null) root  //at bottom of tree      \\n        else root?.apply {  //connect next and recurse downwards\\n            left?.next = right\\n            right?.next = next?.left\\n            connect(left)\\n            connect(right)\\n        }\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the binary tree.\\n    //   - space: O(1), only constant space is used.\\n\\n    func connect(_ root: Node?) -> Node? {\\n        var leftMost = root\\n\\n        while leftMost?.left != nil {\\n            var head = leftMost\\n            while head != nil {\\n                head?.left?.next = head?.right\\n                if let next = head?.next {\\n                    head?.right?.next = next.left\\n                }\\n                head = head?.next\\n            }\\n            leftMost = leftMost?.left\\n        }\\n\\n        return root\\n    }\\n\\n}\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 719347,
                "title": "python-solution-o-1-and-o-n-memory",
                "content": "```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        # edge case check\\n        if not root:\\n            return None\\n        \\n        # initialize the queue with root node (for level order traversal)\\n        queue = collections.deque([root])\\n        \\n        # start the traversal\\n        while queue:\\n            size = len(queue) # get number of nodes on the current level\\n            for i in range(size):\\n                node = queue.popleft() # pop the node\\n                \\n                # An important check so that we do not wire the node to the node on the next level.\\n                if i < size-1:\\n                    node.next = queue[0] # because the right node of the popped node would be the next in the queue. \\n                    \\n                if node.left:\\n                    queue.append(node.left) \\n                if node.right:\\n                    queue.append(node.right)           \\n                \\n        return root\\n```\\n\\nO(1) Memory solution:\\n```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        # edge case check\\n        if not root:\\n            return None\\n        \\n        node = root # create a pointer to the root node\\n        \\n        # iterate only until we have a new level (because the connections for Nth level are done when we are at N-1th level)\\n        while node.left:\\n            head = node\\n            while head:\\n                head.left.next = head.right\\n                if head.next:\\n                    head.right.next = head.next.left\\n                    \\n                head = head.next\\n                \\n            node = node.left\\n\\n        return root\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        # edge case check\\n        if not root:\\n            return None\\n        \\n        # initialize the queue with root node (for level order traversal)\\n        queue = collections.deque([root])\\n        \\n        # start the traversal\\n        while queue:\\n            size = len(queue) # get number of nodes on the current level\\n            for i in range(size):\\n                node = queue.popleft() # pop the node\\n                \\n                # An important check so that we do not wire the node to the node on the next level.\\n                if i < size-1:\\n                    node.next = queue[0] # because the right node of the popped node would be the next in the queue. \\n                    \\n                if node.left:\\n                    queue.append(node.left) \\n                if node.right:\\n                    queue.append(node.right)           \\n                \\n        return root\\n```\n```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        # edge case check\\n        if not root:\\n            return None\\n        \\n        node = root # create a pointer to the root node\\n        \\n        # iterate only until we have a new level (because the connections for Nth level are done when we are at N-1th level)\\n        while node.left:\\n            head = node\\n            while head:\\n                head.left.next = head.right\\n                if head.next:\\n                    head.right.next = head.next.left\\n                    \\n                head = head.next\\n                \\n            node = node.left\\n\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 37606,
                "title": "java-recursive-and-iterative-solutions",
                "content": "        \\n    // dfs iteratively \\n    public void connect1(TreeLinkNode root) {\\n        Stack<TreeLinkNode> stack = new Stack<>();\\n        stack.push(root);\\n        while (!stack.isEmpty()) {\\n            TreeLinkNode n = stack.pop();\\n            if (n != null) {\\n                if (n.right != null) {\\n                    n.left.next = n.right;\\n                    if (n.next != null) {\\n                        n.right.next = n.next.left;\\n                    }\\n                }\\n                stack.push(n.right);\\n                stack.push(n.left);\\n            }\\n        }\\n    }\\n    \\n    // bfs iteratively\\n    public void connect2(TreeLinkNode root) {\\n        Queue<TreeLinkNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        while(!queue.isEmpty()) {\\n            TreeLinkNode n = queue.poll();\\n            if (n != null) {\\n                if (n.right != null) {\\n                    n.left.next = n.right;\\n                    if (n.next != null) {\\n                        n.right.next = n.next.left;\\n                    }\\n                }\\n                queue.add(n.left);\\n                queue.add(n.right);\\n            }\\n        }\\n    }\\n    \\n    // dfs recursively\\n    public void connect(TreeLinkNode root) {\\n        if (root != null) {\\n            if (root.right != null) {\\n                root.left.next = root.right;\\n                if (root.next != null) {\\n                    root.right.next = root.next.left;\\n                } \\n            }\\n            connect(root.left);\\n            connect(root.right);\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "        \\n    // dfs iteratively \\n    public void connect1(TreeLinkNode root) {\\n        Stack<TreeLinkNode> stack = new Stack<>();\\n        stack.push(root);\\n        while (!stack.isEmpty()) {\\n            TreeLinkNode n = stack.pop();\\n            if (n != null) {\\n                if (n.right != null) {\\n                    n.left.next = n.right;\\n                    if (n.next != null) {\\n                        n.right.next = n.next.left;\\n                    }\\n                }\\n                stack.push(n.right);\\n                stack.push(n.left);\\n            }\\n        }\\n    }\\n    \\n    // bfs iteratively\\n    public void connect2(TreeLinkNode root) {\\n        Queue<TreeLinkNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        while(!queue.isEmpty()) {\\n            TreeLinkNode n = queue.poll();\\n            if (n != null) {\\n                if (n.right != null) {\\n                    n.left.next = n.right;\\n                    if (n.next != null) {\\n                        n.right.next = n.next.left;\\n                    }\\n                }\\n                queue.add(n.left);\\n                queue.add(n.right);\\n            }\\n        }\\n    }\\n    \\n    // dfs recursively\\n    public void connect(TreeLinkNode root) {\\n        if (root != null) {\\n            if (root.right != null) {\\n                root.left.next = root.right;\\n                if (root.next != null) {\\n                    root.right.next = root.next.left;\\n                } \\n            }\\n            connect(root.left);\\n            connect(root.right);\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3617528,
                "title": "o-1-space-simple-bfs-java-solution-and-without-recursion",
                "content": "Intution: Treating level of tree is as linked list.\\n1. From parent level connect children level node as linked list and parent level is already connected so we can move to next node of parent to connect other children node.\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        Node head = root;\\n         for(head = root; head != null;){\\n             \\n             if(head.left == null){                  // if left is null then it means no children nodes to connect now\\n                 return root;\\n             }\\n             Node prev = null;\\n             Node curr = head;                      //curr always pointing starting node of every level in starting\\n             \\n             while(curr != null){\\n                 \\n                if(prev != null)                             //  for first node of every level, prev pointing to null\\n                prev.right.next = curr.left;          //connect prev node right to curr left node\\n                curr.left.next = curr.right;          // connect same children nodes of parent \\n                 \\n                 prev = curr;                              // move prev and curr node to next node\\n                 curr = curr.next;\\n             }\\n             head = head.left;                        // move head to next level\\n         }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        Node head = root;\\n         for(head = root; head != null;){\\n             \\n             if(head.left == null){                  // if left is null then it means no children nodes to connect now\\n                 return root;\\n             }\\n             Node prev = null;\\n             Node curr = head;                      //curr always pointing starting node of every level in starting\\n             \\n             while(curr != null){\\n                 \\n                if(prev != null)                             //  for first node of every level, prev pointing to null\\n                prev.right.next = curr.left;          //connect prev node right to curr left node\\n                curr.left.next = curr.right;          // connect same children nodes of parent \\n                 \\n                 prev = curr;                              // move prev and curr node to next node\\n                 curr = curr.next;\\n             }\\n             head = head.left;                        // move head to next level\\n         }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1954109,
                "title": "c-java-python-bfs-o-n-time-o-1-space",
                "content": "I hope the comments are explicit enough to tell about the iterative BFS approach that is used here.\\nTime complexity - O(n)\\nSpace complexity - O(1)\\n\\nC++ \\n\\n```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root) return root;\\n        Node* current = root;\\n        while(current) {\\n            // this will always be the first node of any level\\n            Node* level1stNode = current;\\n            // this runs until we iterate over all the nodes of any level\\n            while(current) {\\n                // this links the child nodes (L child -> next = R child) of the same parent node\\n                if(current->left) {\\n                    current->left->next = current->right;\\n                }\\n                // this checks whether there are more nodes towards right at the same level\\n                if(current->right && current->next) {\\n                    current->right->next = current->next->left;\\n                }\\n                // move on the next node of the current level (L -> R)\\n                current = current->next;\\n            }\\n            // move onto the first node of the next level\\n            current = level1stNode->left;\\n        }\\n        return root;\\n    }\\n};\\n```\\n\\nJava\\n\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return root;\\n        Node current = root;\\n        while(current != null) {\\n\\t\\t\\t// this will always be the first node of any level\\n            Node level1stNode = current;\\n\\t\\t\\t// this runs until we iterate over all the nodes of any level\\n            while(current != null) {\\n\\t\\t\\t\\t// this links the child nodes (L child -> next = R child) of the same parent node\\n                if(current.left != null) {\\n                    current.left.next = current.right;\\n                }\\n\\t\\t\\t\\t// this checks whether there are more nodes towards right at the same level\\n                if(current.right != null && current.next != null) {\\n                    current.right.next = current.next.left;\\n                }\\n\\t\\t\\t\\t// move on the next node of the current level (L -> R)\\n                current = current.next;\\n            }\\n\\t\\t\\t// move onto the first node of the next level\\n            current = level1stNode.left;\\n        }\\n        return root;\\n    }\\n}\\n```\\n\\nPython\\n\\n```\\nclass Solution:\\n    def connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if not root: return root\\n        \\n        self.current = root\\n        \\n        while self.current:\\n            \\n            # this will always be the first node of any level\\n            self.level1stNode = self.current\\n            \\n            # this runs until we iterate over all the nodes of any level\\n            while self.current:\\n                \\n                # this links the child nodes (L child -> next = R child) of the same parent node\\n                if self.current.left:\\n                    self.current.left.next = self.current.right\\n                    \\n                # this checks whether there are more nodes towards right at the same level\\n                if self.current.right and self.current.next:\\n                    self.current.right.next = self.current.next.left\\n                    \\n                # move on the next node of the current level (L -> R)\\n                self.current = self.current.next\\n            \\n            # move onto the first node of the next level\\n            self.current = self.level1stNode.left\\n            \\n        return root\\n```\\n\\n\\uD83D\\uDE80 Thanks for reading. \\nAn upvote would be appreciated.  ^_^\\n",
                "solutionTags": [
                    "Java",
                    "C",
                    "Breadth-First Search",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root) return root;\\n        Node* current = root;\\n        while(current) {\\n            // this will always be the first node of any level\\n            Node* level1stNode = current;\\n            // this runs until we iterate over all the nodes of any level\\n            while(current) {\\n                // this links the child nodes (L child -> next = R child) of the same parent node\\n                if(current->left) {\\n                    current->left->next = current->right;\\n                }\\n                // this checks whether there are more nodes towards right at the same level\\n                if(current->right && current->next) {\\n                    current->right->next = current->next->left;\\n                }\\n                // move on the next node of the current level (L -> R)\\n                current = current->next;\\n            }\\n            // move onto the first node of the next level\\n            current = level1stNode->left;\\n        }\\n        return root;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return root;\\n        Node current = root;\\n        while(current != null) {\\n\\t\\t\\t// this will always be the first node of any level\\n            Node level1stNode = current;\\n\\t\\t\\t// this runs until we iterate over all the nodes of any level\\n            while(current != null) {\\n\\t\\t\\t\\t// this links the child nodes (L child -> next = R child) of the same parent node\\n                if(current.left != null) {\\n                    current.left.next = current.right;\\n                }\\n\\t\\t\\t\\t// this checks whether there are more nodes towards right at the same level\\n                if(current.right != null && current.next != null) {\\n                    current.right.next = current.next.left;\\n                }\\n\\t\\t\\t\\t// move on the next node of the current level (L -> R)\\n                current = current.next;\\n            }\\n\\t\\t\\t// move onto the first node of the next level\\n            current = level1stNode.left;\\n        }\\n        return root;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if not root: return root\\n        \\n        self.current = root\\n        \\n        while self.current:\\n            \\n            # this will always be the first node of any level\\n            self.level1stNode = self.current\\n            \\n            # this runs until we iterate over all the nodes of any level\\n            while self.current:\\n                \\n                # this links the child nodes (L child -> next = R child) of the same parent node\\n                if self.current.left:\\n                    self.current.left.next = self.current.right\\n                    \\n                # this checks whether there are more nodes towards right at the same level\\n                if self.current.right and self.current.next:\\n                    self.current.right.next = self.current.next.left\\n                    \\n                # move on the next node of the current level (L -> R)\\n                self.current = self.current.next\\n            \\n            # move onto the first node of the next level\\n            self.current = self.level1stNode.left\\n            \\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 934059,
                "title": "c-99-100-memory-5-liner-recursively-crispy-af",
                "content": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root and root->left) {\\n            root->left->next = root->right;\\n            auto c1 = root->left, c2 = root->right;\\n            while(c1->right) c1->right->next = c2->left, c1 = c1->right, c2 = c2->left;\\n            root->left = connect(root->left), root->right = connect(root->right);\\n        }\\n        return root;\\n    }\\n};\\n```\\n\\nExplanation -\\n1. Traverse tree\\n2. Make given connections\\n3. ???\\n4. Profit!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root and root->left) {\\n            root->left->next = root->right;\\n            auto c1 = root->left, c2 = root->right;\\n            while(c1->right) c1->right->next = c2->left, c1 = c1->right, c2 = c2->left;\\n            root->left = connect(root->left), root->right = connect(root->right);\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2956337,
                "title": "c-beats-97-explained-using-level-order-traversal",
                "content": "# Best Solution for Beginners\\nWe can solve this using Level order Traversal.\\n\\n    Runtime - 97.14%\\uD83D\\uDD25 \\n\\n# Approach\\n1. Firstly We will do Level Order Travesal.\\n2. Then at Each Level we will join all nodes present at that Level.\\n\\n#  If you like the solution and understand it then Please Upvote.\\u2B06\\uFE0F\\u2764\\uFE0F \\n\\t* PEACE OUT LUV\\u270C\\uFE0F*\\n\\n# Code\\n```\\n/*\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root == NULL){\\n            return root;\\n        }\\n        queue<Node*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size = q.size();\\n            vector<Node*>ans;\\n            for(int i=0; i<size; i++){\\n                Node* node = q.front();\\n                q.pop();\\n                if(node ->left)q.push(node ->left);\\n                if(node ->right)q.push(node ->right);\\n                ans.push_back(node);\\n            }\\n            for(int i=1; i<ans.size(); i++){\\n                ans[i-1] ->next = ans[i];\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\n/*\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root == NULL){\\n            return root;\\n        }\\n        queue<Node*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size = q.size();\\n            vector<Node*>ans;\\n            for(int i=0; i<size; i++){\\n                Node* node = q.front();\\n                q.pop();\\n                if(node ->left)q.push(node ->left);\\n                if(node ->right)q.push(node ->right);\\n                ans.push_back(node);\\n            }\\n            for(int i=1; i<ans.size(); i++){\\n                ans[i-1] ->next = ans[i];\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779810,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        queue<Node*> q;\\n        if (root) q.push(root);\\n        while (q.size()) {\\n            int len = q.size();\\n            Node* curr;\\n            while (len--) {\\n                curr = q.front(), q.pop();\\n                curr->next = len ? q.front():NULL;\\n                if (curr->left) q.push(curr->left);\\n                if (curr->right) q.push(curr->right);         \\n            }\\n        }         \\n        return root;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        queue<Node*> q;\\n        if (root) q.push(root);\\n        while (q.size()) {\\n            int len = q.size();\\n            Node* curr;\\n            while (len--) {\\n                curr = q.front(), q.pop();\\n                curr->next = len ? q.front():NULL;\\n                if (curr->left) q.push(curr->left);\\n                if (curr->right) q.push(curr->right);         \\n            }\\n        }         \\n        return root;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2720678,
                "title": "0ms-100-faster-java-code",
                "content": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return null;\\n        Node left = root.left;\\n        Node right = root.right;\\n        while(left != null){\\n            left.next = right;\\n            left = left.right;\\n            right = right.left;\\n        }\\n        connect(root.left);\\n        connect(root.right);\\n        return root;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return null;\\n        Node left = root.left;\\n        Node right = root.right;\\n        while(left != null){\\n            left.next = right;\\n            left = left.right;\\n            right = right.left;\\n        }\\n        connect(root.left);\\n        connect(root.right);\\n        return root;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1764851,
                "title": "java-bfs-and-dfs-4-solutions",
                "content": "```\\n\\t//DFS\\n\\t//Time Complexity : O(n), where n is the number of elements in root\\n\\t//Space Complexity : O(log n), for recursion stack of a perfect BST\\n\\tpublic Node connect(Node root) {\\n        if(root == null)\\n            return root;\\n        dfs(root);\\n        return root;\\n    }\\n    \\n    private void dfs(Node root) {\\n        // base\\n        if(root.left == null)\\n            return;\\n        \\n        root.left.next = root.right;\\n        dfs(root.left);\\n        if(root.next != null)\\n            root.right.next = root.next.left;\\n        dfs(root.right);\\n    }\\n```\\n```\\n\\t//DFS\\n\\t//Time Complexity : O(n), where n is the number of elements in root\\n\\t//Space Complexity : O(log n), for recursion stack of a perfect BST\\n\\tpublic Node connect1(Node root) {\\n        if(root == null)\\n            return root;\\n        conn(root.left, root.right);\\n        return root;\\n    }\\n    \\n    private void conn(Node left, Node right) {\\n        if(left == null)\\n            return;\\n        \\n        left.next = right;\\n        conn(left.left, left. right);\\n        conn(left.right, right.left);\\n        conn(right.left, right.right);\\n    }\\n```\\n```\\n    //BFS\\n\\t//Time Complexity : O(n), where n is the number of elements in root\\n\\t//Space Complexity : O(1)\\n\\tpublic Node connect2(Node root) {\\n        if(root == null)\\n            return root;\\n        \\n        Node level = root;\\n        while(level.left != null) {\\n            Node curr = level;\\n            while(curr != null) {\\n                curr.left.next = curr.right;\\n                if(curr.next != null)\\n                    curr.right.next = curr.next.left;\\n                curr = curr.next;\\n            }\\n            level = level.left;\\n        }\\n        return root;\\n    }\\n```\\n```\\n\\t//BFS using Queue\\n\\t//Time Complexity : O(n), where n is the number of elements in root\\n\\t//Space Complexity : O(n), for queue\\n\\tpublic Node connect3(Node root) {\\n\\t\\tif(root == null)\\n\\t\\t\\treturn root;\\n\\t\\tQueue<Node> q = new LinkedList<>();\\n\\t\\tq.offer(root);\\n\\n\\t\\twhile(!q.isEmpty()) {\\n\\t\\t\\tint size = q.size();\\n\\t\\t\\tNode prev = q.poll();\\n\\t\\t\\tif(prev.left != null) {\\n\\t\\t\\t\\tq.offer(prev.left);\\n\\t\\t\\t\\tq.offer(prev.right);\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=1; i<size; i++) {\\n\\t\\t\\t\\tNode curr = q.poll();\\n\\t\\t\\t\\tprev.next = curr;\\n\\t\\t\\t\\tif(curr.left != null) {\\n\\t\\t\\t\\t\\tq.offer(curr.left);\\n\\t\\t\\t\\t\\tq.offer(curr.right);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tprev = curr;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn root;\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n\\t//DFS\\n\\t//Time Complexity : O(n), where n is the number of elements in root\\n\\t//Space Complexity : O(log n), for recursion stack of a perfect BST\\n\\tpublic Node connect(Node root) {\\n        if(root == null)\\n            return root;\\n        dfs(root);\\n        return root;\\n    }\\n    \\n    private void dfs(Node root) {\\n        // base\\n        if(root.left == null)\\n            return;\\n        \\n        root.left.next = root.right;\\n        dfs(root.left);\\n        if(root.next != null)\\n            root.right.next = root.next.left;\\n        dfs(root.right);\\n    }\\n```\n```\\n\\t//DFS\\n\\t//Time Complexity : O(n), where n is the number of elements in root\\n\\t//Space Complexity : O(log n), for recursion stack of a perfect BST\\n\\tpublic Node connect1(Node root) {\\n        if(root == null)\\n            return root;\\n        conn(root.left, root.right);\\n        return root;\\n    }\\n    \\n    private void conn(Node left, Node right) {\\n        if(left == null)\\n            return;\\n        \\n        left.next = right;\\n        conn(left.left, left. right);\\n        conn(left.right, right.left);\\n        conn(right.left, right.right);\\n    }\\n```\n```\\n    //BFS\\n\\t//Time Complexity : O(n), where n is the number of elements in root\\n\\t//Space Complexity : O(1)\\n\\tpublic Node connect2(Node root) {\\n        if(root == null)\\n            return root;\\n        \\n        Node level = root;\\n        while(level.left != null) {\\n            Node curr = level;\\n            while(curr != null) {\\n                curr.left.next = curr.right;\\n                if(curr.next != null)\\n                    curr.right.next = curr.next.left;\\n                curr = curr.next;\\n            }\\n            level = level.left;\\n        }\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 934355,
                "title": "populating-next-right-pointer-in-each-node-c-easy-to-understand",
                "content": "```\\nclass Solution {\\n\\npublic:\\n    Node* connect(Node* root) {\\n        if(root == NULL || root->left == NULL) return root;\\n        \\n        \\n        if(root->next != NULL){\\n            root->right->next=root->next->left;\\n        }\\n        \\n        root->left->next = root->right;\\n        \\n        connect(root->left);\\n        connect(root->right);\\n        \\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    Node* connect(Node* root) {\\n        if(root == NULL || root->left == NULL) return root;\\n        \\n        \\n        if(root->next != NULL){\\n            root->right->next=root->next->left;\\n        }\\n        \\n        root->left->next = root->right;\\n        \\n        connect(root->left);\\n        connect(root->right);\\n        \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 934184,
                "title": "python-time-o-n-space-o-1-concise-real-o-1-solution",
                "content": "```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if (head:=root):\\n            while (start:=root.left):\\n                while root:\\n                    root.left.next = root.right\\n                    root.right.next = root.next.left if root.next else None\\n                    root = root.next\\n                root = start\\n        return head\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if (head:=root):\\n            while (start:=root.left):\\n                while root:\\n                    root.left.next = root.right\\n                    root.right.next = root.next.left if root.next else None\\n                    root = root.next\\n                root = start\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 561417,
                "title": "go-recursive-and-iterative",
                "content": "Recursive:\\n```\\nfunc connect(root *Node) *Node {\\n    if root == nil {\\n        return nil\\n    }\\n    \\n    if root.Left != nil {\\n        root.Left.Next = root.Right\\n        if root.Next != nil {\\n            root.Right.Next = root.Next.Left\\n        }\\n    }\\n    \\n    connect(root.Left)\\n    connect(root.Right)\\n    \\n    return root\\n}\\n```\\n\\nIterative (BFS with Queue):\\n```\\nfunc connect(root *Node) *Node {\\n    if root == nil {\\n        return nil\\n    }\\n    \\n    type entry struct{\\n        level int\\n        node *Node\\n    }\\n    \\n    var queue []entry\\n    \\n    var prev *Node\\n    currLevel := -1\\n    \\n    queue = append(queue, entry{level: 0, node: root})\\n    \\n    for len(queue) != 0 {\\n        curr := queue[0]\\n        queue = queue[1:]\\n        \\n        if currLevel != curr.level {\\n            if prev != nil {\\n                prev.Next = nil\\n            }\\n            currLevel = curr.level\\n        } else {\\n            prev.Next = curr.node\\n        }\\n        \\n        prev = curr.node\\n        \\n        if curr.node.Left != nil {\\n            queue = append(queue, entry{level: curr.level+1, node: curr.node.Left})\\n        }\\n        \\n        if curr.node.Right != nil {\\n            queue = append(queue, entry{level: curr.level+1, node: curr.node.Right})\\n        }\\n    }\\n    \\n    return root\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc connect(root *Node) *Node {\\n    if root == nil {\\n        return nil\\n    }\\n    \\n    if root.Left != nil {\\n        root.Left.Next = root.Right\\n        if root.Next != nil {\\n            root.Right.Next = root.Next.Left\\n        }\\n    }\\n    \\n    connect(root.Left)\\n    connect(root.Right)\\n    \\n    return root\\n}\\n```\n```\\nfunc connect(root *Node) *Node {\\n    if root == nil {\\n        return nil\\n    }\\n    \\n    type entry struct{\\n        level int\\n        node *Node\\n    }\\n    \\n    var queue []entry\\n    \\n    var prev *Node\\n    currLevel := -1\\n    \\n    queue = append(queue, entry{level: 0, node: root})\\n    \\n    for len(queue) != 0 {\\n        curr := queue[0]\\n        queue = queue[1:]\\n        \\n        if currLevel != curr.level {\\n            if prev != nil {\\n                prev.Next = nil\\n            }\\n            currLevel = curr.level\\n        } else {\\n            prev.Next = curr.node\\n        }\\n        \\n        prev = curr.node\\n        \\n        if curr.node.Left != nil {\\n            queue = append(queue, entry{level: curr.level+1, node: curr.node.Left})\\n        }\\n        \\n        if curr.node.Right != nil {\\n            queue = append(queue, entry{level: curr.level+1, node: curr.node.Right})\\n        }\\n    }\\n    \\n    return root\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2991023,
                "title": "c-2-methods-with-logic-bfs-traversal-clean-code",
                "content": "***Method -1 [Naive Method]***\\n\\n![image](https://assets.leetcode.com/users/images/c1e0a6f5-6652-42c9-be2d-d4dd6b797b16_1672731185.2271147.png)\\n\\n**n==Number of Nodes \\nT->O(n) && S->O(n) [For storing all the Nodes after BFS] + O(n/2) [For queue, worst Case as it\\'s a Perfect Binary Tree]**\\n\\n***Logic -> Level Order Traversal and connect adjacent Nodes!***\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tNode* connect(Node* root) {\\n\\t\\t\\t\\tif(!root) return NULL;\\n\\n\\t\\t\\t\\tvector<vector<Node*>> lvl;\\n\\t\\t\\t\\tqueue <Node*> q;\\n\\t\\t\\t\\tq.push(root);\\n\\n\\t\\t\\t\\twhile(!q.empty()){\\n\\t\\t\\t\\t\\tint size = q.size();\\n\\t\\t\\t\\t\\tvector <Node*> temp;\\n\\n\\t\\t\\t\\t\\tfor(int i = 0 ; i < size ; i++){\\n\\t\\t\\t\\t\\t\\tNode* node = q.front();\\n\\t\\t\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\t\\t\\tif(node -> left) q.push(node -> left);\\n\\t\\t\\t\\t\\t\\tif(node -> right) q.push(node -> right);\\n\\t\\t\\t\\t\\t\\ttemp.push_back(node);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\ttemp.push_back(NULL);\\n\\t\\t\\t\\t\\tlvl.push_back(temp);\\n\\t\\t\\t\\t} \\n\\n\\t\\t\\t\\tfor(int i = 0 ; i < lvl.size() ; i++){\\n\\t\\t\\t\\t\\tfor(int j = 0 ; j < lvl[i].size() - 1 ; j++) lvl[i][j] -> next = lvl[i][j + 1];\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn root;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\t\\n**Method - 2 [Optimized]**\\n\\n![image](https://assets.leetcode.com/users/images/2bedfde0-1ab4-4a19-b754-0fb7656b6c84_1672755793.910553.png)\\n\\n**n==Number of Nodes\\nT->O(n) && S->O(n) [Recursive Stack Space]**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvoid dfs(Node* l,Node* r){\\n\\t\\t\\tif(!l && !r) return;\\n\\n\\t\\t\\tl -> next = r;\\n\\t\\t\\tr -> next = NULL;\\n\\n\\t\\t\\tdfs(l -> left , l -> right);\\n\\t\\t\\tdfs(l -> right , r -> left);\\n\\t\\t\\tdfs(r -> left , r -> right);\\n\\t\\t}\\n\\n\\t\\tNode* connect(Node* root) {\\n\\t\\t\\tif(!root) return NULL;\\n\\t\\t\\tdfs(root -> left , root -> right);\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tNode* connect(Node* root) {\\n\\t\\t\\t\\tif(!root) return NULL;\\n\\n\\t\\t\\t\\tvector<vector<Node*>> lvl;\\n\\t\\t\\t\\tqueue <Node*> q;\\n\\t\\t\\t\\tq.push(root);\\n\\n\\t\\t\\t\\twhile(!q.empty()){\\n\\t\\t\\t\\t\\tint size = q.size();\\n\\t\\t\\t\\t\\tvector <Node*> temp;\\n\\n\\t\\t\\t\\t\\tfor(int i = 0 ; i < size ; i++){\\n\\t\\t\\t\\t\\t\\tNode* node = q.front();\\n\\t\\t\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\t\\t\\tif(node -> left) q.push(node -> left);\\n\\t\\t\\t\\t\\t\\tif(node -> right) q.push(node -> right);\\n\\t\\t\\t\\t\\t\\ttemp.push_back(node);\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1466306,
                "title": "c-o-n-time-o-1-space-no-recursion-space-0ms-faster-than-100",
                "content": "The idea is to fix the next pointer for child nodes while traversing through parent node. \\nOnce you fixed the next pointer then you can traverse this level in O(1) space.\\n```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n       if(!root)return root;\\n       Node* curr=root;\\n       while(curr->left){\\n            Node* currLeft=curr->left;\\n            while(curr){\\n                curr->left->next=curr->right;\\n                curr->right->next=curr->next?curr->next->left:NULL;\\n                curr=curr->next;\\n            }\\n            curr=currLeft;\\n       }\\n       return root;\\n    }\\n};\\n```\\nFeel free to ask doubt in comments and please don\\'t forget to upvote if you like the solution.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n       if(!root)return root;\\n       Node* curr=root;\\n       while(curr->left){\\n            Node* currLeft=curr->left;\\n            while(curr){\\n                curr->left->next=curr->right;\\n                curr->right->next=curr->next?curr->next->left:NULL;\\n                curr=curr->next;\\n            }\\n            curr=currLeft;\\n       }\\n       return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1357656,
                "title": "python-simple-solution-easy-to-understand-o-n-and-constant-memory",
                "content": "```\\n def helper(self, root, parent=None, isleftChild=True):\\n        if root is None:\\n            return None\\n        \\n        if parent == None:\\n            #we are at root\\n            root.next = None\\n        else:\\n            #we are at some node other than root\\n            if isleftChild:\\n                root.next = parent.right\\n            else:\\n                root.next = None\\n                if parent.next != None:\\n                    root.next = parent.next.left\\n                    \\n        root.left = self.helper(root.left, root, True)\\n        root.right = self.helper(root.right, root, False)\\n        \\n        return root\\n    \\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        return self.helper(root)\\n```\\nplease upvote !",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\n def helper(self, root, parent=None, isleftChild=True):\\n        if root is None:\\n            return None\\n        \\n        if parent == None:\\n            #we are at root\\n            root.next = None\\n        else:\\n            #we are at some node other than root\\n            if isleftChild:\\n                root.next = parent.right\\n            else:\\n                root.next = None\\n                if parent.next != None:\\n                    root.next = parent.next.left\\n                    \\n        root.left = self.helper(root.left, root, True)\\n        root.right = self.helper(root.right, root, False)\\n        \\n        return root\\n    \\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        return self.helper(root)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 934979,
                "title": "easy-bfs-python-solution",
                "content": "```\\n\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        \\n        if not root:\\n            return None\\n        \\n        q=collections.deque()\\n        \\n        q.append(root)\\n        \\n        while q:\\n            for i in range(1,len(q)):\\n                q[i-1].next=q[i]\\n            q[-1].next=None    \\n            newLevel=deque()\\n            for node in q:\\n                if node.left:\\n                    newLevel.append(node.left)\\n                if node.right:\\n                    newLevel.append(node.right)\\n                    \\n            q=newLevel\\n        return root\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        \\n        if not root:\\n            return None\\n        \\n        q=collections.deque()\\n        \\n        q.append(root)\\n        \\n        while q:\\n            for i in range(1,len(q)):\\n                q[i-1].next=q[i]\\n            q[-1].next=None    \\n            newLevel=deque()\\n            for node in q:\\n                if node.left:\\n                    newLevel.append(node.left)\\n                if node.right:\\n                    newLevel.append(node.right)\\n                    \\n            q=newLevel\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 934124,
                "title": "python-constant-space",
                "content": "Use the already-populated next pointers of the row above to fill the row below:\\n```\\ndef connect(self, root: \\'Node\\') -> \\'Node\\':\\n\\tif not root: return\\n\\t\\n\\tabove, below = root, root.left\\n\\twhile below:\\n\\t\\tcur = below\\n\\t\\twhile above:\\n\\t\\t\\tif cur == above.left:\\n\\t\\t\\t\\tcur.next = above.right\\n\\t\\t\\t\\tabove = above.next\\n\\t\\t\\telse:\\n\\t\\t\\t\\tcur.next = above.left\\n\\t\\t\\tcur = cur.next\\n\\n\\t\\tabove = below\\n\\t\\tbelow = below.left\\n\\n\\treturn root\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef connect(self, root: \\'Node\\') -> \\'Node\\':\\n\\tif not root: return\\n\\t\\n\\tabove, below = root, root.left\\n\\twhile below:\\n\\t\\tcur = below\\n\\t\\twhile above:\\n\\t\\t\\tif cur == above.left:\\n\\t\\t\\t\\tcur.next = above.right\\n\\t\\t\\t\\tabove = above.next\\n\\t\\t\\telse:\\n\\t\\t\\t\\tcur.next = above.left\\n\\t\\t\\tcur = cur.next\\n\\n\\t\\tabove = below\\n\\t\\tbelow = below.left\\n\\n\\treturn root\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 557405,
                "title": "2-different-simple-recursion-o-n-time-beats-100",
                "content": "The first solution\\'s idea is only on about the fact that `root.right.next = root.next.left`\\n```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if not root or not root.left:\\n            return root\\n        root.left.next = root.right\\n        if root.next:\\n            root.right.next = root.next.left\\n        self.connect(root.left)\\n        self.connect(root.right)\\n        return root\\n```\\n\\nThe 2nd solution is as simple as stiching nodes recursively, 3 pairs at a time\\n```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if not root or not root.left:\\n            return root\\n        def stich(left, right):\\n            if not left:\\n                return\\n            if left.next:\\n                # optimize, save huge time\\n                return\\n            left.next = right\\n            stich(left.left, left.right)\\n            stich(left.right, right.left)\\n            stich(right.left, right.right)\\n        stich(root.left, root.right)\\n        return root\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if not root or not root.left:\\n            return root\\n        root.left.next = root.right\\n        if root.next:\\n            root.right.next = root.next.left\\n        self.connect(root.left)\\n        self.connect(root.right)\\n        return root\\n```\n```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if not root or not root.left:\\n            return root\\n        def stich(left, right):\\n            if not left:\\n                return\\n            if left.next:\\n                # optimize, save huge time\\n                return\\n            left.next = right\\n            stich(left.left, left.right)\\n            stich(left.right, right.left)\\n            stich(right.left, right.right)\\n        stich(root.left, root.right)\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 37622,
                "title": "share-my-loop-java-1ms-solution-easy-understand",
                "content": "    //Just remember to use result from the last step\\n    public class Solution {\\n        public void connect(TreeLinkNode root) {\\n            if(root==null) return;\\n            while(root.left!=null){\\n                TreeLinkNode tmp = root;\\n                while(tmp!=null){\\n                    tmp.left.next = tmp.right;\\n                    if(tmp.next!=null) tmp.right.next = tmp.next.left;\\n                    tmp = tmp.next;\\n                }\\n                root = root.left;\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public void connect(TreeLinkNode root) {\\n            if(root==null) return;\\n            while(root.left!=null){\\n                TreeLinkNode tmp = root;\\n                while(tmp!=null){\\n                    tmp.left.next = tmp.right;\\n                    if(tmp.next!=null) tmp.right.next = tmp.next.left;\\n                    tmp = tmp.next;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 37675,
                "title": "c-easy-recursive-solution",
                "content": "    class Solution {\\n    public:\\n        void connect(TreeLinkNode *root) {\\n            if(!root)\\n                return;\\n            if(root->left)\\n                root->left->next = root->right;\\n            if(root->next && root->right)\\n                root->right->next = root->next->left;\\n            connect(root->left);\\n            connect(root->right);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void connect(TreeLinkNode *root) {\\n            if(!root)\\n                return;\\n            if(root->left)\\n                root->left->next = root->right;\\n            if(root->next && root->right)\\n                root->right->next = root->next->left;\\n            connect(root->left);\\n            connect(root->right);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3689095,
                "title": "easy-bfs-java-python-c",
                "content": "# * Extra space but clean code\\n---\\n```java []\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null)\\n            return root;\\n        Queue<Node> queue = new LinkedList<>();\\n        queue.add(root);\\n        while(queue.size() > 0)\\n        {\\n            Deque<Node> dq = new ArrayDeque<>();\\n            int length = queue.size();\\n            for(int i = 0;i<length;i++)\\n            {\\n                Node curr = queue.poll();\\n                dq.addLast(curr);\\n                if(curr.left!=null)\\n                    queue.add(curr.left);\\n                if(curr.right!=null)\\n                    queue.add(curr.right);\\n            }\\n            while(dq.size() > 1)\\n            {\\n                Node popped = dq.removeFirst();\\n                popped.next = dq.getFirst();\\n            }\\n            Node popped = dq.removeFirst();\\n            popped.next = null;\\n        }\\n        return root;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root == nullptr)\\n            return root;\\n        queue<Node*> queue;\\n        queue.push(root);\\n        while(queue.size() > 0)\\n        {\\n            deque<Node*> dq;\\n            int length = queue.size();\\n            for(int i = 0;i<length;i++)\\n            {\\n                Node* curr = queue.front();\\n                queue.pop();\\n                dq.push_back(curr);\\n                if(curr->left!=nullptr)\\n                    queue.push(curr->left);\\n                if(curr->right!=nullptr)\\n                    queue.push(curr->right);\\n            }\\n            while(dq.size() > 1)\\n            {\\n                Node* popped = dq.front();\\n                dq.pop_front();\\n                popped->next = dq.front();\\n            }\\n            Node* popped = dq.front();\\n            dq.pop_front();\\n            popped->next = nullptr;\\n        }\\n        return root;\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if not root:\\n            return root\\n        queue = []\\n        queue.append(root)\\n        while queue:\\n            dq = collections.deque()\\n            length = len(queue)\\n            for i in range(length):\\n                curr = queue.pop(0)\\n                dq.append(curr)\\n                if curr.left:\\n                    queue.append(curr.left)\\n                if curr.right:\\n                    queue.append(curr.right)\\n            while len(dq) > 1:\\n                popped = dq.popleft()\\n                popped.next = dq[0]\\n            popped = dq.popleft()\\n            popped.next = None\\n        return root\\n```\\n---\\n>### *Please don\\'t forget to upvote if you\\'ve liked my solution.* \\u2B06\\uFE0F\\n---",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```java []\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null)\\n            return root;\\n        Queue<Node> queue = new LinkedList<>();\\n        queue.add(root);\\n        while(queue.size() > 0)\\n        {\\n            Deque<Node> dq = new ArrayDeque<>();\\n            int length = queue.size();\\n            for(int i = 0;i<length;i++)\\n            {\\n                Node curr = queue.poll();\\n                dq.addLast(curr);\\n                if(curr.left!=null)\\n                    queue.add(curr.left);\\n                if(curr.right!=null)\\n                    queue.add(curr.right);\\n            }\\n            while(dq.size() > 1)\\n            {\\n                Node popped = dq.removeFirst();\\n                popped.next = dq.getFirst();\\n            }\\n            Node popped = dq.removeFirst();\\n            popped.next = null;\\n        }\\n        return root;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root == nullptr)\\n            return root;\\n        queue<Node*> queue;\\n        queue.push(root);\\n        while(queue.size() > 0)\\n        {\\n            deque<Node*> dq;\\n            int length = queue.size();\\n            for(int i = 0;i<length;i++)\\n            {\\n                Node* curr = queue.front();\\n                queue.pop();\\n                dq.push_back(curr);\\n                if(curr->left!=nullptr)\\n                    queue.push(curr->left);\\n                if(curr->right!=nullptr)\\n                    queue.push(curr->right);\\n            }\\n            while(dq.size() > 1)\\n            {\\n                Node* popped = dq.front();\\n                dq.pop_front();\\n                popped->next = dq.front();\\n            }\\n            Node* popped = dq.front();\\n            dq.pop_front();\\n            popped->next = nullptr;\\n        }\\n        return root;\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if not root:\\n            return root\\n        queue = []\\n        queue.append(root)\\n        while queue:\\n            dq = collections.deque()\\n            length = len(queue)\\n            for i in range(length):\\n                curr = queue.pop(0)\\n                dq.append(curr)\\n                if curr.left:\\n                    queue.append(curr.left)\\n                if curr.right:\\n                    queue.append(curr.right)\\n            while len(dq) > 1:\\n                popped = dq.popleft()\\n                popped.next = dq[0]\\n            popped = dq.popleft()\\n            popped.next = None\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2577380,
                "title": "java-100-fast-0ms-easy-recursion-node",
                "content": "If you find my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community,\\nif you have any queries or any improvements please feel free to comment and share your views.\\n\\n       class Solution {\\n    public Node connect(Node root) {\\n        if(root == null){\\n              return root;\\n        }\\n        if(root.left != null) root.left.next = root.right;\\n        if(root.right != null && root.next != null){\\n                root.right.next = root.next.left;\\n            }\\n        connect(root.left);\\n        connect (root.right);\\n        return root;\\n    }\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public Node connect(Node root) {\\n        if(root == null){\\n              return root;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2534439,
                "title": "python-with-simple-recursion-explanation-with-drawing",
                "content": "I divide the code into four part, check out the hashtag. \\n`#part1`: if root is None, we want to just return None.\\n`#part2:` : if cur.left is not None, we want to build a connection between cur.left and cur.right. See pic:\\n![image](https://assets.leetcode.com/users/images/cfeb76d0-09c7-4598-bc2f-2b366fe46eca_1662378412.3597903.png)\\n`#part3`:we want to build connection between node 5 and 6(see pic), if cur.next and cur.left not None.\\n![image](https://assets.leetcode.com/users/images/a315abd7-21a7-43cf-ad9b-31ab3af73219_1662378740.7180765.png)\\n`#part4` call left node and right node do the same thing\\n\\nIf this is helpful, don\\'t forget give me a star and vote\\n\\n\\n```\\nclass Solution:\\n    def connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if not root : return None      #part1\\n        def recursion(cur):\\n            if cur.left:                   #part2\\n                cur.left.next = cur.right\\n\\n            if cur.next and cur.left:     #part3\\n                cur.right.next = cur.next.left\\n\\n            recursion(cur.left) if cur.left else None        #part4\\n            recursion(cur.right) if cur.right else None\\n        \\n        recursion(root)\\n        return root\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if not root : return None      #part1\\n        def recursion(cur):\\n            if cur.left:                   #part2\\n                cur.left.next = cur.right\\n\\n            if cur.next and cur.left:     #part3\\n                cur.right.next = cur.next.left\\n\\n            recursion(cur.left) if cur.left else None        #part4\\n            recursion(cur.right) if cur.right else None\\n        \\n        recursion(root)\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774841,
                "title": "c-efficient-recursive-iterative-using-queue-2-solutions",
                "content": "##### If you understand the approach please please upvote!!!\\uD83D\\uDC4D\\n***Thanks :)***\\n##### Recursive Approach :-\\n* Base case: if the root is null than return null\\n* Now to connect the left subtree of same level with right subtree of that level\\n* The only new line that differentiate from level order traversing is that we need to connect the rightmost node of a level to the leftmost node of the next level.\\n* Now just repeat the steps over and over for every level of tree .*\\n##### Recursive Code:-\\n```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n    if(root == NULL) return NULL;\\n    //connects the left subtree of same level with right subtree of that same level \\n    if(root->left != NULL) root->left->next = root->right;\\n    //connect the rightmost node of a level to the leftmost node of the next level.\\n    if(root->right != NULL && root->next != NULL) root->right->next = root->next->left;\\n    //recursive calls for left and right subtrees.\\n    connect(root->left);\\n    connect(root->right);\\n    return root;\\n    }\\n};\\n```\\n\\n##### Iterative Approach using Queue(like level-order-traversal):-\\n```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root == NULL) return NULL;\\n        queue<Node*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size = q.size(); // get size of queue \\n            for(int i=0 ; i < size ; i++){\\n                Node* item = q.front(); \\n                if(size - 1 == i) // checking the last value of the level\\n                     item -> next = NULL; \\n                q.pop();\\n                \\n                if(size - 1 != i) // if this is not the last value then previous value will point to next one\\n                     item -> next = q.front(); \\n                \\n                if(item -> left != NULL)\\n                    q.push(item -> left);\\n                if(item -> right != NULL)\\n                    q.push(item -> right);\\n            }\\n        } \\n        return root;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Recursion",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n    if(root == NULL) return NULL;\\n    //connects the left subtree of same level with right subtree of that same level \\n    if(root->left != NULL) root->left->next = root->right;\\n    //connect the rightmost node of a level to the leftmost node of the next level.\\n    if(root->right != NULL && root->next != NULL) root->right->next = root->next->left;\\n    //recursive calls for left and right subtrees.\\n    connect(root->left);\\n    connect(root->right);\\n    return root;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root == NULL) return NULL;\\n        queue<Node*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size = q.size(); // get size of queue \\n            for(int i=0 ; i < size ; i++){\\n                Node* item = q.front(); \\n                if(size - 1 == i) // checking the last value of the level\\n                     item -> next = NULL; \\n                q.pop();\\n                \\n                if(size - 1 != i) // if this is not the last value then previous value will point to next one\\n                     item -> next = q.front(); \\n                \\n                if(item -> left != NULL)\\n                    q.push(item -> left);\\n                if(item -> right != NULL)\\n                    q.push(item -> right);\\n            }\\n        } \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1360246,
                "title": "simple-preorder-traversal",
                "content": "```class Solution {\\n    private void helper(Node root)\\n    {\\n        if(root == null)\\n            return;\\n        //since it is a leaf node it wont have any child \\n        if(root.left == null && root.right == null)\\n            return;\\n        //stand on parent and connect left child to right child\\n        root.left.next = root.right;\\n        \\n        //after connecting left child to right , connect parent\\'s right child via the next link we created above to left child of adjacent subtree.\\n        if(root.next != null)\\n            root.right.next = root.next.left;\\n        \\n        helper(root.left);\\n        helper(root.right);\\n    }\\n    public Node connect(Node root) {\\n        helper(root);\\n        return root;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    private void helper(Node root)\\n    {\\n        if(root == null)\\n            return;\\n        //since it is a leaf node it wont have any child \\n        if(root.left == null && root.right == null)\\n            return;\\n        //stand on parent and connect left child to right child\\n        root.left.next = root.right;\\n        \\n        //after connecting left child to right , connect parent\\'s right child via the next link we created above to left child of adjacent subtree.\\n        if(root.next != null)\\n            root.right.next = root.next.left;\\n        \\n        helper(root.left);\\n        helper(root.right);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1114796,
                "title": "python-recursion-constant-space-beats-98-short-solution",
                "content": "```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if not root or not root.left:\\n            return root\\n        \\n        root.left.next = root.right\\n        \\n        if root.next:\\n            root.right.next = root.next.left\\n        \\n        self.connect(root.left)\\n        self.connect(root.right)\\n        return root\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if not root or not root.left:\\n            return root\\n        \\n        root.left.next = root.right\\n        \\n        if root.next:\\n            root.right.next = root.next.left\\n        \\n        self.connect(root.left)\\n        self.connect(root.right)\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 934104,
                "title": "c-easy-iterative-solution",
                "content": "```\\nstruct Node* connect(struct Node* root) {\\n\\tif (!root)\\n        return root;\\n    \\n    struct Node* ptr_node = root;\\n    struct Node* first = ptr_node;\\n    \\n    while (ptr_node->left) {\\n        \\n        while (ptr_node) {\\n            \\n            ptr_node->left->next = ptr_node->right;\\n            \\n            if (ptr_node->next) {\\n                ptr_node->right->next = ptr_node->next->left;\\n            }\\n            \\n            ptr_node = ptr_node->next;\\n        }\\n        \\n        first = first->left;\\n        ptr_node = first;\\n    }\\n    \\n    return root;\\n}\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\nstruct Node* connect(struct Node* root) {\\n\\tif (!root)\\n        return root;\\n    \\n    struct Node* ptr_node = root;\\n    struct Node* first = ptr_node;\\n    \\n    while (ptr_node->left) {\\n        \\n        while (ptr_node) {\\n            \\n            ptr_node->left->next = ptr_node->right;\\n            \\n            if (ptr_node->next) {\\n                ptr_node->right->next = ptr_node->next->left;\\n            }\\n            \\n            ptr_node = ptr_node->next;\\n        }\\n        \\n        first = first->left;\\n        ptr_node = first;\\n    }\\n    \\n    return root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 508672,
                "title": "java-recursive-solution-100-o-n-time-o-1-space-o-n-stack-call",
                "content": "Feel free to discuss Big-O analysis :)\\n```java\\nclass Solution {\\n    public Node connect(Node root) {\\n        if (root == null) return null;\\n        if (root.left != null) root.left.next = root.right;\\n        if (root.right != null) root.right.next = root.next == null ? null : root.next.left;\\n        connect(root.left);\\n        connect(root.right);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```java\\nclass Solution {\\n    public Node connect(Node root) {\\n        if (root == null) return null;\\n        if (root.left != null) root.left.next = root.right;\\n        if (root.right != null) root.right.next = root.next == null ? null : root.next.left;\\n        connect(root.left);\\n        connect(root.right);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 286540,
                "title": "c-while",
                "content": "```\\npublic class Solution {\\n    public Node Connect(Node root) {\\n        var preMostLeft = root;\\n        while (preMostLeft != null) {\\n            var cur = preMostLeft;\\n            while (cur != null && cur.left != null) {\\n                cur.left.next = cur.right;\\n                if (cur.next != null) {\\n                    cur.right.next = cur.next.left;\\n                }\\n                cur = cur.next;\\n            }\\n\\n            preMostLeft = preMostLeft.left;\\n        }\\n\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public Node Connect(Node root) {\\n        var preMostLeft = root;\\n        while (preMostLeft != null) {\\n            var cur = preMostLeft;\\n            while (cur != null && cur.left != null) {\\n                cur.left.next = cur.right;\\n                if (cur.next != null) {\\n                    cur.right.next = cur.next.left;\\n                }\\n                cur = cur.next;\\n            }\\n\\n            preMostLeft = preMostLeft.left;\\n        }\\n\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 163183,
                "title": "java-c-c-solutions-elegant-iterative-solutions-4-lines-and-recursive-solutions-5-lines",
                "content": "# **C++**\\n## Recursive\\nSetting the _next_ pointer from the parent node makes for a clean solution. The only thing to worry about is how to handle the far right node of each level, which doesn\\'t have a _next_. This is easy to check for too, just check if the parent node has a _next_ pointer, if it doesn\\'t, then you\\'re at the far right.\\n```cpp\\n  void connect(TreeLinkNode *root) {\\n    if (root && root->left) {\\n      root->left->next = root->right;\\n      root->right->next = (root->next) ? root->next->left : nullptr;\\n      connect(root->left);\\n      connect(root->right);\\n    }\\n  }\\n```\\t\\n## Iterative\\nSet the _next_ pointer starting from the left of each level, then you can use the _next_ pointer to progress from left to right to complete the level. Once a level is finshed, advance down the left branch and do it again.\\n```cpp\\n  void connect(TreeLinkNode *root) {\\n    for (; root && root->left; root = root->left) {\\n      for (TreeLinkNode* pos = root; pos; pos = pos->next) {\\n        pos->left->next = pos->right;\\n        pos->right->next = (pos->next) ? pos->next->left : nullptr;\\n      }\\n    }\\n  }\\n```\\t\\n# **Java**\\n## Recursive\\n```java\\n    public void connect(TreeLinkNode root) {\\n      if (null != root && null != root.left) {\\n        root.left.next = root.right;\\n        root.right.next = (null != root.next) ? root.next.left : null;\\n        connect(root.left);\\n        connect(root.right);\\n      }\\n    }\\n```\\n## Iterative\\n```java\\n    public void connect(TreeLinkNode root) {\\n      for (; null != root && null != root.left; root = root.left) {\\n        for (TreeLinkNode pos = root; null != pos; pos = pos.next) {\\n          pos.left.next = pos.right;\\n          pos.right.next = (null != pos.next) ? pos.next.left : null;\\n        }\\n      }\\n    }\\n```\\n# **C**\\nSince a c solution would look very much like the c++ solution, I did it slightly differently, but is essentially the same.\\n```c\\nstruct Node* connect(struct Node* root) {\\n  if (root) {\\n    for (struct Node* row_start = root; row_start->left; row_start = row_start->left) {\\n      struct Node* pos = row_start;\\n      for (; pos->next; pos = pos->next) {\\n        pos->left->next = pos->right;\\n        pos->right->next = pos->next->left;\\n      }\\n      pos->left->next = pos->right;\\n    }\\n  }\\n  return root;\\n}\\n```\\n\\n**Note that all solutions abuse the fact that the tree is by definition a perfect binary tree. [Solutions that don\\'t require perfect tree can be found here](https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/discuss/163809/C++-iterative-O(1)-space.-Short-and-easy-to-understand-with-detail.-Bonus-2-line-solution-for-fun)**\\n",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```cpp\\n  void connect(TreeLinkNode *root) {\\n    if (root && root->left) {\\n      root->left->next = root->right;\\n      root->right->next = (root->next) ? root->next->left : nullptr;\\n      connect(root->left);\\n      connect(root->right);\\n    }\\n  }\\n```\n```cpp\\n  void connect(TreeLinkNode *root) {\\n    for (; root && root->left; root = root->left) {\\n      for (TreeLinkNode* pos = root; pos; pos = pos->next) {\\n        pos->left->next = pos->right;\\n        pos->right->next = (pos->next) ? pos->next->left : nullptr;\\n      }\\n    }\\n  }\\n```\n```java\\n    public void connect(TreeLinkNode root) {\\n      if (null != root && null != root.left) {\\n        root.left.next = root.right;\\n        root.right.next = (null != root.next) ? root.next.left : null;\\n        connect(root.left);\\n        connect(root.right);\\n      }\\n    }\\n```\n```java\\n    public void connect(TreeLinkNode root) {\\n      for (; null != root && null != root.left; root = root.left) {\\n        for (TreeLinkNode pos = root; null != pos; pos = pos.next) {\\n          pos.left.next = pos.right;\\n          pos.right.next = (null != pos.next) ? pos.next.left : null;\\n        }\\n      }\\n    }\\n```\n```c\\nstruct Node* connect(struct Node* root) {\\n  if (root) {\\n    for (struct Node* row_start = root; row_start->left; row_start = row_start->left) {\\n      struct Node* pos = row_start;\\n      for (; pos->next; pos = pos->next) {\\n        pos->left->next = pos->right;\\n        pos->right->next = pos->next->left;\\n      }\\n      pos->left->next = pos->right;\\n    }\\n  }\\n  return root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 37642,
                "title": "a-simple-0-ms-recursive-solution-without-helper-function",
                "content": "    public void connect(TreeLinkNode root) {\\n        if (root == null){\\n            return;\\n        }\\n        \\n        if (root.left != null){\\n            root.left.next = root.right;\\n            if (root.next != null){\\n                root.right.next = root.next.left;\\n            }\\n        }\\n        \\n        connect(root.left);\\n        connect(root.right);\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public void connect(TreeLinkNode root) {\\n        if (root == null){\\n            return;\\n        }\\n        \\n        if (root.left != null){\\n            root.left.next = root.right;\\n            if (root.next != null){\\n                root.right.next = root.next.left;\\n            }\\n        }\\n        \\n        connect(root.left);\\n        connect(root.right);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 37720,
                "title": "another-accepted-java-solution",
                "content": "Basically, we use the next pointer to help level traversal. No recursion is needed, O(1) constant space, O(n) running time.\\n\\n    public class Solution {\\n        public void connect(TreeLinkNode root) {\\n            if (root == null) return;\\n            \\n            while (root.left != null) {\\n                TreeLinkNode curr = root;\\n                \\n                while (curr != null) {\\n                    curr.left.next = curr.right;\\n                    curr.right.next = curr.next != null ? curr.next.left : null;\\n                    curr = curr.next;\\n                }\\n                \\n                root = root.left;\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public void connect(TreeLinkNode root) {\\n            if (root == null) return;\\n            \\n            while (root.left != null) {\\n                TreeLinkNode curr = root;\\n                \\n                while (curr != null) {\\n                    curr.left.next = curr.right;\\n                    curr.right.next = curr.next != null ? curr.next.left : null;\\n                    curr = curr.next;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 37749,
                "title": "sharing-my-java-o-1-extra-space-code",
                "content": "    public void connect(TreeLinkNode root) {\\n        TreeLinkNode cur;\\n        TreeLinkNode nextLevel = root;\\n        while (nextLevel != null) {\\n            cur = nextLevel;\\n            // at each level, connects the children nodes\\n            while (cur != null && \\n                    cur.left != null // checking for leaf nodes\\n                    ) \\n            {\\n                cur.left.next = cur.right;\\n                if (cur.next != null) {\\n                    cur.right.next = cur.next.left;\\n                }\\n                cur = cur.next; \\n            }\\n            \\n            nextLevel = nextLevel.left;\\n            \\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public void connect(TreeLinkNode root) {\\n        TreeLinkNode cur;\\n        TreeLinkNode nextLevel = root;\\n        while (nextLevel != null) {\\n            cur = nextLevel;\\n            // at each level, connects the children nodes\\n            while (cur != null && \\n                    cur.left != null // checking for leaf nodes\\n                    ) \\n            {\\n                cur.left.next = cur.right;\\n                if (cur.next != null) {\\n                    cur.right.next = cur.next.left;\\n                }\\n                cur = cur.next; \\n            }\\n            \\n            nextLevel = nextLevel.left;\\n            \\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 37787,
                "title": "simple-iterative-solution",
                "content": "Populate the levels one by one. curLevel points to node whose children will be linked, nextLevel points to the first node in the next level.\\n\\n    class Solution {\\n    public:\\n        void connect(TreeLinkNode *root) {\\n            if(!root)return;\\n            TreeLinkNode*curLevel=root,*nextLevel=root->left;\\n            root->next=NULL;\\n            while(curLevel->left){\\n                curLevel->left->next=curLevel->right;\\n                if (curLevel->next){\\n                    curLevel->right->next = curLevel->next->left;\\n                    curLevel=curLevel->next;\\n                }\\n                else {\\n                    curLevel->right->next=NULL;\\n                    curLevel=nextLevel;\\n                    nextLevel=nextLevel->left;\\n                }\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void connect(TreeLinkNode *root) {\\n            if(!root)return;\\n            TreeLinkNode*curLevel=root,*nextLevel=root->left;\\n            root->next=NULL;\\n            while(curLevel->left){\\n                curLevel->left->next=curLevel->right;\\n                if (curLevel->next){\\n                    curLevel->right->next = curLevel->next->left;\\n                    curLevel=curLevel->next;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 37793,
                "title": "my-recursive-solution",
                "content": "    void connect(TreeLinkNode *root) {\\n        if( root == NULL || root->left == NULL && root->right == NULL )        //{} \\\\ {0}\\n        {\\n           return;\\n        }\\n        \\n        TreeLinkNode *p, *q;\\n        p = root->left;\\n        q = root->right;\\n        p->next = q;\\n        while( p->right != NULL )\\n        {\\n            p = p->right;\\n            q = q->left;\\n            p->next = q;\\n        }\\n        \\n        connect( root->left );\\n        connect( root->right );\\n    }",
                "solutionTags": [],
                "code": "    void connect(TreeLinkNode *root) {\\n        if( root == NULL || root->left == NULL && root->right == NULL )        //{} \\\\ {0}\\n        {\\n           return;\\n        }\\n        \\n        TreeLinkNode *p, *q;\\n        p = root->left;\\n        q = root->right;\\n        p->next = q;\\n        while( p->right != NULL )\\n        {\\n            p = p->right;\\n            q = q->left;\\n            p->next = q;\\n        }\\n        \\n        connect( root->left );\\n        connect( root->right );\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3687361,
                "title": "2-ms-easy-to-understand-using-queue-level-order-traversal-java-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe approach used here is based on level-order traversal of the tree using a queue. The intuition behind the solution is that by traversing the tree level by level, we can keep track of the next right node for each node in the current level and establish the connections.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nA while loop processes each level. Inside the loop, a for loop iterates through each node, connecting it to the next node in the same level if applicable. Nodes with children are added to the queue for the next level. The process continues until all nodes in the current level are processed.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ \\n    (n is number of nodes)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m)$$ \\n  (m is maximum number of nodes in a level)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```Java []\\nclass Solution {\\n    public Node connect(Node root) {\\n        if (root == null) {\\n            return null;\\n        }\\n\\n        Queue<Node> queue = new LinkedList<>();\\n        queue.add(root);\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size(); // Store the size of the current level\\n\\n            for (int i = 0; i < size; i++) {\\n                Node node = queue.remove(); // Remove a node from the queue\\n\\n                if (i < size - 1) {\\n                    node.next = queue.peek(); // Set the next pointer to the node at the front of the queue\\n                }\\n\\n                if (node.left != null) {\\n                    queue.add(node.left); // Add the left child to the queue\\n                }\\n                if (node.right != null) {\\n                    queue.add(node.right); // Add the right child to the queue\\n                }\\n            }\\n        }\\n\\n        return root; // Return the modified root node\\n    }\\n}\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if (root == nullptr) return nullptr;\\n\\n        queue<Node*> queue;\\n        queue.push(root);\\n\\n        while (!queue.empty()) {\\n            int size = queue.size();\\n\\n            for (int i = 0; i < size; i++) {\\n                Node* node = queue.front();\\n                queue.pop();\\n\\n                if (i < size - 1) \\n                    node->next = queue.front();\\n                \\n                if (node->left != nullptr) \\n                    queue.push(node->left);\\n                \\n                if (node->right != nullptr) \\n                    queue.push(node->right);              \\n            }\\n        }\\n\\n        return root;\\n    }\\n};\\n\\n```\\nPLease upvote if u found it useful :)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Breadth-First Search",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```Java []\\nclass Solution {\\n    public Node connect(Node root) {\\n        if (root == null) {\\n            return null;\\n        }\\n\\n        Queue<Node> queue = new LinkedList<>();\\n        queue.add(root);\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size(); // Store the size of the current level\\n\\n            for (int i = 0; i < size; i++) {\\n                Node node = queue.remove(); // Remove a node from the queue\\n\\n                if (i < size - 1) {\\n                    node.next = queue.peek(); // Set the next pointer to the node at the front of the queue\\n                }\\n\\n                if (node.left != null) {\\n                    queue.add(node.left); // Add the left child to the queue\\n                }\\n                if (node.right != null) {\\n                    queue.add(node.right); // Add the right child to the queue\\n                }\\n            }\\n        }\\n\\n        return root; // Return the modified root node\\n    }\\n}\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if (root == nullptr) return nullptr;\\n\\n        queue<Node*> queue;\\n        queue.push(root);\\n\\n        while (!queue.empty()) {\\n            int size = queue.size();\\n\\n            for (int i = 0; i < size; i++) {\\n                Node* node = queue.front();\\n                queue.pop();\\n\\n                if (i < size - 1) \\n                    node->next = queue.front();\\n                \\n                if (node->left != nullptr) \\n                    queue.push(node->left);\\n                \\n                if (node->right != nullptr) \\n                    queue.push(node->right);              \\n            }\\n        }\\n\\n        return root;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2753478,
                "title": "java-beauty-and-easy-solution-explained-visualized-o-n-algo-o-1-memo",
                "content": "The task boils down to understanding the structure of the tree and how to traverse it.\\nThe solution is that we create a method that **contains the right and left nodes of the same level**.\\n1. We connect the left node with the right one using the `next` field.\\n2. The **next** left node of the current left one is combined with the **next** right one.\\n3. The **next** left node of the current right node is combined with the **next** right node.\\n4. And we also take **the next right node of the left one** and combine it with **the left node of the right one**. This is the most difficult step and is the key to solving the problem.\\n\\n**See the image below!** It turns out that we first connected two nodes and then connected their next level. Moreover, first they combined the \"children\" of the left, then the \"children\" of the right, and then they were united.\\n\\n```java\\nclass Solution {\\n        public static Node connect(Node root) {\\n        if (root == null || (root.left == null && root.right == null)) return root;\\n\\n        connectNext(root.left, root.right);\\n\\n        return root;\\n    }\\n\\n    private static void connectNext(Node left, Node right) {\\n        if (left == null || right == null) return;\\n        left.next = right; // Step 1 - comments only for the image below!\\n\\t\\t\\n        connectNext(left.left, left.right); // Step 2\\n        connectNext(left.right, right.left); // Step 3\\n        connectNext(right.left, right.right); // Step 4\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/1f554560-3085-44a7-b2e8-b16c0958a069_1666979901.3168855.png)\\n\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```java\\nclass Solution {\\n        public static Node connect(Node root) {\\n        if (root == null || (root.left == null && root.right == null)) return root;\\n\\n        connectNext(root.left, root.right);\\n\\n        return root;\\n    }\\n\\n    private static void connectNext(Node left, Node right) {\\n        if (left == null || right == null) return;\\n        left.next = right; // Step 1 - comments only for the image below!\\n\\t\\t\\n        connectNext(left.left, left.right); // Step 2\\n        connectNext(left.right, right.left); // Step 3\\n        connectNext(right.left, right.right); // Step 4\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424026,
                "title": "python-c-java-beginner-level-solution-100-faster-simple-short-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome*.**\\n___________________\\n_________________\\n***Q116. Populating Next Right Pointers in Each Node***\\n\\nYou are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:\\n```\\nstruct Node {\\n  int val;\\n  Node *left;\\n  Node *right;\\n  Node *next;\\n}\\n```\\nPopulate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.\\nInitially, all next pointers are set to NULL.\\n____________________________________________________________________________________________________________________\\n\\n***Time complexity*** - O(n)\\n***Space complexity*** - O(1)\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Java Code** :\\n**Runtime**: 0 ms, faster than 100.00% of Java online submissions for Populating Next Right Pointers in Each Node.\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return root;\\n        Node current = root;\\n        while(current != null) {\\n            Node level1stNode = current;\\n            while(current != null) \\n            {\\n                if(current.left != null) \\n                    current.left.next = current.right;\\n                if(current.right != null && current.next != null) \\n                    current.right.next = current.next.left;\\n\\n                current = current.next;\\n            }\\n            current = level1stNode.left;\\n        }\\n        return root;\\n    }\\n}\\n```\\n**Runtime:**  0ms\\n**Memory Usage:**  42.2 MB\\n\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Python  Code** :\\n\\n```\\nclass Solution:\\n    def connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if not root: return root        \\n        self.current = root\\n        while self.current:\\n            self.level1stNode = self.current\\n            while self.current:\\n                if self.current.left:\\n                    self.current.left.next = self.current.right\\n                    \\n                if self.current.right and self.current.next:\\n                    self.current.right.next = self.current.next.left\\n                    \\n                self.current = self.current.next\\n            self.current = self.level1stNode.left\\n        return root\\n```\\n**Runtime:**  131ms\\n**Memory Usage:**  13.8 MB\\n\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **C++  Code** :\\n\\n```\\n\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root) return root;\\n        Node* current = root;\\n        while(current) {\\n            Node* level1stNode = current;\\n            while(current) \\n            {\\n                if(current->left)\\n                    current->left->next = current->right;\\n                if(current->right && current->next)\\n                    current->right->next = current->next->left;\\n\\n                current = current->next;\\n            }\\n            current = level1stNode->left;\\n        }\\n        return root;\\n    }\\n};\\n```\\n**Runtime:**  41ms\\n**Memory Usage:**  69.7MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nstruct Node {\\n  int val;\\n  Node *left;\\n  Node *right;\\n  Node *next;\\n}\\n```\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return root;\\n        Node current = root;\\n        while(current != null) {\\n            Node level1stNode = current;\\n            while(current != null) \\n            {\\n                if(current.left != null) \\n                    current.left.next = current.right;\\n                if(current.right != null && current.next != null) \\n                    current.right.next = current.next.left;\\n\\n                current = current.next;\\n            }\\n            current = level1stNode.left;\\n        }\\n        return root;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if not root: return root        \\n        self.current = root\\n        while self.current:\\n            self.level1stNode = self.current\\n            while self.current:\\n                if self.current.left:\\n                    self.current.left.next = self.current.right\\n                    \\n                if self.current.right and self.current.next:\\n                    self.current.right.next = self.current.next.left\\n                    \\n                self.current = self.current.next\\n            self.current = self.level1stNode.left\\n        return root\\n```\n```\\n\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root) return root;\\n        Node* current = root;\\n        while(current) {\\n            Node* level1stNode = current;\\n            while(current) \\n            {\\n                if(current->left)\\n                    current->left->next = current->right;\\n                if(current->right && current->next)\\n                    current->right->next = current->next->left;\\n\\n                current = current->next;\\n            }\\n            current = level1stNode->left;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1808896,
                "title": "c-5-lines-code-very-easy-dfs-simple-explanation",
                "content": "This solution implements a recursive function - it takes a node, connects the NEXT pointers of it\\'s left & right children, and repeats the process for the children. So the algorithm is :\\nFor each non-leaf node, we do -\\n(1) NEXT of Left child is pointed to Right child. Easy.\\n(2) NEXT of Right child is pointed to NEXT node in the same level (i.e., parent\\'s NEXT\\'s left child).\\n\\nLet\\'s consider the below example. Assume we are at the node \"2\".\\n```\\n\\t\\t\\t\\t   1\\nwe are here\\t=>   2 -> 3\\n\\t\\t\\t   3  4  5  6\\n```\\n\\nSince we\\'re at 2, we would already have our NEXT pointer pointing to the node 3 (should have been done at node 1).\\nNow, we need to correctly set NEXT pointers of our children, i.e, 3 and 4. We follow the said algorithm here.\\nStep 1 : 3\\'s NEXT pointer should simply be set to 4.\\nStep 2 : We know 4\\'s NEXT pointer should now be set to 5. How do we do that? Remember we have 2\\'s NEXT set to 3 already? We\\'re going to use that to get reference of 3, and then reference of 5 - then we just use it! 4\\'s NEXT is set to 2\\'s NEXT\\'s left, which is 5.\\n\\nSo the tree now becomes -\\n\\n```\\n\\t\\t\\t\\t      1\\nwe are here\\t=>    2   ->   3\\n\\t\\t\\t   3 -> 4 -> 5    6\\n```\\n\\nWe repeat this process until all NEXT nodes are set. \\n\\nIn case of last node of a level (for ex: 6), we don\\'t have NEXT of our parent (3) anyway, so it\\'s defaulted to NULL as required already.\\nFor leaf nodes, we don\\'t have children to set so we return.\\n\\n\\nSolution Code in C++ \\n```\\nNode* connect(Node* root) {\\n\\tif(!root || !root->left) return root;                     // if given empty tree OR root is leaf node\\n\\troot->left->next = root->right;                           // making left child\\'s next point to right child\\n\\tif(root->next) root->right->next = root->next->left;      // right child\\'s next point to its parent\\'s next\\'s left node\\n\\troot->left = connect(root->left);                         // connect all next pointers in left subtree\\n\\troot->right = connect(root->right);                       // connect all next pointers in right subtree\\n\\treturn root;\\n}\\n```\\n\\nThanks! Upvote if this helped you!",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n\\t\\t\\t\\t   1\\nwe are here\\t=>   2 -> 3\\n\\t\\t\\t   3  4  5  6\\n```\n```\\n\\t\\t\\t\\t      1\\nwe are here\\t=>    2   ->   3\\n\\t\\t\\t   3 -> 4 -> 5    6\\n```\n```\\nNode* connect(Node* root) {\\n\\tif(!root || !root->left) return root;                     // if given empty tree OR root is leaf node\\n\\troot->left->next = root->right;                           // making left child\\'s next point to right child\\n\\tif(root->next) root->right->next = root->next->left;      // right child\\'s next point to its parent\\'s next\\'s left node\\n\\troot->left = connect(root->left);                         // connect all next pointers in left subtree\\n\\troot->right = connect(root->right);                       // connect all next pointers in right subtree\\n\\treturn root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1783750,
                "title": "level-order-easy-implementation",
                "content": "```\\nimport queue\\nclass Solution:\\n    def connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if root is None:\\n            return\\n        myqueue=queue.Queue()\\n        myqueue.put(root)\\n        myqueue.put(None)\\n        small=[]\\n        while myqueue.empty()==False:\\n            front=myqueue.get()\\n            if front!=None:\\n                if front.left!=None:\\n                    myqueue.put(front.left)\\n                if front.right!=None:\\n                    myqueue.put(front.right)\\n                small.append(front)\\n            else:\\n                if myqueue.empty()==True:\\n                    if len(small)==1:\\n                        front=small[0]\\n                        front.next=None\\n                    else:\\n                        for i in range(len(small)):\\n                            j=i+1\\n                            if j<=len(small)-1:\\n                                small[i].next=small[j]\\n                            if i==len(small)-1:\\n                                small[i].next=None\\n                    break\\n                else:\\n                    if len(small)==1:\\n                        small[0].next=None\\n                    else:\\n                        for i in range(len(small)):\\n                            j=i+1\\n                            if j<=len(small)-1:\\n                                small[i].next=small[j]\\n                            if i==len(small)-1:\\n                                small[i].next=None\\n                small=[]\\n                myqueue.put(None)    \\n        return root\\n```",
                "solutionTags": [],
                "code": "```\\nimport queue\\nclass Solution:\\n    def connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if root is None:\\n            return\\n        myqueue=queue.Queue()\\n        myqueue.put(root)\\n        myqueue.put(None)\\n        small=[]\\n        while myqueue.empty()==False:\\n            front=myqueue.get()\\n            if front!=None:\\n                if front.left!=None:\\n                    myqueue.put(front.left)\\n                if front.right!=None:\\n                    myqueue.put(front.right)\\n                small.append(front)\\n            else:\\n                if myqueue.empty()==True:\\n                    if len(small)==1:\\n                        front=small[0]\\n                        front.next=None\\n                    else:\\n                        for i in range(len(small)):\\n                            j=i+1\\n                            if j<=len(small)-1:\\n                                small[i].next=small[j]\\n                            if i==len(small)-1:\\n                                small[i].next=None\\n                    break\\n                else:\\n                    if len(small)==1:\\n                        small[0].next=None\\n                    else:\\n                        for i in range(len(small)):\\n                            j=i+1\\n                            if j<=len(small)-1:\\n                                small[i].next=small[j]\\n                            if i==len(small)-1:\\n                                small[i].next=None\\n                small=[]\\n                myqueue.put(None)    \\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1653771,
                "title": "java-o-1-memory-solution-recursive-iterative-faster-than-100",
                "content": "**1. Recurisve**\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null)\\n            return root;\\n        if(root.left != null){\\n            if(root.next != null)\\n                root.right.next = root.next.left;\\n            else\\n                root.right.next = null;\\n            root.left.next = root.right;\\n            connect(root.left);\\n            connect(root.right);\\n        }\\n        return root;\\n    }\\n}\\n```\\n\\n**2. Iterative**\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        Node leftest = root;\\n        while(leftest != null && leftest.left != null) {\\n        \\tNode curr = leftest;\\n        \\twhile(true) {\\n        \\t\\tcurr.left.next = curr.right;\\n        \\t\\tif(curr.next != null)\\n        \\t\\t\\tcurr.right.next = curr.getNextSibling().left;\\n        \\t\\telse\\n        \\t\\t\\tbreak;\\n        \\t}\\n        \\tcurr = curr.left;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null)\\n            return root;\\n        if(root.left != null){\\n            if(root.next != null)\\n                root.right.next = root.next.left;\\n            else\\n                root.right.next = null;\\n            root.left.next = root.right;\\n            connect(root.left);\\n            connect(root.right);\\n        }\\n        return root;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        Node leftest = root;\\n        while(leftest != null && leftest.left != null) {\\n        \\tNode curr = leftest;\\n        \\twhile(true) {\\n        \\t\\tcurr.left.next = curr.right;\\n        \\t\\tif(curr.next != null)\\n        \\t\\t\\tcurr.right.next = curr.getNextSibling().left;\\n        \\t\\telse\\n        \\t\\t\\tbreak;\\n        \\t}\\n        \\tcurr = curr.left;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1600990,
                "title": "very-easy-bfs-solution-c-hint-for-constant-space",
                "content": "Hint for constant space -> is to use the next links that you just created \\n```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root == NULL) return root;\\n        queue<Node*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int n=q.size();\\n            int j=0;\\n            for(int i=0;i<n;i++){\\n                Node* node = q.front();\\n                q.pop();\\n                j++;\\n                if(j<n){\\n                    Node* x = q.front();\\n                    node->next = x;\\n                }else{\\n                    node->next = NULL;\\n                }\\n                if(node->left) q.push(node->left);\\n                if(node->right) q.push(node->right);\\n                \\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root == NULL) return root;\\n        queue<Node*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int n=q.size();\\n            int j=0;\\n            for(int i=0;i<n;i++){\\n                Node* node = q.front();\\n                q.pop();\\n                j++;\\n                if(j<n){\\n                    Node* x = q.front();\\n                    node->next = x;\\n                }else{\\n                    node->next = NULL;\\n                }\\n                if(node->left) q.push(node->left);\\n                if(node->right) q.push(node->right);\\n                \\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1497972,
                "title": "c-o-1-space-o-n-time-7-lines-solution",
                "content": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* left;\\n    Node* right;\\n    Node* next;\\n\\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val, Node* _left, Node* _right, Node* _next)\\n        : val(_val), left(_left), right(_right), next(_next) {}\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root && root->left != NULL) {\\n            root->left->next = root->right;\\n            connect(root->left);\\n            if(root->next != NULL) root->right->next = root->next->left;\\n            connect(root->right);\\n        }\\n        \\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* left;\\n    Node* right;\\n    Node* next;\\n\\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val, Node* _left, Node* _right, Node* _next)\\n        : val(_val), left(_left), right(_right), next(_next) {}\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root && root->left != NULL) {\\n            root->left->next = root->right;\\n            connect(root->left);\\n            if(root->next != NULL) root->right->next = root->next->left;\\n            connect(root->right);\\n        }\\n        \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1136720,
                "title": "java-solution-10-lines-code-o-n-time-and-constant-space",
                "content": "Idea here to take advantage of already set values of next. When going to child, parent will already have their next value. We can take advantage of that. This is the minimize solution.\\n\\n```\\npublic Node connect(Node root) {\\n        if(root == null) return root;\\n        modify(root);\\n        \\n        return root;\\n    }\\n    public void modify(Node root){\\n        if(root.left == null && root.right == null){\\n            return;\\n        }\\n        root.left.next = root.right;\\n        if(root.next !=null ){\\n            root.right.next = root.next.left;    \\n        }\\n        modify(root.left);\\n        modify(root.right);  \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic Node connect(Node root) {\\n        if(root == null) return root;\\n        modify(root);\\n        \\n        return root;\\n    }\\n    public void modify(Node root){\\n        if(root.left == null && root.right == null){\\n            return;\\n        }\\n        root.left.next = root.right;\\n        if(root.next !=null ){\\n            root.right.next = root.next.left;    \\n        }\\n        modify(root.left);\\n        modify(root.right);  \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 953162,
                "title": "python-jump-game-iii-with-queue-deque-visited-set",
                "content": "BFS to iterate through all indexes connected to starting index. Storing already explored indices allows us to ensure that we only explore each index a single time.\\n\\t\\n\\tdef canReach(self, arr, start):\\n        \\n        q = collections.deque()\\n        q.append(start)\\n        visited = set()\\n        \\n        while q:\\n            cur_i = q.popleft()\\n            \\n            if arr[cur_i] == 0:\\n                return True\\n            \\n            a, b = cur_i + arr[cur_i], cur_i - arr[cur_i]\\n            \\n            if a < len(arr) and a not in visited:\\n                q.append(a)\\n                visited.add(a)\\n            if b >= 0 and b not in visited:\\n                q.append(b)\\n                visited.add(b)\\n                \\n        return False",
                "solutionTags": [],
                "code": "BFS to iterate through all indexes connected to starting index. Storing already explored indices allows us to ensure that we only explore each index a single time.\\n\\t\\n\\tdef canReach(self, arr, start):\\n        \\n        q = collections.deque()\\n        q.append(start)\\n        visited = set()\\n        \\n        while q:\\n            cur_i = q.popleft()\\n            \\n            if arr[cur_i] == 0:\\n                return True\\n            \\n            a, b = cur_i + arr[cur_i], cur_i - arr[cur_i]\\n            \\n            if a < len(arr) and a not in visited:\\n                q.append(a)\\n                visited.add(a)\\n            if b >= 0 and b not in visited:\\n                q.append(b)\\n                visited.add(b)\\n                \\n        return False",
                "codeTag": "Python3"
            },
            {
                "id": 935186,
                "title": "c-constant-space-iterative-recursive",
                "content": "Iteraitve Solution \\n\\n```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root || !root->left) return root;\\n        Node *current = root;\\n        while(current->left) {\\n            Node *temp = current;\\n            while(current) {\\n                current->left->next = current->right;\\n                if(current->next) current->right->next = current->next->left;\\n                current = current->next;\\n            }\\n            current = temp->left;\\n        }\\n        return root;\\n    }\\n};\\n```\\n\\nRecursive Solution \\n\\n```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root || !root->left) return root;\\n        root->left->next = root->right;\\n        if(root->next) root->right->next = root->next->left;\\n        connect(root->left);\\n        connect(root->right);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root || !root->left) return root;\\n        Node *current = root;\\n        while(current->left) {\\n            Node *temp = current;\\n            while(current) {\\n                current->left->next = current->right;\\n                if(current->next) current->right->next = current->next->left;\\n                current = current->next;\\n            }\\n            current = temp->left;\\n        }\\n        return root;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root || !root->left) return root;\\n        root->left->next = root->right;\\n        if(root->next) root->right->next = root->next->left;\\n        connect(root->left);\\n        connect(root->right);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 762896,
                "title": "5-lines-recursive-python-solution",
                "content": "\\n```\\nclass Solution:\\n    def connect(self, root: \\'Node\\', next=None) -> \\'Node\\':\\n        if root is None: return None\\n        root.next = next\\n        self.connect(root.left, root.right)\\n        self.connect(root.right, root.next.left if root.next else None)\\n        return root\\n```",
                "solutionTags": [
                    "Python",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def connect(self, root: \\'Node\\', next=None) -> \\'Node\\':\\n        if root is None: return None\\n        root.next = next\\n        self.connect(root.left, root.right)\\n        self.connect(root.right, root.next.left if root.next else None)\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 629881,
                "title": "go-golang-dfs-bfs",
                "content": "1. DFS\\n```golang\\n/**\\n * Definition for a Node.\\n * type Node struct {\\n *     Val int\\n *     Left *Node\\n *     Right *Node\\n *     Next *Node\\n * }\\n */\\n\\nfunc connect(root *Node) *Node {\\n    if root == nil {\\n        return nil\\n    }\\n    \\n    if root.Left != nil {\\n        root.Left.Next = root.Right\\n        \\n        if root.Next != nil {\\n            root.Right.Next = root.Next.Left\\n        }\\n    }\\n    \\n    connect(root.Left)\\n    connect(root.Right)\\n    \\n    return root\\n}\\n```\\n2. BFS\\n```golang\\n/**\\n * Definition for a Node.\\n * type Node struct {\\n *     Val int\\n *     Left *Node\\n *     Right *Node\\n *     Next *Node\\n * }\\n */\\n\\nfunc connect(root *Node) *Node {\\n    if root == nil {\\n        return nil\\n    }\\n    \\n    q := []*Node{ root }\\n    \\n    for len(q) > 0 {\\n        var pre *Node\\n        \\n        for _, n := range q {\\n            q = q[1:]\\n            \\n            if pre != nil {\\n                pre.Next = n\\n            }\\n            \\n            pre = n\\n            \\n            if n.Left != nil {\\n                q = append(q, n.Left)\\n            }\\n            \\n            if n.Right != nil {\\n                q = append(q, n.Right)\\n            }\\n        }\\n    }\\n    \\n    return root\\n}\\n```",
                "solutionTags": [],
                "code": "```golang\\n/**\\n * Definition for a Node.\\n * type Node struct {\\n *     Val int\\n *     Left *Node\\n *     Right *Node\\n *     Next *Node\\n * }\\n */\\n\\nfunc connect(root *Node) *Node {\\n    if root == nil {\\n        return nil\\n    }\\n    \\n    if root.Left != nil {\\n        root.Left.Next = root.Right\\n        \\n        if root.Next != nil {\\n            root.Right.Next = root.Next.Left\\n        }\\n    }\\n    \\n    connect(root.Left)\\n    connect(root.Right)\\n    \\n    return root\\n}\\n```\n```golang\\n/**\\n * Definition for a Node.\\n * type Node struct {\\n *     Val int\\n *     Left *Node\\n *     Right *Node\\n *     Next *Node\\n * }\\n */\\n\\nfunc connect(root *Node) *Node {\\n    if root == nil {\\n        return nil\\n    }\\n    \\n    q := []*Node{ root }\\n    \\n    for len(q) > 0 {\\n        var pre *Node\\n        \\n        for _, n := range q {\\n            q = q[1:]\\n            \\n            if pre != nil {\\n                pre.Next = n\\n            }\\n            \\n            pre = n\\n            \\n            if n.Left != nil {\\n                q = append(q, n.Left)\\n            }\\n            \\n            if n.Right != nil {\\n                q = append(q, n.Right)\\n            }\\n        }\\n    }\\n    \\n    return root\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 504940,
                "title": "easy-understand-python-solution",
                "content": "class Solution(object):\\n\\n    def connect(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: Node\\n        \"\"\"\\n        if not root:\\n            return None\\n        if not root.left:\\n            return root\\n        root.left.next = root.right\\n        if root.next:\\n            root.right.next = root.next.left\\n        self.connect(root.left)\\n        self.connect(root.right)\\n        return root",
                "solutionTags": [],
                "code": "class Solution(object):\\n\\n    def connect(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: Node\\n        \"\"\"\\n        if not root:\\n            return None\\n        if not root.left:\\n            return root\\n        root.left.next = root.right\\n        if root.next:\\n            root.right.next = root.next.left\\n        self.connect(root.left)\\n        self.connect(root.right)\\n        return root",
                "codeTag": "Java"
            },
            {
                "id": 307621,
                "title": "simple-recursive-preorder-traversal",
                "content": "```\\npublic void connectHelper(Node root){\\n\\tif(root == null) return;\\n\\tif(root.left != null) root.left.next = root.right;\\n\\tif(root.right != null) root.right.next = (root.next == null) ? null: root.next.left;\\n\\tconnectHelper(root.left);\\n\\tconnectHelper(root.right);\\n\\n}\\npublic Node connect(Node root) {\\n\\tconnectHelper(root);\\n\\treturn root;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic void connectHelper(Node root){\\n\\tif(root == null) return;\\n\\tif(root.left != null) root.left.next = root.right;\\n\\tif(root.right != null) root.right.next = (root.next == null) ? null: root.next.left;\\n\\tconnectHelper(root.left);\\n\\tconnectHelper(root.right);\\n\\n}\\npublic Node connect(Node root) {\\n\\tconnectHelper(root);\\n\\treturn root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 291622,
                "title": "python-recursive-solution",
                "content": "\\u5728\\u8FD9\\u4E2Arecursion chapter\\u5B66\\u4E60\\u81EA\\u5DF1\\u609F\\u51FA\\u6765\\u7684\\u4E00\\u4E2A\\u65B9\\u6CD5\\u3002\\n\\u4ECEexample\\u53EF\\u4EE5\\u53D1\\u73B0\\u7ED9\\u7684\\u89C4\\u5F8B\\u5C31\\u662F\\n\\u6BCF\\u4E2A\\u8282\\u70B9\\uFF08\\u975E\\u53F6\\u5B50\\u7ED3\\u70B9\\uFF09\\u5FC5\\u6709\\u4E24\\u4E2A\\u5B50\\u8282\\u70B9\\n\\u5BF9\\u6BCF\\u4E00level\\u7684\\u8282\\u70B9\\u90FD\\u8FDB\\u884C\\u5982\\u4E0B\\u64CD\\u4F5C\\nleft.next = right\\nright.next = None\\n\\u4F46\\u662F\\u8FD9\\u91CC\\u53EA\\u662F\\u8FDE\\u63A5\\u4E86\\u4E24\\u4E2A\\u8282\\u70B9\\uFF0C\\u4E00\\u5C42level\\u91CC\\u9762\\u8282\\u70B9\\u4E0D\\u6B62\\u8FD9\\u4E48\\u591A\\uFF0C\\u8FD8\\u6709\\u4E2D\\u95F4\\u7684\\uFF0C\\u5C31\\u662F\\u5DE6\\u5B50\\u6811\\u548C\\u53F3\\u5B50\\u6811\\u7684\\u4E4B\\u95F4\\u7684\\u5DE6\\u5B50\\u6811\\u7684\\u53F3\\u8282\\u70B9\\uFF0C\\u548C\\u53F3\\u5B50\\u6811\\u7684\\u5DE6\\u8282\\u70B9\\u8981\\u8FDE\\u63A5\\u8D77\\u6765\\uFF0C\\u6240\\u4EE5\\u9012\\u5F52\\u5199\\u4E86\\u4E2D\\u95F4\\u7684\\nconnect(left.right,right,left)\\n\\u867D\\u7136\\u6700\\u540E\\u5B9E\\u73B0\\u4E86\\u7A0B\\u5E8F\\uFF0C\\u4F46\\u662F\\u6539\\u8FDB\\u7684\\u5730\\u65B9\\u8FD8\\u662F\\u6709\\u5E8F\\u591A\\n\\u5C31\\u6BD4\\u5982\\uFF0C\\u8FD9\\u4E2Aright.next = None\\uFF0C\\u8FD9\\u91CC\\u64CD\\u4F5C\\u4E86\\u591A\\u6B21\\uFF0C\\u5982\\u679C\\u53EF\\u4EE5\\u53EA\\u8981\\u8FDE\\u63A5\\u4E00\\u6B21\\u5C31\\u8FDE\\u4E0A\\u7684\\u8BDD\\u662F\\u6700\\u597D\\u7684\\u4E86\\u3002\\n```\\nclass Solution(object):\\n    def connect(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: Node\\n        \"\"\"\\n        if not root:\\n            return None\\n        root.next = None\\n        def connect(left,right):\\n            if left and right:\\n                left.next = right\\n                right.next = None\\n                connect(left.left,left.right)\\n                connect(left.right,right.left)\\n                connect(right.left,right.right)\\n        connect(root.left,root.right)\\n        return root\\n```\\n\\u5F88\\u660E\\u663E\\u8FD9\\u4E2A\\u4E5F\\u53EF\\u4EE5\\u7528BFS\\u6765\\u505A\\uFF0C\\u540C\\u6837\\uFF0C\\u4E5F\\u662F\\u4E4B\\u524D\\u4ECE\\u8BC4\\u8BBA\\u91CC\\u9762\\u5B66\\u5230\\u7684queue\\u5B9E\\u73B0\\u7684BFS\\u6765\\u89E3\\u51B3\\u8FD9\\u91CC\\u7684\\u95EE\\u9898\\n```\\nfrom collections import deque\\n\\nclass Solution(object):\\n    def connect(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: Node\\n        \"\"\"\\n        if not root:\\n            return None\\n        root.next = None\\n        queue = deque([root])\\n        while queue:\\n            temp,size=[],len(queue)\\n            for i in range(size):\\n                node = queue.popleft()\\n                if node:\\n                    temp.append(node)\\n                if node.left and node.right:\\n                    queue.append(node.left)\\n                    queue.append(node.right)\\n            for index,node in enumerate(temp[:-1]):\\n                node.next = temp[index+1]\\n            temp[-1].next = None\\n        return root\\n```\\n\\u4ECE\\u8BC4\\u8BBA\\u91CC\\u9762\\u5B66\\u5230\\u7684\\u4E00\\u4E2A\\u65B9\\u6CD5\\uFF0C\\u786E\\u5B9E\\uFF0CBFS\\u53EF\\u4EE5\\u4F7F\\u7528\\uFF0C\\u4F46\\u662F\\u6211\\u4EEC\\u6CA1\\u6709\\u5FC5\\u8981\\u7528\\u4E00\\u4E2Aqueue\\u6765\\u5B58\\u50A8node\\uFF0C\\n\\u56E0\\u4E3Anode\\u6709next\\u8282\\u70B9\\uFF0C\\u5F53\\u6211\\u4EEC\\u6709\\u4E00\\u4E2A\\u5934\\u7ED3\\u70B9\\u4E4B\\u540E\\uFF0C\\u5C31\\u53EF\\u4EE5\\u50CF\\u94FE\\u8868\\u4E00\\u6837\\u53BB\\u8BBF\\u95EE\\u4E86\\u3002\\nreference\\uFF1A\\nhttps://leetcode.com/problems/populating-next-right-pointers-in-each-node/discuss/37465/Python-Solution-With-Explaintion\\n```\\nclass Solution(object):\\n    def connect(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: Node\\n        \"\"\"\\n        if not root:\\n            return None\\n        cur = root\\n        nex = cur.left\\n        while cur.left:\\n            cur.left.next = cur.right\\n            if cur.next:\\n                cur.right.next = cur.next.left\\n                cur = cur.next\\n            else:\\n                cur = nex\\n                nex = cur.left\\n        return root\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def connect(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: Node\\n        \"\"\"\\n        if not root:\\n            return None\\n        root.next = None\\n        def connect(left,right):\\n            if left and right:\\n                left.next = right\\n                right.next = None\\n                connect(left.left,left.right)\\n                connect(left.right,right.left)\\n                connect(right.left,right.right)\\n        connect(root.left,root.right)\\n        return root\\n```\n```\\nfrom collections import deque\\n\\nclass Solution(object):\\n    def connect(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: Node\\n        \"\"\"\\n        if not root:\\n            return None\\n        root.next = None\\n        queue = deque([root])\\n        while queue:\\n            temp,size=[],len(queue)\\n            for i in range(size):\\n                node = queue.popleft()\\n                if node:\\n                    temp.append(node)\\n                if node.left and node.right:\\n                    queue.append(node.left)\\n                    queue.append(node.right)\\n            for index,node in enumerate(temp[:-1]):\\n                node.next = temp[index+1]\\n            temp[-1].next = None\\n        return root\\n```\n```\\nclass Solution(object):\\n    def connect(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: Node\\n        \"\"\"\\n        if not root:\\n            return None\\n        cur = root\\n        nex = cur.left\\n        while cur.left:\\n            cur.left.next = cur.right\\n            if cur.next:\\n                cur.right.next = cur.next.left\\n                cur = cur.next\\n            else:\\n                cur = nex\\n                nex = cur.left\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 37658,
                "title": "a-simple-java-recursive-solution-in-6-lines",
                "content": "    public void connect(TreeLinkNode root) {\\n        if (root == null || root.left ==null) return;\\n        root.left.next = root.right;\\n        if (root.next!=null)\\n        root.right.next = root.next.left;\\n        connect(root.left);\\n        connect(root.right);\\n    }",
                "solutionTags": [],
                "code": "    public void connect(TreeLinkNode root) {\\n        if (root == null || root.left ==null) return;\\n        root.left.next = root.right;\\n        if (root.next!=null)\\n        root.right.next = root.next.left;\\n        connect(root.left);\\n        connect(root.right);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 37668,
                "title": "9-line-fast-c-without-recursion",
                "content": "    class Solution {\\n    public:\\n        void connect(TreeLinkNode *root) {\\n            while (root) {\\n                TreeLinkNode *a = root;\\n                while (a) {\\n                    if (a->left) {\\n                        a->left->next = a->right;\\n                        if (a->next)\\n                            a->right->next = a->next->left;\\n                    }\\n                    a=a->next;\\n                }\\n                root=root->left;\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void connect(TreeLinkNode *root) {\\n            while (root) {\\n                TreeLinkNode *a = root;\\n                while (a) {\\n                    if (a->left) {\\n                        a->left->next = a->right;\\n                        if (a->next)\\n                            a->right->next = a->next->left;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3482395,
                "title": "easy-o-n-intutive-c-solution-by-bfs-please-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* left;\\n    Node* right;\\n    Node* next;\\n\\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val, Node* _left, Node* _right, Node* _next)\\n        : val(_val), left(_left), right(_right), next(_next) {}\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        int i,j,k,c=0;\\n        int d1,d2;\\n        queue<Node*>q;\\n        vector<int>ans;\\n\\n        if(!root)\\n        return 0;\\n        q.push(root);\\n\\n        while(!q.empty()){\\n            int n=q.size();\\n\\n            for(i=0;i<n;i++){\\n                Node* curr=q.front();\\n                q.pop();\\n                if(i<n-1){\\n                    curr->next=q.front();\\n                } else{\\n                    curr->next=NULL;\\n                }\\n                if(curr->left){\\n                    q.push(curr->left);\\n                }\\n                if(curr->right){\\n                    q.push(curr->right);\\n                }\\n            }\\n            \\n        }\\n      return root;\\n\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* left;\\n    Node* right;\\n    Node* next;\\n\\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val, Node* _left, Node* _right, Node* _next)\\n        : val(_val), left(_left), right(_right), next(_next) {}\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        int i,j,k,c=0;\\n        int d1,d2;\\n        queue<Node*>q;\\n        vector<int>ans;\\n\\n        if(!root)\\n        return 0;\\n        q.push(root);\\n\\n        while(!q.empty()){\\n            int n=q.size();\\n\\n            for(i=0;i<n;i++){\\n                Node* curr=q.front();\\n                q.pop();\\n                if(i<n-1){\\n                    curr->next=q.front();\\n                } else{\\n                    curr->next=NULL;\\n                }\\n                if(curr->left){\\n                    q.push(curr->left);\\n                }\\n                if(curr->right){\\n                    q.push(curr->right);\\n                }\\n            }\\n            \\n        }\\n      return root;\\n\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298937,
                "title": "python-4-diffrent-solutions-bfs-dfs",
                "content": "# 1. Iterative BFS | Space:O(n)\\n```\\n    def connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if( root == None ):\\n            return root;\\n        q = deque();\\n        q.append(root);\\n        while( len(q) > 0 ):\\n            prev = None ;\\n            size = len(q);\\n            while(size > 0 ):\\n                node = q.popleft();\\n                node.next = prev;\\n                prev = node;\\n                if(node.right):q.append(node.right);\\n                if(node.left):q.append(node.left);\\n                size -= 1;\\n        return root;\\n```\\n\\n# 2.Recursive DFS | Space: O(n)\\n\\n```\\n    def connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        hmap = defaultdict(list);\\n\\n        def dfs(node,h):\\n            if( node == None ):\\n                return;\\n            else:\\n                hmap[h].append(node);\\n                dfs(node.left,h+1);\\n                dfs(node.right,h+1);\\n        \\n        dfs(root,0);\\n        for key in hmap.keys():\\n            for i in range(0, len(hmap[key])-1 ):\\n                hmap[key][i].next = hmap[key][i+1]\\n            hmap[key][-1].next = None\\n        return root\\n```\\n\\n# 3.Recusive DFS | Space:O(logn)\\n\\n```\\ndef connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if( root == None ):\\n            return;\\n        root.next = None;\\n        def dfs(node):\\n            if( node == None or node.left == None ):\\n                return;\\n            node.left.next = node.right;\\n            if(node.next):\\n                node.right.next =node.next.left;\\n            dfs(node.left);\\n            dfs(node.right);    \\n\\n        dfs(root);\\n        return root;\\n\\n```\\n\\n# 4. Iterative Optimized BFS or Level order traversal | O(1)\\n```\\n    def connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        prev = root;\\n        cur = root;\\n        while(prev):\\n            cur = prev;\\n            while( cur ):\\n                if(cur.left):\\n                    cur.left.next = cur.right;\\n                    if(cur.next):\\n                        cur.right.next = cur.next.left;\\n                cur = cur.next;\\n            prev = prev.left;\\n\\n        return root;\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n    def connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if( root == None ):\\n            return root;\\n        q = deque();\\n        q.append(root);\\n        while( len(q) > 0 ):\\n            prev = None ;\\n            size = len(q);\\n            while(size > 0 ):\\n                node = q.popleft();\\n                node.next = prev;\\n                prev = node;\\n                if(node.right):q.append(node.right);\\n                if(node.left):q.append(node.left);\\n                size -= 1;\\n        return root;\\n```\n```\\n    def connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        hmap = defaultdict(list);\\n\\n        def dfs(node,h):\\n            if( node == None ):\\n                return;\\n            else:\\n                hmap[h].append(node);\\n                dfs(node.left,h+1);\\n                dfs(node.right,h+1);\\n        \\n        dfs(root,0);\\n        for key in hmap.keys():\\n            for i in range(0, len(hmap[key])-1 ):\\n                hmap[key][i].next = hmap[key][i+1]\\n            hmap[key][-1].next = None\\n        return root\\n```\n```\\ndef connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if( root == None ):\\n            return;\\n        root.next = None;\\n        def dfs(node):\\n            if( node == None or node.left == None ):\\n                return;\\n            node.left.next = node.right;\\n            if(node.next):\\n                node.right.next =node.next.left;\\n            dfs(node.left);\\n            dfs(node.right);    \\n\\n        dfs(root);\\n        return root;\\n\\n```\n```\\n    def connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        prev = root;\\n        cur = root;\\n        while(prev):\\n            cur = prev;\\n            while( cur ):\\n                if(cur.left):\\n                    cur.left.next = cur.right;\\n                    if(cur.next):\\n                        cur.right.next = cur.next.left;\\n                cur = cur.next;\\n            prev = prev.left;\\n\\n        return root;\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3195670,
                "title": "beats-96-94-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis solution uses a level-order traversal of the binary tree and a queue to keep track of the nodes. For each level, it sets the next pointers of the nodes to the next node in the queue, except for the last node in the level. It then adds the node\\'s children to the queue if they exist, and continues with the next level. The function returns the root node of the binary tree.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if not root:\\n            return root\\n        \\n        # Start with the root node\\n        queue = [root]\\n        \\n        while queue:\\n            # Get the number of nodes in the current level\\n            size = len(queue)\\n            \\n            # Traverse through the nodes in the current level\\n            for i in range(size):\\n                # Get the first node from the queue\\n                node = queue.pop(0)\\n                \\n                # If it\\'s not the last node in the level, set its next to the next node in the queue\\n                if i < size - 1:\\n                    node.next = queue[0]\\n                \\n                # Add the node\\'s children to the queue if they exist\\n                if node.left:\\n                    queue.append(node.left)\\n                if node.right:\\n                    queue.append(node.right)\\n        \\n        # Return the root node\\n        return root\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if not root:\\n            return root\\n        \\n        # Start with the root node\\n        queue = [root]\\n        \\n        while queue:\\n            # Get the number of nodes in the current level\\n            size = len(queue)\\n            \\n            # Traverse through the nodes in the current level\\n            for i in range(size):\\n                # Get the first node from the queue\\n                node = queue.pop(0)\\n                \\n                # If it\\'s not the last node in the level, set its next to the next node in the queue\\n                if i < size - 1:\\n                    node.next = queue[0]\\n                \\n                # Add the node\\'s children to the queue if they exist\\n                if node.left:\\n                    queue.append(node.left)\\n                if node.right:\\n                    queue.append(node.right)\\n        \\n        # Return the root node\\n        return root\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2301718,
                "title": "c-both-recursive-and-iterative-solution",
                "content": "**Iterative approach - same concept as level order traversal**\\n```\\n Node* connect(Node* root) {\\n        if(!root)\\n            return NULL;\\n        queue<Node*> q;\\n        q.push(root);\\n        q.push(NULL);\\n        while(!q.empty()){\\n            Node* curr = q.front();\\n            q.pop();\\n            if(curr==NULL){\\n                if(q.size()>0)\\n                    q.push(NULL);\\n            }\\n            else{\\n                curr->next = q.front();\\n                if(curr->left)\\n                    q.push(curr->left);\\n                if(curr->right)\\n                    q.push(curr->right);\\n            }\\n        }\\n        return root;     \\n    }\\n```\\n**Recursive code**\\n```\\n    Node* connect(Node* root) {\\n        if(root==NULL)\\n            return root;\\n        if(root->left){\\n            root->left->next = root->right;\\n            if(root->next)\\n                root->right->next = root->next->left;\\n        }\\n        connect(root->left);\\n        connect(root->right);\\n        return root;     \\n    }\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Queue"
                ],
                "code": "```\\n Node* connect(Node* root) {\\n        if(!root)\\n            return NULL;\\n        queue<Node*> q;\\n        q.push(root);\\n        q.push(NULL);\\n        while(!q.empty()){\\n            Node* curr = q.front();\\n            q.pop();\\n            if(curr==NULL){\\n                if(q.size()>0)\\n                    q.push(NULL);\\n            }\\n            else{\\n                curr->next = q.front();\\n                if(curr->left)\\n                    q.push(curr->left);\\n                if(curr->right)\\n                    q.push(curr->right);\\n            }\\n        }\\n        return root;     \\n    }\\n```\n```\\n    Node* connect(Node* root) {\\n        if(root==NULL)\\n            return root;\\n        if(root->left){\\n            root->left->next = root->right;\\n            if(root->next)\\n                root->right->next = root->next->left;\\n        }\\n        connect(root->left);\\n        connect(root->right);\\n        return root;     \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1598642,
                "title": "simplest-solution-you-can-find-java-beats-100",
                "content": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        populate(root);\\n        return root;\\n    }\\n    \\n    public void populate(Node root){\\n        \\n        if(root==null)\\n            return;\\n        // fill left\\'s next\\n        if(root.left != null)\\n            root.left.next = root.right;\\n     \\n        // fill right\\'s next based on the next of current node\\n        // this will work simply cuz the root\\'s next\\n        // will always be filled before coming at this line \\n        // Or it will be null in case if the root is the most\\n        // right on it\\'s level\\n        if(root.right!=null && root.next !=null)\\n            root.right.next = root.next.left;\\n        \\n        // Do the same for left and right branches\\n        populate(root.left);\\n        populate(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        populate(root);\\n        return root;\\n    }\\n    \\n    public void populate(Node root){\\n        \\n        if(root==null)\\n            return;\\n        // fill left\\'s next\\n        if(root.left != null)\\n            root.left.next = root.right;\\n     \\n        // fill right\\'s next based on the next of current node\\n        // this will work simply cuz the root\\'s next\\n        // will always be filled before coming at this line \\n        // Or it will be null in case if the root is the most\\n        // right on it\\'s level\\n        if(root.right!=null && root.next !=null)\\n            root.right.next = root.next.left;\\n        \\n        // Do the same for left and right branches\\n        populate(root.left);\\n        populate(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1510637,
                "title": "dfs-bfs-approach-java-easy-to-understand-commented-explanation",
                "content": "Method 1: **DFS**\\n\\n\\tpublic Node connect(Node root) {\\n        dfs(root);\\n        return root;\\n    }\\n\\n    private void dfs(Node root) {\\n        // base case\\n        if (root == null) return;\\n        // if root is not a leaf node\\n        if (root.left != null) {\\n            // add reference of immediate right node in current depth level\\n            root.left.next = root.right;\\n            if (root.next != null) {\\n                root.right.next = root.next.left;\\n            }\\n        }\\n        // traverse left and right subtree\\n        dfs(root.left);\\n        dfs(root.right);\\n    }\\n\\t\\nMethod 2: **BFS**\\n\\n\\tpublic Node connect(Node root) {\\n        if (root == null) return root;\\n\\n        Queue<Node> q = new LinkedList<>();\\n        int depth = 0;  // current depth level in binary tree\\n        q.add(root);    // adding root of the binary tree\\n        while (!q.isEmpty()) {\\n            Node prev = q.poll();   // take out the left most element of current depth\\n            // adding their children into the queue\\n            if (prev.left != null && prev.right != null) {\\n                q.add(prev.left);\\n                q.add(prev.right);\\n            }\\n            // depth \"d\" has 2^d number of nodes\\n            for (int i = 1; i < (1 << depth); i++) {\\n                Node curr = q.poll();\\n                prev.next = curr;   // adding next to previous node in current depth level\\n                prev = curr;        // making current as previous\\n                // adding children into the queue\\n                if (prev.left != null && prev.right != null) {\\n                    q.add(prev.left);\\n                    q.add(prev.right);\\n                }\\n            }\\n            // going one level deep\\n            depth++;\\n        }\\n        // returning root of the binary tree\\n        return root;\\n    }\\n\\t\\nFor more solution like this visit my [github repo](https://github.com/Pandit98himanshu/SwitchJob).",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "Method 1: **DFS**\\n\\n\\tpublic Node connect(Node root) {\\n        dfs(root);\\n        return root;\\n    }\\n\\n    private void dfs(Node root) {\\n        // base case\\n        if (root == null) return;\\n        // if root is not a leaf node\\n        if (root.left != null) {\\n            // add reference of immediate right node in current depth level\\n            root.left.next = root.right;\\n            if (root.next != null) {\\n                root.right.next = root.next.left;\\n            }\\n        }\\n        // traverse left and right subtree\\n        dfs(root.left);\\n        dfs(root.right);\\n    }\\n\\t\\nMethod 2: **BFS**\\n\\n\\tpublic Node connect(Node root) {\\n        if (root == null) return root;\\n\\n        Queue<Node> q = new LinkedList<>();\\n        int depth = 0;  // current depth level in binary tree\\n        q.add(root);    // adding root of the binary tree\\n        while (!q.isEmpty()) {\\n            Node prev = q.poll();   // take out the left most element of current depth\\n            // adding their children into the queue\\n            if (prev.left != null && prev.right != null) {\\n                q.add(prev.left);\\n                q.add(prev.right);\\n            }\\n            // depth \"d\" has 2^d number of nodes\\n            for (int i = 1; i < (1 << depth); i++) {\\n                Node curr = q.poll();\\n                prev.next = curr;   // adding next to previous node in current depth level\\n                prev = curr;        // making current as previous\\n                // adding children into the queue\\n                if (prev.left != null && prev.right != null) {\\n                    q.add(prev.left);\\n                    q.add(prev.right);\\n                }\\n            }\\n            // going one level deep\\n            depth++;\\n        }\\n        // returning root of the binary tree\\n        return root;\\n    }\\n\\t\\nFor more solution like this visit my [github repo](https://github.com/Pandit98himanshu/SwitchJob).",
                "codeTag": "Unknown"
            },
            {
                "id": 1424191,
                "title": "easy-java-solution-o-1-space-100-fastest",
                "content": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n    if(root == null || root.left == null || root.right == null)\\n        return root;\\n    root.left.next = root.right;\\n        if(root.next!=null)\\n        {\\n            root.right.next = root.next.left;\\n        }\\n        connect(root.left);\\n        connect(root.right);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n    if(root == null || root.left == null || root.right == null)\\n        return root;\\n    root.left.next = root.right;\\n        if(root.next!=null)\\n        {\\n            root.right.next = root.next.left;\\n        }\\n        connect(root.left);\\n        connect(root.right);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1326340,
                "title": "c-16ms-16-7mb-easy-recursive-solution",
                "content": "Please upvote this solution to give me validation :)\\n```\\nNode* connect(Node* root) {\\n        if (root != nullptr) helper(root->left, root->right);\\n        return root;\\n    }\\n    \\n    void helper(Node*& leftNode, Node*& rightNode) {\\n        if (!leftNode) {\\n            return;\\n        }\\n        leftNode->next = rightNode;\\n        helper(leftNode->left, leftNode->right);\\n        helper(leftNode->right, rightNode->left);\\n        helper(rightNode->left, rightNode->right);\\n    }",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "Please upvote this solution to give me validation :)\\n```\\nNode* connect(Node* root) {\\n        if (root != nullptr) helper(root->left, root->right);\\n        return root;\\n    }\\n    \\n    void helper(Node*& leftNode, Node*& rightNode) {\\n        if (!leftNode) {\\n            return;\\n        }\\n        leftNode->next = rightNode;\\n        helper(leftNode->left, leftNode->right);\\n        helper(leftNode->right, rightNode->left);\\n        helper(rightNode->left, rightNode->right);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1317964,
                "title": "c-solution-easy-o-n-time-o-1-space",
                "content": "***Please Upvote the solution, if you like it.***\\n```\\nclass Solution {\\npublic:\\n    void dfs(Node* a,Node* b)\\n    {\\n        if(a==NULL&&b==NULL)\\n            return;\\n        a->next=b;\\n        b->next=NULL;\\n\\t\\t//the below function calls are just simulations, as told in the question.\\n        dfs(a->left,a->right);\\n        dfs(a->right,b->left);\\n        dfs(b->left,b->right);\\n    }\\n    Node* connect(Node* root) {\\n        if(root==NULL)\\n            return NULL;\\n        root->next=NULL;\\n        dfs(root->left,root->right);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(Node* a,Node* b)\\n    {\\n        if(a==NULL&&b==NULL)\\n            return;\\n        a->next=b;\\n        b->next=NULL;\\n\\t\\t//the below function calls are just simulations, as told in the question.\\n        dfs(a->left,a->right);\\n        dfs(a->right,b->left);\\n        dfs(b->left,b->right);\\n    }\\n    Node* connect(Node* root) {\\n        if(root==NULL)\\n            return NULL;\\n        root->next=NULL;\\n        dfs(root->left,root->right);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1234428,
                "title": "c-self-explanatory-code",
                "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root == NULL || root->left == NULL) return root;\\n        if(root->next != NULL){\\n            root->right->next=root->next->left;\\n        }\\n        root->left->next = root->right;\\n        connect(root->left);\\n        connect(root->right);\\n        return root;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root == NULL || root->left == NULL) return root;\\n        if(root->next != NULL){\\n            root->right->next=root->next->left;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1019039,
                "title": "c-two-approaches-bfs-using-queue-recursive",
                "content": "## Iterative BFS approach using Queue\\n***Level Order Traversal***\\n### T = O(n) & S = O(n) where n is total number of nodes\\n```\\n    Node* connect(Node* root) {\\n          if(!root)return root;\\n        queue<Node*> Q;\\n        Q.push(root);\\n        while(!Q.empty()){\\n            int n=Q.size();\\n            for(int i=0;i<n;i++){\\n                Node* x=Q.front();\\n                Q.pop();\\n                if(i!=n-1)x->next=q.front();\\n                if(x->left)Q.push(x->left);\\n                if(x->right)Q.push(x->right);\\n            }\\n        }\\n        return root;\\n    }\\n```\\n## Recursive approach\\n```\\t\\nprivate: \\n    void connectLeftToRight(Node* L, Node* R) {\\n        if(L == NULL) {\\n            return;\\n        }\\n        L->next = R;\\n        connectLeftToRight(L->left, L->right);\\n        connectLeftToRight(L->right, R->left);\\n        connectLeftToRight(R->left, R->right);\\n    }    \\npublic:\\n    Node* connect(Node* root) {\\n        if(!root) return root;\\n        connectLeftToRight(root->left, root->right);\\n        return root;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\n    Node* connect(Node* root) {\\n          if(!root)return root;\\n        queue<Node*> Q;\\n        Q.push(root);\\n        while(!Q.empty()){\\n            int n=Q.size();\\n            for(int i=0;i<n;i++){\\n                Node* x=Q.front();\\n                Q.pop();\\n                if(i!=n-1)x->next=q.front();\\n                if(x->left)Q.push(x->left);\\n                if(x->right)Q.push(x->right);\\n            }\\n        }\\n        return root;\\n    }\\n```\n```\\t\\nprivate: \\n    void connectLeftToRight(Node* L, Node* R) {\\n        if(L == NULL) {\\n            return;\\n        }\\n        L->next = R;\\n        connectLeftToRight(L->left, L->right);\\n        connectLeftToRight(L->right, R->left);\\n        connectLeftToRight(R->left, R->right);\\n    }    \\npublic:\\n    Node* connect(Node* root) {\\n        if(!root) return root;\\n        connectLeftToRight(root->left, root->right);\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 955215,
                "title": "iterative-go-w-comments",
                "content": "```go\\nfunc connect(root *Node) *Node {\\n\\t// guard against edge case\\n\\tif root == nil {\\n\\t\\treturn root\\n\\t}\\n\\t// initialize nxt as root\\n\\tnxt := root\\n\\n\\t// loop over every level\\n\\tfor nxt.Left != nil {\\n\\t\\t// point current at next\\n\\t\\tcur := nxt\\n\\n\\t\\t// loop over this level\\n\\t\\tfor cur != nil {\\n\\t\\t\\t// point current\\'s left at current\\'s right\\n\\t\\t\\tcur.Left.Next = cur.Right\\n\\n\\t\\t\\t// if current has a next, point current\\'s right\\n\\t\\t\\t// at the left of the current\\'s next\\n\\t\\t\\tif cur.Next != nil {\\n\\t\\t\\t\\tcur.Right.Next = cur.Next.Left\\n\\t\\t\\t}\\n\\n\\t\\t\\t// move current to the next node in its level\\n\\t\\t\\tcur = cur.Next\\n\\t\\t}\\n\\n\\t\\t// move down a level to the left\\n\\t\\tnxt = nxt.Left\\n\\t}\\n\\n\\t// return root\\n\\treturn root\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc connect(root *Node) *Node {\\n\\t// guard against edge case\\n\\tif root == nil {\\n\\t\\treturn root\\n\\t}\\n\\t// initialize nxt as root\\n\\tnxt := root\\n\\n\\t// loop over every level\\n\\tfor nxt.Left != nil {\\n\\t\\t// point current at next\\n\\t\\tcur := nxt\\n\\n\\t\\t// loop over this level\\n\\t\\tfor cur != nil {\\n\\t\\t\\t// point current\\'s left at current\\'s right\\n\\t\\t\\tcur.Left.Next = cur.Right\\n\\n\\t\\t\\t// if current has a next, point current\\'s right\\n\\t\\t\\t// at the left of the current\\'s next\\n\\t\\t\\tif cur.Next != nil {\\n\\t\\t\\t\\tcur.Right.Next = cur.Next.Left\\n\\t\\t\\t}\\n\\n\\t\\t\\t// move current to the next node in its level\\n\\t\\t\\tcur = cur.Next\\n\\t\\t}\\n\\n\\t\\t// move down a level to the left\\n\\t\\tnxt = nxt.Left\\n\\t}\\n\\n\\t// return root\\n\\treturn root\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 934256,
                "title": "java-2-approaches-bfs-recursion",
                "content": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return root;\\n        Queue<Node> queue = new LinkedList<>();\\n        queue.add(root);\\n        \\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            \\n            while(size--!=0){\\n               Node node = queue.poll();\\n\\t\\t\\t   \\n               if(size == 0){\\n                   node.next = null;\\n               }else{\\n                   node.next = queue.peek();\\n               }\\n\\t\\t\\t   \\n                if(node.left != null)\\n                queue.offer(node.left);\\n\\t\\t\\t\\t\\n                 if(node.right != null)\\n                queue.offer(node.right);\\n\\t\\t\\t\\t\\n            }\\n        }\\n        \\n        return root;\\n        \\n    }\\n}\\n```\\n\\nMore Optimal approach. Inspired by this post - https://leetcode.com/problems/populating-next-right-pointers-in-each-node/discuss/934042/JAVA-Clean-Code-O(N)-Time-Complexity-100-Faster-Solution\\n\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null || root.left == null) return root;\\n        \\n        root.left.next = root.right;\\n        \\n        if(root.next !=null)\\n        root.right.next = root.next.left;\\n        \\n        \\n        connect(root.left);\\n        connect(root.right);\\n        return root;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return root;\\n        Queue<Node> queue = new LinkedList<>();\\n        queue.add(root);\\n        \\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            \\n            while(size--!=0){\\n               Node node = queue.poll();\\n\\t\\t\\t   \\n               if(size == 0){\\n                   node.next = null;\\n               }else{\\n                   node.next = queue.peek();\\n               }\\n\\t\\t\\t   \\n                if(node.left != null)\\n                queue.offer(node.left);\\n\\t\\t\\t\\t\\n                 if(node.right != null)\\n                queue.offer(node.right);\\n\\t\\t\\t\\t\\n            }\\n        }\\n        \\n        return root;\\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null || root.left == null) return root;\\n        \\n        root.left.next = root.right;\\n        \\n        if(root.next !=null)\\n        root.right.next = root.next.left;\\n        \\n        \\n        connect(root.left);\\n        connect(root.right);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 745081,
                "title": "java-recursive-and-iterative-solutions-clear",
                "content": "- Recursive\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if (root == null) return null;\\n        if (root.left != null) root.left.next = root.right;\\n        if (root.right != null && root.next != null) root.right.next = root.next.left;\\n        connect(root.left);\\n        connect(root.right);\\n        return root;\\n    }\\n}\\n```\\n- Iterative\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        Node p = root;\\n        while (p != null) {\\n            Node cur = p;\\n            while (cur != null) {\\n                if (cur.left != null) cur.left.next = cur.right;\\n                if (cur.right != null && cur.next != null) cur.right.next = cur.next.left;\\n                cur = cur.next;\\n            }\\n            p = p.left;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if (root == null) return null;\\n        if (root.left != null) root.left.next = root.right;\\n        if (root.right != null && root.next != null) root.right.next = root.next.left;\\n        connect(root.left);\\n        connect(root.right);\\n        return root;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        Node p = root;\\n        while (p != null) {\\n            Node cur = p;\\n            while (cur != null) {\\n                if (cur.left != null) cur.left.next = cur.right;\\n                if (cur.right != null && cur.next != null) cur.right.next = cur.next.left;\\n                cur = cur.next;\\n            }\\n            p = p.left;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 678158,
                "title": "java-3-different-solutions-without-queue-recursion-using-queue",
                "content": "**Using Queue(Breadth-First Search) :**\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public Node left;\\n    public Node right;\\n \\xA0 \\xA0public Node next;\\n\\n    public Node() {}\\n    \\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, Node _left, Node _right, Node _next) {\\n        val = _val;\\n        left = _left;\\n        right = _right;\\n        next = _next;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return root;\\n        \\n        Queue<Node> queue = new LinkedList<>();\\n \\xA0 \\xA0 \\xA0 \\xA0queue.add(root); \\xA0 \\xA0 \\xA0 \\xA0\\n        while(!queue.isEmpty()){\\n            queue.add(new Node(Integer.MIN_VALUE));\\n            int size = queue.size();\\n            while(size-- > 0){\\n                Node node = queue.remove();\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if(node.val == Integer.MIN_VALUE){\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0break;\\n                }\\n                \\n                node.next = (queue.peek().val == Integer.MIN_VALUE) ? null : queue.peek();\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0  \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0\\n                if(node.left != null){\\n                    queue.add(node.left);\\n                }\\n                \\n                if(node.right != null){\\n                    queue.add(node.right);\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0} \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0\\n            }\\n        }\\n        return root;\\n    }\\n}\\n```\\n**Using Recursion(Depth-First Search) :**\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public Node left;\\n    public Node right;\\n    public Node next;\\n\\n    public Node() {}\\n    \\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, Node _left, Node _right, Node _next) {\\n        val = _val;\\n        left = _left;\\n        right = _right;\\n        next = _next;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public Node connect(Node root) {\\n \\xA0 \\xA0 \\xA0 \\xA0if(root == null) return root; \\xA0 \\xA0 \\xA0 \\xA0\\n        connectUtility(root);\\n        return root;\\n    }\\n    \\n    public void connectUtility(Node root){\\n        if(root == null) return;\\n        \\n        if(root.left != null){\\n            root.left.next = root.right;\\n            if(root.next != null){\\n                root.right.next = root.next.left;\\n            }\\n \\xA0 \\xA0 \\xA0 \\xA0} \\xA0 \\xA0 \\xA0 \\xA0\\n        connectUtility(root.left);\\n        connectUtility(root.right);\\n    }\\n}\\n```\\n**Without Queue(Breadth-First Traversal) :**\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public Node left;\\n    public Node right;\\n    public Node next;\\n\\n    public Node() {}\\n    \\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, Node _left, Node _right, Node _next) {\\n        val = _val;\\n        left = _left;\\n        right = _right;\\n        next = _next;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return root;\\n        \\n        Node levelNodes = root;\\n        while(levelNodes != null){\\n            //to traverse all the nodes of the current level\\n            Node currentNode = levelNodes;\\n            while(currentNode != null){\\n                if(currentNode.left != null){\\n                    currentNode.left.next = currentNode.right;\\n                    //connect the right_node of the left-subtree to the left_node of the right-subtree of the parent tree\\n                    if(currentNode.next != null){\\n                        currentNode.right.next = currentNode.next.left;\\n                    }\\n                }\\n                currentNode = currentNode.next;\\n            }\\n            levelNodes = levelNodes.left;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public Node left;\\n    public Node right;\\n \\xA0 \\xA0public Node next;\\n\\n    public Node() {}\\n    \\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, Node _left, Node _right, Node _next) {\\n        val = _val;\\n        left = _left;\\n        right = _right;\\n        next = _next;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return root;\\n        \\n        Queue<Node> queue = new LinkedList<>();\\n \\xA0 \\xA0 \\xA0 \\xA0queue.add(root); \\xA0 \\xA0 \\xA0 \\xA0\\n        while(!queue.isEmpty()){\\n            queue.add(new Node(Integer.MIN_VALUE));\\n            int size = queue.size();\\n            while(size-- > 0){\\n                Node node = queue.remove();\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if(node.val == Integer.MIN_VALUE){\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0break;\\n                }\\n                \\n                node.next = (queue.peek().val == Integer.MIN_VALUE) ? null : queue.peek();\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0  \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0\\n                if(node.left != null){\\n                    queue.add(node.left);\\n                }\\n                \\n                if(node.right != null){\\n                    queue.add(node.right);\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0} \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0\\n            }\\n        }\\n        return root;\\n    }\\n}\\n```\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public Node left;\\n    public Node right;\\n    public Node next;\\n\\n    public Node() {}\\n    \\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, Node _left, Node _right, Node _next) {\\n        val = _val;\\n        left = _left;\\n        right = _right;\\n        next = _next;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public Node connect(Node root) {\\n \\xA0 \\xA0 \\xA0 \\xA0if(root == null) return root; \\xA0 \\xA0 \\xA0 \\xA0\\n        connectUtility(root);\\n        return root;\\n    }\\n    \\n    public void connectUtility(Node root){\\n        if(root == null) return;\\n        \\n        if(root.left != null){\\n            root.left.next = root.right;\\n            if(root.next != null){\\n                root.right.next = root.next.left;\\n            }\\n \\xA0 \\xA0 \\xA0 \\xA0} \\xA0 \\xA0 \\xA0 \\xA0\\n        connectUtility(root.left);\\n        connectUtility(root.right);\\n    }\\n}\\n```\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public Node left;\\n    public Node right;\\n    public Node next;\\n\\n    public Node() {}\\n    \\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, Node _left, Node _right, Node _next) {\\n        val = _val;\\n        left = _left;\\n        right = _right;\\n        next = _next;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return root;\\n        \\n        Node levelNodes = root;\\n        while(levelNodes != null){\\n            //to traverse all the nodes of the current level\\n            Node currentNode = levelNodes;\\n            while(currentNode != null){\\n                if(currentNode.left != null){\\n                    currentNode.left.next = currentNode.right;\\n                    //connect the right_node of the left-subtree to the left_node of the right-subtree of the parent tree\\n                    if(currentNode.next != null){\\n                        currentNode.right.next = currentNode.next.left;\\n                    }\\n                }\\n                currentNode = currentNode.next;\\n            }\\n            levelNodes = levelNodes.left;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 439405,
                "title": "c-simple-recursive-solution",
                "content": "```\\npublic class Solution {\\n\\tprotected void Connect(Node left, Node right) {\\n\\t\\tif (left == null) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tleft.next = right;\\n\\n\\t\\tConnect(left.left, left.right);\\n\\t\\tif (right != null) {\\n\\t\\t\\tConnect(right.left, right.right);\\n\\t\\t\\tConnect(left.right, right.left);\\n\\t\\t}  \\n\\t}\\n    \\n    public Node Connect(Node root) {\\n        Connect(root, null);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\npublic class Solution {\\n\\tprotected void Connect(Node left, Node right) {\\n\\t\\tif (left == null) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tleft.next = right;\\n\\n\\t\\tConnect(left.left, left.right);\\n\\t\\tif (right != null) {\\n\\t\\t\\tConnect(right.left, right.right);\\n\\t\\t\\tConnect(left.right, right.left);\\n\\t\\t}  \\n\\t}\\n    \\n    public Node Connect(Node root) {\\n        Connect(root, null);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 232382,
                "title": "c-well-commented-solution-o-n-time-o-1-space-100-works-for-all-binary-trees",
                "content": "```\\n/* Please note that this solution works for all types of trees, whether complete or not*/\\n\\n/* Idea---- Before going to any level, make sure that all next of that level is set */\\n/* Maintain this invariant and then solve level by level */\\n\\nclass Solution\\n{\\npublic:\\n    TreeLinkNode* firstNodeJustBelow(TreeLinkNode* root);\\n    void connect(TreeLinkNode *root);\\n};\\n\\n\\n/* Returns the firstNodeJustBelow root */\\nTreeLinkNode* Solution :: firstNodeJustBelow(TreeLinkNode* root)\\n{\\n    // If root is not present, return nullptr\\n    if(!root) return root;\\n    \\n    // Keep Moving right till you find the answer\\n    while(root)\\n    {\\n        // If the left child is present, it is the answer\\n        if(root->left) return root->left;\\n        \\n        // Else if the right child is present, it is the answer\\n        else if(root->right) return root->right;\\n    \\n        // If none of them are present, move to the right of root and then go down\\n        else root = root->next;\\n    }\\n    \\n    return root;\\n}\\n\\n/* Populates the next Pointers */\\nvoid Solution :: connect(TreeLinkNode *root)\\n{\\n    // If no root, nothing to Populate\\n    if(!root) return;\\n    \\n    // Declare it outside to prevent memory wastage. It stores the node whose child is being corrected\\n    TreeLinkNode* current;\\n    \\n    while(root)\\n    {\\n        // Store the address of the first node in the level to get down to the first node in the next level\\n        current = root;\\n        \\n        // Correct all the nodes in the next level before getting down\\n        while(current)\\n        {\\n            // If the left child exits, connect it to the right child, if it exists, else connect it further\\n            if(current->left)\\n                (current->left)->next = (current->right) ? current->right : firstNodeJustBelow(current->next);\\n            \\n            // If the right child exists, connect it to the next node\\n            if(current->right)\\n                (current->right)->next = firstNodeJustBelow(current->next);\\n            \\n            // Correct the children of the next nodes in this level    \\n            current = current->next;    \\n        }\\n        \\n        // Move down to the first node in the next level\\n        root = firstNodeJustBelow(root);\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/* Please note that this solution works for all types of trees, whether complete or not*/\\n\\n/* Idea---- Before going to any level, make sure that all next of that level is set */\\n/* Maintain this invariant and then solve level by level */\\n\\nclass Solution\\n{\\npublic:\\n    TreeLinkNode* firstNodeJustBelow(TreeLinkNode* root);\\n    void connect(TreeLinkNode *root);\\n};\\n\\n\\n/* Returns the firstNodeJustBelow root */\\nTreeLinkNode* Solution :: firstNodeJustBelow(TreeLinkNode* root)\\n{\\n    // If root is not present, return nullptr\\n    if(!root) return root;\\n    \\n    // Keep Moving right till you find the answer\\n    while(root)\\n    {\\n        // If the left child is present, it is the answer\\n        if(root->left) return root->left;\\n        \\n        // Else if the right child is present, it is the answer\\n        else if(root->right) return root->right;\\n    \\n        // If none of them are present, move to the right of root and then go down\\n        else root = root->next;\\n    }\\n    \\n    return root;\\n}\\n\\n/* Populates the next Pointers */\\nvoid Solution :: connect(TreeLinkNode *root)\\n{\\n    // If no root, nothing to Populate\\n    if(!root) return;\\n    \\n    // Declare it outside to prevent memory wastage. It stores the node whose child is being corrected\\n    TreeLinkNode* current;\\n    \\n    while(root)\\n    {\\n        // Store the address of the first node in the level to get down to the first node in the next level\\n        current = root;\\n        \\n        // Correct all the nodes in the next level before getting down\\n        while(current)\\n        {\\n            // If the left child exits, connect it to the right child, if it exists, else connect it further\\n            if(current->left)\\n                (current->left)->next = (current->right) ? current->right : firstNodeJustBelow(current->next);\\n            \\n            // If the right child exists, connect it to the next node\\n            if(current->right)\\n                (current->right)->next = firstNodeJustBelow(current->next);\\n            \\n            // Correct the children of the next nodes in this level    \\n            current = current->next;    \\n        }\\n        \\n        // Move down to the first node in the next level\\n        root = firstNodeJustBelow(root);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 231526,
                "title": "c-well-commented-solution",
                "content": "```\\n/*Idea borrowed from  */\\n/* https://leetcode.com/problems/populating-next-right-pointers-in-each-node/discuss/37473/My-recursive-solution(Java) */\\n\\n/* Please note that this solution only works for complete binary trees */\\n\\nclass Solution\\n{\\npublic:\\n    void connect(TreeLinkNode *root);\\n};\\n\\n/* Connects the nodes at the same level */\\nvoid Solution :: connect(TreeLinkNode* root)\\n{\\n    // If root is empty, nothing to connect\\n    if(!root) return;\\n    \\n    /* Correct the next and right pointers of the root of the left subtree and right subtree */\\n    // This is necessary as we require this to correct the next pointer of the right child of the left subtree\\n    if(root->left)\\n        root->left->next = root->right;\\n    \\n    /* The left child corrected */\\n    \\n    // If the right child exists, move to the right of root. Now, if right neighbour of root exists,\\n    // Connect the right child of root to the left child of root->next\\n    if(root->right)\\n        root->right->next = (root->next) ? (root->next)->left : nullptr;\\n    \\n    /* The above part is very tricky and powerful at the same time */\\n    \\n    /* Recursively correct both trees */\\n    connect(root->left);\\n    connect(root->right);\\n}\\n\\n/* Further ideas */\\n/* We assume that whenever we reach a node, it\\'s next pointer is already set */\\n/* To maintain this invariant, we need to set the next pointers of left and right child before moving down */\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/*Idea borrowed from  */\\n/* https://leetcode.com/problems/populating-next-right-pointers-in-each-node/discuss/37473/My-recursive-solution(Java) */\\n\\n/* Please note that this solution only works for complete binary trees */\\n\\nclass Solution\\n{\\npublic:\\n    void connect(TreeLinkNode *root);\\n};\\n\\n/* Connects the nodes at the same level */\\nvoid Solution :: connect(TreeLinkNode* root)\\n{\\n    // If root is empty, nothing to connect\\n    if(!root) return;\\n    \\n    /* Correct the next and right pointers of the root of the left subtree and right subtree */\\n    // This is necessary as we require this to correct the next pointer of the right child of the left subtree\\n    if(root->left)\\n        root->left->next = root->right;\\n    \\n    /* The left child corrected */\\n    \\n    // If the right child exists, move to the right of root. Now, if right neighbour of root exists,\\n    // Connect the right child of root to the left child of root->next\\n    if(root->right)\\n        root->right->next = (root->next) ? (root->next)->left : nullptr;\\n    \\n    /* The above part is very tricky and powerful at the same time */\\n    \\n    /* Recursively correct both trees */\\n    connect(root->left);\\n    connect(root->right);\\n}\\n\\n/* Further ideas */\\n/* We assume that whenever we reach a node, it\\'s next pointer is already set */\\n/* To maintain this invariant, we need to set the next pointers of left and right child before moving down */\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 163181,
                "title": "easy-java-solution",
                "content": "a lot of solution is over killed here.\\nPlease realize this is full binary tree\\n```\\npublic void connect(TreeLinkNode root) {\\n        if (root == null) return;\\n        connect(root.left, root.right);\\n    }\\n    \\n    private void connect(TreeLinkNode n1, TreeLinkNode n2) {\\n        if (n1 == null) return;\\n        n1.next = n2;\\n        connect(n1.left, n1.right);\\n        connect(n1.right, n2.left);\\n        connect(n2.left, n2.right);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic void connect(TreeLinkNode root) {\\n        if (root == null) return;\\n        connect(root.left, root.right);\\n    }\\n    \\n    private void connect(TreeLinkNode n1, TreeLinkNode n2) {\\n        if (n1 == null) return;\\n        n1.next = n2;\\n        connect(n1.left, n1.right);\\n        connect(n1.right, n2.left);\\n        connect(n2.left, n2.right);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 37706,
                "title": "o-n-java-solution-very-easy-to-understand",
                "content": "    public void connect(TreeLinkNode root) {\\n        if(root == null) return;\\n        TreeLinkNode le = root.left;\\n        TreeLinkNode ri = root.right;\\n        while(le != null) {\\n            le.next = ri;\\n            le = le.right;\\n            ri = ri.left;\\n        }\\n        connect(root.left);\\n        connect(root.right);\\n    }\\n\\n\\nEvery root only takes care of connecting the rightmost nodes in its left child to the leftmost nodes in its right child. Then recurse.",
                "solutionTags": [],
                "code": "    public void connect(TreeLinkNode root) {\\n        if(root == null) return;\\n        TreeLinkNode le = root.left;\\n        TreeLinkNode ri = root.right;\\n        while(le != null) {\\n            le.next = ri;\\n            le = le.right;\\n            ri = ri.left;\\n        }\\n        connect(root.left);\\n        connect(root.right);\\n    }\\n\\n\\nEvery root only takes care of connecting the rightmost nodes in its left child to the leftmost nodes in its right child. Then recurse.",
                "codeTag": "Unknown"
            },
            {
                "id": 37518,
                "title": "java-a-5-line-iterative-space-o-1-and-a-short-iterative-bfssolution",
                "content": "    // Iterative Space O(1) Solution\\n    public void connect(TreeLinkNode root) {\\n        for(TreeLinkNode lead = root; lead != null; lead = lead.left)\\n            for(TreeLinkNode cur = lead; cur != null; cur = cur.next){\\n                if(cur.left != null) cur.left.next = cur.right;\\n                if(cur.right != null && cur.next != null) cur.right.next = cur.next.left;\\n            }\\n    }\\n\\n    // Iterative BFS Solution\\n    public void connect(TreeLinkNode root) {\\n        Queue<TreeLinkNode> queue = new LinkedList<TreeLinkNode>();\\n        if(root != null) queue.offer(root);\\n        TreeLinkNode next = null, cur = null;\\n        for(int n = 1; !queue.isEmpty(); n *= 2, next = null, cur = null)\\n            for(int i = 0; i < n; i++){\\n                cur = queue.poll();\\n                cur.next = next;\\n                next = cur;\\n                if(cur.right != null){\\n                    queue.offer(cur.right);\\n                    queue.offer(cur.left);\\n                }\\n            }\\n    }",
                "solutionTags": [],
                "code": "    // Iterative Space O(1) Solution\\n    public void connect(TreeLinkNode root) {\\n        for(TreeLinkNode lead = root; lead != null; lead = lead.left)\\n            for(TreeLinkNode cur = lead; cur != null; cur = cur.next){\\n                if(cur.left != null) cur.left.next = cur.right;\\n                if(cur.right != null && cur.next != null) cur.right.next = cur.next.left;\\n            }\\n    }\\n\\n    // Iterative BFS Solution\\n    public void connect(TreeLinkNode root) {\\n        Queue<TreeLinkNode> queue = new LinkedList<TreeLinkNode>();\\n        if(root != null) queue.offer(root);\\n        TreeLinkNode next = null, cur = null;\\n        for(int n = 1; !queue.isEmpty(); n *= 2, next = null, cur = null)\\n            for(int i = 0; i < n; i++){\\n                cur = queue.poll();\\n                cur.next = next;\\n                next = cur;\\n                if(cur.right != null){\\n                    queue.offer(cur.right);\\n                    queue.offer(cur.left);\\n                }\\n            }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 37728,
                "title": "4ms-c-solution-in-4loc",
                "content": "     void helper(struct TreeLinkNode *root,struct TreeLinkNode* r){\\n        if(!root)   return;\\n        root->next = r;\\n        helper(root->left,root->right);\\n        helper(root->right,r?r->left:NULL);\\n    }   \\n    void connect(struct TreeLinkNode *root) {\\n        helper(root,NULL);\\n    }",
                "solutionTags": [],
                "code": "     void helper(struct TreeLinkNode *root,struct TreeLinkNode* r){\\n        if(!root)   return;\\n        root->next = r;\\n        helper(root->left,root->right);\\n        helper(root->right,r?r->left:NULL);\\n    }   \\n    void connect(struct TreeLinkNode *root) {\\n        helper(root,NULL);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 37782,
                "title": "my-java-recursive-solution",
                "content": "I like recursive \\n\\n    public class Solution {\\n        public void connect(TreeLinkNode root) {\\n            if (root == null)\\n                return;\\n            connect(root.left);\\n            connect(root.right);\\n            connect(root.left, root.right);\\n        }\\n\\n        public void connect(TreeLinkNode left, TreeLinkNode right) {\\n            while (left != null) {\\n                left.next = right;\\n                left = left.right;\\n                right = right.left;\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n        public void connect(TreeLinkNode root) {\\n            if (root == null)\\n                return;\\n            connect(root.left);\\n            connect(root.right);\\n            connect(root.left, root.right);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3858980,
                "title": "easy-c-level-order-traversal-bfs",
                "content": "# Intuition \\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple level Order traverse BFS \\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* left;\\n    Node* right;\\n    Node* next;\\n\\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val, Node* _left, Node* _right, Node* _next)\\n        : val(_val), left(_left), right(_right), next(_next) {}\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root) return root;\\n        queue<Node *> nodes;\\n        nodes.push(root);\\n        Node * cur;\\n        while(!nodes.empty()){\\n            int size = nodes.size();            \\n            while(size--){\\n                cur= nodes.front();\\n                nodes.pop();\\n                if(!nodes.empty()) cur->next = nodes.front(); \\n                if(cur->left) nodes.push(cur->left);\\n                if(cur->right) nodes.push(cur->right);\\n                if(size==0) cur->next=NULL;\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* left;\\n    Node* right;\\n    Node* next;\\n\\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val, Node* _left, Node* _right, Node* _next)\\n        : val(_val), left(_left), right(_right), next(_next) {}\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root) return root;\\n        queue<Node *> nodes;\\n        nodes.push(root);\\n        Node * cur;\\n        while(!nodes.empty()){\\n            int size = nodes.size();            \\n            while(size--){\\n                cur= nodes.front();\\n                nodes.pop();\\n                if(!nodes.empty()) cur->next = nodes.front(); \\n                if(cur->left) nodes.push(cur->left);\\n                if(cur->right) nodes.push(cur->right);\\n                if(size==0) cur->next=NULL;\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424002,
                "title": "beats-100-recursion",
                "content": "\\n\\n# Approach\\n\\n![WhatsApp Image 2023-04-16 at 21.05.32.jpeg](https://assets.leetcode.com/users/images/f2599a43-e066-47aa-a828-c886d4b357f5_1681659374.0166218.jpeg)\\n\\nThe nodes will point to :-\\n\\nRoot -> null\\n\\nRoot.left -> Root.right\\n\\nRoot.right(Right subtree) -> null\\n\\nRoot.right(Left subtree) -> Root.left(Right subtree)\\n\\n# Code\\n```\\n\\n\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root==null)\\n        return root;\\n\\n    if(root!=null)\\n    {\\n        if(root.left!=null)\\n        root.left.next=root.right;\\n\\n        if(root.right!=null && root.next!=null)\\n        root.right.next=root.next.left;\\n    }\\n        connect(root.left);\\n        connect(root.right);\\n\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root==null)\\n        return root;\\n\\n    if(root!=null)\\n    {\\n        if(root.left!=null)\\n        root.left.next=root.right;\\n\\n        if(root.right!=null && root.next!=null)\\n        root.right.next=root.next.left;\\n    }\\n        connect(root.left);\\n        connect(root.right);\\n\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3401091,
                "title": "java-binary-tree-connect",
                "content": "\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public Node left;\\n    public Node right;\\n    public Node next;\\n\\n    public Node() {}\\n    \\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, Node _left, Node _right, Node _next) {\\n        val = _val;\\n        left = _left;\\n        right = _right;\\n        next = _next;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public Node connect(Node root) {\\n        Node answ = root;\\n        Node tmpLeft;\\n        while (root != null) {\\n            tmpLeft = root.left;\\n            while (root != null && root.left != null) {\\n                    root.left.next = root.right;\\n                if (root.next != null)\\n                    root.right.next = root.next.left;\\n                root = root.next;\\n            }\\n            root = tmpLeft;\\n        }\\n        return answ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public Node left;\\n    public Node right;\\n    public Node next;\\n\\n    public Node() {}\\n    \\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, Node _left, Node _right, Node _next) {\\n        val = _val;\\n        left = _left;\\n        right = _right;\\n        next = _next;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public Node connect(Node root) {\\n        Node answ = root;\\n        Node tmpLeft;\\n        while (root != null) {\\n            tmpLeft = root.left;\\n            while (root != null && root.left != null) {\\n                    root.left.next = root.right;\\n                if (root.next != null)\\n                    root.right.next = root.next.left;\\n                root = root.next;\\n            }\\n            root = tmpLeft;\\n        }\\n        return answ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2966856,
                "title": "python-simple-bfs-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- I used a BFS to explore the tree.\\n- At the step *n* of the loop, the queue will contain all the nodes of the level *n* of the tree.\\n- We can then easily connect all the nodes of the same level by iterating over the queue **at the beginning of the loop** (before running the next step of the BFS).\\n\\n\\nUpvote if it helps! \\uD83D\\uDE42 \\n\\n# Code\\n```\\nclass Solution(object):\\n    def connect(self, root):\\n        queue = [root]\\n\\n        while queue:\\n            for i in range(len(queue) - 1):\\n                queue[i].next = queue[i+1]\\n           \\n            for _ in range(len(queue)):\\n                current = queue.pop(0)\\n                if current and current.left:\\n                    queue.append(current.left)\\n                    queue.append(current.right)\\n        return root\\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def connect(self, root):\\n        queue = [root]\\n\\n        while queue:\\n            for i in range(len(queue) - 1):\\n                queue[i].next = queue[i+1]\\n           \\n            for _ in range(len(queue)):\\n                current = queue.pop(0)\\n                if current and current.left:\\n                    queue.append(current.left)\\n                    queue.append(current.right)\\n        return root\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2953919,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* left;\\n    Node* right;\\n    Node* next;\\n\\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val, Node* _left, Node* _right, Node* _next)\\n        : val(_val), left(_left), right(_right), next(_next) {}\\n};\\n*/\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n    if(root==NULL)\\n    return NULL;\\n    queue<Node*>q;\\n    q.push(root);\\n    q.push(NULL);\\n    while(q.size()>1)\\n    {\\n        int size=q.size();\\n        for(int i=0;i<size;i++)\\n        {\\n            Node* node=q.front();\\n            q.pop();\\n            if(node==NULL)\\n            {\\n                q.push(NULL);\\n                continue;\\n            }\\n            if(node->left)\\n            q.push(node->left);\\n            if(node->right)\\n            q.push(node->right);\\n\\n            node->next=q.front();\\n        }\\n    }\\n    return root;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* left;\\n    Node* right;\\n    Node* next;\\n\\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val, Node* _left, Node* _right, Node* _next)\\n        : val(_val), left(_left), right(_right), next(_next) {}\\n};\\n*/\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n    if(root==NULL)\\n    return NULL;\\n    queue<Node*>q;\\n    q.push(root);\\n    q.push(NULL);\\n    while(q.size()>1)\\n    {\\n        int size=q.size();\\n        for(int i=0;i<size;i++)\\n        {\\n            Node* node=q.front();\\n            q.pop();\\n            if(node==NULL)\\n            {\\n                q.push(NULL);\\n                continue;\\n            }\\n            if(node->left)\\n            q.push(node->left);\\n            if(node->right)\\n            q.push(node->right);\\n\\n            node->next=q.front();\\n        }\\n    }\\n    return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2795148,
                "title": "o-1-space-and-o-n-time-simple-code-in-python",
                "content": "```\\ndef dfs(root):\\n    if root:\\n        if root.left:\\n            root.left.next=root.right\\n        if root.next and root.right:\\n            root.right.next=root.next.left\\n        dfs(root.left)\\n        dfs(root.right)\\nclass Solution:\\n    def connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        dfs(root)\\n        return  root\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef dfs(root):\\n    if root:\\n        if root.left:\\n            root.left.next=root.right\\n        if root.next and root.right:\\n            root.right.next=root.next.left\\n        dfs(root.left)\\n        dfs(root.right)\\nclass Solution:\\n    def connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        dfs(root)\\n        return  root\\n",
                "codeTag": "Java"
            },
            {
                "id": 2750019,
                "title": "java-100-faster-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n     if(root == null) return null;\\n        Node left = root.left;\\n        Node right = root.right;\\n        while(left != null){\\n            left.next = right;\\n            left = left.right;\\n            right = right.left;\\n        }\\n        connect(root.left);\\n        connect(root.right);\\n        return root;   \\n    }\\n}\\n```\\n## PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n     if(root == null) return null;\\n        Node left = root.left;\\n        Node right = root.right;\\n        while(left != null){\\n            left.next = right;\\n            left = left.right;\\n            right = right.left;\\n        }\\n        connect(root.left);\\n        connect(root.right);\\n        return root;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2661106,
                "title": "c-o-n-easy-solution",
                "content": "\\nclass Solution {\\npublic:\\n\\n    Node* connect(Node* root) {\\n        \\n         if(root == NULL)\\n              return NULL;\\n \\n          if(root->left != NULL) \\n              root->left->next = root->right;\\n  \\n          if(root->right != NULL && root->next != NULL)\\n                root->right->next = root->next->left;\\n  \\n            connect(root->left);\\n            connect(root->right);\\n        \\n       return root; \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n\\n    Node* connect(Node* root) {\\n        \\n         if(root == NULL)\\n              return NULL;\\n \\n          if(root->left != NULL) \\n              root->left->next = root->right;\\n  \\n          if(root->right != NULL && root->next != NULL)\\n                root->right->next = root->next->left;\\n  \\n            connect(root->left);\\n            connect(root->right);\\n        \\n       return root; \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2424367,
                "title": "c-three-recursive-solutions-with-visual-explanation",
                "content": "**Solution 1**\\n![image](https://assets.leetcode.com/users/images/11f92bfd-f5a6-4de1-b904-6e5806ec1d38_1660477598.609047.jpeg)\\n```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if (!root) {\\n            return nullptr;\\n        }\\n        \\n        if (root->left) {\\n            root->left->next = root->right;\\n            if (root->next)\\n                root->right->next = root->next->left;\\n\\t\\t\\t\\t\\n            connect(root->left);\\n            connect(root->right);\\n        }\\n        \\n        return root;\\n    }\\n};\\n```\\n\\n**Solution 2**\\n![image](https://assets.leetcode.com/users/images/edff067d-eb96-4e06-a970-2c6f16008f75_1660477773.2009048.jpeg)\\n\\n```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if (!root) {\\n            return nullptr;\\n        }\\n        connectTwoNodes(root->left, root->right);\\n        return root;\\n    }\\nprivate:\\n    \\n    void connectTwoNodes(Node* n1, Node* n2) {\\n        if (!n1 || !n2) {\\n            return;\\n        }\\n        \\n\\t\\t// this is to avoid duplicate connection (check the graph below)\\n        if (!n1->next) {\\n            n1->next = n2;\\n        }\\n        \\n        connectTwoNodes(n1->left, n1->right);\\n        connectTwoNodes(n1->right, n2->left);\\n        connectTwoNodes(n2->left, n2->right);\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/951f8263-5bba-450e-b649-8ed5b3c7d401_1660478186.5010526.jpeg)\\n\\n**Solution 3**\\n![image](https://assets.leetcode.com/users/images/486cc146-7333-499b-9666-2d43882065a5_1660900827.6746473.jpeg)\\n```\\nNode* connect(Node* root) {\\n\\tif (!root){\\n\\t\\treturn nullptr;\\n\\t}\\n\\n\\tconnect(root->left);\\n\\tconnect(root->right);\\n\\n\\tNode *left = root->left;\\n\\tNode *right = root->right;\\n\\twhile (left != nullptr) {\\n\\t\\tleft->next = right;\\n\\t\\tleft = left->right;\\n\\t\\tright = right->left;\\n\\t}\\n\\n\\treturn root;\\n}\\n```\\n\\nPlease let me know if anything could be improved. Happy coding!",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if (!root) {\\n            return nullptr;\\n        }\\n        \\n        if (root->left) {\\n            root->left->next = root->right;\\n            if (root->next)\\n                root->right->next = root->next->left;\\n\\t\\t\\t\\t\\n            connect(root->left);\\n            connect(root->right);\\n        }\\n        \\n        return root;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if (!root) {\\n            return nullptr;\\n        }\\n        connectTwoNodes(root->left, root->right);\\n        return root;\\n    }\\nprivate:\\n    \\n    void connectTwoNodes(Node* n1, Node* n2) {\\n        if (!n1 || !n2) {\\n            return;\\n        }\\n        \\n\\t\\t// this is to avoid duplicate connection (check the graph below)\\n        if (!n1->next) {\\n            n1->next = n2;\\n        }\\n        \\n        connectTwoNodes(n1->left, n1->right);\\n        connectTwoNodes(n1->right, n2->left);\\n        connectTwoNodes(n2->left, n2->right);\\n    }\\n};\\n```\n```\\nNode* connect(Node* root) {\\n\\tif (!root){\\n\\t\\treturn nullptr;\\n\\t}\\n\\n\\tconnect(root->left);\\n\\tconnect(root->right);\\n\\n\\tNode *left = root->left;\\n\\tNode *right = root->right;\\n\\twhile (left != nullptr) {\\n\\t\\tleft->next = right;\\n\\t\\tleft = left->right;\\n\\t\\tright = right->left;\\n\\t}\\n\\n\\treturn root;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2384432,
                "title": "c-solution-o-n-comments-explained-no-extra-space",
                "content": "```\\nclass Solution {\\npublic:\\n// function for nodes to connect to the right of its node\\n    void Connect(Node* parent, Node* root, int L){\\n\\t\\t// if leaf node, we exit the loop\\n        if(root==NULL)  return;\\n\\t\\t\\n\\t\\t// to check if the node is a left child, we directly connect with right node\\n        if(L)   root->next = parent->right;\\n\\t\\t\\n\\t\\t// there can be two cases if it is right child\\n\\t\\t// 1. its parent-> next is null, then this right child has next also null\\n\\t\\t// 2. its parent-> next is not null, we can get the right node \\n\\t\\t// using the next connected to parent node\\n        else{\\n            if(parent->next==NULL)  root->next = nullptr;\\n            else    root->next = parent->next->left;\\n        }\\n\\t\\t\\n\\t\\t// then we call the same function for both the left and right child.\\n        Connect(root, root->left, 1);\\n        Connect(root, root->right, 0);\\n    }\\n    \\n    Node* connect(Node* root) {\\n\\t\\t// if root is null, return null\\n        if(root==NULL)  return NULL;\\n\\t\\t\\n\\t\\t// the first root node will always have next as null.\\n        root->next=NULL;\\n\\t\\t\\n\\t\\t// then we call our connect function to traverse all nodes and connect them.\\n        Connect(root, root->left, 1);\\n        Connect(root, root->right, 0);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n// function for nodes to connect to the right of its node\\n    void Connect(Node* parent, Node* root, int L){\\n\\t\\t// if leaf node, we exit the loop\\n        if(root==NULL)  return;\\n\\t\\t\\n\\t\\t// to check if the node is a left child, we directly connect with right node\\n        if(L)   root->next = parent->right;\\n\\t\\t\\n\\t\\t// there can be two cases if it is right child\\n\\t\\t// 1. its parent-> next is null, then this right child has next also null\\n\\t\\t// 2. its parent-> next is not null, we can get the right node \\n\\t\\t// using the next connected to parent node\\n        else{\\n            if(parent->next==NULL)  root->next = nullptr;\\n            else    root->next = parent->next->left;\\n        }\\n\\t\\t\\n\\t\\t// then we call the same function for both the left and right child.\\n        Connect(root, root->left, 1);\\n        Connect(root, root->right, 0);\\n    }\\n    \\n    Node* connect(Node* root) {\\n\\t\\t// if root is null, return null\\n        if(root==NULL)  return NULL;\\n\\t\\t\\n\\t\\t// the first root node will always have next as null.\\n        root->next=NULL;\\n\\t\\t\\n\\t\\t// then we call our connect function to traverse all nodes and connect them.\\n        Connect(root, root->left, 1);\\n        Connect(root, root->right, 0);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2359491,
                "title": "simple-recursion-o-1-space-o-n-time-c",
                "content": "class Solution {\\npublic:\\n\\n    Node* connect(Node* root) {\\n        if(root==NULL)\\n            return NULL;\\n        Node* ptr1=connect(root->left);\\n        Node* ptr2=connect(root->right);\\n        while(ptr1!=NULL)\\n        {\\n            ptr1->next=ptr2;\\n            ptr1=ptr1->right;\\n            ptr2=ptr2->left;\\n        }\\n        return root;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n\\n    Node* connect(Node* root) {\\n        if(root==NULL)\\n            return NULL;\\n        Node* ptr1=connect(root->left);\\n        Node* ptr2=connect(root->right);\\n        while(ptr1!=NULL)\\n        {\\n            ptr1->next=ptr2;\\n            ptr1=ptr1->right;\\n            ptr2=ptr2->left;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2177257,
                "title": "c-bfs-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        \\n        if( !root ) return root;\\n        queue<Node*> q;\\n        q.push(root);\\n        Node* pre = NULL;\\n        while( !q.empty() ) {\\n            int siz = q.size();\\n            while ( siz-- ) {\\n                Node* p = q.front();\\n                q.pop();\\n                if(siz>0) p->next = q.front();\\n                else p->next = NULL;\\n                if( p->left ){\\n                    q.push(p->left);\\n                }\\n                if( p->right ){\\n                    q.push( p->right );\\n                }\\n            }\\n\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Breadth-First Search",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        \\n        if( !root ) return root;\\n        queue<Node*> q;\\n        q.push(root);\\n        Node* pre = NULL;\\n        while( !q.empty() ) {\\n            int siz = q.size();\\n            while ( siz-- ) {\\n                Node* p = q.front();\\n                q.pop();\\n                if(siz>0) p->next = q.front();\\n                else p->next = NULL;\\n                if( p->left ){\\n                    q.push(p->left);\\n                }\\n                if( p->right ){\\n                    q.push( p->right );\\n                }\\n            }\\n\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2003544,
                "title": "c-recursive-approach-faster-than-97",
                "content": "```\\n\\nclass Solution {\\n    public:\\n    \\n    Node* connect(Node* root) {\\n        if(!root){\\n            return nullptr;\\n        }\\n        if(root->left){\\n            if(root->right){\\n                root->left->next=root->right;\\n            }\\n\\n        }\\n        if(root->right){\\n            if(root->next){\\n                root->right->next=root->next->left;\\n            }\\n        }\\n        connect(root->left);\\n        connect(root->right);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n\\nclass Solution {\\n    public:\\n    \\n    Node* connect(Node* root) {\\n        if(!root){\\n            return nullptr;\\n        }\\n        if(root->left){\\n            if(root->right){\\n                root->left->next=root->right;\\n            }\\n\\n        }\\n        if(root->right){\\n            if(root->next){\\n                root->right->next=root->next->left;\\n            }\\n        }\\n        connect(root->left);\\n        connect(root->right);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1718160,
                "title": "c-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    Node* connect(Node* r) {\\n        Node* root = r;\\n        while(root) {\\n            Node* tNode = root;\\n            while(tNode) {\\n                if(tNode->left) tNode->left->next = tNode->right;\\n                if(tNode->next && tNode->right) tNode->right->next = tNode->next->left;\\n                tNode = tNode->next;\\n            }\\n            root = root->left;\\n        }\\n        \\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    Node* connect(Node* r) {\\n        Node* root = r;\\n        while(root) {\\n            Node* tNode = root;\\n            while(tNode) {\\n                if(tNode->left) tNode->left->next = tNode->right;\\n                if(tNode->next && tNode->right) tNode->right->next = tNode->next->left;\\n                tNode = tNode->next;\\n            }\\n            root = root->left;\\n        }\\n        \\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1605783,
                "title": "python3-elegant-implementation",
                "content": "```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        \\n        dq = deque()\\n        dq.append(root)\\n        dq.append(None)\\n        \\n        while dq:\\n            for i in range(len(dq)):\\n                x = dq.popleft()\\n                if x is not None:\\n                    x.next = dq[0]\\n                    dq.append(x.left)\\n                    dq.append(x.right)\\n            if dq: dq.append(None)\\n            \\n        return root\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        \\n        dq = deque()\\n        dq.append(root)\\n        dq.append(None)\\n        \\n        while dq:\\n            for i in range(len(dq)):\\n                x = dq.popleft()\\n                if x is not None:\\n                    x.next = dq[0]\\n                    dq.append(x.left)\\n                    dq.append(x.right)\\n            if dq: dq.append(None)\\n            \\n        return root\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1516608,
                "title": "easy-recursive-python-solution-with-o-1-space-and-no-helper-function",
                "content": "There\\'s no official recursive solution, but it\\'s quite simple and doesn\\'t require a helper function. The main thing to keep in mind is that the recursion operates on the children *after* the parents have already been previously connected, if necessary.\\n\\n```\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if not root:\\n            return None\\n        \\n        if root.right:\\n            # the easier connection\\n            if root.left:\\n                root.left.next = root.right\\n            # the harder one between nodes of different parents\\n            # we can do this because we already did the easier connection between the \"parents\"\\n            if root.next:\\n                root.right.next = root.next.left            \\n            \\n        root.left = self.connect(root.left)\\n        root.right = self.connect(root.right)\\n        \\n        return root\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if not root:\\n            return None\\n        \\n        if root.right:\\n            # the easier connection\\n            if root.left:\\n                root.left.next = root.right\\n            # the harder one between nodes of different parents\\n            # we can do this because we already did the easier connection between the \"parents\"\\n            if root.next:\\n                root.right.next = root.next.left            \\n            \\n        root.left = self.connect(root.left)\\n        root.right = self.connect(root.right)\\n        \\n        return root\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1395379,
                "title": "simple-dfs-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void dfs(Node* root)\\n    {\\n        if(root->left==nullptr && root->right==nullptr)\\n            return;\\n        if(root->left)\\n            root->left->next=root->right;\\n        if(root->right && root->next)\\n            root->right->next=root->next->left;\\n        dfs(root->left);\\n        dfs(root->right);\\n    }\\n    \\n    Node* connect(Node* root) {\\n        if(root==nullptr)\\n            return nullptr;\\n        dfs(root);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void dfs(Node* root)\\n    {\\n        if(root->left==nullptr && root->right==nullptr)\\n            return;\\n        if(root->left)\\n            root->left->next=root->right;\\n        if(root->right && root->next)\\n            root->right->next=root->next->left;\\n        dfs(root->left);\\n        dfs(root->right);\\n    }\\n    \\n    Node* connect(Node* root) {\\n        if(root==nullptr)\\n            return nullptr;\\n        dfs(root);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1333044,
                "title": "c-bfs",
                "content": "You may find this code extremely similar to level order traversal.\\n```\\nNode* connect(Node* root) {\\n        if(!root) return root;\\n\\n        queue<Node*> q;\\n        q.push(root);\\n        \\n        while(!q.empty()){\\n            int n = q.size();\\n            \\n            for(int i=0; i<n; i++){\\n                Node* node = q.front();\\n                q.pop();\\n                if(i == n-1)\\n                    node->next = NULL;\\n                else\\n                    node->next = q.front();\\n                    \\n                if(node->left)\\n                    q.push(node->left);\\n                if(node->right)\\n                    q.push(node->right);\\n            }\\n        }\\n        return root;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nNode* connect(Node* root) {\\n        if(!root) return root;\\n\\n        queue<Node*> q;\\n        q.push(root);\\n        \\n        while(!q.empty()){\\n            int n = q.size();\\n            \\n            for(int i=0; i<n; i++){\\n                Node* node = q.front();\\n                q.pop();\\n                if(i == n-1)\\n                    node->next = NULL;\\n                else\\n                    node->next = q.front();\\n                    \\n                if(node->left)\\n                    q.push(node->left);\\n                if(node->right)\\n                    q.push(node->right);\\n            }\\n        }\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1147102,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        Node *p = root, *c;     \\n        while(p)\\n        {\\n            c = p;\\n            while(c && c -> left)\\n            {\\n                c -> left -> next = c -> right;\\n                if(c -> next)\\n                {\\n                    c -> right -> next = c -> next -> left;\\n                }\\n                c = c -> next;\\n            }\\n            p = p -> left;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        Node *p = root, *c;     \\n        while(p)\\n        {\\n            c = p;\\n            while(c && c -> left)\\n            {\\n                c -> left -> next = c -> right;\\n                if(c -> next)\\n                {\\n                    c -> right -> next = c -> next -> left;\\n                }\\n                c = c -> next;\\n            }\\n            p = p -> left;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1126811,
                "title": "java-recursive-with-comments-0ms-faster-than-100",
                "content": "Observation : The tree is **Perfect**. This means all nodes have 2 childs or no childs, across the tree. \\nWe will use this observation to make changes to **next** based on state of the node itself or both its children\\n\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        \\n\\t\\t// In case the node itself is null, or any of its children are null we return the root. Both childs are null when we reach the leaf node \\n        if(root ==null || root.left == null || root.right == null) {\\n            return root;\\n        }\\n        \\n\\t\\t// The left child will always point to the right child\\n        root.left.next = root.right;\\n        \\n\\t\\t// If the node has a right sibling on same level, then node\\'s right child should always point to the sibling\\'s left child and so on across the level\\n        if(root.next != null) {\\n            root.right.next = root.next.left;\\n        }\\n        \\n\\t\\t// We call the function recursively on both left and right children so that the same operations are performed at each level\\n        connect(root.left); \\n        connect(root.right);\\n        \\n\\t\\t// Returning the root for the modified sub-tree/tree\\n        return root;\\n    }\\n}\\n```\\n\\n*Thank you for reading my post!\\nIf you found it helpful, please upvote or comment.*",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        \\n\\t\\t// In case the node itself is null, or any of its children are null we return the root. Both childs are null when we reach the leaf node \\n        if(root ==null || root.left == null || root.right == null) {\\n            return root;\\n        }\\n        \\n\\t\\t// The left child will always point to the right child\\n        root.left.next = root.right;\\n        \\n\\t\\t// If the node has a right sibling on same level, then node\\'s right child should always point to the sibling\\'s left child and so on across the level\\n        if(root.next != null) {\\n            root.right.next = root.next.left;\\n        }\\n        \\n\\t\\t// We call the function recursively on both left and right children so that the same operations are performed at each level\\n        connect(root.left); \\n        connect(root.right);\\n        \\n\\t\\t// Returning the root for the modified sub-tree/tree\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1065116,
                "title": "java-easy-to-understand-o-n-time-and-o-1-space-solution-with-explanations",
                "content": "Algorithm:\\n1. We have to travel all cells by recursion\\n2. If the node is null then we return, that will be the base case.\\n2. Then we will check if the node have a parent or not, if it doesn\\'t have parent then we know it is root and the next will be null\\n3. Then we check if it is left or right\\n4. If it is left then the next will be the parent\\'s right\\n5. If it is right then we check if parent\\'s next is null or not if it is null then it is means it is the rightmost then it\\'s next will also be null\\n6. And if the parent\\'s next is not null then the next will be paren\\'t next left.\\n\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        util(null, root, true);\\n        return root;\\n    }\\n    \\n    public void util(Node parent, Node node, boolean isLeft) {\\n        if (node == null) return;\\n\\t\\tif (parent == null) node.next = null;\\n        else {\\n            if(isLeft)  node.next = parent.right;\\n            else  node.next = parent.next == null ? null : parent.next.left;\\n        }\\n        util(node, node.left, true);\\n        util(node, node.right, false);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        util(null, root, true);\\n        return root;\\n    }\\n    \\n    public void util(Node parent, Node node, boolean isLeft) {\\n        if (node == null) return;\\n\\t\\tif (parent == null) node.next = null;\\n        else {\\n            if(isLeft)  node.next = parent.right;\\n            else  node.next = parent.next == null ? null : parent.next.left;\\n        }\\n        util(node, node.left, true);\\n        util(node, node.right, false);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 976388,
                "title": "c-solution-o-1-space-o-n-time",
                "content": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* left;\\n    Node* right;\\n    Node* next;\\n\\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val, Node* _left, Node* _right, Node* _next)\\n        : val(_val), left(_left), right(_right), next(_next) {}\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    void populateLowerLevel(Node* root){\\n        Node* iter=root;\\n        while(iter!=NULL){\\n            iter->left->next=iter->right;\\n            if(iter->next!=NULL){\\n                iter->right->next=iter->next->left;\\n            }\\n            iter=iter->next;\\n        }\\n    }\\n    Node* connect(Node* root) {\\n       \\n        Node* curr=root;\\n        while(curr!=NULL && curr->left!=NULL){\\n            populateLowerLevel(curr);\\n            curr=curr->left;\\n        }\\n    return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* left;\\n    Node* right;\\n    Node* next;\\n\\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val, Node* _left, Node* _right, Node* _next)\\n        : val(_val), left(_left), right(_right), next(_next) {}\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    void populateLowerLevel(Node* root){\\n        Node* iter=root;\\n        while(iter!=NULL){\\n            iter->left->next=iter->right;\\n            if(iter->next!=NULL){\\n                iter->right->next=iter->next->left;\\n            }\\n            iter=iter->next;\\n        }\\n    }\\n    Node* connect(Node* root) {\\n       \\n        Node* curr=root;\\n        while(curr!=NULL && curr->left!=NULL){\\n            populateLowerLevel(curr);\\n            curr=curr->left;\\n        }\\n    return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 934830,
                "title": "go-golang-clean-solutions",
                "content": ">Runtime: 4 ms, faster than 94.42% of Go online submissions for Populating Next Right Pointers in Each Node.\\nMemory Usage: 6.2 MB, less than 8.12% of Go online submissions for Populating Next Right Pointers in Each Node.\\n\\n```go\\nfunc connect(root *Node) *Node {\\n    if root == nil { return root }\\n    queue := []*Node{ root }\\n    for len(queue) != 0 {\\n        pop := queue[0]\\n        queue = queue[1:]\\n        if pop.Left != nil && pop.Right != nil {\\n            pop.Left.Next = pop.Right\\n            if pop.Next != nil {\\n                pop.Right.Next = pop.Next.Left\\n            }\\n            queue = append(queue, pop.Left)\\n            queue = append(queue, pop.Right)\\n        }\\n    }\\n    return root\\n}\\n```\\n\\n>Runtime: 4 ms, faster than 94.42% of Go online submissions for Populating Next Right Pointers in Each Node.\\nMemory Usage: 6.1 MB, less than 25.38% of Go online submissions for Populating Next Right Pointers in Each Node.\\n\\n```go\\nfunc connect(root *Node) *Node {\\n    if root == nil { return root }\\n    var pre, cur *Node\\n    pre = root\\n    for pre.Left != nil {\\n        cur = pre\\n        for cur != nil {\\n            cur.Left.Next = cur.Right\\n            if cur.Next != nil { cur.Right.Next = cur.Next.Left }\\n            cur = cur.Next\\n        }\\n        pre = pre.Left\\n    }\\n    return root\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc connect(root *Node) *Node {\\n    if root == nil { return root }\\n    queue := []*Node{ root }\\n    for len(queue) != 0 {\\n        pop := queue[0]\\n        queue = queue[1:]\\n        if pop.Left != nil && pop.Right != nil {\\n            pop.Left.Next = pop.Right\\n            if pop.Next != nil {\\n                pop.Right.Next = pop.Next.Left\\n            }\\n            queue = append(queue, pop.Left)\\n            queue = append(queue, pop.Right)\\n        }\\n    }\\n    return root\\n}\\n```\n```go\\nfunc connect(root *Node) *Node {\\n    if root == nil { return root }\\n    var pre, cur *Node\\n    pre = root\\n    for pre.Left != nil {\\n        cur = pre\\n        for cur != nil {\\n            cur.Left.Next = cur.Right\\n            if cur.Next != nil { cur.Right.Next = cur.Next.Left }\\n            cur = cur.Next\\n        }\\n        pre = pre.Left\\n    }\\n    return root\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 934260,
                "title": "java-shortest-clean-solution-o-n-time-and-o-1-space-beats-100-easy-to-understand",
                "content": "The code is self explaining.\\n\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        \\n        if (root != null && root.left != null) {\\n            \\n            root.left.next = root.right;\\n            \\n            if(root.next != null) {\\n                root.right.next = root.next.left;\\n            }\\n            \\n            connect(root.left);\\n            connect(root.right);\\n        }\\n        \\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        \\n        if (root != null && root.left != null) {\\n            \\n            root.left.next = root.right;\\n            \\n            if(root.next != null) {\\n                root.right.next = root.next.left;\\n            }\\n            \\n            connect(root.left);\\n            connect(root.right);\\n        }\\n        \\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 934232,
                "title": "from-zero-to-hero-three-approaches-python-3",
                "content": "Hi there! I would like to share my thoughts and solutions to that great problem. As I pointed in the title I will present you with three solutions that take ```O(n)``` time, but different amount of space.\\n\\n\\n**Breadth-first search: O(n) time/space**\\nFrom the beginning I had two thoughts:\\n1. I have to traverse the tree and I am quite happy to know how to do that\\n2. I have to connect all the nodes on the same level\\n\\nAnd after those thoughts, I immediately come up with the idea to use a Deque data structure to collect all the nodes. So the first solution is quite straightforward:\\n```\\nclass Solution:\\n    def connect(self, root: Node) -> Union[Node, None]:\\n        if root is None:\\n            return root\\n\\n        q = deque([root])\\n        while q:\\n            size = len(q)\\n            for i in range(size):\\n                node = q.popleft()\\n\\n                if i + 1 < size:\\n                    node.next = q[0]\\n\\n                if node.left is not None:\\n                    q.append(node.left)\\n                    q.append(node.right)\\n\\n        return root\\n```\\n\\n\\n**Recursion: O(n) time, O(log (n)) space**\\nThe second step was to try to solve the problem by using recursion. One thing I mentioned is that without checking if there is an already existing link between two nodes the algorithm repeats the work he already did before. So pay attention to that!\\n```\\nclass Solution:\\n    def connect(self, root: Node) -> Union[Node, None]:\\n        def traverse(left: Node, right: Node):\\n            if left is None or left.next is right:\\n                return\\n\\n            left.next = right\\n            traverse(left.left, left.right)\\n            traverse(left.right, right.left)\\n            traverse(right.left, right.right)\\n\\n        if root is not None:\\n            traverse(root.left, root.right)\\n\\n        return root\\n```\\n\\n\\n**With Linked List in mind: O(n) time, O(1) space**\\nAnd here is the last one! I should admit this is remarkably elegant and clean code. The way I came up with this algorithm is by observing that actually in the first solution I have used unnecessary space to collect the nodes. But the thing is that when we come to a certain level all the nodes on this level are already connected with the ```next``` link. That gives us the possibility to iterate through the level as if it were a Linked List.\\n```\\nclass Solution:\\n    def connect(self, root: Node) -> Union[Node, None]:\\n        if root is None:\\n            return root\\n\\n        head = tail = root\\n        while tail.left is not None:\\n            tail.left.next = tail.right\\n            if tail.next is not None:\\n                tail.right.next = tail.next.left\\n                tail = tail.next\\n            else:\\n                head = tail = head.left\\n\\n        return root\\n```\\n\\n*\\uD83D\\uDCE2 If you think these solutions are good enough to be recommended to other LeetCoders then upvote.*",
                "solutionTags": [
                    "Python3",
                    "Recursion",
                    "Queue"
                ],
                "code": "```O(n)```\n```\\nclass Solution:\\n    def connect(self, root: Node) -> Union[Node, None]:\\n        if root is None:\\n            return root\\n\\n        q = deque([root])\\n        while q:\\n            size = len(q)\\n            for i in range(size):\\n                node = q.popleft()\\n\\n                if i + 1 < size:\\n                    node.next = q[0]\\n\\n                if node.left is not None:\\n                    q.append(node.left)\\n                    q.append(node.right)\\n\\n        return root\\n```\n```\\nclass Solution:\\n    def connect(self, root: Node) -> Union[Node, None]:\\n        def traverse(left: Node, right: Node):\\n            if left is None or left.next is right:\\n                return\\n\\n            left.next = right\\n            traverse(left.left, left.right)\\n            traverse(left.right, right.left)\\n            traverse(right.left, right.right)\\n\\n        if root is not None:\\n            traverse(root.left, root.right)\\n\\n        return root\\n```\n```next```\n```\\nclass Solution:\\n    def connect(self, root: Node) -> Union[Node, None]:\\n        if root is None:\\n            return root\\n\\n        head = tail = root\\n        while tail.left is not None:\\n            tail.left.next = tail.right\\n            if tail.next is not None:\\n                tail.right.next = tail.next.left\\n                tail = tail.next\\n            else:\\n                head = tail = head.left\\n\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 934097,
                "title": "c-easy-solution-recursive",
                "content": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if (!root || !root->left)\\n            return root;\\n        \\n        connect(root->left);\\n        connect(root->right);\\n        \\n        Node* right_ptr = root->right;\\n        Node* left_ptr = root->left;\\n        left_ptr->next = right_ptr;\\n        \\n        while (left_ptr->right) {\\n            left_ptr = left_ptr->right;\\n            right_ptr = right_ptr->left;\\n            left_ptr->next = right_ptr;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if (!root || !root->left)\\n            return root;\\n        \\n        connect(root->left);\\n        connect(root->right);\\n        \\n        Node* right_ptr = root->right;\\n        Node* left_ptr = root->left;\\n        left_ptr->next = right_ptr;\\n        \\n        while (left_ptr->right) {\\n            left_ptr = left_ptr->right;\\n            right_ptr = right_ptr->left;\\n            left_ptr->next = right_ptr;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 923575,
                "title": "easy-cpp-8-line-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if (root == NULL)\\n            return root;\\n        connectLR(root->left,root->right);\\n        return root;\\n    }\\n    void connectLR(Node* l, Node* r) {\\n        if (l == NULL)\\n            return;\\n        l->next = r;\\n        connectLR(l->left,l->right);\\n        connectLR(l->right,r->left);\\n        connectLR(r->left,r->right);\\n    }\\n};\\n```\\n\\nExplanation:\\n![image](https://assets.leetcode.com/users/images/58c720ed-0429-42e0-8590-04d9022b0caa_1604770737.4726672.png)\\n\\n\\nFor each node:\\n1. Connect left child of its left child with right child of its left child (green)\\n2. Connect right child of its left child with left child of its right child (blue)\\n3. Connect left child of its right child with right child of its right child (red)\\n4. Connect left child to the right child (black)\\n\\nMain trick is that we iterate over two subtrees at the same time (left and right). This trivializes whole problem into four cases mentioned above. \\nFor base case we check if left node is null, since we can\\'t link null node. Due to the fact that trees are guaranteed to be perfectly balanced, we might as well check if right node is null. It doesn\\'t matter.\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if (root == NULL)\\n            return root;\\n        connectLR(root->left,root->right);\\n        return root;\\n    }\\n    void connectLR(Node* l, Node* r) {\\n        if (l == NULL)\\n            return;\\n        l->next = r;\\n        connectLR(l->left,l->right);\\n        connectLR(l->right,r->left);\\n        connectLR(r->left,r->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 821882,
                "title": "a-small-recursive-solution-c",
                "content": "A really efficient recursive approach:\\n \\n ```\\n Node* connect(Node* root) {\\n        if(root == NULL)\\n            return NULL;\\n        if(root->left != NULL)\\n            root->left->next = root->right;\\n        if(root->right != NULL && root->next != NULL)\\n            root->right->next = root->next->left;\\n        connect(root->left);\\n        connect(root->right);\\n        return root;\\n    }\\n",
                "solutionTags": [],
                "code": "A really efficient recursive approach:\\n \\n ```\\n Node* connect(Node* root) {\\n        if(root == NULL)\\n            return NULL;\\n        if(root->left != NULL)\\n            root->left->next = root->right;\\n        if(root->right != NULL && root->next != NULL)\\n            root->right->next = root->next->left;\\n        connect(root->left);\\n        connect(root->right);\\n        return root;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 710100,
                "title": "c-bfs-solution-easy",
                "content": "Just playing around with the pointers.Here is the code\\n```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root==nullptr) return NULL;\\n        queue<Node *> q;\\n        q.push(root);\\n        \\n        while(!q.empty()){\\n            int size=q.size();\\n            while(size-->0){\\n                Node *front=q.front();\\n                q.pop();\\n                \\n                if(front->left!=nullptr){\\n                        front->left->next=front->right;\\n                    \\n                    q.push(front->left);\\n                }\\n                if(front->right!=nullptr){\\n                    if(front->next!=NULL){\\n                        front->right->next=front->next->left;\\n                    }\\n                    \\n                    q.push(front->right);\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root==nullptr) return NULL;\\n        queue<Node *> q;\\n        q.push(root);\\n        \\n        while(!q.empty()){\\n            int size=q.size();\\n            while(size-->0){\\n                Node *front=q.front();\\n                q.pop();\\n                \\n                if(front->left!=nullptr){\\n                        front->left->next=front->right;\\n                    \\n                    q.push(front->left);\\n                }\\n                if(front->right!=nullptr){\\n                    if(front->next!=NULL){\\n                        front->right->next=front->next->left;\\n                    }\\n                    \\n                    q.push(front->right);\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 507105,
                "title": "python-bfs-image-attached",
                "content": "#### 116 | Populating Next Right Pointers in Each Node\\n\\n#### BFS Solution\\n\\n```python\\nclass Solution(object):\\n    def connect(self, root):\\n        if not root:\\n            return \\n        queue = collections.deque([root])\\n        while queue:\\n            curr = queue.popleft()\\n            if curr.left and curr.right:\\n                curr.left.next = curr.right\\n                if curr.next:\\n                    curr.right.next = curr.next.left\\n                queue.append(curr.left)\\n                queue.append(curr.right)\\n```\\n\\n![image](https://user-images.githubusercontent.com/6414741/74363006-88872e00-4d7e-11ea-8091-ab49e4a3efc3.png)\\n\\n----\\n\\n![image](https://user-images.githubusercontent.com/6414741/74363019-8f15a580-4d7e-11ea-87d4-a4181f22de05.png)\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def connect(self, root):\\n        if not root:\\n            return \\n        queue = collections.deque([root])\\n        while queue:\\n            curr = queue.popleft()\\n            if curr.left and curr.right:\\n                curr.left.next = curr.right\\n                if curr.next:\\n                    curr.right.next = curr.next.left\\n                queue.append(curr.left)\\n                queue.append(curr.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 433945,
                "title": "easy-java-solution-runtime-0ms-beat-100",
                "content": "For each node, it has two subtree, left subtree and right subtree. At every level, connect the rightmost node of left subtree to the leftmost node of right subtree. \\nAnd do this loop for each node.\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return null;\\n        Node left = root.left;\\n        Node right = root.right;\\n        while(left != null) {\\n            left.next = right;\\n            left = left.right;\\n            right = right.left;\\n        }\\n        connect(root.left);\\n        connect(root.right);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return null;\\n        Node left = root.left;\\n        Node right = root.right;\\n        while(left != null) {\\n            left.next = right;\\n            left = left.right;\\n            right = right.left;\\n        }\\n        connect(root.left);\\n        connect(root.right);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 405732,
                "title": "java-simple-recursive-solution-beat-100",
                "content": "You just need to iterate the tree from right to left.\\n\\t1. If current node is not leaf node then\\n\\t\\t- set root.left.next = root.right\\n\\t\\t- if root.next is not null, we will set root.right.next = root.next.left\\n\\n```\\nclass Solution {\\n\\tpublic void connectRec(Node root) {\\n\\t\\tif (root == null || root.left == null || root.right == null) return;\\n\\t\\troot.left.next = root.right;\\n\\t\\tif (root.next != null) root.right.next = root.next.left;\\n\\t\\tconnectRec(root.right);\\n\\t\\tcoonectRec(root.left);\\n\\t}\\n\\t\\n\\tpublic Node connect(Node root) {\\n\\t\\tconnectRec(root);\\n\\t\\treturn root;\\n\\t}\\n}\\n```\\nTime Complexity O(N) \\nSpace Complexity O(1)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\tpublic void connectRec(Node root) {\\n\\t\\tif (root == null || root.left == null || root.right == null) return;\\n\\t\\troot.left.next = root.right;\\n\\t\\tif (root.next != null) root.right.next = root.next.left;\\n\\t\\tconnectRec(root.right);\\n\\t\\tcoonectRec(root.left);\\n\\t}\\n\\t\\n\\tpublic Node connect(Node root) {\\n\\t\\tconnectRec(root);\\n\\t\\treturn root;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 346354,
                "title": "my-easy-to-understand-recursive-solution-cpp-beat-97",
                "content": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root) return root;\\n        if(root->left) {\\n            root->left->next = root->right;\\n            if(root->next) root->right->next = root->next->left;\\n            connect(root->left);\\n            connect(root->right);\\n        }\\n        return root;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root) return root;\\n        if(root->left) {\\n            root->left->next = root->right;\\n            if(root->next) root->right->next = root->next->left;\\n            connect(root->left);\\n            connect(root->right);\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 339375,
                "title": "simple-java-recursive-solution-beats-100",
                "content": "/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public Node left;\\n    public Node right;\\n    public Node next;\\n\\n    public Node() {}\\n\\n    public Node(int _val,Node _left,Node _right,Node _next) {\\n        val = _val;\\n        left = _left;\\n        right = _right;\\n        next = _next;\\n    }\\n};\\n*/\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) {\\n            return root;\\n        }\\n        root.next = null;\\n        helper(root.left, root.right);\\n        return root;\\n    }\\n    \\n    public void helper(Node root1, Node root2) {\\n        if (root1 == null && root2==null) {\\n            return;\\n        }\\n        root1.next = root2;\\n        helper(root1.left, root1.right);\\n        helper(root1.right, root2.left);\\n        helper(root2.left, root2.right);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) {\\n            return root;\\n        }\\n        root.next = null;\\n        helper(root.left, root.right);\\n        return root;\\n    }\\n    \\n    public void helper(Node root1, Node root2) {\\n        if (root1 == null && root2==null) {\\n            return;\\n        }\\n        root1.next = root2;\\n        helper(root1.left, root1.right);\\n        helper(root1.right, root2.left);\\n        helper(root2.left, root2.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564620,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1565418,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1568485,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1565480,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1569347,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1572089,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1772435,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1763411,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1569568,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1569567,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1564620,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1565418,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1568485,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1565480,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1569347,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1572089,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1772435,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1763411,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1569568,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1569567,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1766045,
                "content": [
                    {
                        "username": "aashima19",
                        "content": "can someone please help and tell me what is wrong with my solution?\\nIt is giving me NULL ptr error.\\nThank you :))\\n\\n_________________________________________________________________________\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n     queue<Node*>q;\\n     q.push(root);\\n     while(!q.empty())\\n     {\\n         int size=q.size();\\n       \\n         for(int i=0;i<size;i++)\\n         {   auto node=q.front();\\n             if(i==size-1)\\n         { // cout<<i<<size-1;\\n                if(node->left!=NULL) \\n                {q.push(node->left); }\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n         }\\n         else  \\n           {           \\n                if(node->left!=NULL) q.push(node->left);\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n                Node* node2=q.front();\\n               node->next=node2;\\n              // cout<<node->val;  \\n           }\\n         }\\n     }   \\n     return root;\\n    }\\n};\\n\\n_______________________________________________________________________"
                    },
                    {
                        "username": "uday06",
                        "content": "just add this condition it will work fine\\n\\nif(root==NULL)\\nreturn root;"
                    },
                    {
                        "username": "AdityaPawar1510",
                        "content": "I'm writing pythin solution,\nIn that facing strange issue where queue getting added with extra None in last iteration.\n\n `     \n    \n\n        nodeQueue = [root]\n        height=2\n        ctr=1\n        while nodeQueue:\n            node = nodeQueue.pop(0)\n            if not node:\n                break\n            if node.left:\n                nodeQueue.append(node.left)\n            if node.right:\n                nodeQueue.append(node.right)\n            if ctr==height:\n                height*=2\n                ctr=1\n            else:\n                if nodeQueue:\n                    nodeQueue[0].next=nodeQueue[1]\n                ctr+=1\n        return root\n`\n\nIn above code if below piece is removed it shows error, but we already check None before inserting, I validated by printing queue at each steps, there also i last iterattion it shows None automatically.\n\n`\n\n            if not node:\n                break\n\n`\n "
                    },
                    {
                        "username": "roshan_agr",
                        "content": "somehow connect method is getting called twice, second time with root as None\\ni added this condition in the beginning of connect method to pass all the test cases\\n        if root is None:\\n            return root"
                    },
                    {
                        "username": "Aditya-Sood",
                        "content": "for Go (v1.17.6 as runtime at the time of writing) with BFS using a \\'queue\\' slice (I know, not constant space), I noticed that the runtime was adding a nil element to my \\'queue\\' slice after processing the last element - thereby causing an infinite loop since the size automatically became > 1\\n\\nI\\'ve been through my code multiple times and even printed the state variables to verify the same\\n\\nif anyone else faces the same issue do let me know, I\\'m curious as to why this is happening\\n"
                    },
                    {
                        "username": "nessieyang",
                        "content": "I met the same issue, it already took me half an hour to figure out the reason but I am still wondering why"
                    },
                    {
                        "username": "itaiyz97",
                        "content": "The official solution suggests using O(N) space complexity, but doesn\\'t it say we can only use O(1) space complexity?"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "I just solved 117 and I found that 116 is also the same ? Why did they post two question which are same? Or did I miss anything ?"
                    },
                    {
                        "username": "ihost",
                        "content": "Don\\u2019t understand, why the default output is [number,#,number,#,number,#\\u2026]. I don\\u2019t know what the default output mean??\\nLet\\u2019s say the test case: [1,2,3,4,5,7,9]\\nThe output is : [1,#,2,#,4,#]\\nDo i have to understand what is going on here to start coding or not? Any suggestion have be grateful!"
                    },
                    {
                        "username": "ihost",
                        "content": "I think i might understood now, it need to point left node to right node at the same level?"
                    },
                    {
                        "username": "Zefick",
                        "content": "Does pre-allocated array of 6000 elements counted as \"constant extra space\"?\\nIn fact as the tree is perfect in this problem, I only need the array of log2(6000) elements, which is just 13."
                    },
                    {
                        "username": "nitissssh",
                        "content": "whys is it medium ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "cjbot1998",
                        "content": "tried to rack my brain to use DFS because saw this problem under DFS. Realized this would be much easier with BFS and saved the effort. smh"
                    },
                    {
                        "username": "namankandol",
                        "content": "Why am I not able to traverse by level order. My code somehow gives TLE. Can someone explain."
                    }
                ]
            },
            {
                "id": 1729331,
                "content": [
                    {
                        "username": "aashima19",
                        "content": "can someone please help and tell me what is wrong with my solution?\\nIt is giving me NULL ptr error.\\nThank you :))\\n\\n_________________________________________________________________________\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n     queue<Node*>q;\\n     q.push(root);\\n     while(!q.empty())\\n     {\\n         int size=q.size();\\n       \\n         for(int i=0;i<size;i++)\\n         {   auto node=q.front();\\n             if(i==size-1)\\n         { // cout<<i<<size-1;\\n                if(node->left!=NULL) \\n                {q.push(node->left); }\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n         }\\n         else  \\n           {           \\n                if(node->left!=NULL) q.push(node->left);\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n                Node* node2=q.front();\\n               node->next=node2;\\n              // cout<<node->val;  \\n           }\\n         }\\n     }   \\n     return root;\\n    }\\n};\\n\\n_______________________________________________________________________"
                    },
                    {
                        "username": "uday06",
                        "content": "just add this condition it will work fine\\n\\nif(root==NULL)\\nreturn root;"
                    },
                    {
                        "username": "AdityaPawar1510",
                        "content": "I'm writing pythin solution,\nIn that facing strange issue where queue getting added with extra None in last iteration.\n\n `     \n    \n\n        nodeQueue = [root]\n        height=2\n        ctr=1\n        while nodeQueue:\n            node = nodeQueue.pop(0)\n            if not node:\n                break\n            if node.left:\n                nodeQueue.append(node.left)\n            if node.right:\n                nodeQueue.append(node.right)\n            if ctr==height:\n                height*=2\n                ctr=1\n            else:\n                if nodeQueue:\n                    nodeQueue[0].next=nodeQueue[1]\n                ctr+=1\n        return root\n`\n\nIn above code if below piece is removed it shows error, but we already check None before inserting, I validated by printing queue at each steps, there also i last iterattion it shows None automatically.\n\n`\n\n            if not node:\n                break\n\n`\n "
                    },
                    {
                        "username": "roshan_agr",
                        "content": "somehow connect method is getting called twice, second time with root as None\\ni added this condition in the beginning of connect method to pass all the test cases\\n        if root is None:\\n            return root"
                    },
                    {
                        "username": "Aditya-Sood",
                        "content": "for Go (v1.17.6 as runtime at the time of writing) with BFS using a \\'queue\\' slice (I know, not constant space), I noticed that the runtime was adding a nil element to my \\'queue\\' slice after processing the last element - thereby causing an infinite loop since the size automatically became > 1\\n\\nI\\'ve been through my code multiple times and even printed the state variables to verify the same\\n\\nif anyone else faces the same issue do let me know, I\\'m curious as to why this is happening\\n"
                    },
                    {
                        "username": "nessieyang",
                        "content": "I met the same issue, it already took me half an hour to figure out the reason but I am still wondering why"
                    },
                    {
                        "username": "itaiyz97",
                        "content": "The official solution suggests using O(N) space complexity, but doesn\\'t it say we can only use O(1) space complexity?"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "I just solved 117 and I found that 116 is also the same ? Why did they post two question which are same? Or did I miss anything ?"
                    },
                    {
                        "username": "ihost",
                        "content": "Don\\u2019t understand, why the default output is [number,#,number,#,number,#\\u2026]. I don\\u2019t know what the default output mean??\\nLet\\u2019s say the test case: [1,2,3,4,5,7,9]\\nThe output is : [1,#,2,#,4,#]\\nDo i have to understand what is going on here to start coding or not? Any suggestion have be grateful!"
                    },
                    {
                        "username": "ihost",
                        "content": "I think i might understood now, it need to point left node to right node at the same level?"
                    },
                    {
                        "username": "Zefick",
                        "content": "Does pre-allocated array of 6000 elements counted as \"constant extra space\"?\\nIn fact as the tree is perfect in this problem, I only need the array of log2(6000) elements, which is just 13."
                    },
                    {
                        "username": "nitissssh",
                        "content": "whys is it medium ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "cjbot1998",
                        "content": "tried to rack my brain to use DFS because saw this problem under DFS. Realized this would be much easier with BFS and saved the effort. smh"
                    },
                    {
                        "username": "namankandol",
                        "content": "Why am I not able to traverse by level order. My code somehow gives TLE. Can someone explain."
                    }
                ]
            },
            {
                "id": 1673798,
                "content": [
                    {
                        "username": "aashima19",
                        "content": "can someone please help and tell me what is wrong with my solution?\\nIt is giving me NULL ptr error.\\nThank you :))\\n\\n_________________________________________________________________________\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n     queue<Node*>q;\\n     q.push(root);\\n     while(!q.empty())\\n     {\\n         int size=q.size();\\n       \\n         for(int i=0;i<size;i++)\\n         {   auto node=q.front();\\n             if(i==size-1)\\n         { // cout<<i<<size-1;\\n                if(node->left!=NULL) \\n                {q.push(node->left); }\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n         }\\n         else  \\n           {           \\n                if(node->left!=NULL) q.push(node->left);\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n                Node* node2=q.front();\\n               node->next=node2;\\n              // cout<<node->val;  \\n           }\\n         }\\n     }   \\n     return root;\\n    }\\n};\\n\\n_______________________________________________________________________"
                    },
                    {
                        "username": "uday06",
                        "content": "just add this condition it will work fine\\n\\nif(root==NULL)\\nreturn root;"
                    },
                    {
                        "username": "AdityaPawar1510",
                        "content": "I'm writing pythin solution,\nIn that facing strange issue where queue getting added with extra None in last iteration.\n\n `     \n    \n\n        nodeQueue = [root]\n        height=2\n        ctr=1\n        while nodeQueue:\n            node = nodeQueue.pop(0)\n            if not node:\n                break\n            if node.left:\n                nodeQueue.append(node.left)\n            if node.right:\n                nodeQueue.append(node.right)\n            if ctr==height:\n                height*=2\n                ctr=1\n            else:\n                if nodeQueue:\n                    nodeQueue[0].next=nodeQueue[1]\n                ctr+=1\n        return root\n`\n\nIn above code if below piece is removed it shows error, but we already check None before inserting, I validated by printing queue at each steps, there also i last iterattion it shows None automatically.\n\n`\n\n            if not node:\n                break\n\n`\n "
                    },
                    {
                        "username": "roshan_agr",
                        "content": "somehow connect method is getting called twice, second time with root as None\\ni added this condition in the beginning of connect method to pass all the test cases\\n        if root is None:\\n            return root"
                    },
                    {
                        "username": "Aditya-Sood",
                        "content": "for Go (v1.17.6 as runtime at the time of writing) with BFS using a \\'queue\\' slice (I know, not constant space), I noticed that the runtime was adding a nil element to my \\'queue\\' slice after processing the last element - thereby causing an infinite loop since the size automatically became > 1\\n\\nI\\'ve been through my code multiple times and even printed the state variables to verify the same\\n\\nif anyone else faces the same issue do let me know, I\\'m curious as to why this is happening\\n"
                    },
                    {
                        "username": "nessieyang",
                        "content": "I met the same issue, it already took me half an hour to figure out the reason but I am still wondering why"
                    },
                    {
                        "username": "itaiyz97",
                        "content": "The official solution suggests using O(N) space complexity, but doesn\\'t it say we can only use O(1) space complexity?"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "I just solved 117 and I found that 116 is also the same ? Why did they post two question which are same? Or did I miss anything ?"
                    },
                    {
                        "username": "ihost",
                        "content": "Don\\u2019t understand, why the default output is [number,#,number,#,number,#\\u2026]. I don\\u2019t know what the default output mean??\\nLet\\u2019s say the test case: [1,2,3,4,5,7,9]\\nThe output is : [1,#,2,#,4,#]\\nDo i have to understand what is going on here to start coding or not? Any suggestion have be grateful!"
                    },
                    {
                        "username": "ihost",
                        "content": "I think i might understood now, it need to point left node to right node at the same level?"
                    },
                    {
                        "username": "Zefick",
                        "content": "Does pre-allocated array of 6000 elements counted as \"constant extra space\"?\\nIn fact as the tree is perfect in this problem, I only need the array of log2(6000) elements, which is just 13."
                    },
                    {
                        "username": "nitissssh",
                        "content": "whys is it medium ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "cjbot1998",
                        "content": "tried to rack my brain to use DFS because saw this problem under DFS. Realized this would be much easier with BFS and saved the effort. smh"
                    },
                    {
                        "username": "namankandol",
                        "content": "Why am I not able to traverse by level order. My code somehow gives TLE. Can someone explain."
                    }
                ]
            },
            {
                "id": 1574581,
                "content": [
                    {
                        "username": "aashima19",
                        "content": "can someone please help and tell me what is wrong with my solution?\\nIt is giving me NULL ptr error.\\nThank you :))\\n\\n_________________________________________________________________________\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n     queue<Node*>q;\\n     q.push(root);\\n     while(!q.empty())\\n     {\\n         int size=q.size();\\n       \\n         for(int i=0;i<size;i++)\\n         {   auto node=q.front();\\n             if(i==size-1)\\n         { // cout<<i<<size-1;\\n                if(node->left!=NULL) \\n                {q.push(node->left); }\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n         }\\n         else  \\n           {           \\n                if(node->left!=NULL) q.push(node->left);\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n                Node* node2=q.front();\\n               node->next=node2;\\n              // cout<<node->val;  \\n           }\\n         }\\n     }   \\n     return root;\\n    }\\n};\\n\\n_______________________________________________________________________"
                    },
                    {
                        "username": "uday06",
                        "content": "just add this condition it will work fine\\n\\nif(root==NULL)\\nreturn root;"
                    },
                    {
                        "username": "AdityaPawar1510",
                        "content": "I'm writing pythin solution,\nIn that facing strange issue where queue getting added with extra None in last iteration.\n\n `     \n    \n\n        nodeQueue = [root]\n        height=2\n        ctr=1\n        while nodeQueue:\n            node = nodeQueue.pop(0)\n            if not node:\n                break\n            if node.left:\n                nodeQueue.append(node.left)\n            if node.right:\n                nodeQueue.append(node.right)\n            if ctr==height:\n                height*=2\n                ctr=1\n            else:\n                if nodeQueue:\n                    nodeQueue[0].next=nodeQueue[1]\n                ctr+=1\n        return root\n`\n\nIn above code if below piece is removed it shows error, but we already check None before inserting, I validated by printing queue at each steps, there also i last iterattion it shows None automatically.\n\n`\n\n            if not node:\n                break\n\n`\n "
                    },
                    {
                        "username": "roshan_agr",
                        "content": "somehow connect method is getting called twice, second time with root as None\\ni added this condition in the beginning of connect method to pass all the test cases\\n        if root is None:\\n            return root"
                    },
                    {
                        "username": "Aditya-Sood",
                        "content": "for Go (v1.17.6 as runtime at the time of writing) with BFS using a \\'queue\\' slice (I know, not constant space), I noticed that the runtime was adding a nil element to my \\'queue\\' slice after processing the last element - thereby causing an infinite loop since the size automatically became > 1\\n\\nI\\'ve been through my code multiple times and even printed the state variables to verify the same\\n\\nif anyone else faces the same issue do let me know, I\\'m curious as to why this is happening\\n"
                    },
                    {
                        "username": "nessieyang",
                        "content": "I met the same issue, it already took me half an hour to figure out the reason but I am still wondering why"
                    },
                    {
                        "username": "itaiyz97",
                        "content": "The official solution suggests using O(N) space complexity, but doesn\\'t it say we can only use O(1) space complexity?"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "I just solved 117 and I found that 116 is also the same ? Why did they post two question which are same? Or did I miss anything ?"
                    },
                    {
                        "username": "ihost",
                        "content": "Don\\u2019t understand, why the default output is [number,#,number,#,number,#\\u2026]. I don\\u2019t know what the default output mean??\\nLet\\u2019s say the test case: [1,2,3,4,5,7,9]\\nThe output is : [1,#,2,#,4,#]\\nDo i have to understand what is going on here to start coding or not? Any suggestion have be grateful!"
                    },
                    {
                        "username": "ihost",
                        "content": "I think i might understood now, it need to point left node to right node at the same level?"
                    },
                    {
                        "username": "Zefick",
                        "content": "Does pre-allocated array of 6000 elements counted as \"constant extra space\"?\\nIn fact as the tree is perfect in this problem, I only need the array of log2(6000) elements, which is just 13."
                    },
                    {
                        "username": "nitissssh",
                        "content": "whys is it medium ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "cjbot1998",
                        "content": "tried to rack my brain to use DFS because saw this problem under DFS. Realized this would be much easier with BFS and saved the effort. smh"
                    },
                    {
                        "username": "namankandol",
                        "content": "Why am I not able to traverse by level order. My code somehow gives TLE. Can someone explain."
                    }
                ]
            },
            {
                "id": 1572733,
                "content": [
                    {
                        "username": "aashima19",
                        "content": "can someone please help and tell me what is wrong with my solution?\\nIt is giving me NULL ptr error.\\nThank you :))\\n\\n_________________________________________________________________________\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n     queue<Node*>q;\\n     q.push(root);\\n     while(!q.empty())\\n     {\\n         int size=q.size();\\n       \\n         for(int i=0;i<size;i++)\\n         {   auto node=q.front();\\n             if(i==size-1)\\n         { // cout<<i<<size-1;\\n                if(node->left!=NULL) \\n                {q.push(node->left); }\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n         }\\n         else  \\n           {           \\n                if(node->left!=NULL) q.push(node->left);\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n                Node* node2=q.front();\\n               node->next=node2;\\n              // cout<<node->val;  \\n           }\\n         }\\n     }   \\n     return root;\\n    }\\n};\\n\\n_______________________________________________________________________"
                    },
                    {
                        "username": "uday06",
                        "content": "just add this condition it will work fine\\n\\nif(root==NULL)\\nreturn root;"
                    },
                    {
                        "username": "AdityaPawar1510",
                        "content": "I'm writing pythin solution,\nIn that facing strange issue where queue getting added with extra None in last iteration.\n\n `     \n    \n\n        nodeQueue = [root]\n        height=2\n        ctr=1\n        while nodeQueue:\n            node = nodeQueue.pop(0)\n            if not node:\n                break\n            if node.left:\n                nodeQueue.append(node.left)\n            if node.right:\n                nodeQueue.append(node.right)\n            if ctr==height:\n                height*=2\n                ctr=1\n            else:\n                if nodeQueue:\n                    nodeQueue[0].next=nodeQueue[1]\n                ctr+=1\n        return root\n`\n\nIn above code if below piece is removed it shows error, but we already check None before inserting, I validated by printing queue at each steps, there also i last iterattion it shows None automatically.\n\n`\n\n            if not node:\n                break\n\n`\n "
                    },
                    {
                        "username": "roshan_agr",
                        "content": "somehow connect method is getting called twice, second time with root as None\\ni added this condition in the beginning of connect method to pass all the test cases\\n        if root is None:\\n            return root"
                    },
                    {
                        "username": "Aditya-Sood",
                        "content": "for Go (v1.17.6 as runtime at the time of writing) with BFS using a \\'queue\\' slice (I know, not constant space), I noticed that the runtime was adding a nil element to my \\'queue\\' slice after processing the last element - thereby causing an infinite loop since the size automatically became > 1\\n\\nI\\'ve been through my code multiple times and even printed the state variables to verify the same\\n\\nif anyone else faces the same issue do let me know, I\\'m curious as to why this is happening\\n"
                    },
                    {
                        "username": "nessieyang",
                        "content": "I met the same issue, it already took me half an hour to figure out the reason but I am still wondering why"
                    },
                    {
                        "username": "itaiyz97",
                        "content": "The official solution suggests using O(N) space complexity, but doesn\\'t it say we can only use O(1) space complexity?"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "I just solved 117 and I found that 116 is also the same ? Why did they post two question which are same? Or did I miss anything ?"
                    },
                    {
                        "username": "ihost",
                        "content": "Don\\u2019t understand, why the default output is [number,#,number,#,number,#\\u2026]. I don\\u2019t know what the default output mean??\\nLet\\u2019s say the test case: [1,2,3,4,5,7,9]\\nThe output is : [1,#,2,#,4,#]\\nDo i have to understand what is going on here to start coding or not? Any suggestion have be grateful!"
                    },
                    {
                        "username": "ihost",
                        "content": "I think i might understood now, it need to point left node to right node at the same level?"
                    },
                    {
                        "username": "Zefick",
                        "content": "Does pre-allocated array of 6000 elements counted as \"constant extra space\"?\\nIn fact as the tree is perfect in this problem, I only need the array of log2(6000) elements, which is just 13."
                    },
                    {
                        "username": "nitissssh",
                        "content": "whys is it medium ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "cjbot1998",
                        "content": "tried to rack my brain to use DFS because saw this problem under DFS. Realized this would be much easier with BFS and saved the effort. smh"
                    },
                    {
                        "username": "namankandol",
                        "content": "Why am I not able to traverse by level order. My code somehow gives TLE. Can someone explain."
                    }
                ]
            },
            {
                "id": 2062298,
                "content": [
                    {
                        "username": "aashima19",
                        "content": "can someone please help and tell me what is wrong with my solution?\\nIt is giving me NULL ptr error.\\nThank you :))\\n\\n_________________________________________________________________________\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n     queue<Node*>q;\\n     q.push(root);\\n     while(!q.empty())\\n     {\\n         int size=q.size();\\n       \\n         for(int i=0;i<size;i++)\\n         {   auto node=q.front();\\n             if(i==size-1)\\n         { // cout<<i<<size-1;\\n                if(node->left!=NULL) \\n                {q.push(node->left); }\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n         }\\n         else  \\n           {           \\n                if(node->left!=NULL) q.push(node->left);\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n                Node* node2=q.front();\\n               node->next=node2;\\n              // cout<<node->val;  \\n           }\\n         }\\n     }   \\n     return root;\\n    }\\n};\\n\\n_______________________________________________________________________"
                    },
                    {
                        "username": "uday06",
                        "content": "just add this condition it will work fine\\n\\nif(root==NULL)\\nreturn root;"
                    },
                    {
                        "username": "AdityaPawar1510",
                        "content": "I'm writing pythin solution,\nIn that facing strange issue where queue getting added with extra None in last iteration.\n\n `     \n    \n\n        nodeQueue = [root]\n        height=2\n        ctr=1\n        while nodeQueue:\n            node = nodeQueue.pop(0)\n            if not node:\n                break\n            if node.left:\n                nodeQueue.append(node.left)\n            if node.right:\n                nodeQueue.append(node.right)\n            if ctr==height:\n                height*=2\n                ctr=1\n            else:\n                if nodeQueue:\n                    nodeQueue[0].next=nodeQueue[1]\n                ctr+=1\n        return root\n`\n\nIn above code if below piece is removed it shows error, but we already check None before inserting, I validated by printing queue at each steps, there also i last iterattion it shows None automatically.\n\n`\n\n            if not node:\n                break\n\n`\n "
                    },
                    {
                        "username": "roshan_agr",
                        "content": "somehow connect method is getting called twice, second time with root as None\\ni added this condition in the beginning of connect method to pass all the test cases\\n        if root is None:\\n            return root"
                    },
                    {
                        "username": "Aditya-Sood",
                        "content": "for Go (v1.17.6 as runtime at the time of writing) with BFS using a \\'queue\\' slice (I know, not constant space), I noticed that the runtime was adding a nil element to my \\'queue\\' slice after processing the last element - thereby causing an infinite loop since the size automatically became > 1\\n\\nI\\'ve been through my code multiple times and even printed the state variables to verify the same\\n\\nif anyone else faces the same issue do let me know, I\\'m curious as to why this is happening\\n"
                    },
                    {
                        "username": "nessieyang",
                        "content": "I met the same issue, it already took me half an hour to figure out the reason but I am still wondering why"
                    },
                    {
                        "username": "itaiyz97",
                        "content": "The official solution suggests using O(N) space complexity, but doesn\\'t it say we can only use O(1) space complexity?"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "I just solved 117 and I found that 116 is also the same ? Why did they post two question which are same? Or did I miss anything ?"
                    },
                    {
                        "username": "ihost",
                        "content": "Don\\u2019t understand, why the default output is [number,#,number,#,number,#\\u2026]. I don\\u2019t know what the default output mean??\\nLet\\u2019s say the test case: [1,2,3,4,5,7,9]\\nThe output is : [1,#,2,#,4,#]\\nDo i have to understand what is going on here to start coding or not? Any suggestion have be grateful!"
                    },
                    {
                        "username": "ihost",
                        "content": "I think i might understood now, it need to point left node to right node at the same level?"
                    },
                    {
                        "username": "Zefick",
                        "content": "Does pre-allocated array of 6000 elements counted as \"constant extra space\"?\\nIn fact as the tree is perfect in this problem, I only need the array of log2(6000) elements, which is just 13."
                    },
                    {
                        "username": "nitissssh",
                        "content": "whys is it medium ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "cjbot1998",
                        "content": "tried to rack my brain to use DFS because saw this problem under DFS. Realized this would be much easier with BFS and saved the effort. smh"
                    },
                    {
                        "username": "namankandol",
                        "content": "Why am I not able to traverse by level order. My code somehow gives TLE. Can someone explain."
                    }
                ]
            },
            {
                "id": 2045129,
                "content": [
                    {
                        "username": "aashima19",
                        "content": "can someone please help and tell me what is wrong with my solution?\\nIt is giving me NULL ptr error.\\nThank you :))\\n\\n_________________________________________________________________________\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n     queue<Node*>q;\\n     q.push(root);\\n     while(!q.empty())\\n     {\\n         int size=q.size();\\n       \\n         for(int i=0;i<size;i++)\\n         {   auto node=q.front();\\n             if(i==size-1)\\n         { // cout<<i<<size-1;\\n                if(node->left!=NULL) \\n                {q.push(node->left); }\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n         }\\n         else  \\n           {           \\n                if(node->left!=NULL) q.push(node->left);\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n                Node* node2=q.front();\\n               node->next=node2;\\n              // cout<<node->val;  \\n           }\\n         }\\n     }   \\n     return root;\\n    }\\n};\\n\\n_______________________________________________________________________"
                    },
                    {
                        "username": "uday06",
                        "content": "just add this condition it will work fine\\n\\nif(root==NULL)\\nreturn root;"
                    },
                    {
                        "username": "AdityaPawar1510",
                        "content": "I'm writing pythin solution,\nIn that facing strange issue where queue getting added with extra None in last iteration.\n\n `     \n    \n\n        nodeQueue = [root]\n        height=2\n        ctr=1\n        while nodeQueue:\n            node = nodeQueue.pop(0)\n            if not node:\n                break\n            if node.left:\n                nodeQueue.append(node.left)\n            if node.right:\n                nodeQueue.append(node.right)\n            if ctr==height:\n                height*=2\n                ctr=1\n            else:\n                if nodeQueue:\n                    nodeQueue[0].next=nodeQueue[1]\n                ctr+=1\n        return root\n`\n\nIn above code if below piece is removed it shows error, but we already check None before inserting, I validated by printing queue at each steps, there also i last iterattion it shows None automatically.\n\n`\n\n            if not node:\n                break\n\n`\n "
                    },
                    {
                        "username": "roshan_agr",
                        "content": "somehow connect method is getting called twice, second time with root as None\\ni added this condition in the beginning of connect method to pass all the test cases\\n        if root is None:\\n            return root"
                    },
                    {
                        "username": "Aditya-Sood",
                        "content": "for Go (v1.17.6 as runtime at the time of writing) with BFS using a \\'queue\\' slice (I know, not constant space), I noticed that the runtime was adding a nil element to my \\'queue\\' slice after processing the last element - thereby causing an infinite loop since the size automatically became > 1\\n\\nI\\'ve been through my code multiple times and even printed the state variables to verify the same\\n\\nif anyone else faces the same issue do let me know, I\\'m curious as to why this is happening\\n"
                    },
                    {
                        "username": "nessieyang",
                        "content": "I met the same issue, it already took me half an hour to figure out the reason but I am still wondering why"
                    },
                    {
                        "username": "itaiyz97",
                        "content": "The official solution suggests using O(N) space complexity, but doesn\\'t it say we can only use O(1) space complexity?"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "I just solved 117 and I found that 116 is also the same ? Why did they post two question which are same? Or did I miss anything ?"
                    },
                    {
                        "username": "ihost",
                        "content": "Don\\u2019t understand, why the default output is [number,#,number,#,number,#\\u2026]. I don\\u2019t know what the default output mean??\\nLet\\u2019s say the test case: [1,2,3,4,5,7,9]\\nThe output is : [1,#,2,#,4,#]\\nDo i have to understand what is going on here to start coding or not? Any suggestion have be grateful!"
                    },
                    {
                        "username": "ihost",
                        "content": "I think i might understood now, it need to point left node to right node at the same level?"
                    },
                    {
                        "username": "Zefick",
                        "content": "Does pre-allocated array of 6000 elements counted as \"constant extra space\"?\\nIn fact as the tree is perfect in this problem, I only need the array of log2(6000) elements, which is just 13."
                    },
                    {
                        "username": "nitissssh",
                        "content": "whys is it medium ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "cjbot1998",
                        "content": "tried to rack my brain to use DFS because saw this problem under DFS. Realized this would be much easier with BFS and saved the effort. smh"
                    },
                    {
                        "username": "namankandol",
                        "content": "Why am I not able to traverse by level order. My code somehow gives TLE. Can someone explain."
                    }
                ]
            },
            {
                "id": 2002558,
                "content": [
                    {
                        "username": "aashima19",
                        "content": "can someone please help and tell me what is wrong with my solution?\\nIt is giving me NULL ptr error.\\nThank you :))\\n\\n_________________________________________________________________________\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n     queue<Node*>q;\\n     q.push(root);\\n     while(!q.empty())\\n     {\\n         int size=q.size();\\n       \\n         for(int i=0;i<size;i++)\\n         {   auto node=q.front();\\n             if(i==size-1)\\n         { // cout<<i<<size-1;\\n                if(node->left!=NULL) \\n                {q.push(node->left); }\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n         }\\n         else  \\n           {           \\n                if(node->left!=NULL) q.push(node->left);\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n                Node* node2=q.front();\\n               node->next=node2;\\n              // cout<<node->val;  \\n           }\\n         }\\n     }   \\n     return root;\\n    }\\n};\\n\\n_______________________________________________________________________"
                    },
                    {
                        "username": "uday06",
                        "content": "just add this condition it will work fine\\n\\nif(root==NULL)\\nreturn root;"
                    },
                    {
                        "username": "AdityaPawar1510",
                        "content": "I'm writing pythin solution,\nIn that facing strange issue where queue getting added with extra None in last iteration.\n\n `     \n    \n\n        nodeQueue = [root]\n        height=2\n        ctr=1\n        while nodeQueue:\n            node = nodeQueue.pop(0)\n            if not node:\n                break\n            if node.left:\n                nodeQueue.append(node.left)\n            if node.right:\n                nodeQueue.append(node.right)\n            if ctr==height:\n                height*=2\n                ctr=1\n            else:\n                if nodeQueue:\n                    nodeQueue[0].next=nodeQueue[1]\n                ctr+=1\n        return root\n`\n\nIn above code if below piece is removed it shows error, but we already check None before inserting, I validated by printing queue at each steps, there also i last iterattion it shows None automatically.\n\n`\n\n            if not node:\n                break\n\n`\n "
                    },
                    {
                        "username": "roshan_agr",
                        "content": "somehow connect method is getting called twice, second time with root as None\\ni added this condition in the beginning of connect method to pass all the test cases\\n        if root is None:\\n            return root"
                    },
                    {
                        "username": "Aditya-Sood",
                        "content": "for Go (v1.17.6 as runtime at the time of writing) with BFS using a \\'queue\\' slice (I know, not constant space), I noticed that the runtime was adding a nil element to my \\'queue\\' slice after processing the last element - thereby causing an infinite loop since the size automatically became > 1\\n\\nI\\'ve been through my code multiple times and even printed the state variables to verify the same\\n\\nif anyone else faces the same issue do let me know, I\\'m curious as to why this is happening\\n"
                    },
                    {
                        "username": "nessieyang",
                        "content": "I met the same issue, it already took me half an hour to figure out the reason but I am still wondering why"
                    },
                    {
                        "username": "itaiyz97",
                        "content": "The official solution suggests using O(N) space complexity, but doesn\\'t it say we can only use O(1) space complexity?"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "I just solved 117 and I found that 116 is also the same ? Why did they post two question which are same? Or did I miss anything ?"
                    },
                    {
                        "username": "ihost",
                        "content": "Don\\u2019t understand, why the default output is [number,#,number,#,number,#\\u2026]. I don\\u2019t know what the default output mean??\\nLet\\u2019s say the test case: [1,2,3,4,5,7,9]\\nThe output is : [1,#,2,#,4,#]\\nDo i have to understand what is going on here to start coding or not? Any suggestion have be grateful!"
                    },
                    {
                        "username": "ihost",
                        "content": "I think i might understood now, it need to point left node to right node at the same level?"
                    },
                    {
                        "username": "Zefick",
                        "content": "Does pre-allocated array of 6000 elements counted as \"constant extra space\"?\\nIn fact as the tree is perfect in this problem, I only need the array of log2(6000) elements, which is just 13."
                    },
                    {
                        "username": "nitissssh",
                        "content": "whys is it medium ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "cjbot1998",
                        "content": "tried to rack my brain to use DFS because saw this problem under DFS. Realized this would be much easier with BFS and saved the effort. smh"
                    },
                    {
                        "username": "namankandol",
                        "content": "Why am I not able to traverse by level order. My code somehow gives TLE. Can someone explain."
                    }
                ]
            },
            {
                "id": 1995070,
                "content": [
                    {
                        "username": "aashima19",
                        "content": "can someone please help and tell me what is wrong with my solution?\\nIt is giving me NULL ptr error.\\nThank you :))\\n\\n_________________________________________________________________________\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n     queue<Node*>q;\\n     q.push(root);\\n     while(!q.empty())\\n     {\\n         int size=q.size();\\n       \\n         for(int i=0;i<size;i++)\\n         {   auto node=q.front();\\n             if(i==size-1)\\n         { // cout<<i<<size-1;\\n                if(node->left!=NULL) \\n                {q.push(node->left); }\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n         }\\n         else  \\n           {           \\n                if(node->left!=NULL) q.push(node->left);\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n                Node* node2=q.front();\\n               node->next=node2;\\n              // cout<<node->val;  \\n           }\\n         }\\n     }   \\n     return root;\\n    }\\n};\\n\\n_______________________________________________________________________"
                    },
                    {
                        "username": "uday06",
                        "content": "just add this condition it will work fine\\n\\nif(root==NULL)\\nreturn root;"
                    },
                    {
                        "username": "AdityaPawar1510",
                        "content": "I'm writing pythin solution,\nIn that facing strange issue where queue getting added with extra None in last iteration.\n\n `     \n    \n\n        nodeQueue = [root]\n        height=2\n        ctr=1\n        while nodeQueue:\n            node = nodeQueue.pop(0)\n            if not node:\n                break\n            if node.left:\n                nodeQueue.append(node.left)\n            if node.right:\n                nodeQueue.append(node.right)\n            if ctr==height:\n                height*=2\n                ctr=1\n            else:\n                if nodeQueue:\n                    nodeQueue[0].next=nodeQueue[1]\n                ctr+=1\n        return root\n`\n\nIn above code if below piece is removed it shows error, but we already check None before inserting, I validated by printing queue at each steps, there also i last iterattion it shows None automatically.\n\n`\n\n            if not node:\n                break\n\n`\n "
                    },
                    {
                        "username": "roshan_agr",
                        "content": "somehow connect method is getting called twice, second time with root as None\\ni added this condition in the beginning of connect method to pass all the test cases\\n        if root is None:\\n            return root"
                    },
                    {
                        "username": "Aditya-Sood",
                        "content": "for Go (v1.17.6 as runtime at the time of writing) with BFS using a \\'queue\\' slice (I know, not constant space), I noticed that the runtime was adding a nil element to my \\'queue\\' slice after processing the last element - thereby causing an infinite loop since the size automatically became > 1\\n\\nI\\'ve been through my code multiple times and even printed the state variables to verify the same\\n\\nif anyone else faces the same issue do let me know, I\\'m curious as to why this is happening\\n"
                    },
                    {
                        "username": "nessieyang",
                        "content": "I met the same issue, it already took me half an hour to figure out the reason but I am still wondering why"
                    },
                    {
                        "username": "itaiyz97",
                        "content": "The official solution suggests using O(N) space complexity, but doesn\\'t it say we can only use O(1) space complexity?"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "I just solved 117 and I found that 116 is also the same ? Why did they post two question which are same? Or did I miss anything ?"
                    },
                    {
                        "username": "ihost",
                        "content": "Don\\u2019t understand, why the default output is [number,#,number,#,number,#\\u2026]. I don\\u2019t know what the default output mean??\\nLet\\u2019s say the test case: [1,2,3,4,5,7,9]\\nThe output is : [1,#,2,#,4,#]\\nDo i have to understand what is going on here to start coding or not? Any suggestion have be grateful!"
                    },
                    {
                        "username": "ihost",
                        "content": "I think i might understood now, it need to point left node to right node at the same level?"
                    },
                    {
                        "username": "Zefick",
                        "content": "Does pre-allocated array of 6000 elements counted as \"constant extra space\"?\\nIn fact as the tree is perfect in this problem, I only need the array of log2(6000) elements, which is just 13."
                    },
                    {
                        "username": "nitissssh",
                        "content": "whys is it medium ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "cjbot1998",
                        "content": "tried to rack my brain to use DFS because saw this problem under DFS. Realized this would be much easier with BFS and saved the effort. smh"
                    },
                    {
                        "username": "namankandol",
                        "content": "Why am I not able to traverse by level order. My code somehow gives TLE. Can someone explain."
                    }
                ]
            },
            {
                "id": 1953589,
                "content": [
                    {
                        "username": "aashima19",
                        "content": "can someone please help and tell me what is wrong with my solution?\\nIt is giving me NULL ptr error.\\nThank you :))\\n\\n_________________________________________________________________________\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n     queue<Node*>q;\\n     q.push(root);\\n     while(!q.empty())\\n     {\\n         int size=q.size();\\n       \\n         for(int i=0;i<size;i++)\\n         {   auto node=q.front();\\n             if(i==size-1)\\n         { // cout<<i<<size-1;\\n                if(node->left!=NULL) \\n                {q.push(node->left); }\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n         }\\n         else  \\n           {           \\n                if(node->left!=NULL) q.push(node->left);\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n                Node* node2=q.front();\\n               node->next=node2;\\n              // cout<<node->val;  \\n           }\\n         }\\n     }   \\n     return root;\\n    }\\n};\\n\\n_______________________________________________________________________"
                    },
                    {
                        "username": "uday06",
                        "content": "just add this condition it will work fine\\n\\nif(root==NULL)\\nreturn root;"
                    },
                    {
                        "username": "AdityaPawar1510",
                        "content": "I'm writing pythin solution,\nIn that facing strange issue where queue getting added with extra None in last iteration.\n\n `     \n    \n\n        nodeQueue = [root]\n        height=2\n        ctr=1\n        while nodeQueue:\n            node = nodeQueue.pop(0)\n            if not node:\n                break\n            if node.left:\n                nodeQueue.append(node.left)\n            if node.right:\n                nodeQueue.append(node.right)\n            if ctr==height:\n                height*=2\n                ctr=1\n            else:\n                if nodeQueue:\n                    nodeQueue[0].next=nodeQueue[1]\n                ctr+=1\n        return root\n`\n\nIn above code if below piece is removed it shows error, but we already check None before inserting, I validated by printing queue at each steps, there also i last iterattion it shows None automatically.\n\n`\n\n            if not node:\n                break\n\n`\n "
                    },
                    {
                        "username": "roshan_agr",
                        "content": "somehow connect method is getting called twice, second time with root as None\\ni added this condition in the beginning of connect method to pass all the test cases\\n        if root is None:\\n            return root"
                    },
                    {
                        "username": "Aditya-Sood",
                        "content": "for Go (v1.17.6 as runtime at the time of writing) with BFS using a \\'queue\\' slice (I know, not constant space), I noticed that the runtime was adding a nil element to my \\'queue\\' slice after processing the last element - thereby causing an infinite loop since the size automatically became > 1\\n\\nI\\'ve been through my code multiple times and even printed the state variables to verify the same\\n\\nif anyone else faces the same issue do let me know, I\\'m curious as to why this is happening\\n"
                    },
                    {
                        "username": "nessieyang",
                        "content": "I met the same issue, it already took me half an hour to figure out the reason but I am still wondering why"
                    },
                    {
                        "username": "itaiyz97",
                        "content": "The official solution suggests using O(N) space complexity, but doesn\\'t it say we can only use O(1) space complexity?"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "I just solved 117 and I found that 116 is also the same ? Why did they post two question which are same? Or did I miss anything ?"
                    },
                    {
                        "username": "ihost",
                        "content": "Don\\u2019t understand, why the default output is [number,#,number,#,number,#\\u2026]. I don\\u2019t know what the default output mean??\\nLet\\u2019s say the test case: [1,2,3,4,5,7,9]\\nThe output is : [1,#,2,#,4,#]\\nDo i have to understand what is going on here to start coding or not? Any suggestion have be grateful!"
                    },
                    {
                        "username": "ihost",
                        "content": "I think i might understood now, it need to point left node to right node at the same level?"
                    },
                    {
                        "username": "Zefick",
                        "content": "Does pre-allocated array of 6000 elements counted as \"constant extra space\"?\\nIn fact as the tree is perfect in this problem, I only need the array of log2(6000) elements, which is just 13."
                    },
                    {
                        "username": "nitissssh",
                        "content": "whys is it medium ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "cjbot1998",
                        "content": "tried to rack my brain to use DFS because saw this problem under DFS. Realized this would be much easier with BFS and saved the effort. smh"
                    },
                    {
                        "username": "namankandol",
                        "content": "Why am I not able to traverse by level order. My code somehow gives TLE. Can someone explain."
                    }
                ]
            },
            {
                "id": 1950680,
                "content": [
                    {
                        "username": "21Cash",
                        "content": "You gotta be kidding me if u expect me to give you the O(1) memory solution without having seen the problem before"
                    },
                    {
                        "username": "rajat_171",
                        "content": "IT\\'s this just BFS ?? with saperator."
                    },
                    {
                        "username": "21Cash",
                        "content": "O(1) memory, how about that?? Still easy??\\n"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n         queue<Node*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size=q.size();\\n            if(size==0){\\n                return root;\\n            }\\n           \\n            while(size>0){\\n                 Node* temp;\\n                 if(size>1){\\n                     temp=q.front();\\n                     q.pop();\\n                     Node * newadd=q.front();\\n\\n                     temp->next=newadd;\\n                 }else{\\n                     temp=q.front();\\n                     q.pop();\\n                 }\\n                 if(temp->left != nullptr){  //----ERROR LINE-------\\n                     q.push(temp->left);\\n                 }\\n                 \\n                 if(temp->right!=nullptr){\\n                     q.push(temp->right);\\n                 }\\n                 size--;\\n                   \\n            }\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\n//   I am unable to understand error in inserting the temp left node if it is not null\\n"
                    },
                    {
                        "username": "ayush_ag",
                        "content": "Why is there a return type in the method. There\\'s nothing mentioned in the question on what needs to be returned."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I think bfs is the best way to visualize a tree in best efficient manner\\n\\n\\uD83D\\uDFE2 it needs only the O(N) extra space in the worst case"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 isn\\'t it same as the Populating Next Right Pointers in Each Node II"
                    },
                    {
                        "username": "SanskarGoyal_14",
                        "content": "Very easy question. If you know level order traversal (BFS), this question is a cake walk for you.\nJust perform BFS and for every node, think of how you can connect it with its next node at the same level.\n\nMy solution-\nhttps://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/3360359/c-simplest-bfs-solution-o-n-time/\nPLEASE HAVE A LOOK AND UPVOTE.. "
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "For those who bother what the return object is: the return object should be a Node object of the first level, and the object in other levels should be linked together, yet different layers are not needed to be linked to the node of other levels, and the only return object is the Node of the first level."
                    },
                    {
                        "username": "smbody",
                        "content": "Coding in java,\\n\\nI am able to perform level order traversal, but i am not able to include multiple null values in my answer. How can one do it ?"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "Why is there no option for using RUST?\\n"
                    }
                ]
            },
            {
                "id": 1879520,
                "content": [
                    {
                        "username": "21Cash",
                        "content": "You gotta be kidding me if u expect me to give you the O(1) memory solution without having seen the problem before"
                    },
                    {
                        "username": "rajat_171",
                        "content": "IT\\'s this just BFS ?? with saperator."
                    },
                    {
                        "username": "21Cash",
                        "content": "O(1) memory, how about that?? Still easy??\\n"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n         queue<Node*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size=q.size();\\n            if(size==0){\\n                return root;\\n            }\\n           \\n            while(size>0){\\n                 Node* temp;\\n                 if(size>1){\\n                     temp=q.front();\\n                     q.pop();\\n                     Node * newadd=q.front();\\n\\n                     temp->next=newadd;\\n                 }else{\\n                     temp=q.front();\\n                     q.pop();\\n                 }\\n                 if(temp->left != nullptr){  //----ERROR LINE-------\\n                     q.push(temp->left);\\n                 }\\n                 \\n                 if(temp->right!=nullptr){\\n                     q.push(temp->right);\\n                 }\\n                 size--;\\n                   \\n            }\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\n//   I am unable to understand error in inserting the temp left node if it is not null\\n"
                    },
                    {
                        "username": "ayush_ag",
                        "content": "Why is there a return type in the method. There\\'s nothing mentioned in the question on what needs to be returned."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I think bfs is the best way to visualize a tree in best efficient manner\\n\\n\\uD83D\\uDFE2 it needs only the O(N) extra space in the worst case"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 isn\\'t it same as the Populating Next Right Pointers in Each Node II"
                    },
                    {
                        "username": "SanskarGoyal_14",
                        "content": "Very easy question. If you know level order traversal (BFS), this question is a cake walk for you.\nJust perform BFS and for every node, think of how you can connect it with its next node at the same level.\n\nMy solution-\nhttps://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/3360359/c-simplest-bfs-solution-o-n-time/\nPLEASE HAVE A LOOK AND UPVOTE.. "
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "For those who bother what the return object is: the return object should be a Node object of the first level, and the object in other levels should be linked together, yet different layers are not needed to be linked to the node of other levels, and the only return object is the Node of the first level."
                    },
                    {
                        "username": "smbody",
                        "content": "Coding in java,\\n\\nI am able to perform level order traversal, but i am not able to include multiple null values in my answer. How can one do it ?"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "Why is there no option for using RUST?\\n"
                    }
                ]
            },
            {
                "id": 1872271,
                "content": [
                    {
                        "username": "21Cash",
                        "content": "You gotta be kidding me if u expect me to give you the O(1) memory solution without having seen the problem before"
                    },
                    {
                        "username": "rajat_171",
                        "content": "IT\\'s this just BFS ?? with saperator."
                    },
                    {
                        "username": "21Cash",
                        "content": "O(1) memory, how about that?? Still easy??\\n"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n         queue<Node*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size=q.size();\\n            if(size==0){\\n                return root;\\n            }\\n           \\n            while(size>0){\\n                 Node* temp;\\n                 if(size>1){\\n                     temp=q.front();\\n                     q.pop();\\n                     Node * newadd=q.front();\\n\\n                     temp->next=newadd;\\n                 }else{\\n                     temp=q.front();\\n                     q.pop();\\n                 }\\n                 if(temp->left != nullptr){  //----ERROR LINE-------\\n                     q.push(temp->left);\\n                 }\\n                 \\n                 if(temp->right!=nullptr){\\n                     q.push(temp->right);\\n                 }\\n                 size--;\\n                   \\n            }\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\n//   I am unable to understand error in inserting the temp left node if it is not null\\n"
                    },
                    {
                        "username": "ayush_ag",
                        "content": "Why is there a return type in the method. There\\'s nothing mentioned in the question on what needs to be returned."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I think bfs is the best way to visualize a tree in best efficient manner\\n\\n\\uD83D\\uDFE2 it needs only the O(N) extra space in the worst case"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 isn\\'t it same as the Populating Next Right Pointers in Each Node II"
                    },
                    {
                        "username": "SanskarGoyal_14",
                        "content": "Very easy question. If you know level order traversal (BFS), this question is a cake walk for you.\nJust perform BFS and for every node, think of how you can connect it with its next node at the same level.\n\nMy solution-\nhttps://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/3360359/c-simplest-bfs-solution-o-n-time/\nPLEASE HAVE A LOOK AND UPVOTE.. "
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "For those who bother what the return object is: the return object should be a Node object of the first level, and the object in other levels should be linked together, yet different layers are not needed to be linked to the node of other levels, and the only return object is the Node of the first level."
                    },
                    {
                        "username": "smbody",
                        "content": "Coding in java,\\n\\nI am able to perform level order traversal, but i am not able to include multiple null values in my answer. How can one do it ?"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "Why is there no option for using RUST?\\n"
                    }
                ]
            },
            {
                "id": 1869170,
                "content": [
                    {
                        "username": "21Cash",
                        "content": "You gotta be kidding me if u expect me to give you the O(1) memory solution without having seen the problem before"
                    },
                    {
                        "username": "rajat_171",
                        "content": "IT\\'s this just BFS ?? with saperator."
                    },
                    {
                        "username": "21Cash",
                        "content": "O(1) memory, how about that?? Still easy??\\n"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n         queue<Node*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size=q.size();\\n            if(size==0){\\n                return root;\\n            }\\n           \\n            while(size>0){\\n                 Node* temp;\\n                 if(size>1){\\n                     temp=q.front();\\n                     q.pop();\\n                     Node * newadd=q.front();\\n\\n                     temp->next=newadd;\\n                 }else{\\n                     temp=q.front();\\n                     q.pop();\\n                 }\\n                 if(temp->left != nullptr){  //----ERROR LINE-------\\n                     q.push(temp->left);\\n                 }\\n                 \\n                 if(temp->right!=nullptr){\\n                     q.push(temp->right);\\n                 }\\n                 size--;\\n                   \\n            }\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\n//   I am unable to understand error in inserting the temp left node if it is not null\\n"
                    },
                    {
                        "username": "ayush_ag",
                        "content": "Why is there a return type in the method. There\\'s nothing mentioned in the question on what needs to be returned."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I think bfs is the best way to visualize a tree in best efficient manner\\n\\n\\uD83D\\uDFE2 it needs only the O(N) extra space in the worst case"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 isn\\'t it same as the Populating Next Right Pointers in Each Node II"
                    },
                    {
                        "username": "SanskarGoyal_14",
                        "content": "Very easy question. If you know level order traversal (BFS), this question is a cake walk for you.\nJust perform BFS and for every node, think of how you can connect it with its next node at the same level.\n\nMy solution-\nhttps://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/3360359/c-simplest-bfs-solution-o-n-time/\nPLEASE HAVE A LOOK AND UPVOTE.. "
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "For those who bother what the return object is: the return object should be a Node object of the first level, and the object in other levels should be linked together, yet different layers are not needed to be linked to the node of other levels, and the only return object is the Node of the first level."
                    },
                    {
                        "username": "smbody",
                        "content": "Coding in java,\\n\\nI am able to perform level order traversal, but i am not able to include multiple null values in my answer. How can one do it ?"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "Why is there no option for using RUST?\\n"
                    }
                ]
            },
            {
                "id": 1863726,
                "content": [
                    {
                        "username": "21Cash",
                        "content": "You gotta be kidding me if u expect me to give you the O(1) memory solution without having seen the problem before"
                    },
                    {
                        "username": "rajat_171",
                        "content": "IT\\'s this just BFS ?? with saperator."
                    },
                    {
                        "username": "21Cash",
                        "content": "O(1) memory, how about that?? Still easy??\\n"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n         queue<Node*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size=q.size();\\n            if(size==0){\\n                return root;\\n            }\\n           \\n            while(size>0){\\n                 Node* temp;\\n                 if(size>1){\\n                     temp=q.front();\\n                     q.pop();\\n                     Node * newadd=q.front();\\n\\n                     temp->next=newadd;\\n                 }else{\\n                     temp=q.front();\\n                     q.pop();\\n                 }\\n                 if(temp->left != nullptr){  //----ERROR LINE-------\\n                     q.push(temp->left);\\n                 }\\n                 \\n                 if(temp->right!=nullptr){\\n                     q.push(temp->right);\\n                 }\\n                 size--;\\n                   \\n            }\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\n//   I am unable to understand error in inserting the temp left node if it is not null\\n"
                    },
                    {
                        "username": "ayush_ag",
                        "content": "Why is there a return type in the method. There\\'s nothing mentioned in the question on what needs to be returned."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I think bfs is the best way to visualize a tree in best efficient manner\\n\\n\\uD83D\\uDFE2 it needs only the O(N) extra space in the worst case"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 isn\\'t it same as the Populating Next Right Pointers in Each Node II"
                    },
                    {
                        "username": "SanskarGoyal_14",
                        "content": "Very easy question. If you know level order traversal (BFS), this question is a cake walk for you.\nJust perform BFS and for every node, think of how you can connect it with its next node at the same level.\n\nMy solution-\nhttps://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/3360359/c-simplest-bfs-solution-o-n-time/\nPLEASE HAVE A LOOK AND UPVOTE.. "
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "For those who bother what the return object is: the return object should be a Node object of the first level, and the object in other levels should be linked together, yet different layers are not needed to be linked to the node of other levels, and the only return object is the Node of the first level."
                    },
                    {
                        "username": "smbody",
                        "content": "Coding in java,\\n\\nI am able to perform level order traversal, but i am not able to include multiple null values in my answer. How can one do it ?"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "Why is there no option for using RUST?\\n"
                    }
                ]
            },
            {
                "id": 1863718,
                "content": [
                    {
                        "username": "21Cash",
                        "content": "You gotta be kidding me if u expect me to give you the O(1) memory solution without having seen the problem before"
                    },
                    {
                        "username": "rajat_171",
                        "content": "IT\\'s this just BFS ?? with saperator."
                    },
                    {
                        "username": "21Cash",
                        "content": "O(1) memory, how about that?? Still easy??\\n"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n         queue<Node*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size=q.size();\\n            if(size==0){\\n                return root;\\n            }\\n           \\n            while(size>0){\\n                 Node* temp;\\n                 if(size>1){\\n                     temp=q.front();\\n                     q.pop();\\n                     Node * newadd=q.front();\\n\\n                     temp->next=newadd;\\n                 }else{\\n                     temp=q.front();\\n                     q.pop();\\n                 }\\n                 if(temp->left != nullptr){  //----ERROR LINE-------\\n                     q.push(temp->left);\\n                 }\\n                 \\n                 if(temp->right!=nullptr){\\n                     q.push(temp->right);\\n                 }\\n                 size--;\\n                   \\n            }\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\n//   I am unable to understand error in inserting the temp left node if it is not null\\n"
                    },
                    {
                        "username": "ayush_ag",
                        "content": "Why is there a return type in the method. There\\'s nothing mentioned in the question on what needs to be returned."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I think bfs is the best way to visualize a tree in best efficient manner\\n\\n\\uD83D\\uDFE2 it needs only the O(N) extra space in the worst case"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 isn\\'t it same as the Populating Next Right Pointers in Each Node II"
                    },
                    {
                        "username": "SanskarGoyal_14",
                        "content": "Very easy question. If you know level order traversal (BFS), this question is a cake walk for you.\nJust perform BFS and for every node, think of how you can connect it with its next node at the same level.\n\nMy solution-\nhttps://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/3360359/c-simplest-bfs-solution-o-n-time/\nPLEASE HAVE A LOOK AND UPVOTE.. "
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "For those who bother what the return object is: the return object should be a Node object of the first level, and the object in other levels should be linked together, yet different layers are not needed to be linked to the node of other levels, and the only return object is the Node of the first level."
                    },
                    {
                        "username": "smbody",
                        "content": "Coding in java,\\n\\nI am able to perform level order traversal, but i am not able to include multiple null values in my answer. How can one do it ?"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "Why is there no option for using RUST?\\n"
                    }
                ]
            },
            {
                "id": 1848647,
                "content": [
                    {
                        "username": "21Cash",
                        "content": "You gotta be kidding me if u expect me to give you the O(1) memory solution without having seen the problem before"
                    },
                    {
                        "username": "rajat_171",
                        "content": "IT\\'s this just BFS ?? with saperator."
                    },
                    {
                        "username": "21Cash",
                        "content": "O(1) memory, how about that?? Still easy??\\n"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n         queue<Node*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size=q.size();\\n            if(size==0){\\n                return root;\\n            }\\n           \\n            while(size>0){\\n                 Node* temp;\\n                 if(size>1){\\n                     temp=q.front();\\n                     q.pop();\\n                     Node * newadd=q.front();\\n\\n                     temp->next=newadd;\\n                 }else{\\n                     temp=q.front();\\n                     q.pop();\\n                 }\\n                 if(temp->left != nullptr){  //----ERROR LINE-------\\n                     q.push(temp->left);\\n                 }\\n                 \\n                 if(temp->right!=nullptr){\\n                     q.push(temp->right);\\n                 }\\n                 size--;\\n                   \\n            }\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\n//   I am unable to understand error in inserting the temp left node if it is not null\\n"
                    },
                    {
                        "username": "ayush_ag",
                        "content": "Why is there a return type in the method. There\\'s nothing mentioned in the question on what needs to be returned."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I think bfs is the best way to visualize a tree in best efficient manner\\n\\n\\uD83D\\uDFE2 it needs only the O(N) extra space in the worst case"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 isn\\'t it same as the Populating Next Right Pointers in Each Node II"
                    },
                    {
                        "username": "SanskarGoyal_14",
                        "content": "Very easy question. If you know level order traversal (BFS), this question is a cake walk for you.\nJust perform BFS and for every node, think of how you can connect it with its next node at the same level.\n\nMy solution-\nhttps://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/3360359/c-simplest-bfs-solution-o-n-time/\nPLEASE HAVE A LOOK AND UPVOTE.. "
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "For those who bother what the return object is: the return object should be a Node object of the first level, and the object in other levels should be linked together, yet different layers are not needed to be linked to the node of other levels, and the only return object is the Node of the first level."
                    },
                    {
                        "username": "smbody",
                        "content": "Coding in java,\\n\\nI am able to perform level order traversal, but i am not able to include multiple null values in my answer. How can one do it ?"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "Why is there no option for using RUST?\\n"
                    }
                ]
            },
            {
                "id": 1833871,
                "content": [
                    {
                        "username": "21Cash",
                        "content": "You gotta be kidding me if u expect me to give you the O(1) memory solution without having seen the problem before"
                    },
                    {
                        "username": "rajat_171",
                        "content": "IT\\'s this just BFS ?? with saperator."
                    },
                    {
                        "username": "21Cash",
                        "content": "O(1) memory, how about that?? Still easy??\\n"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n         queue<Node*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size=q.size();\\n            if(size==0){\\n                return root;\\n            }\\n           \\n            while(size>0){\\n                 Node* temp;\\n                 if(size>1){\\n                     temp=q.front();\\n                     q.pop();\\n                     Node * newadd=q.front();\\n\\n                     temp->next=newadd;\\n                 }else{\\n                     temp=q.front();\\n                     q.pop();\\n                 }\\n                 if(temp->left != nullptr){  //----ERROR LINE-------\\n                     q.push(temp->left);\\n                 }\\n                 \\n                 if(temp->right!=nullptr){\\n                     q.push(temp->right);\\n                 }\\n                 size--;\\n                   \\n            }\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\n//   I am unable to understand error in inserting the temp left node if it is not null\\n"
                    },
                    {
                        "username": "ayush_ag",
                        "content": "Why is there a return type in the method. There\\'s nothing mentioned in the question on what needs to be returned."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I think bfs is the best way to visualize a tree in best efficient manner\\n\\n\\uD83D\\uDFE2 it needs only the O(N) extra space in the worst case"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 isn\\'t it same as the Populating Next Right Pointers in Each Node II"
                    },
                    {
                        "username": "SanskarGoyal_14",
                        "content": "Very easy question. If you know level order traversal (BFS), this question is a cake walk for you.\nJust perform BFS and for every node, think of how you can connect it with its next node at the same level.\n\nMy solution-\nhttps://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/3360359/c-simplest-bfs-solution-o-n-time/\nPLEASE HAVE A LOOK AND UPVOTE.. "
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "For those who bother what the return object is: the return object should be a Node object of the first level, and the object in other levels should be linked together, yet different layers are not needed to be linked to the node of other levels, and the only return object is the Node of the first level."
                    },
                    {
                        "username": "smbody",
                        "content": "Coding in java,\\n\\nI am able to perform level order traversal, but i am not able to include multiple null values in my answer. How can one do it ?"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "Why is there no option for using RUST?\\n"
                    }
                ]
            },
            {
                "id": 1825265,
                "content": [
                    {
                        "username": "21Cash",
                        "content": "You gotta be kidding me if u expect me to give you the O(1) memory solution without having seen the problem before"
                    },
                    {
                        "username": "rajat_171",
                        "content": "IT\\'s this just BFS ?? with saperator."
                    },
                    {
                        "username": "21Cash",
                        "content": "O(1) memory, how about that?? Still easy??\\n"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n         queue<Node*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size=q.size();\\n            if(size==0){\\n                return root;\\n            }\\n           \\n            while(size>0){\\n                 Node* temp;\\n                 if(size>1){\\n                     temp=q.front();\\n                     q.pop();\\n                     Node * newadd=q.front();\\n\\n                     temp->next=newadd;\\n                 }else{\\n                     temp=q.front();\\n                     q.pop();\\n                 }\\n                 if(temp->left != nullptr){  //----ERROR LINE-------\\n                     q.push(temp->left);\\n                 }\\n                 \\n                 if(temp->right!=nullptr){\\n                     q.push(temp->right);\\n                 }\\n                 size--;\\n                   \\n            }\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\n//   I am unable to understand error in inserting the temp left node if it is not null\\n"
                    },
                    {
                        "username": "ayush_ag",
                        "content": "Why is there a return type in the method. There\\'s nothing mentioned in the question on what needs to be returned."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I think bfs is the best way to visualize a tree in best efficient manner\\n\\n\\uD83D\\uDFE2 it needs only the O(N) extra space in the worst case"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 isn\\'t it same as the Populating Next Right Pointers in Each Node II"
                    },
                    {
                        "username": "SanskarGoyal_14",
                        "content": "Very easy question. If you know level order traversal (BFS), this question is a cake walk for you.\nJust perform BFS and for every node, think of how you can connect it with its next node at the same level.\n\nMy solution-\nhttps://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/3360359/c-simplest-bfs-solution-o-n-time/\nPLEASE HAVE A LOOK AND UPVOTE.. "
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "For those who bother what the return object is: the return object should be a Node object of the first level, and the object in other levels should be linked together, yet different layers are not needed to be linked to the node of other levels, and the only return object is the Node of the first level."
                    },
                    {
                        "username": "smbody",
                        "content": "Coding in java,\\n\\nI am able to perform level order traversal, but i am not able to include multiple null values in my answer. How can one do it ?"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "Why is there no option for using RUST?\\n"
                    }
                ]
            },
            {
                "id": 1785371,
                "content": [
                    {
                        "username": "21Cash",
                        "content": "You gotta be kidding me if u expect me to give you the O(1) memory solution without having seen the problem before"
                    },
                    {
                        "username": "rajat_171",
                        "content": "IT\\'s this just BFS ?? with saperator."
                    },
                    {
                        "username": "21Cash",
                        "content": "O(1) memory, how about that?? Still easy??\\n"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n         queue<Node*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size=q.size();\\n            if(size==0){\\n                return root;\\n            }\\n           \\n            while(size>0){\\n                 Node* temp;\\n                 if(size>1){\\n                     temp=q.front();\\n                     q.pop();\\n                     Node * newadd=q.front();\\n\\n                     temp->next=newadd;\\n                 }else{\\n                     temp=q.front();\\n                     q.pop();\\n                 }\\n                 if(temp->left != nullptr){  //----ERROR LINE-------\\n                     q.push(temp->left);\\n                 }\\n                 \\n                 if(temp->right!=nullptr){\\n                     q.push(temp->right);\\n                 }\\n                 size--;\\n                   \\n            }\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\n//   I am unable to understand error in inserting the temp left node if it is not null\\n"
                    },
                    {
                        "username": "ayush_ag",
                        "content": "Why is there a return type in the method. There\\'s nothing mentioned in the question on what needs to be returned."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I think bfs is the best way to visualize a tree in best efficient manner\\n\\n\\uD83D\\uDFE2 it needs only the O(N) extra space in the worst case"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 isn\\'t it same as the Populating Next Right Pointers in Each Node II"
                    },
                    {
                        "username": "SanskarGoyal_14",
                        "content": "Very easy question. If you know level order traversal (BFS), this question is a cake walk for you.\nJust perform BFS and for every node, think of how you can connect it with its next node at the same level.\n\nMy solution-\nhttps://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/3360359/c-simplest-bfs-solution-o-n-time/\nPLEASE HAVE A LOOK AND UPVOTE.. "
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "For those who bother what the return object is: the return object should be a Node object of the first level, and the object in other levels should be linked together, yet different layers are not needed to be linked to the node of other levels, and the only return object is the Node of the first level."
                    },
                    {
                        "username": "smbody",
                        "content": "Coding in java,\\n\\nI am able to perform level order traversal, but i am not able to include multiple null values in my answer. How can one do it ?"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "Why is there no option for using RUST?\\n"
                    }
                ]
            },
            {
                "id": 1761008,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "gekh",
                        "content": "Why is there no Rust?"
                    },
                    {
                        "username": "thannerusaiharshith",
                        "content": "The hint is to use the level order traversal!"
                    },
                    {
                        "username": "gekh",
                        "content": "thanks"
                    },
                    {
                        "username": "Thakur_aman_cs",
                        "content": "This solution uses a queue to store the nodes at each level of the tree, and iterates through the queue to set the next pointers of the nodes. It starts by adding the root node to the queue, and then iterates through the queue until it is empty. For each node in the queue, it sets the next pointer to the next node in the queue (if it exists), and adds the left and right children of the node to the queue. This ensures that the next pointers are set in a breadth-first order."
                    },
                    {
                        "username": "devKangM",
                        "content": " ```\nvar connect = function(root) {\n    let queue = [root];\n    while (queue.length != 0) {\n        console.log(\"start: \", queue.length)\n        const len = queue.length;\n        let nextQueue = [];\n        for (let i = 0; i < len; i++) {\n            const target = queue.shift();\n            if (target.left) nextQueue.push(target.left);\n            if (target.right) nextQueue.push(target.right);\n            if (i === len-1) target.next = null;\n            else target.next = queue[0];\n        }\n        queue = nextQueue;\n        console.log(\"last: \", queue.length);\n\n    }\n    return root;\n};\n```\n\nstart:  1\nlast:  2\nstart:  2\nlast:  4\nstart:  4\nlast:  0\nstart:  1\n\nhere is my code, and Stdout.\nbut some error happen.\n```\nLine 22 in solution.js\n            if (target.left) nextQueue.push(target.left);\n                       ^\nTypeError: Cannot read properties of null (reading 'left')\n    Line 22: Char 24 in solution.js (connect)\n    Line 94: Char 19 in solution.js (Object.<anonymous>)\n    Line 16: Char 8 in runner.js (Object.runner)\n    Line 33: Char 26 in solution.js (Object.<anonymous>)\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\n    at Module.load (node:internal/modules/cjs/loader:981:32)\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\n```\nIn this case, i got a problem that i can't understand.\nwhy the queue.length became from 0 to 1 like Stdout?\nI can't understand.... help me"
                    },
                    {
                        "username": "shivamgcoder",
                        "content": "simple recursion solution\\nclass Solution:\\n\\tdef connect(self, root: \\'Node\\') -> \\'Node\\':\\n\\t\\tif not root or not root.left:\\n\\t\\t\\treturn root\\n\\t\\troot.left.next=root.right\\n\\t\\tif root.next:\\n\\t\\t\\troot.right.next=root.next.left\\n\\t\\tself.connect(root.left)\\n\\t\\tself.connect(root.right)\\n\\t\\treturn root\\n"
                    },
                    {
                        "username": "AmanJaiSingh",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        queue<Node* > q1;\\n        q1.push(root);\\n        q1.push(NULL);\\n        while(q1.size()>1){\\n            Node* curr=q1.front();\\n            q1.pop();\\n            if(curr==NULL){\\n                q1.push(NULL);\\n                continue;\\n            }\\n            curr->next=q1.front();\\n            if(curr->left) q1.push(curr->left);\\n            if(curr->right) q1.push(curr->right);\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\nwhy this shows runtime error .. it doesnot pop the null why is this happning,.."
                    },
                    {
                        "username": "Ayush142",
                        "content": "Just add boundry condition , it will work fine\\n        if(root==NULL){\\n            return root;\\n        } "
                    },
                    {
                        "username": "conway22",
                        "content": "so the key point is perfect binary tree!!!"
                    },
                    {
                        "username": "matans844",
                        "content": "I tried to write a solution in C (which was accepted), but I had a problem when using dynamic memory allocation in debug vs non-debug mode.\\n\\nI want to maintain a static array of pointers to the yet unconnected TreeNodes in the tail of each row in the given perfect binary tree so that I can use it and update it while traversing the tree in-order. For this, I need the tree height. I can use the problem constraints to find an upper bound for it, `12`, which is good enough. However, I was aiming at a more general solution in which I can also practice dynamic memory allocation.\\n\\nI came up with the following attempt (which was accepted):\\n```\\n/**\\n * Definition for a Node.\\n * struct Node {\\n *     int val;\\n *     struct Node *left;\\n *     struct Node *right;\\n *     struct Node *next;\\n * };\\n */\\n\\nint curr_height = 0;\\nint height = 0;\\nint have_height = 0;\\n\\nstruct Node ** ptr_to_table = NULL;\\n\\nvoid allocate_direct_table(){\\n\\tint SIZE = height + 9;\\n\\tptr_to_table = calloc(SIZE, sizeof(struct Node *));\\n\\n\\tstruct Node * arr[SIZE];\\n\\tfor(int i=0; i<SIZE; i++){\\n\\t\\tarr[i] = NULL;\\n\\t}\\n\\n\\t*ptr_to_table = arr;\\n\\n\\t\\n\\t// ptr_to_table = malloc((height + 1) * sizeof(struct Node *));\\n\\t// memset(ptr_to_table, 0, (height + 1) * sizeof(struct Node *));\\n}\\n\\nvoid process(struct Node* root){\\n\\tint index = curr_height;\\n\\tif(ptr_to_table[index]){\\n\\t\\tptr_to_table[index] -> next = root;\\n\\t}\\n\\tptr_to_table[index] = root;\\n\\troot -> next = NULL;\\n}\\n\\nvoid preprocess(){\\n\\theight = curr_height;\\n\\tallocate_direct_table();\\n}\\n\\nstruct Node* connect(struct Node* root) {\\n\\tif(!root && !have_height){\\n\\t\\tpreprocess();\\n\\t\\thave_height = 1;\\n\\t\\treturn NULL;\\n\\t}\\n\\tif(!root) return NULL;\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> left);\\n\\tcurr_height --;\\n\\n\\tprocess(root);\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> right);\\n\\tcurr_height --;\\n\\n\\treturn root;\\n    \\n}\\n```\\nI found a behavior of this code that I could not explain. It involves the dynamic memory allocation in the `allocate_direct_table()` function: \\n1. When debugging, I can use `SIZE = height`, and everything works.\\n2. When submitting, I get an `AddressSanitizer: heap-buffer-overflow` error, so I have to increase the height. I have no idea why, and I have no idea why `9` is enough. It probably has to do with the problem constraints, which means my solution is not general.\\n\\nHere is the error when submitting the version with `SIZE = height`:\\n\\nProblematic input:\\n\\n    [-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13]\\n\\nRuntime Error:\\n\\n    =================================================================\\n    ==30==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000178 at pc 0x55979bc921c2 bp 0x7ffd997833a0 sp 0x7ffd99783390\\n    READ of size 8 at 0x603000000178 thread T0\\n        #5 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    0x603000000178 is located 0 bytes to the right of 24-byte region [0x603000000160,0x603000000178)\\n    allocated by thread T0 here:\\n        #0 0x7f179ec8bdc6 in calloc (/lib/x86_64-linux-gnu/libasan.so.5+0x10ddc6)\\n        #7 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    Shadow bytes around the buggy address:\\n      0x0c067fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff8000: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8010: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    =>0x0c067fff8020: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00[fa]\\n      0x0c067fff8030: fa fa 00 00 06 fa fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8040: 00 fa fa fa 00 00 00 fa fa fa 00 00 00 00 fa fa\\n      0x0c067fff8050: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00\\n      0x0c067fff8060: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8070: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    Shadow byte legend (one shadow byte represents 8 application bytes):\\n      Addressable:           00\\n      Partially addressable: 01 02 03 04 05 06 07 \\n      Heap left redzone:       fa\\n      Freed heap region:       fd\\n      Stack left redzone:      f1\\n      Stack mid redzone:       f2\\n      Stack right redzone:     f3\\n      Stack after return:      f5\\n      Stack use after scope:   f8\\n      Global redzone:          f9\\n      Global init order:       f6\\n      Poisoned by user:        f7\\n      Container overflow:      fc\\n      Array cookie:            ac\\n      Intra object redzone:    bb\\n      ASan internal:           fe\\n      Left alloca redzone:     ca\\n      Right alloca redzone:    cb\\n      Shadow gap:              cc\\n    ==30==ABORTING\\n\\n\\n**Questions:**\\n1. Why does `SIZE = height` not work in debug mode?\\n2. Why is it `9` or more that I need to add?\\n\\nAny help is much appreciated!"
                    },
                    {
                        "username": "vdsyrocks",
                        "content": "Do level order traversal with a \"prev\" variable "
                    }
                ]
            },
            {
                "id": 1749449,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "gekh",
                        "content": "Why is there no Rust?"
                    },
                    {
                        "username": "thannerusaiharshith",
                        "content": "The hint is to use the level order traversal!"
                    },
                    {
                        "username": "gekh",
                        "content": "thanks"
                    },
                    {
                        "username": "Thakur_aman_cs",
                        "content": "This solution uses a queue to store the nodes at each level of the tree, and iterates through the queue to set the next pointers of the nodes. It starts by adding the root node to the queue, and then iterates through the queue until it is empty. For each node in the queue, it sets the next pointer to the next node in the queue (if it exists), and adds the left and right children of the node to the queue. This ensures that the next pointers are set in a breadth-first order."
                    },
                    {
                        "username": "devKangM",
                        "content": " ```\nvar connect = function(root) {\n    let queue = [root];\n    while (queue.length != 0) {\n        console.log(\"start: \", queue.length)\n        const len = queue.length;\n        let nextQueue = [];\n        for (let i = 0; i < len; i++) {\n            const target = queue.shift();\n            if (target.left) nextQueue.push(target.left);\n            if (target.right) nextQueue.push(target.right);\n            if (i === len-1) target.next = null;\n            else target.next = queue[0];\n        }\n        queue = nextQueue;\n        console.log(\"last: \", queue.length);\n\n    }\n    return root;\n};\n```\n\nstart:  1\nlast:  2\nstart:  2\nlast:  4\nstart:  4\nlast:  0\nstart:  1\n\nhere is my code, and Stdout.\nbut some error happen.\n```\nLine 22 in solution.js\n            if (target.left) nextQueue.push(target.left);\n                       ^\nTypeError: Cannot read properties of null (reading 'left')\n    Line 22: Char 24 in solution.js (connect)\n    Line 94: Char 19 in solution.js (Object.<anonymous>)\n    Line 16: Char 8 in runner.js (Object.runner)\n    Line 33: Char 26 in solution.js (Object.<anonymous>)\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\n    at Module.load (node:internal/modules/cjs/loader:981:32)\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\n```\nIn this case, i got a problem that i can't understand.\nwhy the queue.length became from 0 to 1 like Stdout?\nI can't understand.... help me"
                    },
                    {
                        "username": "shivamgcoder",
                        "content": "simple recursion solution\\nclass Solution:\\n\\tdef connect(self, root: \\'Node\\') -> \\'Node\\':\\n\\t\\tif not root or not root.left:\\n\\t\\t\\treturn root\\n\\t\\troot.left.next=root.right\\n\\t\\tif root.next:\\n\\t\\t\\troot.right.next=root.next.left\\n\\t\\tself.connect(root.left)\\n\\t\\tself.connect(root.right)\\n\\t\\treturn root\\n"
                    },
                    {
                        "username": "AmanJaiSingh",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        queue<Node* > q1;\\n        q1.push(root);\\n        q1.push(NULL);\\n        while(q1.size()>1){\\n            Node* curr=q1.front();\\n            q1.pop();\\n            if(curr==NULL){\\n                q1.push(NULL);\\n                continue;\\n            }\\n            curr->next=q1.front();\\n            if(curr->left) q1.push(curr->left);\\n            if(curr->right) q1.push(curr->right);\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\nwhy this shows runtime error .. it doesnot pop the null why is this happning,.."
                    },
                    {
                        "username": "Ayush142",
                        "content": "Just add boundry condition , it will work fine\\n        if(root==NULL){\\n            return root;\\n        } "
                    },
                    {
                        "username": "conway22",
                        "content": "so the key point is perfect binary tree!!!"
                    },
                    {
                        "username": "matans844",
                        "content": "I tried to write a solution in C (which was accepted), but I had a problem when using dynamic memory allocation in debug vs non-debug mode.\\n\\nI want to maintain a static array of pointers to the yet unconnected TreeNodes in the tail of each row in the given perfect binary tree so that I can use it and update it while traversing the tree in-order. For this, I need the tree height. I can use the problem constraints to find an upper bound for it, `12`, which is good enough. However, I was aiming at a more general solution in which I can also practice dynamic memory allocation.\\n\\nI came up with the following attempt (which was accepted):\\n```\\n/**\\n * Definition for a Node.\\n * struct Node {\\n *     int val;\\n *     struct Node *left;\\n *     struct Node *right;\\n *     struct Node *next;\\n * };\\n */\\n\\nint curr_height = 0;\\nint height = 0;\\nint have_height = 0;\\n\\nstruct Node ** ptr_to_table = NULL;\\n\\nvoid allocate_direct_table(){\\n\\tint SIZE = height + 9;\\n\\tptr_to_table = calloc(SIZE, sizeof(struct Node *));\\n\\n\\tstruct Node * arr[SIZE];\\n\\tfor(int i=0; i<SIZE; i++){\\n\\t\\tarr[i] = NULL;\\n\\t}\\n\\n\\t*ptr_to_table = arr;\\n\\n\\t\\n\\t// ptr_to_table = malloc((height + 1) * sizeof(struct Node *));\\n\\t// memset(ptr_to_table, 0, (height + 1) * sizeof(struct Node *));\\n}\\n\\nvoid process(struct Node* root){\\n\\tint index = curr_height;\\n\\tif(ptr_to_table[index]){\\n\\t\\tptr_to_table[index] -> next = root;\\n\\t}\\n\\tptr_to_table[index] = root;\\n\\troot -> next = NULL;\\n}\\n\\nvoid preprocess(){\\n\\theight = curr_height;\\n\\tallocate_direct_table();\\n}\\n\\nstruct Node* connect(struct Node* root) {\\n\\tif(!root && !have_height){\\n\\t\\tpreprocess();\\n\\t\\thave_height = 1;\\n\\t\\treturn NULL;\\n\\t}\\n\\tif(!root) return NULL;\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> left);\\n\\tcurr_height --;\\n\\n\\tprocess(root);\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> right);\\n\\tcurr_height --;\\n\\n\\treturn root;\\n    \\n}\\n```\\nI found a behavior of this code that I could not explain. It involves the dynamic memory allocation in the `allocate_direct_table()` function: \\n1. When debugging, I can use `SIZE = height`, and everything works.\\n2. When submitting, I get an `AddressSanitizer: heap-buffer-overflow` error, so I have to increase the height. I have no idea why, and I have no idea why `9` is enough. It probably has to do with the problem constraints, which means my solution is not general.\\n\\nHere is the error when submitting the version with `SIZE = height`:\\n\\nProblematic input:\\n\\n    [-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13]\\n\\nRuntime Error:\\n\\n    =================================================================\\n    ==30==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000178 at pc 0x55979bc921c2 bp 0x7ffd997833a0 sp 0x7ffd99783390\\n    READ of size 8 at 0x603000000178 thread T0\\n        #5 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    0x603000000178 is located 0 bytes to the right of 24-byte region [0x603000000160,0x603000000178)\\n    allocated by thread T0 here:\\n        #0 0x7f179ec8bdc6 in calloc (/lib/x86_64-linux-gnu/libasan.so.5+0x10ddc6)\\n        #7 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    Shadow bytes around the buggy address:\\n      0x0c067fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff8000: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8010: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    =>0x0c067fff8020: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00[fa]\\n      0x0c067fff8030: fa fa 00 00 06 fa fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8040: 00 fa fa fa 00 00 00 fa fa fa 00 00 00 00 fa fa\\n      0x0c067fff8050: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00\\n      0x0c067fff8060: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8070: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    Shadow byte legend (one shadow byte represents 8 application bytes):\\n      Addressable:           00\\n      Partially addressable: 01 02 03 04 05 06 07 \\n      Heap left redzone:       fa\\n      Freed heap region:       fd\\n      Stack left redzone:      f1\\n      Stack mid redzone:       f2\\n      Stack right redzone:     f3\\n      Stack after return:      f5\\n      Stack use after scope:   f8\\n      Global redzone:          f9\\n      Global init order:       f6\\n      Poisoned by user:        f7\\n      Container overflow:      fc\\n      Array cookie:            ac\\n      Intra object redzone:    bb\\n      ASan internal:           fe\\n      Left alloca redzone:     ca\\n      Right alloca redzone:    cb\\n      Shadow gap:              cc\\n    ==30==ABORTING\\n\\n\\n**Questions:**\\n1. Why does `SIZE = height` not work in debug mode?\\n2. Why is it `9` or more that I need to add?\\n\\nAny help is much appreciated!"
                    },
                    {
                        "username": "vdsyrocks",
                        "content": "Do level order traversal with a \"prev\" variable "
                    }
                ]
            },
            {
                "id": 1749358,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "gekh",
                        "content": "Why is there no Rust?"
                    },
                    {
                        "username": "thannerusaiharshith",
                        "content": "The hint is to use the level order traversal!"
                    },
                    {
                        "username": "gekh",
                        "content": "thanks"
                    },
                    {
                        "username": "Thakur_aman_cs",
                        "content": "This solution uses a queue to store the nodes at each level of the tree, and iterates through the queue to set the next pointers of the nodes. It starts by adding the root node to the queue, and then iterates through the queue until it is empty. For each node in the queue, it sets the next pointer to the next node in the queue (if it exists), and adds the left and right children of the node to the queue. This ensures that the next pointers are set in a breadth-first order."
                    },
                    {
                        "username": "devKangM",
                        "content": " ```\nvar connect = function(root) {\n    let queue = [root];\n    while (queue.length != 0) {\n        console.log(\"start: \", queue.length)\n        const len = queue.length;\n        let nextQueue = [];\n        for (let i = 0; i < len; i++) {\n            const target = queue.shift();\n            if (target.left) nextQueue.push(target.left);\n            if (target.right) nextQueue.push(target.right);\n            if (i === len-1) target.next = null;\n            else target.next = queue[0];\n        }\n        queue = nextQueue;\n        console.log(\"last: \", queue.length);\n\n    }\n    return root;\n};\n```\n\nstart:  1\nlast:  2\nstart:  2\nlast:  4\nstart:  4\nlast:  0\nstart:  1\n\nhere is my code, and Stdout.\nbut some error happen.\n```\nLine 22 in solution.js\n            if (target.left) nextQueue.push(target.left);\n                       ^\nTypeError: Cannot read properties of null (reading 'left')\n    Line 22: Char 24 in solution.js (connect)\n    Line 94: Char 19 in solution.js (Object.<anonymous>)\n    Line 16: Char 8 in runner.js (Object.runner)\n    Line 33: Char 26 in solution.js (Object.<anonymous>)\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\n    at Module.load (node:internal/modules/cjs/loader:981:32)\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\n```\nIn this case, i got a problem that i can't understand.\nwhy the queue.length became from 0 to 1 like Stdout?\nI can't understand.... help me"
                    },
                    {
                        "username": "shivamgcoder",
                        "content": "simple recursion solution\\nclass Solution:\\n\\tdef connect(self, root: \\'Node\\') -> \\'Node\\':\\n\\t\\tif not root or not root.left:\\n\\t\\t\\treturn root\\n\\t\\troot.left.next=root.right\\n\\t\\tif root.next:\\n\\t\\t\\troot.right.next=root.next.left\\n\\t\\tself.connect(root.left)\\n\\t\\tself.connect(root.right)\\n\\t\\treturn root\\n"
                    },
                    {
                        "username": "AmanJaiSingh",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        queue<Node* > q1;\\n        q1.push(root);\\n        q1.push(NULL);\\n        while(q1.size()>1){\\n            Node* curr=q1.front();\\n            q1.pop();\\n            if(curr==NULL){\\n                q1.push(NULL);\\n                continue;\\n            }\\n            curr->next=q1.front();\\n            if(curr->left) q1.push(curr->left);\\n            if(curr->right) q1.push(curr->right);\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\nwhy this shows runtime error .. it doesnot pop the null why is this happning,.."
                    },
                    {
                        "username": "Ayush142",
                        "content": "Just add boundry condition , it will work fine\\n        if(root==NULL){\\n            return root;\\n        } "
                    },
                    {
                        "username": "conway22",
                        "content": "so the key point is perfect binary tree!!!"
                    },
                    {
                        "username": "matans844",
                        "content": "I tried to write a solution in C (which was accepted), but I had a problem when using dynamic memory allocation in debug vs non-debug mode.\\n\\nI want to maintain a static array of pointers to the yet unconnected TreeNodes in the tail of each row in the given perfect binary tree so that I can use it and update it while traversing the tree in-order. For this, I need the tree height. I can use the problem constraints to find an upper bound for it, `12`, which is good enough. However, I was aiming at a more general solution in which I can also practice dynamic memory allocation.\\n\\nI came up with the following attempt (which was accepted):\\n```\\n/**\\n * Definition for a Node.\\n * struct Node {\\n *     int val;\\n *     struct Node *left;\\n *     struct Node *right;\\n *     struct Node *next;\\n * };\\n */\\n\\nint curr_height = 0;\\nint height = 0;\\nint have_height = 0;\\n\\nstruct Node ** ptr_to_table = NULL;\\n\\nvoid allocate_direct_table(){\\n\\tint SIZE = height + 9;\\n\\tptr_to_table = calloc(SIZE, sizeof(struct Node *));\\n\\n\\tstruct Node * arr[SIZE];\\n\\tfor(int i=0; i<SIZE; i++){\\n\\t\\tarr[i] = NULL;\\n\\t}\\n\\n\\t*ptr_to_table = arr;\\n\\n\\t\\n\\t// ptr_to_table = malloc((height + 1) * sizeof(struct Node *));\\n\\t// memset(ptr_to_table, 0, (height + 1) * sizeof(struct Node *));\\n}\\n\\nvoid process(struct Node* root){\\n\\tint index = curr_height;\\n\\tif(ptr_to_table[index]){\\n\\t\\tptr_to_table[index] -> next = root;\\n\\t}\\n\\tptr_to_table[index] = root;\\n\\troot -> next = NULL;\\n}\\n\\nvoid preprocess(){\\n\\theight = curr_height;\\n\\tallocate_direct_table();\\n}\\n\\nstruct Node* connect(struct Node* root) {\\n\\tif(!root && !have_height){\\n\\t\\tpreprocess();\\n\\t\\thave_height = 1;\\n\\t\\treturn NULL;\\n\\t}\\n\\tif(!root) return NULL;\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> left);\\n\\tcurr_height --;\\n\\n\\tprocess(root);\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> right);\\n\\tcurr_height --;\\n\\n\\treturn root;\\n    \\n}\\n```\\nI found a behavior of this code that I could not explain. It involves the dynamic memory allocation in the `allocate_direct_table()` function: \\n1. When debugging, I can use `SIZE = height`, and everything works.\\n2. When submitting, I get an `AddressSanitizer: heap-buffer-overflow` error, so I have to increase the height. I have no idea why, and I have no idea why `9` is enough. It probably has to do with the problem constraints, which means my solution is not general.\\n\\nHere is the error when submitting the version with `SIZE = height`:\\n\\nProblematic input:\\n\\n    [-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13]\\n\\nRuntime Error:\\n\\n    =================================================================\\n    ==30==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000178 at pc 0x55979bc921c2 bp 0x7ffd997833a0 sp 0x7ffd99783390\\n    READ of size 8 at 0x603000000178 thread T0\\n        #5 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    0x603000000178 is located 0 bytes to the right of 24-byte region [0x603000000160,0x603000000178)\\n    allocated by thread T0 here:\\n        #0 0x7f179ec8bdc6 in calloc (/lib/x86_64-linux-gnu/libasan.so.5+0x10ddc6)\\n        #7 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    Shadow bytes around the buggy address:\\n      0x0c067fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff8000: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8010: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    =>0x0c067fff8020: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00[fa]\\n      0x0c067fff8030: fa fa 00 00 06 fa fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8040: 00 fa fa fa 00 00 00 fa fa fa 00 00 00 00 fa fa\\n      0x0c067fff8050: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00\\n      0x0c067fff8060: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8070: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    Shadow byte legend (one shadow byte represents 8 application bytes):\\n      Addressable:           00\\n      Partially addressable: 01 02 03 04 05 06 07 \\n      Heap left redzone:       fa\\n      Freed heap region:       fd\\n      Stack left redzone:      f1\\n      Stack mid redzone:       f2\\n      Stack right redzone:     f3\\n      Stack after return:      f5\\n      Stack use after scope:   f8\\n      Global redzone:          f9\\n      Global init order:       f6\\n      Poisoned by user:        f7\\n      Container overflow:      fc\\n      Array cookie:            ac\\n      Intra object redzone:    bb\\n      ASan internal:           fe\\n      Left alloca redzone:     ca\\n      Right alloca redzone:    cb\\n      Shadow gap:              cc\\n    ==30==ABORTING\\n\\n\\n**Questions:**\\n1. Why does `SIZE = height` not work in debug mode?\\n2. Why is it `9` or more that I need to add?\\n\\nAny help is much appreciated!"
                    },
                    {
                        "username": "vdsyrocks",
                        "content": "Do level order traversal with a \"prev\" variable "
                    }
                ]
            },
            {
                "id": 1726567,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "gekh",
                        "content": "Why is there no Rust?"
                    },
                    {
                        "username": "thannerusaiharshith",
                        "content": "The hint is to use the level order traversal!"
                    },
                    {
                        "username": "gekh",
                        "content": "thanks"
                    },
                    {
                        "username": "Thakur_aman_cs",
                        "content": "This solution uses a queue to store the nodes at each level of the tree, and iterates through the queue to set the next pointers of the nodes. It starts by adding the root node to the queue, and then iterates through the queue until it is empty. For each node in the queue, it sets the next pointer to the next node in the queue (if it exists), and adds the left and right children of the node to the queue. This ensures that the next pointers are set in a breadth-first order."
                    },
                    {
                        "username": "devKangM",
                        "content": " ```\nvar connect = function(root) {\n    let queue = [root];\n    while (queue.length != 0) {\n        console.log(\"start: \", queue.length)\n        const len = queue.length;\n        let nextQueue = [];\n        for (let i = 0; i < len; i++) {\n            const target = queue.shift();\n            if (target.left) nextQueue.push(target.left);\n            if (target.right) nextQueue.push(target.right);\n            if (i === len-1) target.next = null;\n            else target.next = queue[0];\n        }\n        queue = nextQueue;\n        console.log(\"last: \", queue.length);\n\n    }\n    return root;\n};\n```\n\nstart:  1\nlast:  2\nstart:  2\nlast:  4\nstart:  4\nlast:  0\nstart:  1\n\nhere is my code, and Stdout.\nbut some error happen.\n```\nLine 22 in solution.js\n            if (target.left) nextQueue.push(target.left);\n                       ^\nTypeError: Cannot read properties of null (reading 'left')\n    Line 22: Char 24 in solution.js (connect)\n    Line 94: Char 19 in solution.js (Object.<anonymous>)\n    Line 16: Char 8 in runner.js (Object.runner)\n    Line 33: Char 26 in solution.js (Object.<anonymous>)\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\n    at Module.load (node:internal/modules/cjs/loader:981:32)\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\n```\nIn this case, i got a problem that i can't understand.\nwhy the queue.length became from 0 to 1 like Stdout?\nI can't understand.... help me"
                    },
                    {
                        "username": "shivamgcoder",
                        "content": "simple recursion solution\\nclass Solution:\\n\\tdef connect(self, root: \\'Node\\') -> \\'Node\\':\\n\\t\\tif not root or not root.left:\\n\\t\\t\\treturn root\\n\\t\\troot.left.next=root.right\\n\\t\\tif root.next:\\n\\t\\t\\troot.right.next=root.next.left\\n\\t\\tself.connect(root.left)\\n\\t\\tself.connect(root.right)\\n\\t\\treturn root\\n"
                    },
                    {
                        "username": "AmanJaiSingh",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        queue<Node* > q1;\\n        q1.push(root);\\n        q1.push(NULL);\\n        while(q1.size()>1){\\n            Node* curr=q1.front();\\n            q1.pop();\\n            if(curr==NULL){\\n                q1.push(NULL);\\n                continue;\\n            }\\n            curr->next=q1.front();\\n            if(curr->left) q1.push(curr->left);\\n            if(curr->right) q1.push(curr->right);\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\nwhy this shows runtime error .. it doesnot pop the null why is this happning,.."
                    },
                    {
                        "username": "Ayush142",
                        "content": "Just add boundry condition , it will work fine\\n        if(root==NULL){\\n            return root;\\n        } "
                    },
                    {
                        "username": "conway22",
                        "content": "so the key point is perfect binary tree!!!"
                    },
                    {
                        "username": "matans844",
                        "content": "I tried to write a solution in C (which was accepted), but I had a problem when using dynamic memory allocation in debug vs non-debug mode.\\n\\nI want to maintain a static array of pointers to the yet unconnected TreeNodes in the tail of each row in the given perfect binary tree so that I can use it and update it while traversing the tree in-order. For this, I need the tree height. I can use the problem constraints to find an upper bound for it, `12`, which is good enough. However, I was aiming at a more general solution in which I can also practice dynamic memory allocation.\\n\\nI came up with the following attempt (which was accepted):\\n```\\n/**\\n * Definition for a Node.\\n * struct Node {\\n *     int val;\\n *     struct Node *left;\\n *     struct Node *right;\\n *     struct Node *next;\\n * };\\n */\\n\\nint curr_height = 0;\\nint height = 0;\\nint have_height = 0;\\n\\nstruct Node ** ptr_to_table = NULL;\\n\\nvoid allocate_direct_table(){\\n\\tint SIZE = height + 9;\\n\\tptr_to_table = calloc(SIZE, sizeof(struct Node *));\\n\\n\\tstruct Node * arr[SIZE];\\n\\tfor(int i=0; i<SIZE; i++){\\n\\t\\tarr[i] = NULL;\\n\\t}\\n\\n\\t*ptr_to_table = arr;\\n\\n\\t\\n\\t// ptr_to_table = malloc((height + 1) * sizeof(struct Node *));\\n\\t// memset(ptr_to_table, 0, (height + 1) * sizeof(struct Node *));\\n}\\n\\nvoid process(struct Node* root){\\n\\tint index = curr_height;\\n\\tif(ptr_to_table[index]){\\n\\t\\tptr_to_table[index] -> next = root;\\n\\t}\\n\\tptr_to_table[index] = root;\\n\\troot -> next = NULL;\\n}\\n\\nvoid preprocess(){\\n\\theight = curr_height;\\n\\tallocate_direct_table();\\n}\\n\\nstruct Node* connect(struct Node* root) {\\n\\tif(!root && !have_height){\\n\\t\\tpreprocess();\\n\\t\\thave_height = 1;\\n\\t\\treturn NULL;\\n\\t}\\n\\tif(!root) return NULL;\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> left);\\n\\tcurr_height --;\\n\\n\\tprocess(root);\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> right);\\n\\tcurr_height --;\\n\\n\\treturn root;\\n    \\n}\\n```\\nI found a behavior of this code that I could not explain. It involves the dynamic memory allocation in the `allocate_direct_table()` function: \\n1. When debugging, I can use `SIZE = height`, and everything works.\\n2. When submitting, I get an `AddressSanitizer: heap-buffer-overflow` error, so I have to increase the height. I have no idea why, and I have no idea why `9` is enough. It probably has to do with the problem constraints, which means my solution is not general.\\n\\nHere is the error when submitting the version with `SIZE = height`:\\n\\nProblematic input:\\n\\n    [-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13]\\n\\nRuntime Error:\\n\\n    =================================================================\\n    ==30==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000178 at pc 0x55979bc921c2 bp 0x7ffd997833a0 sp 0x7ffd99783390\\n    READ of size 8 at 0x603000000178 thread T0\\n        #5 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    0x603000000178 is located 0 bytes to the right of 24-byte region [0x603000000160,0x603000000178)\\n    allocated by thread T0 here:\\n        #0 0x7f179ec8bdc6 in calloc (/lib/x86_64-linux-gnu/libasan.so.5+0x10ddc6)\\n        #7 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    Shadow bytes around the buggy address:\\n      0x0c067fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff8000: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8010: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    =>0x0c067fff8020: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00[fa]\\n      0x0c067fff8030: fa fa 00 00 06 fa fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8040: 00 fa fa fa 00 00 00 fa fa fa 00 00 00 00 fa fa\\n      0x0c067fff8050: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00\\n      0x0c067fff8060: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8070: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    Shadow byte legend (one shadow byte represents 8 application bytes):\\n      Addressable:           00\\n      Partially addressable: 01 02 03 04 05 06 07 \\n      Heap left redzone:       fa\\n      Freed heap region:       fd\\n      Stack left redzone:      f1\\n      Stack mid redzone:       f2\\n      Stack right redzone:     f3\\n      Stack after return:      f5\\n      Stack use after scope:   f8\\n      Global redzone:          f9\\n      Global init order:       f6\\n      Poisoned by user:        f7\\n      Container overflow:      fc\\n      Array cookie:            ac\\n      Intra object redzone:    bb\\n      ASan internal:           fe\\n      Left alloca redzone:     ca\\n      Right alloca redzone:    cb\\n      Shadow gap:              cc\\n    ==30==ABORTING\\n\\n\\n**Questions:**\\n1. Why does `SIZE = height` not work in debug mode?\\n2. Why is it `9` or more that I need to add?\\n\\nAny help is much appreciated!"
                    },
                    {
                        "username": "vdsyrocks",
                        "content": "Do level order traversal with a \"prev\" variable "
                    }
                ]
            },
            {
                "id": 1723359,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "gekh",
                        "content": "Why is there no Rust?"
                    },
                    {
                        "username": "thannerusaiharshith",
                        "content": "The hint is to use the level order traversal!"
                    },
                    {
                        "username": "gekh",
                        "content": "thanks"
                    },
                    {
                        "username": "Thakur_aman_cs",
                        "content": "This solution uses a queue to store the nodes at each level of the tree, and iterates through the queue to set the next pointers of the nodes. It starts by adding the root node to the queue, and then iterates through the queue until it is empty. For each node in the queue, it sets the next pointer to the next node in the queue (if it exists), and adds the left and right children of the node to the queue. This ensures that the next pointers are set in a breadth-first order."
                    },
                    {
                        "username": "devKangM",
                        "content": " ```\nvar connect = function(root) {\n    let queue = [root];\n    while (queue.length != 0) {\n        console.log(\"start: \", queue.length)\n        const len = queue.length;\n        let nextQueue = [];\n        for (let i = 0; i < len; i++) {\n            const target = queue.shift();\n            if (target.left) nextQueue.push(target.left);\n            if (target.right) nextQueue.push(target.right);\n            if (i === len-1) target.next = null;\n            else target.next = queue[0];\n        }\n        queue = nextQueue;\n        console.log(\"last: \", queue.length);\n\n    }\n    return root;\n};\n```\n\nstart:  1\nlast:  2\nstart:  2\nlast:  4\nstart:  4\nlast:  0\nstart:  1\n\nhere is my code, and Stdout.\nbut some error happen.\n```\nLine 22 in solution.js\n            if (target.left) nextQueue.push(target.left);\n                       ^\nTypeError: Cannot read properties of null (reading 'left')\n    Line 22: Char 24 in solution.js (connect)\n    Line 94: Char 19 in solution.js (Object.<anonymous>)\n    Line 16: Char 8 in runner.js (Object.runner)\n    Line 33: Char 26 in solution.js (Object.<anonymous>)\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\n    at Module.load (node:internal/modules/cjs/loader:981:32)\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\n```\nIn this case, i got a problem that i can't understand.\nwhy the queue.length became from 0 to 1 like Stdout?\nI can't understand.... help me"
                    },
                    {
                        "username": "shivamgcoder",
                        "content": "simple recursion solution\\nclass Solution:\\n\\tdef connect(self, root: \\'Node\\') -> \\'Node\\':\\n\\t\\tif not root or not root.left:\\n\\t\\t\\treturn root\\n\\t\\troot.left.next=root.right\\n\\t\\tif root.next:\\n\\t\\t\\troot.right.next=root.next.left\\n\\t\\tself.connect(root.left)\\n\\t\\tself.connect(root.right)\\n\\t\\treturn root\\n"
                    },
                    {
                        "username": "AmanJaiSingh",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        queue<Node* > q1;\\n        q1.push(root);\\n        q1.push(NULL);\\n        while(q1.size()>1){\\n            Node* curr=q1.front();\\n            q1.pop();\\n            if(curr==NULL){\\n                q1.push(NULL);\\n                continue;\\n            }\\n            curr->next=q1.front();\\n            if(curr->left) q1.push(curr->left);\\n            if(curr->right) q1.push(curr->right);\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\nwhy this shows runtime error .. it doesnot pop the null why is this happning,.."
                    },
                    {
                        "username": "Ayush142",
                        "content": "Just add boundry condition , it will work fine\\n        if(root==NULL){\\n            return root;\\n        } "
                    },
                    {
                        "username": "conway22",
                        "content": "so the key point is perfect binary tree!!!"
                    },
                    {
                        "username": "matans844",
                        "content": "I tried to write a solution in C (which was accepted), but I had a problem when using dynamic memory allocation in debug vs non-debug mode.\\n\\nI want to maintain a static array of pointers to the yet unconnected TreeNodes in the tail of each row in the given perfect binary tree so that I can use it and update it while traversing the tree in-order. For this, I need the tree height. I can use the problem constraints to find an upper bound for it, `12`, which is good enough. However, I was aiming at a more general solution in which I can also practice dynamic memory allocation.\\n\\nI came up with the following attempt (which was accepted):\\n```\\n/**\\n * Definition for a Node.\\n * struct Node {\\n *     int val;\\n *     struct Node *left;\\n *     struct Node *right;\\n *     struct Node *next;\\n * };\\n */\\n\\nint curr_height = 0;\\nint height = 0;\\nint have_height = 0;\\n\\nstruct Node ** ptr_to_table = NULL;\\n\\nvoid allocate_direct_table(){\\n\\tint SIZE = height + 9;\\n\\tptr_to_table = calloc(SIZE, sizeof(struct Node *));\\n\\n\\tstruct Node * arr[SIZE];\\n\\tfor(int i=0; i<SIZE; i++){\\n\\t\\tarr[i] = NULL;\\n\\t}\\n\\n\\t*ptr_to_table = arr;\\n\\n\\t\\n\\t// ptr_to_table = malloc((height + 1) * sizeof(struct Node *));\\n\\t// memset(ptr_to_table, 0, (height + 1) * sizeof(struct Node *));\\n}\\n\\nvoid process(struct Node* root){\\n\\tint index = curr_height;\\n\\tif(ptr_to_table[index]){\\n\\t\\tptr_to_table[index] -> next = root;\\n\\t}\\n\\tptr_to_table[index] = root;\\n\\troot -> next = NULL;\\n}\\n\\nvoid preprocess(){\\n\\theight = curr_height;\\n\\tallocate_direct_table();\\n}\\n\\nstruct Node* connect(struct Node* root) {\\n\\tif(!root && !have_height){\\n\\t\\tpreprocess();\\n\\t\\thave_height = 1;\\n\\t\\treturn NULL;\\n\\t}\\n\\tif(!root) return NULL;\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> left);\\n\\tcurr_height --;\\n\\n\\tprocess(root);\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> right);\\n\\tcurr_height --;\\n\\n\\treturn root;\\n    \\n}\\n```\\nI found a behavior of this code that I could not explain. It involves the dynamic memory allocation in the `allocate_direct_table()` function: \\n1. When debugging, I can use `SIZE = height`, and everything works.\\n2. When submitting, I get an `AddressSanitizer: heap-buffer-overflow` error, so I have to increase the height. I have no idea why, and I have no idea why `9` is enough. It probably has to do with the problem constraints, which means my solution is not general.\\n\\nHere is the error when submitting the version with `SIZE = height`:\\n\\nProblematic input:\\n\\n    [-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13]\\n\\nRuntime Error:\\n\\n    =================================================================\\n    ==30==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000178 at pc 0x55979bc921c2 bp 0x7ffd997833a0 sp 0x7ffd99783390\\n    READ of size 8 at 0x603000000178 thread T0\\n        #5 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    0x603000000178 is located 0 bytes to the right of 24-byte region [0x603000000160,0x603000000178)\\n    allocated by thread T0 here:\\n        #0 0x7f179ec8bdc6 in calloc (/lib/x86_64-linux-gnu/libasan.so.5+0x10ddc6)\\n        #7 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    Shadow bytes around the buggy address:\\n      0x0c067fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff8000: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8010: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    =>0x0c067fff8020: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00[fa]\\n      0x0c067fff8030: fa fa 00 00 06 fa fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8040: 00 fa fa fa 00 00 00 fa fa fa 00 00 00 00 fa fa\\n      0x0c067fff8050: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00\\n      0x0c067fff8060: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8070: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    Shadow byte legend (one shadow byte represents 8 application bytes):\\n      Addressable:           00\\n      Partially addressable: 01 02 03 04 05 06 07 \\n      Heap left redzone:       fa\\n      Freed heap region:       fd\\n      Stack left redzone:      f1\\n      Stack mid redzone:       f2\\n      Stack right redzone:     f3\\n      Stack after return:      f5\\n      Stack use after scope:   f8\\n      Global redzone:          f9\\n      Global init order:       f6\\n      Poisoned by user:        f7\\n      Container overflow:      fc\\n      Array cookie:            ac\\n      Intra object redzone:    bb\\n      ASan internal:           fe\\n      Left alloca redzone:     ca\\n      Right alloca redzone:    cb\\n      Shadow gap:              cc\\n    ==30==ABORTING\\n\\n\\n**Questions:**\\n1. Why does `SIZE = height` not work in debug mode?\\n2. Why is it `9` or more that I need to add?\\n\\nAny help is much appreciated!"
                    },
                    {
                        "username": "vdsyrocks",
                        "content": "Do level order traversal with a \"prev\" variable "
                    }
                ]
            },
            {
                "id": 1717320,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "gekh",
                        "content": "Why is there no Rust?"
                    },
                    {
                        "username": "thannerusaiharshith",
                        "content": "The hint is to use the level order traversal!"
                    },
                    {
                        "username": "gekh",
                        "content": "thanks"
                    },
                    {
                        "username": "Thakur_aman_cs",
                        "content": "This solution uses a queue to store the nodes at each level of the tree, and iterates through the queue to set the next pointers of the nodes. It starts by adding the root node to the queue, and then iterates through the queue until it is empty. For each node in the queue, it sets the next pointer to the next node in the queue (if it exists), and adds the left and right children of the node to the queue. This ensures that the next pointers are set in a breadth-first order."
                    },
                    {
                        "username": "devKangM",
                        "content": " ```\nvar connect = function(root) {\n    let queue = [root];\n    while (queue.length != 0) {\n        console.log(\"start: \", queue.length)\n        const len = queue.length;\n        let nextQueue = [];\n        for (let i = 0; i < len; i++) {\n            const target = queue.shift();\n            if (target.left) nextQueue.push(target.left);\n            if (target.right) nextQueue.push(target.right);\n            if (i === len-1) target.next = null;\n            else target.next = queue[0];\n        }\n        queue = nextQueue;\n        console.log(\"last: \", queue.length);\n\n    }\n    return root;\n};\n```\n\nstart:  1\nlast:  2\nstart:  2\nlast:  4\nstart:  4\nlast:  0\nstart:  1\n\nhere is my code, and Stdout.\nbut some error happen.\n```\nLine 22 in solution.js\n            if (target.left) nextQueue.push(target.left);\n                       ^\nTypeError: Cannot read properties of null (reading 'left')\n    Line 22: Char 24 in solution.js (connect)\n    Line 94: Char 19 in solution.js (Object.<anonymous>)\n    Line 16: Char 8 in runner.js (Object.runner)\n    Line 33: Char 26 in solution.js (Object.<anonymous>)\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\n    at Module.load (node:internal/modules/cjs/loader:981:32)\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\n```\nIn this case, i got a problem that i can't understand.\nwhy the queue.length became from 0 to 1 like Stdout?\nI can't understand.... help me"
                    },
                    {
                        "username": "shivamgcoder",
                        "content": "simple recursion solution\\nclass Solution:\\n\\tdef connect(self, root: \\'Node\\') -> \\'Node\\':\\n\\t\\tif not root or not root.left:\\n\\t\\t\\treturn root\\n\\t\\troot.left.next=root.right\\n\\t\\tif root.next:\\n\\t\\t\\troot.right.next=root.next.left\\n\\t\\tself.connect(root.left)\\n\\t\\tself.connect(root.right)\\n\\t\\treturn root\\n"
                    },
                    {
                        "username": "AmanJaiSingh",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        queue<Node* > q1;\\n        q1.push(root);\\n        q1.push(NULL);\\n        while(q1.size()>1){\\n            Node* curr=q1.front();\\n            q1.pop();\\n            if(curr==NULL){\\n                q1.push(NULL);\\n                continue;\\n            }\\n            curr->next=q1.front();\\n            if(curr->left) q1.push(curr->left);\\n            if(curr->right) q1.push(curr->right);\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\nwhy this shows runtime error .. it doesnot pop the null why is this happning,.."
                    },
                    {
                        "username": "Ayush142",
                        "content": "Just add boundry condition , it will work fine\\n        if(root==NULL){\\n            return root;\\n        } "
                    },
                    {
                        "username": "conway22",
                        "content": "so the key point is perfect binary tree!!!"
                    },
                    {
                        "username": "matans844",
                        "content": "I tried to write a solution in C (which was accepted), but I had a problem when using dynamic memory allocation in debug vs non-debug mode.\\n\\nI want to maintain a static array of pointers to the yet unconnected TreeNodes in the tail of each row in the given perfect binary tree so that I can use it and update it while traversing the tree in-order. For this, I need the tree height. I can use the problem constraints to find an upper bound for it, `12`, which is good enough. However, I was aiming at a more general solution in which I can also practice dynamic memory allocation.\\n\\nI came up with the following attempt (which was accepted):\\n```\\n/**\\n * Definition for a Node.\\n * struct Node {\\n *     int val;\\n *     struct Node *left;\\n *     struct Node *right;\\n *     struct Node *next;\\n * };\\n */\\n\\nint curr_height = 0;\\nint height = 0;\\nint have_height = 0;\\n\\nstruct Node ** ptr_to_table = NULL;\\n\\nvoid allocate_direct_table(){\\n\\tint SIZE = height + 9;\\n\\tptr_to_table = calloc(SIZE, sizeof(struct Node *));\\n\\n\\tstruct Node * arr[SIZE];\\n\\tfor(int i=0; i<SIZE; i++){\\n\\t\\tarr[i] = NULL;\\n\\t}\\n\\n\\t*ptr_to_table = arr;\\n\\n\\t\\n\\t// ptr_to_table = malloc((height + 1) * sizeof(struct Node *));\\n\\t// memset(ptr_to_table, 0, (height + 1) * sizeof(struct Node *));\\n}\\n\\nvoid process(struct Node* root){\\n\\tint index = curr_height;\\n\\tif(ptr_to_table[index]){\\n\\t\\tptr_to_table[index] -> next = root;\\n\\t}\\n\\tptr_to_table[index] = root;\\n\\troot -> next = NULL;\\n}\\n\\nvoid preprocess(){\\n\\theight = curr_height;\\n\\tallocate_direct_table();\\n}\\n\\nstruct Node* connect(struct Node* root) {\\n\\tif(!root && !have_height){\\n\\t\\tpreprocess();\\n\\t\\thave_height = 1;\\n\\t\\treturn NULL;\\n\\t}\\n\\tif(!root) return NULL;\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> left);\\n\\tcurr_height --;\\n\\n\\tprocess(root);\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> right);\\n\\tcurr_height --;\\n\\n\\treturn root;\\n    \\n}\\n```\\nI found a behavior of this code that I could not explain. It involves the dynamic memory allocation in the `allocate_direct_table()` function: \\n1. When debugging, I can use `SIZE = height`, and everything works.\\n2. When submitting, I get an `AddressSanitizer: heap-buffer-overflow` error, so I have to increase the height. I have no idea why, and I have no idea why `9` is enough. It probably has to do with the problem constraints, which means my solution is not general.\\n\\nHere is the error when submitting the version with `SIZE = height`:\\n\\nProblematic input:\\n\\n    [-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13]\\n\\nRuntime Error:\\n\\n    =================================================================\\n    ==30==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000178 at pc 0x55979bc921c2 bp 0x7ffd997833a0 sp 0x7ffd99783390\\n    READ of size 8 at 0x603000000178 thread T0\\n        #5 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    0x603000000178 is located 0 bytes to the right of 24-byte region [0x603000000160,0x603000000178)\\n    allocated by thread T0 here:\\n        #0 0x7f179ec8bdc6 in calloc (/lib/x86_64-linux-gnu/libasan.so.5+0x10ddc6)\\n        #7 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    Shadow bytes around the buggy address:\\n      0x0c067fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff8000: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8010: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    =>0x0c067fff8020: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00[fa]\\n      0x0c067fff8030: fa fa 00 00 06 fa fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8040: 00 fa fa fa 00 00 00 fa fa fa 00 00 00 00 fa fa\\n      0x0c067fff8050: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00\\n      0x0c067fff8060: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8070: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    Shadow byte legend (one shadow byte represents 8 application bytes):\\n      Addressable:           00\\n      Partially addressable: 01 02 03 04 05 06 07 \\n      Heap left redzone:       fa\\n      Freed heap region:       fd\\n      Stack left redzone:      f1\\n      Stack mid redzone:       f2\\n      Stack right redzone:     f3\\n      Stack after return:      f5\\n      Stack use after scope:   f8\\n      Global redzone:          f9\\n      Global init order:       f6\\n      Poisoned by user:        f7\\n      Container overflow:      fc\\n      Array cookie:            ac\\n      Intra object redzone:    bb\\n      ASan internal:           fe\\n      Left alloca redzone:     ca\\n      Right alloca redzone:    cb\\n      Shadow gap:              cc\\n    ==30==ABORTING\\n\\n\\n**Questions:**\\n1. Why does `SIZE = height` not work in debug mode?\\n2. Why is it `9` or more that I need to add?\\n\\nAny help is much appreciated!"
                    },
                    {
                        "username": "vdsyrocks",
                        "content": "Do level order traversal with a \"prev\" variable "
                    }
                ]
            },
            {
                "id": 1693207,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "gekh",
                        "content": "Why is there no Rust?"
                    },
                    {
                        "username": "thannerusaiharshith",
                        "content": "The hint is to use the level order traversal!"
                    },
                    {
                        "username": "gekh",
                        "content": "thanks"
                    },
                    {
                        "username": "Thakur_aman_cs",
                        "content": "This solution uses a queue to store the nodes at each level of the tree, and iterates through the queue to set the next pointers of the nodes. It starts by adding the root node to the queue, and then iterates through the queue until it is empty. For each node in the queue, it sets the next pointer to the next node in the queue (if it exists), and adds the left and right children of the node to the queue. This ensures that the next pointers are set in a breadth-first order."
                    },
                    {
                        "username": "devKangM",
                        "content": " ```\nvar connect = function(root) {\n    let queue = [root];\n    while (queue.length != 0) {\n        console.log(\"start: \", queue.length)\n        const len = queue.length;\n        let nextQueue = [];\n        for (let i = 0; i < len; i++) {\n            const target = queue.shift();\n            if (target.left) nextQueue.push(target.left);\n            if (target.right) nextQueue.push(target.right);\n            if (i === len-1) target.next = null;\n            else target.next = queue[0];\n        }\n        queue = nextQueue;\n        console.log(\"last: \", queue.length);\n\n    }\n    return root;\n};\n```\n\nstart:  1\nlast:  2\nstart:  2\nlast:  4\nstart:  4\nlast:  0\nstart:  1\n\nhere is my code, and Stdout.\nbut some error happen.\n```\nLine 22 in solution.js\n            if (target.left) nextQueue.push(target.left);\n                       ^\nTypeError: Cannot read properties of null (reading 'left')\n    Line 22: Char 24 in solution.js (connect)\n    Line 94: Char 19 in solution.js (Object.<anonymous>)\n    Line 16: Char 8 in runner.js (Object.runner)\n    Line 33: Char 26 in solution.js (Object.<anonymous>)\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\n    at Module.load (node:internal/modules/cjs/loader:981:32)\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\n```\nIn this case, i got a problem that i can't understand.\nwhy the queue.length became from 0 to 1 like Stdout?\nI can't understand.... help me"
                    },
                    {
                        "username": "shivamgcoder",
                        "content": "simple recursion solution\\nclass Solution:\\n\\tdef connect(self, root: \\'Node\\') -> \\'Node\\':\\n\\t\\tif not root or not root.left:\\n\\t\\t\\treturn root\\n\\t\\troot.left.next=root.right\\n\\t\\tif root.next:\\n\\t\\t\\troot.right.next=root.next.left\\n\\t\\tself.connect(root.left)\\n\\t\\tself.connect(root.right)\\n\\t\\treturn root\\n"
                    },
                    {
                        "username": "AmanJaiSingh",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        queue<Node* > q1;\\n        q1.push(root);\\n        q1.push(NULL);\\n        while(q1.size()>1){\\n            Node* curr=q1.front();\\n            q1.pop();\\n            if(curr==NULL){\\n                q1.push(NULL);\\n                continue;\\n            }\\n            curr->next=q1.front();\\n            if(curr->left) q1.push(curr->left);\\n            if(curr->right) q1.push(curr->right);\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\nwhy this shows runtime error .. it doesnot pop the null why is this happning,.."
                    },
                    {
                        "username": "Ayush142",
                        "content": "Just add boundry condition , it will work fine\\n        if(root==NULL){\\n            return root;\\n        } "
                    },
                    {
                        "username": "conway22",
                        "content": "so the key point is perfect binary tree!!!"
                    },
                    {
                        "username": "matans844",
                        "content": "I tried to write a solution in C (which was accepted), but I had a problem when using dynamic memory allocation in debug vs non-debug mode.\\n\\nI want to maintain a static array of pointers to the yet unconnected TreeNodes in the tail of each row in the given perfect binary tree so that I can use it and update it while traversing the tree in-order. For this, I need the tree height. I can use the problem constraints to find an upper bound for it, `12`, which is good enough. However, I was aiming at a more general solution in which I can also practice dynamic memory allocation.\\n\\nI came up with the following attempt (which was accepted):\\n```\\n/**\\n * Definition for a Node.\\n * struct Node {\\n *     int val;\\n *     struct Node *left;\\n *     struct Node *right;\\n *     struct Node *next;\\n * };\\n */\\n\\nint curr_height = 0;\\nint height = 0;\\nint have_height = 0;\\n\\nstruct Node ** ptr_to_table = NULL;\\n\\nvoid allocate_direct_table(){\\n\\tint SIZE = height + 9;\\n\\tptr_to_table = calloc(SIZE, sizeof(struct Node *));\\n\\n\\tstruct Node * arr[SIZE];\\n\\tfor(int i=0; i<SIZE; i++){\\n\\t\\tarr[i] = NULL;\\n\\t}\\n\\n\\t*ptr_to_table = arr;\\n\\n\\t\\n\\t// ptr_to_table = malloc((height + 1) * sizeof(struct Node *));\\n\\t// memset(ptr_to_table, 0, (height + 1) * sizeof(struct Node *));\\n}\\n\\nvoid process(struct Node* root){\\n\\tint index = curr_height;\\n\\tif(ptr_to_table[index]){\\n\\t\\tptr_to_table[index] -> next = root;\\n\\t}\\n\\tptr_to_table[index] = root;\\n\\troot -> next = NULL;\\n}\\n\\nvoid preprocess(){\\n\\theight = curr_height;\\n\\tallocate_direct_table();\\n}\\n\\nstruct Node* connect(struct Node* root) {\\n\\tif(!root && !have_height){\\n\\t\\tpreprocess();\\n\\t\\thave_height = 1;\\n\\t\\treturn NULL;\\n\\t}\\n\\tif(!root) return NULL;\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> left);\\n\\tcurr_height --;\\n\\n\\tprocess(root);\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> right);\\n\\tcurr_height --;\\n\\n\\treturn root;\\n    \\n}\\n```\\nI found a behavior of this code that I could not explain. It involves the dynamic memory allocation in the `allocate_direct_table()` function: \\n1. When debugging, I can use `SIZE = height`, and everything works.\\n2. When submitting, I get an `AddressSanitizer: heap-buffer-overflow` error, so I have to increase the height. I have no idea why, and I have no idea why `9` is enough. It probably has to do with the problem constraints, which means my solution is not general.\\n\\nHere is the error when submitting the version with `SIZE = height`:\\n\\nProblematic input:\\n\\n    [-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13]\\n\\nRuntime Error:\\n\\n    =================================================================\\n    ==30==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000178 at pc 0x55979bc921c2 bp 0x7ffd997833a0 sp 0x7ffd99783390\\n    READ of size 8 at 0x603000000178 thread T0\\n        #5 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    0x603000000178 is located 0 bytes to the right of 24-byte region [0x603000000160,0x603000000178)\\n    allocated by thread T0 here:\\n        #0 0x7f179ec8bdc6 in calloc (/lib/x86_64-linux-gnu/libasan.so.5+0x10ddc6)\\n        #7 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    Shadow bytes around the buggy address:\\n      0x0c067fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff8000: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8010: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    =>0x0c067fff8020: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00[fa]\\n      0x0c067fff8030: fa fa 00 00 06 fa fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8040: 00 fa fa fa 00 00 00 fa fa fa 00 00 00 00 fa fa\\n      0x0c067fff8050: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00\\n      0x0c067fff8060: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8070: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    Shadow byte legend (one shadow byte represents 8 application bytes):\\n      Addressable:           00\\n      Partially addressable: 01 02 03 04 05 06 07 \\n      Heap left redzone:       fa\\n      Freed heap region:       fd\\n      Stack left redzone:      f1\\n      Stack mid redzone:       f2\\n      Stack right redzone:     f3\\n      Stack after return:      f5\\n      Stack use after scope:   f8\\n      Global redzone:          f9\\n      Global init order:       f6\\n      Poisoned by user:        f7\\n      Container overflow:      fc\\n      Array cookie:            ac\\n      Intra object redzone:    bb\\n      ASan internal:           fe\\n      Left alloca redzone:     ca\\n      Right alloca redzone:    cb\\n      Shadow gap:              cc\\n    ==30==ABORTING\\n\\n\\n**Questions:**\\n1. Why does `SIZE = height` not work in debug mode?\\n2. Why is it `9` or more that I need to add?\\n\\nAny help is much appreciated!"
                    },
                    {
                        "username": "vdsyrocks",
                        "content": "Do level order traversal with a \"prev\" variable "
                    }
                ]
            },
            {
                "id": 1682295,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "gekh",
                        "content": "Why is there no Rust?"
                    },
                    {
                        "username": "thannerusaiharshith",
                        "content": "The hint is to use the level order traversal!"
                    },
                    {
                        "username": "gekh",
                        "content": "thanks"
                    },
                    {
                        "username": "Thakur_aman_cs",
                        "content": "This solution uses a queue to store the nodes at each level of the tree, and iterates through the queue to set the next pointers of the nodes. It starts by adding the root node to the queue, and then iterates through the queue until it is empty. For each node in the queue, it sets the next pointer to the next node in the queue (if it exists), and adds the left and right children of the node to the queue. This ensures that the next pointers are set in a breadth-first order."
                    },
                    {
                        "username": "devKangM",
                        "content": " ```\nvar connect = function(root) {\n    let queue = [root];\n    while (queue.length != 0) {\n        console.log(\"start: \", queue.length)\n        const len = queue.length;\n        let nextQueue = [];\n        for (let i = 0; i < len; i++) {\n            const target = queue.shift();\n            if (target.left) nextQueue.push(target.left);\n            if (target.right) nextQueue.push(target.right);\n            if (i === len-1) target.next = null;\n            else target.next = queue[0];\n        }\n        queue = nextQueue;\n        console.log(\"last: \", queue.length);\n\n    }\n    return root;\n};\n```\n\nstart:  1\nlast:  2\nstart:  2\nlast:  4\nstart:  4\nlast:  0\nstart:  1\n\nhere is my code, and Stdout.\nbut some error happen.\n```\nLine 22 in solution.js\n            if (target.left) nextQueue.push(target.left);\n                       ^\nTypeError: Cannot read properties of null (reading 'left')\n    Line 22: Char 24 in solution.js (connect)\n    Line 94: Char 19 in solution.js (Object.<anonymous>)\n    Line 16: Char 8 in runner.js (Object.runner)\n    Line 33: Char 26 in solution.js (Object.<anonymous>)\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\n    at Module.load (node:internal/modules/cjs/loader:981:32)\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\n```\nIn this case, i got a problem that i can't understand.\nwhy the queue.length became from 0 to 1 like Stdout?\nI can't understand.... help me"
                    },
                    {
                        "username": "shivamgcoder",
                        "content": "simple recursion solution\\nclass Solution:\\n\\tdef connect(self, root: \\'Node\\') -> \\'Node\\':\\n\\t\\tif not root or not root.left:\\n\\t\\t\\treturn root\\n\\t\\troot.left.next=root.right\\n\\t\\tif root.next:\\n\\t\\t\\troot.right.next=root.next.left\\n\\t\\tself.connect(root.left)\\n\\t\\tself.connect(root.right)\\n\\t\\treturn root\\n"
                    },
                    {
                        "username": "AmanJaiSingh",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        queue<Node* > q1;\\n        q1.push(root);\\n        q1.push(NULL);\\n        while(q1.size()>1){\\n            Node* curr=q1.front();\\n            q1.pop();\\n            if(curr==NULL){\\n                q1.push(NULL);\\n                continue;\\n            }\\n            curr->next=q1.front();\\n            if(curr->left) q1.push(curr->left);\\n            if(curr->right) q1.push(curr->right);\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\nwhy this shows runtime error .. it doesnot pop the null why is this happning,.."
                    },
                    {
                        "username": "Ayush142",
                        "content": "Just add boundry condition , it will work fine\\n        if(root==NULL){\\n            return root;\\n        } "
                    },
                    {
                        "username": "conway22",
                        "content": "so the key point is perfect binary tree!!!"
                    },
                    {
                        "username": "matans844",
                        "content": "I tried to write a solution in C (which was accepted), but I had a problem when using dynamic memory allocation in debug vs non-debug mode.\\n\\nI want to maintain a static array of pointers to the yet unconnected TreeNodes in the tail of each row in the given perfect binary tree so that I can use it and update it while traversing the tree in-order. For this, I need the tree height. I can use the problem constraints to find an upper bound for it, `12`, which is good enough. However, I was aiming at a more general solution in which I can also practice dynamic memory allocation.\\n\\nI came up with the following attempt (which was accepted):\\n```\\n/**\\n * Definition for a Node.\\n * struct Node {\\n *     int val;\\n *     struct Node *left;\\n *     struct Node *right;\\n *     struct Node *next;\\n * };\\n */\\n\\nint curr_height = 0;\\nint height = 0;\\nint have_height = 0;\\n\\nstruct Node ** ptr_to_table = NULL;\\n\\nvoid allocate_direct_table(){\\n\\tint SIZE = height + 9;\\n\\tptr_to_table = calloc(SIZE, sizeof(struct Node *));\\n\\n\\tstruct Node * arr[SIZE];\\n\\tfor(int i=0; i<SIZE; i++){\\n\\t\\tarr[i] = NULL;\\n\\t}\\n\\n\\t*ptr_to_table = arr;\\n\\n\\t\\n\\t// ptr_to_table = malloc((height + 1) * sizeof(struct Node *));\\n\\t// memset(ptr_to_table, 0, (height + 1) * sizeof(struct Node *));\\n}\\n\\nvoid process(struct Node* root){\\n\\tint index = curr_height;\\n\\tif(ptr_to_table[index]){\\n\\t\\tptr_to_table[index] -> next = root;\\n\\t}\\n\\tptr_to_table[index] = root;\\n\\troot -> next = NULL;\\n}\\n\\nvoid preprocess(){\\n\\theight = curr_height;\\n\\tallocate_direct_table();\\n}\\n\\nstruct Node* connect(struct Node* root) {\\n\\tif(!root && !have_height){\\n\\t\\tpreprocess();\\n\\t\\thave_height = 1;\\n\\t\\treturn NULL;\\n\\t}\\n\\tif(!root) return NULL;\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> left);\\n\\tcurr_height --;\\n\\n\\tprocess(root);\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> right);\\n\\tcurr_height --;\\n\\n\\treturn root;\\n    \\n}\\n```\\nI found a behavior of this code that I could not explain. It involves the dynamic memory allocation in the `allocate_direct_table()` function: \\n1. When debugging, I can use `SIZE = height`, and everything works.\\n2. When submitting, I get an `AddressSanitizer: heap-buffer-overflow` error, so I have to increase the height. I have no idea why, and I have no idea why `9` is enough. It probably has to do with the problem constraints, which means my solution is not general.\\n\\nHere is the error when submitting the version with `SIZE = height`:\\n\\nProblematic input:\\n\\n    [-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13]\\n\\nRuntime Error:\\n\\n    =================================================================\\n    ==30==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000178 at pc 0x55979bc921c2 bp 0x7ffd997833a0 sp 0x7ffd99783390\\n    READ of size 8 at 0x603000000178 thread T0\\n        #5 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    0x603000000178 is located 0 bytes to the right of 24-byte region [0x603000000160,0x603000000178)\\n    allocated by thread T0 here:\\n        #0 0x7f179ec8bdc6 in calloc (/lib/x86_64-linux-gnu/libasan.so.5+0x10ddc6)\\n        #7 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    Shadow bytes around the buggy address:\\n      0x0c067fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff8000: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8010: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    =>0x0c067fff8020: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00[fa]\\n      0x0c067fff8030: fa fa 00 00 06 fa fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8040: 00 fa fa fa 00 00 00 fa fa fa 00 00 00 00 fa fa\\n      0x0c067fff8050: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00\\n      0x0c067fff8060: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8070: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    Shadow byte legend (one shadow byte represents 8 application bytes):\\n      Addressable:           00\\n      Partially addressable: 01 02 03 04 05 06 07 \\n      Heap left redzone:       fa\\n      Freed heap region:       fd\\n      Stack left redzone:      f1\\n      Stack mid redzone:       f2\\n      Stack right redzone:     f3\\n      Stack after return:      f5\\n      Stack use after scope:   f8\\n      Global redzone:          f9\\n      Global init order:       f6\\n      Poisoned by user:        f7\\n      Container overflow:      fc\\n      Array cookie:            ac\\n      Intra object redzone:    bb\\n      ASan internal:           fe\\n      Left alloca redzone:     ca\\n      Right alloca redzone:    cb\\n      Shadow gap:              cc\\n    ==30==ABORTING\\n\\n\\n**Questions:**\\n1. Why does `SIZE = height` not work in debug mode?\\n2. Why is it `9` or more that I need to add?\\n\\nAny help is much appreciated!"
                    },
                    {
                        "username": "vdsyrocks",
                        "content": "Do level order traversal with a \"prev\" variable "
                    }
                ]
            },
            {
                "id": 1673850,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "gekh",
                        "content": "Why is there no Rust?"
                    },
                    {
                        "username": "thannerusaiharshith",
                        "content": "The hint is to use the level order traversal!"
                    },
                    {
                        "username": "gekh",
                        "content": "thanks"
                    },
                    {
                        "username": "Thakur_aman_cs",
                        "content": "This solution uses a queue to store the nodes at each level of the tree, and iterates through the queue to set the next pointers of the nodes. It starts by adding the root node to the queue, and then iterates through the queue until it is empty. For each node in the queue, it sets the next pointer to the next node in the queue (if it exists), and adds the left and right children of the node to the queue. This ensures that the next pointers are set in a breadth-first order."
                    },
                    {
                        "username": "devKangM",
                        "content": " ```\nvar connect = function(root) {\n    let queue = [root];\n    while (queue.length != 0) {\n        console.log(\"start: \", queue.length)\n        const len = queue.length;\n        let nextQueue = [];\n        for (let i = 0; i < len; i++) {\n            const target = queue.shift();\n            if (target.left) nextQueue.push(target.left);\n            if (target.right) nextQueue.push(target.right);\n            if (i === len-1) target.next = null;\n            else target.next = queue[0];\n        }\n        queue = nextQueue;\n        console.log(\"last: \", queue.length);\n\n    }\n    return root;\n};\n```\n\nstart:  1\nlast:  2\nstart:  2\nlast:  4\nstart:  4\nlast:  0\nstart:  1\n\nhere is my code, and Stdout.\nbut some error happen.\n```\nLine 22 in solution.js\n            if (target.left) nextQueue.push(target.left);\n                       ^\nTypeError: Cannot read properties of null (reading 'left')\n    Line 22: Char 24 in solution.js (connect)\n    Line 94: Char 19 in solution.js (Object.<anonymous>)\n    Line 16: Char 8 in runner.js (Object.runner)\n    Line 33: Char 26 in solution.js (Object.<anonymous>)\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\n    at Module.load (node:internal/modules/cjs/loader:981:32)\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\n```\nIn this case, i got a problem that i can't understand.\nwhy the queue.length became from 0 to 1 like Stdout?\nI can't understand.... help me"
                    },
                    {
                        "username": "shivamgcoder",
                        "content": "simple recursion solution\\nclass Solution:\\n\\tdef connect(self, root: \\'Node\\') -> \\'Node\\':\\n\\t\\tif not root or not root.left:\\n\\t\\t\\treturn root\\n\\t\\troot.left.next=root.right\\n\\t\\tif root.next:\\n\\t\\t\\troot.right.next=root.next.left\\n\\t\\tself.connect(root.left)\\n\\t\\tself.connect(root.right)\\n\\t\\treturn root\\n"
                    },
                    {
                        "username": "AmanJaiSingh",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        queue<Node* > q1;\\n        q1.push(root);\\n        q1.push(NULL);\\n        while(q1.size()>1){\\n            Node* curr=q1.front();\\n            q1.pop();\\n            if(curr==NULL){\\n                q1.push(NULL);\\n                continue;\\n            }\\n            curr->next=q1.front();\\n            if(curr->left) q1.push(curr->left);\\n            if(curr->right) q1.push(curr->right);\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\nwhy this shows runtime error .. it doesnot pop the null why is this happning,.."
                    },
                    {
                        "username": "Ayush142",
                        "content": "Just add boundry condition , it will work fine\\n        if(root==NULL){\\n            return root;\\n        } "
                    },
                    {
                        "username": "conway22",
                        "content": "so the key point is perfect binary tree!!!"
                    },
                    {
                        "username": "matans844",
                        "content": "I tried to write a solution in C (which was accepted), but I had a problem when using dynamic memory allocation in debug vs non-debug mode.\\n\\nI want to maintain a static array of pointers to the yet unconnected TreeNodes in the tail of each row in the given perfect binary tree so that I can use it and update it while traversing the tree in-order. For this, I need the tree height. I can use the problem constraints to find an upper bound for it, `12`, which is good enough. However, I was aiming at a more general solution in which I can also practice dynamic memory allocation.\\n\\nI came up with the following attempt (which was accepted):\\n```\\n/**\\n * Definition for a Node.\\n * struct Node {\\n *     int val;\\n *     struct Node *left;\\n *     struct Node *right;\\n *     struct Node *next;\\n * };\\n */\\n\\nint curr_height = 0;\\nint height = 0;\\nint have_height = 0;\\n\\nstruct Node ** ptr_to_table = NULL;\\n\\nvoid allocate_direct_table(){\\n\\tint SIZE = height + 9;\\n\\tptr_to_table = calloc(SIZE, sizeof(struct Node *));\\n\\n\\tstruct Node * arr[SIZE];\\n\\tfor(int i=0; i<SIZE; i++){\\n\\t\\tarr[i] = NULL;\\n\\t}\\n\\n\\t*ptr_to_table = arr;\\n\\n\\t\\n\\t// ptr_to_table = malloc((height + 1) * sizeof(struct Node *));\\n\\t// memset(ptr_to_table, 0, (height + 1) * sizeof(struct Node *));\\n}\\n\\nvoid process(struct Node* root){\\n\\tint index = curr_height;\\n\\tif(ptr_to_table[index]){\\n\\t\\tptr_to_table[index] -> next = root;\\n\\t}\\n\\tptr_to_table[index] = root;\\n\\troot -> next = NULL;\\n}\\n\\nvoid preprocess(){\\n\\theight = curr_height;\\n\\tallocate_direct_table();\\n}\\n\\nstruct Node* connect(struct Node* root) {\\n\\tif(!root && !have_height){\\n\\t\\tpreprocess();\\n\\t\\thave_height = 1;\\n\\t\\treturn NULL;\\n\\t}\\n\\tif(!root) return NULL;\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> left);\\n\\tcurr_height --;\\n\\n\\tprocess(root);\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> right);\\n\\tcurr_height --;\\n\\n\\treturn root;\\n    \\n}\\n```\\nI found a behavior of this code that I could not explain. It involves the dynamic memory allocation in the `allocate_direct_table()` function: \\n1. When debugging, I can use `SIZE = height`, and everything works.\\n2. When submitting, I get an `AddressSanitizer: heap-buffer-overflow` error, so I have to increase the height. I have no idea why, and I have no idea why `9` is enough. It probably has to do with the problem constraints, which means my solution is not general.\\n\\nHere is the error when submitting the version with `SIZE = height`:\\n\\nProblematic input:\\n\\n    [-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13]\\n\\nRuntime Error:\\n\\n    =================================================================\\n    ==30==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000178 at pc 0x55979bc921c2 bp 0x7ffd997833a0 sp 0x7ffd99783390\\n    READ of size 8 at 0x603000000178 thread T0\\n        #5 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    0x603000000178 is located 0 bytes to the right of 24-byte region [0x603000000160,0x603000000178)\\n    allocated by thread T0 here:\\n        #0 0x7f179ec8bdc6 in calloc (/lib/x86_64-linux-gnu/libasan.so.5+0x10ddc6)\\n        #7 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    Shadow bytes around the buggy address:\\n      0x0c067fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff8000: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8010: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    =>0x0c067fff8020: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00[fa]\\n      0x0c067fff8030: fa fa 00 00 06 fa fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8040: 00 fa fa fa 00 00 00 fa fa fa 00 00 00 00 fa fa\\n      0x0c067fff8050: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00\\n      0x0c067fff8060: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8070: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    Shadow byte legend (one shadow byte represents 8 application bytes):\\n      Addressable:           00\\n      Partially addressable: 01 02 03 04 05 06 07 \\n      Heap left redzone:       fa\\n      Freed heap region:       fd\\n      Stack left redzone:      f1\\n      Stack mid redzone:       f2\\n      Stack right redzone:     f3\\n      Stack after return:      f5\\n      Stack use after scope:   f8\\n      Global redzone:          f9\\n      Global init order:       f6\\n      Poisoned by user:        f7\\n      Container overflow:      fc\\n      Array cookie:            ac\\n      Intra object redzone:    bb\\n      ASan internal:           fe\\n      Left alloca redzone:     ca\\n      Right alloca redzone:    cb\\n      Shadow gap:              cc\\n    ==30==ABORTING\\n\\n\\n**Questions:**\\n1. Why does `SIZE = height` not work in debug mode?\\n2. Why is it `9` or more that I need to add?\\n\\nAny help is much appreciated!"
                    },
                    {
                        "username": "vdsyrocks",
                        "content": "Do level order traversal with a \"prev\" variable "
                    }
                ]
            },
            {
                "id": 1671845,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "gekh",
                        "content": "Why is there no Rust?"
                    },
                    {
                        "username": "thannerusaiharshith",
                        "content": "The hint is to use the level order traversal!"
                    },
                    {
                        "username": "gekh",
                        "content": "thanks"
                    },
                    {
                        "username": "Thakur_aman_cs",
                        "content": "This solution uses a queue to store the nodes at each level of the tree, and iterates through the queue to set the next pointers of the nodes. It starts by adding the root node to the queue, and then iterates through the queue until it is empty. For each node in the queue, it sets the next pointer to the next node in the queue (if it exists), and adds the left and right children of the node to the queue. This ensures that the next pointers are set in a breadth-first order."
                    },
                    {
                        "username": "devKangM",
                        "content": " ```\nvar connect = function(root) {\n    let queue = [root];\n    while (queue.length != 0) {\n        console.log(\"start: \", queue.length)\n        const len = queue.length;\n        let nextQueue = [];\n        for (let i = 0; i < len; i++) {\n            const target = queue.shift();\n            if (target.left) nextQueue.push(target.left);\n            if (target.right) nextQueue.push(target.right);\n            if (i === len-1) target.next = null;\n            else target.next = queue[0];\n        }\n        queue = nextQueue;\n        console.log(\"last: \", queue.length);\n\n    }\n    return root;\n};\n```\n\nstart:  1\nlast:  2\nstart:  2\nlast:  4\nstart:  4\nlast:  0\nstart:  1\n\nhere is my code, and Stdout.\nbut some error happen.\n```\nLine 22 in solution.js\n            if (target.left) nextQueue.push(target.left);\n                       ^\nTypeError: Cannot read properties of null (reading 'left')\n    Line 22: Char 24 in solution.js (connect)\n    Line 94: Char 19 in solution.js (Object.<anonymous>)\n    Line 16: Char 8 in runner.js (Object.runner)\n    Line 33: Char 26 in solution.js (Object.<anonymous>)\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\n    at Module.load (node:internal/modules/cjs/loader:981:32)\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\n```\nIn this case, i got a problem that i can't understand.\nwhy the queue.length became from 0 to 1 like Stdout?\nI can't understand.... help me"
                    },
                    {
                        "username": "shivamgcoder",
                        "content": "simple recursion solution\\nclass Solution:\\n\\tdef connect(self, root: \\'Node\\') -> \\'Node\\':\\n\\t\\tif not root or not root.left:\\n\\t\\t\\treturn root\\n\\t\\troot.left.next=root.right\\n\\t\\tif root.next:\\n\\t\\t\\troot.right.next=root.next.left\\n\\t\\tself.connect(root.left)\\n\\t\\tself.connect(root.right)\\n\\t\\treturn root\\n"
                    },
                    {
                        "username": "AmanJaiSingh",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        queue<Node* > q1;\\n        q1.push(root);\\n        q1.push(NULL);\\n        while(q1.size()>1){\\n            Node* curr=q1.front();\\n            q1.pop();\\n            if(curr==NULL){\\n                q1.push(NULL);\\n                continue;\\n            }\\n            curr->next=q1.front();\\n            if(curr->left) q1.push(curr->left);\\n            if(curr->right) q1.push(curr->right);\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\nwhy this shows runtime error .. it doesnot pop the null why is this happning,.."
                    },
                    {
                        "username": "Ayush142",
                        "content": "Just add boundry condition , it will work fine\\n        if(root==NULL){\\n            return root;\\n        } "
                    },
                    {
                        "username": "conway22",
                        "content": "so the key point is perfect binary tree!!!"
                    },
                    {
                        "username": "matans844",
                        "content": "I tried to write a solution in C (which was accepted), but I had a problem when using dynamic memory allocation in debug vs non-debug mode.\\n\\nI want to maintain a static array of pointers to the yet unconnected TreeNodes in the tail of each row in the given perfect binary tree so that I can use it and update it while traversing the tree in-order. For this, I need the tree height. I can use the problem constraints to find an upper bound for it, `12`, which is good enough. However, I was aiming at a more general solution in which I can also practice dynamic memory allocation.\\n\\nI came up with the following attempt (which was accepted):\\n```\\n/**\\n * Definition for a Node.\\n * struct Node {\\n *     int val;\\n *     struct Node *left;\\n *     struct Node *right;\\n *     struct Node *next;\\n * };\\n */\\n\\nint curr_height = 0;\\nint height = 0;\\nint have_height = 0;\\n\\nstruct Node ** ptr_to_table = NULL;\\n\\nvoid allocate_direct_table(){\\n\\tint SIZE = height + 9;\\n\\tptr_to_table = calloc(SIZE, sizeof(struct Node *));\\n\\n\\tstruct Node * arr[SIZE];\\n\\tfor(int i=0; i<SIZE; i++){\\n\\t\\tarr[i] = NULL;\\n\\t}\\n\\n\\t*ptr_to_table = arr;\\n\\n\\t\\n\\t// ptr_to_table = malloc((height + 1) * sizeof(struct Node *));\\n\\t// memset(ptr_to_table, 0, (height + 1) * sizeof(struct Node *));\\n}\\n\\nvoid process(struct Node* root){\\n\\tint index = curr_height;\\n\\tif(ptr_to_table[index]){\\n\\t\\tptr_to_table[index] -> next = root;\\n\\t}\\n\\tptr_to_table[index] = root;\\n\\troot -> next = NULL;\\n}\\n\\nvoid preprocess(){\\n\\theight = curr_height;\\n\\tallocate_direct_table();\\n}\\n\\nstruct Node* connect(struct Node* root) {\\n\\tif(!root && !have_height){\\n\\t\\tpreprocess();\\n\\t\\thave_height = 1;\\n\\t\\treturn NULL;\\n\\t}\\n\\tif(!root) return NULL;\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> left);\\n\\tcurr_height --;\\n\\n\\tprocess(root);\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> right);\\n\\tcurr_height --;\\n\\n\\treturn root;\\n    \\n}\\n```\\nI found a behavior of this code that I could not explain. It involves the dynamic memory allocation in the `allocate_direct_table()` function: \\n1. When debugging, I can use `SIZE = height`, and everything works.\\n2. When submitting, I get an `AddressSanitizer: heap-buffer-overflow` error, so I have to increase the height. I have no idea why, and I have no idea why `9` is enough. It probably has to do with the problem constraints, which means my solution is not general.\\n\\nHere is the error when submitting the version with `SIZE = height`:\\n\\nProblematic input:\\n\\n    [-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13]\\n\\nRuntime Error:\\n\\n    =================================================================\\n    ==30==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000178 at pc 0x55979bc921c2 bp 0x7ffd997833a0 sp 0x7ffd99783390\\n    READ of size 8 at 0x603000000178 thread T0\\n        #5 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    0x603000000178 is located 0 bytes to the right of 24-byte region [0x603000000160,0x603000000178)\\n    allocated by thread T0 here:\\n        #0 0x7f179ec8bdc6 in calloc (/lib/x86_64-linux-gnu/libasan.so.5+0x10ddc6)\\n        #7 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    Shadow bytes around the buggy address:\\n      0x0c067fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff8000: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8010: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    =>0x0c067fff8020: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00[fa]\\n      0x0c067fff8030: fa fa 00 00 06 fa fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8040: 00 fa fa fa 00 00 00 fa fa fa 00 00 00 00 fa fa\\n      0x0c067fff8050: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00\\n      0x0c067fff8060: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8070: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    Shadow byte legend (one shadow byte represents 8 application bytes):\\n      Addressable:           00\\n      Partially addressable: 01 02 03 04 05 06 07 \\n      Heap left redzone:       fa\\n      Freed heap region:       fd\\n      Stack left redzone:      f1\\n      Stack mid redzone:       f2\\n      Stack right redzone:     f3\\n      Stack after return:      f5\\n      Stack use after scope:   f8\\n      Global redzone:          f9\\n      Global init order:       f6\\n      Poisoned by user:        f7\\n      Container overflow:      fc\\n      Array cookie:            ac\\n      Intra object redzone:    bb\\n      ASan internal:           fe\\n      Left alloca redzone:     ca\\n      Right alloca redzone:    cb\\n      Shadow gap:              cc\\n    ==30==ABORTING\\n\\n\\n**Questions:**\\n1. Why does `SIZE = height` not work in debug mode?\\n2. Why is it `9` or more that I need to add?\\n\\nAny help is much appreciated!"
                    },
                    {
                        "username": "vdsyrocks",
                        "content": "Do level order traversal with a \"prev\" variable "
                    }
                ]
            }
        ]
    }
]