[
    {
        "title": "Promise Time Limit",
        "question_content": "Given an&nbsp;asynchronous function&nbsp;fn&nbsp;and a time t&nbsp;in milliseconds, return&nbsp;a new&nbsp;time limited&nbsp;version of the input function. fn takes arguments provided to the&nbsp;time limited&nbsp;function.\nThe time limited function should follow these rules:\n\n\tIf the fn completes within the time limit of t milliseconds, the time limited function should&nbsp;resolve with the result.\n\tIf the execution of the fn exceeds the time limit, the time limited function should reject with the string \"Time Limit Exceeded\".\n\n&nbsp;\nExample 1:\n\nInput: \nfn = async (n) => { \n&nbsp; await new Promise(res => setTimeout(res, 100)); \n&nbsp; return n * n; \n}\ninputs = [5]\nt = 50\nOutput: {\"rejected\":\"Time Limit Exceeded\",\"time\":50}\nExplanation:\nconst limited = timeLimit(fn, t)\nconst start = performance.now()\nlet result;\ntry {\n&nbsp; &nbsp;const res = await limited(...inputs)\n&nbsp; &nbsp;result = {\"resolved\": res, \"time\": Math.floor(performance.now() - start)};\n} catch (err) {\n&nbsp;  result = {\"rejected\": err, \"time\": Math.floor(performance.now() - start)};\n}\nconsole.log(result) // Output\nThe provided function is set to resolve after 100ms. However, the time limit is set to 50ms. It rejects at t=50ms because the time limit was reached.\n\nExample 2:\n\nInput: \nfn = async (n) => { \n&nbsp; await new Promise(res => setTimeout(res, 100)); \n&nbsp; return n * n; \n}\ninputs = [5]\nt = 150\nOutput: {\"resolved\":25,\"time\":100}\nExplanation:\nThe function resolved 5 * 5 = 25 at t=100ms. The time limit is never reached.\n\nExample 3:\n\nInput: \nfn = async (a, b) => { \n&nbsp; await new Promise(res => setTimeout(res, 120)); \n&nbsp; return a + b; \n}\ninputs = [5,10]\nt = 150\nOutput: {\"resolved\":15,\"time\":120}\nExplanation:\n​​​​The function resolved 5 + 10 = 15 at t=120ms. The time limit is never reached.\n\nExample 4:\n\nInput: \nfn = async () => { \n&nbsp; throw \"Error\";\n}\ninputs = []\nt = 1000\nOutput: {\"rejected\":\"Error\",\"time\":0}\nExplanation:\nThe function immediately throws an error.\n&nbsp;\nConstraints:\n\n\t0 <= inputs.length <= 10\n\t0 <= t <= 1000\n\tfn returns a promise",
        "solutions": [
            {
                "id": 3406548,
                "title": "easy-promise-race-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const originalFnPromise = fn(...args);\\n\\n        const timeoutPromise = new Promise((_, reject) => {\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([originalFnPromise, timeoutPromise]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const originalFnPromise = fn(...args);\\n\\n        const timeoutPromise = new Promise((_, reject) => {\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([originalFnPromise, timeoutPromise]);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3413842,
                "title": "settimeout-within-promise-body",
                "content": "# Approach\\nUse promise and call setTimeout for given time t.\\nThis is async call, next line will be executed just after this  call, if callback is returned before next line completes execution then it will return promise rejection, otherwise promise will resolve regurarly.\\n\\n\\n# Code\\n```\\nvar timeLimit = function(fn, t) {\\n    return async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n            fn(...args).then(resolve, reject);\\n        });\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar timeLimit = function(fn, t) {\\n    return async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n            fn(...args).then(resolve, reject);\\n        });\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529233,
                "title": "promise-real-life-example-dry-run-usecase-o-1-js-ts-beginner-friendly-day12",
                "content": "#Note it will better if you read ***[this post](https://leetcode.com/problems/sleep/discuss/3525419/Promise-oror-Examples-oror-Dry-Run-oror-Usecase-oror-O(1)-oror-JS-and-TS-oror-Beginner-Friendly-oror-Day11)*** before reading this post as its a continuation type of post  \\n***\\n## Problem Summary:\\n* Given an `asynchronous` function fn and a time limit `t` in milliseconds, we need to create a new time-limited version of the input function. \\n* The time-limited function should behave identically to the original function, except that if it takes longer than `t` milliseconds to fulfill, it should reject with the string` \"Time Limit Exceeded\"`.\\n***\\n## Intuition:\\nWe can use a combination of `Promise`, `setTimeout`, and `async/await` to implement the time-limited function. By setting a timeout using `setTimeout`, we can enforce the time limit and reject the promise if it exceeds the specified duration.\\n***\\n## Approach:\\n* Create a wrapper function that takes the original function `fn` and the time limit `t` as parameters.\\n* Within the wrapper function, return an `async` function that accepts any number of arguments using the spread operator `...args`.\\n* Inside the `async` function, create a new `Promise` to handle the `asynchronous` execution.\\n* Use `setTimeout` to set a timer with the time limit `t`. If the timer expires before the promise is resolved, reject the `promise` with the string `\"Time Limit Exceeded\"`.\\n* Call the original function `fn` with the provided arguments `...args` and `await` its completion.\\n* If the function completes before the time limit, resolve the promise with the result.\\n* Return the promise from the `async` function.\\n***\\n## Concepts : \\n### you can refer ***[this post](https://leetcode.com/problems/sleep/discuss/3525419/Promise-oror-Examples-oror-Dry-Run-oror-Usecase-oror-O(1)-oror-JS-and-TS-oror-Beginner-Friendly-oror-Day11)*** it has detailed explanation of these concepts\\n* Asynchronous functions\\n* Promises\\n* setTimeout\\n* async/await\\n***\\n## Solutions: \\n**Javascript Solution:**\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    return new Promise((delayresolve, reject) => {\\n      const timeoutId = setTimeout(() => {\\n        clearTimeout(timeoutId);\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n\\n      fn(...args)\\n        .then((result) => {\\n          clearTimeout(timeoutId);\\n          delayresolve(result);\\n        })\\n        .catch((error) => {\\n          clearTimeout(timeoutId);\\n          reject(error);\\n        });\\n    });\\n  };\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\\n\\n**Typescript Solution:**\\n```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n  return async function (...args: any[]) {\\n    return new Promise((delayresolve, reject) => {\\n      const timeoutId = setTimeout(() => {\\n        clearTimeout(timeoutId);\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n\\n      fn(...args)\\n        .then((result) => {\\n          clearTimeout(timeoutId);\\n          delayresolve(result);\\n        })\\n        .catch((error) => {\\n          clearTimeout(timeoutId);\\n          reject(error);\\n        });\\n    });\\n  };\\n}\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\\n***\\n**Time Complexity: O(fn)\\nSpace Complexity: O(1)**\\n***\\n## Real life Example:\\n```\\nasync function fetchData() {\\n  return new Promise((delayresolve) => {\\n    setTimeout(() => {\\n      delayresolve(\"Data fetched successfully!\");\\n    }, 2000);\\n  });\\n}\\n\\nconst timeLimitedFetchData = timeLimit(fetchData, 1500);\\n\\ntimeLimitedFetchData().then((result) => {\\n  console.log(result);\\n}).catch((error) => {\\n  console.error(error);\\n});\\n```\\n**Now Letsss discuss the flow of the code:** **Less go**\\n* We have an `asynchronous` function `fetchData` that simulates fetching data by returning a `promise` that `resolves` after a delay of `2000` milliseconds.\\n* We create a time-limited version of `fetchData` using `timeLimit` and provide the function and a time limit of `1500` milliseconds.\\n* We call the time-limited function `timeLimitedFetchData` without any arguments.\\n* Inside the time-limited function, a new `promise` is created to handle the `asynchronous` execution.\\n* A timer is set using `setTimeout` for `1500` milliseconds.\\n* The original `fetchData` function is called with no arguments and awaited for its completion.\\n* Since the original function takes `2000` milliseconds to complete, it exceeds the time limit of `1500` milliseconds.\\n* The timer expires, and the `promise` is rejected with the string `\"Time Limit Exceeded\"`.\\n* The rejection is caught in the catch block, and an error message is logged to the console. \\nThat\\'s it you got it!!\\n***\\n*We all have silly questions, so don\\'t be afraid to ask them. I will gladly answer them!!*",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    return new Promise((delayresolve, reject) => {\\n      const timeoutId = setTimeout(() => {\\n        clearTimeout(timeoutId);\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n\\n      fn(...args)\\n        .then((result) => {\\n          clearTimeout(timeoutId);\\n          delayresolve(result);\\n        })\\n        .catch((error) => {\\n          clearTimeout(timeoutId);\\n          reject(error);\\n        });\\n    });\\n  };\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\n```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n  return async function (...args: any[]) {\\n    return new Promise((delayresolve, reject) => {\\n      const timeoutId = setTimeout(() => {\\n        clearTimeout(timeoutId);\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n\\n      fn(...args)\\n        .then((result) => {\\n          clearTimeout(timeoutId);\\n          delayresolve(result);\\n        })\\n        .catch((error) => {\\n          clearTimeout(timeoutId);\\n          reject(error);\\n        });\\n    });\\n  };\\n}\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\n```\\nasync function fetchData() {\\n  return new Promise((delayresolve) => {\\n    setTimeout(() => {\\n      delayresolve(\"Data fetched successfully!\");\\n    }, 2000);\\n  });\\n}\\n\\nconst timeLimitedFetchData = timeLimit(fetchData, 1500);\\n\\ntimeLimitedFetchData().then((result) => {\\n  console.log(result);\\n}).catch((error) => {\\n  console.error(error);\\n});\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529228,
                "title": "detailed-explanation-of-solution-using-promise-in-javascript-promise-race-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n 1.Acc to Problem statement we have function fn returning Promise and  time T.if this function takes larger time than T to resolve then we have to return new Promise which reject after Time T with \"Time Limit Exceeded\" message otherwise we have to return fn.\\n2. That means we have to return that Promise which settles earlier and for this `Promise.race([p1,p2])` is used, where p1 and p2 are promised.\\n3.This method takes list of promises and returns that promise which settles earliar.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n - We will first create original Promise that is return by fn and rejectedPromise that reject after T ms.\\n - Once we have these promises, we will return a promise betweeen these two which settles earliar.\\n# Complexity\\n- Time complexity: O(min(Time taken to settles among all Promises))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n           const originalPromise=fn(...args);\\n           const rejectPromise=new Promise((resolve,reject)=>{setTimeout(()=>{\\n               reject(\"Time Limit Exceeded\")\\n           },t);\\n           });\\n          return Promise.race([originalPromise,rejectPromise]);  \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n           const originalPromise=fn(...args);\\n           const rejectPromise=new Promise((resolve,reject)=>{setTimeout(()=>{\\n               reject(\"Time Limit Exceeded\")\\n           },t);\\n           });\\n          return Promise.race([originalPromise,rejectPromise]);  \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3411232,
                "title": "easy-to-understand-javascript-typescript-begineer-friendly",
                "content": "# Explaination\\nThe Promise.race() method is one of the promise concurrency methods. It\\'s useful when you want the first async task to complete, but do not care about its eventual state (i.e. it can either succeed or fail).\\n\\nIf the iterable contains one or more non-promise values and/or an already settled promise, then Promise.race() will settle to the first of these values found in the iterable.\\n\\n***The Promise.race() static method takes an iterable of promises as input and returns a single Promise. This returned promise settles with the eventual state of the first promise that settles.***\\n\\n### Note\\n***If the iterable contains one or more non-promise value and/or an already settled promise, then Promise.race will settle to the first of these values found in the array:***\\n\\n\\n\\n# Code\\n```TypeScript []\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        const fns = fn(...args);\\n\\n        const p = new Promise((res, rej) => {\\n            setTimeout(() => {\\n                rej(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([fns, p]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\\n```JavaScript []\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const fns = fn(...args);\\n\\n        const p = new Promise((res, rej) => {\\n            setTimeout(() => {\\n                rej(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([fns, p]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```TypeScript []\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        const fns = fn(...args);\\n\\n        const p = new Promise((res, rej) => {\\n            setTimeout(() => {\\n                rej(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([fns, p]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\n```JavaScript []\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const fns = fn(...args);\\n\\n        const p = new Promise((res, rej) => {\\n            setTimeout(() => {\\n                rej(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([fns, p]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4004290,
                "title": "javascript-promises-api-functionality",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAccording to the given problem statement.,\\n->  *if function `fn() executed before the given time period t`, then it\\'s considered that execution is \"**successful**\"*\\n->  *if function `fn() executed after the given time period t`, then it\\'s considered that execution is \"**failed**\"*\\n\\nWe need to implement a normal function execution within the time limit & a rejected function with \"Time limit exceeded\" using Promise constructor.\\n\\n*Why Promise constructor when we can achieve the same using any asynchronous function by throwing an error of \\'time limit exceeded\\'?*\\n\\nTo impose Promise API functionality on the obtained results.\\n\\n> **`Promise.race()`**, which waits only for the first settled promise and gets its result (or error)\\n\\nLet\\'s get it on!\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe timeLimit function takes two arguments an asynchronous function **`fn()`** and a time **`t`** in milliseconds\\n\\nreturn an *`async function`* with arbitrary number of arguments which are passed to **`fn()`**\\n\\n**`fn()`** performs a certain execution operation and to be executed before the **`time limit t`**\\n-   ***cond1*** - a successful function exec., ***funcExec = fn(...args)***\\n-   ***cond2*** - when the time limit is exceeded before the execution of above function, a failed function exec., ***funcRej = new promise((_, reject) => {})***\\n\\nimplement a new Promise constructor\\n```\\nlet funcRej = new Promise((resolve, reject) => {\\n            setTimeout(() => {\\n                reject(\"Time Limit Exceeded\");\\n            }, t)\\n        })\\n```\\nthe constructor returns a rejected promise depending on `t`\\n\\nNow impose a Promise API functionality with **Promise.race()** which takes an array of resolved / rejected promises as parameters\\n**`Promise.race([ ])`**\\n\\nreturn the result \\n```\\nPromise.race([funcExec, funcRej])\\n```\\n\\n`funcExec` *is executed with a result before t milliseconds*\\n`funcRej` *is executed with an error after t milliseconds*\\n# Complexity\\n- **Time complexity :**   $$O(min(funcExecTime, funcRejTime))$$ ~ $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- **Space complexity :**  $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        let funcExec = fn(...args);\\n        let funcRej = new Promise((resolve, reject) => {\\n            setTimeout(() => {\\n                reject(\"Time Limit Exceeded\");\\n            }, t)\\n        })\\n        return Promise.race([funcExec, funcRej])\\n    }\\n};\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet funcRej = new Promise((resolve, reject) => {\\n            setTimeout(() => {\\n                reject(\"Time Limit Exceeded\");\\n            }, t)\\n        })\\n```\n```\\nPromise.race([funcExec, funcRej])\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3465010,
                "title": "double-arrow-function-simple-4-line-of-code",
                "content": "# Code\\n```js\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = (fn, t) => (...args) => new Promise((resolve, reject) => {\\n    setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n    fn(...args).then(resolve).catch(reject);\\n});\\n```\\n\\n# Explanation\\n\\nAn arrow function `var timeLimit = (fn, t) =>` returns another arrow function `(...args) =>` that returns a `Promise`.\\n\\nOn the promise handler, I created *timeout* and on the callback we reject the promise with the message. `setTimeout(() => reject(\"Time Limit Exceeded\"), t);`\\nIf the function doesn\\'t complete within the `t` time, then the callback of *setTimeout* will be called.\\n\\nOn the next line, I called `fn` function with the `...args`. I used spread sytanx. \\nIf the function get done successfully then the `resolve` function will be called. On error `reject` function will be called.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = (fn, t) => (...args) => new Promise((resolve, reject) => {\\n    setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n    fn(...args).then(resolve).catch(reject);\\n});\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3411903,
                "title": "accepted-javascript",
                "content": "```\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return await Promise.race([\\n            new Promise(resolve => resolve(fn(...args))),\\n            new Promise((_, reject) => setTimeout(() => reject(\"Time Limit Exceeded\"), t))\\n        ]);\\n    };\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return await Promise.race([\\n            new Promise(resolve => resolve(fn(...args))),\\n            new Promise((_, reject) => setTimeout(() => reject(\"Time Limit Exceeded\"), t))\\n        ]);\\n    };\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529118,
                "title": "java-script-solution-for-promise-time-limit-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this code is to enforce a time limit on a given function. It wraps the function in a new function that returns a promise. If the wrapped function exceeds the specified time limit, it rejects the promise with a \"Time Limit Exceeded\" error.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The timeLimit function takes two parameters: fn, which is the function to be time-limited, and t, which is the time limit in milliseconds.\\n2. It returns an async function that accepts any number of arguments (...args) and returns a promise.\\n3. Within the returned async function, a new promise is created to handle the time limit.\\n4. A timeout is set using setTimeout, which will reject the promise after t milliseconds if it hasn\\'t been resolved or rejected before that.\\n5. The wrapped function (fn) is invoked with the provided arguments using await.\\n6. If the wrapped function resolves successfully, the result is passed to resolve of the promise created in step 3.\\n7. If an error occurs during the execution of the wrapped function, it is caught, and the promise is rejected with the error.\\n8. Regardless of whether the wrapped function resolves or rejects, the timeout is cleared using clearTimeout to prevent it from triggering after the function has completed.\\n9. The time-limited function returns the promise.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this code is dependent on the time complexity of the wrapped function (fn). The time limit is enforced by setting a timeout, which doesn\\'t affect the time complexity of the wrapped function itself. Therefore, the time complexity of the code can be considered the same as the time complexity of the wrapped function.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this code is determined by the memory required to store the wrapped function and the promise. Since the wrapped function and promise are created within the returned function and not stored outside, the space complexity is minimal and mainly depends on the wrapped function and its internal operations.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    return new Promise(async (resolve, reject) => {\\n      const timeout = setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n\\n      try {\\n        const result = await fn(...args);\\n        resolve(result);\\n      } catch(err) {\\n        reject(err);\\n      }\\n      clearTimeout(timeout);\\n    });\\n  };\\n};\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    return new Promise(async (resolve, reject) => {\\n      const timeout = setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n\\n      try {\\n        const result = await fn(...args);\\n        resolve(result);\\n      } catch(err) {\\n        reject(err);\\n      }\\n      clearTimeout(timeout);\\n    });\\n  };\\n};\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3531308,
                "title": "simple-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis code is designed to make sure a function doesn\\'t take too long to execute by setting a time limit on it. It does this by wrapping the function in a new function that returns a promise. If the wrapped function takes too long to execute, the promise is rejected with an error message that says \"Time Limit Exceeded\".\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The timeLimit function takes two arguments: \"fn\", which is the function to be time-limited, and \"t\", which is the time limit in milliseconds.\\n- It returns a new asynchronous function that can take any number of arguments using the spread syntax (...args) and returns a promise.\\n- Inside the returned async function, a new promise is created to handle the time limit.\\n- A timeout is set using the setTimeout function, which will reject the promise after t milliseconds if it hasn\\'t been resolved or rejected before that.\\n- The wrapped function (fn) is then called with the provided arguments using the \"await\" keyword.\\n- If the wrapped function resolves successfully, its result is passed to the \"resolve\" function of the promise created in step 3.\\n- If an error occurs during the execution of the wrapped function, it is caught, and the promise is rejected with the error.\\n- Regardless of whether the wrapped function resolves or rejects, the timeout is cleared using clearTimeout to prevent it from triggering after the function has completed.\\n- Finally, the time-limited function returns the promise created in step 3.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise(async (resolve, reject) => {\\n        const tt = setTimeout(() => {\\n            reject(\"Time Limit Exceeded\");\\n        }, t);\\n\\n        try {\\n            const result = await fn(...args);\\n            resolve(result);\\n        } catch(err) {\\n            reject(err);\\n        }\\n        clearTimeout(tt);\\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise(async (resolve, reject) => {\\n        const tt = setTimeout(() => {\\n            reject(\"Time Limit Exceeded\");\\n        }, t);\\n\\n        try {\\n            const result = await fn(...args);\\n            resolve(result);\\n        } catch(err) {\\n            reject(err);\\n        }\\n        clearTimeout(tt);\\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3438827,
                "title": "promise-and-settimeout",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen I saw that the return was an asynchronous function, my first thought was to return a promise from this function.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe first thing is, by using the setTimeout function we reject the promise when the given time (``` t ```) has expired, we store the timeout\\'s id for the purpose of clearing the memory. If the promise isn\\'t rejected with the timeout, it\\'s because the time it took to complete the promise of the given function was less than ```t```. Therefore, we simply handle it. Finally, we delete the id of the timeout to clear the memory.\\n\\n\\n# Code\\n```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n    return new Promise((res, rej) => {\\n      const timeoutID = setTimeout(() => rej(\"Time Limit Exceeded\"), t);\\n\\n      fn(...args).then(res).catch(rej).finally(() => {clearTimeout(timeoutID)});\\n    })\\n  }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "``` t ```\n```t```\n```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n    return new Promise((res, rej) => {\\n      const timeoutID = setTimeout(() => rej(\"Time Limit Exceeded\"), t);\\n\\n      fn(...args).then(res).catch(rej).finally(() => {clearTimeout(timeoutID)});\\n    })\\n  }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3414762,
                "title": "easy-simple-javascript-solution",
                "content": "\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const fns=fn(...args);\\n        const p=new Promise((res,rej)=>{\\n            setTimeout(()=>{\\n                rej(\\'Time Limit Exceeded\\')\\n            },t);\\n\\n        })\\n\\n        return Promise.race([fns,p]);\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const fns=fn(...args);\\n        const p=new Promise((res,rej)=>{\\n            setTimeout(()=>{\\n                rej(\\'Time Limit Exceeded\\')\\n            },t);\\n\\n        })\\n\\n        return Promise.race([fns,p]);\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4027403,
                "title": "promise-race-easy-js-solution",
                "content": "# Intuition\\nWe want to create a version of an asynchronous function that has a time limit. If the function completes within the time limit, it should return the result; otherwise, it should reject with a specific message.\\n\\n# Approach\\n1. We define a timeLimit function that takes two parameters: the asynchronous function fn and the time limit t.\\n\\n2. Inside the timeLimit function, we return an asynchronous function that can accept any number of arguments using the ...args syntax.\\n\\n3. We create a promise called myPromise that will resolve with the string \"success\" after a timeout of t milliseconds.\\n\\n4. We use Promise.race() to race two promises: myPromise and the execution of fn(...args).\\n\\n5. If myPromise wins the race (timeout is reached before fn completes), we return a new promise that rejects with the message \"Time Limit Exceeded.\"\\n\\n6. If fn wins the race (completes within the time limit), we return a new promise that resolves with the result obtained from fn.\\n\\n7. This code effectively provides a time-limited version of the input function fn.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const myPromise=new Promise((resolve,reject)=>{\\n            setTimeout(()=>{\\n                resolve(\"success\");\\n            },t)\\n        })\\n        const ans=await Promise.race([myPromise,fn(...args)]);\\n        if(ans==\"success\"){\\n            return new Promise((resolve,reject)=>{\\n                reject(\"Time Limit Exceeded\")\\n            })\\n        }\\n        return new Promise((resolve,reject)=>{\\n            resolve(ans)\\n        })\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const myPromise=new Promise((resolve,reject)=>{\\n            setTimeout(()=>{\\n                resolve(\"success\");\\n            },t)\\n        })\\n        const ans=await Promise.race([myPromise,fn(...args)]);\\n        if(ans==\"success\"){\\n            return new Promise((resolve,reject)=>{\\n                reject(\"Time Limit Exceeded\")\\n            })\\n        }\\n        return new Promise((resolve,reject)=>{\\n            resolve(ans)\\n        })\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3879331,
                "title": "beats-98-20-simple-solution-with-minimal-code",
                "content": "# Intuition\\nThese approach emphasizes achieving **performance with minimal code**.\\n\\n# Approach\\n\\n**1.** First, we create a **new promise, timeoutPromise,** with setTimeout(). If this promise doesn\\'t resolve within the given time limit t, it will reject with the message \"Time Limit Exceeded\".\\n**2.** Call the function **fn(...args)**, which returns a promise.\\n**3.** Use **Promise.race()** to wait for either the result of the asynchronous function or the timeoutPromise to settle. Whichever promise settles first will determine the outcome of the timeLimit function.\\n\\nPlease **Upvote** if you find helpful.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const timeoutPromise = new Promise((resolve,reject) => \\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n        );\\n        return Promise.race([fn(...args), timeoutPromise]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const timeoutPromise = new Promise((resolve,reject) => \\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n        );\\n        return Promise.race([fn(...args), timeoutPromise]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3683659,
                "title": "using-promise",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nusing Promise.race, whichever promise (execution or timeout) resolves or rejects first will determine the outcome of the returned promise\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nnside the returned asynchronous function, Promise.race is used to race between two promises:\\n\\nThe first promise is the execution of fn(...args). This represents the actual execution of the provided function with the given arguments.\\nThe second promise is created using setTimeout and will reject with the message \"Time Limit Exceeded\" after t milliseconds.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the timeLimit function itself is O(1) since it doesn\\'t involve any loops or recursion.\\nThe time complexity of the returned asynchronous function is determined by the time it takes to execute the provided function fn and the timeout duration t. It depends on the implementation of fn and may vary.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the timeLimit function is O(1) since it doesn\\'t create any additional data structures that grow with the input size.\\nThe space complexity of the returned asynchronous function depends on the space complexity of fn and the arguments args passed to it.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async (...args) => {\\n    return Promise.race([\\n        fn(...args),\\n        new Promise((_, rejected) => setTimeout(rejected, t, \"Time Limit Exceeded\"))\\n    ])\\n  };\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async (...args) => {\\n    return Promise.race([\\n        fn(...args),\\n        new Promise((_, rejected) => setTimeout(rejected, t, \"Time Limit Exceeded\"))\\n    ])\\n  };\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3638379,
                "title": "using-promise-race-simple-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUnderstanding problem\\n- call **fn** with (...args)\\n- if **fn** takes more time than the given time(t)\\n    - reject with \"Time limit Exceeded\"  // code -1\\n- else\\n    - return promise response of fn(...args) // code -2\\n    - if **fn** rejects, reject the promise\\n    - if **fn** resolves, resolve the promise\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nFirst approach\\n - how to measure the **fn** running time?\\n - make countdown timer from **t** to **0** ?\\n\\n## buggy code (to understand, can skip)\\n```\\nvar timeLimit = function (fn, t) {\\n  return async function (...args) {\\n    const startTime = performance.now();\\n\\n    const result = await fn(...args);\\n\\n    const endTime = performance.now();\\n    const timeTaken = endTime - startTime;\\n\\n    return new Promise((resolve, reject) => {\\n      if (timeTaken > t) {\\n        reject(\"Time Limit Exceeded\",t);\\n      }\\n\\n      resolve(result);\\n    });\\n  };\\n};\\n```\\nHere we can measure the time of fn but it will await whatever time it takes. If given t=2s but fn takes 10s to execute then we can return result only after 10s. So by this we can understand we need fastest response whichever code( code-1 or code-2) completes first. Therefore make use of Promise.race.\\n\\nSecond approach\\n - use Promise.race\\n - [Promise.race](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race) takes array of promises and returns a single promise whichever settles first. \\n\\n# Complexity\\n- Time complexity: Time complexity of fn\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: Space complexity of fn\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n## using async await\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async (...args) => {\\n    let timeoutId;\\n\\n    const timeoutPromise = new Promise((resolve, reject) => {\\n      timeoutId = setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n    });\\n\\n    try {\\n      const result = await Promise.race([fn(...args), timeoutPromise]);\\n      clearTimeout(timeoutId);\\n      return result;\\n    } catch (error) {\\n      clearTimeout(timeoutId);\\n      throw error;\\n    }\\n  };\\n}\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\\n## Explaination\\nInside this function, we create a timeoutId variable to hold the timer ID.\\n\\nWe create a timeoutPromise using a setTimeout function(code-1), which will reject the promise with the \"Time Limit Exceeded\" message after the specified time t has passed.\\n\\nUsing Promise.race, we wait for either the fn(...args) promise or the timeoutPromise to settle. If fn(...args) completes before the timeout, the result is assigned, and the timeoutId is cleared. Otherwise, if the timeout is reached first, the timeoutPromise rejects with the \"Time Limit Exceeded\" message.\\n\\nIn the catch block, we clear the timeoutId and rethrow the error to maintain consistency with the rejected promise behavior.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar timeLimit = function (fn, t) {\\n  return async function (...args) {\\n    const startTime = performance.now();\\n\\n    const result = await fn(...args);\\n\\n    const endTime = performance.now();\\n    const timeTaken = endTime - startTime;\\n\\n    return new Promise((resolve, reject) => {\\n      if (timeTaken > t) {\\n        reject(\"Time Limit Exceeded\",t);\\n      }\\n\\n      resolve(result);\\n    });\\n  };\\n};\\n```\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async (...args) => {\\n    let timeoutId;\\n\\n    const timeoutPromise = new Promise((resolve, reject) => {\\n      timeoutId = setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n    });\\n\\n    try {\\n      const result = await Promise.race([fn(...args), timeoutPromise]);\\n      clearTimeout(timeoutId);\\n      return result;\\n    } catch (error) {\\n      clearTimeout(timeoutId);\\n      throw error;\\n    }\\n  };\\n}\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529368,
                "title": "easy-to-understand-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n           return Promise.race([fn(...args), new Promise((resolve, reject) => {\\n            setTimeout(() => {reject(\"Time Limit Exceeded\")}, t);\\n        })]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n           return Promise.race([fn(...args), new Promise((resolve, reject) => {\\n            setTimeout(() => {reject(\"Time Limit Exceeded\")}, t);\\n        })]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3407275,
                "title": "effective-js-solution-using-promise-race-with-explanation",
                "content": "\\nThe problem is asking us to write a function that takes an asynchronous function fn and a time limit t, and returns a new version of fn that will reject with the message \"Time Limit Exceeded\" if it takes longer than t milliseconds to complete.\\n\\n\\n# Approach\\nWe can use `Promise.race` to race the original promise returned by fn against a new promise that will reject after t milliseconds if fn hasn\\'t completed yet.\\n\\nIf fn completes before the timeout, the implementation will return the result of fn. However, if the timeout expires before fn completes, the implementation will reject with the message \"Time Limit Exceeded\".\\n\\nWe also keep track of the amount of time elapsed between the start of fn and the completion of the promise (using `Date.now()`), and throw an error if the elapsed time exceeds t. This ensures that our implementation accurately enforces the time limit even if fn takes slightly longer to complete than the specified time limit.\\n\\n# Complexity\\n\\n## Time complexity:\\n\\nThe time complexity of the timeLimited function depends on the time complexity of the fn function passed as an argument. In the worst case, if fn takes longer than the time limit t, the function will have a time complexity of **O(1)**, because it will reject the promise immediately after the timeout expires. If fn completes before the timeout, the time complexity will be the **same as fn**, because it is simply invoking fn with the provided arguments.\\n\\n## Space complexity:\\nThe space complexity of the timeLimited function is constant because the function creates only a few variables to keep track of the timeout and elapsed time, and none of these variables depend on the size of the input.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n     const start = Date.now();\\n     const result = await Promise.race([fn(...args), new Promise((_, reject) => setTimeout(() => reject(\"Time Limit Exceeded\"), t))]);\\n      const elapsed = Date.now() - start;\\n     if (elapsed >= t) {\\n        throw \"Time Limit Exceeded\";\\n    }\\n       return result;\\n  }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n     const start = Date.now();\\n     const result = await Promise.race([fn(...args), new Promise((_, reject) => setTimeout(() => reject(\"Time Limit Exceeded\"), t))]);\\n      const elapsed = Date.now() - start;\\n     if (elapsed >= t) {\\n        throw \"Time Limit Exceeded\";\\n    }\\n       return result;\\n  }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4102368,
                "title": "easy-promise-solution-34-lines-javascript-beats-100",
                "content": "```\\n// Define timeLimit function\\nvar timeLimit = function(fn, t) {\\n    // Return async function\\n    return async function(...args) {\\n        // Call the provided function\\n        const fns = fn(...args);\\n        // Create a promise for timeout\\n        const p = new Promise((res, rej) => {\\n            // Set a timeout for t milliseconds\\n            setTimeout(() => {\\n                // Reject the promise if timeout\\n                rej(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        // Race between function and timeout\\n        return Promise.race([fns, p]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// Define timeLimit function\\nvar timeLimit = function(fn, t) {\\n    // Return async function\\n    return async function(...args) {\\n        // Call the provided function\\n        const fns = fn(...args);\\n        // Create a promise for timeout\\n        const p = new Promise((res, rej) => {\\n            // Set a timeout for t milliseconds\\n            setTimeout(() => {\\n                // Reject the promise if timeout\\n                rej(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        // Race between function and timeout\\n        return Promise.race([fns, p]);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4092683,
                "title": "the-timelimit-function-return-new-async-function-that-can-be-use-as-a-wrapper-around-other-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n    \\n\\treturn async function(...args) {\\n        let funcExec = fn(...args);\\n        let funcRej = new Promise((resolve, reject) => {\\n            setTimeout(() => {\\n                reject(\"Time Limit Exceeded\");\\n            }, t)\\n        })\\n        return Promise.race([funcExec, funcRej])\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n    \\n\\treturn async function(...args) {\\n        let funcExec = fn(...args);\\n        let funcRej = new Promise((resolve, reject) => {\\n            setTimeout(() => {\\n                reject(\"Time Limit Exceeded\");\\n            }, t)\\n        })\\n        return Promise.race([funcExec, funcRej])\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4089503,
                "title": "promise-time-limit",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n      const _execution=fn(...args)\\n      const _timeLimit=new Promise((_,reject)=>{\\n          setTimeout(()=>{\\n              reject(\"Time Limit Exceeded\")\\n          },t)\\n      })\\n      return Promise.race([_execution, _timeLimit])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n      const _execution=fn(...args)\\n      const _timeLimit=new Promise((_,reject)=>{\\n          setTimeout(()=>{\\n              reject(\"Time Limit Exceeded\")\\n          },t)\\n      })\\n      return Promise.race([_execution, _timeLimit])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4087877,
                "title": "promise-time-limit-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n    return async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n            fn(...args).then(resolve, reject);\\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n    return async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n            fn(...args).then(resolve, reject);\\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4077698,
                "title": "the-most-simple-and-single-liner-solution-using-promise",
                "content": "# Intuition\\nConsider 2 methods/promise which ever executes first, return the first executed method.\\n# Approach\\nWe can make the use of Promise.race() to solve the problem. This is exactly what question tryies to make you learn.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return Promise.race([fn(...args), new Promise((res,rej)=>setTimeout(rej,t,\\'Time Limit Exceeded\\'))])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return Promise.race([fn(...args), new Promise((res,rej)=>setTimeout(rej,t,\\'Time Limit Exceeded\\'))])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4061021,
                "title": "easiest-solution",
                "content": "# Approach\\nPromise.race is the best way to solve this. All you need are 2 promise objects, one is result of fn(...args) and second one is called from a timeout function that will wait for t mseconds.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        let promise1 = fn(...args)\\n        let promise2 = new Promise((_,reject)=>{\\n            setTimeout(()=>{\\n                reject(\"Time Limit Exceeded\")\\n            },t)\\n        })\\n        return Promise.race([promise1,promise2])\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        let promise1 = fn(...args)\\n        let promise2 = new Promise((_,reject)=>{\\n            setTimeout(()=>{\\n                reject(\"Time Limit Exceeded\")\\n            },t)\\n        })\\n        return Promise.race([promise1,promise2])\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4041202,
                "title": "await-solution-detailed-explanation-of-javascript-event-loop-beginner-friendly",
                "content": "# Intuition\\nTo start off we know that if we want to have a time limit a `setTimeout` is needed. This `setTimeout` has to reject our promise within time `t`. Why did I know that we need a `Promise`? Well if the words resolve and reject are in the problem description it is then pretty obvious. \\n\\n# Approach\\nThe approach is quite standard: set a timeout, await the data, resolve it, and then reject it if time `t` has elapsed.\\n\\nAdditionally, there are a couple of important considerations. Simply leaving the `setTimeout` as is could potentially result in memory leaks, especially if an infinite loop were to run. Therefore, for each call to the `timeLimit` function, it is essential to ensure that the timeout is cleared.\\n\\nHowever, there is one aspect that might be confusing\\u2014how can `setTimeout` and `fn` seemingly run concurrently in JavaScript, given that it is a single-threaded language? Let me explain why they can.\\n\\nYou see, `fn` is an asynchronous function, and so \"is\" `setTimeout`. But why is `fn` able to execute when `setTimeout` is called first?\\n\\nIf we were to visualize the call stack, it might look like this: `fn` (called second) -> `setTimeout` (called first) -> next line to be executed. So how is it possible?\\n\\nWell that is because `setTimeout` works a little bit differently in the sense that when its called it will execute after `t` seconds and not in the asynchronous callstack (***Queue***) but rather in the normal one (***Stack***). So if `fn` is still calculating after `t` seconds the code in `setTimeout` will execute because it\\'s in the normal call stack and **set** the state or rejected. But what if `fn` finishes in time, what will happen to setTimeout? Well it would \"still\" execute but since we **set** the state of resolved before the time period of `t` to where that part of the call stack will not show up.\\n\\nIn summary, the order of execution may not match the order of function calls, and operations like `setTimeout` and `await` interact within the JavaScript event loop differently to determine the actual execution sequence. Clearing the `timeout` is essential to prevent potential memory leaks.\"\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ because `...args` can have the size of 0 &rarr; n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise(async (resolve, reject) => {\\n            const id = setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n            try {\\n                const res = await fn(...args);\\n                resolve(res);\\n            } catch (err) {\\n                reject(err);\\n            } finally {\\n                clearTimeout(id);\\n            }\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise(async (resolve, reject) => {\\n            const id = setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n            try {\\n                const res = await fn(...args);\\n                resolve(res);\\n            } catch (err) {\\n                reject(err);\\n            } finally {\\n                clearTimeout(id);\\n            }\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4036955,
                "title": "a",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n  const Prmise =  new Promise((a,reject)=>{\\n setTimeout(()=>{\\nreject(\\'Time Limit Exceeded\\')\\n},t)\\n})\\nreturn Promise.race([Prmise, fn(...args)])\\n}}\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n  const Prmise =  new Promise((a,reject)=>{\\n setTimeout(()=>{\\nreject(\\'Time Limit Exceeded\\')\\n},t)\\n})\\nreturn Promise.race([Prmise, fn(...args)])\\n}}\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4035522,
                "title": "multiple-clean-solution-with-explanation",
                "content": "\\n\\n# Explanation\\nThe function is supposed to return a new promise with either resolve or reject based on the provided time. So declare a variable `timeOut` that returns `reject(\"Time Limit Exceeded\")` after the provided time excedeed. If this is executed prior to whatever is returned from `fn(...args)`, promise is resolved with rejected no matter what the returned value of fn is at the later time.\\n\\nOn the other hand, if `fn(...args)` completes executing prior `setTimeout`, promise is considered fulfilled with whatever is returned from it and ignores the reject of `timeOut`.\\n\\n# Why `clearTimeout(timeOut)` on `fn(...args)`?\\nIf the fn(...args) is executed prior to setTimeout, we do not want this setTimeout to execute at latter point even if this doesn\\'t bring any value. We want the process to cancel it once our purpose is met. \\n\\n\\n# Approach 1\\nUsing `.then`\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function (fn, t) {\\n  return async function (...args) {\\n    return new Promise((resolve, reject) => {\\n      const timeOut = setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n\\n      fn(...args)\\n        .then((res) => resolve(res))\\n        .catch((err) => reject(err))\\n        .finally(() => clearTimeout(timeOut));\\n    });\\n  };\\n};\\n```\\n\\n\\n# Approach 2\\nUsing `async await`\\n\\nNote: One of the minor difference is we need to wrap the callback fn `(resolve, reject) => {}` with `async` unlike in `Approach 1`. We could technically have `async` wrapped in `Approach 1` as well but it works without as well.\\n\\n# code\\n```\\n\\nvar timeLimit = function (fn, t) {\\n  return async function (...args) {\\n    return new Promise(async (resolve, reject) => {\\n      const timeOut = setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n\\n      try {\\n        const result = await fn(...args);\\n        resolve(result);\\n      } catch (err) {\\n        reject(err);\\n      } finally {\\n        clearTimeout(timeOut);\\n      }\\n    });\\n  };\\n};\\n\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function (fn, t) {\\n  return async function (...args) {\\n    return new Promise((resolve, reject) => {\\n      const timeOut = setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n\\n      fn(...args)\\n        .then((res) => resolve(res))\\n        .catch((err) => reject(err))\\n        .finally(() => clearTimeout(timeOut));\\n    });\\n  };\\n};\\n```\n```\\n\\nvar timeLimit = function (fn, t) {\\n  return async function (...args) {\\n    return new Promise(async (resolve, reject) => {\\n      const timeOut = setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n\\n      try {\\n        const result = await fn(...args);\\n        resolve(result);\\n      } catch (err) {\\n        reject(err);\\n      } finally {\\n        clearTimeout(timeOut);\\n      }\\n    });\\n  };\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4017259,
                "title": "promise-time-limit-with-ukrainian-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\u0414\\u043B\\u044F \\u0432\\u0438\\u0440\\u0456\\u0448\\u0435\\u043D\\u043D\\u044F \\u0446\\u0456\\u0454\\u0457 \\u0437\\u0430\\u0434\\u0430\\u0447\\u0456 \\u044F \\u0432\\u0438\\u043A\\u043E\\u0440\\u0438\\u0441\\u0442\\u043E\\u0432\\u0443\\u044E \\u043C\\u0435\\u0442\\u043E\\u0434 `race`, \\u044F\\u043A\\u0438\\u0439 \\u043F\\u043E\\u0432\\u0435\\u0440\\u0442\\u0430\\u0454 \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442 \\u043F\\u0435\\u0440\\u0448\\u043E\\u0433\\u043E \\u0432\\u0438\\u0440\\u0456\\u0448\\u0435\\u043D\\u043E\\u0433\\u043E \\u043F\\u0440\\u043E\\u043C\\u0456\\u0441\\u0443.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. \\u0421\\u043F\\u043E\\u0447\\u0430\\u0442\\u043A\\u0443 \\u0441\\u0442\\u0432\\u043E\\u0440\\u044E\\u044E \\u0437\\u043C\\u0456\\u043D\\u043D\\u0443 `originalPromise`, \\u044F\\u043A\\u0430 \\u043F\\u0440\\u0435\\u0434\\u0441\\u0442\\u0430\\u0432\\u043B\\u044F\\u0454 \\u043F\\u0440\\u043E\\u043C\\u0456\\u0441, \\u044F\\u043A\\u0438\\u0439 \\u0431\\u0443\\u0434\\u0435 \\u0432\\u0438\\u0440\\u0456\\u0448\\u0435\\u043D\\u043E \\u0447\\u0435\\u0440\\u0435\\u0437 \\u043F\\u0435\\u0432\\u043D\\u0438\\u0439 \\u043F\\u0440\\u043E\\u043C\\u0456\\u0436\\u043E\\u043A \\u0447\\u0430\\u0441\\u0443.\\n2. \\u041F\\u043E\\u0442\\u0456\\u043C \\u0441\\u0442\\u0432\\u043E\\u0440\\u044E\\u044E \\u0437\\u043C\\u0456\\u043D\\u043D\\u0443 `timeLimiter`, \\u044F\\u043A\\u0430 \\u0432\\u0438\\u043A\\u043E\\u0440\\u0438\\u0441\\u0442\\u043E\\u0432\\u0443\\u0454\\u0442\\u044C\\u0441\\u044F \\u0434\\u043B\\u044F \\u043E\\u0431\\u043C\\u0435\\u0436\\u0435\\u043D\\u043D\\u044F \\u0447\\u0430\\u0441\\u0443 \\u0432\\u0438\\u043A\\u043E\\u043D\\u0430\\u043D\\u043D\\u044F \\u043F\\u0435\\u0440\\u0448\\u043E\\u0433\\u043E \\u043F\\u0440\\u043E\\u043C\\u0456\\u0441\\u0443. \\u041D\\u0430\\u043F\\u0440\\u0438\\u043A\\u043B\\u0430\\u0434, \\u044F\\u043A\\u0449\\u043E \\u043F\\u0435\\u0440\\u0448\\u0438\\u0439 \\u043F\\u0440\\u043E\\u043C\\u0456\\u0441 \\u043D\\u0435 \\u0432\\u0438\\u0440\\u0456\\u0448\\u0443\\u0454\\u0442\\u044C\\u0441\\u044F \\u043F\\u0440\\u043E\\u0442\\u044F\\u0433\\u043E\\u043C 5 \\u0441\\u0435\\u043A\\u0443\\u043D\\u0434, \\u0432\\u0438\\u043A\\u043E\\u043D\\u0443\\u0454\\u0442\\u044C\\u0441\\u044F \\u043F\\u0440\\u043E\\u043C\\u0456\\u0441 `timeLimiter`, \\u044F\\u043A\\u0438\\u0439 \\u043F\\u043E\\u0432\\u0435\\u0440\\u0442\\u0430\\u0454 \\'Time Limit Exceeded\\'.\\n\\n\\n# Code\\n```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        const originalPromise = fn(...args)\\n        const timeLimiter = new Promise((_, reject) => setTimeout(() => reject(\\'Time Limit Exceeded\\'), t))\\n        return Promise.race([originalPromise, timeLimiter])\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        const originalPromise = fn(...args)\\n        const timeLimiter = new Promise((_, reject) => setTimeout(() => reject(\\'Time Limit Exceeded\\'), t))\\n        return Promise.race([originalPromise, timeLimiter])\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4014698,
                "title": "best-of-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n       let funcExec = fn(...args);\\n        let funcRaj = new Promise((resolve, reject) => {\\n            setTimeout(() => {\\n                reject(\"Time Limit Exceeded\");\\n            }, t)\\n        })\\n       return Promise.race([funcExec, funcRaj])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n       let funcExec = fn(...args);\\n        let funcRaj = new Promise((resolve, reject) => {\\n            setTimeout(() => {\\n                reject(\"Time Limit Exceeded\");\\n            }, t)\\n        })\\n       return Promise.race([funcExec, funcRaj])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4011255,
                "title": "solution",
                "content": "```\\r\\nconst timeLimit = (fn, t) => async (...args) => {\\r\\n  const promise1 = Promise.resolve(fn(...args));\\r\\n\\r\\n  const promise2 = new Promise((_, reject) => {\\r\\n    setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\r\\n  });\\r\\n\\r\\n  return Promise.race([promise1, promise2]);\\r\\n};\\r\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\r\\nconst timeLimit = (fn, t) => async (...args) => {\\r\\n  const promise1 = Promise.resolve(fn(...args));\\r\\n\\r\\n  const promise2 = new Promise((_, reject) => {\\r\\n    setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\r\\n  });\\r\\n\\r\\n  return Promise.race([promise1, promise2]);\\r\\n};\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4007367,
                "title": "the-10x-approach-promise-race",
                "content": "# Intuition\\nWhen we want to limit the execution time of a function, a common approach is to race the function against a timer. If the function completes before the timer, it\\'s successful. If the timer completes first, we know the function took too long.\\n\\n# Approach\\n1. We wrap the given function `fn` inside another function that will be returned. This allows us to intercept the arguments and control the execution.\\n2. We create a `timeoutPromise` that will reject after time `t` has passed.\\n3. We use `Promise.race` to race the function against the timeout, which returns the first *settled* promise, rather than the first *fulfilled* promise like in `Promise.any`. (See more @ [mdn](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race#return_value)) If `fn` completes first, its result (or error) will be returned. If the timeout completes first, it will reject with \"Time Limit Exceeded\".\\n\\n# Complexity\\n- Time complexity:\\n  - The time complexity is dependent on the function `fn` that is passed in. The `timeLimit` function itself just adds a constant overhead for setting up the race condition.\\n\\n- Space complexity:\\n  - $$O(1)$$: The space complexity is constant since we are only creating a few promises and not using any data structures that grow with input size.\\n\\n# Code\\n```typescript\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        const timeoutPromise = new Promise((_,reject) => {\\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n        })\\n\\n        return Promise.race([fn(...args), timeoutPromise])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "# Intuition\\nWhen we want to limit the execution time of a function, a common approach is to race the function against a timer. If the function completes before the timer, it\\'s successful. If the timer completes first, we know the function took too long.\\n\\n# Approach\\n1. We wrap the given function `fn` inside another function that will be returned. This allows us to intercept the arguments and control the execution.\\n2. We create a `timeoutPromise` that will reject after time `t` has passed.\\n3. We use `Promise.race` to race the function against the timeout, which returns the first *settled* promise, rather than the first *fulfilled* promise like in `Promise.any`. (See more @ [mdn](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race#return_value)) If `fn` completes first, its result (or error) will be returned. If the timeout completes first, it will reject with \"Time Limit Exceeded\".\\n\\n# Complexity\\n- Time complexity:\\n  - The time complexity is dependent on the function `fn` that is passed in. The `timeLimit` function itself just adds a constant overhead for setting up the race condition.\\n\\n- Space complexity:\\n  - $$O(1)$$: The space complexity is constant since we are only creating a few promises and not using any data structures that grow with input size.\\n\\n# Code\\n```typescript\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        const timeoutPromise = new Promise((_,reject) => {\\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n        })\\n\\n        return Promise.race([fn(...args), timeoutPromise])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3993804,
                "title": "easy-solution",
                "content": "# Code\\n```\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        // Create a promise that calls fn with the given arguments\\n        let fnPromise = fn(...args);\\n        // Create a promise that rejects after t milliseconds\\n        let timeoutPromise = new Promise((_, reject) => setTimeout(reject, t, \"Time Limit Exceeded\"));\\n        // Return a promise that races fn and timeout\\n        return Promise.race([fnPromise, timeoutPromise]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        // Create a promise that calls fn with the given arguments\\n        let fnPromise = fn(...args);\\n        // Create a promise that rejects after t milliseconds\\n        let timeoutPromise = new Promise((_, reject) => setTimeout(reject, t, \"Time Limit Exceeded\"));\\n        // Return a promise that races fn and timeout\\n        return Promise.race([fnPromise, timeoutPromise]);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3984040,
                "title": "js",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nconst timeLimit = function (fn, t) {\\n    return async function (...args) {\\n        return new Promise((res, rej) => {\\n            const timer = setTimeout(() => rej(\\'Time Limit Exceeded\\'), t);\\n\\n            fn(...args)\\n                .then((result) => {\\n                    clearTimeout(timer);\\n                    res(result);\\n                })\\n                .catch((error) => rej(error));\\n        });\\n    };\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nconst timeLimit = function (fn, t) {\\n    return async function (...args) {\\n        return new Promise((res, rej) => {\\n            const timer = setTimeout(() => rej(\\'Time Limit Exceeded\\'), t);\\n\\n            fn(...args)\\n                .then((result) => {\\n                    clearTimeout(timer);\\n                    res(result);\\n                })\\n                .catch((error) => rej(error));\\n        });\\n    };\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3982844,
                "title": "simple-solution-with-promise-race",
                "content": "# What is Promise.race\\n\\n`race()` is a static method of the Promise class that accepts an array of promises and returns the data of first completed promise irrespective of whether it\\'s accepted or rejected.\\n\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nconst timeLimit = (fn, t) => {\\n    return async function (...args) {\\n        // Original Promise Function\\n        const promise = fn(...args);\\n\\n        // Function to reject promise after timeout\\n        const timeOutPromise = new Promise((_, reject) => {\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t);\\n        });\\n\\n        // race method which returns first settled promise data.\\n        return Promise.race([promise, timeOutPromise]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nconst timeLimit = (fn, t) => {\\n    return async function (...args) {\\n        // Original Promise Function\\n        const promise = fn(...args);\\n\\n        // Function to reject promise after timeout\\n        const timeOutPromise = new Promise((_, reject) => {\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t);\\n        });\\n\\n        // race method which returns first settled promise data.\\n        return Promise.race([promise, timeOutPromise]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3978684,
                "title": "2-very-simple-approaches",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const timeLimitPr = new Promise((resolve,reject)=>{\\n            setTimeout(()=>reject(\\'Time Limit Exceeded\\'),t)\\n        })\\n        \\n        return Promise.race([timeLimitPr,fn(...args)]);\\n    }\\n};\\n```\\n```\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve,reject)=>{\\n            setTimeout(()=>reject(\\'Time Limit Exceeded\\'),t)\\n            fn(...args).then(resolve).catch(reject)\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const timeLimitPr = new Promise((resolve,reject)=>{\\n            setTimeout(()=>reject(\\'Time Limit Exceeded\\'),t)\\n        })\\n        \\n        return Promise.race([timeLimitPr,fn(...args)]);\\n    }\\n};\\n```\n```\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve,reject)=>{\\n            setTimeout(()=>reject(\\'Time Limit Exceeded\\'),t)\\n            fn(...args).then(resolve).catch(reject)\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3978018,
                "title": "easy-solution-go-for-it",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {  \\n                const ans = fn(...args);\\n\\n               const p = new Promise((resolve, reject) => { setTimeout(()=> {\\n                reject(\"Time Limit Exceeded\");\\n                 }, t) });\\n\\n                return await Promise.race([p, ans]);\\n  // Both resolve, but promise2 is faster\\n        }\\n        \\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {  \\n                const ans = fn(...args);\\n\\n               const p = new Promise((resolve, reject) => { setTimeout(()=> {\\n                reject(\"Time Limit Exceeded\");\\n                 }, t) });\\n\\n                return await Promise.race([p, ans]);\\n  // Both resolve, but promise2 is faster\\n        }\\n        \\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3950782,
                "title": "settimeout-with-async-await-promise",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNote that you need the try catch block to catch when the `reject()` by setTimeout\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n       return new Promise(async(resolve,reject)=>{\\n            const timeout = setTimeout(()=>{\\n                reject(\\'Time Limit Exceeded\\');\\n            },t);\\n            try{\\n            const result = await fn(...args);\\n            resolve(result);\\n            }catch(e){\\n                reject(e);\\n            }finally{\\n            clearTimeout(timeout);\\n            }\\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n       return new Promise(async(resolve,reject)=>{\\n            const timeout = setTimeout(()=>{\\n                reject(\\'Time Limit Exceeded\\');\\n            },t);\\n            try{\\n            const result = await fn(...args);\\n            resolve(result);\\n            }catch(e){\\n                reject(e);\\n            }finally{\\n            clearTimeout(timeout);\\n            }\\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3944940,
                "title": "js-explanation-with-code",
                "content": "# Intuition\\nUsing Promise, settimeout.\\n\\n# Approach\\nSimplifying, we have to return a rejected promise if the fn function which returns a resolved result does not complete in the given t ms.\\n\\n- we make to promises one with the given functin fn which is a promise function,\\n- other promise is a rejected promise, which gets executed in t ms\\n- Now, we use Promsie.race to see which promise finishes earlier, Promise.race takes input as an array of promises.\\n\\n# Complexity\\n- Time complexity:\\nO(fn)\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nconst timeLimit = (fn,t) => {\\n    return async (...args) => {\\n       const originalPromise = fn(...args);\\n       const rejectPromise = new Promise((resolve, reject) =>{setTimeout(()=>{reject(\"Time Limit Exceeded\")},t)});\\n\\n       return Promise.race([originalPromise, rejectPromise]);\\n    }\\n}\\n\\n\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nconst timeLimit = (fn,t) => {\\n    return async (...args) => {\\n       const originalPromise = fn(...args);\\n       const rejectPromise = new Promise((resolve, reject) =>{setTimeout(()=>{reject(\"Time Limit Exceeded\")},t)});\\n\\n       return Promise.race([originalPromise, rejectPromise]);\\n    }\\n}\\n\\n\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3932697,
                "title": "typescript-race-solution",
                "content": "# Approach\\nWe use *Promise.race* to solve a problem\\n# Complexity\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n            return Promise.race( [\\n                fn( ...args ),\\n                new Promise( ( _, reject ) => setTimeout( () => reject( \\'Time Limit Exceeded\\' ), t ) )\\n            ] )\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n            return Promise.race( [\\n                fn( ...args ),\\n                new Promise( ( _, reject ) => setTimeout( () => reject( \\'Time Limit Exceeded\\' ), t ) )\\n            ] )\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3923944,
                "title": "extremely-simple-typescript-solution",
                "content": "# Code\\n```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nconst timeLimit = (fn: Fn, t: number): Fn => (...args) =>\\n  new Promise((resolve, reject) => {\\n    setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n    fn(...args)\\n      .then(resolve)\\n      .catch(reject);\\n  });\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nconst timeLimit = (fn: Fn, t: number): Fn => (...args) =>\\n  new Promise((resolve, reject) => {\\n    setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n    fn(...args)\\n      .then(resolve)\\n      .catch(reject);\\n  });\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3858244,
                "title": "typescript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\t\\treturn async function(...args:any[]) {\\n            return new Promise(async (resolve,reject)=>{\\n            const timeoutId = setTimeout(() => {\\n             clearTimeout(timeoutId);\\n             reject(\"Time Limit Exceeded\");\\n             }, t);\\n               await fn(...args).then((sol)=>{\\n                 //  clearTimeout(timeoutId);\\n                    resolve(sol);\\n                }).catch((err)=>{\\n                   //clearTimeout(timeoutId);\\n                    reject(err);\\n                });\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\t\\treturn async function(...args:any[]) {\\n            return new Promise(async (resolve,reject)=>{\\n            const timeoutId = setTimeout(() => {\\n             clearTimeout(timeoutId);\\n             reject(\"Time Limit Exceeded\");\\n             }, t);\\n               await fn(...args).then((sol)=>{\\n                 //  clearTimeout(timeoutId);\\n                    resolve(sol);\\n                }).catch((err)=>{\\n                   //clearTimeout(timeoutId);\\n                    reject(err);\\n                });\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3853008,
                "title": "2637-promise-time-limit",
                "content": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const funct = fn(...args);\\n\\n        const timeout = new Promise((_, reject) => {\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([funct, timeout]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const funct = fn(...args);\\n\\n        const timeout = new Promise((_, reject) => {\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([funct, timeout]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3830247,
                "title": "simple-soln-for-timeouts-using-promise-race",
                "content": "# Note \\nPromise.race() is a an method that represents the eventual completion of an very first asynchronous operation either it is fulfilled or rejected. (Already resolved promises are returned first and \\'non-promise\\' values).\\n\\n# Code\\n```\\nconst timeLimit = (fn, time) => {\\n  return (...args)=> {\\n    return Promise.race([\\n      fn(...args),\\n      new Promise((resolve, reject) => {\\n        setTimeout(() => {\\n        reject(\"Time Limit Exceeded\")\\n        }, time);\\n      }),\\n    ]);\\n  };\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst timeLimit = (fn, time) => {\\n  return (...args)=> {\\n    return Promise.race([\\n      fn(...args),\\n      new Promise((resolve, reject) => {\\n        setTimeout(() => {\\n        reject(\"Time Limit Exceeded\")\\n        }, time);\\n      }),\\n    ]);\\n  };\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3819491,
                "title": "this-type-of-qns-wants-you-to-control-the-state-of-the-promise",
                "content": "# Intuition\\nFor such qns never uses async await as they want you to suspend the promise for a time and run functions in parallel. \\nAsync await makes logic sequential and doesnt give you the explicit control over resolve and rejection of the promise, it always return a fullfilled promise once the function call terminates. \\nUsing native promise you can run function in parallel to timeout and then also be able to control which rejects and resolves. \\nIf a fn is faster than timeout  will be first fullfilled as either a resolve/reject otherwise timeout will be fullfilled as a rejection.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((res,rej)=>{\\n            setTimeout(()=>rej(\"Time Limit Exceeded\"),t)    \\n            fn(...args).then(res).catch(rej)                                \\n        })\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((res,rej)=>{\\n            setTimeout(()=>rej(\"Time Limit Exceeded\"),t)    \\n            fn(...args).then(res).catch(rej)                                \\n        })\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3808985,
                "title": "typescript-o-max-t-n-1",
                "content": "# Code\\n```\\ntype Fn = (...params: any[]) => Promise<unknown>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn function(...args) {\\n        return Promise.race([fn(...args), new Promise((resolve, reject) => {\\n            return setTimeout(reject, t, \"Time Limit Exceeded\");\\n        })]);\\n    }\\n};\\n```\\n\\n# Complexity\\n`fn` is denoted as `T(n)`, where `n` is the size of the input.\\n\\n- Time complexity: $$O(max(T(n), 1))$$\\n- Space complexity: $$O(max(T(n), 1))$$",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...params: any[]) => Promise<unknown>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn function(...args) {\\n        return Promise.race([fn(...args), new Promise((resolve, reject) => {\\n            return setTimeout(reject, t, \"Time Limit Exceeded\");\\n        })]);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3805803,
                "title": "typescript-solution-4-lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args): Promise<any> {\\n       return new Promise<any>((resolve, reject) => {\\n            setTimeout(() => reject(\\'Time Limit Exceeded\\'), t);\\n            fn(...args).then(resolve, reject);\\n        }); \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args): Promise<any> {\\n       return new Promise<any>((resolve, reject) => {\\n            setTimeout(() => reject(\\'Time Limit Exceeded\\'), t);\\n            fn(...args).then(resolve, reject);\\n        }); \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3786119,
                "title": "super-easy-and-imp-concept-promise-race",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince the problem requires two distinct conditions to execute and compete with each other on the basis of time so it seems like a good place to use promise.race() .\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDefine the two separate promises - the function acts inherently as a promise when it executes later on in the code.\\nIn the end we use promise.race to return whichever promise that executes first. \\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const promise1 = fn(...args)\\n        const promise2 = new Promise((resolve,reject)=>{\\n            setTimeout(reject,t,\"Time Limit Exceeded\")\\n        })\\n        \\n        return  Promise.race([promise1,promise2])\\n\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const promise1 = fn(...args)\\n        const promise2 = new Promise((resolve,reject)=>{\\n            setTimeout(reject,t,\"Time Limit Exceeded\")\\n        })\\n        \\n        return  Promise.race([promise1,promise2])\\n\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3757854,
                "title": "ts-very-simple-implementation-promise",
                "content": "# Code\\n```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        return new Promise((resolve,reject)=>{\\n            setTimeout(()=>{\\n                reject(\"Time Limit Exceeded\")\\n            },t)\\n            fn(...args).then((result)=>resolve(result)).catch((error)=> reject(error))\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        return new Promise((resolve,reject)=>{\\n            setTimeout(()=>{\\n                reject(\"Time Limit Exceeded\")\\n            },t)\\n            fn(...args).then((result)=>resolve(result)).catch((error)=> reject(error))\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3703511,
                "title": "promise-race-concept",
                "content": "# Intuition\\nBoth of them are promise. Whichever gives outcome first will be run, may it be resolve or reject. \\nWe pass an iterable in the Promise race method.\\nIterable consists of all the promises to check for resolve/reject whichever completes first.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const first = fn(...args);\\n        const second = new Promise((_,reject)=>{\\n            setTimeout(()=>{\\n                reject(\"Time Limit Exceeded\")\\n            }, t)\\n        });\\n        return Promise.race([first, second]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const first = fn(...args);\\n        const second = new Promise((_,reject)=>{\\n            setTimeout(()=>{\\n                reject(\"Time Limit Exceeded\")\\n            }, t)\\n        });\\n        return Promise.race([first, second]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3694266,
                "title": "time-limit-problem-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const FuncPromise = fn(...args);\\n\\n        const prom1 = new Promise((resolve, reject) => {\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([FuncPromise, prom1]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const FuncPromise = fn(...args);\\n\\n        const prom1 = new Promise((resolve, reject) => {\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([FuncPromise, prom1]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3678465,
                "title": "typescript-solution-using-promise-race",
                "content": "# Code\\n```\\ntype AsyncFunction = (...params: any[]) => Promise<any>;\\n\\n// This problem is essentially a race between two conditions:\\n// 1. Timeout function resolves first -> throw error\\n// 2. Original function resolves first -> resolve value\\nfunction timeLimit(fn: AsyncFunction, timeout: number): AsyncFunction {\\n    return async function (...args) {\\n        return Promise.race([\\n            fn(...args),\\n            rejectAfterTime(timeout)\\n        ])\\n    }\\n};\\n\\nfunction rejectAfterTime(timeout: number): Promise<void> {\\n    return new Promise<void>((resolve, reject) => {\\n        setTimeout(() => {\\n            reject(\\'Time Limit Exceeded\\');\\n       }, timeout); \\n    });\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype AsyncFunction = (...params: any[]) => Promise<any>;\\n\\n// This problem is essentially a race between two conditions:\\n// 1. Timeout function resolves first -> throw error\\n// 2. Original function resolves first -> resolve value\\nfunction timeLimit(fn: AsyncFunction, timeout: number): AsyncFunction {\\n    return async function (...args) {\\n        return Promise.race([\\n            fn(...args),\\n            rejectAfterTime(timeout)\\n        ])\\n    }\\n};\\n\\nfunction rejectAfterTime(timeout: number): Promise<void> {\\n    return new Promise<void>((resolve, reject) => {\\n        setTimeout(() => {\\n            reject(\\'Time Limit Exceeded\\');\\n       }, timeout); \\n    });\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3669060,
                "title": "delightful",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nfunction timeLimit(fn, t) {\\n  return async (...args) => {\\n    return Promise.race([\\n        fn(...args),\\n        new Promise((_, rejected) => setTimeout(rejected, t, \"Time Limit Exceeded\"))\\n    ])\\n  };\\n}\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nfunction timeLimit(fn, t) {\\n  return async (...args) => {\\n    return Promise.race([\\n        fn(...args),\\n        new Promise((_, rejected) => setTimeout(rejected, t, \"Time Limit Exceeded\"))\\n    ])\\n  };\\n}\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3652375,
                "title": "solution-using-promise-race",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhere there are 2 async process. whichever completes first we have to get its resp and clear the others. Promise.race([]) helps us with the promise handling for this use case.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimple logic\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        let fnExec = fn(...args);\\n        let timeoutProm = new Promise((res,rej)=>{\\n            setTimeout(()=>rej(\"Time Limit Exceeded\"),t);\\n        });\\n        return Promise.race([fnExec, timeoutProm]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        let fnExec = fn(...args);\\n        let timeoutProm = new Promise((res,rej)=>{\\n            setTimeout(()=>rej(\"Time Limit Exceeded\"),t);\\n        });\\n        return Promise.race([fnExec, timeoutProm]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3597609,
                "title": "js-solution-use-promise-race",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return Promise.race([\\n            new Promise((_, rej) => setTimeout(() => rej(\"Time Limit Exceeded\"), t)), \\n            fn(...args)\\n        ]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return Promise.race([\\n            new Promise((_, rej) => setTimeout(() => rej(\"Time Limit Exceeded\"), t)), \\n            fn(...args)\\n        ]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3597394,
                "title": "promise-time-limit",
                "content": "```\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        \\n        return new Promise((res, rej) => { \\n            setTimeout(() => {\\n               rej(\\'Time Limit Exceeded\\'); \\n            }, t)\\n            \\n            fn(...args)\\n            .then((result) => {\\n                res(result);\\n            })\\n            .catch((error) => {\\n                rej(error)\\n            })\\n        });        \\n    }\\n};```",
                "solutionTags": [],
                "code": "```\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        \\n        return new Promise((res, rej) => { \\n            setTimeout(() => {\\n               rej(\\'Time Limit Exceeded\\'); \\n            }, t)\\n            \\n            fn(...args)\\n            .then((result) => {\\n                res(result);\\n            })\\n            .catch((error) => {\\n                rej(error)\\n            })\\n        });        \\n    }\\n};```",
                "codeTag": "Unknown"
            },
            {
                "id": 3593505,
                "title": "day-12-javascript-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            const timeout = setTimeout(() => { \\n                reject(\"Time Limit Exceeded\"); \\n            }, t);\\n\\n            fn(...args)\\n                .then(resolve)\\n                .catch(reject)\\n                .finally(() => {\\n                    clearTimeout(timeout);\\n                });\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            const timeout = setTimeout(() => { \\n                reject(\"Time Limit Exceeded\"); \\n            }, t);\\n\\n            fn(...args)\\n                .then(resolve)\\n                .catch(reject)\\n                .finally(() => {\\n                    clearTimeout(timeout);\\n                });\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3578751,
                "title": "promise-race-method-javascript",
                "content": "Promise.race is a method that takes an array of promises as input and returns a new promise. It resolves or rejects and stops as soon as the first promise in the input array resolves or rejects.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n    const endsInTimeT = new Promise((resolve, reject) => {    \\n        setTimeout(() => {\\n            reject(\"Time Limit Exceeded\");\\n        }, t+1);\\n    });\\n    \\n\\treturn async function(...args) {\\n        const racePromise = Promise.race([endsInTimeT, fn(...args)]);\\n        return racePromise\\n                .then((result) => { \\n                  return result;\\n                })\\n                .catch((error) => {   \\n                   throw error;\\n                });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n    const endsInTimeT = new Promise((resolve, reject) => {    \\n        setTimeout(() => {\\n            reject(\"Time Limit Exceeded\");\\n        }, t+1);\\n    });\\n    \\n\\treturn async function(...args) {\\n        const racePromise = Promise.race([endsInTimeT, fn(...args)]);\\n        return racePromise\\n                .then((result) => { \\n                  return result;\\n                })\\n                .catch((error) => {   \\n                   throw error;\\n                });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3555466,
                "title": "simple-and-easy-stepwise-explanation-to-understand-core-concept-as-well-as-code-written",
                "content": "Initially I found it difficult to understand the concept hence here is the simplified way of understanding.\\n1. setTimeout takes first parameter as function to execute after the time is completed and second parameter as time to wait before executing the function\\n2. fn(...args) starts executing asynchronously and the function in setTimeout is made to wait until time t gets completed\\n3. Before time out if function gets executed it is resolved else gives rejection\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((res,rej)=>{\\n            setTimeout(()=>rej(\"Time Limit Exceeded\"),t)\\n            fn(...args).then(res).catch(rej)\\n        }\\n        )\\n    }\\n}\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((res,rej)=>{\\n            setTimeout(()=>rej(\"Time Limit Exceeded\"),t)\\n            fn(...args).then(res).catch(rej)\\n        }\\n        )\\n    }\\n}\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3548830,
                "title": "js-easy-solution-async-await-beats-100",
                "content": "```\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    return new Promise(async (resolve, reject) => {\\n      const timeout = setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n\\n      try {\\n        const result = await fn(...args);\\n        resolve(result);\\n      } catch(err) {\\n        reject(err);\\n      }\\n      clearTimeout(timeout);\\n    });\\n  };\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    return new Promise(async (resolve, reject) => {\\n      const timeout = setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n\\n      try {\\n        const result = await fn(...args);\\n        resolve(result);\\n      } catch(err) {\\n        reject(err);\\n      }\\n      clearTimeout(timeout);\\n    });\\n  };\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3543465,
                "title": "javascript-promises-with-comments",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        \\n        //return a promise that..\\n        return new Promise((res, rej) => {\\n            //...rejects as soon as soon as threshold `t` passes.\\n            const timeout = setTimeout(() => rej(`Time Limit Exceeded`),  t);\\n\\n            //...otherwise, resolves or rejects to the value that\\n            //fn resolves or reject to.\\n            fn(...args)\\n            .then(data => {\\n                //fn has resolved, clear the timeout.\\n                clearTimeout(timeout);\\n                res(data);\\n            })\\n            .catch(err => rej(err)); \\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        \\n        //return a promise that..\\n        return new Promise((res, rej) => {\\n            //...rejects as soon as soon as threshold `t` passes.\\n            const timeout = setTimeout(() => rej(`Time Limit Exceeded`),  t);\\n\\n            //...otherwise, resolves or rejects to the value that\\n            //fn resolves or reject to.\\n            fn(...args)\\n            .then(data => {\\n                //fn has resolved, clear the timeout.\\n                clearTimeout(timeout);\\n                res(data);\\n            })\\n            .catch(err => rej(err)); \\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3537709,
                "title": "js-day-12-day-30-two-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    For this Problem i have findout two solutions\\n        1. Using simple promise Callback\\n        2. Using Promise.race (Js inbuilt static method)\\n    This example is about to demonstrate my solution.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. Approach first (Using promise callback)\\n- Return a new Promise with 2 inputs; resolve to continue with our function if everything is fine and reject to stop execution if something is wrong.\\n- Inside the returned promise, declare a timeout  which is a timeout function that will be executed based on input t  \\n    1. If time surpasses t then we return a reject expression with the Time Limit Exceeded string and will be catched in the catch callback function.\\n    2. After timeout we return the eventual function with its parameters (fn(...args)), then we proceed to solution (.then(resolve)), catch any  errors (.catch(reject)) ).\\n\\n---\\n\\n2. Approach Second (Using Promise.race inbuilt method)\\n\\n - The Promise.race() static method takes an iterable of promises as input and returns a single Promise. This returned promise settles with the eventual state of the first promise that settles(even Promise resolved or rejected)\\n    1. Return both inputs (function and the timelimit) inside Promise.race.\\n    2. So promise.race returns the first settled promise. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(t)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\n1. 1st Approach(Using Promise Callback)\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            setTimeout(()=>  reject(\\'Time Limit Exceeded\\'),t);\\n\\n             fn(...args)\\n             .then( resolve)\\n             .catch( reject)\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n\\n\\n---\\n2. 2nd Approach (Using Promise. race)\\n\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        \\n       return Promise.race([fn(...args), new Promise((res,rej) => setTimeout(()=>rej(\"Time Limit Exceeded\"),t))])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n1. 1st Approach(Using Promise Callback)\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            setTimeout(()=>  reject(\\'Time Limit Exceeded\\'),t);\\n\\n             fn(...args)\\n             .then( resolve)\\n             .catch( reject)\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n\\n\\n---\\n2. 2nd Approach (Using Promise. race)\\n\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        \\n       return Promise.race([fn(...args), new Promise((res,rej) => setTimeout(()=>rej(\"Time Limit Exceeded\"),t))])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3535424,
                "title": "promise-time-limit-problem",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            const timeout = setTimeout(() => {\\n                clearTimeout(timeout);\\n                reject(\"Time Limit Exceeded\");\\n            }, t);\\n\\n            fn(...args).then((result) => {\\n                clearTimeout(timeout);\\n                resolve(result);\\n            }).catch((error) => {\\n                clearTimeout(timeout);\\n                reject(error);\\n            });\\n        });\\n    }\\n};\\n\\n/**\\n * let limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            const timeout = setTimeout(() => {\\n                clearTimeout(timeout);\\n                reject(\"Time Limit Exceeded\");\\n            }, t);\\n\\n            fn(...args).then((result) => {\\n                clearTimeout(timeout);\\n                resolve(result);\\n            }).catch((error) => {\\n                clearTimeout(timeout);\\n                reject(error);\\n            });\\n        });\\n    }\\n};\\n\\n/**\\n * let limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3534588,
                "title": "sol-n-javascript-typescript-easy",
                "content": "# Revised Approach\\n\\nTo create a time-limited version of an asynchronous function, we can make use of the Promise.race() method. We\\'ll create a new Promise that rejects with the string \"Time Limit Exceeded\" after the specified time limit. We\\'ll also invoke the original function and return the result of the Promise.race() method, which will either be the resolved value of the original function or the rejected value indicating the time limit was exceeded.\\n\\n# Complexity Analysis\\n\\nThe time complexity is dependent on the execution time of the original function. If the original function resolves or rejects within the time limit, the time complexity will be determined by the original function. Otherwise, it will be determined by the time limit.\\n\\nThe space complexity is constant as we\\'re not using any additional data structures that scale with the input size.\\n\\n# Code\\n\\n```javascript\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n  return async function (...args: any[]): Promise<any> {\\n    const fns = fn(...args);\\n    const timeLimitPromise = new Promise((_, reject) => {\\n      setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n    });\\n\\n    return Promise.race([fns, timeLimitPromise]);\\n  };\\n}\\n```\\n\\n",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```javascript\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n  return async function (...args: any[]): Promise<any> {\\n    const fns = fn(...args);\\n    const timeLimitPromise = new Promise((_, reject) => {\\n      setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n    });\\n\\n    return Promise.race([fns, timeLimitPromise]);\\n  };\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3533947,
                "title": "javascript-code-only",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const fns = fn(...args);\\n\\n        const p = new Promise((res, rej) => {\\n            setTimeout(() => {\\n                rej(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([fns, p]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const fns = fn(...args);\\n\\n        const p = new Promise((res, rej) => {\\n            setTimeout(() => {\\n                rej(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([fns, p]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3533778,
                "title": "beats-99-js-ts-promises-promise-time-limit-easy-solution-with-explanation",
                "content": "![image.png](https://assets.leetcode.com/users/images/12bd08fc-832a-41a0-9840-1bd0f7c8af74_1684310493.7335916.png)\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI was thinking about using Promises, like everyone else. This example is about to demonstrate my solution.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Return a new `Promise` with 2 inputs; `resolve` to continue with our function if everything is fine and `reject` to stop execution if something is wrong.\\n    - Inside the returned promise, declare a `timeout` variable which is a timeout that will be executed based on time delay (if we have surpassed `t`) as we specify below.\\n    - If time surpasses `t` then we return a `reject` expression with the `Time Limit Exceeded` string.\\n    - After `timeout` we return the eventual function with its parameters (`fn(...a)`), then we proceed to solution (`.then(resolve)`), catch any potential errors (`.catch(reject)`) and finally clear `timeout` (`finally(() => clearTimeout(timeout))`).\\n\\n# Complexity\\n- Time complexity: `O(1)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n`JavaScript`\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            const timeout = setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\'); }, t);\\n            fn(...args).then(resolve).catch(reject).finally(() => clearTimeout(timeout));\\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\\n\\n`TypeScript`\\n```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            const timeout = setTimeout(() => { reject(\\'Time Limit Exceeded\\');}, t)\\n            fn(...args).then(resolve).catch(reject).finally(() => clearTimeout(timeout));\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\\n\\n# Feedback\\nI would appreciate your feedback and would like to receive your comments and perspectives regarding my approach. I would also enjoy suggestions about how to hone my DSA skills because I am very new to this sector and it\\'s challenging at first. Thanks a lot!",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            const timeout = setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\'); }, t);\\n            fn(...args).then(resolve).catch(reject).finally(() => clearTimeout(timeout));\\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\n```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            const timeout = setTimeout(() => { reject(\\'Time Limit Exceeded\\');}, t)\\n            fn(...args).then(resolve).catch(reject).finally(() => clearTimeout(timeout));\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3533059,
                "title": "using-promise-race-with-formatted-promise-s-responses",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const handlePromise = async (fn, fnName) => {\\n            try {\\n                const value = await fn(...args);\\n                return { fnName, state: \\'resolved\\', value };\\n            } catch (err) {\\n                return { fnName, state: \\'rejected\\', err };\\n            }\\n        }\\n\\n        const timedFn = async() => {\\n            await new Promise((res, rej) => {\\n                try {\\n                    setTimeout(res, t);\\n                }catch (err) {\\n                    rej(\\'Something went wrong.\\');\\n                }\\n            });\\n        }\\n\\n        const result = await Promise.race([handlePromise(fn, \\'fn\\'), handlePromise(timedFn, \\'timedFn\\')]);\\n\\n        if(result.fnName === \\'timedFn\\' && result.state === \\'resolved\\') {\\n            return Promise.reject(\\'Time Limit Exceeded\\');\\n        }\\n        \\n        if(result.fnName === \\'fn\\' && result.state === \\'resolved\\') {\\n            return Promise.resolve(result.value);\\n        }\\n\\n        return Promise.reject(result.err);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const handlePromise = async (fn, fnName) => {\\n            try {\\n                const value = await fn(...args);\\n                return { fnName, state: \\'resolved\\', value };\\n            } catch (err) {\\n                return { fnName, state: \\'rejected\\', err };\\n            }\\n        }\\n\\n        const timedFn = async() => {\\n            await new Promise((res, rej) => {\\n                try {\\n                    setTimeout(res, t);\\n                }catch (err) {\\n                    rej(\\'Something went wrong.\\');\\n                }\\n            });\\n        }\\n\\n        const result = await Promise.race([handlePromise(fn, \\'fn\\'), handlePromise(timedFn, \\'timedFn\\')]);\\n\\n        if(result.fnName === \\'timedFn\\' && result.state === \\'resolved\\') {\\n            return Promise.reject(\\'Time Limit Exceeded\\');\\n        }\\n        \\n        if(result.fnName === \\'fn\\' && result.state === \\'resolved\\') {\\n            return Promise.resolve(result.value);\\n        }\\n\\n        return Promise.reject(result.err);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3532549,
                "title": "creating-a-time-limited-version-of-an-asynchronous-function",
                "content": "# Intuition\\nThe goal is to create a time-limited version of an asynchronous function, where if the function takes longer than the specified time limit to fulfill, it rejects with a \"Time Limit Exceeded\" message.\\n\\n# Approach\\n1. The timeLimited function takes two arguments: fn, the original asynchronous function, and t, the time limit in milliseconds.\\n2. It returns a new function that acts as the time-limited version of fn.\\n3. Inside the new function, the original function fn is called with the provided arguments using the spread operator (...args), and its promise is stored in the promise variable.\\n4. A new promise timeoutPromise is created using the setTimeout function. If the timeout expires before the original function completes, the promise is rejected with the message \"Time Limit Exceeded\".\\n5. The Promise.race method is used to wait for either the original function\\'s promise or the timeout promise to settle. The settled promise (either resolved or rejected) will be returned.\\n6. If the original function completes before the timeout, its promise will resolve first, and the overall promise will resolve with the result.\\n7. If the timeout expires before the original function completes, the timeout promise will reject first, and the overall promise will reject with the \"Time Limit Exceeded\" message.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const promise = fn(...args);\\n        const timeoutPromise = new Promise((resolve, reject) => {\\n          setTimeout(() => {\\n            reject(\"Time Limit Exceeded\");\\n          }, t);\\n        });\\n        return Promise.race([promise, timeoutPromise]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const promise = fn(...args);\\n        const timeoutPromise = new Promise((resolve, reject) => {\\n          setTimeout(() => {\\n            reject(\"Time Limit Exceeded\");\\n          }, t);\\n        });\\n        return Promise.race([promise, timeoutPromise]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3532293,
                "title": "javascript-solution-with-return-await-new-promise",
                "content": "# Intuition\\nfllow the hints ;P\\n# Approach\\ncreate a new promise that you have to return and await. inside it start a timer that rejects when it is reached. Call the function and resolve/reject in the then/catch clause\\n\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\n\\treturn async function(...args) {\\n        return await new Promise((resolve, reject) => {\\n            setTimeout(()=> {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t)   \\n            fn(...args)\\n                .then((val) => resolve(val))\\n                .catch(reject)\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\n\\treturn async function(...args) {\\n        return await new Promise((resolve, reject) => {\\n            setTimeout(()=> {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t)   \\n            fn(...args)\\n                .then((val) => resolve(val))\\n                .catch(reject)\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3532006,
                "title": "javascript-easy-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        \\n        return new Promise((resolve, reject)=>{\\n           \\n           setTimeout(()=>reject(\"Time Limit Exceeded\"),t);\\n           \\n           fn(...args)\\n            .then((res) => resolve(res))\\n            .catch((err) => reject(err))\\n           \\n\\n        })\\n        \\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        \\n        return new Promise((resolve, reject)=>{\\n           \\n           setTimeout(()=>reject(\"Time Limit Exceeded\"),t);\\n           \\n           fn(...args)\\n            .then((res) => resolve(res))\\n            .catch((err) => reject(err))\\n           \\n\\n        })\\n        \\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3531960,
                "title": "simple-explanation-of-solution-javascript-typescript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn simpler terms, the problem is asking for a function that takes another function, and a time limit as inputs. The function should return a new function that, when called, will execute the provided function with the given arguments. However, if the execution takes longer than the specified time limit, the new function should reject the promise instead of resolving it.\\n\\nTo achieve this, we need to utilize a concept called `Promise.race()`. This concept allows us to create a race between multiple promises, and the first promise to either resolve or reject will determine the outcome of the race. In our case, we want to race between the execution of the function and a timeout promise.\\n\\nSo, the goal is to create a time-limited version of a function that either returns the resolved value within the specified time or rejects the promise with a timeout message if it exceeds the time limit.\\n\\n---\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn this code, the `timeLimit` function takes an asynchronous function `fn` and a time limit `t` in milliseconds as arguments. It returns a new function that uses Promise.race to race between the `fn() promise` and a `timeout promise` created using setTimeout.\\n\\nIf `fn()` fulfills before the timeout occurs, the timeLimited function resolves with the same value. However, if `fn()` takes longer than t milliseconds to `fulfill`, the timeout promise will `reject` with the message `Time Limit Exceeded`.\\n\\n---\\n\\n# Code\\n```javascript []\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n\\n        const functionPromise = fn(...args)\\n        const timePromise = new Promise((_, reject) => {\\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n        })\\n\\n        return Promise.race([functionPromise, timePromise])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\\n```typescript []\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\n\\treturn async function(...args) {\\n        const functionPromise = fn(...args)\\n        const timePromise = new Promise((_, reject) => {\\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n        })\\n\\n        return Promise.race([functionPromise, timePromise])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```javascript []\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n\\n        const functionPromise = fn(...args)\\n        const timePromise = new Promise((_, reject) => {\\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n        })\\n\\n        return Promise.race([functionPromise, timePromise])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\n```typescript []\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\n\\treturn async function(...args) {\\n        const functionPromise = fn(...args)\\n        const timePromise = new Promise((_, reject) => {\\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n        })\\n\\n        return Promise.race([functionPromise, timePromise])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3531840,
                "title": "promise-pool-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    const timeLimitPromise = new Promise((resolve, reject) => {\\n      setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n    });\\n    const returnedPromise = fn(...args);\\n    return Promise.race([timeLimitPromise, returnedPromise]);\\n  }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    const timeLimitPromise = new Promise((resolve, reject) => {\\n      setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n    });\\n    const returnedPromise = fn(...args);\\n    return Promise.race([timeLimitPromise, returnedPromise]);\\n  }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3531817,
                "title": "promise-time-limit",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    const promise = fn(...args)\\n    const timeout = new Promise((resolve,reject) => {\\n      setTimeout(() => reject(\"Time Limit Exceeded\"),t);\\n    });\\n    return Promise.race([promise,timeout])\\n  };\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    const promise = fn(...args)\\n    const timeout = new Promise((resolve,reject) => {\\n      setTimeout(() => reject(\"Time Limit Exceeded\"),t);\\n    });\\n    return Promise.race([promise,timeout])\\n  };\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3531534,
                "title": "self-explanatory-two-solution-beginner-friendly",
                "content": "# Solution One - (Using Callback)\\n\\n# Code\\n\\n```\\nvar timeLimit = function (fn, t) {\\n  return async function (...args) {\\n    return new Promise((resolve, reject) => {\\n      const id = setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n      fn(...args)\\n        .then((res) => resolve(res))\\n        .catch((err) => reject(err))\\n        .finally(() => clearTimeout(id));\\n    });\\n  };\\n};\\n```\\n\\n# Solution Two - (Using async/await)\\n\\n# Code\\n```\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise(async(resolve,reject) => {\\n            const id = setTimeout(() => reject(\"Time Limit Exceeded\"),t);\\n            try{\\n                const res = await fn(...args);\\n                resolve(res);\\n            }catch(err){\\n                reject(err);\\n            }\\n        })\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar timeLimit = function (fn, t) {\\n  return async function (...args) {\\n    return new Promise((resolve, reject) => {\\n      const id = setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n      fn(...args)\\n        .then((res) => resolve(res))\\n        .catch((err) => reject(err))\\n        .finally(() => clearTimeout(id));\\n    });\\n  };\\n};\\n```\n```\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise(async(resolve,reject) => {\\n            const id = setTimeout(() => reject(\"Time Limit Exceeded\"),t);\\n            try{\\n                const res = await fn(...args);\\n                resolve(res);\\n            }catch(err){\\n                reject(err);\\n            }\\n        })\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3531526,
                "title": "2637-promise-time-limit-javascript-day-12",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const promise= fn.apply(this,args);\\n        const timeout = new Promise((_,reject) =>{\\n            setTimeout(()=>{\\n                reject(\"Time Limit Exceeded\");\\n            },t);\\n        });\\n        return Promise.race([promise,timeout]);\\n    };\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const promise= fn.apply(this,args);\\n        const timeout = new Promise((_,reject) =>{\\n            setTimeout(()=>{\\n                reject(\"Time Limit Exceeded\");\\n            },t);\\n        });\\n        return Promise.race([promise,timeout]);\\n    };\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3531456,
                "title": "simple-solution-easy-to-understand-o-1-time-o-1-space",
                "content": "# Complexity\\n- Time complexity: **O(1)**\\n- Space complexity: **O(1)**\\n\\n# Code\\n```\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise(async (resolve, reject) => {\\n            const timeoutId = setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n            fn(...args)\\n                .then((resolve))\\n                .catch(reject)\\n                .finally(() => clearTimeout(t));\\n        });\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise(async (resolve, reject) => {\\n            const timeoutId = setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n            fn(...args)\\n                .then((resolve))\\n                .catch(reject)\\n                .finally(() => clearTimeout(t));\\n        });\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3531404,
                "title": "you-just-need-to-know-the-promise-race",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nYou just need to know the Promise.race():\\n\\nThe Promise.race() static method takes an iterable of promises as input and returns a single Promise. This returned promise settles with the eventual state of the first promise that settles.\\n\\n```\\nconst promise1 = new Promise((resolve, reject) => {\\n  setTimeout(resolve, 500, \\'one\\');\\n});\\n\\nconst promise2 = new Promise((resolve, reject) => {\\n  setTimeout(resolve, 100, \\'two\\');\\n});\\n\\nPromise.race([promise1, promise2]).then((value) => {\\n  console.log(value);\\n  // Both resolve, but promise2 is faster\\n});\\n// Expected output: \"two\"\\n\\n```\\n\\n# Approach\\nwe have fn which is the promise function and we need another promise function To throw a race between two Promises.\\n\\n# Complexity\\n- Time complexity: O(t)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\n    const timeLimit =   new Promise((resolve, reject) => {\\n            setTimeout(() => reject(\\'Time Limit Exceeded\\'), t);\\n    })\\n\\n\\treturn async function(...args) {\\n        return await Promise.race([fn(...args),timeLimit]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst promise1 = new Promise((resolve, reject) => {\\n  setTimeout(resolve, 500, \\'one\\');\\n});\\n\\nconst promise2 = new Promise((resolve, reject) => {\\n  setTimeout(resolve, 100, \\'two\\');\\n});\\n\\nPromise.race([promise1, promise2]).then((value) => {\\n  console.log(value);\\n  // Both resolve, but promise2 is faster\\n});\\n// Expected output: \"two\"\\n\\n```\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\n    const timeLimit =   new Promise((resolve, reject) => {\\n            setTimeout(() => reject(\\'Time Limit Exceeded\\'), t);\\n    })\\n\\n\\treturn async function(...args) {\\n        return await Promise.race([fn(...args),timeLimit]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3531338,
                "title": "advanced-approach-with-concept-building-and-easy-explanation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor this problem we should know a in-built function Promise.race().Here is some information about Promise.race().\\n\\nThe Promise.race() static method takes an iterable of promises as input and returns a single Promise. This returned promise settles with the eventual state of the first promise that settles.\\n\\nSo here we are just gonna create our new custom promise which will then be run against the given promise. So the winner will be executed.\\n\\n# Please upvote.\\u2705\\u261D\\uFE0F\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const originalFnPromise = fn(...args);\\n\\n        const timeoutPromise = new Promise((_, reject) => {\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([originalFnPromise, timeoutPromise]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const originalFnPromise = fn(...args);\\n\\n        const timeoutPromise = new Promise((_, reject) => {\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([originalFnPromise, timeoutPromise]);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3531293,
                "title": "java-script-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    return new Promise(async (resolve, reject) => {\\n      const timeout = setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n\\n      try {\\n        const result = await fn(...args);\\n        resolve(result);\\n      } catch(err) {\\n        reject(err);\\n      }\\n      clearTimeout(timeout);\\n    });\\n  };\\n};\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    return new Promise(async (resolve, reject) => {\\n      const timeout = setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n\\n      try {\\n        const result = await fn(...args);\\n        resolve(result);\\n      } catch(err) {\\n        reject(err);\\n      }\\n      clearTimeout(timeout);\\n    });\\n  };\\n};\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3531291,
                "title": "easy-js-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    return new Promise((resolve, reject) => {\\n      setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n      fn(...args).then(resolve).catch(reject);\\n    })\\n  }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    return new Promise((resolve, reject) => {\\n      setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n      fn(...args).then(resolve).catch(reject);\\n    })\\n  }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3531245,
                "title": "beginner-s-js-solution",
                "content": "> DISCLAIMER: I am not a Pro, Just sharing my solution here to start a healthy discussion, if you feel it could have been better, please feel free to share your solution and thoughts \\uD83D\\uDE4F below\\n\\n# Intuition\\nPromise static method might be helpful \\uD83E\\uDD14\\uD83E\\uDDD9\\u200D\\u2642\\uFE0F\\n\\n# Approach\\nIf we need to race between two promises which one reaches end state first and end state doesn\\'t matter than we can use Promise static method `Promise.race()`\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n![image.png](https://assets.leetcode.com/users/images/164dd62e-ac15-4f2c-8e02-6f19553df88f_1684249915.0756152.png)\\n\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n\\t\\tconst prom = new Promise((res,rej)=> setTimeout(()=>rej(\"Time Limit Exceeded\"),t));\\n        return Promise.race([prom,fn(...args)])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n\\t\\tconst prom = new Promise((res,rej)=> setTimeout(()=>rej(\"Time Limit Exceeded\"),t));\\n        return Promise.race([prom,fn(...args)])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3531099,
                "title": "promise-time-limit-easy-solution-with-explanation",
                "content": "# Intuition\\nThe intuition behind this problem is to limit the execution time of a given function to a specific duration. If the function takes longer than the specified time limit, it should be terminated and return a predefined error message.\\n\\n# Approach\\nThe approach to solving this problem is to wrap the given function in another function that incorporates a timeout mechanism. The wrapper function will execute the original function and also create a timeout promise that rejects with an error message after the specified time limit. By using Promise.race, we can wait for either the original function to complete or the timeout to occur. Whichever promise resolves or rejects first will be the result of the overall wrapper function.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\nThe space complexity of the wrapper function is also O(1) since it doesn\\'t use any additional data structures that scale with the input size.\\n\\n- Space complexity: $$O(1)$$\\nThe space complexity of the wrapper function is also O(1) since it doesn\\'t use any additional data structures that scale with the input size.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function (fn, t) {\\n  return async function (...args) {\\n    const promise = fn(...args);\\n    const timeout = new Promise((resolve, reject) => {\\n      setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n    });\\n    return Promise.race([promise, timeout]); // Return a promise that resolves or rejects based on which promise resolves or rejects first\\n  };\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function (fn, t) {\\n  return async function (...args) {\\n    const promise = fn(...args);\\n    const timeout = new Promise((resolve, reject) => {\\n      setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n    });\\n    return Promise.race([promise, timeout]); // Return a promise that resolves or rejects based on which promise resolves or rejects first\\n  };\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3531083,
                "title": "easy-solution-o-1",
                "content": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const rePromise = fn(...args);\\n        const tlPromise = new Promise((_, rej) => {\\n            setTimeout(() => {\\n                rej(\"Time Limit Exceeded\")\\n            }, t);\\n        });\\n        return Promise.race([rePromise, tlPromise]);\\n    };\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const rePromise = fn(...args);\\n        const tlPromise = new Promise((_, rej) => {\\n            setTimeout(() => {\\n                rej(\"Time Limit Exceeded\")\\n            }, t);\\n        });\\n        return Promise.race([rePromise, tlPromise]);\\n    };\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3530980,
                "title": "2637-promise-time-limit-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can create a time-limited version of an asynchronous function by using the Promise.race() method to race between the original function and a timeout promise. Here\\'s an example implementation in JavaScript:\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn the above code, the timeLimited function takes two arguments: fn (the original asynchronous function) and t (the time limit in milliseconds). It returns a new asynchronous function that wraps the original function.\\n\\nInside the new function, we create a timeout promise using setTimeout which will reject with the string \"Time Limit Exceeded\" after t milliseconds. Then, we use Promise.race() to race between the original function fn(...args) and the timeout promise. Whichever promise resolves or rejects first will be returned by Promise.race().\\n\\n```javascript []\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const timeoutPromise = new Promise((resolve, reject) =>{\\n            setTimeout(() => {\\n                reject(\"Time Limit Exceeded\");\\n            }, t);\\n        });\\n        try{\\n            const result = await Promise.race([fn(...args), timeoutPromise]);\\n            return result;\\n        }catch(error){\\n            throw error;\\n        }\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the timeLimited function itself is constant, O(1), as it performs basic operations without any loops or recursive calls. However, the time complexity of executing the time-limited function depends on the time complexity of the original function fn.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the timeLimited function is also constant, O(1), as it only creates a few variables and promises regardless of the input size.\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript []\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const timeoutPromise = new Promise((resolve, reject) =>{\\n            setTimeout(() => {\\n                reject(\"Time Limit Exceeded\");\\n            }, t);\\n        });\\n        try{\\n            const result = await Promise.race([fn(...args), timeoutPromise]);\\n            return result;\\n        }catch(error){\\n            throw error;\\n        }\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3530877,
                "title": "js-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const time1 = fn(...args);\\n        const time2 = new Promise((res, rej) => {\\n            setTimeout(()=> {\\n                rej (\\'Time Limit Exceeded\\')\\n            }, t)\\n        });\\n\\n        return Promise.race([time1, time2]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const time1 = fn(...args);\\n        const time2 = new Promise((res, rej) => {\\n            setTimeout(()=> {\\n                rej (\\'Time Limit Exceeded\\')\\n            }, t)\\n        });\\n\\n        return Promise.race([time1, time2]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3530843,
                "title": "async-w-o-async",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise(async(resolve,reject)=>{\\n            const id=setTimeout(()=>reject(\"Time Limit Exceeded\"),t);\\n            //ASYNC way\\n            try{\\n                const res=await fn(...args);\\n                resolve(res)\\n            }catch(err){\\n                reject(err)\\n            }\\n            clearTimeout(id);\\n\\n            /*\\n            w/o async\\n            fn(...args)\\n                .then((res)=>resolve(res))\\n                .catch((err)=>reject(err))\\n                .finally(()=>clearTimeout(id))\\n            */\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise(async(resolve,reject)=>{\\n            const id=setTimeout(()=>reject(\"Time Limit Exceeded\"),t);\\n            //ASYNC way\\n            try{\\n                const res=await fn(...args);\\n                resolve(res)\\n            }catch(err){\\n                reject(err)\\n            }\\n            clearTimeout(id);\\n\\n            /*\\n            w/o async\\n            fn(...args)\\n                .then((res)=>resolve(res))\\n                .catch((err)=>reject(err))\\n                .finally(()=>clearTimeout(id))\\n            */\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3530628,
                "title": "easy-to-understand-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    return new Promise(async (resolve, reject) => {\\n      const timeout = setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n\\n      try {\\n        const result = await fn(...args);\\n        resolve(result);\\n      } catch(err) {\\n        reject(err);\\n      }\\n      clearTimeout(timeout);\\n    });\\n  };\\n};\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    return new Promise(async (resolve, reject) => {\\n      const timeout = setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n\\n      try {\\n        const result = await fn(...args);\\n        resolve(result);\\n      } catch(err) {\\n        reject(err);\\n      }\\n      clearTimeout(timeout);\\n    });\\n  };\\n};\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3530512,
                "title": "solution-typescript-javascript",
                "content": "# Code\\n``` typescript []\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        return Promise.race([\\n            fn(...args),\\n            new Promise((_, reject) => {\\n                setTimeout(\\n                    () => reject(\\'Time Limit Exceeded\\'),\\n                    t\\n                )\\n            })\\n        ]);  \\n    }\\n};\\n```\\n``` javascript []\\nvar timeLimit = function(fn, t) {\\n\\treturn function(...args) {\\n         return Promise.race([\\n            fn(...args),\\n            new Promise((_, reject) => {\\n                setTimeout(\\n                    () => reject(\\'Time Limit Exceeded\\'),\\n                    t\\n                )\\n            })\\n        ]);  \\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "``` typescript []\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        return Promise.race([\\n            fn(...args),\\n            new Promise((_, reject) => {\\n                setTimeout(\\n                    () => reject(\\'Time Limit Exceeded\\'),\\n                    t\\n                )\\n            })\\n        ]);  \\n    }\\n};\\n```\n``` javascript []\\nvar timeLimit = function(fn, t) {\\n\\treturn function(...args) {\\n         return Promise.race([\\n            fn(...args),\\n            new Promise((_, reject) => {\\n                setTimeout(\\n                    () => reject(\\'Time Limit Exceeded\\'),\\n                    t\\n                )\\n            })\\n        ]);  \\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3530496,
                "title": "explanation-from-the-senior-developer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe given code defines a function called timeLimit that takes two parameters: fn and t. Here\\'s a step-by-step explanation of how it works:\\n\\nThe timeLimit function is defined using the const keyword.\\nIt is an asynchronous function, indicated by the async keyword before the function declaration.\\nThe function takes two parameters: fn and t.\\nfn is a function that will be executed.\\nt is the time limit in milliseconds.\\nInside the function, a new anonymous async function is defined using the async function(...args) syntax. This function takes any number of arguments using the rest parameter syntax (...args).\\nThe originalFnPromise variable is declared and assigned the result of calling the fn function with the provided arguments (fn(...args)). This means that the fn function is executed with the passed arguments, and it returns a promise representing the asynchronous operation.\\nThe timeoutPromise variable is declared and assigned a new promise.\\nInside the timeoutPromise, a setTimeout function is used to delay the execution of its callback by t milliseconds.\\nIn the callback function, the promise is rejected by calling the reject function with the message \\'Time Limit Exceeded\\'. This means that if the setTimeout callback is executed after t milliseconds, the timeoutPromise will be rejected with the given error message.\\nThe Promise.race function is used to race between two promises: originalFnPromise and timeoutPromise.\\nThe Promise.race function takes an array of promises and returns a new promise that resolves or rejects as soon as one of the promises in the array settles (either resolves or rejects).\\nIn this case, it races between originalFnPromise and timeoutPromise, so whichever promise settles first will determine the outcome of the returned promise.\\nThe final result of the timeLimit function is the promise returned by Promise.race.\\nIf originalFnPromise settles (either resolves or rejects) before the timeoutPromise, the result of originalFnPromise will be passed through.\\nIf the timeoutPromise settles (rejects) before originalFnPromise, it means the time limit has been exceeded, and the rejection reason will be \\'Time Limit Exceeded\\'.\\nIn summary, the timeLimit function creates a wrapper function that adds a time limit to the execution of another function (fn). The wrapped function can be called with any number of arguments, and it returns a promise that resolves with the result of fn if it completes within the specified time (t), or rejects with the error message \\'Time Limit Exceeded\\' if fn takes longer than the specified time.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const originalFnPromise = fn(...args);\\n\\n        const timeoutPromise = new Promise((_, reject) => {\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([originalFnPromise, timeoutPromise]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const originalFnPromise = fn(...args);\\n\\n        const timeoutPromise = new Promise((_, reject) => {\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([originalFnPromise, timeoutPromise]);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3530495,
                "title": "easiest-explanation-let-s-race",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- **Promise:**\\n    - A JavaScript object which holds the producing code and calls to the consuming code.\\n    - It ensures to produce a single value when required (in the future).\\n    - It\\'s main purpose is to track & manage multiple asynchronous operations\\n    - It has *4 Stages*:\\n        1. *Fulfilled*: Promise succeeded\\n        2. *Rejected*: Promise failed\\n        3. *Pending*: Promise is still pending\\n        4. *Settled*: Promise is either fulfilled or rejected\\n    - Syntax:\\n    `var promise = new Promise(function(resolve, reject){\\n     //do something\\n});`\\n\\n- **setTimeout**:\\n    - This method is used to execute a function, after waiting for a specified number of milliseconds.\\n    - Syntax: `setTimeout(function, milliseconds);` \\n\\n- **Promise.race():** \\n    - It is one of the promise concurrency methods.\\n    - It is used when we want the first asynchronous task to complete, but do not care about its eventual state (either succeed or fail).\\n    - *For Example:* Take it as a race, so which ever promise gets successfully completed (fulfills or rejects) early will get executed and rest promise\\'s results will not be displayed as an output.\\n    - Syntax: `Promise.race(iterable);`\\n\\n\\n# Code\\n``` javaScript []\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const originalPromise = fn(...args);\\n\\n        const timeLimitPromise = new Promise((_, reject) => {\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([originalPromise, timeLimitPromise]);\\n    }\\n};\\n```\\n\\n\\uD83D\\uDC47\\uD83C\\uDFFC ***Do Share your Opinion, by voting.***",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javaScript []\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const originalPromise = fn(...args);\\n\\n        const timeLimitPromise = new Promise((_, reject) => {\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([originalPromise, timeLimitPromise]);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3530493,
                "title": "simple-easy-and-sort-solution",
                "content": "```\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n   \\n    return new Promise((resolve,reject) => {\\n        setTimeout(() => {\\n            reject(\"Time Limit Exceeded\");\\n        }, t);\\n        fn(...args).then(resolve).catch(reject);\\n    })\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n   \\n    return new Promise((resolve,reject) => {\\n        setTimeout(() => {\\n            reject(\"Time Limit Exceeded\");\\n        }, t);\\n        fn(...args).then(resolve).catch(reject);\\n    })\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3530483,
                "title": "chatgpt-code-snippet",
                "content": "# Intuition\\n\\nThe problem requires us to implement a time-limited version of an asynchronous function. Given an asynchronous function `fn` and a time limit `t` in milliseconds, we need to create a new function that behaves like the original function `fn` but rejects the promise with a \"Time Limit Exceeded\" message if it takes longer than `t` milliseconds to fulfill.\\n\\nTo solve this problem, we can use a wrapper function that wraps the original function `fn` and adds a timeout mechanism to enforce the time limit. If the wrapped function exceeds the specified time limit, we reject the promise with the appropriate message. Otherwise, we resolve the promise with the result.\\n\\n# Approach\\n\\n1. We define the `timeLimit` function that takes `fn` (the original asynchronous function) and `t` (the time limit) as input.\\n2. Inside the `timeLimit` function, we return a new wrapper function that accepts any number of arguments (`...args`).\\n3. In the wrapper function, we create a new promise using the `Promise` constructor. This promise will be returned to the caller of the wrapper function.\\n4. Within the promise, we start a timeout using `setTimeout` and specify the time limit `t` as the duration. If the timeout expires before the wrapped function resolves, we reject the promise with the message \"Time Limit Exceeded\".\\n5. We then invoke the original function `fn` with the provided arguments (`fn(...args)`). If the original function resolves before the timeout, we clear the timeout using `clearTimeout` and resolve the wrapper function\\'s promise with the result.\\n6. If the original function rejects, we also clear the timeout and reject the wrapper function\\'s promise with the error.\\n7. Finally, we return the wrapper function, which serves as the time-limited version of the original function.\\n\\n# Complexity Analysis\\n\\n## Time Complexity:\\nThe time complexity of the `timeLimit` function is constant, O(1), as it performs a fixed number of operations regardless of the size of the input.\\n\\n## Space Complexity:\\nThe space complexity is also constant, O(1), as no additional data structures or recursive calls are used. The memory usage remains constant throughout the execution.\\n\\n# Code\\n\\n```javascript\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    return new Promise((resolve, reject) => {\\n      const timeout = setTimeout(() => {\\n        reject(\\'Time Limit Exceeded\\');\\n      }, t);\\n\\n      fn(...args)\\n        .then((result) => {\\n          clearTimeout(timeout);\\n          resolve(result);\\n        })\\n        .catch((error) => {\\n          clearTimeout(timeout);\\n          reject(error);\\n        });\\n    });\\n  };\\n};\\n```\\n\\n# Example Usage\\n\\n```javascript\\nconst limited = timeLimit((t) => new Promise((res) => setTimeout(res, t)), 100);\\nlimited(150).catch(console.log); // Output: \"Time Limit Exceeded\" at t=100ms\\n```\\n\\nIn this example, we create a time-limited version of an asynchronous function that waits for the specified time before resolving. The time limit is set to 100 milliseconds, but the function takes 150 milliseconds to complete. As a result, the promise is rejected with the \"Time Limit Exceeded\" message at t=100ms.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    return new Promise((resolve, reject) => {\\n      const timeout = setTimeout(() => {\\n        reject(\\'Time Limit Exceeded\\');\\n      }, t);\\n\\n      fn(...args)\\n        .then((result) => {\\n          clearTimeout(timeout);\\n          resolve(result);\\n        })\\n        .catch((error) => {\\n          clearTimeout(timeout);\\n          reject(error);\\n        });\\n    });\\n  };\\n};\\n```\n```javascript\\nconst limited = timeLimit((t) => new Promise((res) => setTimeout(res, t)), 100);\\nlimited(150).catch(console.log); // Output: \"Time Limit Exceeded\" at t=100ms\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3530316,
                "title": "easy-solution-3-line-code-75-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# Approach\\nIt returns an asynchronous function that takes any number of arguments using the spread syntax ...args. This function executes the input function fn with the input arguments args and saves the result in a variable called s1.\\n\\nThe function also creates a new promise, s2, using the setTimeout method. This promise rejects with a message of \\'Time Limit Exceeded\\' if it is not resolved within t milliseconds.\\n\\nFinally, the function returns a promise that uses Promise.race to resolve with s1 if it is resolved before s2. Otherwise, it rejects with the message \\'Time Limit Exceeded\\'.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\n    var timeLimit = function(fn, t) {\\n   \\n\\treturn async function(...args) {\\n    const s1 = fn(...args)\\n    const s2= new Promise((res,rej)=>{setTimeout(()=>{ rej(\\'Time Limit Exceeded\\')},t) })\\n     return Promise.race([s1,s2])\\n    } \\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "JavaScript",
                    "String"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\n    var timeLimit = function(fn, t) {\\n   \\n\\treturn async function(...args) {\\n    const s1 = fn(...args)\\n    const s2= new Promise((res,rej)=>{setTimeout(()=>{ rej(\\'Time Limit Exceeded\\')},t) })\\n     return Promise.race([s1,s2])\\n    } \\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3530225,
                "title": "js-promise-without-the-race",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nObviously we have time window when we either resolve or fail.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. use setTimeout where our error is being sent to the promise \\n2. start our fn with args\\n3. when the timer gets resolved then we just fail\\n4. when the fn is complete  - we either resolve or fail depends when it succeeded\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise(async (done, fail) => {\\n            let resolved = false;\\n            const timerOpLimitId = setTimeout(() => {\\n                resolved = true;\\n                fail(\\'Time Limit Exceeded\\');\\n            }, t ?? 0);\\n            let fnResult;\\n            try {\\n                fnResult = await (fn ? fn(...(args || [])) : Promise.resolve());\\n                resolved ? void 0 : done(fnResult);\\n            } catch (fnErrMsg) {\\n                resolved ? void 0 : fail(fnErrMsg);\\n            }\\n            clearTimeout(timerOpLimitId);\\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise(async (done, fail) => {\\n            let resolved = false;\\n            const timerOpLimitId = setTimeout(() => {\\n                resolved = true;\\n                fail(\\'Time Limit Exceeded\\');\\n            }, t ?? 0);\\n            let fnResult;\\n            try {\\n                fnResult = await (fn ? fn(...(args || [])) : Promise.resolve());\\n                resolved ? void 0 : done(fnResult);\\n            } catch (fnErrMsg) {\\n                resolved ? void 0 : fail(fnErrMsg);\\n            }\\n            clearTimeout(timerOpLimitId);\\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3530162,
                "title": "day-12-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n    const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(\"Time Limit Exceeded\"), t));\\n    const resultPromise = fn(...args);\\n\\n    return Promise.race([resultPromise, timeoutPromise]);\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n    const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(\"Time Limit Exceeded\"), t));\\n    const resultPromise = fn(...args);\\n\\n    return Promise.race([resultPromise, timeoutPromise]);\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3530121,
                "title": "promise-settimeout-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n  return async function(...args) {\\n    return new Promise((resolve, reject) => {\\n      const timeout = setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n      fn(...args)\\n        .then(resolve)\\n        .catch(reject)\\n        .finally(() => clearTimeout(timeout));\\n    })\\n  }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n  return async function(...args) {\\n    return new Promise((resolve, reject) => {\\n      const timeout = setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n      fn(...args)\\n        .then(resolve)\\n        .catch(reject)\\n        .finally(() => clearTimeout(timeout));\\n    })\\n  }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3530038,
                "title": "javascript-easy-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    const timeLimitPromise = new Promise((resolve, reject) => {\\n      setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n    });\\n    const returnedPromise = fn(...args);\\n    return Promise.race([timeLimitPromise, returnedPromise]);\\n  }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\\n![UpvoteLeetcode.jpeg](https://assets.leetcode.com/users/images/822d61df-974d-44c0-8bb1-186b62dbbe65_1684225412.9392846.jpeg)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    const timeLimitPromise = new Promise((resolve, reject) => {\\n      setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n    });\\n    const returnedPromise = fn(...args);\\n    return Promise.race([timeLimitPromise, returnedPromise]);\\n  }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3530029,
                "title": "promise-time-limit-solution-with-promise-race-and-settimeout-js-day-12",
                "content": "# Intuition\\nTo solve this problem we need to take into account the time limit during which our function can be executed.\\nFor this we will use `setTimeout` inside a promise and the `Promise.race` method to get the first settled promise.\\n\\n# Approach\\nLets create a new Promise `timeLimitedPromise` to control execution time based on a time.\\nThen we should call it together with our function in `Promise.race`. \\n`race` method will return the first fulfilled promise and that will be our function call or time limit promise if time limit was exceeded.\\nP.s. We can omit errors as they are not specified in the problem requirements.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const timeLimitedPromise = new Promise((_, reject) => {\\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n        })\\n        return Promise.race([\\n            fn(...args),\\n            timeLimitedPromise\\n        ])\\n    }\\n};\\n\\n```\\n\\n\\nIf you like this solution and it looks simple and clean please vote. It would motivate me ;)\\n\\nThanks!",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const timeLimitedPromise = new Promise((_, reject) => {\\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n        })\\n        return Promise.race([\\n            fn(...args),\\n            timeLimitedPromise\\n        ])\\n    }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529962,
                "title": "promise-time-limit-easy-solution",
                "content": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((res, rej) => {\\n            setTimeout(() => rej(\"Time Limit Exceeded\"),t);\\n            fn(...args).then(res, rej);\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((res, rej) => {\\n            setTimeout(() => rej(\"Time Limit Exceeded\"),t);\\n            fn(...args).then(res, rej);\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529944,
                "title": "javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n     const start = Date.now();\\n     const result = await Promise.race([fn(...args), new Promise((_, reject) => setTimeout(() => reject(\"Time Limit Exceeded\"), t))]);\\n      const elapsed = Date.now() - start;\\n     if (elapsed >= t) {\\n        throw \"Time Limit Exceeded\";\\n    }\\n       return result;\\n  }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n     const start = Date.now();\\n     const result = await Promise.race([fn(...args), new Promise((_, reject) => setTimeout(() => reject(\"Time Limit Exceeded\"), t))]);\\n      const elapsed = Date.now() - start;\\n     if (elapsed >= t) {\\n        throw \"Time Limit Exceeded\";\\n    }\\n       return result;\\n  }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529901,
                "title": "well-explained-clean-solution-promise-race",
                "content": "# Question Explanation\\nA promise \"fn\" is provided which is going to be resolved in some x time we dont know. We have to build a new Promise which should be rejected in \"t\" seconds.\\nIf the promise fn takes more than \"t\" seconds to be resolved then the newly created promise should reject by Time Limit Exceeded, else the resolved value of the \"fn\" promise should be returned.\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nAll we have to do is to check which Promise is executed first, is it \\n\"fn\" Promise or the newly created promise.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe Promise.race() static method takes an iterable of promises as input and returns a single Promise. This single promise is the promise which get resolved or rejected first.\\nHence, if \"fn\" promise gets resolved within t time, then is send the resolved value, else the newly created Prommise sends \"Time Limit Exceeded\".\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\n\\treturn async function(...args) {\\n        \\n        const newPromise = new Promise((resolve, reject) => setTimeout(() => reject(\\'Time Limit Exceeded\\'), t))\\n\\n        const actualPromise = fn(...args);\\n\\n        return Promise.race([actualPromise, newPromise]);\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\n\\treturn async function(...args) {\\n        \\n        const newPromise = new Promise((resolve, reject) => setTimeout(() => reject(\\'Time Limit Exceeded\\'), t))\\n\\n        const actualPromise = fn(...args);\\n\\n        return Promise.race([actualPromise, newPromise]);\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529870,
                "title": "day-12-js-simple-and-easy-promise-race-solution",
                "content": "# Intuition\\nThe Question states that we have given a fn function that returns a promise .\\n\\nNow we are also Given the timelimit t\\n\\nif the promise is resolved within t miliseconds then the promise with fn if returned\\n\\nElse the promise with **Time Limit Exceeded** is Returned\\n\\n# Approach\\nToday from one of the solution I learned about **Promise.race**\\n\\n1. **Promise.race** : it takes different promises and returns the promise that resolves faster\\n2. So We Are going to use this approach to solve the question\\n3. First we will have the promise returned by the function fn\\n\\n```\\n const ogPromise = fn(...args)\\n```\\n4. Now we will have a delayed promise with t time that rejects with message of \"TIME LIMIT EXCEEDED\"\\n5. We wil be using the setTimeout function for the delay of t miliseconds\\n\\n ```\\nconst DelayedPromise = new Promise((_,reject)=>{\\n            setTimeout(()=>{\\n                reject(\"Time Limit Exceeded\")\\n            },t);\\n        })\\n```\\n\\n6. Now we will be returning the promise with faster resolving time . i.e. if promise ogPromise is resolved first it is returned or if the promise with delayed time is resolved first then it is returned.\\n7. For this purpose we will be using Promise.rece with both promises as parameters\\n\\n```\\nPromise.race([ogPromise,DelayedPromise]);\\n```\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\nHere n will be the max time required to resolve a promise\\n\\n- Space complexity:\\n $$O(1)$$ \\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const ogPromise = fn(...args);\\n\\n        const DelayedPromise = new Promise((_,reject)=>{\\n            setTimeout(()=>{\\n                reject(\"Time Limit Exceeded\")\\n            },t);\\n        })\\n\\n        return Promise.race([ogPromise,DelayedPromise]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\\n\\n# **If You Like my solution Dont forget to upvote \\uD83D\\uDE07**\\n![upvote.jpg](https://assets.leetcode.com/users/images/2b07485f-1a17-487f-923c-66b3b03e39ca_1684221712.7089345.jpeg)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n const ogPromise = fn(...args)\\n```\n```\\nconst DelayedPromise = new Promise((_,reject)=>{\\n            setTimeout(()=>{\\n                reject(\"Time Limit Exceeded\")\\n            },t);\\n        })\\n```\n```\\nPromise.race([ogPromise,DelayedPromise]);\\n```\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const ogPromise = fn(...args);\\n\\n        const DelayedPromise = new Promise((_,reject)=>{\\n            setTimeout(()=>{\\n                reject(\"Time Limit Exceeded\")\\n            },t);\\n        })\\n\\n        return Promise.race([ogPromise,DelayedPromise]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529780,
                "title": "time-juggler-putting-async-functions-on-a-leash",
                "content": "# Intuition\\nThe timeLimit function takes an original asynchronous function fn and a time limit t as input. It returns a new asynchronous function that ensures the execution of fn is time-limited.\\n\\nInside the new function, a promise is created with a timeout using setTimeout to reject if the time limit is exceeded. fn is then invoked with the provided arguments, and its promise is chained to the timeout promise using .then() and .catch().\\n\\nIf fn resolves within the time limit, the new function resolves with the resolved value. If fn rejects or the time limit is exceeded, the new function rejects with the appropriate value or message.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe timeLimit function takes two parameters: fn, which represents the original asynchronous function, and t, which is the time limit in milliseconds.\\n\\nIt returns a new asynchronous function that accepts any number of arguments (...args).\\n\\nInside the new function, a promise is created using the Promise constructor. This promise is responsible for tracking the time limit.\\n\\nA setTimeout function is used to set up a timer. After the specified time t has elapsed, the timer triggers and the promise is rejected with the message \"Time Limit Exceeded\".\\n\\nThe original function fn is invoked with the provided arguments (fn(...args)). It returns a promise representing the execution of the original function.\\n\\nThe promise returned by fn(...args) is chained using .then() and .catch(). If the original function resolves within the time limit, the promise chain resolves with the resolved value. If it rejects, the promise chain rejects with the same error.\\n\\nThe promise chain is wrapped inside the outer promise created in step 3. This ensures that the overall promise returned by the new function resolves or rejects based on the execution of the original function and the time limit.\\n\\nThe new function returns the promise, allowing the caller to handle the result using .then() and .catch().\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity : O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve,reject)=>{\\n            setTimeout(()=>{\\n                reject(\"Time Limit Exceeded\",);\\n            },t);\\n            fn(...args).then(resolve).catch(reject);\\n        })\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve,reject)=>{\\n            setTimeout(()=>{\\n                reject(\"Time Limit Exceeded\",);\\n            },t);\\n            fn(...args).then(resolve).catch(reject);\\n        })\\n    }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529742,
                "title": "simple-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve,reject)=>{\\n            setTimeout(()=>{\\n                reject(\"Time Limit Exceeded\",);\\n            },t);\\n            fn(...args).then(resolve).catch(reject);\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve,reject)=>{\\n            setTimeout(()=>{\\n                reject(\"Time Limit Exceeded\",);\\n            },t);\\n            fn(...args).then(resolve).catch(reject);\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529731,
                "title": "day-12",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n    const result = Promise.resolve(fn.apply(this, args));\\n    const timeout = new Promise((_, reject) =>\\n      setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n    );\\n    return Promise.race([result, timeout]);\\n  };\\n};\\n\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n    const result = Promise.resolve(fn.apply(this, args));\\n    const timeout = new Promise((_, reject) =>\\n      setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n    );\\n    return Promise.race([result, timeout]);\\n  };\\n};\\n\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529707,
                "title": "easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing wrapper function having two argument fn and t.Now check fot each condition and return result accordingly;\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate wrapper function having two argument fn(original function) and t(time limit).If the timer expire before the promise resolved , reject the promise by the string \"Time Limit Exceeded\".If the function complete before the time limit ,resolve the promise by result.At last return promise from async function.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(f(n));\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((delayresolve , reject)=>{\\n            const timeoutId= setTimeout(()=>{\\n                clearTimeout(timeoutId);\\n                reject(\"Time Limit Exceeded\");\\n            },t);\\n            fn(...args)\\n            .then((result)=>{\\n                clearTimeout(timeoutId);\\n                delayresolve(result);\\n            })\\n            .catch((error)=>{\\n                clearTimeout(timeoutId);\\n                reject(error);\\n            });\\n        });\\n    };\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((delayresolve , reject)=>{\\n            const timeoutId= setTimeout(()=>{\\n                clearTimeout(timeoutId);\\n                reject(\"Time Limit Exceeded\");\\n            },t);\\n            fn(...args)\\n            .then((result)=>{\\n                clearTimeout(timeoutId);\\n                delayresolve(result);\\n            })\\n            .catch((error)=>{\\n                clearTimeout(timeoutId);\\n                reject(error);\\n            });\\n        });\\n    };\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529678,
                "title": "promise-with-handlers",
                "content": "# Explanation\\n##### Given the time limit (t), the async function should :-\\n1. If function **(fn)** gets fullfilled (either *resolved* or *rejected* ) before time limit **(t)**, then either *resolve with the return value* or *reject with the error* related to the function (fn)\\n2. If function **(fn)** is *not fullfilled* before time limit **(t)**, then *reject* with the message (\"Time Limit Exceeded\") **at time (t)**;\\n\\n# Approach\\n1. Declare a **setTimeout** function to reject at time (t) if the function (fn) is not fullfilled before that time.\\n2. Invoke the function **(fn)** and attach handlers (**.then** -> to resolve with response and **.catch** to handle reject with errors). \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {   \\n\\treturn async function(...args) {        \\n       return new Promise((resolve,reject) => {\\n           // if time exceeds the time limit \"t\"\\n           setTimeout(() => reject(\"Time Limit Exceeded\"),t);\\n\\n           // if fullfilled before the time limit \"t\"\\n           fn(...args)\\n                .then((result) => resolve(result))\\n                .catch((err) => reject(err));          \\n       });    \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {   \\n\\treturn async function(...args) {        \\n       return new Promise((resolve,reject) => {\\n           // if time exceeds the time limit \"t\"\\n           setTimeout(() => reject(\"Time Limit Exceeded\"),t);\\n\\n           // if fullfilled before the time limit \"t\"\\n           fn(...args)\\n                .then((result) => resolve(result))\\n                .catch((err) => reject(err));          \\n       });    \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529574,
                "title": "easy-98-beaten-code-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const p1 = fn(...args)\\n        const p2 = new Promise((res,rej)=>{\\n            setTimeout(()=>{\\n                rej(\\'Time Limit Exceeded\\')               \\n            },t)\\n        })\\n\\n        return Promise.race([p1,p2])\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const p1 = fn(...args)\\n        const p2 = new Promise((res,rej)=>{\\n            setTimeout(()=>{\\n                rej(\\'Time Limit Exceeded\\')               \\n            },t)\\n        })\\n\\n        return Promise.race([p1,p2])\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529573,
                "title": "without-race-function-simple-typescript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        return new Promise((res, rej) => {\\n            setTimeout(() => rej(\"Time Limit Exceeded\"), t);\\n            fn(...args)\\n                .then(res)\\n                .catch(rej);\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        return new Promise((res, rej) => {\\n            setTimeout(() => rej(\"Time Limit Exceeded\"), t);\\n            fn(...args)\\n                .then(res)\\n                .catch(rej);\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529569,
                "title": "1-liner",
                "content": "\\n```\\n\\nconst timeLimit = (fn, t) => (...args) =>\\n    Promise.race([\\n      fn(...args),\\n      new Promise((_, reject) => setTimeout(reject, t, \\'Time Limit Exceeded\\')),\\n    ]);\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nconst timeLimit = (fn, t) => (...args) =>\\n    Promise.race([\\n      fn(...args),\\n      new Promise((_, reject) => setTimeout(reject, t, \\'Time Limit Exceeded\\')),\\n    ]);\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529501,
                "title": "js-promise-race-time-57ms-75-space-42mb-47",
                "content": "# Approach\\nWe\\'ll try out the `Promise.race` method which automatically returns the first promise to finish,\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        // timeout promise\\n        const timeout = new Promise ((resolve, reject) => {\\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n        })\\n        // function promise\\n        const func = fn(...args);\\n        // return first promise that resolves/rjects\\n        return Promise.race([timeout, func])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        // timeout promise\\n        const timeout = new Promise ((resolve, reject) => {\\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n        })\\n        // function promise\\n        const func = fn(...args);\\n        // return first promise that resolves/rjects\\n        return Promise.race([timeout, func])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529439,
                "title": "javascript-simple-javascript-typescript-solution",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Approach 1 Using Javascript :\\n# Runtime: 70 ms, faster than 10.25% of JavaScript online submissions for Promise Time Limit.\\n# Memory Usage: 41.4 MB, less than 97.51% of JavaScript online submissions for Promise Time Limit.\\n\\n\\tvar timeLimit = function(fn, t) {\\n\\t\\treturn async function(...args) {\\n\\t\\t\\treturn new Promise((resolve, reject) => {\\n\\n\\t\\t\\t\\tsetTimeout(() => { reject(\\'Time Limit Exceeded\\');}, t);\\n\\n\\t\\t\\t\\tfn(...args).then(resolve).catch(reject);\\n\\n\\t\\t\\t});\\n\\t\\t};\\n\\t};\\n# Approach 2 Using Typescript :\\n# Runtime: 61 ms, faster than 71.67% of TypeScript online submissions for Promise Time Limit.\\n# Memory Usage: 42.8 MB, less than 77.11% of TypeScript online submissions for Promise Time Limit.\\n\\n\\ttype Fn = (...params: any[]) => Promise<any>;\\n\\n\\tfunction timeLimit(fn: Fn, t: number): Fn {\\n\\t\\treturn async function(...args) {\\n\\t\\t\\treturn new Promise((resolve, reject) => {\\n\\n\\t\\t\\t\\tsetTimeout(() => { reject(\\'Time Limit Exceeded\\');}, t);\\n\\n\\t\\t\\t\\tfn(...args).then(resolve).catch(reject);\\n\\n\\t\\t\\t});\\n\\t\\t}\\n\\t};\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Approach 1 Using Javascript :\\n# Runtime: 70 ms, faster than 10.25% of JavaScript online submissions for Promise Time Limit.\\n# Memory Usage: 41.4 MB, less than 97.51% of JavaScript online submissions for Promise Time Limit.\\n\\n\\tvar timeLimit = function(fn, t) {\\n\\t\\treturn async function(...args) {\\n\\t\\t\\treturn new Promise((resolve, reject) => {\\n\\n\\t\\t\\t\\tsetTimeout(() => { reject(\\'Time Limit Exceeded\\');}, t);\\n\\n\\t\\t\\t\\tfn(...args).then(resolve).catch(reject);\\n\\n\\t\\t\\t});\\n\\t\\t};\\n\\t};\\n# Approach 2 Using Typescript :\\n# Runtime: 61 ms, faster than 71.67% of TypeScript online submissions for Promise Time Limit.\\n# Memory Usage: 42.8 MB, less than 77.11% of TypeScript online submissions for Promise Time Limit.\\n\\n\\ttype Fn = (...params: any[]) => Promise<any>;\\n\\n\\tfunction timeLimit(fn: Fn, t: number): Fn {\\n\\t\\treturn async function(...args) {\\n\\t\\t\\treturn new Promise((resolve, reject) => {\\n\\n\\t\\t\\t\\tsetTimeout(() => { reject(\\'Time Limit Exceeded\\');}, t);\\n\\n\\t\\t\\t\\tfn(...args).then(resolve).catch(reject);\\n\\n\\t\\t\\t});\\n\\t\\t}\\n\\t};\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Unknown"
            },
            {
                "id": 3529432,
                "title": "promise-time-limit",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar timeLimit = function(fn, t) {\\n    return async function(...args) {\\n        return new Promise((resolve, reject) => { // create a new promise to return \\n\\n        // create a timer to reject the promise if the `t` time passes\\n        const timeout = setTimeout(() => {\\n            reject(\"Time Limit Exceeded\");\\n        }, t);\\n\\n        // start using the function as usual if it\\'s succed before just return it\\n        fn(...args)\\n            .then(resolve)\\n            .catch(reject)\\n            // clear timer is needed to free memory from setTimeout - good practise\\n            .finally(() => clearTimeout(timeout));\\n        })\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar timeLimit = function(fn, t) {\\n    return async function(...args) {\\n        return new Promise((resolve, reject) => { // create a new promise to return \\n\\n        // create a timer to reject the promise if the `t` time passes\\n        const timeout = setTimeout(() => {\\n            reject(\"Time Limit Exceeded\");\\n        }, t);\\n\\n        // start using the function as usual if it\\'s succed before just return it\\n        fn(...args)\\n            .then(resolve)\\n            .catch(reject)\\n            // clear timer is needed to free memory from setTimeout - good practise\\n            .finally(() => clearTimeout(timeout));\\n        })\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529419,
                "title": "try-to-understand-the-problem",
                "content": "**Understand the problem -**\\n\\nGiven an asyncronous function `fn` and a time `t` in milliseconds, return a new time limited version of the input function.\\n\\nWe have to return a new time limited version of the input function. What is time limited function then ?\\n\\nA time limited function is a function that is identical to the original unless it takes longer than `t` milliseconds to fullfill. In that case, it will reject with \"Time Limit Exceeded\".  Note that it should reject with a string, not an Error.\\n\\nBreakdown the definition ->\\n\\nA time limited function is a function means we have to return a function (We have to return a time limited version of the input function)-> \\n\\n```\\nvar timeLimit = function(fn, t) {\\n\\treturn function(...args){}\\n};\\n```\\ntime limited function is identical to the original function ->\\nmeans return function is also asyncronous\\n```\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args){}\\n};\\n```\\nIf the input function take more time to resolve then it will reject with time limit exceeded otherwise resolve.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve,reject) => {\\n            fn(...args).then((val) => resolve(val)). catch((err) => reject(err));\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\');\\n            },t);\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar timeLimit = function(fn, t) {\\n\\treturn function(...args){}\\n};\\n```\n```\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args){}\\n};\\n```\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve,reject) => {\\n            fn(...args).then((val) => resolve(val)). catch((err) => reject(err));\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\');\\n            },t);\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529397,
                "title": "js-solution-40-8-mb-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            setTimeout(() => {\\n                reject(\"Time Limit Exceeded\");\\n            }, t);\\n            fn(...args).then(resolve).catch(reject);\\n        }\\n        );\\n    };\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            setTimeout(() => {\\n                reject(\"Time Limit Exceeded\");\\n            }, t);\\n            fn(...args).then(resolve).catch(reject);\\n        }\\n        );\\n    };\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529377,
                "title": "javascript-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve,reject)=>{\\n\\n        const rejector=setTimeout(()=>{\\n            reject(\"Time Limit Exceeded\");\\n        }, t);\\n\\n        \\n        fn(...args)\\n            .then(resolve)\\n            .catch(reject)\\n            .finally(()=>clearTimeout(rejector));\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve,reject)=>{\\n\\n        const rejector=setTimeout(()=>{\\n            reject(\"Time Limit Exceeded\");\\n        }, t);\\n\\n        \\n        fn(...args)\\n            .then(resolve)\\n            .catch(reject)\\n            .finally(()=>clearTimeout(rejector));\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529369,
                "title": "day-12-solution-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    return new Promise(async (resolve, reject) => {\\n      const timeout = setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n\\n      try {\\n        const result = await fn(...args);\\n        resolve(result);\\n      } catch(err) {\\n        reject(err);\\n      }\\n      clearTimeout(timeout);\\n    });\\n  };\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    return new Promise(async (resolve, reject) => {\\n      const timeout = setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n\\n      try {\\n        const result = await fn(...args);\\n        resolve(result);\\n      } catch(err) {\\n        reject(err);\\n      }\\n      clearTimeout(timeout);\\n    });\\n  };\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529362,
                "title": "javascript-simple-solution-using-promise-then-catch-and-finally",
                "content": "# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn function(...args) {\\n        return new Promise((resolve, reject) => {\\n            const id = setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n            fn(...args).then(resolve).catch(reject).finally(() => clearTimeout(id))\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn function(...args) {\\n        return new Promise((resolve, reject) => {\\n            const id = setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n            fn(...args).then(resolve).catch(reject).finally(() => clearTimeout(id))\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529299,
                "title": "day-12-javascript-challenge",
                "content": "# Intuition\\nRace condition in Promise\\n\\n# Approach\\nUsed Promise.race for checking function call\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function (fn, t) {\\n    return async function (...args) {\\n        const returnPromise = fn(...args);\\n\\n        const timeLimitPromise = new Promise((_, reject) => {\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([returnPromise, timeLimitPromise])\\n    }\\n\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function (fn, t) {\\n    return async function (...args) {\\n        const returnPromise = fn(...args);\\n\\n        const timeLimitPromise = new Promise((_, reject) => {\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([returnPromise, timeLimitPromise])\\n    }\\n\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529294,
                "title": "time-limited-function-optimized-solution",
                "content": "# Intuition\\nThe problem requires us to implement a time-limited version of an asynchronous function. If the original function takes longer than the specified time limit to fulfill, it should reject with a \"Time Limit Exceeded\" message. Our task is to design an optimized solution that efficiently handles the time limit.\\n\\n# Approach\\nTo solve the problem, we can use the `Promise.race` method, which allows us to race two promises against each other: the result of the original function and a timer-based promise that rejects if the time limit is exceeded. By leveraging this approach, we can effectively control the execution time and handle the time limit with simplicity.\\n\\nIn the implementation, we define a higher-order function `timeLimit `that takes the original function `fn` and the time limit `t` as parameters. Inside this function, we return an asynchronous function that serves as the time-limited version of `fn`. Within this asynchronous function, we use `Promise.race` to race two promises: the result of `fn(...args)` and a new promise created using `setTimeout`. If the original function resolves or rejects before the timeout, the corresponding result or error will be returned. However, if the timeout occurs first, the promise will reject with the \"Time Limit Exceeded\" message.\\n\\n# Complexity\\n- Time complexity:\\n The time complexity of this solution depends on the execution time of the original function `fn` and the timeout duration `t`. In the worst case, if `fn` takes longer than `t` to complete, the time complexity will be determined by the longer of the two. Therefore, the time complexity can vary between **O(fn) and O(t)**, whichever is larger.\\n\\n\\n\\n- Space complexity:\\nThe space complexity of this solution is relatively low and remains constant. It primarily depends on the memory required to store the original function `fn`, the timeout duration `t`, and the arguments passed to the time-limited function. Hence, the space complexity is **O(1)**, as it does not grow significantly with the input size or time limit.\\n\\nPlease note that the actual time complexity will depend on the characteristics of the original function and the specified time limit, and it may vary in different scenarios.\\n# Code\\n```\\nconst timeLimit = (fn, t) => {\\n  return async function(...args) {\\n    return Promise.race([\\n      fn(...args),\\n      new Promise((_, reject) => setTimeout(() => reject(\"Time Limit Exceeded\"), t))\\n    ]);\\n  };\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst timeLimit = (fn, t) => {\\n  return async function(...args) {\\n    return Promise.race([\\n      fn(...args),\\n      new Promise((_, reject) => setTimeout(() => reject(\"Time Limit Exceeded\"), t))\\n    ]);\\n  };\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529278,
                "title": "easy-solution-with-promise-race",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        let firstPromise = fn(...args);\\n        let secondPromise = new Promise((resolve, reject) => \\n                            setTimeout(() => reject(\"Time Limit Exceeded\"), t));\\n        return Promise.race([firstPromise, secondPromise]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        let firstPromise = fn(...args);\\n        let secondPromise = new Promise((resolve, reject) => \\n                            setTimeout(() => reject(\"Time Limit Exceeded\"), t));\\n        return Promise.race([firstPromise, secondPromise]);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529252,
                "title": "easy-javascript-solution",
                "content": "# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject)=> {\\n           const timeout =  setTimeout(() => {\\n                reject(\"Time Limit Exceeded\")\\n            },t) \\n\\n            fn(...args)\\n                .then(resolve)\\n                .catch(reject)\\n                .finally(() => clearTimeout(timeout))\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject)=> {\\n           const timeout =  setTimeout(() => {\\n                reject(\"Time Limit Exceeded\")\\n            },t) \\n\\n            fn(...args)\\n                .then(resolve)\\n                .catch(reject)\\n                .finally(() => clearTimeout(timeout))\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529248,
                "title": "promise-time-limit-in-1",
                "content": "\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nconst timeLimit = function (fn, t) {\\n\\n    //  func is async and will return a Promise\\n  return async function (...args) {\\n    const timeout = new Promise((resolve, reject) => {\\n      setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n    });\\n\\n    //    //  first Promise to reject  win the race\\n    const result = Promise.race([fn(...args), timeout]);\\n\\n    try {\\n      const value = await result;\\n      return value;\\n    } catch (error) {\\n         // If there is any error, throw it as a number\\n      throw error;\\n    }\\n  };\\n};\\n\\nconst fn = async (n) => {\\n  await new Promise((res) => setTimeout(res, 100));\\n  return n * n;\\n};\\n\\nconst limited = timeLimit(fn, 50);\\nlimited(5)\\n  .then(console.log) // Will not be called because the promise is rejected\\n  .catch(console.error); // {\"rejected\":\"Time Limit Exceeded\",\"time\":50}\\n\\n\\n\\n  // Time comp : - O(1)\\n  // space comp : - O(1)\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nconst timeLimit = function (fn, t) {\\n\\n    //  func is async and will return a Promise\\n  return async function (...args) {\\n    const timeout = new Promise((resolve, reject) => {\\n      setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n    });\\n\\n    //    //  first Promise to reject  win the race\\n    const result = Promise.race([fn(...args), timeout]);\\n\\n    try {\\n      const value = await result;\\n      return value;\\n    } catch (error) {\\n         // If there is any error, throw it as a number\\n      throw error;\\n    }\\n  };\\n};\\n\\nconst fn = async (n) => {\\n  await new Promise((res) => setTimeout(res, 100));\\n  return n * n;\\n};\\n\\nconst limited = timeLimit(fn, 50);\\nlimited(5)\\n  .then(console.log) // Will not be called because the promise is rejected\\n  .catch(console.error); // {\"rejected\":\"Time Limit Exceeded\",\"time\":50}\\n\\n\\n\\n  // Time comp : - O(1)\\n  // space comp : - O(1)\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529218,
                "title": "typescript-solution-with-promise-race",
                "content": "```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nconst timeLimit = (fn: Fn, t: number): Fn => {\\n  return async (...args) => {\\n    const timeoutPromise = new Promise((_, reject) => {\\n      setTimeout(() => reject(\\'Time Limit Exceeded\\'), t);\\n    });\\n\\n    const result = await Promise.race([timeoutPromise, fn(...args)]);\\n    return result;\\n  };\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nconst timeLimit = (fn: Fn, t: number): Fn => {\\n  return async (...args) => {\\n    const timeoutPromise = new Promise((_, reject) => {\\n      setTimeout(() => reject(\\'Time Limit Exceeded\\'), t);\\n    });\\n\\n    const result = await Promise.race([timeoutPromise, fn(...args)]);\\n    return result;\\n  };\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529205,
                "title": "beats-98-74-with-promise-race",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const originalFnPromise = fn(...args);\\n\\n        const timeoutPromise = new Promise((_, reject) => {\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([originalFnPromise, timeoutPromise]);\\n    }\\n};\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\\n[Promise.race() documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race)\\n# Approach\\nThe timeLimit function takes in an asynchronous function and a time limit in milliseconds as its arguments. It returns a new function that has the same signature as the original function. This returned function is also an asynchronous function that can be called with any number of arguments.\\n\\nInside the returned function, a timeout promise is created using setTimeout with the specified time limit. If the original function takes longer than the time limit, the timeout promise will reject with the error message \\'Time Limit Exceeded\\'.\\n\\n** Then, Promise.race is used to race the original function with the timeout promise. The result of the race is stored in a variable called result.\\n\\nIf the original function resolves before the timeout promise, the timeout promise is still active and needs to be cleared using clearTimeout. Then, result is returned.\\n\\nIf the timeout promise rejects first, clearTimeout is called to cancel the timer, and the function rejects with the string \\'Time Limit Exceeded\\'. **\\n\\nOverall, the timeLimit function provides a simple and effective way to time-limit an asynchronous function and return a specific error message if the time limit is exceeded.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const originalFnPromise = fn(...args);\\n\\n        const timeoutPromise = new Promise((_, reject) => {\\n            setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\')\\n            }, t);\\n        })\\n\\n        return Promise.race([originalFnPromise, timeoutPromise]);\\n    }\\n};\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529142,
                "title": "simple-javascript-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return Promise.race([fn(...args), new Promise((resolve, reject) => {\\n            setTimeout(() => {reject(\"Time Limit Exceeded\")}, t);\\n        })]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return Promise.race([fn(...args), new Promise((resolve, reject) => {\\n            setTimeout(() => {reject(\"Time Limit Exceeded\")}, t);\\n        })]);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529093,
                "title": "typescript-solution",
                "content": "```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        return new Promise<any>((resolve, reject) => {\\n            const id = setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n            \\n            return fn(...args).then(resolve).catch(reject).finally(() => clearTimeout(id))\\n        })\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        return new Promise<any>((resolve, reject) => {\\n            const id = setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n            \\n            return fn(...args).then(resolve).catch(reject).finally(() => clearTimeout(id))\\n        })\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529087,
                "title": "with-promice",
                "content": "# With Promice\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            setTimeout (() => {\\n                reject(\"Time Limit Exceeded\");\\n            }, t);\\n            fn(...args).then(resolve).catch(reject);\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            setTimeout (() => {\\n                reject(\"Time Limit Exceeded\");\\n            }, t);\\n            fn(...args).then(resolve).catch(reject);\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529082,
                "title": "new-promise-javascript",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n            fn(...args).then(resolve, reject); \\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n            fn(...args).then(resolve, reject); \\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529035,
                "title": "easy-way-solution",
                "content": "Intuition\\nThe problem requires limiting the time a function takes to execute to prevent it from running indefinitely. To achieve this, we can use a timeout mechanism that rejects the promise if the function execution time exceeds the specified limit.\\n\\nApproach\\nWe can define a higher-order function timeLimit that takes in a function fn and a time limit t. The timeLimit function returns a new function that wraps the original function. This new function uses a Promise.race to race two promises:\\n\\nThe promise returned by the original function fn with its parameters.\\nA timeout promise that rejects with the message \"Time Limit Exceeded\" after t milliseconds.\\nIf the fn promise is resolved before the timeout, we clear the timeout using clearTimeout and return the resolved value. If the fn promise is rejected, we also clear the timeout and rethrow the error. If the timeout is triggered before the fn promise resolves, it rejects with the \"Time Limit Exceeded\" message.\\n\\nComplexity\\nTime complexity: The time complexity of this solution is O(1) because we are adding a constant amount of time complexity to each function call. The timeLimit function takes O(1) time, and the wrapped function takes the same time as the original function fn.\\nSpace complexity: The space complexity of this solution is O(1) because we are not creating any additional data structures.\\n#Code\\nconst timeLimit = (fn, t) => {\\n  return async (...args) => {\\n    let timeoutId;\\n    const timeoutPromise = new Promise((_, reject) => {\\n      timeoutId = setTimeout(() => {\\n        reject(\\'Time Limit Exceeded\\');\\n      }, t);\\n    });\\n\\n    try {\\n      const result = await Promise.race([fn(...args), timeoutPromise]);\\n      clearTimeout(timeoutId);\\n      return result;\\n    } catch (error) {\\n      clearTimeout(timeoutId);\\n      throw error;\\n    }\\n  };\\n};\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "Intuition\\nThe problem requires limiting the time a function takes to execute to prevent it from running indefinitely. To achieve this, we can use a timeout mechanism that rejects the promise if the function execution time exceeds the specified limit.\\n\\nApproach\\nWe can define a higher-order function timeLimit that takes in a function fn and a time limit t. The timeLimit function returns a new function that wraps the original function. This new function uses a Promise.race to race two promises:\\n\\nThe promise returned by the original function fn with its parameters.\\nA timeout promise that rejects with the message \"Time Limit Exceeded\" after t milliseconds.\\nIf the fn promise is resolved before the timeout, we clear the timeout using clearTimeout and return the resolved value. If the fn promise is rejected, we also clear the timeout and rethrow the error. If the timeout is triggered before the fn promise resolves, it rejects with the \"Time Limit Exceeded\" message.\\n\\nComplexity\\nTime complexity: The time complexity of this solution is O(1) because we are adding a constant amount of time complexity to each function call. The timeLimit function takes O(1) time, and the wrapped function takes the same time as the original function fn.\\nSpace complexity: The space complexity of this solution is O(1) because we are not creating any additional data structures.\\n#Code\\nconst timeLimit = (fn, t) => {\\n  return async (...args) => {\\n    let timeoutId;\\n    const timeoutPromise = new Promise((_, reject) => {\\n      timeoutId = setTimeout(() => {\\n        reject(\\'Time Limit Exceeded\\');\\n      }, t);\\n    });\\n\\n    try {\\n      const result = await Promise.race([fn(...args), timeoutPromise]);\\n      clearTimeout(timeoutId);\\n      return result;\\n    } catch (error) {\\n      clearTimeout(timeoutId);\\n      throw error;\\n    }\\n  };\\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3528977,
                "title": "using-promise-race-30-days-of-lc-javascript-challenge-js-and-ts-solution-day-11",
                "content": "## Intuition\\n- We use Javascript\\'s Promise.race function to choose between the timeout and the async function `fn`\\n- We create a `new Promise` `timeLimit` represent the countdown of the time limit `t`\\n- We create another variable to store represent the countdown of our function `fnTime`\\n- We then Promise.race `timeLimit` and `fnTime` and return whichever completes first\\n\\n## Code\\n``` javascript []\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        let timeLimit = new Promise((resolve, reject) => {setTimeout(() => reject(\"Time Limit Exceeded\"), t);});\\n        let fnTime = fn(...args)\\n        return Promise.race([timeLimit, fnTime])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\\n``` typescript []\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        let timeLimit = new Promise((resolve, reject) => {setTimeout(() => reject(\"Time Limit Exceeded\"), t);});\\n        let fnTime = fn(...args)\\n        return Promise.race([timeLimit, fnTime])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript []\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        let timeLimit = new Promise((resolve, reject) => {setTimeout(() => reject(\"Time Limit Exceeded\"), t);});\\n        let fnTime = fn(...args)\\n        return Promise.race([timeLimit, fnTime])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\n``` typescript []\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        let timeLimit = new Promise((resolve, reject) => {setTimeout(() => reject(\"Time Limit Exceeded\"), t);});\\n        let fnTime = fn(...args)\\n        return Promise.race([timeLimit, fnTime])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3528934,
                "title": "day-12-easy-solution-in-js",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve,reject)=>{\\n            setTimeout(()=>reject(\"Time Limit Exceeded\"),t);\\n            fn(...args).then(resolve).catch(reject);\\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve,reject)=>{\\n            setTimeout(()=>reject(\"Time Limit Exceeded\"),t);\\n            fn(...args).then(resolve).catch(reject);\\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3528882,
                "title": "easy-algorithm-explained-javascript",
                "content": "# Intuition:\\nThe timeLimit function returns a higher-order function that takes two arguments: a function (fn) and a time limit (t), and returns a promise that wraps the execution of the fn function. If the fn function takes longer than t milliseconds to execute, the promise is rejected with a \"Time Limit Exceeded\" error message.\\n\\n# Algorithm:\\n\\n1. Define a timeLimit function that takes two arguments:\\n   - fn: the function to execute within the time limit\\n   - t: the time limit in milliseconds\\n2. The timeLimit function returns a new function that takes an arbitrary number of arguments using the spread syntax ...args.\\n3. Within the new function, return a Promise that wraps the execution of the fn function.\\n4. Set a timeout function that rejects the promise with a \"Time Limit Exceeded\" error message after t milliseconds.\\n5. Execute the fn function with the spread syntax ...args.\\n6. If the fn function resolves its promise, then resolve the outer promise with the same value.\\n7. If the fn function rejects its promise, then reject the outer promise with the same reason.\\n# Time complexity:\\nThe time complexity of the timeLimit function is O(1), as it performs a constant amount of work and does not depend on the size of the input.\\n\\n# Space complexity:\\nThe space complexity of the timeLimit function is O(1), as it uses a constant amount of memory and does not depend on the size of the input. However, the memory usage may increase depending on the implementation of the fn function.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise( (resolve, reject) => {\\n            setTimeout( () => {\\n                reject(\"Time Limit Exceeded\");\\n            }, t);\\n            fn(...args)\\n            .then(resolve)\\n            .catch(reject);\\n        })\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise( (resolve, reject) => {\\n            setTimeout( () => {\\n                reject(\"Time Limit Exceeded\");\\n            }, t);\\n            fn(...args)\\n            .then(resolve)\\n            .catch(reject);\\n        })\\n        \\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3528870,
                "title": "promise-race-js-solution",
                "content": "# Promises\\n\\nA `Promise` is an object representing the `eventual completion / failure`  of an `asynchronous` operation and its resulting value\\n\\n`Promises` are helpful as it provides a way to handle `asynchronous` operations involving a sequences of steps, making us write cleaner, maintainable `asynchronous` code\\n\\n### Three State Promise\\n\\n`Promise` has three states:\\n\\n- `Pending` - This is the initial state of a `Promise` it is yet `fulfilled` nor `rejected`\\n- `Fulfilled` - The `Promise` has successfully been `resolved` . Thus, the `resulting value` is now available\\n- `Rejected` - The `Promises` has `failed`  . Thus, an `error` or the `rejected reasoning` is now available\\n\\nFrom `Pending` state `Promise` can transition to either being `Fulfilled` or  `Rejected` . Once, a Promise is `Fulfilled` or  `Rejected` , it will remain in either one of these states with its fixed value\\n\\n### Promise.race\\n\\nWe can use `Promise.race` to directly handle the resolved and rejected states of `promise` or `timeout` for our code. Whichever promise settles first will determine the returned promise state\\n\\n- If the `promise` resolves first, the `timeLimit function` will properly display the desired output value\\n- If the `timeout` resolves first, the `timeLimit function` will properly reject with `Time Limit Exceeded` message\\n\\n# Complexity\\n- Time complexity: O(1)\\n\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const promise = fn(...args)\\n        const timeout = new Promise((_, reject) => {\\n            setTimeout(() => {\\n                reject(\"Time Limit Exceeded\")\\n            },t)\\n        })\\n        return Promise.race([promise, timeout])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        const promise = fn(...args)\\n        const timeout = new Promise((_, reject) => {\\n            setTimeout(() => {\\n                reject(\"Time Limit Exceeded\")\\n            },t)\\n        })\\n        return Promise.race([promise, timeout])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3528848,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    const timeLimitPromise = new Promise((resolve, reject) => {\\n      setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n    });\\n    const returnedPromise = fn(...args);\\n    return Promise.race([timeLimitPromise, returnedPromise]);\\n  }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    const timeLimitPromise = new Promise((resolve, reject) => {\\n      setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n    });\\n    const returnedPromise = fn(...args);\\n    return Promise.race([timeLimitPromise, returnedPromise]);\\n  }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3528829,
                "title": "promise-solution-with-comments",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn function(...args) {\\n        return new Promise((resolve, reject) => {\\n            // If this timeout runs, the time limit is exceeded and we reject the promise\\n            const timeout = setTimeout(() => reject(\\'Time Limit Exceeded\\'), t);\\n\\n            // Call fn with the arguments passed in\\n            fn(...args).then((res) => {\\n                // If it resolves successfully we clear the timeout so it won\\'t reject the promise\\n                clearTimeout(timeout);\\n                // And we resolve the promise with the result of calling fn()\\n                resolve(res);\\n            // If fn throws an error, we reject the promise with the error\\n            }).catch((err) => reject(err));\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn function(...args) {\\n        return new Promise((resolve, reject) => {\\n            // If this timeout runs, the time limit is exceeded and we reject the promise\\n            const timeout = setTimeout(() => reject(\\'Time Limit Exceeded\\'), t);\\n\\n            // Call fn with the arguments passed in\\n            fn(...args).then((res) => {\\n                // If it resolves successfully we clear the timeout so it won\\'t reject the promise\\n                clearTimeout(timeout);\\n                // And we resolve the promise with the result of calling fn()\\n                resolve(res);\\n            // If fn throws an error, we reject the promise with the error\\n            }).catch((err) => reject(err));\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3528819,
                "title": "video-blog-deep-dive",
                "content": "**DAY 12 - 30 Days of LC JS\\n2637. Promise Time Limit**\\n\\n**Easy Explanation:**\\nhttps://youtu.be/mKAAdiddkkw\\nhttps://code-crusaders.epizy.com/day-12-promise-time-limit/\\n\\n**Code**\\n``` javascript []\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    return new Promise((resolve, reject) => {\\n      setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n      fn(...args)\\n        .then(resolve)\\n        .catch(reject);\\n    });\\n  };\\n};\\n\\n```\\n\\n**Happy Coding ^_^**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript []\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n  return async function(...args) {\\n    return new Promise((resolve, reject) => {\\n      setTimeout(() => {\\n        reject(\"Time Limit Exceeded\");\\n      }, t);\\n      fn(...args)\\n        .then(resolve)\\n        .catch(reject);\\n    });\\n  };\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3528786,
                "title": "day-12-javascript-typescript",
                "content": "# Code - JS\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        promise1 = new Promise((resolve, reject) => {setTimeout(() => resolve(fn(...args)), 0)});\\n        promise2 = new Promise((resolve, reject) => {setTimeout(() => reject(\"Time Limit Exceeded\"), t)});\\n        return Promise.race([promise1, promise2]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\\n# TS\\n```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        const promise1 = new Promise((resolve, reject) => {setTimeout(() => resolve(fn(...args)), 0)});\\n        const  promise2 = new Promise((resolve, reject) => {setTimeout(() => reject(\"Time Limit Exceeded\"), t)});\\n        return Promise.race([promise1, promise2]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        promise1 = new Promise((resolve, reject) => {setTimeout(() => resolve(fn(...args)), 0)});\\n        promise2 = new Promise((resolve, reject) => {setTimeout(() => reject(\"Time Limit Exceeded\"), t)});\\n        return Promise.race([promise1, promise2]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```\n```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        const promise1 = new Promise((resolve, reject) => {setTimeout(() => resolve(fn(...args)), 0)});\\n        const  promise2 = new Promise((resolve, reject) => {setTimeout(() => reject(\"Time Limit Exceeded\"), t)});\\n        return Promise.race([promise1, promise2]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3521517,
                "title": "promise-time-limit-js-two-promise-60-ms",
                "content": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {    \\n        p1 = new Promise((resolve, reject) => {setTimeout(() => resolve(fn(...args)), 0)})\\n        p2 = new Promise((resolve, reject) => {setTimeout(() => reject(\"Time Limit Exceeded\"), t)})\\n                        \\n        return Promise.race([p1, p2])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {    \\n        p1 = new Promise((resolve, reject) => {setTimeout(() => resolve(fn(...args)), 0)})\\n        p2 = new Promise((resolve, reject) => {setTimeout(() => reject(\"Time Limit Exceeded\"), t)})\\n                        \\n        return Promise.race([p1, p2])\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3515831,
                "title": "ts-promise-race-vs-returning-a-new-promise-52ms-42-8mb",
                "content": "This is a nice challenge, directly between the easier [sleep](https://leetcode.com/problems/sleep/) ([cracked here](https://leetcode.com/problems/sleep/solutions/3495914/)) and the more challenging [promise pool](https://leetcode.com/problems/promise-pool/) ([cracked here](https://leetcode.com/problems/promise-pool/solutions/3534230/)): definitely consider solving all of them to consolidate!\\n\\nFirst, let\\'s go with the easiest approach of having two promises running at the same time:\\n* `p1` will be our rejection promise, \"rejecting\" the planned message after `t` milliseconds;\\n* `p2` will be our resolve promise.\\n\\nWhat makes us solve this problem easily is the built-in `Promise` method [`.race()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race): unlike [`.any`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/any) (click either to read the documentation on MDN), this will register both resolutions and rejections, giving us the result of the first one to happen, we want.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```ts\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nconst timeLimit = (fn: Fn, t: number): Fn => {\\n\\treturn async function(...args) {\\n        // rejection promise\\n        const p1 = new Promise((res, rej) => setTimeout(() => rej(\"Time Limit Exceeded\"), t));\\n        // resolve promise\\n        const p2 = new Promise((res) => res(fn(...args)));\\n        return Promise.race([p1, p2])\\n    }\\n};\\n```\\n\\nAnd since `async`-`await` is basically still syntactic sugar to get a promise effect, we don\\'t even need to wrap `p2` into a new one:\\n\\n```ts\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nconst timeLimit = (fn: Fn, t: number): Fn => {\\n\\treturn async function(...args) {\\n        // rejection promise\\n        const p1 = new Promise((res, rej) => setTimeout(() => rej(\"Time Limit Exceeded\"), t));\\n        // resolve promise\\n        const p2 = fn(...args);\\n        return Promise.race([p1, p2])\\n    }\\n};\\n```\\n\\nAlternatively we can just `return` a new `Promise` with inside an instruction to time out in `t` milliseconds and reject, followed by the call to our function `fn` with the matching resolution and rejection clauses (We need the latter for the fourth case, that tests that explicitly):\\n\\n```ts\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nconst timeLimit = (fn: Fn, t: number): Fn => {\\n\\treturn async (...args) => {\\n        return new Promise((res, rej) => {\\n            setTimeout(() => rej(\"Time Limit Exceeded\"), t);\\n            fn(...args).then(res).catch(rej);\\n        });\\n    }\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```ts\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nconst timeLimit = (fn: Fn, t: number): Fn => {\\n\\treturn async function(...args) {\\n        // rejection promise\\n        const p1 = new Promise((res, rej) => setTimeout(() => rej(\"Time Limit Exceeded\"), t));\\n        // resolve promise\\n        const p2 = new Promise((res) => res(fn(...args)));\\n        return Promise.race([p1, p2])\\n    }\\n};\\n```\n```ts\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nconst timeLimit = (fn: Fn, t: number): Fn => {\\n\\treturn async function(...args) {\\n        // rejection promise\\n        const p1 = new Promise((res, rej) => setTimeout(() => rej(\"Time Limit Exceeded\"), t));\\n        // resolve promise\\n        const p2 = fn(...args);\\n        return Promise.race([p1, p2])\\n    }\\n};\\n```\n```ts\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nconst timeLimit = (fn: Fn, t: number): Fn => {\\n\\treturn async (...args) => {\\n        return new Promise((res, rej) => {\\n            setTimeout(() => rej(\"Time Limit Exceeded\"), t);\\n            fn(...args).then(res).catch(rej);\\n        });\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3491503,
                "title": "using-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve,reject)=>{\\n            setTimeout(()=>reject(\"Time Limit Exceeded\"), t);\\n            fn(...args).then(resolve,reject);\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve,reject)=>{\\n            setTimeout(()=>reject(\"Time Limit Exceeded\"), t);\\n            fn(...args).then(resolve,reject);\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3491055,
                "title": "typescript-3-lines",
                "content": "\\n```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n    const timeLimit = new Promise((r, rej) => setTimeout(() => rej(\"Time Limit Exceeded\"), t));\\n\\treturn async function(...args) {\\n        return await Promise.race([fn(...args), timeLimit]) \\n    }\\n};\\n",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "\\n```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n    const timeLimit = new Promise((r, rej) => setTimeout(() => rej(\"Time Limit Exceeded\"), t));\\n\\treturn async function(...args) {\\n        return await Promise.race([fn(...args), timeLimit]) \\n    }\\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3488562,
                "title": "beginner-friendly-solution-detailed-explanation-about-promises",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Promises is object that will return a resolve - if fulfilled or reject - if failed or rejected. \\n- In this case, we are given a function with a set TimeOut, and a `t` number variable.\\n- We need to test wheter if the function given can be finished within `t` time\\n- Basic approach will be comparing the `t` with the time in the function, however we do not have the variable of time in the function because it uses `...args` as props.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Ways to do it is to make a promise with a setTimeout, that will return a  reject if not fulfilled. \\n2. We will delete the promise (setTimeout) if the function  given are executed first, using `.finally(()=> clearTimeout(timeoutId));` executed if the given function runs first\\n\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n    return async function(...args) {\\n/**Creating new Promises, with a setTimeout of t */\\n        return new Promise((resolve, reject) => {\\n            const timeoutId = setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n            fn(...args).then(resolve).catch(reject).finally(()=> clearTimeout(timeoutId));\\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n    return async function(...args) {\\n/**Creating new Promises, with a setTimeout of t */\\n        return new Promise((resolve, reject) => {\\n            const timeoutId = setTimeout(() => reject(\"Time Limit Exceeded\"), t);\\n            fn(...args).then(resolve).catch(reject).finally(()=> clearTimeout(timeoutId));\\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3479510,
                "title": "typescript-simple-solution",
                "content": "```typescript\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n            fn(...args).then(resolve).catch(reject)\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```typescript\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            setTimeout(() => reject(\"Time Limit Exceeded\"), t)\\n            fn(...args).then(resolve).catch(reject)\\n        })\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3453361,
                "title": "using-simple-then-and-catch",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((res, rej)=>{\\n            setTimeout(()=>{\\n                rej(\"Time Limit Exceeded\");\\n            }, t);\\n            fn(...args).then((r)=>{\\n                res(r)\\n            }).catch((e)=>{\\n                rej(e)\\n            })\\n        })        \\n        \\n\\n\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((res, rej)=>{\\n            setTimeout(()=>{\\n                rej(\"Time Limit Exceeded\");\\n            }, t);\\n            fn(...args).then((r)=>{\\n                res(r)\\n            }).catch((e)=>{\\n                rej(e)\\n            })\\n        })        \\n        \\n\\n\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3452980,
                "title": "javascript-ez-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            const timer = setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\');\\n            }, t);\\n            fn(...args).then((result) => {\\n                clearTimeout(timer);\\n                resolve(result);\\n            }).catch((err) => {\\n                clearTimeout(timer);\\n                reject(err);\\n            });\\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        return new Promise((resolve, reject) => {\\n            const timer = setTimeout(() => {\\n                reject(\\'Time Limit Exceeded\\');\\n            }, t);\\n            fn(...args).then((result) => {\\n                clearTimeout(timer);\\n                resolve(result);\\n            }).catch((err) => {\\n                clearTimeout(timer);\\n                reject(err);\\n            });\\n        });\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3444251,
                "title": "one-liner",
                "content": "```\\nvar timeLimit = function(f, t) {\\n\\treturn async function(...args) {\\n        return Promise.race([f(...args), new Promise((_, err) => setTimeout(() => err(\"Time Limit Exceeded\"), t))]);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar timeLimit = function(f, t) {\\n\\treturn async function(...args) {\\n        return Promise.race([f(...args), new Promise((_, err) => setTimeout(() => err(\"Time Limit Exceeded\"), t))]);\\n    }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3441155,
                "title": "a-bit-better-memory-usage",
                "content": "# Intuition\\nI have to create a function which return first Promise resolve or reject  depends on time limit.\\n\\n# Approach\\nmy aproach is a little different from others. I moved **maxDelay** function to the top of **timeLimit** function because it creates only when we call first time **timelimit** function and we avoid creating **maxDelay** function each call.\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nconst timeLimit = (fn, t) => {\\n  const maxDelay = new Promise((_, rj) => setTimeout(() => {\\n    rj(\\'Time Limit Exceeded\\');\\n  }, t));\\n\\treturn async function(...args) {\\n    const res = await Promise.race([fn(...args), maxDelay]);\\n    return res;\\n  }\\n};\\n\\nconst limit = timeLimit(fn, t);\\n// creates maxDelay promise which already have t - time\\nlimit(5);\\n// by calling limit we just wait by method .race which one is faster and return\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst timeLimit = (fn, t) => {\\n  const maxDelay = new Promise((_, rj) => setTimeout(() => {\\n    rj(\\'Time Limit Exceeded\\');\\n  }, t));\\n\\treturn async function(...args) {\\n    const res = await Promise.race([fn(...args), maxDelay]);\\n    return res;\\n  }\\n};\\n\\nconst limit = timeLimit(fn, t);\\n// creates maxDelay promise which already have t - time\\nlimit(5);\\n// by calling limit we just wait by method .race which one is faster and return\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3440059,
                "title": "with-arrow-function-and-promise-race-code-is-more-readable",
                "content": "# Approach\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = (fn, t) => (...args) =>\\n    Promise.race([\\n        fn(...args),\\n        new Promise((_, reject) => setTimeout(() => reject(\\'Time Limit Exceeded\\'), t))\\n    ])\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = (fn, t) => (...args) =>\\n    Promise.race([\\n        fn(...args),\\n        new Promise((_, reject) => setTimeout(() => reject(\\'Time Limit Exceeded\\'), t))\\n    ])\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3436392,
                "title": "10-short-typesrcipt-click",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        let rejectPromise = new Promise<any>((res, rej) => setTimeout(() => rej(\"Time Limit Exceeded\"), t))\\n        return Promise.race([fn(...args), rejectPromise]); \\n    }\\n};\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...params: any[]) => Promise<any>;\\n\\nfunction timeLimit(fn: Fn, t: number): Fn {\\n\\treturn async function(...args) {\\n        let rejectPromise = new Promise<any>((res, rej) => setTimeout(() => rej(\"Time Limit Exceeded\"), t))\\n        return Promise.race([fn(...args), rejectPromise]); \\n    }\\n};\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3433043,
                "title": "javascript-simplest-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        let a = fn(...args);\\n        let b = new Promise((res,rej)=>{\\n            setTimeout(()=>{\\n                rej(\"Time Limit Exceeded\");\\n            },t);\\n        })\\n        return Promise.race([a,b]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {number} t\\n * @return {Function}\\n */\\nvar timeLimit = function(fn, t) {\\n\\treturn async function(...args) {\\n        let a = fn(...args);\\n        let b = new Promise((res,rej)=>{\\n            setTimeout(()=>{\\n                rej(\"Time Limit Exceeded\");\\n            },t);\\n        })\\n        return Promise.race([a,b]);\\n    }\\n};\\n\\n/**\\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\\n */\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1896498,
                "content": [
                    {
                        "username": "boboboy_",
                        "content": "I think Difficulty for this problem should be medium."
                    },
                    {
                        "username": "codemode365",
                        "content": "So, it is\\n"
                    },
                    {
                        "username": "gkucmierz",
                        "content": " `(node:30) Warning: Accessing non-existent property \\'ListNode\\' of module exports inside circular dependency\\n(Use `nodejs run --trace-warnings ...` to show where the warning was created)\\n(node:30) Warning: Accessing non-existent property \\'TreeNode\\' of module exports inside circular dependency\\n(node:30) Warning: Accessing non-existent property \\'NestedInteger\\' of module exports inside circular dependency\\nnode:internal/process/promises:246\\n          triggerUncaughtException(err, true /* fromPromise */);\\n          ^\\n[UnhandledPromiseRejection: This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). The promise rejected with the reason \"Error\".] {\\n  code: \\'ERR_UNHANDLED_REJECTION\\'\\n}`\\n\\nI can\\'t understand this error. What can be wrong in my code?"
                    },
                    {
                        "username": "VictorKasap",
                        "content": "same"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "[@gkucmierz](/gkucmierz) Ok, I added 4 case error handling and it works.\\nBut Why 1, 2, 3 case didn\\'t worked without this?\\nI think these tests are not correctly separated.\\n"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "[@terryjiang1996](/terryjiang1996) No, this is my solution which works perfect outside leetcode:\n\nhttps://instacode.app/run/FDDGHsDsGcBcAJYEsC2BTAMqpCC88AKAM0gBpEBKeXAPngG9gBIAJzVgFcXJCA6fgIYsA5tCq14kNAHd4ABRbgUSaGgIE20cABsAbmnJsAVmlCxxdRvGvxt7eGkgATavCIDtqgNzAb8VbAAKqho4Byw6hYMvn4Ozq6wLBxoPrHwxqYRAOTB6PBYyggAogAeoGhoTpVZFKk2AL7k5nXWJAT8vEKiFLywABaOGmjQ1JYxfkhEhI5OVGyc3C02MwlJKeM2mjr6Q2JL9bUxBz71PmBQcPBO4EUsiiyryfAA-PAADPAAXPAAjGcQMAQJFcAmgAE9IKBCJAovR4DEBNIBDhJDJ5IplKpdqN-OxcqFwrtyABWN4fAC0Vxud3ALAotXh1nmXB4PAAVJIvPDTiAAZdYNoEiECjhiGR4KS3odgARQRCoQRYTFEmDon4+QgHvhEciEAKCD8AEyHdUXHRoXjacDCAhZTRZQwm+D1eCgASwUB9aZUKw2Pnmy3W21oO4OhxO+rAA6Ks5AA"
                    },
                    {
                        "username": "iRONiCBAT7",
                        "content": "same error encountered"
                    },
                    {
                        "username": "meet2674shah",
                        "content": "[@gkucmierz](/gkucmierz)  the function which is time limited might also throw an error. So, you need to catch it. (like test case 4)"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@Grzegorz](/gkucmierz) I'm pretty sure you're throwing the error from inside the setTimeout callback function. Scheduled functions with setTimeout / setInterval are executed in the event loop (scheduled as macrotasks). That's why you're getting the \"unhandled rejection\" error, because you have no error handler there. I'm pretty sure you can't rely on async/await for this, you have to use the Promise constructor which passes you a reject callback that you can use for this purpose."
                    },
                    {
                        "username": "terryjiang1996",
                        "content": "[@gkucmierz](/gkucmierz) I get the same error. Have you found the solution for this?"
                    },
                    {
                        "username": "user3540qH",
                        "content": "[@gkucmierz](/gkucmierz) try the 4th test"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "It is working correctly with test on my local machine:\n\n```\nconst fn = async (n) => { \n  await new Promise(res => setTimeout(res, 100)); \n  return n * n;\n};\n\n// result:\nconst limited = timeLimit(fn, 150);\n// tle:\n// const limited = timeLimit(fn, 50);\n\nlimited(11).then(res => {\n  console.log('res', res);\n}).catch(err => {\n  console.log('err', err);\n});\n```"
                    },
                    {
                        "username": "jayshah28",
                        "content": "I\\'m amazed about how deeply Leetcode is touching every concept so deeply by providing Editorials. Looks like the Javascript maker\\'s itself is making this. -_-"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 12 : Done Solving Todays Question .\\n\\n`Tip : Try to resolve promises individually and then return the fastest promise resolved with the help of \"Pomise.race\"`"
                    },
                    {
                        "username": "burber",
                        "content": "Buenos dias, \nI used the race solution after a day break from losing my sanity. I have a question though, as I was reading through documentation on Promises, I noticed that promises can be constructed with \"new Promise((resolve, reject) . . .\"  In my mind, I assumed you could use both resolve and reject in the promise, and it would just return whichever came first. This did not work though. Is there something I could have done wrong? Is it even possible to call both of them in one promise?"
                    },
                    {
                        "username": "sonterix",
                        "content": "I wouldn\\'t say this is an Easy one but the challenge is cool!"
                    },
                    {
                        "username": "shahan989",
                        "content": "good question for revision !"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Thank you Leetcode, for me who I am a beginner in typescript, this trip has been trully instructive. I have to study a lot for every challenge."
                    },
                    {
                        "username": "Preethi1235",
                        "content": "Given function is asynchronous , hence it can run in background .\\n if it  was a synchronous function , we could not time limit it.\\nCorrect me if I\\'m wrong."
                    },
                    {
                        "username": "vkavek",
                        "content": "You use async await, which puts it in a \\'synchronous state\\'."
                    }
                ]
            },
            {
                "id": 1862654,
                "content": [
                    {
                        "username": "boboboy_",
                        "content": "I think Difficulty for this problem should be medium."
                    },
                    {
                        "username": "codemode365",
                        "content": "So, it is\\n"
                    },
                    {
                        "username": "gkucmierz",
                        "content": " `(node:30) Warning: Accessing non-existent property \\'ListNode\\' of module exports inside circular dependency\\n(Use `nodejs run --trace-warnings ...` to show where the warning was created)\\n(node:30) Warning: Accessing non-existent property \\'TreeNode\\' of module exports inside circular dependency\\n(node:30) Warning: Accessing non-existent property \\'NestedInteger\\' of module exports inside circular dependency\\nnode:internal/process/promises:246\\n          triggerUncaughtException(err, true /* fromPromise */);\\n          ^\\n[UnhandledPromiseRejection: This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). The promise rejected with the reason \"Error\".] {\\n  code: \\'ERR_UNHANDLED_REJECTION\\'\\n}`\\n\\nI can\\'t understand this error. What can be wrong in my code?"
                    },
                    {
                        "username": "VictorKasap",
                        "content": "same"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "[@gkucmierz](/gkucmierz) Ok, I added 4 case error handling and it works.\\nBut Why 1, 2, 3 case didn\\'t worked without this?\\nI think these tests are not correctly separated.\\n"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "[@terryjiang1996](/terryjiang1996) No, this is my solution which works perfect outside leetcode:\n\nhttps://instacode.app/run/FDDGHsDsGcBcAJYEsC2BTAMqpCC88AKAM0gBpEBKeXAPngG9gBIAJzVgFcXJCA6fgIYsA5tCq14kNAHd4ABRbgUSaGgIE20cABsAbmnJsAVmlCxxdRvGvxt7eGkgATavCIDtqgNzAb8VbAAKqho4Byw6hYMvn4Ozq6wLBxoPrHwxqYRAOTB6PBYyggAogAeoGhoTpVZFKk2AL7k5nXWJAT8vEKiFLywABaOGmjQ1JYxfkhEhI5OVGyc3C02MwlJKeM2mjr6Q2JL9bUxBz71PmBQcPBO4EUsiiyryfAA-PAADPAAXPAAjGcQMAQJFcAmgAE9IKBCJAovR4DEBNIBDhJDJ5IplKpdqN-OxcqFwrtyABWN4fAC0Vxud3ALAotXh1nmXB4PAAVJIvPDTiAAZdYNoEiECjhiGR4KS3odgARQRCoQRYTFEmDon4+QgHvhEciEAKCD8AEyHdUXHRoXjacDCAhZTRZQwm+D1eCgASwUB9aZUKw2Pnmy3W21oO4OhxO+rAA6Ks5AA"
                    },
                    {
                        "username": "iRONiCBAT7",
                        "content": "same error encountered"
                    },
                    {
                        "username": "meet2674shah",
                        "content": "[@gkucmierz](/gkucmierz)  the function which is time limited might also throw an error. So, you need to catch it. (like test case 4)"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@Grzegorz](/gkucmierz) I'm pretty sure you're throwing the error from inside the setTimeout callback function. Scheduled functions with setTimeout / setInterval are executed in the event loop (scheduled as macrotasks). That's why you're getting the \"unhandled rejection\" error, because you have no error handler there. I'm pretty sure you can't rely on async/await for this, you have to use the Promise constructor which passes you a reject callback that you can use for this purpose."
                    },
                    {
                        "username": "terryjiang1996",
                        "content": "[@gkucmierz](/gkucmierz) I get the same error. Have you found the solution for this?"
                    },
                    {
                        "username": "user3540qH",
                        "content": "[@gkucmierz](/gkucmierz) try the 4th test"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "It is working correctly with test on my local machine:\n\n```\nconst fn = async (n) => { \n  await new Promise(res => setTimeout(res, 100)); \n  return n * n;\n};\n\n// result:\nconst limited = timeLimit(fn, 150);\n// tle:\n// const limited = timeLimit(fn, 50);\n\nlimited(11).then(res => {\n  console.log('res', res);\n}).catch(err => {\n  console.log('err', err);\n});\n```"
                    },
                    {
                        "username": "jayshah28",
                        "content": "I\\'m amazed about how deeply Leetcode is touching every concept so deeply by providing Editorials. Looks like the Javascript maker\\'s itself is making this. -_-"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 12 : Done Solving Todays Question .\\n\\n`Tip : Try to resolve promises individually and then return the fastest promise resolved with the help of \"Pomise.race\"`"
                    },
                    {
                        "username": "burber",
                        "content": "Buenos dias, \nI used the race solution after a day break from losing my sanity. I have a question though, as I was reading through documentation on Promises, I noticed that promises can be constructed with \"new Promise((resolve, reject) . . .\"  In my mind, I assumed you could use both resolve and reject in the promise, and it would just return whichever came first. This did not work though. Is there something I could have done wrong? Is it even possible to call both of them in one promise?"
                    },
                    {
                        "username": "sonterix",
                        "content": "I wouldn\\'t say this is an Easy one but the challenge is cool!"
                    },
                    {
                        "username": "shahan989",
                        "content": "good question for revision !"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Thank you Leetcode, for me who I am a beginner in typescript, this trip has been trully instructive. I have to study a lot for every challenge."
                    },
                    {
                        "username": "Preethi1235",
                        "content": "Given function is asynchronous , hence it can run in background .\\n if it  was a synchronous function , we could not time limit it.\\nCorrect me if I\\'m wrong."
                    },
                    {
                        "username": "vkavek",
                        "content": "You use async await, which puts it in a \\'synchronous state\\'."
                    }
                ]
            },
            {
                "id": 1895484,
                "content": [
                    {
                        "username": "boboboy_",
                        "content": "I think Difficulty for this problem should be medium."
                    },
                    {
                        "username": "codemode365",
                        "content": "So, it is\\n"
                    },
                    {
                        "username": "gkucmierz",
                        "content": " `(node:30) Warning: Accessing non-existent property \\'ListNode\\' of module exports inside circular dependency\\n(Use `nodejs run --trace-warnings ...` to show where the warning was created)\\n(node:30) Warning: Accessing non-existent property \\'TreeNode\\' of module exports inside circular dependency\\n(node:30) Warning: Accessing non-existent property \\'NestedInteger\\' of module exports inside circular dependency\\nnode:internal/process/promises:246\\n          triggerUncaughtException(err, true /* fromPromise */);\\n          ^\\n[UnhandledPromiseRejection: This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). The promise rejected with the reason \"Error\".] {\\n  code: \\'ERR_UNHANDLED_REJECTION\\'\\n}`\\n\\nI can\\'t understand this error. What can be wrong in my code?"
                    },
                    {
                        "username": "VictorKasap",
                        "content": "same"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "[@gkucmierz](/gkucmierz) Ok, I added 4 case error handling and it works.\\nBut Why 1, 2, 3 case didn\\'t worked without this?\\nI think these tests are not correctly separated.\\n"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "[@terryjiang1996](/terryjiang1996) No, this is my solution which works perfect outside leetcode:\n\nhttps://instacode.app/run/FDDGHsDsGcBcAJYEsC2BTAMqpCC88AKAM0gBpEBKeXAPngG9gBIAJzVgFcXJCA6fgIYsA5tCq14kNAHd4ABRbgUSaGgIE20cABsAbmnJsAVmlCxxdRvGvxt7eGkgATavCIDtqgNzAb8VbAAKqho4Byw6hYMvn4Ozq6wLBxoPrHwxqYRAOTB6PBYyggAogAeoGhoTpVZFKk2AL7k5nXWJAT8vEKiFLywABaOGmjQ1JYxfkhEhI5OVGyc3C02MwlJKeM2mjr6Q2JL9bUxBz71PmBQcPBO4EUsiiyryfAA-PAADPAAXPAAjGcQMAQJFcAmgAE9IKBCJAovR4DEBNIBDhJDJ5IplKpdqN-OxcqFwrtyABWN4fAC0Vxud3ALAotXh1nmXB4PAAVJIvPDTiAAZdYNoEiECjhiGR4KS3odgARQRCoQRYTFEmDon4+QgHvhEciEAKCD8AEyHdUXHRoXjacDCAhZTRZQwm+D1eCgASwUB9aZUKw2Pnmy3W21oO4OhxO+rAA6Ks5AA"
                    },
                    {
                        "username": "iRONiCBAT7",
                        "content": "same error encountered"
                    },
                    {
                        "username": "meet2674shah",
                        "content": "[@gkucmierz](/gkucmierz)  the function which is time limited might also throw an error. So, you need to catch it. (like test case 4)"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@Grzegorz](/gkucmierz) I'm pretty sure you're throwing the error from inside the setTimeout callback function. Scheduled functions with setTimeout / setInterval are executed in the event loop (scheduled as macrotasks). That's why you're getting the \"unhandled rejection\" error, because you have no error handler there. I'm pretty sure you can't rely on async/await for this, you have to use the Promise constructor which passes you a reject callback that you can use for this purpose."
                    },
                    {
                        "username": "terryjiang1996",
                        "content": "[@gkucmierz](/gkucmierz) I get the same error. Have you found the solution for this?"
                    },
                    {
                        "username": "user3540qH",
                        "content": "[@gkucmierz](/gkucmierz) try the 4th test"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "It is working correctly with test on my local machine:\n\n```\nconst fn = async (n) => { \n  await new Promise(res => setTimeout(res, 100)); \n  return n * n;\n};\n\n// result:\nconst limited = timeLimit(fn, 150);\n// tle:\n// const limited = timeLimit(fn, 50);\n\nlimited(11).then(res => {\n  console.log('res', res);\n}).catch(err => {\n  console.log('err', err);\n});\n```"
                    },
                    {
                        "username": "jayshah28",
                        "content": "I\\'m amazed about how deeply Leetcode is touching every concept so deeply by providing Editorials. Looks like the Javascript maker\\'s itself is making this. -_-"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 12 : Done Solving Todays Question .\\n\\n`Tip : Try to resolve promises individually and then return the fastest promise resolved with the help of \"Pomise.race\"`"
                    },
                    {
                        "username": "burber",
                        "content": "Buenos dias, \nI used the race solution after a day break from losing my sanity. I have a question though, as I was reading through documentation on Promises, I noticed that promises can be constructed with \"new Promise((resolve, reject) . . .\"  In my mind, I assumed you could use both resolve and reject in the promise, and it would just return whichever came first. This did not work though. Is there something I could have done wrong? Is it even possible to call both of them in one promise?"
                    },
                    {
                        "username": "sonterix",
                        "content": "I wouldn\\'t say this is an Easy one but the challenge is cool!"
                    },
                    {
                        "username": "shahan989",
                        "content": "good question for revision !"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Thank you Leetcode, for me who I am a beginner in typescript, this trip has been trully instructive. I have to study a lot for every challenge."
                    },
                    {
                        "username": "Preethi1235",
                        "content": "Given function is asynchronous , hence it can run in background .\\n if it  was a synchronous function , we could not time limit it.\\nCorrect me if I\\'m wrong."
                    },
                    {
                        "username": "vkavek",
                        "content": "You use async await, which puts it in a \\'synchronous state\\'."
                    }
                ]
            },
            {
                "id": 1895738,
                "content": [
                    {
                        "username": "boboboy_",
                        "content": "I think Difficulty for this problem should be medium."
                    },
                    {
                        "username": "codemode365",
                        "content": "So, it is\\n"
                    },
                    {
                        "username": "gkucmierz",
                        "content": " `(node:30) Warning: Accessing non-existent property \\'ListNode\\' of module exports inside circular dependency\\n(Use `nodejs run --trace-warnings ...` to show where the warning was created)\\n(node:30) Warning: Accessing non-existent property \\'TreeNode\\' of module exports inside circular dependency\\n(node:30) Warning: Accessing non-existent property \\'NestedInteger\\' of module exports inside circular dependency\\nnode:internal/process/promises:246\\n          triggerUncaughtException(err, true /* fromPromise */);\\n          ^\\n[UnhandledPromiseRejection: This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). The promise rejected with the reason \"Error\".] {\\n  code: \\'ERR_UNHANDLED_REJECTION\\'\\n}`\\n\\nI can\\'t understand this error. What can be wrong in my code?"
                    },
                    {
                        "username": "VictorKasap",
                        "content": "same"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "[@gkucmierz](/gkucmierz) Ok, I added 4 case error handling and it works.\\nBut Why 1, 2, 3 case didn\\'t worked without this?\\nI think these tests are not correctly separated.\\n"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "[@terryjiang1996](/terryjiang1996) No, this is my solution which works perfect outside leetcode:\n\nhttps://instacode.app/run/FDDGHsDsGcBcAJYEsC2BTAMqpCC88AKAM0gBpEBKeXAPngG9gBIAJzVgFcXJCA6fgIYsA5tCq14kNAHd4ABRbgUSaGgIE20cABsAbmnJsAVmlCxxdRvGvxt7eGkgATavCIDtqgNzAb8VbAAKqho4Byw6hYMvn4Ozq6wLBxoPrHwxqYRAOTB6PBYyggAogAeoGhoTpVZFKk2AL7k5nXWJAT8vEKiFLywABaOGmjQ1JYxfkhEhI5OVGyc3C02MwlJKeM2mjr6Q2JL9bUxBz71PmBQcPBO4EUsiiyryfAA-PAADPAAXPAAjGcQMAQJFcAmgAE9IKBCJAovR4DEBNIBDhJDJ5IplKpdqN-OxcqFwrtyABWN4fAC0Vxud3ALAotXh1nmXB4PAAVJIvPDTiAAZdYNoEiECjhiGR4KS3odgARQRCoQRYTFEmDon4+QgHvhEciEAKCD8AEyHdUXHRoXjacDCAhZTRZQwm+D1eCgASwUB9aZUKw2Pnmy3W21oO4OhxO+rAA6Ks5AA"
                    },
                    {
                        "username": "iRONiCBAT7",
                        "content": "same error encountered"
                    },
                    {
                        "username": "meet2674shah",
                        "content": "[@gkucmierz](/gkucmierz)  the function which is time limited might also throw an error. So, you need to catch it. (like test case 4)"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@Grzegorz](/gkucmierz) I'm pretty sure you're throwing the error from inside the setTimeout callback function. Scheduled functions with setTimeout / setInterval are executed in the event loop (scheduled as macrotasks). That's why you're getting the \"unhandled rejection\" error, because you have no error handler there. I'm pretty sure you can't rely on async/await for this, you have to use the Promise constructor which passes you a reject callback that you can use for this purpose."
                    },
                    {
                        "username": "terryjiang1996",
                        "content": "[@gkucmierz](/gkucmierz) I get the same error. Have you found the solution for this?"
                    },
                    {
                        "username": "user3540qH",
                        "content": "[@gkucmierz](/gkucmierz) try the 4th test"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "It is working correctly with test on my local machine:\n\n```\nconst fn = async (n) => { \n  await new Promise(res => setTimeout(res, 100)); \n  return n * n;\n};\n\n// result:\nconst limited = timeLimit(fn, 150);\n// tle:\n// const limited = timeLimit(fn, 50);\n\nlimited(11).then(res => {\n  console.log('res', res);\n}).catch(err => {\n  console.log('err', err);\n});\n```"
                    },
                    {
                        "username": "jayshah28",
                        "content": "I\\'m amazed about how deeply Leetcode is touching every concept so deeply by providing Editorials. Looks like the Javascript maker\\'s itself is making this. -_-"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 12 : Done Solving Todays Question .\\n\\n`Tip : Try to resolve promises individually and then return the fastest promise resolved with the help of \"Pomise.race\"`"
                    },
                    {
                        "username": "burber",
                        "content": "Buenos dias, \nI used the race solution after a day break from losing my sanity. I have a question though, as I was reading through documentation on Promises, I noticed that promises can be constructed with \"new Promise((resolve, reject) . . .\"  In my mind, I assumed you could use both resolve and reject in the promise, and it would just return whichever came first. This did not work though. Is there something I could have done wrong? Is it even possible to call both of them in one promise?"
                    },
                    {
                        "username": "sonterix",
                        "content": "I wouldn\\'t say this is an Easy one but the challenge is cool!"
                    },
                    {
                        "username": "shahan989",
                        "content": "good question for revision !"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Thank you Leetcode, for me who I am a beginner in typescript, this trip has been trully instructive. I have to study a lot for every challenge."
                    },
                    {
                        "username": "Preethi1235",
                        "content": "Given function is asynchronous , hence it can run in background .\\n if it  was a synchronous function , we could not time limit it.\\nCorrect me if I\\'m wrong."
                    },
                    {
                        "username": "vkavek",
                        "content": "You use async await, which puts it in a \\'synchronous state\\'."
                    }
                ]
            },
            {
                "id": 1965010,
                "content": [
                    {
                        "username": "boboboy_",
                        "content": "I think Difficulty for this problem should be medium."
                    },
                    {
                        "username": "codemode365",
                        "content": "So, it is\\n"
                    },
                    {
                        "username": "gkucmierz",
                        "content": " `(node:30) Warning: Accessing non-existent property \\'ListNode\\' of module exports inside circular dependency\\n(Use `nodejs run --trace-warnings ...` to show where the warning was created)\\n(node:30) Warning: Accessing non-existent property \\'TreeNode\\' of module exports inside circular dependency\\n(node:30) Warning: Accessing non-existent property \\'NestedInteger\\' of module exports inside circular dependency\\nnode:internal/process/promises:246\\n          triggerUncaughtException(err, true /* fromPromise */);\\n          ^\\n[UnhandledPromiseRejection: This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). The promise rejected with the reason \"Error\".] {\\n  code: \\'ERR_UNHANDLED_REJECTION\\'\\n}`\\n\\nI can\\'t understand this error. What can be wrong in my code?"
                    },
                    {
                        "username": "VictorKasap",
                        "content": "same"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "[@gkucmierz](/gkucmierz) Ok, I added 4 case error handling and it works.\\nBut Why 1, 2, 3 case didn\\'t worked without this?\\nI think these tests are not correctly separated.\\n"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "[@terryjiang1996](/terryjiang1996) No, this is my solution which works perfect outside leetcode:\n\nhttps://instacode.app/run/FDDGHsDsGcBcAJYEsC2BTAMqpCC88AKAM0gBpEBKeXAPngG9gBIAJzVgFcXJCA6fgIYsA5tCq14kNAHd4ABRbgUSaGgIE20cABsAbmnJsAVmlCxxdRvGvxt7eGkgATavCIDtqgNzAb8VbAAKqho4Byw6hYMvn4Ozq6wLBxoPrHwxqYRAOTB6PBYyggAogAeoGhoTpVZFKk2AL7k5nXWJAT8vEKiFLywABaOGmjQ1JYxfkhEhI5OVGyc3C02MwlJKeM2mjr6Q2JL9bUxBz71PmBQcPBO4EUsiiyryfAA-PAADPAAXPAAjGcQMAQJFcAmgAE9IKBCJAovR4DEBNIBDhJDJ5IplKpdqN-OxcqFwrtyABWN4fAC0Vxud3ALAotXh1nmXB4PAAVJIvPDTiAAZdYNoEiECjhiGR4KS3odgARQRCoQRYTFEmDon4+QgHvhEciEAKCD8AEyHdUXHRoXjacDCAhZTRZQwm+D1eCgASwUB9aZUKw2Pnmy3W21oO4OhxO+rAA6Ks5AA"
                    },
                    {
                        "username": "iRONiCBAT7",
                        "content": "same error encountered"
                    },
                    {
                        "username": "meet2674shah",
                        "content": "[@gkucmierz](/gkucmierz)  the function which is time limited might also throw an error. So, you need to catch it. (like test case 4)"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@Grzegorz](/gkucmierz) I'm pretty sure you're throwing the error from inside the setTimeout callback function. Scheduled functions with setTimeout / setInterval are executed in the event loop (scheduled as macrotasks). That's why you're getting the \"unhandled rejection\" error, because you have no error handler there. I'm pretty sure you can't rely on async/await for this, you have to use the Promise constructor which passes you a reject callback that you can use for this purpose."
                    },
                    {
                        "username": "terryjiang1996",
                        "content": "[@gkucmierz](/gkucmierz) I get the same error. Have you found the solution for this?"
                    },
                    {
                        "username": "user3540qH",
                        "content": "[@gkucmierz](/gkucmierz) try the 4th test"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "It is working correctly with test on my local machine:\n\n```\nconst fn = async (n) => { \n  await new Promise(res => setTimeout(res, 100)); \n  return n * n;\n};\n\n// result:\nconst limited = timeLimit(fn, 150);\n// tle:\n// const limited = timeLimit(fn, 50);\n\nlimited(11).then(res => {\n  console.log('res', res);\n}).catch(err => {\n  console.log('err', err);\n});\n```"
                    },
                    {
                        "username": "jayshah28",
                        "content": "I\\'m amazed about how deeply Leetcode is touching every concept so deeply by providing Editorials. Looks like the Javascript maker\\'s itself is making this. -_-"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 12 : Done Solving Todays Question .\\n\\n`Tip : Try to resolve promises individually and then return the fastest promise resolved with the help of \"Pomise.race\"`"
                    },
                    {
                        "username": "burber",
                        "content": "Buenos dias, \nI used the race solution after a day break from losing my sanity. I have a question though, as I was reading through documentation on Promises, I noticed that promises can be constructed with \"new Promise((resolve, reject) . . .\"  In my mind, I assumed you could use both resolve and reject in the promise, and it would just return whichever came first. This did not work though. Is there something I could have done wrong? Is it even possible to call both of them in one promise?"
                    },
                    {
                        "username": "sonterix",
                        "content": "I wouldn\\'t say this is an Easy one but the challenge is cool!"
                    },
                    {
                        "username": "shahan989",
                        "content": "good question for revision !"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Thank you Leetcode, for me who I am a beginner in typescript, this trip has been trully instructive. I have to study a lot for every challenge."
                    },
                    {
                        "username": "Preethi1235",
                        "content": "Given function is asynchronous , hence it can run in background .\\n if it  was a synchronous function , we could not time limit it.\\nCorrect me if I\\'m wrong."
                    },
                    {
                        "username": "vkavek",
                        "content": "You use async await, which puts it in a \\'synchronous state\\'."
                    }
                ]
            },
            {
                "id": 1895562,
                "content": [
                    {
                        "username": "boboboy_",
                        "content": "I think Difficulty for this problem should be medium."
                    },
                    {
                        "username": "codemode365",
                        "content": "So, it is\\n"
                    },
                    {
                        "username": "gkucmierz",
                        "content": " `(node:30) Warning: Accessing non-existent property \\'ListNode\\' of module exports inside circular dependency\\n(Use `nodejs run --trace-warnings ...` to show where the warning was created)\\n(node:30) Warning: Accessing non-existent property \\'TreeNode\\' of module exports inside circular dependency\\n(node:30) Warning: Accessing non-existent property \\'NestedInteger\\' of module exports inside circular dependency\\nnode:internal/process/promises:246\\n          triggerUncaughtException(err, true /* fromPromise */);\\n          ^\\n[UnhandledPromiseRejection: This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). The promise rejected with the reason \"Error\".] {\\n  code: \\'ERR_UNHANDLED_REJECTION\\'\\n}`\\n\\nI can\\'t understand this error. What can be wrong in my code?"
                    },
                    {
                        "username": "VictorKasap",
                        "content": "same"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "[@gkucmierz](/gkucmierz) Ok, I added 4 case error handling and it works.\\nBut Why 1, 2, 3 case didn\\'t worked without this?\\nI think these tests are not correctly separated.\\n"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "[@terryjiang1996](/terryjiang1996) No, this is my solution which works perfect outside leetcode:\n\nhttps://instacode.app/run/FDDGHsDsGcBcAJYEsC2BTAMqpCC88AKAM0gBpEBKeXAPngG9gBIAJzVgFcXJCA6fgIYsA5tCq14kNAHd4ABRbgUSaGgIE20cABsAbmnJsAVmlCxxdRvGvxt7eGkgATavCIDtqgNzAb8VbAAKqho4Byw6hYMvn4Ozq6wLBxoPrHwxqYRAOTB6PBYyggAogAeoGhoTpVZFKk2AL7k5nXWJAT8vEKiFLywABaOGmjQ1JYxfkhEhI5OVGyc3C02MwlJKeM2mjr6Q2JL9bUxBz71PmBQcPBO4EUsiiyryfAA-PAADPAAXPAAjGcQMAQJFcAmgAE9IKBCJAovR4DEBNIBDhJDJ5IplKpdqN-OxcqFwrtyABWN4fAC0Vxud3ALAotXh1nmXB4PAAVJIvPDTiAAZdYNoEiECjhiGR4KS3odgARQRCoQRYTFEmDon4+QgHvhEciEAKCD8AEyHdUXHRoXjacDCAhZTRZQwm+D1eCgASwUB9aZUKw2Pnmy3W21oO4OhxO+rAA6Ks5AA"
                    },
                    {
                        "username": "iRONiCBAT7",
                        "content": "same error encountered"
                    },
                    {
                        "username": "meet2674shah",
                        "content": "[@gkucmierz](/gkucmierz)  the function which is time limited might also throw an error. So, you need to catch it. (like test case 4)"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@Grzegorz](/gkucmierz) I'm pretty sure you're throwing the error from inside the setTimeout callback function. Scheduled functions with setTimeout / setInterval are executed in the event loop (scheduled as macrotasks). That's why you're getting the \"unhandled rejection\" error, because you have no error handler there. I'm pretty sure you can't rely on async/await for this, you have to use the Promise constructor which passes you a reject callback that you can use for this purpose."
                    },
                    {
                        "username": "terryjiang1996",
                        "content": "[@gkucmierz](/gkucmierz) I get the same error. Have you found the solution for this?"
                    },
                    {
                        "username": "user3540qH",
                        "content": "[@gkucmierz](/gkucmierz) try the 4th test"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "It is working correctly with test on my local machine:\n\n```\nconst fn = async (n) => { \n  await new Promise(res => setTimeout(res, 100)); \n  return n * n;\n};\n\n// result:\nconst limited = timeLimit(fn, 150);\n// tle:\n// const limited = timeLimit(fn, 50);\n\nlimited(11).then(res => {\n  console.log('res', res);\n}).catch(err => {\n  console.log('err', err);\n});\n```"
                    },
                    {
                        "username": "jayshah28",
                        "content": "I\\'m amazed about how deeply Leetcode is touching every concept so deeply by providing Editorials. Looks like the Javascript maker\\'s itself is making this. -_-"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 12 : Done Solving Todays Question .\\n\\n`Tip : Try to resolve promises individually and then return the fastest promise resolved with the help of \"Pomise.race\"`"
                    },
                    {
                        "username": "burber",
                        "content": "Buenos dias, \nI used the race solution after a day break from losing my sanity. I have a question though, as I was reading through documentation on Promises, I noticed that promises can be constructed with \"new Promise((resolve, reject) . . .\"  In my mind, I assumed you could use both resolve and reject in the promise, and it would just return whichever came first. This did not work though. Is there something I could have done wrong? Is it even possible to call both of them in one promise?"
                    },
                    {
                        "username": "sonterix",
                        "content": "I wouldn\\'t say this is an Easy one but the challenge is cool!"
                    },
                    {
                        "username": "shahan989",
                        "content": "good question for revision !"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Thank you Leetcode, for me who I am a beginner in typescript, this trip has been trully instructive. I have to study a lot for every challenge."
                    },
                    {
                        "username": "Preethi1235",
                        "content": "Given function is asynchronous , hence it can run in background .\\n if it  was a synchronous function , we could not time limit it.\\nCorrect me if I\\'m wrong."
                    },
                    {
                        "username": "vkavek",
                        "content": "You use async await, which puts it in a \\'synchronous state\\'."
                    }
                ]
            },
            {
                "id": 1987420,
                "content": [
                    {
                        "username": "boboboy_",
                        "content": "I think Difficulty for this problem should be medium."
                    },
                    {
                        "username": "codemode365",
                        "content": "So, it is\\n"
                    },
                    {
                        "username": "gkucmierz",
                        "content": " `(node:30) Warning: Accessing non-existent property \\'ListNode\\' of module exports inside circular dependency\\n(Use `nodejs run --trace-warnings ...` to show where the warning was created)\\n(node:30) Warning: Accessing non-existent property \\'TreeNode\\' of module exports inside circular dependency\\n(node:30) Warning: Accessing non-existent property \\'NestedInteger\\' of module exports inside circular dependency\\nnode:internal/process/promises:246\\n          triggerUncaughtException(err, true /* fromPromise */);\\n          ^\\n[UnhandledPromiseRejection: This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). The promise rejected with the reason \"Error\".] {\\n  code: \\'ERR_UNHANDLED_REJECTION\\'\\n}`\\n\\nI can\\'t understand this error. What can be wrong in my code?"
                    },
                    {
                        "username": "VictorKasap",
                        "content": "same"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "[@gkucmierz](/gkucmierz) Ok, I added 4 case error handling and it works.\\nBut Why 1, 2, 3 case didn\\'t worked without this?\\nI think these tests are not correctly separated.\\n"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "[@terryjiang1996](/terryjiang1996) No, this is my solution which works perfect outside leetcode:\n\nhttps://instacode.app/run/FDDGHsDsGcBcAJYEsC2BTAMqpCC88AKAM0gBpEBKeXAPngG9gBIAJzVgFcXJCA6fgIYsA5tCq14kNAHd4ABRbgUSaGgIE20cABsAbmnJsAVmlCxxdRvGvxt7eGkgATavCIDtqgNzAb8VbAAKqho4Byw6hYMvn4Ozq6wLBxoPrHwxqYRAOTB6PBYyggAogAeoGhoTpVZFKk2AL7k5nXWJAT8vEKiFLywABaOGmjQ1JYxfkhEhI5OVGyc3C02MwlJKeM2mjr6Q2JL9bUxBz71PmBQcPBO4EUsiiyryfAA-PAADPAAXPAAjGcQMAQJFcAmgAE9IKBCJAovR4DEBNIBDhJDJ5IplKpdqN-OxcqFwrtyABWN4fAC0Vxud3ALAotXh1nmXB4PAAVJIvPDTiAAZdYNoEiECjhiGR4KS3odgARQRCoQRYTFEmDon4+QgHvhEciEAKCD8AEyHdUXHRoXjacDCAhZTRZQwm+D1eCgASwUB9aZUKw2Pnmy3W21oO4OhxO+rAA6Ks5AA"
                    },
                    {
                        "username": "iRONiCBAT7",
                        "content": "same error encountered"
                    },
                    {
                        "username": "meet2674shah",
                        "content": "[@gkucmierz](/gkucmierz)  the function which is time limited might also throw an error. So, you need to catch it. (like test case 4)"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@Grzegorz](/gkucmierz) I'm pretty sure you're throwing the error from inside the setTimeout callback function. Scheduled functions with setTimeout / setInterval are executed in the event loop (scheduled as macrotasks). That's why you're getting the \"unhandled rejection\" error, because you have no error handler there. I'm pretty sure you can't rely on async/await for this, you have to use the Promise constructor which passes you a reject callback that you can use for this purpose."
                    },
                    {
                        "username": "terryjiang1996",
                        "content": "[@gkucmierz](/gkucmierz) I get the same error. Have you found the solution for this?"
                    },
                    {
                        "username": "user3540qH",
                        "content": "[@gkucmierz](/gkucmierz) try the 4th test"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "It is working correctly with test on my local machine:\n\n```\nconst fn = async (n) => { \n  await new Promise(res => setTimeout(res, 100)); \n  return n * n;\n};\n\n// result:\nconst limited = timeLimit(fn, 150);\n// tle:\n// const limited = timeLimit(fn, 50);\n\nlimited(11).then(res => {\n  console.log('res', res);\n}).catch(err => {\n  console.log('err', err);\n});\n```"
                    },
                    {
                        "username": "jayshah28",
                        "content": "I\\'m amazed about how deeply Leetcode is touching every concept so deeply by providing Editorials. Looks like the Javascript maker\\'s itself is making this. -_-"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 12 : Done Solving Todays Question .\\n\\n`Tip : Try to resolve promises individually and then return the fastest promise resolved with the help of \"Pomise.race\"`"
                    },
                    {
                        "username": "burber",
                        "content": "Buenos dias, \nI used the race solution after a day break from losing my sanity. I have a question though, as I was reading through documentation on Promises, I noticed that promises can be constructed with \"new Promise((resolve, reject) . . .\"  In my mind, I assumed you could use both resolve and reject in the promise, and it would just return whichever came first. This did not work though. Is there something I could have done wrong? Is it even possible to call both of them in one promise?"
                    },
                    {
                        "username": "sonterix",
                        "content": "I wouldn\\'t say this is an Easy one but the challenge is cool!"
                    },
                    {
                        "username": "shahan989",
                        "content": "good question for revision !"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Thank you Leetcode, for me who I am a beginner in typescript, this trip has been trully instructive. I have to study a lot for every challenge."
                    },
                    {
                        "username": "Preethi1235",
                        "content": "Given function is asynchronous , hence it can run in background .\\n if it  was a synchronous function , we could not time limit it.\\nCorrect me if I\\'m wrong."
                    },
                    {
                        "username": "vkavek",
                        "content": "You use async await, which puts it in a \\'synchronous state\\'."
                    }
                ]
            },
            {
                "id": 1941828,
                "content": [
                    {
                        "username": "boboboy_",
                        "content": "I think Difficulty for this problem should be medium."
                    },
                    {
                        "username": "codemode365",
                        "content": "So, it is\\n"
                    },
                    {
                        "username": "gkucmierz",
                        "content": " `(node:30) Warning: Accessing non-existent property \\'ListNode\\' of module exports inside circular dependency\\n(Use `nodejs run --trace-warnings ...` to show where the warning was created)\\n(node:30) Warning: Accessing non-existent property \\'TreeNode\\' of module exports inside circular dependency\\n(node:30) Warning: Accessing non-existent property \\'NestedInteger\\' of module exports inside circular dependency\\nnode:internal/process/promises:246\\n          triggerUncaughtException(err, true /* fromPromise */);\\n          ^\\n[UnhandledPromiseRejection: This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). The promise rejected with the reason \"Error\".] {\\n  code: \\'ERR_UNHANDLED_REJECTION\\'\\n}`\\n\\nI can\\'t understand this error. What can be wrong in my code?"
                    },
                    {
                        "username": "VictorKasap",
                        "content": "same"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "[@gkucmierz](/gkucmierz) Ok, I added 4 case error handling and it works.\\nBut Why 1, 2, 3 case didn\\'t worked without this?\\nI think these tests are not correctly separated.\\n"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "[@terryjiang1996](/terryjiang1996) No, this is my solution which works perfect outside leetcode:\n\nhttps://instacode.app/run/FDDGHsDsGcBcAJYEsC2BTAMqpCC88AKAM0gBpEBKeXAPngG9gBIAJzVgFcXJCA6fgIYsA5tCq14kNAHd4ABRbgUSaGgIE20cABsAbmnJsAVmlCxxdRvGvxt7eGkgATavCIDtqgNzAb8VbAAKqho4Byw6hYMvn4Ozq6wLBxoPrHwxqYRAOTB6PBYyggAogAeoGhoTpVZFKk2AL7k5nXWJAT8vEKiFLywABaOGmjQ1JYxfkhEhI5OVGyc3C02MwlJKeM2mjr6Q2JL9bUxBz71PmBQcPBO4EUsiiyryfAA-PAADPAAXPAAjGcQMAQJFcAmgAE9IKBCJAovR4DEBNIBDhJDJ5IplKpdqN-OxcqFwrtyABWN4fAC0Vxud3ALAotXh1nmXB4PAAVJIvPDTiAAZdYNoEiECjhiGR4KS3odgARQRCoQRYTFEmDon4+QgHvhEciEAKCD8AEyHdUXHRoXjacDCAhZTRZQwm+D1eCgASwUB9aZUKw2Pnmy3W21oO4OhxO+rAA6Ks5AA"
                    },
                    {
                        "username": "iRONiCBAT7",
                        "content": "same error encountered"
                    },
                    {
                        "username": "meet2674shah",
                        "content": "[@gkucmierz](/gkucmierz)  the function which is time limited might also throw an error. So, you need to catch it. (like test case 4)"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@Grzegorz](/gkucmierz) I'm pretty sure you're throwing the error from inside the setTimeout callback function. Scheduled functions with setTimeout / setInterval are executed in the event loop (scheduled as macrotasks). That's why you're getting the \"unhandled rejection\" error, because you have no error handler there. I'm pretty sure you can't rely on async/await for this, you have to use the Promise constructor which passes you a reject callback that you can use for this purpose."
                    },
                    {
                        "username": "terryjiang1996",
                        "content": "[@gkucmierz](/gkucmierz) I get the same error. Have you found the solution for this?"
                    },
                    {
                        "username": "user3540qH",
                        "content": "[@gkucmierz](/gkucmierz) try the 4th test"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "It is working correctly with test on my local machine:\n\n```\nconst fn = async (n) => { \n  await new Promise(res => setTimeout(res, 100)); \n  return n * n;\n};\n\n// result:\nconst limited = timeLimit(fn, 150);\n// tle:\n// const limited = timeLimit(fn, 50);\n\nlimited(11).then(res => {\n  console.log('res', res);\n}).catch(err => {\n  console.log('err', err);\n});\n```"
                    },
                    {
                        "username": "jayshah28",
                        "content": "I\\'m amazed about how deeply Leetcode is touching every concept so deeply by providing Editorials. Looks like the Javascript maker\\'s itself is making this. -_-"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 12 : Done Solving Todays Question .\\n\\n`Tip : Try to resolve promises individually and then return the fastest promise resolved with the help of \"Pomise.race\"`"
                    },
                    {
                        "username": "burber",
                        "content": "Buenos dias, \nI used the race solution after a day break from losing my sanity. I have a question though, as I was reading through documentation on Promises, I noticed that promises can be constructed with \"new Promise((resolve, reject) . . .\"  In my mind, I assumed you could use both resolve and reject in the promise, and it would just return whichever came first. This did not work though. Is there something I could have done wrong? Is it even possible to call both of them in one promise?"
                    },
                    {
                        "username": "sonterix",
                        "content": "I wouldn\\'t say this is an Easy one but the challenge is cool!"
                    },
                    {
                        "username": "shahan989",
                        "content": "good question for revision !"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Thank you Leetcode, for me who I am a beginner in typescript, this trip has been trully instructive. I have to study a lot for every challenge."
                    },
                    {
                        "username": "Preethi1235",
                        "content": "Given function is asynchronous , hence it can run in background .\\n if it  was a synchronous function , we could not time limit it.\\nCorrect me if I\\'m wrong."
                    },
                    {
                        "username": "vkavek",
                        "content": "You use async await, which puts it in a \\'synchronous state\\'."
                    }
                ]
            },
            {
                "id": 1895951,
                "content": [
                    {
                        "username": "boboboy_",
                        "content": "I think Difficulty for this problem should be medium."
                    },
                    {
                        "username": "codemode365",
                        "content": "So, it is\\n"
                    },
                    {
                        "username": "gkucmierz",
                        "content": " `(node:30) Warning: Accessing non-existent property \\'ListNode\\' of module exports inside circular dependency\\n(Use `nodejs run --trace-warnings ...` to show where the warning was created)\\n(node:30) Warning: Accessing non-existent property \\'TreeNode\\' of module exports inside circular dependency\\n(node:30) Warning: Accessing non-existent property \\'NestedInteger\\' of module exports inside circular dependency\\nnode:internal/process/promises:246\\n          triggerUncaughtException(err, true /* fromPromise */);\\n          ^\\n[UnhandledPromiseRejection: This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). The promise rejected with the reason \"Error\".] {\\n  code: \\'ERR_UNHANDLED_REJECTION\\'\\n}`\\n\\nI can\\'t understand this error. What can be wrong in my code?"
                    },
                    {
                        "username": "VictorKasap",
                        "content": "same"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "[@gkucmierz](/gkucmierz) Ok, I added 4 case error handling and it works.\\nBut Why 1, 2, 3 case didn\\'t worked without this?\\nI think these tests are not correctly separated.\\n"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "[@terryjiang1996](/terryjiang1996) No, this is my solution which works perfect outside leetcode:\n\nhttps://instacode.app/run/FDDGHsDsGcBcAJYEsC2BTAMqpCC88AKAM0gBpEBKeXAPngG9gBIAJzVgFcXJCA6fgIYsA5tCq14kNAHd4ABRbgUSaGgIE20cABsAbmnJsAVmlCxxdRvGvxt7eGkgATavCIDtqgNzAb8VbAAKqho4Byw6hYMvn4Ozq6wLBxoPrHwxqYRAOTB6PBYyggAogAeoGhoTpVZFKk2AL7k5nXWJAT8vEKiFLywABaOGmjQ1JYxfkhEhI5OVGyc3C02MwlJKeM2mjr6Q2JL9bUxBz71PmBQcPBO4EUsiiyryfAA-PAADPAAXPAAjGcQMAQJFcAmgAE9IKBCJAovR4DEBNIBDhJDJ5IplKpdqN-OxcqFwrtyABWN4fAC0Vxud3ALAotXh1nmXB4PAAVJIvPDTiAAZdYNoEiECjhiGR4KS3odgARQRCoQRYTFEmDon4+QgHvhEciEAKCD8AEyHdUXHRoXjacDCAhZTRZQwm+D1eCgASwUB9aZUKw2Pnmy3W21oO4OhxO+rAA6Ks5AA"
                    },
                    {
                        "username": "iRONiCBAT7",
                        "content": "same error encountered"
                    },
                    {
                        "username": "meet2674shah",
                        "content": "[@gkucmierz](/gkucmierz)  the function which is time limited might also throw an error. So, you need to catch it. (like test case 4)"
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@Grzegorz](/gkucmierz) I'm pretty sure you're throwing the error from inside the setTimeout callback function. Scheduled functions with setTimeout / setInterval are executed in the event loop (scheduled as macrotasks). That's why you're getting the \"unhandled rejection\" error, because you have no error handler there. I'm pretty sure you can't rely on async/await for this, you have to use the Promise constructor which passes you a reject callback that you can use for this purpose."
                    },
                    {
                        "username": "terryjiang1996",
                        "content": "[@gkucmierz](/gkucmierz) I get the same error. Have you found the solution for this?"
                    },
                    {
                        "username": "user3540qH",
                        "content": "[@gkucmierz](/gkucmierz) try the 4th test"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "It is working correctly with test on my local machine:\n\n```\nconst fn = async (n) => { \n  await new Promise(res => setTimeout(res, 100)); \n  return n * n;\n};\n\n// result:\nconst limited = timeLimit(fn, 150);\n// tle:\n// const limited = timeLimit(fn, 50);\n\nlimited(11).then(res => {\n  console.log('res', res);\n}).catch(err => {\n  console.log('err', err);\n});\n```"
                    },
                    {
                        "username": "jayshah28",
                        "content": "I\\'m amazed about how deeply Leetcode is touching every concept so deeply by providing Editorials. Looks like the Javascript maker\\'s itself is making this. -_-"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 12 : Done Solving Todays Question .\\n\\n`Tip : Try to resolve promises individually and then return the fastest promise resolved with the help of \"Pomise.race\"`"
                    },
                    {
                        "username": "burber",
                        "content": "Buenos dias, \nI used the race solution after a day break from losing my sanity. I have a question though, as I was reading through documentation on Promises, I noticed that promises can be constructed with \"new Promise((resolve, reject) . . .\"  In my mind, I assumed you could use both resolve and reject in the promise, and it would just return whichever came first. This did not work though. Is there something I could have done wrong? Is it even possible to call both of them in one promise?"
                    },
                    {
                        "username": "sonterix",
                        "content": "I wouldn\\'t say this is an Easy one but the challenge is cool!"
                    },
                    {
                        "username": "shahan989",
                        "content": "good question for revision !"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Thank you Leetcode, for me who I am a beginner in typescript, this trip has been trully instructive. I have to study a lot for every challenge."
                    },
                    {
                        "username": "Preethi1235",
                        "content": "Given function is asynchronous , hence it can run in background .\\n if it  was a synchronous function , we could not time limit it.\\nCorrect me if I\\'m wrong."
                    },
                    {
                        "username": "vkavek",
                        "content": "You use async await, which puts it in a \\'synchronous state\\'."
                    }
                ]
            }
        ]
    },
    {
        "title": "Color the Triangle Red",
        "question_content": null,
        "solutions": [],
        "discussions": []
    },
    {
        "title": "Find the Prefix Common Array of Two Arrays",
        "question_content": "<p>You are given two <strong>0-indexed </strong>integer<strong> </strong>permutations <code>A</code> and <code>B</code> of length <code>n</code>.</p>\n\n<p>A <strong>prefix common array</strong> of <code>A</code> and <code>B</code> is an array <code>C</code> such that <code>C[i]</code> is equal to the count of numbers that are present at or before the index <code>i</code> in both <code>A</code> and <code>B</code>.</p>\n\n<p>Return <em>the <strong>prefix common array</strong> of </em><code>A</code><em> and </em><code>B</code>.</p>\n\n<p>A sequence of <code>n</code> integers is called a&nbsp;<strong>permutation</strong> if it contains all integers from <code>1</code> to <code>n</code> exactly once.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> A = [1,3,2,4], B = [3,1,2,4]\n<strong>Output:</strong> [0,2,3,4]\n<strong>Explanation:</strong> At i = 0: no number is common, so C[0] = 0.\nAt i = 1: 1 and 3 are common in A and B, so C[1] = 2.\nAt i = 2: 1, 2, and 3 are common in A and B, so C[2] = 3.\nAt i = 3: 1, 2, 3, and 4 are common in A and B, so C[3] = 4.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> A = [2,3,1], B = [3,1,2]\n<strong>Output:</strong> [0,1,3]\n<strong>Explanation:</strong> At i = 0: no number is common, so C[0] = 0.\nAt i = 1: only 3 is common in A and B, so C[1] = 1.\nAt i = 2: 1, 2, and 3 are common in A and B, so C[2] = 3.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= A.length == B.length == n &lt;= 50</code></li>\n\t<li><code>1 &lt;= A[i], B[i] &lt;= n</code></li>\n\t<li><code>It is guaranteed that A and B are both a permutation of n integers.</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3466676,
                "title": "frequency-array-solution-explained-o-n-time-and-space-c",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& a, vector<int>& b) {\\n        // Get the Size of an Array\\n        int n = a.size();\\n        \\n        // Create frequency array which will store the running frequency\\n        // of each integer in both the arrays together. Since, they\\n        // are permutations, the frequency of the each element will \\n        // reach 2 at max at any point during the iterations.\\n        vector<int> aux(n+1, 0);\\n        \\n        // Answer array\\n        vector<int> ans(n, 0);\\n        \\n        // cmn will store the number of elements found to be common yet.         \\n        int cmn = 0;\\n        for(int i = 0; i < n; i++){\\n            // Increment frequency of element a[i], if frequency becomes 2 then \\n            // increment the cmn counter.\\n            aux[a[i]]++;\\n            if(aux[a[i]] == 2) cmn++;\\n            // Increment frequency of element b[i], if frequency becomes 2 then\\n            // increment the cmn counter.       \\n            aux[b[i]]++;\\n            if(aux[b[i]] == 2) cmn++;\\n            \\n            // Because we are moving in one direction the common elements\\n            // will not be changed infact the count will remain same or increase\\n            // but will never get reduced and hence at index \\'i\\' the number of\\n            // common elements will be \\'cmn\\'       \\n            ans[i] = cmn;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nIf it was easy for you to understand, make sure to upvote and help others!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& a, vector<int>& b) {\\n        // Get the Size of an Array\\n        int n = a.size();\\n        \\n        // Create frequency array which will store the running frequency\\n        // of each integer in both the arrays together. Since, they\\n        // are permutations, the frequency of the each element will \\n        // reach 2 at max at any point during the iterations.\\n        vector<int> aux(n+1, 0);\\n        \\n        // Answer array\\n        vector<int> ans(n, 0);\\n        \\n        // cmn will store the number of elements found to be common yet.         \\n        int cmn = 0;\\n        for(int i = 0; i < n; i++){\\n            // Increment frequency of element a[i], if frequency becomes 2 then \\n            // increment the cmn counter.\\n            aux[a[i]]++;\\n            if(aux[a[i]] == 2) cmn++;\\n            // Increment frequency of element b[i], if frequency becomes 2 then\\n            // increment the cmn counter.       \\n            aux[b[i]]++;\\n            if(aux[b[i]] == 2) cmn++;\\n            \\n            // Because we are moving in one direction the common elements\\n            // will not be changed infact the count will remain same or increase\\n            // but will never get reduced and hence at index \\'i\\' the number of\\n            // common elements will be \\'cmn\\'       \\n            ans[i] = cmn;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466857,
                "title": "day-394-brute-optimal-one-pass-100-0ms-python-java-c-explained-approach",
                "content": "# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe need to find an array C of the same length such that C[i] is the number of elements that are common to both A and B in the prefix of length i+1.\\n\\nWe can start by creating two hash maps indexStoreOfA and indexStoreOfB to store the indices of each element in A and B, respectively.\\n\\nWe then iterate over the prefix of A and count the number of elements that are common to both A and B up to that point. We do this by checking if the index of each element in A is less than or equal to i and the index of the same element in B is also less than or equal to i.\\n\\nWe store the count in an array answer and return it as the answer.\\n\\nSince we iterate over the prefix of A and perform constant time operations for each element, the time complexity of this solution is O(n^2), where n is the length of the arrays A and B.\\n\\n\\n# Code\\n```java []\\npublic int[]ThePrefixCommonArray(int[] A, int[] B) {\\n    int length = A.length;\\n    // Create two hash maps to store the indices of each element in A and B\\n    HashMap<Integer, Integer> indexStoreOfA = new HashMap<>();\\n    HashMap<Integer, Integer> indexStoreOfB = new HashMap<>();\\n    // Populate the hash maps with the indices of each element in A and B\\n    for (int i = 0; i < length; i++) {\\n        indexStoreOfA.put(A[i], i);\\n        indexStoreOfB.put(B[i], i);\\n    }\\n    // Create an array to store the prefix common array\\n    int[] answer = new int[length];\\n    // Iterate over each element in A\\n    for (int i = 0; i < length; i++) {\\n        int prefixCounter = 0;\\n        // Iterate over each element in the prefix of A up to i\\n        for (int j = 0; j <= i; j++) {\\n            // If the element at index j in A is also in B and its index in both A and B is less than or equal to i,\\n            // increment the prefix counter\\n            if (indexStoreOfA.get(A[j]) <= i && indexStoreOfB.get(A[j]) <= i) prefixCounter++;\\n        }\\n        // Store the prefix counter in the answer array\\n        answer[i] = prefixCounter;\\n    }\\n    // Return the prefix common array\\n    return answer;\\n}\\n```\\n```python []\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        n = len(A)\\n        m1, m2 = {}, {}\\n        for i in range(n):\\n            m1[A[i]] = i\\n            m2[B[i]] = i\\n        c = [0] * n\\n        for i in range(n):\\n            cnt = 0\\n            for j in range(i + 1):\\n                if m1[A[j]] <= i and m2[A[j]] <= i:\\n                    cnt += 1\\n            c[i] = cnt\\n        return c\\n```\\n```c++ []\\nclass Solution {\\npublic    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n        unordered_map<int, int> m1, m2;\\n        for(int i = 0; i < n; i++) {\\n            m1[A[i]] = i;\\n            m2[B[i]] = i;\\n        }\\n        vector<int> c(n);\\n        for(int i = 0; i < n; i++) {\\n            int cnt = 0;\\n            for(int j = 0; j <= i; j++) {\\n                if(m1[A[j]] <= i && m2[A[j]] <= i) {\\n                    cnt++;\\n                }\\n            }\\n            c[i] = cnt;\\n        }\\n        return c;\\n    }\\n};\\n```\\n\\n\\n# Complexity\\nTC: The time complexity of the code is O(n^2), where n is the length of the input arrays A and B. This is because the code iterates over each element in A and then iterates over each element in the prefix of A up to i, resulting in a nested loop. The time complexity of the nested loop is O(n^2) because the maximum number of iterations is n(n+1)/2. Therefore, the overall time complexity of the code is O(n^2).\\nSC: The space complexity of the code is O(n), where n is the length of the input\\n\\n\\n# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n# Optimal approach using frequency array \\nWe are given two integer permutations A and B of length n, and we need to find the prefix common array of A and B.\\n\\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\\n\\nTo find the prefix common array, we can iterate over both arrays A and B simultaneously and keep track of the frequency of each integer in both arrays using an array cnt.\\n\\nFor each element in A and B, we increment the corresponding element in cnt and check if its frequency becomes 2. If the frequency becomes 2, it means that the element is present in both A and B at or before the current index i.\\n\\nWe update the corresponding element in the result array res by adding 1 if the frequency of the element in A or B becomes 2, otherwise we add 0.\\n\\nFinally, we compute the prefix sum of the res array to get the prefix common array of A and B.\\n\\nThe time complexity of this approach is O(n), where n is the length of the input arrays A and B.\\n\\n```java []\\npublic int[] findThePrefixCommonArray(int[] A, int[] B) {\\n    int n = A.length, res[] = new int[n],cnt[] = new int[51];\\n    for (int i = 0; i < n; ++i) {\\n        res[i] = (++cnt[A[i]] == 2 ? 1 : 0) + (++cnt[B[i]] == 2 ? 1 : 0);\\n        if( i > 0)  res[i] += res[i - 1];\\n    }\\n    return res;\\n}\\n```\\n```c++ []\\n vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n    int n = A.size();\\n    vector<int> res(n), cnt(51);\\n    for (int i = 0; i < n; ++i) {\\n        res[i] = (++cnt[A[i]] == 2 ? 1 : 0) + (++cnt[B[i]] == 2 ? 1 : 0);\\n        if( i > 0)  res[i] += res[i - 1];\\n    }\\n    return res;\\n}\\n```\\n```python []\\ndef findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n    n = len(A)\\n    res = [0] * n\\n    cnt = [0] * 51\\n    for i in range(n):\\n        res[i] = ((cnt[A[i]] := cnt[A[i]] + 1) == 2) + ((cnt[B[i]] := cnt[B[i]] + 1) == 2)\\n        if i > 0:\\n            res[i] += res[i - 1]\\n    return res\\n```\\n# TC = o(n)\\n# SC = O(51)==>o(1)\\n\\n![BREUSELEE.webp](https://assets.leetcode.com/users/images/062630f0-ef80-4e74-abdb-302827b99235_1680054012.5054147.webp)\\n![image.png](https://assets.leetcode.com/users/images/303fa18d-281d-49f0-87ef-1a018fc9a488_1681355186.0923774.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\nhttps://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/solutions/3466857/day-394-brute-optimal-100-0ms-python-java-c-explained-approach/\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```java []\\npublic int[]ThePrefixCommonArray(int[] A, int[] B) {\\n    int length = A.length;\\n    // Create two hash maps to store the indices of each element in A and B\\n    HashMap<Integer, Integer> indexStoreOfA = new HashMap<>();\\n    HashMap<Integer, Integer> indexStoreOfB = new HashMap<>();\\n    // Populate the hash maps with the indices of each element in A and B\\n    for (int i = 0; i < length; i++) {\\n        indexStoreOfA.put(A[i], i);\\n        indexStoreOfB.put(B[i], i);\\n    }\\n    // Create an array to store the prefix common array\\n    int[] answer = new int[length];\\n    // Iterate over each element in A\\n    for (int i = 0; i < length; i++) {\\n        int prefixCounter = 0;\\n        // Iterate over each element in the prefix of A up to i\\n        for (int j = 0; j <= i; j++) {\\n            // If the element at index j in A is also in B and its index in both A and B is less than or equal to i,\\n            // increment the prefix counter\\n            if (indexStoreOfA.get(A[j]) <= i && indexStoreOfB.get(A[j]) <= i) prefixCounter++;\\n        }\\n        // Store the prefix counter in the answer array\\n        answer[i] = prefixCounter;\\n    }\\n    // Return the prefix common array\\n    return answer;\\n}\\n```\n```python []\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        n = len(A)\\n        m1, m2 = {}, {}\\n        for i in range(n):\\n            m1[A[i]] = i\\n            m2[B[i]] = i\\n        c = [0] * n\\n        for i in range(n):\\n            cnt = 0\\n            for j in range(i + 1):\\n                if m1[A[j]] <= i and m2[A[j]] <= i:\\n                    cnt += 1\\n            c[i] = cnt\\n        return c\\n```\n```c++ []\\nclass Solution {\\npublic    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n        unordered_map<int, int> m1, m2;\\n        for(int i = 0; i < n; i++) {\\n            m1[A[i]] = i;\\n            m2[B[i]] = i;\\n        }\\n        vector<int> c(n);\\n        for(int i = 0; i < n; i++) {\\n            int cnt = 0;\\n            for(int j = 0; j <= i; j++) {\\n                if(m1[A[j]] <= i && m2[A[j]] <= i) {\\n                    cnt++;\\n                }\\n            }\\n            c[i] = cnt;\\n        }\\n        return c;\\n    }\\n};\\n```\n```java []\\npublic int[] findThePrefixCommonArray(int[] A, int[] B) {\\n    int n = A.length, res[] = new int[n],cnt[] = new int[51];\\n    for (int i = 0; i < n; ++i) {\\n        res[i] = (++cnt[A[i]] == 2 ? 1 : 0) + (++cnt[B[i]] == 2 ? 1 : 0);\\n        if( i > 0)  res[i] += res[i - 1];\\n    }\\n    return res;\\n}\\n```\n```c++ []\\n vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n    int n = A.size();\\n    vector<int> res(n), cnt(51);\\n    for (int i = 0; i < n; ++i) {\\n        res[i] = (++cnt[A[i]] == 2 ? 1 : 0) + (++cnt[B[i]] == 2 ? 1 : 0);\\n        if( i > 0)  res[i] += res[i - 1];\\n    }\\n    return res;\\n}\\n```\n```python []\\ndef findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n    n = len(A)\\n    res = [0] * n\\n    cnt = [0] * 51\\n    for i in range(n):\\n        res[i] = ((cnt[A[i]] := cnt[A[i]] + 1) == 2) + ((cnt[B[i]] := cnt[B[i]] + 1) == 2)\\n        if i > 0:\\n            res[i] += res[i - 1]\\n    return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466962,
                "title": "java-c-python-one-pass",
                "content": "# **Explanation**\\nIterate A[i] and B[i],\\nand record if we have ever seen A[i] and B[i].\\n\\nThe second time we have seen the same value,\\nwe will increment the number `cur` of current common elements.\\n\\nFinall return the result.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(n)` for output\\n<br>\\n\\n**Java**\\n```java\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int cur = 0, n = A.length, res[] = new int[n], seen[] = new int[n + 1];\\n        for (int i = 0; i < n; ++i) {\\n            if (++seen[A[i]] == 2) cur++;\\n            if (++seen[B[i]] == 2) cur++;\\n            res[i] = cur;\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int cur = 0, n = A.size();\\n        vector<int> res(n), seen(n + 1);\\n        for (int i = 0; i < n; ++i) {\\n            if (++seen[A[i]] == 2) cur++;\\n            if (++seen[B[i]] == 2) cur++;\\n            res[i] = cur;\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        res = []\\n        seen = cur = 0\\n        for ab in zip(A, B):\\n            for a in ab:\\n                if (1 << a) & seen:\\n                    cur += 1\\n                seen |= 1 << a\\n            res.append(cur)\\n        return res\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int cur = 0, n = A.length, res[] = new int[n], seen[] = new int[n + 1];\\n        for (int i = 0; i < n; ++i) {\\n            if (++seen[A[i]] == 2) cur++;\\n            if (++seen[B[i]] == 2) cur++;\\n            res[i] = cur;\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int cur = 0, n = A.size();\\n        vector<int> res(n), seen(n + 1);\\n        for (int i = 0; i < n; ++i) {\\n            if (++seen[A[i]] == 2) cur++;\\n            if (++seen[B[i]] == 2) cur++;\\n            res[i] = cur;\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        res = []\\n        seen = cur = 0\\n        for ab in zip(A, B):\\n            for a in ab:\\n                if (1 << a) & seen:\\n                    cur += 1\\n                seen |= 1 << a\\n            res.append(cur)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3466638,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int a[]=new int[51];\\n        int len=A.length;\\n        int res[]=new int[len];\\n        for(int i=1;i<=len;i++)\\n        {\\n            a[A[i-1]]++;\\n            a[B[i-1]]++;\\n            int count=0;\\n            for(int j=0;j<=50;j++)\\n            {\\n                if(a[j]==2)\\n                {\\n                    count++;\\n                }\\n            }\\n            res[i-1]=count;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int a[]=new int[51];\\n        int len=A.length;\\n        int res[]=new int[len];\\n        for(int i=1;i<=len;i++)\\n        {\\n            a[A[i-1]]++;\\n            a[B[i-1]]++;\\n            int count=0;\\n            for(int j=0;j<=50;j++)\\n            {\\n                if(a[j]==2)\\n                {\\n                    count++;\\n                }\\n            }\\n            res[i-1]=count;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466695,
                "title": "explained-using-bit-set-very-simple-easy-to-understand-solution",
                "content": "\\n<b> Up vote if you like the solution</b>\\n\\n# Approach\\nLets consider the case if the constraint is, value of array is less than 32 in place of 50\\nHere we can take two flags a & b. Keep setting its bits as per the array value we see on iteration.\\n    Then taking the bit wise AND of a & b, then counting the 1\\'s will give us no. of common elements till we traversed.\\n\\nSo if you understand above case, for constraint above we can take 4 variables a1, a2, b1 & b2 to store status of seen element.\\nHere a1 will store status of 1-31 & a2 store status of 32 to 50. Same is the case for b1 & b2.\\n\\n\\n# Code\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int a1 = 0, b1 = 0, a2 = 0, b2 = 0;\\n        vector<int> ans;\\n        for(int i = 0; i < A.size(); ++i){\\n            if(A[i] < 32) a1 = (a1 | (1 << A[i]));\\n            else a2 = (a2 | (1 << (A[i] - 31)));\\n            if(B[i] < 32) b1 = (b1 | (1 << B[i]));\\n            else b2 = (b2 | (1 << (B[i] - 31)));\\n            ans.push_back(__builtin_popcount((a1 & b1))  + __builtin_popcount((a2 & b2)));\\n        }\\n        return ans;\\n    }\\n};\\n```\\n<b>Here is an article of my last interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int a1 = 0, b1 = 0, a2 = 0, b2 = 0;\\n        vector<int> ans;\\n        for(int i = 0; i < A.size(); ++i){\\n            if(A[i] < 32) a1 = (a1 | (1 << A[i]));\\n            else a2 = (a2 | (1 << (A[i] - 31)));\\n            if(B[i] < 32) b1 = (b1 | (1 << B[i]));\\n            else b2 = (b2 | (1 << (B[i] - 31)));\\n            ans.push_back(__builtin_popcount((a1 & b1))  + __builtin_popcount((a2 & b2)));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466640,
                "title": "counter",
                "content": "\\nWe go left-to-right and count the elements in both arrays.\\n\\nThe element `n` appears in both arrays when `cnt[n] == 2`.\\n\\n```cpp\\nvector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n    vector<int> res, cnt(51);\\n    for (int i = 0; i < A.size(); ++i)\\n        res.push_back((++cnt[A[i]] == 2) + (++cnt[B[i]] == 2));\\n    partial_sum(begin(res), end(res), begin(res));\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nvector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n    vector<int> res, cnt(51);\\n    for (int i = 0; i < A.size(); ++i)\\n        res.push_back((++cnt[A[i]] == 2) + (++cnt[B[i]] == 2));\\n    partial_sum(begin(res), end(res), begin(res));\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3467191,
                "title": "c-python-o-n-solution-using-set",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_set<int> a, b;\\n        vector<int> ans;\\n        int count = 0;\\n        for(int i = 0; i < A.size(); i++) {\\n            a.insert(A[i]);\\n            b.insert(B[i]);\\n            if(A[i] == B[i]) {\\n                count++;\\n                ans.push_back(count);\\n                continue;\\n            }\\n            if(b.find(A[i]) != b.end()) count++;\\n            if(a.find(B[i]) != a.end()) count++;\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# Python / Python3\\n```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        a = set()\\n        b = set()\\n        ans = []\\n        count = 0\\n        for i in range(0, len(A)):\\n            a.add(A[i])\\n            b.add(B[i])\\n            if A[i] == B[i]:\\n                count += 1\\n                ans.append(count)\\n                continue\\n            if A[i] in b:\\n                count += 1\\n            if B[i] in a:\\n                count += 1\\n            ans.append(count)\\n        return ans\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_set<int> a, b;\\n        vector<int> ans;\\n        int count = 0;\\n        for(int i = 0; i < A.size(); i++) {\\n            a.insert(A[i]);\\n            b.insert(B[i]);\\n            if(A[i] == B[i]) {\\n                count++;\\n                ans.push_back(count);\\n                continue;\\n            }\\n            if(b.find(A[i]) != b.end()) count++;\\n            if(a.find(B[i]) != a.end()) count++;\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        a = set()\\n        b = set()\\n        ans = []\\n        count = 0\\n        for i in range(0, len(A)):\\n            a.add(A[i])\\n            b.add(B[i])\\n            if A[i] == B[i]:\\n                count += 1\\n                ans.append(count)\\n                continue\\n            if A[i] in b:\\n                count += 1\\n            if B[i] in a:\\n                count += 1\\n            ans.append(count)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466802,
                "title": "c-best-solution-one-time-traversal-o-n-easy-to-understand",
                "content": "\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(3n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& a, vector<int>& b) {\\n        vector<int> temp;\\n        set<int> st;\\n        map<int, bool> m1, m2;\\n        \\n        for(int i=0; i<a.size(); i++)   {\\n            m1[a[i]] = m2[b[i]] = true; // make the both element true in their map\\n            if(m1.find(b[i]) != m1.end())  st.insert(b[i]);     // if the b[i] is present before in the array a then push it in set\\n            if(m2.find(a[i]) != m2.end())  st.insert(a[i]);     // if the a[i] is present before in the array b then push it in set\\n            temp.push_back(st.size());      // set => size indecates the number of element common \\n        }\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Map",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& a, vector<int>& b) {\\n        vector<int> temp;\\n        set<int> st;\\n        map<int, bool> m1, m2;\\n        \\n        for(int i=0; i<a.size(); i++)   {\\n            m1[a[i]] = m2[b[i]] = true; // make the both element true in their map\\n            if(m1.find(b[i]) != m1.end())  st.insert(b[i]);     // if the b[i] is present before in the array a then push it in set\\n            if(m2.find(a[i]) != m2.end())  st.insert(a[i]);     // if the a[i] is present before in the array b then push it in set\\n            temp.push_back(st.size());      // set => size indecates the number of element common \\n        }\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469401,
                "title": "java-find-the-prefix-common-array-of-two-arrays",
                "content": "\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n                int []com = new int[A.length];\\n        HashSet<Integer> setA = new HashSet<>();\\n        HashSet<Integer> setB = new HashSet<>();\\n        for (int i = 0; i < A.length; i++)\\n        {\\n            setA.add(A[i]);\\n            setB.add(B[i]);\\n            HashSet<Integer> tmp = new HashSet<>(setA);\\n            tmp.retainAll(setB);\\n            com[i] = tmp.size();\\n        }\\n        return com;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n                int []com = new int[A.length];\\n        HashSet<Integer> setA = new HashSet<>();\\n        HashSet<Integer> setB = new HashSet<>();\\n        for (int i = 0; i < A.length; i++)\\n        {\\n            setA.add(A[i]);\\n            setB.add(B[i]);\\n            HashSet<Integer> tmp = new HashSet<>(setA);\\n            tmp.retainAll(setB);\\n            com[i] = tmp.size();\\n        }\\n        return com;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467846,
                "title": "python-3-8-lines-w-example-t-m-132-ms-16-mb",
                "content": "```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n\\n        ans, cur, d = [], 0, defaultdict(int)   #  Example: A = [1,3,2,4], B = [3,1,2,4]\\n\\n        for a,b in zip(A,B):                    #  zip(A,B) = [(1,3), (3,1), (2,2), (4,4)]\\n\\n            if a == b: ans.append(cur:=cur+1)   #    (A,B)      d       cur    ans\\n                                                #    \\u2013\\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013\\n            else:                               #    (1,3)  {1:1, 3:1}    0    [0]\\n                d[a] += 1                       #    (3,1)  {1:2, 3:2}    2    [0,2]\\n                d[b] += 1                       #    (2,2)  {1:2, 3:2}    3    [0,2,3]\\n                                                #    (4,4)  {1:2, 3:2}    4    [0,2,3,4]\\n\\n                ans.append(cur:= cur+ (d[a] == 2) + (d[b] == 2))\\n\\n            print((a,b), d, cur, ans)\\n        return ans\\n```\\n[https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/submissions/941774522/](http://)\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n\\n        ans, cur, d = [], 0, defaultdict(int)   #  Example: A = [1,3,2,4], B = [3,1,2,4]\\n\\n        for a,b in zip(A,B):                    #  zip(A,B) = [(1,3), (3,1), (2,2), (4,4)]\\n\\n            if a == b: ans.append(cur:=cur+1)   #    (A,B)      d       cur    ans\\n                                                #    \\u2013\\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013\\n            else:                               #    (1,3)  {1:1, 3:1}    0    [0]\\n                d[a] += 1                       #    (3,1)  {1:2, 3:2}    2    [0,2]\\n                d[b] += 1                       #    (2,2)  {1:2, 3:2}    3    [0,2,3]\\n                                                #    (4,4)  {1:2, 3:2}    4    [0,2,3,4]\\n\\n                ans.append(cur:= cur+ (d[a] == 2) + (d[b] == 2))\\n\\n            print((a,b), d, cur, ans)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497523,
                "title": "c-solution-using-set-one-pass-solution",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Check if the values are equal, then count the value as common one\\n- Else check if any of the value is present in the set or not, if present, the increase the count, else insert it into the set\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_set<int> mp;\\n        vector<int> res;\\n        int count=0;\\n        for(int i=0;i<A.size();i++) {\\n            if(A[i]==B[i]) {\\n                count++;\\n            }else{\\n                if(mp.find(A[i])!=mp.end()) count++;\\n                else mp.insert(A[i]);\\n\\n                if(mp.find(B[i])!=mp.end()) count++;\\n                else mp.insert(B[i]);\\n            }\\n            res.push_back(count);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_set<int> mp;\\n        vector<int> res;\\n        int count=0;\\n        for(int i=0;i<A.size();i++) {\\n            if(A[i]==B[i]) {\\n                count++;\\n            }else{\\n                if(mp.find(A[i])!=mp.end()) count++;\\n                else mp.insert(A[i]);\\n\\n                if(mp.find(B[i])!=mp.end()) count++;\\n                else mp.insert(B[i]);\\n            }\\n            res.push_back(count);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3492154,
                "title": "c-maintain-a-count-array-easy-to-understand",
                "content": "# Intuition\\nSTORE COUNT OF ELEMENT OF ARRAT\\n\\n# Approach\\nMAINTAIN COUNT OF ELEMENT\\'S OF ARRAY\\nFOR 1st ARRAY INCREMENT COUNT FOR 2nd ARRAY DECREMENT COUNT OF ELEMENT\\n1st ARRAY: BEFORE INCREMENT COUNT CHECK ELEMENT COUNT < 0  OR NOTE\\n2nd ARRAY: BEFRE DECREMENT COUNT CHECK ELEMENT PREVIOSLY EXISTS OF NOT\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n = A.size(),k=0;\\n        vector<int> ans(n),dp(n+1,0);//DP ARRAY FOR STORE COUNT OF ALL ELEMENTS\\n        for(int i = 0; i < n; i++){\\n            if(dp[A[i]]<0)k++;\\n            dp[A[i]]++;\\n            if(dp[B[i]]>0)k++;\\n            dp[B[i]]--;\\n            ans[i] = k;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n = A.size(),k=0;\\n        vector<int> ans(n),dp(n+1,0);//DP ARRAY FOR STORE COUNT OF ALL ELEMENTS\\n        for(int i = 0; i < n; i++){\\n            if(dp[A[i]]<0)k++;\\n            dp[A[i]]++;\\n            if(dp[B[i]]>0)k++;\\n            dp[B[i]]--;\\n            ans[i] = k;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467605,
                "title": "python3-one-line",
                "content": "Loop over the intersection of arrays, increasing the length of the window, moving the index to the right at each iteration. An array composed of the length of the intersection of the arrays at each step will be the answer.\\n\\nFor example: (current step, set(A[:i + 1]), set(B[:i + 1]), length of intersection)\\ni = 0: {1}, {3} -> 0\\ni = 1: {1, 3}, {1, 3} -> 2\\ni = 2: {1, 2, 3}, {1, 2, 3} -> 3\\ni = 3: {1, 2, 3, 4}, {1, 2, 3, 4} -> 4\\n\\n```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        return [len(set(A[:i + 1]) & set(B[:i + 1])) for i in range(len(A))]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        return [len(set(A[:i + 1]) & set(B[:i + 1])) for i in range(len(A))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466741,
                "title": "easy-to-understand-map-simple-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) \\n    {\\n        int n = A.size();\\n        unordered_map<int, int>mp;\\n        vector<int>ans(n, 0);\\n        for (int i = 0; i < n; i++)\\n        {\\n            mp[B[i]]++;\\n            //====================================\\n            int common = 0;\\n            for (int j = 0; j <= i; j++)\\n            {\\n                if (mp.count(A[j])) common++;\\n            }\\n            //======================================\\n            ans[i] = common;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) \\n    {\\n        int n = A.size();\\n        unordered_map<int, int>mp;\\n        vector<int>ans(n, 0);\\n        for (int i = 0; i < n; i++)\\n        {\\n            mp[B[i]]++;\\n            //====================================\\n            int common = 0;\\n            for (int j = 0; j <= i; j++)\\n            {\\n                if (mp.count(A[j])) common++;\\n            }\\n            //======================================\\n            ans[i] = common;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466729,
                "title": "simple-clean-java-solution",
                "content": "\\n```java []\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[] res = new int[A.length];\\n        Set<Integer> setA = new HashSet<>();\\n        Set<Integer> setB = new HashSet<>();\\n        for(int i=0; i<A.length; i++){\\n            setA.add(A[i]);\\n            setB.add(B[i]);\\n            Set<Integer> set = new HashSet(setA);\\n            set.retainAll(setB);\\n            res[i] = set.size();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[] res = new int[A.length];\\n        Set<Integer> setA = new HashSet<>();\\n        Set<Integer> setB = new HashSet<>();\\n        for(int i=0; i<A.length; i++){\\n            setA.add(A[i]);\\n            setB.add(B[i]);\\n            Set<Integer> set = new HashSet(setA);\\n            set.retainAll(setB);\\n            res[i] = set.size();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3816661,
                "title": "python-3-two-set-solution",
                "content": "```python3 []\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        res, s1, s2 = [], set(), set()\\n        for a, b in zip(A, B):\\n            s1.add(a)\\n            s2.add(b)\\n            res.append(len(s1 & s2))\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        res, s1, s2 = [], set(), set()\\n        for a, b in zip(A, B):\\n            s1.add(a)\\n            s2.add(b)\\n            res.append(len(s1 & s2))\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481901,
                "title": "easy-c-solution-single-loop-set",
                "content": "# Intuition\\nWe start filling elements in the set\\nset oonly has unique elements\\nAs we fill elements in set the size should increase by 2 every time but due to duplicacy it does not\\nso we just see how many should be there - how many there are. \\n\\n# Approach\\n2*(i+1)-st.size()\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_set<int> st;\\n        vector<int> ans;\\n        for(int i=0;i<A.size();i++){\\n            st.insert(A[i]);st.insert(B[i]);\\n            ans.push_back(2*(i+1)-st.size());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_set<int> st;\\n        vector<int> ans;\\n        for(int i=0;i<A.size();i++){\\n            st.insert(A[i]);st.insert(B[i]);\\n            ans.push_back(2*(i+1)-st.size());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467133,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n        vector<int> vis(n + 1), ans;\\n        for(int i = 0; i < n; i++) {\\n            vis[A[i]]++;\\n            vis[B[i]]++;\\n            int cnt = 0;\\n            for(int j = 1; j <= n; j++) if(vis[j] == 2) cnt++;\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n        vector<int> vis(n + 1), ans;\\n        for(int i = 0; i < n; i++) {\\n            vis[A[i]]++;\\n            vis[B[i]]++;\\n            int cnt = 0;\\n            for(int j = 1; j <= n; j++) if(vis[j] == 2) cnt++;\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466858,
                "title": "c-easy-time-o-n-space-o-n-most-optimized",
                "content": "````\\n\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int> ans;\\n        vector<int> v(51,0);\\n        int x = 0;\\n        for(int i = 0; i < A.size(); i++){\\n            if(v[A[i]]<0)\\n                x++;\\n            v[A[i]]++;\\n            if(v[B[i]]>0)\\n                x++;\\n            v[B[i]]--;\\n            ans.push_back(x);\\n        }\\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "````\\n\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int> ans;\\n        vector<int> v(51,0);\\n        int x = 0;\\n        for(int i = 0; i < A.size(); i++){\\n            if(v[A[i]]<0)\\n                x++;\\n            v[A[i]]++;\\n            if(v[B[i]]>0)\\n                x++;\\n            v[B[i]]--;\\n            ans.push_back(x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466822,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        count = defaultdict(int)\\n        n = len(A)\\n        ans = [0] * n\\n        s = 0\\n        for i in range(n):\\n            count[A[i]] += 1\\n            if count[A[i]] == 2:\\n                s += 1\\n            count[B[i]] += 1\\n            if count[B[i]] == 2:\\n                s += 1\\n            ans[i] = s\\n        return ans\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        count = defaultdict(int)\\n        n = len(A)\\n        ans = [0] * n\\n        s = 0\\n        for i in range(n):\\n            count[A[i]] += 1\\n            if count[A[i]] == 2:\\n                s += 1\\n            count[B[i]] += 1\\n            if count[B[i]] == 2:\\n                s += 1\\n            ans[i] = s\\n        return ans\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466722,
                "title": "c-solution-using-set",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int>arr(A.size());\\n        int index=0;\\n        \\n        for(int i=0;i<A.size();i++){\\n            int count = 0;\\n            set<int>set;\\n            for(int j=0; j<=i;j++){\\n                set.insert(A[j]);\\n            }\\n            for(int k=0;k<=i;k++){\\n                if(!set.insert(B[k]).second ){\\n                    count++;\\n                }    \\n            }\\n            arr[index++] = count;\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int>arr(A.size());\\n        int index=0;\\n        \\n        for(int i=0;i<A.size();i++){\\n            int count = 0;\\n            set<int>set;\\n            for(int j=0; j<=i;j++){\\n                set.insert(A[j]);\\n            }\\n            for(int k=0;k<=i;k++){\\n                if(!set.insert(B[k]).second ){\\n                    count++;\\n                }    \\n            }\\n            arr[index++] = count;\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466708,
                "title": "set-counting-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_set<int> s1, s2;\\n        int n = A.size();\\n        vector<int> ans;\\n        for(int i=0; i<n; i++) {\\n            s1.insert(A[i]);\\n            s2.insert(B[i]);\\n            \\n            int cnt = 0;\\n            for(int i=1; i<=n; i++) {\\n                if(s1.find(i) != s1.end() && s2.find(i) != s1.end()) cnt++;\\n            }\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_set<int> s1, s2;\\n        int n = A.size();\\n        vector<int> ans;\\n        for(int i=0; i<n; i++) {\\n            s1.insert(A[i]);\\n            s2.insert(B[i]);\\n            \\n            int cnt = 0;\\n            for(int i=1; i<=n; i++) {\\n                if(s1.find(i) != s1.end() && s2.find(i) != s1.end()) cnt++;\\n            }\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466635,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_map<int,int> mp;\\n        vector<int> val;\\n        int ans=0;\\n        for(int i=0;i<A.size();i++){\\n            mp[A[i]]++;\\n            if(mp[A[i]] == 2)\\n                ans++;\\n            mp[B[i]]++;\\n            if(mp[B[i]] == 2)\\n                ans++;\\n            val.push_back(ans);\\n        }\\n        return val;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_map<int,int> mp;\\n        vector<int> val;\\n        int ans=0;\\n        for(int i=0;i<A.size();i++){\\n            mp[A[i]]++;\\n            if(mp[A[i]] == 2)\\n                ans++;\\n            mp[B[i]]++;\\n            if(mp[B[i]] == 2)\\n                ans++;\\n            val.push_back(ans);\\n        }\\n        return val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950768,
                "title": "easy-c-solution-maps-beats-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n      map<int,int> mp;\\n      int count=0;\\n      vector<int> v;\\n      for(int i=0;i<A.size();i++)\\n      {\\n          mp[A[i]]++;\\n          if(mp[A[i]]==2)\\n          {\\n              count++;\\n          }\\n          mp[B[i]]++;\\n          if(mp[B[i]]==2)\\n          {\\n              count++;\\n          }\\n          v.push_back(count);\\n      }  \\n    return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n      map<int,int> mp;\\n      int count=0;\\n      vector<int> v;\\n      for(int i=0;i<A.size();i++)\\n      {\\n          mp[A[i]]++;\\n          if(mp[A[i]]==2)\\n          {\\n              count++;\\n          }\\n          mp[B[i]]++;\\n          if(mp[B[i]]==2)\\n          {\\n              count++;\\n          }\\n          v.push_back(count);\\n      }  \\n    return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3765411,
                "title": "java-hashset-easy-to-understand-o-n",
                "content": "# Intuition\\nBasically the problem statement says we need to check how many duplicate elements we got upto every index from both arrays A and B.\\n\\n# Approach\\nAs soon as the word duplicate strikes your mind.. you should think of HashSets. Maintain a HashSet to store unique elements and create array C denoting how many duplicates we have found upto that index in both arrays A and B.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        HashSet<Integer> unique = new HashSet<>();\\n        int[] C = new int[A.length];\\n        for(int i=0; i<C.length; i++){\\n            unique.add(A[i]);\\n            unique.add(B[i]);\\n            C[i] = (2*(i+1)) - unique.size();\\n        }\\n        return C;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        HashSet<Integer> unique = new HashSet<>();\\n        int[] C = new int[A.length];\\n        for(int i=0; i<C.length; i++){\\n            unique.add(A[i]);\\n            unique.add(B[i]);\\n            C[i] = (2*(i+1)) - unique.size();\\n        }\\n        return C;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3603166,
                "title": "frequency-array-solution-o-n-time-and-space-faster-than-100-online-java-solution",
                "content": "class Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int freq[] = new int[A.length+1];\\n        int c[] = new int[A.length];\\n        int count = 0;\\n        for(int i=0;i<A.length;i++){\\n            freq[A[i]]++;\\n            if(freq[A[i]]==2)count++;\\n            freq[B[i]]++;\\n            if(freq[B[i]]==2)count++;\\n            c[i]=count;\\n        }\\n        return c;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int freq[] = new int[A.length+1];\\n        int c[] = new int[A.length];\\n        int count = 0;\\n        for(int i=0;i<A.length;i++){\\n            freq[A[i]]++;\\n            if(freq[A[i]]==2)count++;\\n            freq[B[i]]++;\\n            if(freq[B[i]]==2)count++;\\n            c[i]=count;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3467151,
                "title": "simple-easy-solution-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int>ans;\\n        unordered_map<int, int>mp;\\n        for(int i=0; i<A.size(); i++) {\\n            mp[A[i]]++;\\n            mp[B[i]]++;\\n            int t= 2*(i+1)- mp.size();\\n            ans.push_back(t);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int>ans;\\n        unordered_map<int, int>mp;\\n        for(int i=0; i<A.size(); i++) {\\n            mp[A[i]]++;\\n            mp[B[i]]++;\\n            int t= 2*(i+1)- mp.size();\\n            ans.push_back(t);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467075,
                "title": "java-simple-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires finding the number of common elements between the two given integer arrays for each prefix of the arrays.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create two ArrayList objects, al and bl, to store the elements of the input arrays a and b, respectively.\\n\\n1. Initialize the size of the input arrays to n and create an integer array ans of size n to store the number of common elements between a and b for each prefix of the arrays.\\n\\n1. Initialize a counter variable cnt to 0.\\n\\n1. Loop through each prefix of the input arrays using a for loop that iterates over the indices i from 0 to n-1.\\n\\n1. In each iteration, add the ith element of a and b to their respective ArrayLists.\\n\\n1. If the ith elements of a and b are equal, increment the counter variable cnt by 1.\\n\\n1. If the ith elements of a and b are not equal, check if bl (the ArrayList for b) contains the ith element of a. If true, increment the counter variable cnt by 1.\\n\\n1. Similarly, check if al (the ArrayList for a) contains the ith element of b. If true, increment the counter variable cnt by 1.\\n\\n1. Store the count of common elements cnt in the ith index of the ans array.\\n\\n1. After looping through all prefixes, return the ans array.\\n\\n**The overall approach of the code is to use two ArrayList objects to keep track of the elements of the input arrays and then iterate over each prefix of the arrays to count the number of common elements between them.**\\n\\n# Complexity\\n- Time complexity:  O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] a, int[] b) {\\n        List<Integer> al = new ArrayList<>();\\n        List<Integer> bl = new ArrayList<>();\\n        int n = a.length;\\n        int[] ans = new int[n];\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            \\n            al.add(a[i]);\\n            bl.add(b[i]);\\n            if(a[i]==b[i]){\\n                cnt++;\\n            }\\n            else{\\n                if(bl.contains(a[i])){\\n                    cnt++;\\n                }\\n                if(al.contains(b[i])){\\n                    cnt++;\\n                }\\n            }\\n            ans[i] = cnt;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] a, int[] b) {\\n        List<Integer> al = new ArrayList<>();\\n        List<Integer> bl = new ArrayList<>();\\n        int n = a.length;\\n        int[] ans = new int[n];\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            \\n            al.add(a[i]);\\n            bl.add(b[i]);\\n            if(a[i]==b[i]){\\n                cnt++;\\n            }\\n            else{\\n                if(bl.contains(a[i])){\\n                    cnt++;\\n                }\\n                if(al.contains(b[i])){\\n                    cnt++;\\n                }\\n            }\\n            ans[i] = cnt;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466861,
                "title": "java-simplest-solution-ever",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        \\n \\n    int n = A.length;\\n        int m = B.length;\\n        int[] C = new int[n];\\n        Set<Integer> setA = new HashSet<>();\\n        Set<Integer> setB = new HashSet<>();\\n        for (int i = 0; i < n; i++) {\\n            setA.add(A[i]);\\n            setB.add(B[i]);\\n            int commonCount = 0;\\n            for (int num : setA) {\\n                if (setB.contains(num)) {\\n                    commonCount++;\\n                }\\n            }\\n            C[i] = commonCount;\\n        }\\n        return C;\\n    }\\n}\\n\\n\\n\\n\\n    \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        \\n \\n    int n = A.length;\\n        int m = B.length;\\n        int[] C = new int[n];\\n        Set<Integer> setA = new HashSet<>();\\n        Set<Integer> setB = new HashSet<>();\\n        for (int i = 0; i < n; i++) {\\n            setA.add(A[i]);\\n            setB.add(B[i]);\\n            int commonCount = 0;\\n            for (int num : setA) {\\n                if (setB.contains(num)) {\\n                    commonCount++;\\n                }\\n            }\\n            C[i] = commonCount;\\n        }\\n        return C;\\n    }\\n}\\n\\n\\n\\n\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466801,
                "title": "brute-c-solution",
                "content": "\\n# Approach\\nFor each index check in both arrays for the common elements.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& q, vector<int>& w) {\\n        int n=q.size();\\n        vector<int>v;\\n        for(int i=0;i<n;i++){\\n            int cnt=0;\\n            for(int k=0;k<=i;k++){\\n                for(int p=0;p<=i;p++){\\n                    if(q[k]==w[p]){\\n                        cnt++;\\n                    }\\n                }\\n            }\\n            v.push_back(cnt);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& q, vector<int>& w) {\\n        int n=q.size();\\n        vector<int>v;\\n        for(int i=0;i<n;i++){\\n            int cnt=0;\\n            for(int k=0;k<=i;k++){\\n                for(int p=0;p<=i;p++){\\n                    if(q[k]==w[p]){\\n                        cnt++;\\n                    }\\n                }\\n            }\\n            v.push_back(cnt);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3987843,
                "title": "c-o-n-hashmap-o-n-time",
                "content": "# Intuition\\nBecause there are guaranteed to be the same permutation of n elements, if we can have the indices of each element from {1..n} available in O(1) time, we can quickly check in an iterative fashion if we want to add to the prefix or not.\\n\\n# Approach\\nCreate two index-maps for the two arrays. If the elements are the same, then we add 1 to our answer till before. Else, we may encounter an element in `A` which was present in `B` before, or the vice-versa. Hence, we need to add 1 based on both checks.\\n\\n# Complexity\\n- Time complexity:\\nO(n) : 3 loops.\\n\\n- Space complexity:\\nO(n) : 2 Hashmaps + 1 solution array.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_map<int, int> A_idx;\\n        unordered_map<int, int> B_idx;\\n        for(int i = 0 ; i < A.size(); i++) A_idx[A[i]] = i;\\n        for(int i = 0 ; i < A.size(); i++) B_idx[B[i]] = i;\\n        vector<int> soln_c(A.size(), 0);\\n        soln_c[0] = A[0] == B[0];\\n        for(int i = 1 ; i < A.size(); i++) {\\n            soln_c[i] = soln_c[i-1];\\n            if(A[i] == B[i])\\n                soln_c[i] += 1;\\n            else\\n                soln_c[i] += (B_idx[A[i]] <= i) + (A_idx[B[i]] <= i);\\n        }\\n        return soln_c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_map<int, int> A_idx;\\n        unordered_map<int, int> B_idx;\\n        for(int i = 0 ; i < A.size(); i++) A_idx[A[i]] = i;\\n        for(int i = 0 ; i < A.size(); i++) B_idx[B[i]] = i;\\n        vector<int> soln_c(A.size(), 0);\\n        soln_c[0] = A[0] == B[0];\\n        for(int i = 1 ; i < A.size(); i++) {\\n            soln_c[i] = soln_c[i-1];\\n            if(A[i] == B[i])\\n                soln_c[i] += 1;\\n            else\\n                soln_c[i] += (B_idx[A[i]] <= i) + (A_idx[B[i]] <= i);\\n        }\\n        return soln_c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3937672,
                "title": "2657-find-the-prefix-common-array-of-two-arrays-java",
                "content": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        // Initialize an array to store the common prefix lengths\\n        int ans[] = new int[A.length];\\n        // Initialize a counter to keep track of common prefix length\\n        int cnt = 0;\\n\\n        // Initialize hash maps to track element frequencies in arrays A and B\\n        HashMap<Integer, Integer> H1 = new HashMap<Integer, Integer>();\\n        HashMap<Integer, Integer> H2 = new HashMap<Integer, Integer>();\\n\\n        // Check if the first elements of A and B are equal\\n        if (A[0] == B[0]) {\\n            cnt++;          // Increment the counter\\n            ans[0] = cnt;   // Store the counter value for the first index\\n        } else {\\n            H1.put(A[0], 1); // Add the first element of A to H1 with frequency 1\\n            H2.put(B[0], 1); // Add the first element of B to H2 with frequency 1\\n        }\\n\\n        // Iterate through the arrays starting from the second index\\n        for (int i = 1; i < A.length; i++) {\\n            // If elements at the same index in A and B are equal, increment the counter\\n            if (A[i] == B[i])\\n                cnt++;\\n            \\n            // If the current element of A has occurred previously in B, increment the counter\\n            if (H2.containsKey(A[i]))\\n                cnt++;\\n            \\n            // If the current element of B has occurred previously in A, increment the counter\\n            if (H1.containsKey(B[i]))\\n                cnt++;\\n            \\n            // Store the current counter value in the ans array\\n            ans[i] = cnt;\\n            \\n            // Update frequency counts in the hash maps\\n            H1.put(A[i], H1.getOrDefault(A[i], 0) + 1);\\n            H2.put(B[i], H2.getOrDefault(B[i], 0) + 1);\\n        }\\n\\n        // Return the array containing common prefix lengths for each index\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        // Initialize an array to store the common prefix lengths\\n        int ans[] = new int[A.length];\\n        // Initialize a counter to keep track of common prefix length\\n        int cnt = 0;\\n\\n        // Initialize hash maps to track element frequencies in arrays A and B\\n        HashMap<Integer, Integer> H1 = new HashMap<Integer, Integer>();\\n        HashMap<Integer, Integer> H2 = new HashMap<Integer, Integer>();\\n\\n        // Check if the first elements of A and B are equal\\n        if (A[0] == B[0]) {\\n            cnt++;          // Increment the counter\\n            ans[0] = cnt;   // Store the counter value for the first index\\n        } else {\\n            H1.put(A[0], 1); // Add the first element of A to H1 with frequency 1\\n            H2.put(B[0], 1); // Add the first element of B to H2 with frequency 1\\n        }\\n\\n        // Iterate through the arrays starting from the second index\\n        for (int i = 1; i < A.length; i++) {\\n            // If elements at the same index in A and B are equal, increment the counter\\n            if (A[i] == B[i])\\n                cnt++;\\n            \\n            // If the current element of A has occurred previously in B, increment the counter\\n            if (H2.containsKey(A[i]))\\n                cnt++;\\n            \\n            // If the current element of B has occurred previously in A, increment the counter\\n            if (H1.containsKey(B[i]))\\n                cnt++;\\n            \\n            // Store the current counter value in the ans array\\n            ans[i] = cnt;\\n            \\n            // Update frequency counts in the hash maps\\n            H1.put(A[i], H1.getOrDefault(A[i], 0) + 1);\\n            H2.put(B[i], H2.getOrDefault(B[i], 0) + 1);\\n        }\\n\\n        // Return the array containing common prefix lengths for each index\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3721347,
                "title": "easy-solution-using-hashset-o-n-java",
                "content": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        \\n        HashSet<Integer> set1=new HashSet<>();\\n        HashSet<Integer> set2=new HashSet<>();\\n        \\n        int [] arr=new int[A.length];\\n        for(int i=0;i<A.length;i++)\\n        {\\n            set1.add(A[i]);\\n            set2.add(B[i]);\\n            \\n            HashSet<Integer> res=new HashSet<>(set1);\\n            res.retainAll(set2);\\n            arr[i]=res.size();   \\n        }\\n        return arr;  // upvote my solution\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        \\n        HashSet<Integer> set1=new HashSet<>();\\n        HashSet<Integer> set2=new HashSet<>();\\n        \\n        int [] arr=new int[A.length];\\n        for(int i=0;i<A.length;i++)\\n        {\\n            set1.add(A[i]);\\n            set2.add(B[i]);\\n            \\n            HashSet<Integer> res=new HashSet<>(set1);\\n            res.retainAll(set2);\\n            arr[i]=res.size();   \\n        }\\n        return arr;  // upvote my solution\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718097,
                "title": "c-easiest-possible-solution-o-n-2",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_map<int, int> map1; // Create an unordered map to store the frequency of elements from both A and B\\n        vector<int> ans(A.size(), 0); // Create a result vector initialized with 0s, to store the prefix common array\\n\\n        for (int i = 0; i < A.size(); i++) {\\n            map1[A[i]]++; // Increment the frequency of element A[i] in the map\\n            map1[B[i]]++; // Increment the frequency of element B[i] in the map\\n\\n            int count = 0; // Initialize a count variable to store the number of elements with frequency >= 2\\n\\n            for (auto it : map1) // Iterate through the elements of the unordered map\\n                if (it.second >= 2) // If the frequency is greater than or equal to 2, it means it\\'s common in both A and B\\n                    count += it.second; // Increment the count based on the frequency of the common element\\n\\n            ans[i] += count / 2; // Store half of the count in the result array for each index i\\n        }\\n\\n        return ans; // Return the result vector containing the prefix common array\\n    }\\n};\\n```\\n\\n**Time Complexity:**\\n\\nThe outer loop runs for A.size() iterations, and the inner loop iterates over the elements of the unordered map, which has a maximum size of 2 * A.size() (as it stores elements from both A and B). Therefore, the time complexity of the inner loop is O(A.size()).\\nSince the inner loop runs inside the outer loop, the overall time complexity of the function is O(A.size() * A.size()).\\n\\n**Space Complexity:**\\n\\nThe unordered map map1 can store up to 2 * A.size() elements, each containing a unique element from A and B. Therefore, the space complexity of the unordered map is O(A.size()).\\nThe ans vector has the same size as vector A, so its space complexity is also O(A.size()).\\nOverall, the space complexity of the function is O(A.size()).",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_map<int, int> map1; // Create an unordered map to store the frequency of elements from both A and B\\n        vector<int> ans(A.size(), 0); // Create a result vector initialized with 0s, to store the prefix common array\\n\\n        for (int i = 0; i < A.size(); i++) {\\n            map1[A[i]]++; // Increment the frequency of element A[i] in the map\\n            map1[B[i]]++; // Increment the frequency of element B[i] in the map\\n\\n            int count = 0; // Initialize a count variable to store the number of elements with frequency >= 2\\n\\n            for (auto it : map1) // Iterate through the elements of the unordered map\\n                if (it.second >= 2) // If the frequency is greater than or equal to 2, it means it\\'s common in both A and B\\n                    count += it.second; // Increment the count based on the frequency of the common element\\n\\n            ans[i] += count / 2; // Store half of the count in the result array for each index i\\n        }\\n\\n        return ans; // Return the result vector containing the prefix common array\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710294,
                "title": "intuative-solution-beats-98-79-in-rn-98-42-in-m",
                "content": "# Intuition\\nlet,\\n\\ni = current number of elements being checked in the lists\\nn = length of list\\nk = number of common elements\\nd = Length of dictionary\\n\\nIf we store the all unique elements in a dictionary upto the **i**th length and let\\'s assume that no element is common between the two list, then the length of the dictionary will be i*2. However, now let us assume there are k number of common elements, then the length of the dictionary is:\\n$$d = i*2 - k$$\\n\\nor\\n\\n$$k = i*2 - d$$\\n\\nfor example:\\n    A = [1,3]\\n    B = [3,1]\\n    n = 2\\n    \\n    when i = 1\\n    d = 2 #dictionary = [1,3]\\n    k = 1 * 2 - 2 = 0\\n\\n    when i = 2\\n    d = 2 #dictionary = [1,3]\\n    k = 2 * 2 - 2 = 2\\n\\n# Complexity\\n- Time complexity:\\n    $$O(n)$$\\n\\n- Space complexity:\\n    worst case, 2n from dictionary (tmp) and n from list (C):\\n    3n\\n    $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        C = []\\n        tmp = {}\\n        if A[0] == B[0]:\\n            C.append(1)\\n        else:\\n            C.append(0)\\n        tmp[A[0]] = 1\\n        tmp[B[0]] = 1\\n        for i in range(1,len(A)):\\n            tmp[A[i]] = 1\\n            tmp[B[i]] = 1\\n            C.append((i+1)*2 - len(tmp)) \\n        return C\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        C = []\\n        tmp = {}\\n        if A[0] == B[0]:\\n            C.append(1)\\n        else:\\n            C.append(0)\\n        tmp[A[0]] = 1\\n        tmp[B[0]] = 1\\n        for i in range(1,len(A)):\\n            tmp[A[i]] = 1\\n            tmp[B[i]] = 1\\n            C.append((i+1)*2 - len(tmp)) \\n        return C\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690673,
                "title": "swift-hash-table-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt first, I wanted to solve through dictionaries, because I did not understand the task at all. Because a friend explained that whenever we iterate over an array we count everything to count all the same numbers. From 0 to i. This turned out to be very important!\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI realized that a dictionary is not needed. We can use a set. Each time we insert numbers into a set, we know the difference in the number. Thus, we can understand how many identical numbers are already in the set.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func findThePrefixCommonArray(_ A: [Int], _ B: [Int]) -> [Int] {\\n        var set: Set<Int> = []\\n        var result: [Int] = []\\n        for i in 1...A.count {\\n            set.insert(A[i - 1])\\n            set.insert(B[i - 1])\\n            result.append(i * 2 - set.count)\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    func findThePrefixCommonArray(_ A: [Int], _ B: [Int]) -> [Int] {\\n        var set: Set<Int> = []\\n        var result: [Int] = []\\n        for i in 1...A.count {\\n            set.insert(A[i - 1])\\n            set.insert(B[i - 1])\\n            result.append(i * 2 - set.count)\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688343,
                "title": "easy-lvl-problem",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n        vector<int> f(n+1);\\n        vector<int> res(n);\\n\\n        for (int i=0; i<n; i++) {\\n            if (++f[A[i]] == 2) res[i]++;\\n            if (++f[B[i]] == 2) res[i]++;\\n\\n            if (i>0) res[i] += res[i-1];\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n        vector<int> f(n+1);\\n        vector<int> res(n);\\n\\n        for (int i=0; i<n; i++) {\\n            if (++f[A[i]] == 2) res[i]++;\\n            if (++f[B[i]] == 2) res[i]++;\\n\\n            if (i>0) res[i] += res[i-1];\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3670342,
                "title": "simple-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince each integer can only appear once in each array, if the integer is already in the set seen, then increment by one. Otherwise, add to the set. No concerns of duplicate counting due to distinct integers.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) due to iteratring through entire array.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) due to seen set that will contain every element.\\n# Code\\n```\\n/**\\n * @param {number[]} A\\n * @param {number[]} B\\n * @return {number[]}\\n */\\nvar findThePrefixCommonArray = function(A, B) {\\n    let seen = new Set();\\n    let prefixCommonArr = [];\\n    let currentCount = 0;\\n\\n    for (let i = 0; i < A.length; i++) {\\n        if (seen.has(A[i])) {\\n            currentCount += 1;\\n        }\\n        seen.add(A[i]);\\n\\n        if (seen.has(B[i])) {\\n            currentCount +=1 ;\\n        }\\n        seen.add(B[i]);\\n        \\n        prefixCommonArr[i] = currentCount;\\n    }\\n\\n    return prefixCommonArr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} A\\n * @param {number[]} B\\n * @return {number[]}\\n */\\nvar findThePrefixCommonArray = function(A, B) {\\n    let seen = new Set();\\n    let prefixCommonArr = [];\\n    let currentCount = 0;\\n\\n    for (let i = 0; i < A.length; i++) {\\n        if (seen.has(A[i])) {\\n            currentCount += 1;\\n        }\\n        seen.add(A[i]);\\n\\n        if (seen.has(B[i])) {\\n            currentCount +=1 ;\\n        }\\n        seen.add(B[i]);\\n        \\n        prefixCommonArr[i] = currentCount;\\n    }\\n\\n    return prefixCommonArr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3668005,
                "title": "beats-100-optimal-o-n-hashing",
                "content": "# Approach\\nThe main logic of the code involves keeping track of the frequency of elements in both arrays using the `freq` array. By checking if an element has a frequency of 2, we can determine if it is common in both prefix arrays. The cumulative count `cumcount` is incremented whenever a new common element is found. Finally, the count array is populated with the cumulative `count` up to each index.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$, for storing `count[]`\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[] count = new int[A.length];\\n        int n = A.length;\\n        int[] freq = new int[51];\\n\\n        int cumcount = 0;\\n        for(int i=0; i<n; i++) {\\n            freq[A[i]]++;\\n            // if freq[x] ==2 that mean it was already common in both the prefix arrays\\n            if(freq[A[i]] == 2) \\n                cumcount++;\\n            \\n            // similarly for element B[i]\\n            freq[B[i]]++;\\n            if(freq[B[i]] == 2)\\n                cumcount++;\\n            \\n            count[i] = cumcount;\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n### Please do upvote!! \\uD83D\\uDE4F",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[] count = new int[A.length];\\n        int n = A.length;\\n        int[] freq = new int[51];\\n\\n        int cumcount = 0;\\n        for(int i=0; i<n; i++) {\\n            freq[A[i]]++;\\n            // if freq[x] ==2 that mean it was already common in both the prefix arrays\\n            if(freq[A[i]] == 2) \\n                cumcount++;\\n            \\n            // similarly for element B[i]\\n            freq[B[i]]++;\\n            if(freq[B[i]] == 2)\\n                cumcount++;\\n            \\n            count[i] = cumcount;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3656547,
                "title": "extremely-easy-beginner-friendly-method-brute-force",
                "content": "\\n# Approach\\n                           Brute force method\\nTo solve the problem, we can iterate through the arrays A and B simultaneously and create a counter vector to store the elements encountered at each index. For each iteration, we sort the counter vector and count the number of duplicates. The count represents the number of common elements between the prefixes A[0:i+1] and B[0:i+1]. We store this count in the solution vector.\\n\\n# Complexity\\n- Time complexity: O(n^2 log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: O(min(n,m))\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) \\n    {\\n        vector<int> solution;\\n        vector<int> counter;\\n        int count = 0;\\n        for(int i = 0; i<A.size();i++)\\n        {\\n            count = 0;\\n            counter.push_back(A[i]);\\n            counter.push_back(B[i]);\\n\\n            sort(counter.begin(), counter.end());\\n            for(int j = 1 ; j< counter.size();j++)\\n            {\\n                if(counter[j]==counter[j-1])count++;\\n            }\\n\\n            solution.push_back(count);\\n        }       \\n\\n        return solution;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) \\n    {\\n        vector<int> solution;\\n        vector<int> counter;\\n        int count = 0;\\n        for(int i = 0; i<A.size();i++)\\n        {\\n            count = 0;\\n            counter.push_back(A[i]);\\n            counter.push_back(B[i]);\\n\\n            sort(counter.begin(), counter.end());\\n            for(int j = 1 ; j< counter.size();j++)\\n            {\\n                if(counter[j]==counter[j-1])count++;\\n            }\\n\\n            solution.push_back(count);\\n        }       \\n\\n        return solution;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553756,
                "title": "solution-using-set-identities",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere are probably easier solutions, but here is a mathematical one that shows the power of set identities.\\n\\nWhat you want is to maintain the intersection between the sets of numbers in either array that you\\'ve already seen so far. The size of this intersection at each $$i$$ is equal to $$C[i]$$.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLet $$sA$$ and $$sB$$ be sets containing elements from $$A$$ and $$B$$ respectively as we traverse the arrays. Let $$sA_i$$ and $$sB_i$$ be the two sets after iteration $$i$$. Then, in iteration $$i+1$$, the elements $$A[i+1]$$ and $$B[i+1]$$ come along. \\n\\nWe want $$C[i+1] = |sA_{i+1} \\\\cap sB_{i+1}| = |(sA_i \\\\cup \\\\{A[i]\\\\}) \\\\cap (sB_i \\\\cup \\\\{B[i]\\\\})|$$.\\n\\nNow, recall the following set identity: $$A \\\\cap (B \\\\cup C) = (A \\\\cap B) \\\\cup (A \\\\cap C)$$. Using this identity, $$C[i+1]$$ can be written as:\\n\\n$$C[i+1] = (sA_i \\\\cap sB_i) \\\\cup (\\\\{A[i]\\\\} \\\\cap sB_i) \\\\cup (\\\\{B[i]\\\\} \\\\cap sA_i) \\\\cup (\\\\{A[i]\\\\} \\\\cap \\\\{B[i]\\\\})$$.\\n\\nBut $$sA_i \\\\cap sB_i = C[i]$$ which we have from the previous iteration, and the other three terms in the union above can be obtained by simply query-ing $$sA$$ and $$sB$$ for the elements. One can do this using a set or a hashmap.\\n\\n# Complexity\\n- Time complexity: $$O(n\\\\log n)$$ improvable to $$O(n)$$ with hashmap.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        set<int> setA, setB;\\n        vector<int> C;\\n        C.assign(A.size(), 0);\\n        for (int i = 0; i < A.size(); i++)\\n        {\\n            C[i] = ((i > 0) ? C[i-1] : 0) + \\n                   (setB.find(A[i]) != setB.end()) + \\n                   (setA.find(B[i]) != setA.end())\\n                   + (A[i] == B[i]);\\n\\n            setA.insert(A[i]);\\n            setB.insert(B[i]);\\n        }\\n\\n        return C;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        set<int> setA, setB;\\n        vector<int> C;\\n        C.assign(A.size(), 0);\\n        for (int i = 0; i < A.size(); i++)\\n        {\\n            C[i] = ((i > 0) ? C[i-1] : 0) + \\n                   (setB.find(A[i]) != setB.end()) + \\n                   (setA.find(B[i]) != setA.end())\\n                   + (A[i] == B[i]);\\n\\n            setA.insert(A[i]);\\n            setB.insert(B[i]);\\n        }\\n\\n        return C;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531758,
                "title": "brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& a, vector<int>& b) {\\n        \\n        int n = a.size();\\n        unordered_map<int, int> mp;\\n        int ans = 0;\\n        vector<int> res(n,0);\\n        for(int i=0;i<n;i++)\\n        {   \\n            mp[a[i]]++ ;\\n            \\n            for(int j=0;j<=i;j++)\\n            {\\n                if(mp.count(b[j]))\\n                {\\n                    res[i]++;\\n                }\\n            }\\n        }\\n        \\n       \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& a, vector<int>& b) {\\n        \\n        int n = a.size();\\n        unordered_map<int, int> mp;\\n        int ans = 0;\\n        vector<int> res(n,0);\\n        for(int i=0;i<n;i++)\\n        {   \\n            mp[a[i]]++ ;\\n            \\n            for(int j=0;j<=i;j++)\\n            {\\n                if(mp.count(b[j]))\\n                {\\n                    res[i]++;\\n                }\\n            }\\n        }\\n        \\n       \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525437,
                "title": "two-solutions-to-find-the-prefix-common-array-of-two-arrays-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# 1. Approach\\n<!-- Describe your approach to solving the problem. -->\\n*BRUTE FORCE APPROACH*\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^3)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int i, j, k, count=0;\\n        vector<int> ans;\\n        for(i=0 ; i<A.size() ; i++)\\n        {\\n            count=0;\\n            for(j=0 ; j<=i ; j++)\\n            {\\n                for(k=0 ; k<=i ; k++)\\n                {\\n                    if(A[j]==B[k])\\n                    {\\n                        count++;\\n                    }\\n                }\\n            }\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# 2. Approach\\n<!-- Describe your approach to solving the problem. -->\\n*OPTIMIZED APPROACH*\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2logn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int i, j, k, count=0;\\n        vector<int> temp1;\\n        vector<int> temp2;\\n        vector<int> ans;\\n        for(i=0 ; i<A.size() ; i++)\\n        {\\n            count=0;\\n            j=0, k=0;\\n            copy(A.begin(), A.begin()+i+1, back_inserter(temp1));\\n            copy(B.begin(), B.begin()+i+1, back_inserter(temp2));\\n            sort(temp1.begin(), temp1.end());\\n            sort(temp2.begin(), temp2.end());\\n            while(j<=i && k<=i)\\n            {\\n                if(temp1[j]==temp2[k])\\n                {\\n                    count++;\\n                    j++;\\n                    k++;\\n                }\\n                else if(temp1[j]<temp2[k])\\n                {\\n                    j++;\\n                }\\n                else if(temp1[j]>temp2[k])\\n                {\\n                    k++;\\n                }\\n            }\\n            temp1.clear();\\n            temp2.clear();\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/4edc6144-1286-417b-a06b-f2c829b9d98e_1684120230.4192863.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int i, j, k, count=0;\\n        vector<int> ans;\\n        for(i=0 ; i<A.size() ; i++)\\n        {\\n            count=0;\\n            for(j=0 ; j<=i ; j++)\\n            {\\n                for(k=0 ; k<=i ; k++)\\n                {\\n                    if(A[j]==B[k])\\n                    {\\n                        count++;\\n                    }\\n                }\\n            }\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int i, j, k, count=0;\\n        vector<int> temp1;\\n        vector<int> temp2;\\n        vector<int> ans;\\n        for(i=0 ; i<A.size() ; i++)\\n        {\\n            count=0;\\n            j=0, k=0;\\n            copy(A.begin(), A.begin()+i+1, back_inserter(temp1));\\n            copy(B.begin(), B.begin()+i+1, back_inserter(temp2));\\n            sort(temp1.begin(), temp1.end());\\n            sort(temp2.begin(), temp2.end());\\n            while(j<=i && k<=i)\\n            {\\n                if(temp1[j]==temp2[k])\\n                {\\n                    count++;\\n                    j++;\\n                    k++;\\n                }\\n                else if(temp1[j]<temp2[k])\\n                {\\n                    j++;\\n                }\\n                else if(temp1[j]>temp2[k])\\n                {\\n                    k++;\\n                }\\n            }\\n            temp1.clear();\\n            temp2.clear();\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522472,
                "title": "java-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int n=A.length;\\n        int ans[]=new int[n];\\n        int index=0;\\n        Set<Integer> s1=new HashSet<>();\\n        Set<Integer> s2=new HashSet<>();\\n         if(A[0]==B[0]){\\n                ans[index++]=1;\\n            }else if(A[0]!=B[0]){\\n                ans[index++]=0;\\n            }\\n            s1.add(A[0]);\\n            s2.add(B[0]);\\n        for(int i=1;i<n;i++)\\n        {\\n            s1.add(A[i]);\\n            s2.add(B[i]);\\n            int c=0;\\n            for(int j:s1){\\n                if(s2.contains(j))c++;\\n            }\\n            ans[index++]=c;\\n        }\\n        return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int n=A.length;\\n        int ans[]=new int[n];\\n        int index=0;\\n        Set<Integer> s1=new HashSet<>();\\n        Set<Integer> s2=new HashSet<>();\\n         if(A[0]==B[0]){\\n                ans[index++]=1;\\n            }else if(A[0]!=B[0]){\\n                ans[index++]=0;\\n            }\\n            s1.add(A[0]);\\n            s2.add(B[0]);\\n        for(int i=1;i<n;i++)\\n        {\\n            s1.add(A[i]);\\n            s2.add(B[i]);\\n            int c=0;\\n            for(int j:s1){\\n                if(s2.contains(j))c++;\\n            }\\n            ans[index++]=c;\\n        }\\n        return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519710,
                "title": "c-easy-solution-with-o-n-time-complexity",
                "content": "# Intuition\\nusing ordered map\\n\\n# Approach\\nusing map to count the common values so far.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int>v;\\n        map<int,int>mp;\\n        int c=0;\\n//traversing through out the vector finding wether vectors have coommon eleemnts in it using map.(if repeated then frequency will be 2)\\n        for(int i=0;i<A.size();i++){\\n            mp[A[i]]++;\\n            if(mp[A[i]]==2){\\n                c++;\\n            }\\n            mp[B[i]]++;\\n             if(mp[B[i]]==2){\\n                c++;\\n            }\\n            v.push_back(c);\\n        }\\n        return v;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int>v;\\n        map<int,int>mp;\\n        int c=0;\\n//traversing through out the vector finding wether vectors have coommon eleemnts in it using map.(if repeated then frequency will be 2)\\n        for(int i=0;i<A.size();i++){\\n            mp[A[i]]++;\\n            if(mp[A[i]]==2){\\n                c++;\\n            }\\n            mp[B[i]]++;\\n             if(mp[B[i]]==2){\\n                c++;\\n            }\\n            v.push_back(c);\\n        }\\n        return v;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507561,
                "title": "single-pass-easy-simple-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to just need to count the seen element\\'s.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe use a unordered_set to store the count of distinct elements.\\nIf we know that how many elements are new then we can easily calculate the no.of same elsement\\'s.\\n\\nFirst run a loop from i=0 to i<n(size of array) Then we start inserting the each element of both the array\\'s in unordered_set.\\nif any of the element\\'s are same the it not pushed in unordered_set so in this way we can easily know the no. of diffrent element\\'s so far.\\nand then we If all the visited numbers are distinct the the size of unordered_set is  equal to (i+1)*2.\\nAnd by comparing the these two we can easily know the no. of same element\\'s.\\nand that is push_back to the Our answer array(C).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nAs we run a loop i=0 to i<n \\nTime complexity:$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nAs we use an unordered_set.\\nSpace complexity:$$O(n)$$\\n\\n# Code\\n`If you like the solution then please give an UP-VOTE`\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_set<int>us;\\n        vector<int>C;\\n        for(int i=0;i<A.size();i++){\\n            us.insert(A[i]);\\n            us.insert(B[i]);\\n            C.push_back((i+1)*2-us.size());\\n        }\\n        return C;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_set<int>us;\\n        vector<int>C;\\n        for(int i=0;i<A.size();i++){\\n            us.insert(A[i]);\\n            us.insert(B[i]);\\n            C.push_back((i+1)*2-us.size());\\n        }\\n        return C;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3504846,
                "title": "c-simplest-using-only-one-set-only",
                "content": "##### Algorithm \\n* Check if A\\'s index is already present , cnt+1 if yes\\n* Insert A[i] to check with B\\n* Check B\\'s index is already present , cnt+1 if yes\\n* Insert B[i] for \\n\\nWe don\\'t need extra map for 2nd array as we are counting comman indexs from both arrays\\n\\n\\n\\n#####  C++ Code\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_set<int>s;\\n        int n=A.size();\\n        \\n        vector<int>ans(n);\\n        int cnt=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s.find(A[i])!=s.end()) cnt++;\\n            s.insert(A[i]);\\n            if(s.find(B[i])!=s.end()) cnt++;\\n            s.insert(B[i]);\\n            \\n            ans[i]=cnt;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n##### Complexity \\n* TC : O(n)\\n* SC : O(2n) : set + ans vector\\n\\n##### *Upvote if it helped you :)*\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_set<int>s;\\n        int n=A.size();\\n        \\n        vector<int>ans(n);\\n        int cnt=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s.find(A[i])!=s.end()) cnt++;\\n            s.insert(A[i]);\\n            if(s.find(B[i])!=s.end()) cnt++;\\n            s.insert(B[i]);\\n            \\n            ans[i]=cnt;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3488004,
                "title": "easy-c-solution-using-set",
                "content": "# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        set<int> st;\\n        int cnt=0;\\n        int n= A.size();\\n        vector<int> ans;\\n        for (int i=0; i<n; i++){\\n            if (st.find(A[i])!=st.end()){\\n                cnt++;\\n            }\\n            else st.insert(A[i]);\\n            if (st.find(B[i])!=st.end()){\\n                cnt++;\\n            }\\n            else st.insert(B[i]);\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Counting",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        set<int> st;\\n        int cnt=0;\\n        int n= A.size();\\n        vector<int> ans;\\n        for (int i=0; i<n; i++){\\n            if (st.find(A[i])!=st.end()){\\n                cnt++;\\n            }\\n            else st.insert(A[i]);\\n            if (st.find(B[i])!=st.end()){\\n                cnt++;\\n            }\\n            else st.insert(B[i]);\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481183,
                "title": "c-brute-force-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n*logn)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        map<int, int>m1, m2;\\n        vector<int>ans;\\n        int cnt=0;\\n        for(int i=0; i<A.size(); i++){\\n            m1[A[i]]++;\\n            m2[B[i]]++;\\n            if(m1.find(B[i])!=m1.end()){cnt++;}\\n            if(m2.find(A[i])!=m2.end()){cnt++;}\\n            if(A[i]==B[i]){cnt--;}\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        map<int, int>m1, m2;\\n        vector<int>ans;\\n        int cnt=0;\\n        for(int i=0; i<A.size(); i++){\\n            m1[A[i]]++;\\n            m2[B[i]]++;\\n            if(m1.find(B[i])!=m1.end()){cnt++;}\\n            if(m2.find(A[i])!=m2.end()){cnt++;}\\n            if(A[i]==B[i]){cnt--;}\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475896,
                "title": "easy-understanding-o-n-time-complexity",
                "content": "\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        s = {}\\n        result = []\\n        n = len(A)\\n        count = 0\\n\\n        for i in range(n):\\n            if A[i] in s:\\n                s[A[i]] += 1\\n                count += 1\\n            else:\\n                s[A[i]] = 1\\n\\n            \\n            if B[i] in s:\\n                s[B[i]] += 1\\n                count += 1\\n            else:\\n                s[B[i]] = 1\\n            result.append(count)\\n        return result\\n\\n\\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        s = {}\\n        result = []\\n        n = len(A)\\n        count = 0\\n\\n        for i in range(n):\\n            if A[i] in s:\\n                s[A[i]] += 1\\n                count += 1\\n            else:\\n                s[A[i]] = 1\\n\\n            \\n            if B[i] in s:\\n                s[B[i]] += 1\\n                count += 1\\n            else:\\n                s[B[i]] = 1\\n            result.append(count)\\n        return result\\n\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3474066,
                "title": "easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& arr1, vector<int>& arr2) \\n\\t{\\n\\t\\tvector<int>ans;\\n\\t\\tvector<int>v;\\n\\t\\tint maxele = *max_element(arr1.begin(),arr1.end());\\n\\t\\tv.resize(maxele+1,0);\\n\\t\\tint count = 0;\\n\\t\\tint idx = 0;\\n\\t\\twhile(idx < arr1.size())\\n\\t\\t{\\n\\t\\t    v[arr1[idx]]++;\\n\\t\\t    v[arr2[idx]]++;\\n\\t\\t    int count = 0;\\n\\t\\t    for(int i=0;i<v.size();i++)\\n\\t\\t    {\\n\\t\\t    \\tif(v[i] == 2)\\n\\t\\t    \\t{\\n\\t\\t    \\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tans.push_back(count);\\n\\t\\t\\tidx++;\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& arr1, vector<int>& arr2) \\n\\t{\\n\\t\\tvector<int>ans;\\n\\t\\tvector<int>v;\\n\\t\\tint maxele = *max_element(arr1.begin(),arr1.end());\\n\\t\\tv.resize(maxele+1,0);\\n\\t\\tint count = 0;\\n\\t\\tint idx = 0;\\n\\t\\twhile(idx < arr1.size())\\n\\t\\t{\\n\\t\\t    v[arr1[idx]]++;\\n\\t\\t    v[arr2[idx]]++;\\n\\t\\t    int count = 0;\\n\\t\\t    for(int i=0;i<v.size();i++)\\n\\t\\t    {\\n\\t\\t    \\tif(v[i] == 2)\\n\\t\\t    \\t{\\n\\t\\t    \\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tans.push_back(count);\\n\\t\\t\\tidx++;\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469415,
                "title": "find-the-prefix-common-array-of-two-arrays-c-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n=A.size();\\n        vector<int> ans(n);\\n        ans[0]=0;\\n        ans[n-1]=n;\\n        vector<int> a(n+1,0);\\n        vector<int> b(n+1,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            a[A[i]]=1;\\n            b[B[i]]=1;\\n            int count=0;\\n            for(int j=1;j<=n;j++)\\n            {\\n                if(a[j]==1&&b[j]==1)\\n                {\\n                    count++;\\n                }\\n            }\\n            ans[i]=count;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n=A.size();\\n        vector<int> ans(n);\\n        ans[0]=0;\\n        ans[n-1]=n;\\n        vector<int> a(n+1,0);\\n        vector<int> b(n+1,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            a[A[i]]=1;\\n            b[B[i]]=1;\\n            int count=0;\\n            for(int j=1;j<=n;j++)\\n            {\\n                if(a[j]==1&&b[j]==1)\\n                {\\n                    count++;\\n                }\\n            }\\n            ans[i]=count;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469162,
                "title": "c-solution",
                "content": "```\\nint* findThePrefixCommonArray(int* A, int ASize, int* B, int BSize, int* returnSize){\\n    int* c = (int*)calloc(ASize, sizeof(int));\\n    int* count = (int*)calloc(ASize+1, sizeof(int));\\n    int commonCnt = 0;\\n    for(int i = 0; i < ASize; i++){\\n        count[A[i]]++;\\n        count[B[i]]++;\\n        if(count[A[i]] == 2) commonCnt++;\\n        if(count[B[i]] == 2 && A[i] != B[i]) commonCnt++;\\n        c[i] = commonCnt;\\n    }\\n    *returnSize = ASize;\\n    return c;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint* findThePrefixCommonArray(int* A, int ASize, int* B, int BSize, int* returnSize){\\n    int* c = (int*)calloc(ASize, sizeof(int));\\n    int* count = (int*)calloc(ASize+1, sizeof(int));\\n    int commonCnt = 0;\\n    for(int i = 0; i < ASize; i++){\\n        count[A[i]]++;\\n        count[B[i]]++;\\n        if(count[A[i]] == 2) commonCnt++;\\n        if(count[B[i]] == 2 && A[i] != B[i]) commonCnt++;\\n        c[i] = commonCnt;\\n    }\\n    *returnSize = ASize;\\n    return c;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3468672,
                "title": "hash-table-java-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int n = A.length;\\n        HashMap<Integer,Integer> mp1 = new HashMap<>();\\n        HashMap<Integer,Integer> mp2 = new HashMap<>();\\n        int[] C = new int[n];\\n        for(int i=0;i<n;i++){\\n            mp1.put(A[i],mp1.getOrDefault(A[i],0)+1);\\n            mp2.put(B[i],mp2.getOrDefault(B[i],0)+1);\\n            for(int x:mp1.keySet()){\\n                if(mp2.containsKey(x)){\\n                    C[i] += Math.min(mp1.get(x),mp2.get(x));\\n                }\\n            }\\n        }\\n        return C;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int n = A.length;\\n        HashMap<Integer,Integer> mp1 = new HashMap<>();\\n        HashMap<Integer,Integer> mp2 = new HashMap<>();\\n        int[] C = new int[n];\\n        for(int i=0;i<n;i++){\\n            mp1.put(A[i],mp1.getOrDefault(A[i],0)+1);\\n            mp2.put(B[i],mp2.getOrDefault(B[i],0)+1);\\n            for(int x:mp1.keySet()){\\n                if(mp2.containsKey(x)){\\n                    C[i] += Math.min(mp1.get(x),mp2.get(x));\\n                }\\n            }\\n        }\\n        return C;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468175,
                "title": "c",
                "content": "![image](https://assets.leetcode.com/users/images/b5f5c2fb-9367-4e2c-b6eb-593965b340d3_1682824695.380845.png)\\n```\\nint* findThePrefixCommonArray(int* A, int ASize, int* B, int BSize, int* returnSize) {\\n    int arr[51] = {0};\\n    *returnSize = ASize;\\n    int* C = (int*) calloc(ASize, sizeof(int));\\n    arr[A[0]]++;\\n    arr[B[0]]++;\\n    if (A[0] == B[0]) C[0]++;\\n    C[ASize-1] = ASize;\\n    for (int i = 1 ; i < ASize - 1; i++) {\\n        if (arr[A[i]] != 0) {\\n            C[i]++;\\n        } else {\\n            arr[A[i]]++;\\n        }\\n        if (arr[B[i]] != 0) {\\n            C[i]++;\\n        } else {\\n            arr[B[i]]++;\\n        }\\n        C[i] += C[i-1];\\n    }\\n    return C;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint* findThePrefixCommonArray(int* A, int ASize, int* B, int BSize, int* returnSize) {\\n    int arr[51] = {0};\\n    *returnSize = ASize;\\n    int* C = (int*) calloc(ASize, sizeof(int));\\n    arr[A[0]]++;\\n    arr[B[0]]++;\\n    if (A[0] == B[0]) C[0]++;\\n    C[ASize-1] = ASize;\\n    for (int i = 1 ; i < ASize - 1; i++) {\\n        if (arr[A[i]] != 0) {\\n            C[i]++;\\n        } else {\\n            arr[A[i]]++;\\n        }\\n        if (arr[B[i]] != 0) {\\n            C[i]++;\\n        } else {\\n            arr[B[i]]++;\\n        }\\n        C[i] += C[i-1];\\n    }\\n    return C;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3467669,
                "title": "c-code-using-vector",
                "content": "# Complexity\\n- Time complexity:\\n   O(N)\\n\\n- Space complexity:\\n O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n=A.size();\\n        vector<int>fr(n+1);\\n        vector<int>ans(n,0);\\n        int ct=0;\\n\\n        for(int i=0;i<n;i++){\\n            if(++fr[A[i]]==2)ct++;\\n            if(++fr[B[i]]==2)ct++;\\n            ans[i]=ct;\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n=A.size();\\n        vector<int>fr(n+1);\\n        vector<int>ans(n,0);\\n        int ct=0;\\n\\n        for(int i=0;i<n;i++){\\n            if(++fr[A[i]]==2)ct++;\\n            if(++fr[B[i]]==2)ct++;\\n            ans[i]=ct;\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467653,
                "title": "simple-python-solution-using-intersection-between-the-sets",
                "content": "# Approach:\\nPerform intersection of both the sets after adding each new element in both the sets A and B\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        setA,setB,n,res=set(),set(),len(A),list()\\n        for i in range(n):\\n            setA.add(A[i])\\n            setB.add(B[i])\\n            res.append(len(setA.intersection(setB)))\\n        return res       \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        setA,setB,n,res=set(),set(),len(A),list()\\n        for i in range(n):\\n            setA.add(A[i])\\n            setB.add(B[i])\\n            res.append(len(setA.intersection(setB)))\\n        return res       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467279,
                "title": "easy-solution-with-the-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ngo to the index and check the previous elements\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n-go to each and every element \\n-and check the prior elements if they match then increment the count variable initialised with zero\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) \\n    {\\n        vector<int>ans;\\n        int count=0;\\n        for(int i=0;i<A.size();i++)\\n        {\\n            for(int j=0;j<=i;j++)\\n            {\\n                for(int k=0;k<=i;k++)\\n                {\\n                    if( A[j]==B[k])\\n                        count++;\\n                }\\n            }\\n            ans.push_back(count);\\n            count=0;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# upvote me for the solution comment if any doubts\\n![images.jpeg](https://assets.leetcode.com/users/images/08f7a485-5bb3-4a9b-a6d6-5a4b513d8d6d_1682789008.721314.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) \\n    {\\n        vector<int>ans;\\n        int count=0;\\n        for(int i=0;i<A.size();i++)\\n        {\\n            for(int j=0;j<=i;j++)\\n            {\\n                for(int k=0;k<=i;k++)\\n                {\\n                    if( A[j]==B[k])\\n                        count++;\\n                }\\n            }\\n            ans.push_back(count);\\n            count=0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467278,
                "title": "easy-solution-with-the-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ngo to the index and check the previous elements\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n-go to each and every element \\n-and check the prior elements if they match then increment the count variable initialised with zero\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) \\n    {\\n        vector<int>ans;\\n        int count=0;\\n        for(int i=0;i<A.size();i++)\\n        {\\n            for(int j=0;j<=i;j++)\\n            {\\n                for(int k=0;k<=i;k++)\\n                {\\n                    if( A[j]==B[k])\\n                        count++;\\n                }\\n            }\\n            ans.push_back(count);\\n            count=0;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# upvote me for the solution comment if any doubts\\n![images.jpeg](https://assets.leetcode.com/users/images/08f7a485-5bb3-4a9b-a6d6-5a4b513d8d6d_1682789008.721314.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) \\n    {\\n        vector<int>ans;\\n        int count=0;\\n        for(int i=0;i<A.size();i++)\\n        {\\n            for(int j=0;j<=i;j++)\\n            {\\n                for(int k=0;k<=i;k++)\\n                {\\n                    if( A[j]==B[k])\\n                        count++;\\n                }\\n            }\\n            ans.push_back(count);\\n            count=0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467189,
                "title": "using-set-damn-easy-and-short-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        // vector<int> ans;\\n        int n=A.size();\\n        vector<int> ans(n,0);\\n        set<int> st;\\n        for(int i=0;i<n;i++){\\n            int cnt=0;\\n            st.insert(A[i]);\\n            for(int j=i;j>=0;j--){\\n                if(st.find(B[j])!=st.end())cnt++;\\n            }\\n            ans[i]=cnt;\\n        }\\n        return ans;\\n    }\\n};```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        // vector<int> ans;\\n        int n=A.size();\\n        vector<int> ans(n,0);\\n        set<int> st;\\n        for(int i=0;i<n;i++){\\n            int cnt=0;\\n            st.insert(A[i]);\\n            for(int j=i;j>=0;j--){\\n                if(st.find(B[j])!=st.end())cnt++;\\n            }\\n            ans[i]=cnt;\\n        }\\n        return ans;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 3467150,
                "title": "simplest-solution-o-n-hashset-java",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        HashSet<Integer> hs=new HashSet<>();\\n        int []out=new int[A.length];\\n        for(int i=0;i<A.length;i++){\\n            hs.add(A[i]);\\n            hs.add(B[i]);\\n            out[i]=2*(i+1)-hs.size();\\n        }\\n\\n        return out;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        HashSet<Integer> hs=new HashSet<>();\\n        int []out=new int[A.length];\\n        for(int i=0;i<A.length;i++){\\n            hs.add(A[i]);\\n            hs.add(B[i]);\\n            out[i]=2*(i+1)-hs.size();\\n        }\\n\\n        return out;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467148,
                "title": "c-easy-approach-using-set",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n=A.size();\\n        set<int> st1;\\n        set<int> st2;\\n        vector<int> ans(n,0);\\n        if(A[0]==B[0])\\n            ans[0]=1;\\n        st1.insert(A[0]);\\n        st2.insert(B[0]);\\n        for(int i=1;i<n;i++)\\n        {\\n            st1.insert(A[i]);\\n            st2.insert(B[i]);\\n            int cnt=0;\\n            for(int x:st1)\\n            {\\n                if(st2.find(x)!=st2.end())\\n                    cnt++;\\n            }\\n            ans[i]=cnt;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n=A.size();\\n        set<int> st1;\\n        set<int> st2;\\n        vector<int> ans(n,0);\\n        if(A[0]==B[0])\\n            ans[0]=1;\\n        st1.insert(A[0]);\\n        st2.insert(B[0]);\\n        for(int i=1;i<n;i++)\\n        {\\n            st1.insert(A[i]);\\n            st2.insert(B[i]);\\n            int cnt=0;\\n            for(int x:st1)\\n            {\\n                if(st2.find(x)!=st2.end())\\n                    cnt++;\\n            }\\n            ans[i]=cnt;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467105,
                "title": "simple-easy-8-line-of-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int>ans;\\n        unordered_set<int>st;\\n        for(int i=0; i<A.size(); i++) {\\n            st.insert(A[i]);\\n            st.insert(B[i]);\\n            int t= 2*(i+1)- st.size();\\n            ans.push_back(t);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int>ans;\\n        unordered_set<int>st;\\n        for(int i=0; i<A.size(); i++) {\\n            st.insert(A[i]);\\n            st.insert(B[i]);\\n            int t= 2*(i+1)- st.size();\\n            ans.push_back(t);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466989,
                "title": "java-solution-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[] arr = new int[A.length];\\n        int index = 0;\\n        \\n        for(int i = 0; i < A.length; i++) {\\n            int count = 0;\\n            Set<Integer> set = new HashSet<>();\\n            \\n            for(int j = 0; j <= i; j++) {\\n                set.add(A[j]);\\n            }\\n            \\n            for(int k = 0; k <= i; k++) {\\n                if(!set.add(B[k])) {\\n                    count++;\\n                }\\n            }\\n            \\n            arr[index++] = count;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[] arr = new int[A.length];\\n        int index = 0;\\n        \\n        for(int i = 0; i < A.length; i++) {\\n            int count = 0;\\n            Set<Integer> set = new HashSet<>();\\n            \\n            for(int j = 0; j <= i; j++) {\\n                set.add(A[j]);\\n            }\\n            \\n            for(int k = 0; k <= i; k++) {\\n                if(!set.add(B[k])) {\\n                    count++;\\n                }\\n            }\\n            \\n            arr[index++] = count;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466930,
                "title": "c-easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSo we know that we have to get common elements till i, while iterating in array.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNow if we have 1 at position 0 in vector 1 and position 2 in vector 2, then 1 won\\'t be common till positon 2. \\n\\nSo we get choose maximum of indices for this number and store it in common array.\\n\\nNow we have a ans vector, to store the total new answers we have for a particular indice in the array.\\n\\nNow for our answer, we know from above example at positon 2 we will have this pair as answer. But all of the pairs behind are also the answer.\\n\\nSo to add those we run the last loop.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n  O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n  O(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n        \\n        vector<int> common(n+1,0);\\n        \\n        for (int i=0;i<n;i++) {\\n            common[A[i]] = max(common[A[i]],i);\\n            common[B[i]] = max(common[B[i]],i);\\n        } \\n        \\n        vector<int> ans(n,0);\\n\\n        for (int i=0;i<n;i++) {\\n            ans[common[i+1]]++;\\n        }\\n        \\n        \\n        for (int i=1;i<n;i++) {\\n            ans[i] += ans[i-1];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n        \\n        vector<int> common(n+1,0);\\n        \\n        for (int i=0;i<n;i++) {\\n            common[A[i]] = max(common[A[i]],i);\\n            common[B[i]] = max(common[B[i]],i);\\n        } \\n        \\n        vector<int> ans(n,0);\\n\\n        for (int i=0;i<n;i++) {\\n            ans[common[i+1]]++;\\n        }\\n        \\n        \\n        for (int i=1;i<n;i++) {\\n            ans[i] += ans[i-1];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466894,
                "title": "java-contest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        HashMap<Integer,Integer> m1 = new HashMap<>();\\n        HashMap<Integer,Integer> m2 = new HashMap<>();\\n        int[] ans = new int[A.length];\\n        int a=0;\\n        for(int i=0;i<A.length;i++){\\n            m1.put(A[i],1);\\n            m2.put(B[i],1);\\n            int e = 0;\\n            for(int j=0;j<=i;j++){\\n                if(m1.containsKey(B[j])){\\n                    for(j=0;j<=i;j++){\\n                        if( m2.containsKey(A[j])){\\n                            ans[i]=a+1;\\n                    a++;\\n                 e=ans[i];\\n                        }\\n                    }\\n                \\n              }\\n                \\n            }\\n            a=0;\\n            \\n           ans[i]=e;\\n            \\n            \\n\\n        }\\n        return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        HashMap<Integer,Integer> m1 = new HashMap<>();\\n        HashMap<Integer,Integer> m2 = new HashMap<>();\\n        int[] ans = new int[A.length];\\n        int a=0;\\n        for(int i=0;i<A.length;i++){\\n            m1.put(A[i],1);\\n            m2.put(B[i],1);\\n            int e = 0;\\n            for(int j=0;j<=i;j++){\\n                if(m1.containsKey(B[j])){\\n                    for(j=0;j<=i;j++){\\n                        if( m2.containsKey(A[j])){\\n                            ans[i]=a+1;\\n                    a++;\\n                 e=ans[i];\\n                        }\\n                    }\\n                \\n              }\\n                \\n            }\\n            a=0;\\n            \\n           ans[i]=e;\\n            \\n            \\n\\n        }\\n        return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466867,
                "title": "easy-java-solution-sets-o-n-approach",
                "content": "\\n# Approach\\nTake a Set and start putting values inside it one by one. Make a expected Size which would represent the exptected size of the set if all the elements are unique.\\n\\nNow, if there are unique elements, then set wouldn\\'t add those elements, and therefore subtracting exptectedSize with the set size would result to our answer\\n\\n- Time complexity:\\nSince we traverse the array, therefore complexity would be O(N)\\n# Code\\n```\\nclass Solution {\\n    public static int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        Set<Integer> set = new HashSet<>();\\n        int[] ans = new int[A.length];\\n        int expectedSize = 2;\\n        for(int i = 0; i< A.length; i++){\\n            set.add(A[i]);\\n            set.add(B[i]);\\n\\n            ans[i] = expectedSize-set.size();\\n            expectedSize+=2;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        Set<Integer> set = new HashSet<>();\\n        int[] ans = new int[A.length];\\n        int expectedSize = 2;\\n        for(int i = 0; i< A.length; i++){\\n            set.add(A[i]);\\n            set.add(B[i]);\\n\\n            ans[i] = expectedSize-set.size();\\n            expectedSize+=2;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466793,
                "title": "simple-code-using-mapping",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        boolean t[] = new boolean[51];\\n        int len = A.length;\\n        int C[] = new int[len];\\n        int count = 0;\\n        for(int i=0; i<len; i++){\\n            \\n            if(t[A[i]] && t[B[i]]){\\n                count+=2;\\n                C[i] = count;\\n            }  \\n\\n            else if(t[A[i]] || t[B[i]] || A[i] == B[i] ) C[i] = ++count;\\n\\n            else C[i] = count;\\n            \\n            t[A[i]] = true;\\n            t[B[i]] = true;\\n        }\\n        return C;\\n    }   \\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        boolean t[] = new boolean[51];\\n        int len = A.length;\\n        int C[] = new int[len];\\n        int count = 0;\\n        for(int i=0; i<len; i++){\\n            \\n            if(t[A[i]] && t[B[i]]){\\n                count+=2;\\n                C[i] = count;\\n            }  \\n\\n            else if(t[A[i]] || t[B[i]] || A[i] == B[i] ) C[i] = ++count;\\n\\n            else C[i] = count;\\n            \\n            t[A[i]] = true;\\n            t[B[i]] = true;\\n        }\\n        return C;\\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466783,
                "title": "only-map-tc-o-n-easy-understsnding-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n=A.size();\\n        vector<int> c(n);\\n        unordered_map<int , int> mp;\\n        int prevsum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(mp[A[i]] || mp[B[i]] || (A[i]==B[i]))\\n            {\\n                if(A[i]==B[i])\\n                {\\n                   c[i]=prevsum+mp[A[i]]+mp[B[i]]+1; \\n                }\\n                else\\n                {\\n                    c[i]=prevsum+mp[A[i]]+mp[B[i]];\\n                }\\n                \\n            }\\n            else\\n            {\\n                c[i]=0+prevsum;\\n            }\\n            prevsum=c[i];\\n            mp[A[i]]=1;\\n            mp[B[i]]=1;\\n            \\n        }\\n        return c;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n=A.size();\\n        vector<int> c(n);\\n        unordered_map<int , int> mp;\\n        int prevsum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(mp[A[i]] || mp[B[i]] || (A[i]==B[i]))\\n            {\\n                if(A[i]==B[i])\\n                {\\n                   c[i]=prevsum+mp[A[i]]+mp[B[i]]+1; \\n                }\\n                else\\n                {\\n                    c[i]=prevsum+mp[A[i]]+mp[B[i]];\\n                }\\n                \\n            }\\n            else\\n            {\\n                c[i]=0+prevsum;\\n            }\\n            prevsum=c[i];\\n            mp[A[i]]=1;\\n            mp[B[i]]=1;\\n            \\n        }\\n        return c;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466761,
                "title": "dart-solution-using-hashmaps",
                "content": "\\n# Code\\n```\\nclass Solution {\\n  List<int> findThePrefixCommonArray(List<int> A, List<int> B) {\\n    List<int> result = [];\\n    for (int i = 1; i <= A.length; i++) {\\n      result.add(countCommonNumbers(A.sublist(0, i), B.sublist(0, i)));\\n    }\\n    return result;\\n  }\\n\\n  int countCommonNumbers(List<int> A, List<int> B) {\\n    Map<int, int> freq1 = {};\\n    Map<int, int> freq2 = {};\\n\\n    int result = 0;\\n\\n    for (int i = 0; i < A.length; i++) {\\n      if (!freq1.containsKey(A[i])) {\\n        freq1[A[i]] = 1;\\n      } else {\\n        freq1[A[i]] = freq1[A[i]]! + 1;\\n      }\\n    }\\n\\n    for (int i = 0; i < B.length; i++) {\\n      if (!freq2.containsKey(B[i])) {\\n        freq2[B[i]] = 1;\\n      } else {\\n        freq2[B[i]] = freq2[B[i]]! + 1;\\n      }\\n    }\\n\\n    for (var x in freq1.entries) {\\n      int countsInA = x.value;\\n      int countsInB = 0;\\n      if (freq2.containsKey(x.key)) {\\n        countsInB = freq2[x.key]!;\\n      }\\n      result += countsInA < countsInB ? countsInA : countsInB;\\n    }\\n    return result;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  List<int> findThePrefixCommonArray(List<int> A, List<int> B) {\\n    List<int> result = [];\\n    for (int i = 1; i <= A.length; i++) {\\n      result.add(countCommonNumbers(A.sublist(0, i), B.sublist(0, i)));\\n    }\\n    return result;\\n  }\\n\\n  int countCommonNumbers(List<int> A, List<int> B) {\\n    Map<int, int> freq1 = {};\\n    Map<int, int> freq2 = {};\\n\\n    int result = 0;\\n\\n    for (int i = 0; i < A.length; i++) {\\n      if (!freq1.containsKey(A[i])) {\\n        freq1[A[i]] = 1;\\n      } else {\\n        freq1[A[i]] = freq1[A[i]]! + 1;\\n      }\\n    }\\n\\n    for (int i = 0; i < B.length; i++) {\\n      if (!freq2.containsKey(B[i])) {\\n        freq2[B[i]] = 1;\\n      } else {\\n        freq2[B[i]] = freq2[B[i]]! + 1;\\n      }\\n    }\\n\\n    for (var x in freq1.entries) {\\n      int countsInA = x.value;\\n      int countsInB = 0;\\n      if (freq2.containsKey(x.key)) {\\n        countsInB = freq2[x.key]!;\\n      }\\n      result += countsInA < countsInB ? countsInA : countsInB;\\n    }\\n    return result;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466734,
                "title": "python-set-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        seen_of_A = set()\\n        seen_of_B = set()\\n        c=[0]*len(A)\\n        common=0\\n        for i in range(len(A)):\\n            if A[i]==B[i]:\\n                common +=1\\n            if A[i] in seen_of_B:\\n                common +=1\\n            if B[i] in seen_of_A:\\n                common +=1\\n            c[i] = common\\n            seen_of_A.add(A[i])\\n            seen_of_B.add(B[i])\\n        return c\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        seen_of_A = set()\\n        seen_of_B = set()\\n        c=[0]*len(A)\\n        common=0\\n        for i in range(len(A)):\\n            if A[i]==B[i]:\\n                common +=1\\n            if A[i] in seen_of_B:\\n                common +=1\\n            if B[i] in seen_of_A:\\n                common +=1\\n            c[i] = common\\n            seen_of_A.add(A[i])\\n            seen_of_B.add(B[i])\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466686,
                "title": "python-1-line",
                "content": "```python\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        return [len(set(A[:i+1]) & set(B[:i+1])) for i in range(len(A))]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        return [len(set(A[:i+1]) & set(B[:i+1])) for i in range(len(A))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466669,
                "title": "c-map",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_map<int,int> mp1,mp2;\\n        int cnt=0;\\n        vector<int> ans;\\n        for(int i=0;i<A.size();i++){\\n            mp1[A[i]]++;\\n            mp2[B[i]]++;\\n            \\n            if(mp1.find(B[i])!=mp1.end()){\\n                cnt+=1;\\n            }\\n            if(mp2.find(A[i])!=mp2.end() && A[i]!=B[i]){\\n                cnt+=1;\\n            }\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_map<int,int> mp1,mp2;\\n        int cnt=0;\\n        vector<int> ans;\\n        for(int i=0;i<A.size();i++){\\n            mp1[A[i]]++;\\n            mp2[B[i]]++;\\n            \\n            if(mp1.find(B[i])!=mp1.end()){\\n                cnt+=1;\\n            }\\n            if(mp2.find(A[i])!=mp2.end() && A[i]!=B[i]){\\n                cnt+=1;\\n            }\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466650,
                "title": "beginner-friendly-java-one-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[] ans = new int[A.length];\\n        int[] arr=new int[A.length+1];\\n        int idx=0;\\n        int x=0;\\n        while(idx<A.length)\\n        {\\n            arr[A[idx]]++;\\n            arr[B[idx]]++;\\n            if(arr[A[idx]]==2)x++;\\n            if(arr[B[idx]]==2)x++;\\n            \\n            if(A[idx]==B[idx])x--;\\n            ans[idx]=x;\\n            idx++;\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[] ans = new int[A.length];\\n        int[] arr=new int[A.length+1];\\n        int idx=0;\\n        int x=0;\\n        while(idx<A.length)\\n        {\\n            arr[A[idx]]++;\\n            arr[B[idx]]++;\\n            if(arr[A[idx]]==2)x++;\\n            if(arr[B[idx]]==2)x++;\\n            \\n            if(A[idx]==B[idx])x--;\\n            ans[idx]=x;\\n            idx++;\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4097211,
                "title": "best-solution-using-hash-map-in-c",
                "content": "\\n# C++\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector <int> v1;\\n        map <int , int> mp;\\n        for(int i = 0; i < A.size(); i++) {\\n            mp[A[i]] = i;\\n            int count = 0;\\n            for(int j = 0; j < mp.size(); j++) {\\n                if(mp.find(B[j]) != mp.end()) {\\n                    count++;\\n                }\\n            }\\n            v1.push_back(count);\\n        }\\n        return v1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector <int> v1;\\n        map <int , int> mp;\\n        for(int i = 0; i < A.size(); i++) {\\n            mp[A[i]] = i;\\n            int count = 0;\\n            for(int j = 0; j < mp.size(); j++) {\\n                if(mp.find(B[j]) != mp.end()) {\\n                    count++;\\n                }\\n            }\\n            v1.push_back(count);\\n        }\\n        return v1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4097156,
                "title": "best-solution-using-brute-force-in-c",
                "content": "\\n# C++\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector <int> v1;\\n        for(int i = 0; i < A.size(); i++) {\\n            int count = 0;\\n            for(int j = 0; j < i+1; j++) {\\n                for(int k = 0; k < i+1; k++) {\\n                    if(B[k] == A[j]) {\\n                        count++;\\n                    }\\n                }\\n            }\\n            v1.push_back(count);\\n        }\\n        return v1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector <int> v1;\\n        for(int i = 0; i < A.size(); i++) {\\n            int count = 0;\\n            for(int j = 0; j < i+1; j++) {\\n                for(int k = 0; k < i+1; k++) {\\n                    if(B[k] == A[j]) {\\n                        count++;\\n                    }\\n                }\\n            }\\n            v1.push_back(count);\\n        }\\n        return v1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4095762,
                "title": "using-simple-map-c-o-n-beats-others",
                "content": "\\n\\nTIME COMPLEXITY IS O(N)\\nAFTER READING SOLUTION STILL FACE ANY DOUBTS-\\n1> COMMENT BELOW , I M ACTIVE ON LC \\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n   \\'\\'\\'     // FIRST STEP IS TO CHECK \\n        // PHLA ELEMENT DONO array ka same h ya alag h \\n        vector<int>v;\\n        int count=0;\\n        if(A[0]==B[0])\\n        {\\n            count++; // same number mila to count 0->1\\n            v.push_back(count); // store kra lo count ko 0 index par\\n        }\\n        else\\n        {\\n            //remain count be 0 bcz dono element alg h \\n            v.push_back(0);\\n        }\\n        // now bcz we have visited 0 index elements of a and b \\n        // now we will store them in map\\n        \\n        unordered_map<int,int>mp;  //key,frequency\\n        mp[A[0]]++;\\n        mp[B[0]]++;\\n        \\n        //now we must traverse for index 1 to n-1\\n        \\n        for(int i=1;i<A.size();i++)\\n        {\\n            //check if they are same \\n            if(A[i]==B[i])\\n            {\\n                count++;  //  for eg a[0],b[0] = 1,3 and a[1]b[1]= 1,1 toh 1 -> comes 3 times ..so common pair for both array will be only 1,1 so count+=1;\\n                \\n                v.push_back(count);\\n            }\\n            else\\n            {\\n                //agr same ni different ho tbh \\n                //check kro vo map mh h ya nhi , if exist in map then we can count them as repeated \\n                if(mp.find(A[i])!=mp.end())   \\n                {   count++; }\\n                if(mp.find(B[i])!=mp.end())\\n                {\\n                    count++;\\n                }\\n                  v.push_back(count);\\n                // add all visited elemnts in map \\n                mp[A[i]]++;\\n                mp[B[i]]++;\\n            }\\n        }\\n        \\n      return v;\\n        \\'\\'\\'\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n   \\'\\'\\'     // FIRST STEP IS TO CHECK \\n        // PHLA ELEMENT DONO array ka same h ya alag h \\n        vector<int>v;\\n        int count=0;\\n        if(A[0]==B[0])\\n        {\\n            count++; // same number mila to count 0->1\\n            v.push_back(count); // store kra lo count ko 0 index par\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4090389,
                "title": "o-n-solution-one-set-easely-can-be-rewriten-for-any-language",
                "content": "# Intuition\\nThere were too many overcomplicated solutions so I decided to try to use only one Set \\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[] res = new int[A.length];\\n        \\n        HashSet<Integer> mem = new HashSet<>();\\n        mem.add(A[0]); \\n        res[0] = mem.add(B[0]) ? 0 : 1; // if first value eq second value then it\\'s common prefix \\n\\n        for (int i = 1; i < res.length; i++) {\\n            int c = mem.add(A[i]) ? 0 : 1;\\n            c += mem.add(B[i]) ? 0 : 1;\\n            res[i] = c + res[i - 1]; // number of common prefixes can\\'t decrease, so we can reuse calculated on previous iteration value\\n        }\\n\\n        return res;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[] res = new int[A.length];\\n        \\n        HashSet<Integer> mem = new HashSet<>();\\n        mem.add(A[0]); \\n        res[0] = mem.add(B[0]) ? 0 : 1; // if first value eq second value then it\\'s common prefix \\n\\n        for (int i = 1; i < res.length; i++) {\\n            int c = mem.add(A[i]) ? 0 : 1;\\n            c += mem.add(B[i]) ? 0 : 1;\\n            res[i] = c + res[i - 1]; // number of common prefixes can\\'t decrease, so we can reuse calculated on previous iteration value\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079189,
                "title": "solve-using-stack-o-n-complexity",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def findThePrefixCommonArray(self, a: List[int], b: List[int]) -> List[int]:\\n        stack = []\\n        i = 0\\n        n = len(a)\\n        count = 0\\n        ans = [0]*n\\n        while i<n:\\n            #if num in stack, increase count else add in stack\\n            if a[i] in stack: count +=1\\n            if a[i] not in stack:\\n                stack.append(a[i])\\n            #if num in stack, increase count else add in stack\\n            if b[i] in stack: count +=1\\n            if b[i] not in stack:\\n                stack.append(b[i])\\n            ans[i] = count\\n            i+=1\\n        return ans\\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Stack",
                    "Counting"
                ],
                "code": "```\\nclass Solution:\\n    def findThePrefixCommonArray(self, a: List[int], b: List[int]) -> List[int]:\\n        stack = []\\n        i = 0\\n        n = len(a)\\n        count = 0\\n        ans = [0]*n\\n        while i<n:\\n            #if num in stack, increase count else add in stack\\n            if a[i] in stack: count +=1\\n            if a[i] not in stack:\\n                stack.append(a[i])\\n            #if num in stack, increase count else add in stack\\n            if b[i] in stack: count +=1\\n            if b[i] not in stack:\\n                stack.append(b[i])\\n            ans[i] = count\\n            i+=1\\n        return ans\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4073550,
                "title": "easy-to-understand-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        ans = [0] * len(A)\\n\\n        for i in range(len(A)):\\n            common_A = Counter(A[:i+1])\\n            common_B = Counter(B[:i+1])\\n            common = common_A & common_B\\n            ans[i] = len(common)\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        ans = [0] * len(A)\\n\\n        for i in range(len(A)):\\n            common_A = Counter(A[:i+1])\\n            common_B = Counter(B[:i+1])\\n            common = common_A & common_B\\n            ans[i] = len(common)\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4071263,
                "title": "a-simple-solution-with-two-sets-beats-94",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        seen_a, seen_b = set(), set()\\n        counter, counts = 0, []\\n        for a, b in zip(A,B):\\n            seen_a.add(a)\\n            seen_b.add(b)\\n            counter += (a in seen_b) + (b in seen_a) - (a == b)\\n            counts.append(counter)\\n\\n        return counts\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        seen_a, seen_b = set(), set()\\n        counter, counts = 0, []\\n        for a, b in zip(A,B):\\n            seen_a.add(a)\\n            seen_b.add(b)\\n            counter += (a in seen_b) + (b in seen_a) - (a == b)\\n            counts.append(counter)\\n\\n        return counts\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065710,
                "title": "super-easy-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n\\n        int cnt=0;\\n        vector<int>v;\\n        unordered_map<int,int>mp1;\\n        for(int i=0;i<A.size();i++)\\n        {\\n            if(A[i]==B[i])\\n            {\\n                cnt++;\\n            }\\n            if(mp1.find(A[i])!=mp1.end())\\n            {\\n                cnt++;\\n            }\\n            if(mp1.find(B[i])!=mp1.end())\\n            {\\n                cnt++;\\n            }\\n            mp1[A[i]]++;\\n            mp1[B[i]]++;\\n            v.push_back(cnt);\\n        }\\n        return v;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n\\n        int cnt=0;\\n        vector<int>v;\\n        unordered_map<int,int>mp1;\\n        for(int i=0;i<A.size();i++)\\n        {\\n            if(A[i]==B[i])\\n            {\\n                cnt++;\\n            }\\n            if(mp1.find(A[i])!=mp1.end())\\n            {\\n                cnt++;\\n            }\\n            if(mp1.find(B[i])!=mp1.end())\\n            {\\n                cnt++;\\n            }\\n            mp1[A[i]]++;\\n            mp1[B[i]]++;\\n            v.push_back(cnt);\\n        }\\n        return v;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4058591,
                "title": "java-simple-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int C[]=new int[A.length];\\n        Set<Integer> set = new HashSet();\\n        set.add(A[0]);\\n        set.add(B[0]);\\n        C[0]=A[0]==B[0]?1:0;\\n   \\n   \\n     \\n        for(int i=1;i<A.length;i++){\\n               \\n               if(A[i]!=B[i]){\\n               C[i]=C[i-1]+(set.contains(B[i])?1:0);\\n               C[i]+=set.contains(A[i])?1:0;\\n               }\\n               else{\\n            C[i]=C[i-1]+1;\\n               }\\n            \\n set.add(A[i]);\\n        set.add(B[i]);\\n        }\\nreturn C;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int C[]=new int[A.length];\\n        Set<Integer> set = new HashSet();\\n        set.add(A[0]);\\n        set.add(B[0]);\\n        C[0]=A[0]==B[0]?1:0;\\n   \\n   \\n     \\n        for(int i=1;i<A.length;i++){\\n               \\n               if(A[i]!=B[i]){\\n               C[i]=C[i-1]+(set.contains(B[i])?1:0);\\n               C[i]+=set.contains(A[i])?1:0;\\n               }\\n               else{\\n            C[i]=C[i-1]+1;\\n               }\\n            \\n set.add(A[i]);\\n        set.add(B[i]);\\n        }\\nreturn C;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4053192,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[] result = new int[A.length];\\n        HashMap<Integer, Integer> mapA = new HashMap<>();\\n        HashMap<Integer, Integer> mapB = new HashMap<>();\\n        for(int i=0; i<A.length; i++) {\\n            mapA.put(A[i], mapA.getOrDefault(A[i], 0)+1);\\n            mapB.put(B[i], mapB.getOrDefault(B[i], 0)+1);\\n            for(int a: mapA.keySet()) {\\n                if(mapB.containsKey(a)) {\\n                    result[i] += mapA.get(a);\\n                }\\n            }\\n        }\\n        for(int i=0; i<result.length; i++) {\\n            System.out.println(result[i]);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[] result = new int[A.length];\\n        HashMap<Integer, Integer> mapA = new HashMap<>();\\n        HashMap<Integer, Integer> mapB = new HashMap<>();\\n        for(int i=0; i<A.length; i++) {\\n            mapA.put(A[i], mapA.getOrDefault(A[i], 0)+1);\\n            mapB.put(B[i], mapB.getOrDefault(B[i], 0)+1);\\n            for(int a: mapA.keySet()) {\\n                if(mapB.containsKey(a)) {\\n                    result[i] += mapA.get(a);\\n                }\\n            }\\n        }\\n        for(int i=0; i<result.length; i++) {\\n            System.out.println(result[i]);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4046828,
                "title": "very-easy-c-code-beginner-friendly",
                "content": "# Intuition\\nThe intution is to use 2 hash maps to keep check of what integers we\\'ve encountered so far in both vectors A and B. As we pass through an integer we\\'ll add that number and it\\'s freq(1) in the maps.\\nthen in second loop we\\'ll iterate through maps. As it is given that size of both arrays will be equal, that means size of hashMaps will also be equal, till integers traversed. \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int>ans;\\n         int count=0;\\n         unordered_map<int,int>mp1;\\n         unordered_map<int,int>mp2;\\n         \\n         for(int i=0;i<A.size();i++)\\n            count=0;\\n             int j=0;\\n            mp1[A[i]]=1;\\n            mp2[B[i]]=1;\\n            for(auto x:mp1)\\n           {\\n              if(mp2.find(x.first)!=mp2.end() && x.second==mp2[B[j]] )\\n              \\n              {\\n                  count++;\\n              }\\n              \\n              j++;\\n           }\\n           ans.push_back(count);\\n         }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int>ans;\\n         int count=0;\\n         unordered_map<int,int>mp1;\\n         unordered_map<int,int>mp2;\\n         \\n         for(int i=0;i<A.size();i++)\\n            count=0;\\n             int j=0;\\n            mp1[A[i]]=1;\\n            mp2[B[i]]=1;\\n            for(auto x:mp1)\\n           {\\n              if(mp2.find(x.first)!=mp2.end() && x.second==mp2[B[j]] )\\n              \\n              {\\n                  count++;\\n              }\\n              \\n              j++;\\n           }\\n           ans.push_back(count);\\n         }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045163,
                "title": "1ms-100-java-no-map",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBasically whenever a number has occured two times, that is in both arrays, we increment count.So, count keeps track of all the COMMON elements that have occured yet in both arrays. So in each iteration we put value of count in our ans array\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[]frq  = new int[A.length+1];\\n        int[]ans  = new int[A.length];\\n        int count=0;\\n\\n        for(int i=0; i<ans.length; i++){\\n            frq[A[i]]++;\\n            if(frq[A[i]] == 2) count++;\\n            frq[B[i]]++;\\n            if(frq[B[i]] == 2) count++;\\n\\n            ans[i] = count;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[]frq  = new int[A.length+1];\\n        int[]ans  = new int[A.length];\\n        int count=0;\\n\\n        for(int i=0; i<ans.length; i++){\\n            frq[A[i]]++;\\n            if(frq[A[i]] == 2) count++;\\n            frq[B[i]]++;\\n            if(frq[B[i]] == 2) count++;\\n\\n            ans[i] = count;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043985,
                "title": "short-one",
                "content": "# Code\\n```\\nclass Solution {\\n    fun findThePrefixCommonArray(a: IntArray, b: IntArray) = IntArray(a.size) { i ->\\n        a.sliceArray(0..i).intersect(b.sliceArray(0..i).toSet()).size\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun findThePrefixCommonArray(a: IntArray, b: IntArray) = IntArray(a.size) { i ->\\n        a.sliceArray(0..i).intersect(b.sliceArray(0..i).toSet()).size\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040536,
                "title": "hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n        vector<int>res, vis(n);\\n        int cnt=0;\\n        unordered_map<int, int>mp;\\n        for(int i=0; i<n; i++){\\n            vis[A[i]-1]++;\\n            vis[B[i]-1]++;\\n            for(int j=0; j<n; j++)\\n            {\\n                if(vis[j]==2){\\n                    mp[i]++;\\n                }\\n            }\\n            cnt=mp[i];\\n            res.push_back(cnt);\\n        }\\n        for(auto i: vis){\\n            cout<<i<<\" \";\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n        vector<int>res, vis(n);\\n        int cnt=0;\\n        unordered_map<int, int>mp;\\n        for(int i=0; i<n; i++){\\n            vis[A[i]-1]++;\\n            vis[B[i]-1]++;\\n            for(int j=0; j<n; j++)\\n            {\\n                if(vis[j]==2){\\n                    mp[i]++;\\n                }\\n            }\\n            cnt=mp[i];\\n            res.push_back(cnt);\\n        }\\n        for(auto i: vis){\\n            cout<<i<<\" \";\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4039869,
                "title": "easy-python-solution-using-dict",
                "content": "# Approach\\nInitialize a dict to keep the counter. Loop through A and B if the element is there in the dict then increment the counter else add the key to the dict. Finally add the counter to the `output`.\\n\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```py\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        charDict = {}\\n        output, counter = [], 0 \\n        for i in range(len(A)) : \\n            if A[i] not in charDict.keys() : \\n                charDict[A[i]] = 1 \\n            else : \\n                charDict[A[i]] += 1 \\n                counter += 1 \\n\\n            if B[i] not in charDict.keys() : \\n                charDict[B[i]] = 1 \\n            else :\\n                charDict[B[i]] += 1\\n                counter += 1 \\n\\n            output.append(counter)\\n\\n        return output \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table"
                ],
                "code": "```py\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        charDict = {}\\n        output, counter = [], 0 \\n        for i in range(len(A)) : \\n            if A[i] not in charDict.keys() : \\n                charDict[A[i]] = 1 \\n            else : \\n                charDict[A[i]] += 1 \\n                counter += 1 \\n\\n            if B[i] not in charDict.keys() : \\n                charDict[B[i]] = 1 \\n            else :\\n                charDict[B[i]] += 1\\n                counter += 1 \\n\\n            output.append(counter)\\n\\n        return output \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038273,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int> answer;\\n\\n        for(int i=0;i<A.size();i++){\\n            int count=0;\\n            for(int m=0;m<=i;m++){\\n            for(int j=0;j<=i;j++){\\n                if(A[m]==B[j]){\\n                count++;\\n                }\\n            }\\n        }\\n        answer.push_back(count);\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int> answer;\\n\\n        for(int i=0;i<A.size();i++){\\n            int count=0;\\n            for(int m=0;m<=i;m++){\\n            for(int j=0;j<=i;j++){\\n                if(A[m]==B[j]){\\n                count++;\\n                }\\n            }\\n        }\\n        answer.push_back(count);\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023323,
                "title": "java-solution-using-hashmap-o-n-tc-beats-75",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[] ans = new int[A.length];\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        int temp = 0;\\n        for(int i = 0; i < A.length; i++){\\n            if(A[i]==B[i]){\\n                temp++;\\n                ans[i] = temp;\\n            }\\n            else if(hm.containsKey(A[i])){\\n                temp++;\\n            }\\n            else{\\n                hm.put(A[i], 1);\\n            }\\n            if(hm.containsKey(B[i])){\\n                temp++;\\n            }\\n            else{\\n                hm.put(B[i], 1);\\n            }\\n            ans[i] = temp;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[] ans = new int[A.length];\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        int temp = 0;\\n        for(int i = 0; i < A.length; i++){\\n            if(A[i]==B[i]){\\n                temp++;\\n                ans[i] = temp;\\n            }\\n            else if(hm.containsKey(A[i])){\\n                temp++;\\n            }\\n            else{\\n                hm.put(A[i], 1);\\n            }\\n            if(hm.containsKey(B[i])){\\n                temp++;\\n            }\\n            else{\\n                hm.put(B[i], 1);\\n            }\\n            ans[i] = temp;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022377,
                "title": "map-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n\\n      vector<int> ans;\\n     \\n     unordered_map<int,int> mymap;\\n     int count=0;\\n     for(int i=0;i<A.size();i++)\\n      {\\n        mymap[A[i]]++;\\n        mymap[B[i]]++;\\n        if(A[i]!=B[i]){\\n            if(mymap[A[i]] >= 2) count++;\\n            if(mymap[B[i]] >= 2) count++;\\n        }\\n        else{\\n            count++;\\n        }\\n          ans.push_back(count);\\n         \\n      } \\n\\n      return ans;\\n\\n       \\n\\n       \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n\\n      vector<int> ans;\\n     \\n     unordered_map<int,int> mymap;\\n     int count=0;\\n     for(int i=0;i<A.size();i++)\\n      {\\n        mymap[A[i]]++;\\n        mymap[B[i]]++;\\n        if(A[i]!=B[i]){\\n            if(mymap[A[i]] >= 2) count++;\\n            if(mymap[B[i]] >= 2) count++;\\n        }\\n        else{\\n            count++;\\n        }\\n          ans.push_back(count);\\n         \\n      } \\n\\n      return ans;\\n\\n       \\n\\n       \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022366,
                "title": "simple-solution-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n\\n      vector<int> ans;\\n      int count=0;\\n      if(A[0]!=B[0]){\\n          ans.push_back(0);\\n\\n      }else{\\n          count++; \\n          ans.push_back(1);\\n      }\\n     map<int,int> mymap;\\n\\n     mymap[A[0]]++;\\n     mymap[B[0]]++;\\n\\n\\n      for(int i=1;i<A.size();i++)\\n      {\\n        mymap[A[i]]++;\\n        mymap[B[i]]++;\\n        if(A[i]!=B[i]){\\n            if(mymap[A[i]] >= 2) count++;\\n            if(mymap[B[i]] >= 2) count++;\\n        }\\n        else{\\n            count++;\\n        }\\n          ans.push_back(count);\\n         \\n      } \\n\\n      return ans;\\n\\n       \\n\\n       \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n\\n      vector<int> ans;\\n      int count=0;\\n      if(A[0]!=B[0]){\\n          ans.push_back(0);\\n\\n      }else{\\n          count++; \\n          ans.push_back(1);\\n      }\\n     map<int,int> mymap;\\n\\n     mymap[A[0]]++;\\n     mymap[B[0]]++;\\n\\n\\n      for(int i=1;i<A.size();i++)\\n      {\\n        mymap[A[i]]++;\\n        mymap[B[i]]++;\\n        if(A[i]!=B[i]){\\n            if(mymap[A[i]] >= 2) count++;\\n            if(mymap[B[i]] >= 2) count++;\\n        }\\n        else{\\n            count++;\\n        }\\n          ans.push_back(count);\\n         \\n      } \\n\\n      return ans;\\n\\n       \\n\\n       \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4017925,
                "title": "very-simple-approach-using-map-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_map<int,int>mp1;\\n        unordered_map<int,int>mp2;\\n        int count=0;\\n        vector<int>ans;\\n        for(int i=0;i<A.size();i++)\\n        {\\n           mp1[A[i]]++;\\n           mp2[B[i]]++;\\n           count=0;\\n           for(int j=0;j<=i;j++)\\n           {   \\n           if(mp2.find(A[j])!=mp1.end())\\n           {\\n               count++;\\n           }\\n           }\\n           ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_map<int,int>mp1;\\n        unordered_map<int,int>mp2;\\n        int count=0;\\n        vector<int>ans;\\n        for(int i=0;i<A.size();i++)\\n        {\\n           mp1[A[i]]++;\\n           mp2[B[i]]++;\\n           count=0;\\n           for(int j=0;j<=i;j++)\\n           {   \\n           if(mp2.find(A[j])!=mp1.end())\\n           {\\n               count++;\\n           }\\n           }\\n           ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4015110,
                "title": "95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n=A.size();\\n        vector<int>ans(n);int count=0;\\n        vector<int>seen(n+1);\\n        for(int i=0;i<n;i++){\\n            if(++seen[A[i]]==2)count++;\\n            if(++seen[B[i]]==2)count++;\\n            ans[i]=count;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n=A.size();\\n        vector<int>ans(n);int count=0;\\n        vector<int>seen(n+1);\\n        for(int i=0;i<n;i++){\\n            if(++seen[A[i]]==2)count++;\\n            if(++seen[B[i]]==2)count++;\\n            ans[i]=count;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012750,
                "title": "using-hash-set-and-indexing",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) \\n    {\\n       vector<int> v;\\n       set<int> s;\\n       for(int i=0;i<A.size();i++)\\n       {\\n           s.insert(A[i]);\\n           s.insert(B[i]);\\n           if(s.size() >= 2*(i+1))\\n           {\\n               \\n              \\n              v.push_back(s.size()-2*(i+1));\\n           }\\n           else\\n           {\\n               \\n             \\n                v.push_back(2*(i+1)-s.size());\\n           }\\n       }\\n       return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) \\n    {\\n       vector<int> v;\\n       set<int> s;\\n       for(int i=0;i<A.size();i++)\\n       {\\n           s.insert(A[i]);\\n           s.insert(B[i]);\\n           if(s.size() >= 2*(i+1))\\n           {\\n               \\n              \\n              v.push_back(s.size()-2*(i+1));\\n           }\\n           else\\n           {\\n               \\n             \\n                v.push_back(2*(i+1)-s.size());\\n           }\\n       }\\n       return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010121,
                "title": "very-simple-javascript-typescript-solution-set-array",
                "content": "\\n# Set\\n```\\nconst findThePrefixCommonArray = (A, B) => {\\n    const set = new Set();\\n    const result = [];\\n    let cnt = 0;\\n\\n    for (let i = 0; i < A.length; i++) {\\n        if (set.has(A[i])) {\\n            cnt++;\\n        } else {\\n           set.add(A[i]);\\n        }\\n\\n        if (set.has(B[i])) {\\n            cnt++;\\n        } else {\\n           set.add(B[i])\\n        }\\n\\n        result[i] = cnt;\\n    }\\n\\n    return result;\\n};\\n```\\n\\n\\n\\n# Array\\n```\\nconst findThePrefixCommonArray = (A, B) => {\\n    const arr = [];\\n    const result = [];\\n    let cnt = 0;\\n\\n    for (let i = 0; i < A.length; i++) {\\n        if (arr[A[i]]) {\\n            cnt++;\\n        } else {\\n           arr[A[i]] = 1; \\n        }\\n\\n        if (arr[B[i]]) {\\n            cnt++;\\n        } else {\\n           arr[B[i]] = 1; \\n        }\\n\\n        result[i] = cnt;\\n    }\\n\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array",
                    "Ordered Set"
                ],
                "code": "```\\nconst findThePrefixCommonArray = (A, B) => {\\n    const set = new Set();\\n    const result = [];\\n    let cnt = 0;\\n\\n    for (let i = 0; i < A.length; i++) {\\n        if (set.has(A[i])) {\\n            cnt++;\\n        } else {\\n           set.add(A[i]);\\n        }\\n\\n        if (set.has(B[i])) {\\n            cnt++;\\n        } else {\\n           set.add(B[i])\\n        }\\n\\n        result[i] = cnt;\\n    }\\n\\n    return result;\\n};\\n```\n```\\nconst findThePrefixCommonArray = (A, B) => {\\n    const arr = [];\\n    const result = [];\\n    let cnt = 0;\\n\\n    for (let i = 0; i < A.length; i++) {\\n        if (arr[A[i]]) {\\n            cnt++;\\n        } else {\\n           arr[A[i]] = 1; \\n        }\\n\\n        if (arr[B[i]]) {\\n            cnt++;\\n        } else {\\n           arr[B[i]] = 1; \\n        }\\n\\n        result[i] = cnt;\\n    }\\n\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4005931,
                "title": "my-solution-is-very-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& a, vector<int>& b) {\\n    unordered_map<int,int>mp;\\n    int ans =0;\\n    vector<int>v;\\n    int c =0;\\n\\n    for(int i =0; i<a.size(); i++){\\n        mp[a[i]]++;\\n         for(int j =0; j<=i; j++){\\n\\n           if(mp.find(b[j])!=mp.end()){\\n               c++;\\n           }\\n            \\n       }\\n       v.push_back(c);\\n       c=0;\\n    }\\n    \\n   return v;\\n    }\\n};\\n\\n/*\\n1,2,3,4\\n1,2,3,4\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n*/\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& a, vector<int>& b) {\\n    unordered_map<int,int>mp;\\n    int ans =0;\\n    vector<int>v;\\n    int c =0;\\n\\n    for(int i =0; i<a.size(); i++){\\n        mp[a[i]]++;\\n         for(int j =0; j<=i; j++){\\n\\n           if(mp.find(b[j])!=mp.end()){\\n               c++;\\n           }\\n            \\n       }\\n       v.push_back(c);\\n       c=0;\\n    }\\n    \\n   return v;\\n    }\\n};\\n\\n/*\\n1,2,3,4\\n1,2,3,4\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4004417,
                "title": "95-faster-and-i-think-smarter-one-too",
                "content": "# Intuition\\niterate from end to start. as every list in the end will have n number of matches i.e., len of list.\\n\\n# Approach\\nat the end there will be n no. of matches for sure. use a set and have the unique values in it. which will help in determining the number of matches.\\nEX:\\nA = [1,2,3,4] len of A = 4\\nB = [1,3,2,4]\\n\\nas said above last value of result will be 4. iterate from back. \\n\\n=> insert ***len(A)-len(uniqueset)*** to the start of the list to each iteration.\\nExplanation:\\n\\n:i=3 uniqueset = () result=[4] \\n    :i=2 uniqueset = (4) result = ( [len(A)-len(uniqueset),4] => [4-1,4] ) = [3,4]\\n    :i=1 uniqueset = (2,3,4) => result = [1,3,4]\\n    :i=0 uniqueset = (1,2,3,4) => result = [0,1,3,4]\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        unique = set()\\n        _len = len(A)\\n        result = [_len]\\n        for i in range(_len-2,-1,-1):\\n            unique.add(A[i+1])\\n            unique.add(B[i+1])\\n            result.insert(0,_len-len(unique))\\n        return result\\n\\n```\\n\\nThak you :)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        unique = set()\\n        _len = len(A)\\n        result = [_len]\\n        for i in range(_len-2,-1,-1):\\n            unique.add(A[i+1])\\n            unique.add(B[i+1])\\n            result.insert(0,_len-len(unique))\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3997181,
                "title": "ruby-one-liner-250ms",
                "content": "# Intuition\\nCan be solved simply by counting the matches of one array slice with another array slice, although there may be a way of taking advantage of the consecutive integers in each permutation\\n\\n# Approach\\n`map` the `b.size` array using `count`, `include?` and front-inclusive slices `[..i]`\\n\\n# Code\\n```\\ndef find_the_prefix_common_array(a, b)\\n  (0...b.size).map{|i| a[..i].count{|a| b[..i].include?(a)}}\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef find_the_prefix_common_array(a, b)\\n  (0...b.size).map{|i| a[..i].count{|a| b[..i].include?(a)}}\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3992166,
                "title": "direct-approach-using-java",
                "content": "\\n\\n# Java Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int arr[] = new int[A.length];\\n        for(int i =0;i<A.length;i++){\\n            int count = 0;\\n            for(int j = 0;j<=i;j++){\\n                for(int k = 0;k<=i;k++)\\n                    if(A[j]==B[k])\\n                        count++;                    \\n            }\\n            arr[i] = count;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int arr[] = new int[A.length];\\n        for(int i =0;i<A.length;i++){\\n            int count = 0;\\n            for(int j = 0;j<=i;j++){\\n                for(int k = 0;k<=i;k++)\\n                    if(A[j]==B[k])\\n                        count++;                    \\n            }\\n            arr[i] = count;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991127,
                "title": "o-n-time-complexity-o-1-space-complexity-solution",
                "content": "# Intuition\\ncreate a map to keep track of integers seen till now. \\n# Approach\\ncreate a map to keep track of integers seen till now. Since the number is till 50  and array of bool is enough to keep track to keep time complexity to minimum.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        bool prefixSet[51]={false};\\n        int idx=0;\\n        int commonCnt=0;\\n        vector<int > result;\\n        \\n        while (idx< A.size())\\n        {\\n            if (prefixSet[A[idx]])\\n            {\\n                commonCnt++;   \\n            }\\n            else\\n            {\\n                prefixSet[A[idx]] = true;\\n            }\\n\\n            if (prefixSet[B[idx]])\\n            {\\n                commonCnt++;   \\n            }\\n            else\\n            {\\n                prefixSet[B[idx]] = true;\\n            }\\n\\n            result.push_back(commonCnt);\\n\\n            idx++;\\n        }\\n\\n        return result;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        bool prefixSet[51]={false};\\n        int idx=0;\\n        int commonCnt=0;\\n        vector<int > result;\\n        \\n        while (idx< A.size())\\n        {\\n            if (prefixSet[A[idx]])\\n            {\\n                commonCnt++;   \\n            }\\n            else\\n            {\\n                prefixSet[A[idx]] = true;\\n            }\\n\\n            if (prefixSet[B[idx]])\\n            {\\n                commonCnt++;   \\n            }\\n            else\\n            {\\n                prefixSet[B[idx]] = true;\\n            }\\n\\n            result.push_back(commonCnt);\\n\\n            idx++;\\n        }\\n\\n        return result;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988258,
                "title": "essay-c-solution-using-multiset-for-beginner",
                "content": "\\n\\nHere\\'s a simplified explanation of the code:\\n\\n**Intuition**:\\nThe code aims to find the number of common elements between two vectors while considering their positions.\\n\\n**Approach**:\\n1. Initialize two multisets, `m1` and `m2`, to store the elements from vectors `A` and `B`, respectively. Multisets are used because they allow duplicate elements and automatically sort them.\\n\\n2. Find the sizes of vectors `A` and `B` and store them in `n` and `m`, respectively.\\n\\n3. Determine the maximum length between `n` and `m` and store it in the variable `len`. This is used for iterating through both vectors.\\n\\n4. Create an empty vector `ans` to store the results.\\n\\n5. Iterate from `i` equals 0 to `len - 1`:\\n   - Insert the element at position `i` in vector `A` into `m1`.\\n   - Insert the element at position `i` in vector `B` into `m2`.\\n\\n6. Initialize a variable `count` to 0 to keep track of the number of common elements at each position.\\n\\n7. Iterate through the elements in `m1`:\\n   - For each element, check if it exists in `m2` by using `m2.find(ele)`. If it does, increment the `count` variable.\\n\\n8. After counting the common elements for the current position, push the `count` value into the `ans` vector.\\n\\n9. Continue this process for all positions in the vectors.\\n\\n10. Finally, return the `ans` vector containing the counts of common elements at each position.\\n\\n**Complexity**:\\n\\n- Time complexity: The code has a nested loop that iterates through both vectors, so the time complexity is O(max(n, m)), where n and m are the sizes of vectors A and B, respectively.\\n\\n- Space complexity: The code uses two multisets, `m1` and `m2`, to store the elements from vectors A and B. The space complexity is O(n + m), where n and m are the sizes of vectors A and B, respectively, because the multisets store the unique elements from each vector.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n\\n        multiset<int> m1;\\n        multiset<int> m2;\\n        int n= A.size();\\n        int m= B.size();\\n        int len= max(n,m);\\n        vector<int> ans;\\n        for(int i =0; i<len; i++){\\n            \\n          m1.insert(A[i]);\\n          m2.insert(B[i]);\\n         int count =0;\\n         for( auto ele : m1){\\n            \\n            if( m2.find(ele)!= m2.end()){\\n                count++;\\n            }\\n         }\\n         ans.push_back(count);\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n\\n        multiset<int> m1;\\n        multiset<int> m2;\\n        int n= A.size();\\n        int m= B.size();\\n        int len= max(n,m);\\n        vector<int> ans;\\n        for(int i =0; i<len; i++){\\n            \\n          m1.insert(A[i]);\\n          m2.insert(B[i]);\\n         int count =0;\\n         for( auto ele : m1){\\n            \\n            if( m2.find(ele)!= m2.end()){\\n                count++;\\n            }\\n         }\\n         ans.push_back(count);\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988058,
                "title": "two-sets",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n     unordered_set<int>h1;\\n     unordered_set<int>h2;\\n     int ans=0;\\n     vector<int>v(A.size(),0);\\n     for(int i=0;i<A.size();i++){\\n         if(A[i]==B[i]){\\n             h1.insert(A[i]);\\n             h2.insert(A[i]);\\n             v[i]=++ans;\\n             continue;\\n         }\\n         v[i]=ans;\\n         if(h1.find(B[i])!=h1.end()){\\n             v[i]=++ans;\\n         }\\n         h2.insert(B[i]);\\n         if(h2.find(A[i])!=h2.end()){\\n             v[i]=++ans;\\n         }\\n         h1.insert(A[i]);\\n     }\\n     return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n     unordered_set<int>h1;\\n     unordered_set<int>h2;\\n     int ans=0;\\n     vector<int>v(A.size(),0);\\n     for(int i=0;i<A.size();i++){\\n         if(A[i]==B[i]){\\n             h1.insert(A[i]);\\n             h2.insert(A[i]);\\n             v[i]=++ans;\\n             continue;\\n         }\\n         v[i]=ans;\\n         if(h1.find(B[i])!=h1.end()){\\n             v[i]=++ans;\\n         }\\n         h2.insert(B[i]);\\n         if(h2.find(A[i])!=h2.end()){\\n             v[i]=++ans;\\n         }\\n         h1.insert(A[i]);\\n     }\\n     return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982412,
                "title": "java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[] res = new int[A.length];\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i=0; i<res.length; i++) {\\n            map.put(A[i], map.getOrDefault(A[i], 0) +1 );\\n            map.put(B[i], map.getOrDefault(B[i], 0) +1 );\\n            res[i] = (int) map.values()\\n                                .stream()\\n                                .filter(v -> v==2)\\n                                .count();\\n        }\\n        return res;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[] res = new int[A.length];\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i=0; i<res.length; i++) {\\n            map.put(A[i], map.getOrDefault(A[i], 0) +1 );\\n            map.put(B[i], map.getOrDefault(B[i], 0) +1 );\\n            res[i] = (int) map.values()\\n                                .stream()\\n                                .filter(v -> v==2)\\n                                .count();\\n        }\\n        return res;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975706,
                "title": "java-one-pass",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        Set<Integer> one = new HashSet<>()  ,two = new HashSet<>();\\n        int res = 0;\\n        int[] resarr = new int[A.length];\\n        for(int i = 0 ; i<A.length ;i++){\\n            int a = A[i] , b = B[i];\\n            one.add(a);two.add(b);\\n            if(two.contains(a)) res++;\\n            if( a!= b && one.contains(b)) res++;\\n            resarr[i] = res;\\n        }\\n        return resarr;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        Set<Integer> one = new HashSet<>()  ,two = new HashSet<>();\\n        int res = 0;\\n        int[] resarr = new int[A.length];\\n        for(int i = 0 ; i<A.length ;i++){\\n            int a = A[i] , b = B[i];\\n            one.add(a);two.add(b);\\n            if(two.contains(a)) res++;\\n            if( a!= b && one.contains(b)) res++;\\n            resarr[i] = res;\\n        }\\n        return resarr;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974183,
                "title": "elixir-simple-solution-using-mapset",
                "content": "```\\ndefmodule Solution do\\n  @spec find_the_prefix_common_array(a :: [integer], b :: [integer]) :: [integer]\\n  def find_the_prefix_common_array(a, b) do\\n    Enum.zip(a, b)\\n    |> Enum.reduce({[], 0, %MapSet{}, %MapSet{}}, fn {a, b}, {ans, ct, sa, sb} ->\\n      ct =\\n        cond do\\n          a == b -> ct + 1\\n          MapSet.member?(sa, b) && MapSet.member?(sb, a) -> ct + 2\\n          MapSet.member?(sa, b) || MapSet.member?(sb, a) -> ct + 1\\n          true -> ct\\n        end\\n\\n      {[ct | ans], ct, MapSet.put(sa, a), MapSet.put(sb, b)}\\n    end)\\n    |> elem(0)\\n    |> Enum.reverse()\\n  end\\nend\\n\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec find_the_prefix_common_array(a :: [integer], b :: [integer]) :: [integer]\\n  def find_the_prefix_common_array(a, b) do\\n    Enum.zip(a, b)\\n    |> Enum.reduce({[], 0, %MapSet{}, %MapSet{}}, fn {a, b}, {ans, ct, sa, sb} ->\\n      ct =\\n        cond do\\n          a == b -> ct + 1\\n          MapSet.member?(sa, b) && MapSet.member?(sb, a) -> ct + 2\\n          MapSet.member?(sa, b) || MapSet.member?(sb, a) -> ct + 1\\n          true -> ct\\n        end\\n\\n      {[ct | ans], ct, MapSet.put(sa, a), MapSet.put(sb, b)}\\n    end)\\n    |> elem(0)\\n    |> Enum.reverse()\\n  end\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3973931,
                "title": "java-beginner-friendly-approach-using-arrays-and-count",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCount the occurances and carry forwarding the current count and saving space by modifying exisiting input Array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n       int[] result = new int[51];\\n       int counter =0;\\n       for(int i=0;i<A.length;i++)\\n       {\\n           result[A[i]]++;\\n           if(result[A[i]]==2)\\n           counter++;\\n           result[B[i]]++;\\n           if(result[B[i]]==2)\\n           counter++;\\n           A[i]=counter;\\n       } \\n       return A;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n       int[] result = new int[51];\\n       int counter =0;\\n       for(int i=0;i<A.length;i++)\\n       {\\n           result[A[i]]++;\\n           if(result[A[i]]==2)\\n           counter++;\\n           result[B[i]]++;\\n           if(result[B[i]]==2)\\n           counter++;\\n           A[i]=counter;\\n       } \\n       return A;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971811,
                "title": "easy-soln-for-beginners-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int>ans;\\n        unordered_map<int,int>map;\\n        for(int i=0;i<B.size();i++){\\n            map[B[i]]++;\\n            int count=0;\\n            for(int j=0;j<=i;j++){\\n                if(map.find(A[j])!=map.end()){\\n                    count++;\\n                }\\n            }\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int>ans;\\n        unordered_map<int,int>map;\\n        for(int i=0;i<B.size();i++){\\n            map[B[i]]++;\\n            int count=0;\\n            for(int j=0;j<=i;j++){\\n                if(map.find(A[j])!=map.end()){\\n                    count++;\\n                }\\n            }\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969337,
                "title": "beats-99",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n\\n        int count[] = new int[A.length];\\n        int result[] = new int[A.length];\\n        int temp = 0;\\n        for(int i = 0; i<A.length; i++){\\n            count[A[i]-1]++;\\n            count[B[i]-1]++;\\n\\n            if(count[A[i]-1]==2) temp++;\\n            if(count[B[i]-1]==2 && A[i]!=B[i]) temp++;\\n            result[i] = temp;\\n            }\\n\\n            return result;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n\\n        int count[] = new int[A.length];\\n        int result[] = new int[A.length];\\n        int temp = 0;\\n        for(int i = 0; i<A.length; i++){\\n            count[A[i]-1]++;\\n            count[B[i]-1]++;\\n\\n            if(count[A[i]-1]==2) temp++;\\n            if(count[B[i]-1]==2 && A[i]!=B[i]) temp++;\\n            result[i] = temp;\\n            }\\n\\n            return result;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958656,
                "title": "java-observation-hashset-solution-se",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        Set<Integer> set = new HashSet<>();\\n        int res[] = new int[A.length];\\n        int ind = 0;\\n        for(int i = 0;i<A.length;i++){\\n            set.add(A[i]);\\n            set.add(B[i]);\\n            res[ind++] = 2*(i+1) - set.size();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        Set<Integer> set = new HashSet<>();\\n        int res[] = new int[A.length];\\n        int ind = 0;\\n        for(int i = 0;i<A.length;i++){\\n            set.add(A[i]);\\n            set.add(B[i]);\\n            res[ind++] = 2*(i+1) - set.size();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958071,
                "title": "c-unordered-map-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n=A.size();\\n        vector<int> ans(n,0);\\n        unordered_map<int,int> mp;\\n        \\n        for(int i=0;i<n;i++){\\n            mp[A[i]]++;\\n            mp[B[i]]++;\\n            int cnt=0;\\n            for(auto it: mp){\\n                if(it.second>=2){\\n                    cnt++;\\n                }\\n            }\\n            ans[i]=cnt;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n=A.size();\\n        vector<int> ans(n,0);\\n        unordered_map<int,int> mp;\\n        \\n        for(int i=0;i<n;i++){\\n            mp[A[i]]++;\\n            mp[B[i]]++;\\n            int cnt=0;\\n            for(auto it: mp){\\n                if(it.second>=2){\\n                    cnt++;\\n                }\\n            }\\n            ans[i]=cnt;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3955548,
                "title": "easy-solution-in-c",
                "content": "# Intuition\\n\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int>c;\\n        unordered_map<int,int>m;\\n        for(int i=0;i<A.size();i++){\\n            int ans=0;\\n            m[A[i]]++;\\n            m[B[i]]++;\\n            for(auto const &p:m){\\n                 if(p.second==2)\\n                    ans++;\\n            }\\n            c.push_back(ans);\\n        }\\n        return c;\\n\\n\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int>c;\\n        unordered_map<int,int>m;\\n        for(int i=0;i<A.size();i++){\\n            int ans=0;\\n            m[A[i]]++;\\n            m[B[i]]++;\\n            for(auto const &p:m){\\n                 if(p.second==2)\\n                    ans++;\\n            }\\n            c.push_back(ans);\\n        }\\n        return c;\\n\\n\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946368,
                "title": "java-solution-using-2-hashmaps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        HashMap<Integer,Integer> map1=new HashMap<>();\\n        HashMap<Integer,Integer> map2=new HashMap<>();\\n        for(int i=0;i<A.length;i++)\\n        {\\n            map1.put(i,A[i]);\\n            map2.put(B[i],i);\\n        }\\n\\n        int result[]=new int[A.length];\\n        for(int j=0;j<result.length;j++)\\n        {\\n            int cnt=0;\\n            for(int x=j;x>=0;x--)\\n            {\\n                if(map2.containsKey(map1.get(x)))\\n                {\\n                    if(map2.get(map1.get(x))<=j)\\n                    {\\n                        cnt++;\\n                    }\\n                }\\n            }\\n            result[j]=cnt;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        HashMap<Integer,Integer> map1=new HashMap<>();\\n        HashMap<Integer,Integer> map2=new HashMap<>();\\n        for(int i=0;i<A.length;i++)\\n        {\\n            map1.put(i,A[i]);\\n            map2.put(B[i],i);\\n        }\\n\\n        int result[]=new int[A.length];\\n        for(int j=0;j<result.length;j++)\\n        {\\n            int cnt=0;\\n            for(int x=j;x>=0;x--)\\n            {\\n                if(map2.containsKey(map1.get(x)))\\n                {\\n                    if(map2.get(map1.get(x))<=j)\\n                    {\\n                        cnt++;\\n                    }\\n                }\\n            }\\n            result[j]=cnt;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942129,
                "title": "easy-c-solution-o-n-approach-beats-94",
                "content": "# Intuition\\nUse a hashmap to store the frequency of each element.\\n\\n# Approach\\n- If A[i] and B[i] have frequency as 2 and both of them are equal then add only 1 to count.\\n- If both of them are not equal then separately check whether their frequency is 2 or not.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int> ans;\\n        unordered_map<int, int> freq;\\n        int n = A.size();\\n        int cnt = 0;\\n\\n        for(int i = 0; i < n; i++) {\\n            freq[A[i]]++;\\n            freq[B[i]]++;\\n            if(A[i] == B[i] && freq[A[i]] == 2)\\n                cnt++;\\n            else {\\n                if(freq[A[i]] == 2)\\n                    cnt++;\\n                if(freq[B[i]] == 2)\\n                    cnt++;\\n            }\\n\\n            ans.push_back(cnt);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int> ans;\\n        unordered_map<int, int> freq;\\n        int n = A.size();\\n        int cnt = 0;\\n\\n        for(int i = 0; i < n; i++) {\\n            freq[A[i]]++;\\n            freq[B[i]]++;\\n            if(A[i] == B[i] && freq[A[i]] == 2)\\n                cnt++;\\n            else {\\n                if(freq[A[i]] == 2)\\n                    cnt++;\\n                if(freq[B[i]] == 2)\\n                    cnt++;\\n            }\\n\\n            ans.push_back(cnt);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941030,
                "title": "o-n-time-o-n-space-c-solution",
                "content": "# Intuition\\nFew observations:\\n1. All 3 vectors (A, B, Resulting) must be of the same size.\\n2. On each iteration we need to determine how much common elements A and B have.\\n3. Thus this common number may only grow or stay the same.\\n4. If it grows it only can grow by 1 or 2.\\n\\n# Approach\\nWe traverse both arrays at the same time comparing its values.\\nWe use hash to store the \"not yet matching\" elements encountered in it.\\nIf elements match we increase common counter by 1.\\nIf they dont - we check if the elements are already in the hash, increasing common counter by 1 with each match, or adding \"not yet matched\" element to the hash.\\nOn each iteration set the resulting value for this position in the array to current common counter.\\n\\n \\n# Complexity\\n- Time complexity:\\nO(N) since we traverse all sets exactly 1 time and hash usage is limited to add\\\\search methods which both are O(1).\\n\\n- Space complexity:\\nO(N) - in the worst case we will end up having a hash with all the values from A and from B in it.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    /*\\n    test cases:\\n    [1 3 2 4] [3 1 2 4] - [0 2 3 4] - +\\n    [2 3 1] [3 1 2] - [0 1 3] - +\\n    [1 2 3 4 5 6 7] [1 2 3 4 5 6 7] - [1 2 3 4 5 6 7] - +\\n    [1 2 3 4 5] [6 7 8 9 10] - [0 0 0 0 0] - +\\n    [0 1 2 3 4] [4 3 2 1 0] - [0 0 1 4 5] - +\\n    [2 4 5 3 1] [3 5 4 1 0] - [0 0 2 3 4] - +\\n    */\\n\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) \\n    {\\n        if(A.size() != B.size())\\n            return vector<int>();\\n        \\n        unordered_set<int> set_unc;\\n        vector<int> res(A.size(), 0);\\n\\n        int common = 0;\\n\\n        for(int i = 0; i < A.size(); i++)\\n        {\\n            int a = A[i], b = B[i];\\n            if(a == b)\\n                common++;\\n            else\\n            {\\n                if(set_unc.contains(a))\\n                    common++;\\n                else\\n                    set_unc.insert(a);\\n\\n                if(set_unc.contains(b))\\n                    common++;\\n                else\\n                    set_unc.insert(b);\\n            }\\n            res[i] = common;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    /*\\n    test cases:\\n    [1 3 2 4] [3 1 2 4] - [0 2 3 4] - +\\n    [2 3 1] [3 1 2] - [0 1 3] - +\\n    [1 2 3 4 5 6 7] [1 2 3 4 5 6 7] - [1 2 3 4 5 6 7] - +\\n    [1 2 3 4 5] [6 7 8 9 10] - [0 0 0 0 0] - +\\n    [0 1 2 3 4] [4 3 2 1 0] - [0 0 1 4 5] - +\\n    [2 4 5 3 1] [3 5 4 1 0] - [0 0 2 3 4] - +\\n    */\\n\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) \\n    {\\n        if(A.size() != B.size())\\n            return vector<int>();\\n        \\n        unordered_set<int> set_unc;\\n        vector<int> res(A.size(), 0);\\n\\n        int common = 0;\\n\\n        for(int i = 0; i < A.size(); i++)\\n        {\\n            int a = A[i], b = B[i];\\n            if(a == b)\\n                common++;\\n            else\\n            {\\n                if(set_unc.contains(a))\\n                    common++;\\n                else\\n                    set_unc.insert(a);\\n\\n                if(set_unc.contains(b))\\n                    common++;\\n                else\\n                    set_unc.insert(b);\\n            }\\n            res[i] = common;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3940890,
                "title": "jai-shree-ram-optimised-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n\\n        int n=A.size();\\n        vector<int>ans(n,0);\\n        unordered_set<int>s;\\n        int cnt=0;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            s.insert(A[i]);\\n            for(int j=0;j<=i;j++)\\n            {\\n                if(s.count(B[j])!=0)\\n                {\\n                    ans[i]++;\\n                }\\n            }\\n            //ans[i]=cnt;\\n        }\\n        return ans;\\n        \\n\\n\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n\\n        int n=A.size();\\n        vector<int>ans(n,0);\\n        unordered_set<int>s;\\n        int cnt=0;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            s.insert(A[i]);\\n            for(int j=0;j<=i;j++)\\n            {\\n                if(s.count(B[j])!=0)\\n                {\\n                    ans[i]++;\\n                }\\n            }\\n            //ans[i]=cnt;\\n        }\\n        return ans;\\n        \\n\\n\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3926209,
                "title": "c-easy-time-o-n-space-o-n-most-optimized",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n        unordered_map<int, int> m;\\n        vector<int> v;\\n        \\n        for(int i = 0; i < n; i++){\\n            m[A[i]]++;\\n            m[B[i]]++;\\n\\n            int c = 0;\\n\\n            for(auto it : m)if(it.second == 2)c++;\\n\\n            v.push_back(c);\\n        }\\n\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n        unordered_map<int, int> m;\\n        vector<int> v;\\n        \\n        for(int i = 0; i < n; i++){\\n            m[A[i]]++;\\n            m[B[i]]++;\\n\\n            int c = 0;\\n\\n            for(auto it : m)if(it.second == 2)c++;\\n\\n            v.push_back(c);\\n        }\\n\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920725,
                "title": "java-simple-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int count = 0;\\n        int[] freq = new int[51];\\n        int[] res = new int[A.length];\\n        for(int i = 0; i < A.length; i++) {\\n            for(int j = 0; j <= i; j++) {\\n                freq[A[j]]++;\\n                freq[B[j]]++;\\n            }\\n            count = 0;\\n            for(int j = 0; j < freq.length; j++) {\\n                if(freq[j] == 2)\\n                    count += 1;\\n                freq[j] = 0;\\n            }\\n            res[i] = count;\\n        }        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int count = 0;\\n        int[] freq = new int[51];\\n        int[] res = new int[A.length];\\n        for(int i = 0; i < A.length; i++) {\\n            for(int j = 0; j <= i; j++) {\\n                freq[A[j]]++;\\n                freq[B[j]]++;\\n            }\\n            count = 0;\\n            for(int j = 0; j < freq.length; j++) {\\n                if(freq[j] == 2)\\n                    count += 1;\\n                freq[j] = 0;\\n            }\\n            res[i] = count;\\n        }        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920463,
                "title": "easy-solution-using-vector-unordered-map-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_map<int, int> perm;\\n        vector<int> prefix;\\n        int common = 0;\\n        for(int i=0; i < A.size(); i++){\\n            if(++perm[A[i]-1] > 1) common++;\\n            if(++perm[B[i]-1] > 1) common++;\\n            prefix.push_back(common);\\n        }\\n        return prefix;\\n    }\\n};\\n```\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int> perm(50,0), prefix;\\n        int common = 0;\\n        for(int i=0; i < A.size(); i++){\\n            if(++perm[A[i]-1] > 1) common++;\\n            if(++perm[B[i]-1] > 1) common++;\\n            prefix.push_back(common);\\n        }\\n        return prefix;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_map<int, int> perm;\\n        vector<int> prefix;\\n        int common = 0;\\n        for(int i=0; i < A.size(); i++){\\n            if(++perm[A[i]-1] > 1) common++;\\n            if(++perm[B[i]-1] > 1) common++;\\n            prefix.push_back(common);\\n        }\\n        return prefix;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int> perm(50,0), prefix;\\n        int common = 0;\\n        for(int i=0; i < A.size(); i++){\\n            if(++perm[A[i]-1] > 1) common++;\\n            if(++perm[B[i]-1] > 1) common++;\\n            prefix.push_back(common);\\n        }\\n        return prefix;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3913127,
                "title": "simple-python-solution-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Inialize two hashmap\\n2. Traverse each element\\n3. If Both elements are same then increement as 1\\n4. other wise verify the elements in hasmaps\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        x = defaultdict(lambda:0)\\n        y = defaultdict(lambda:0)\\n        c=[]\\n        common=0\\n        for i in range(len(A)):\\n            if A[i]==B[i]:\\n                common+=1\\n            else:\\n                if x[B[i]]>0:\\n                    common+=1\\n                if y[A[i]]>0:\\n                    common+=1\\n                x[A[i]]+=1\\n                y[B[i]]+=1\\n            c.append(common)\\n        return c\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        x = defaultdict(lambda:0)\\n        y = defaultdict(lambda:0)\\n        c=[]\\n        common=0\\n        for i in range(len(A)):\\n            if A[i]==B[i]:\\n                common+=1\\n            else:\\n                if x[B[i]]>0:\\n                    common+=1\\n                if y[A[i]]>0:\\n                    common+=1\\n                x[A[i]]+=1\\n                y[B[i]]+=1\\n            c.append(common)\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911665,
                "title": "easy-readable-solution-12-lines-o-n-time-o-n-space",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        ans, c, s1, s2 = [], 0, set(), set()\\n        for i in range(len(A)):\\n            if A[i] not in s1 and A[i] in s2:\\n                c += 1\\n            if B[i] not in s2 and B[i] in s1:\\n                c += 1\\n            if A[i] == B[i] and A[i] not in s1 and B[i] not in s2:\\n                c += 1\\n            s1.add(A[i])\\n            s2.add(B[i])\\n            ans.append(c)\\n        return ans\\n```\\n\\nPlease let me know if any improvements can be made.\\n\\nThanks",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        ans, c, s1, s2 = [], 0, set(), set()\\n        for i in range(len(A)):\\n            if A[i] not in s1 and A[i] in s2:\\n                c += 1\\n            if B[i] not in s2 and B[i] in s1:\\n                c += 1\\n            if A[i] == B[i] and A[i] not in s1 and B[i] not in s2:\\n                c += 1\\n            s1.add(A[i])\\n            s2.add(B[i])\\n            ans.append(c)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911071,
                "title": "c-time-o-n-space-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Have a map to store if the number appeared in both array\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] FindThePrefixCommonArray(int[] A, int[] B) {\\n        int[] map = new int[A.Length + 1];\\n        int[] ret = new int[A.Length];\\n        int prev = 0;\\n\\n        for(int i = 0; i < A.Length; i++)\\n        {\\n            map[A[i]]++;\\n            map[B[i]]++;\\n            \\n            ret[i] = prev;\\n\\n            if (map[A[i]] == 2)\\n                ret[i]++;\\n\\n            if (A[i] != B[i] && map[B[i]] == 2)\\n                ret[i]++;\\n\\n            prev = ret[i];\\n        }\\n\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] FindThePrefixCommonArray(int[] A, int[] B) {\\n        int[] map = new int[A.Length + 1];\\n        int[] ret = new int[A.Length];\\n        int prev = 0;\\n\\n        for(int i = 0; i < A.Length; i++)\\n        {\\n            map[A[i]]++;\\n            map[B[i]]++;\\n            \\n            ret[i] = prev;\\n\\n            if (map[A[i]] == 2)\\n                ret[i]++;\\n\\n            if (A[i] != B[i] && map[B[i]] == 2)\\n                ret[i]++;\\n\\n            prev = ret[i];\\n        }\\n\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3910580,
                "title": "beats-100-faster-c-easy-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& a, vector<int>& b) {\\n\\n        vector<int>ans;\\n        set<int>s;\\n        for(int i=0;i<a.size();i++){\\n            s.insert(a[i]);\\n            s.insert(b[i]);\\n            int t=(i+1)*2,n=s.size();\\n            (n==t) ? ans.push_back(0) : ans.push_back(t-n);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& a, vector<int>& b) {\\n\\n        vector<int>ans;\\n        set<int>s;\\n        for(int i=0;i<a.size();i++){\\n            s.insert(a[i]);\\n            s.insert(b[i]);\\n            int t=(i+1)*2,n=s.size();\\n            (n==t) ? ans.push_back(0) : ans.push_back(t-n);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908607,
                "title": "c-solution-using-set",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        set<int> s1;\\n        vector<int> v;\\n        for(int i=0; i<A.size(); i++){\\n            s1.insert(A[i]);\\n            int cnt=0;\\n            for(int j=0; j<=i; j++){\\n                if(s1.find(B[j])!=s1.end()){\\n                    cnt++;\\n                }\\n            }\\n             v.push_back(cnt);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        set<int> s1;\\n        vector<int> v;\\n        for(int i=0; i<A.size(); i++){\\n            s1.insert(A[i]);\\n            int cnt=0;\\n            for(int j=0; j<=i; j++){\\n                if(s1.find(B[j])!=s1.end()){\\n                    cnt++;\\n                }\\n            }\\n             v.push_back(cnt);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3900971,
                "title": "c-easy-solution-with-unordered-maps",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_map<int, int> map1;\\n        unordered_map<int, int> map2;\\n\\n        vector<int> res;\\n        int count = 0;\\n        for (int i = 0; i < (int) A.size(); i++) {\\n            map1[A[i]]++;\\n            map2[B[i]]++;\\n            if (map2[A[i]] > 0) {\\n                count++;\\n                map2[A[i]]--;\\n                map1[A[i]]--;\\n            }\\n            if (map1[B[i]] > 0) {\\n                count++;\\n                map1[B[i]]--;\\n                map2[B[i]]--;\\n            }\\n\\n            res.push_back(count);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_map<int, int> map1;\\n        unordered_map<int, int> map2;\\n\\n        vector<int> res;\\n        int count = 0;\\n        for (int i = 0; i < (int) A.size(); i++) {\\n            map1[A[i]]++;\\n            map2[B[i]]++;\\n            if (map2[A[i]] > 0) {\\n                count++;\\n                map2[A[i]]--;\\n                map1[A[i]]--;\\n            }\\n            if (map1[B[i]] > 0) {\\n                count++;\\n                map1[B[i]]--;\\n                map2[B[i]]--;\\n            }\\n\\n            res.push_back(count);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3898891,
                "title": "python-simple-python-solution-prefix-sum",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 134 ms, faster than 85.57% of Python3 online submissions for Find the Prefix Common Array of Two Arrays.\\n# Memory Usage: 16.4 MB, less than 44.65% of Python3 online submissions for Find the Prefix Common Array of Two Arrays.\\n\\n\\tclass Solution:\\n\\t\\tdef findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n\\n\\t\\t\\tresult = [0 for _ in range(len(A))]\\n\\n\\t\\t\\tif A[0] == B[0]:\\n\\t\\t\\t\\tresult[0] = 1\\n\\n\\t\\t\\tfor index in range(1 , len(A)):\\n\\n\\t\\t\\t\\tcheck = False\\n\\n\\t\\t\\t\\tif A[index] == B[index]:\\n\\t\\t\\t\\t\\tresult[index] = result[index - 1] + 1\\n\\t\\t\\t\\telse:\\n\\n\\t\\t\\t\\t\\tif A[index] in B[:index + 1]:\\n\\t\\t\\t\\t\\t\\tresult[index] = result[index - 1] + 1\\n\\t\\t\\t\\t\\t\\tcheck = True\\n\\n\\t\\t\\t\\t\\tif B[index] in A[:index + 1]:\\n\\n\\t\\t\\t\\t\\t\\tif check == False:\\n\\t\\t\\t\\t\\t\\t\\tresult[index] = result[index - 1] + 1\\n\\t\\t\\t\\t\\t\\t\\tcheck = True\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tresult[index] = result[index] + 1\\n\\n\\t\\t\\t\\t\\tif check == False:\\n\\t\\t\\t\\t\\t\\tresult[index] = result[index - 1]\\n\\n\\t\\t\\treturn result\\n\\t\\t\\t\\n\\tTime Complexity : O(n)\\n\\tSpace Complexity : O(n)\\n\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 134 ms, faster than 85.57% of Python3 online submissions for Find the Prefix Common Array of Two Arrays.\\n# Memory Usage: 16.4 MB, less than 44.65% of Python3 online submissions for Find the Prefix Common Array of Two Arrays.\\n\\n\\tclass Solution:\\n\\t\\tdef findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n\\n\\t\\t\\tresult = [0 for _ in range(len(A))]\\n\\n\\t\\t\\tif A[0] == B[0]:\\n\\t\\t\\t\\tresult[0] = 1\\n\\n\\t\\t\\tfor index in range(1 , len(A)):\\n\\n\\t\\t\\t\\tcheck = False\\n\\n\\t\\t\\t\\tif A[index] == B[index]:\\n\\t\\t\\t\\t\\tresult[index] = result[index - 1] + 1\\n\\t\\t\\t\\telse:\\n\\n\\t\\t\\t\\t\\tif A[index] in B[:index + 1]:\\n\\t\\t\\t\\t\\t\\tresult[index] = result[index - 1] + 1\\n\\t\\t\\t\\t\\t\\tcheck = True\\n\\n\\t\\t\\t\\t\\tif B[index] in A[:index + 1]:\\n\\n\\t\\t\\t\\t\\t\\tif check == False:\\n\\t\\t\\t\\t\\t\\t\\tresult[index] = result[index - 1] + 1\\n\\t\\t\\t\\t\\t\\t\\tcheck = True\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tresult[index] = result[index] + 1\\n\\n\\t\\t\\t\\t\\tif check == False:\\n\\t\\t\\t\\t\\t\\tresult[index] = result[index - 1]\\n\\n\\t\\t\\treturn result\\n\\t\\t\\t\\n\\tTime Complexity : O(n)\\n\\tSpace Complexity : O(n)\\n\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 3896199,
                "title": "beats-100-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& a, vector<int>& b) \\n    {\\n        int n=a.size();\\n        vector<int>ans;\\n        vector<int>ma(n+2,0);\\n        vector<int>mb(n+2,0);\\n        ma[a[0]]++;mb[b[0]]++;\\n        if(a[0]==b[0]) ans.push_back(1);\\n        else ans.push_back(0);\\n        for(int i=1;i<a.size();i++)\\n        {\\n            ma[a[i]]++;\\n            mb[b[i]]++;\\n            if(a[i]==b[i]) ans.push_back(ans.back()+1);\\n            else ans.push_back(ans.back()+ma[b[i]]+mb[a[i]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& a, vector<int>& b) \\n    {\\n        int n=a.size();\\n        vector<int>ans;\\n        vector<int>ma(n+2,0);\\n        vector<int>mb(n+2,0);\\n        ma[a[0]]++;mb[b[0]]++;\\n        if(a[0]==b[0]) ans.push_back(1);\\n        else ans.push_back(0);\\n        for(int i=1;i<a.size();i++)\\n        {\\n            ma[a[i]]++;\\n            mb[b[i]]++;\\n            if(a[i]==b[i]) ans.push_back(ans.back()+1);\\n            else ans.push_back(ans.back()+ma[b[i]]+mb[a[i]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892907,
                "title": "o-n-solution-using-single-for-loop",
                "content": "# Intuition\\n1. We know that the possible numbers are between 1,n.\\n2. We know that each number can only occur once in each array.\\n\\n# Approach\\nWe setup a hashtable to keep track if a number has occured before in either array. \\n\\nStep 1:\\nIterate through both arrays simoltaneously. If the number at the current index is the same in both arrays increment the counter.\\n\\nStep 2:\\nIf the numbers at the current index are not the same, we check our hashtable to see if the number occured before.\\n\\nStep 3:\\nIf the number occured previously, we increment the counter.\\nIf it did not occur previously, we update the hashtable.\\n\\nStep 4:\\nAppend the current state of the counter to our results array at the end of each itteration. \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_map <int,bool> map;\\n        vector<int> C;\\n        int common = 0;\\n        \\n        for(int i = 0; i<A.size();i++){\\n            if (A[i]==B[i])\\n            {\\n                common++;\\n            }\\n            else {\\n                if(map[A[i]]==1){\\n                    common++;\\n                }else{\\n                    map[A[i]]=1;\\n                }\\n                if (map[B[i]]==1){\\n                    common++;\\n                }else{\\n                    map[B[i]]=1;\\n                }\\n            }\\n            C.push_back(common);\\n        }\\n        return C;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        unordered_map <int,bool> map;\\n        vector<int> C;\\n        int common = 0;\\n        \\n        for(int i = 0; i<A.size();i++){\\n            if (A[i]==B[i])\\n            {\\n                common++;\\n            }\\n            else {\\n                if(map[A[i]]==1){\\n                    common++;\\n                }else{\\n                    map[A[i]]=1;\\n                }\\n                if (map[B[i]]==1){\\n                    common++;\\n                }else{\\n                    map[B[i]]=1;\\n                }\\n            }\\n            C.push_back(common);\\n        }\\n        return C;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890396,
                "title": "easiest-python-solution-using-dictionary",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        ans=[]\\n        i=0\\n        l=len(A)\\n        dicts={}\\n        last=0\\n        while i<l:\\n            if A[i] in dicts:\\n                last+=1\\n            else:dicts[A[i]]=1\\n            if B[i] in dicts:\\n                last+=1\\n            else:dicts[B[i]]=1\\n            ans.append(last)\\n            i+=1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        ans=[]\\n        i=0\\n        l=len(A)\\n        dicts={}\\n        last=0\\n        while i<l:\\n            if A[i] in dicts:\\n                last+=1\\n            else:dicts[A[i]]=1\\n            if B[i] in dicts:\\n                last+=1\\n            else:dicts[B[i]]=1\\n            ans.append(last)\\n            i+=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884494,
                "title": "easy-to-understand-solution-time-o-n",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        Set<Integer> set = new HashSet<>();\\n        int ans[] = new int[A.length];\\n\\n        int count=0;\\n        for(int i=0;i<A.length;i++){\\n                if(A[i]==B[i]){\\n                    count++;\\n                }else{\\n                count = getCount(A[i],count,set);\\n                count = getCount(B[i],count,set);\\n                }\\n            ans[i]=count;        \\n            }\\n      return   ans;\\n    }\\n\\n    int getCount(int num,int count,Set<Integer> set){\\n            if(set.contains(num)){\\n                count++;\\n            }else{\\n                set.add(num);\\n            }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        Set<Integer> set = new HashSet<>();\\n        int ans[] = new int[A.length];\\n\\n        int count=0;\\n        for(int i=0;i<A.length;i++){\\n                if(A[i]==B[i]){\\n                    count++;\\n                }else{\\n                count = getCount(A[i],count,set);\\n                count = getCount(B[i],count,set);\\n                }\\n            ans[i]=count;        \\n            }\\n      return   ans;\\n    }\\n\\n    int getCount(int num,int count,Set<Integer> set){\\n            if(set.contains(num)){\\n                count++;\\n            }else{\\n                set.add(num);\\n            }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3878964,
                "title": "python-one-pass-set-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        seen = set()\\n        res = [0] * len(A)\\n        for i in range(len(A)):\\n            presented = 0\\n            if A[i] in seen:\\n                presented += 1\\n            seen.add(A[i])\\n            if B[i] in seen:\\n                presented += 1\\n            seen.add(B[i])\\n            res[i] = presented if i == 0 else presented + res[i - 1]\\n        return res \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        seen = set()\\n        res = [0] * len(A)\\n        for i in range(len(A)):\\n            presented = 0\\n            if A[i] in seen:\\n                presented += 1\\n            seen.add(A[i])\\n            if B[i] in seen:\\n                presented += 1\\n            seen.add(B[i])\\n            res[i] = presented if i == 0 else presented + res[i - 1]\\n        return res \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873944,
                "title": "systumm",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B)\\n    {\\n        vector<int> ans(B.size(),0);\\n        unordered_map<int,bool> map;\\n        for(int i=0;i<A.size();i++)\\n        {\\n            if(find(B.begin(),B.begin()+i+1,A[i])!=B.begin()+i+1)\\n                ans[i]++;\\n            ans[i]+=map[B[i]];\\n            map[A[i]]=true;\\n            if(i>0)\\n            ans[i]+=ans[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B)\\n    {\\n        vector<int> ans(B.size(),0);\\n        unordered_map<int,bool> map;\\n        for(int i=0;i<A.size();i++)\\n        {\\n            if(find(B.begin(),B.begin()+i+1,A[i])!=B.begin()+i+1)\\n                ans[i]++;\\n            ans[i]+=map[B[i]];\\n            map[A[i]]=true;\\n            if(i>0)\\n            ans[i]+=ans[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873414,
                "title": "beats-98-24-of-users-with-c-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        \\n        int n = A.size();\\n        unordered_map<int,int>mp;\\n        vector<int>ans(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            int count = 0;\\n            //if(A[i]==B[i]) count++;\\n            if(mp[A[i]]>0) count++;\\n            else mp[A[i]]++;\\n            if(mp[B[i]]>0) count++;\\n            else mp[B[i]]++;\\n            if(i==0) ans[0]=count;\\n            else ans[i]=ans[i-1]+count;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        \\n        int n = A.size();\\n        unordered_map<int,int>mp;\\n        vector<int>ans(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            int count = 0;\\n            //if(A[i]==B[i]) count++;\\n            if(mp[A[i]]>0) count++;\\n            else mp[A[i]]++;\\n            if(mp[B[i]]>0) count++;\\n            else mp[B[i]]++;\\n            if(i==0) ans[0]=count;\\n            else ans[i]=ans[i-1]+count;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3859960,
                "title": "beginner-friendly-easy-hashtable-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        //int count = 0;\\n        vector<int> ans;\\n        map<int,int> mp;\\n        for(int i =0;i<A.size();i++){\\n            mp[A[i]]++;\\n            mp[B[i]]++;\\n            int count = 0;\\n            for(auto it: mp){\\n                if(it.second == 2){\\n                    count++;\\n                }\\n            }\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        //int count = 0;\\n        vector<int> ans;\\n        map<int,int> mp;\\n        for(int i =0;i<A.size();i++){\\n            mp[A[i]]++;\\n            mp[B[i]]++;\\n            int count = 0;\\n            for(auto it: mp){\\n                if(it.second == 2){\\n                    count++;\\n                }\\n            }\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3859005,
                "title": "c-easy-solution-using-both-map-and-set",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        // Unordered - Set\\n        \\n        vector<int> ans;\\n        unordered_set<int> st;\\n\\n        for(int i=0 ;i<A.size() ;i++){\\n            st.insert(A[i]);\\n            st.insert(B[i]);\\n\\n            ans.push_back(2*(i+1) - st.size());\\n        }\\n        return ans;\\n        \\n        // Unordered - Map\\n\\n        // unordered_map<int, int> mpa, mpb;\\n        // int common = 0;\\n        // vector<int> ans;\\n\\n        // for(int i=0 ;i<A.size() ;i++){\\n        //     mpa[A[i]]=1;\\n        //     if(mpb[A[i]])\\n        //     common++;\\n        //     else\\n        //     mpb[A[i]] = 1;\\n        //     if(mpa[B[i]])\\n        //     common++;\\n        //     else\\n        //     mpb[B[i]] = 1;\\n\\n        //     ans.push_back(common);\\n        // }\\n        // return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        // Unordered - Set\\n        \\n        vector<int> ans;\\n        unordered_set<int> st;\\n\\n        for(int i=0 ;i<A.size() ;i++){\\n            st.insert(A[i]);\\n            st.insert(B[i]);\\n\\n            ans.push_back(2*(i+1) - st.size());\\n        }\\n        return ans;\\n        \\n        // Unordered - Map\\n\\n        // unordered_map<int, int> mpa, mpb;\\n        // int common = 0;\\n        // vector<int> ans;\\n\\n        // for(int i=0 ;i<A.size() ;i++){\\n        //     mpa[A[i]]=1;\\n        //     if(mpb[A[i]])\\n        //     common++;\\n        //     else\\n        //     mpb[A[i]] = 1;\\n        //     if(mpa[B[i]])\\n        //     common++;\\n        //     else\\n        //     mpb[B[i]] = 1;\\n\\n        //     ans.push_back(common);\\n        // }\\n        // return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3854667,
                "title": "c-hash-table-time-o-n-space-o-n",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        \\n        vector<int> ans(A.size());\\n        unordered_map<int, int> um;\\n        for(int i = 0; i < A.size(); ++i){\\n            //Add frequency of the current values\\n            um[A[i]]++;\\n            um[B[i]]++;\\n\\n            //Copy the previous answer, this is important since we dont need to find the numbers that we have already found, instead we will just increment if we found one again\\n            if(i > 0) ans[i] = ans[i-1];\\n\\n            //If the same value is in the same index, only add once\\n            if(A[i] == B[i]){\\n                ans[i]++;\\n                continue;\\n            }\\n\\n            //Else, if the count is 2 (meaning the other number has been found), add one to the answer\\n            if(um[A[i]] == 2) ans[i]++;\\n            if(um[B[i]] == 2) ans[i]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        \\n        vector<int> ans(A.size());\\n        unordered_map<int, int> um;\\n        for(int i = 0; i < A.size(); ++i){\\n            //Add frequency of the current values\\n            um[A[i]]++;\\n            um[B[i]]++;\\n\\n            //Copy the previous answer, this is important since we dont need to find the numbers that we have already found, instead we will just increment if we found one again\\n            if(i > 0) ans[i] = ans[i-1];\\n\\n            //If the same value is in the same index, only add once\\n            if(A[i] == B[i]){\\n                ans[i]++;\\n                continue;\\n            }\\n\\n            //Else, if the count is 2 (meaning the other number has been found), add one to the answer\\n            if(um[A[i]] == 2) ans[i]++;\\n            if(um[B[i]] == 2) ans[i]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853201,
                "title": "easy-solution-using-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n \\n        c=[]\\n        \\n        for i in range(0,len(A)):\\n            if len(set(A[:i+1]) & set(B[:i+1]))>0:\\n                c.append(len(set(A[:i+1]) & set(B[:i+1])))\\n            else:\\n                c.append(0)\\n        return c\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n \\n        c=[]\\n        \\n        for i in range(0,len(A)):\\n            if len(set(A[:i+1]) & set(B[:i+1]))>0:\\n                c.append(len(set(A[:i+1]) & set(B[:i+1])))\\n            else:\\n                c.append(0)\\n        return c\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3850395,
                "title": "c-beats-100-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) \\n    {\\n        int size = A.size();\\n        vector<int> aux(size, -1);\\n\\n        for(int i = 0; i < size; i++)\\n        {\\n            if(aux[A[i] - 1] < i)\\n                aux[A[i] - 1] = i;\\n\\n            if(aux[B[i] - 1] < i)\\n                aux[B[i] - 1] = i;\\n        }\\n\\n        vector<int> C(size, 0);\\n\\n        for(int i = 0; i < size; i++)\\n        {\\n            ++C[aux[i]];\\n        }\\n\\n        for(int i = 1; i < size; i++)\\n        {\\n            C[i] += C[i - 1];\\n        }\\n\\n        return C;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) \\n    {\\n        int size = A.size();\\n        vector<int> aux(size, -1);\\n\\n        for(int i = 0; i < size; i++)\\n        {\\n            if(aux[A[i] - 1] < i)\\n                aux[A[i] - 1] = i;\\n\\n            if(aux[B[i] - 1] < i)\\n                aux[B[i] - 1] = i;\\n        }\\n\\n        vector<int> C(size, 0);\\n\\n        for(int i = 0; i < size; i++)\\n        {\\n            ++C[aux[i]];\\n        }\\n\\n        for(int i = 1; i < size; i++)\\n        {\\n            C[i] += C[i - 1];\\n        }\\n\\n        return C;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3848110,
                "title": "worst-complexities-but-simple-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>&a , vector<int>&b){\\n        vector<int>ans;\\n        for(int i=0; i<a.size(); i++){\\n            int c=0;\\n            unordered_set<int>st1,st2;\\n            for(int j=0; j<=i; j++){\\n                st1.insert(a[j]);\\n                st2.insert(b[j]);\\n            }\\n            for(auto i:st2){\\n                if(st1.find(i)!=st1.end()){\\n                    c++;\\n                }\\n            }\\n            ans.push_back(c);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>&a , vector<int>&b){\\n        vector<int>ans;\\n        for(int i=0; i<a.size(); i++){\\n            int c=0;\\n            unordered_set<int>st1,st2;\\n            for(int j=0; j<=i; j++){\\n                st1.insert(a[j]);\\n                st2.insert(b[j]);\\n            }\\n            for(auto i:st2){\\n                if(st1.find(i)!=st1.end()){\\n                    c++;\\n                }\\n            }\\n            ans.push_back(c);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845955,
                "title": "c-solution-hashset-o-n-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$ O(n) $$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] FindThePrefixCommonArray(int[] A, int[] B) {\\n        int[] res = new int[A.Length];\\n        HashSet<int> hashSet = new();\\n\\n        for(int i=0; i<A.Length; i++){\\n            hashSet.Add(A[i]);\\n            int count = 0;\\n\\n            for(int j=0; j<=i; j++){\\n                if(hashSet.Contains(B[j])){\\n                    count++;\\n                }\\n            }\\n\\n            res[i] = count;\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] FindThePrefixCommonArray(int[] A, int[] B) {\\n        int[] res = new int[A.Length];\\n        HashSet<int> hashSet = new();\\n\\n        for(int i=0; i<A.Length; i++){\\n            hashSet.Add(A[i]);\\n            int count = 0;\\n\\n            for(int j=0; j<=i; j++){\\n                if(hashSet.Contains(B[j])){\\n                    count++;\\n                }\\n            }\\n\\n            res[i] = count;\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845401,
                "title": "simple-implementation-using-dictionary",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] FindThePrefixCommonArray(int[] A, int[] B) {\\n        int n = A.Length, prev = 0;\\n        int[] result = new int[n];\\n        Dictionary<int, int> lookup = new Dictionary<int,int>();\\n\\n        for(int i = 0; i < n; i++){\\n            int aNum = A[i];\\n            int bNum = B[i];\\n\\n            if(!lookup.ContainsKey(aNum))\\n                lookup.Add(aNum, 1);\\n            else\\n                lookup[aNum] += 1;\\n\\n            \\n            if(!lookup.ContainsKey(bNum))\\n                lookup.Add(bNum, 1);\\n            else\\n                lookup[bNum] += 1;\\n            \\n            if(lookup[aNum] == 2)\\n                result[i] += 1;\\n            \\n            if(lookup[bNum] == 2 && aNum != bNum)\\n                result[i] += 1;\\n\\n            result[i] += prev;\\n            prev = result[i];\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] FindThePrefixCommonArray(int[] A, int[] B) {\\n        int n = A.Length, prev = 0;\\n        int[] result = new int[n];\\n        Dictionary<int, int> lookup = new Dictionary<int,int>();\\n\\n        for(int i = 0; i < n; i++){\\n            int aNum = A[i];\\n            int bNum = B[i];\\n\\n            if(!lookup.ContainsKey(aNum))\\n                lookup.Add(aNum, 1);\\n            else\\n                lookup[aNum] += 1;\\n\\n            \\n            if(!lookup.ContainsKey(bNum))\\n                lookup.Add(bNum, 1);\\n            else\\n                lookup[bNum] += 1;\\n            \\n            if(lookup[aNum] == 2)\\n                result[i] += 1;\\n            \\n            if(lookup[bNum] == 2 && aNum != bNum)\\n                result[i] += 1;\\n\\n            result[i] += prev;\\n            prev = result[i];\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843482,
                "title": "simple-c-solution-using-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        set<int> st;\\n        int n = A.size();\\n        vector<int> ans(n,0);\\n        ans[n-1] = n;\\n        int i;\\n        for(int i=0;i<n-1;i++){\\n            st.insert(A[i]);\\n            st.insert(B[i]);\\n            ans[i] = (i+1)*2 - st.size();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        set<int> st;\\n        int n = A.size();\\n        vector<int> ans(n,0);\\n        ans[n-1] = n;\\n        int i;\\n        for(int i=0;i<n-1;i++){\\n            st.insert(A[i]);\\n            st.insert(B[i]);\\n            ans[i] = (i+1)*2 - st.size();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841827,
                "title": "100-beating-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[] arr=new int[A.length];\\n        int []set1=new int[A.length+1];\\n        int []set2=new int[A.length+1];\\n        int cnt=0;\\n        for(int i=0;i<A.length;i++){\\n           set1[A[i]]=1;\\n           set2[B[i]]=1;\\n            if(A[i]==B[i])cnt++;\\n            else{\\n            if(set1[B[i]]==1)cnt++;\\n            if(set2[A[i]]==1)cnt++;}\\n            arr[i]=cnt;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int[] arr=new int[A.length];\\n        int []set1=new int[A.length+1];\\n        int []set2=new int[A.length+1];\\n        int cnt=0;\\n        for(int i=0;i<A.length;i++){\\n           set1[A[i]]=1;\\n           set2[B[i]]=1;\\n            if(A[i]==B[i])cnt++;\\n            else{\\n            if(set1[B[i]]==1)cnt++;\\n            if(set2[A[i]]==1)cnt++;}\\n            arr[i]=cnt;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841773,
                "title": "c-beats-95-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n=A.size();\\n        vector<int>ans(n);\\n        map<int,int>mp;\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            mp[A[i]]++;\\n            if(mp[A[i]]==2)\\n            c++;\\n            mp[B[i]]++;\\n            if(mp[B[i]]==2)\\n            c++;\\n            ans[i]=c;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n=A.size();\\n        vector<int>ans(n);\\n        map<int,int>mp;\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            mp[A[i]]++;\\n            if(mp[A[i]]==2)\\n            c++;\\n            mp[B[i]]++;\\n            if(mp[B[i]]==2)\\n            c++;\\n            ans[i]=c;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840438,
                "title": "python-linear-in-time-and-space-simply-use-two-sets",
                "content": "# Intuition\\nUse Python\\'s set\\n\\n# Approach\\nIterate from the beginning. At each step add element from A to one set and element B to another set. The result at this point is size of the intersection of the sets.\\n\\n# Complexity\\n- Time complexity: O(N) : each set operation is constant time\\n\\n- Space complexity: O(N) : sets store every number once\\n\\n# Code\\n```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        sa, sb = set(), set()\\n        res = []\\n        for i in range(len(A)):\\n            sa.add(A[i])\\n            sb.add(B[i])\\n            res.append(len(sa & sb))\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:\\n        sa, sb = set(), set()\\n        res = []\\n        for i in range(len(A)):\\n            sa.add(A[i])\\n            sb.add(B[i])\\n            res.append(len(sa & sb))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832737,
                "title": "easy-to-understand-c-solution-using-set-using-map-beats-97-50",
                "content": "\\n\\n# Code\\n```\\n\\n//Using set :- Beats 97.50% in Runtime of c++ user\\n//             Beats 46.50% in Memory of c++ user\\n\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int> ans;\\n        unordered_set<int> mp;\\n        for(int i=0;i<A.size();i++){\\n            int cnt=0;\\n            mp.insert(A[i]);\\n            for(int j=0;j<=i;j++){\\n                    if(mp.find(B[j]) != mp.end()) cnt++;\\n            }\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# Code\\n\\n```\\n//Using Map :- Beats 95.90% Runtime of c++ user\\n//             Beats 68.17% in Memory of c++ user\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n        vector<int> ans(n,0);\\n        unordered_map<int,int> mp;\\n        int cnt=0;\\n        \\n        if(A[0] == B[0]){\\n            cnt++; \\n            ans[0] = cnt;\\n        }\\n        \\n        mp[A[0]]++;\\n        mp[B[0]]++;\\n        \\n        for(int i=1;i<n;i++){\\n           if(A[i] == B[i]) cnt++;\\n            else{\\n                if(mp.find(A[i]) != mp.end()) cnt++;\\n                if(mp.find(B[i]) != mp.end()) cnt++;\\n            }\\n            ans[i] = cnt;\\n            mp[A[i]]++;\\n            mp[B[i]]++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Map",
                    "Ordered Set"
                ],
                "code": "```\\n\\n//Using set :- Beats 97.50% in Runtime of c++ user\\n//             Beats 46.50% in Memory of c++ user\\n\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        vector<int> ans;\\n        unordered_set<int> mp;\\n        for(int i=0;i<A.size();i++){\\n            int cnt=0;\\n            mp.insert(A[i]);\\n            for(int j=0;j<=i;j++){\\n                    if(mp.find(B[j]) != mp.end()) cnt++;\\n            }\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n//Using Map :- Beats 95.90% Runtime of c++ user\\n//             Beats 68.17% in Memory of c++ user\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {\\n        int n = A.size();\\n        vector<int> ans(n,0);\\n        unordered_map<int,int> mp;\\n        int cnt=0;\\n        \\n        if(A[0] == B[0]){\\n            cnt++; \\n            ans[0] = cnt;\\n        }\\n        \\n        mp[A[0]]++;\\n        mp[B[0]]++;\\n        \\n        for(int i=1;i<n;i++){\\n           if(A[i] == B[i]) cnt++;\\n            else{\\n                if(mp.find(A[i]) != mp.end()) cnt++;\\n                if(mp.find(B[i]) != mp.end()) cnt++;\\n            }\\n            ans[i] = cnt;\\n            mp[A[i]]++;\\n            mp[B[i]]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3829437,
                "title": "easy-kotlin-solution-with-just-one-set",
                "content": "# Code\\n```\\nclass Solution {\\n    fun findThePrefixCommonArray(A: IntArray, B: IntArray): IntArray {\\n        val result = IntArray(A.size)\\n        val set = mutableSetOf<Int>()\\n        var i = 0\\n        var commonPrefixCounter = 0\\n\\n        while (i < A.size) {\\n            if (!set.add(A[i]))\\n                commonPrefixCounter++\\n                \\n            if (!set.add(B[i]))\\n                commonPrefixCounter++\\n\\n            result[i] = commonPrefixCounter\\n            i++\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    fun findThePrefixCommonArray(A: IntArray, B: IntArray): IntArray {\\n        val result = IntArray(A.size)\\n        val set = mutableSetOf<Int>()\\n        var i = 0\\n        var commonPrefixCounter = 0\\n\\n        while (i < A.size) {\\n            if (!set.add(A[i]))\\n                commonPrefixCounter++\\n                \\n            if (!set.add(B[i]))\\n                commonPrefixCounter++\\n\\n            result[i] = commonPrefixCounter\\n            i++\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827242,
                "title": "simple-code-one-pass-using-set-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        HashSet<Integer> set = new HashSet<>();\\n        int n = A.length; \\n        int[] ans = new int[n];\\n        int count = 0;\\n\\n        for(int i = 0; i<n; i++){\\n            if(set.contains(A[i])){\\n                count++;\\n            }\\n            set.add(A[i]);\\n\\n            if(set.contains(B[i])){\\n                count++;\\n            }\\n            set.add(B[i]);\\n\\n            ans[i] = count;\\n\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        HashSet<Integer> set = new HashSet<>();\\n        int n = A.length; \\n        int[] ans = new int[n];\\n        int count = 0;\\n\\n        for(int i = 0; i<n; i++){\\n            if(set.contains(A[i])){\\n                count++;\\n            }\\n            set.add(A[i]);\\n\\n            if(set.contains(B[i])){\\n                count++;\\n            }\\n            set.add(B[i]);\\n\\n            ans[i] = count;\\n\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826923,
                "title": "2657-find-the-prefix-common-array-of-two-arrays",
                "content": "# Intuition\\n<!-- using Hashset we can determine the common elements of both the arrays a and b at specified index -->\\n\\n# Approach\\n<!-- using Hashset and two for loops -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- )(n^2)-->\\n\\n- Space complexity:\\n<!-- O(n) -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] a, int[] b) {\\n        int[] c=new int[a.length];\\n\\t  HashSet<Integer> set=new HashSet<>();\\n\\t\\n\\t   for(int i=0;i<a.length;i++){\\n\\t       set.add(a[i]);\\n\\t       int co=0;\\n\\t     for(int j=0;j<=i;j++){\\n\\t         if(set.contains(b[j])) co++;\\n\\t     }\\n\\t     c[i]=co;\\n\\t       \\n\\t   }\\n\\t\\t return c;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findThePrefixCommonArray(int[] a, int[] b) {\\n        int[] c=new int[a.length];\\n\\t  HashSet<Integer> set=new HashSet<>();\\n\\t\\n\\t   for(int i=0;i<a.length;i++){\\n\\t       set.add(a[i]);\\n\\t       int co=0;\\n\\t     for(int j=0;j<=i;j++){\\n\\t         if(set.contains(b[j])) co++;\\n\\t     }\\n\\t     c[i]=co;\\n\\t       \\n\\t   }\\n\\t\\t return c;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1877149,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "It must be tagged as easy"
                    },
                    {
                        "username": "pritul2020",
                        "content": "explain it bro ,i not understand it"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Just go for the brute force solution, n<=50 only :)"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Why is this testcase invalid?\\nA = [3,1,1,2,4]\\nB = [1,3,1,2,4]\\n\\nIs there any metion regarding this invalidness in question? Plz point me that !!\\nLeetcode gives this error for this testcase\\n`\\nexpected variables A[0]:1 and A[2]:1 to have different values\\n`\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement mentions that both A and B are permutations of n integers, where n is the length of A and B. \\n\\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once. This is a fundamental property of a permutation.\\n\\nIn the case of A = [3,1,1,2,4], it\\'s not a valid permutation of the integers from 1 to 5 because it contains the number 1 twice and the number 5 is missing. So, this test case is indeed invalid because it violates the stated conditions of the problem. \\n\\nThus, the error message you see from Leetcode is correct and indicates that all elements in the permutation should be unique. In the problematic test case, the elements A[0] and A[2] are both 1, which is not allowed in a permutation."
                    },
                    {
                        "username": "botan",
                        "content": "\"You are given two 0-indexed integer permutations A and B of length n.\"\\n\"A sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.\"\\n\\nYou\\'d have to fish for this information though, so your point is totally valid.\\nPerhaps a point should be added to the constraints about values of A and B being distinct."
                    },
                    {
                        "username": "botan",
                        "content": "I have the JS solution that beats 100% submissions by using 2 bitmasks.\nhttps://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/solutions/3477139/top-100-javascript-o-n-time-o-1-space-bitmask/"
                    },
                    {
                        "username": "Abhinav_Shaw",
                        "content": "what if the size of the arrays are not same?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement, it\\'s explicitly mentioned that the size of both arrays A and B is equal to n. \\n\\nIf the sizes of the two arrays are not the same, then it will violate the problem constraints, thus rendering the situation invalid for this problem. \\n\\nThe problem is designed to compare corresponding elements in the two arrays. If the arrays are of different sizes, this comparison would not be possible for all elements. Thus, the problem assumes and requires that both arrays are of the same size."
                    },
                    {
                        "username": "botan",
                        "content": "Then the longer array will just get a tail with the same value at each position.\\n\\nE.g. A = [1, 2, 3], B = [1, 2, 3, 4, 5, 6, 7], result = [1, 2, 3, 3, 3, 3, 3]"
                    },
                    {
                        "username": "aquaman55",
                        "content": "1 <= A.length == B.length == n <= 50 \\n\\nRead the constraint"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "did it using a stack \\n"
                    },
                    {
                        "username": "sanchitdeshmukh23",
                        "content": "using hashmap was much more easier.\\n"
                    }
                ]
            },
            {
                "id": 1880977,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "It must be tagged as easy"
                    },
                    {
                        "username": "pritul2020",
                        "content": "explain it bro ,i not understand it"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Just go for the brute force solution, n<=50 only :)"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Why is this testcase invalid?\\nA = [3,1,1,2,4]\\nB = [1,3,1,2,4]\\n\\nIs there any metion regarding this invalidness in question? Plz point me that !!\\nLeetcode gives this error for this testcase\\n`\\nexpected variables A[0]:1 and A[2]:1 to have different values\\n`\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement mentions that both A and B are permutations of n integers, where n is the length of A and B. \\n\\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once. This is a fundamental property of a permutation.\\n\\nIn the case of A = [3,1,1,2,4], it\\'s not a valid permutation of the integers from 1 to 5 because it contains the number 1 twice and the number 5 is missing. So, this test case is indeed invalid because it violates the stated conditions of the problem. \\n\\nThus, the error message you see from Leetcode is correct and indicates that all elements in the permutation should be unique. In the problematic test case, the elements A[0] and A[2] are both 1, which is not allowed in a permutation."
                    },
                    {
                        "username": "botan",
                        "content": "\"You are given two 0-indexed integer permutations A and B of length n.\"\\n\"A sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.\"\\n\\nYou\\'d have to fish for this information though, so your point is totally valid.\\nPerhaps a point should be added to the constraints about values of A and B being distinct."
                    },
                    {
                        "username": "botan",
                        "content": "I have the JS solution that beats 100% submissions by using 2 bitmasks.\nhttps://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/solutions/3477139/top-100-javascript-o-n-time-o-1-space-bitmask/"
                    },
                    {
                        "username": "Abhinav_Shaw",
                        "content": "what if the size of the arrays are not same?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement, it\\'s explicitly mentioned that the size of both arrays A and B is equal to n. \\n\\nIf the sizes of the two arrays are not the same, then it will violate the problem constraints, thus rendering the situation invalid for this problem. \\n\\nThe problem is designed to compare corresponding elements in the two arrays. If the arrays are of different sizes, this comparison would not be possible for all elements. Thus, the problem assumes and requires that both arrays are of the same size."
                    },
                    {
                        "username": "botan",
                        "content": "Then the longer array will just get a tail with the same value at each position.\\n\\nE.g. A = [1, 2, 3], B = [1, 2, 3, 4, 5, 6, 7], result = [1, 2, 3, 3, 3, 3, 3]"
                    },
                    {
                        "username": "aquaman55",
                        "content": "1 <= A.length == B.length == n <= 50 \\n\\nRead the constraint"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "did it using a stack \\n"
                    },
                    {
                        "username": "sanchitdeshmukh23",
                        "content": "using hashmap was much more easier.\\n"
                    }
                ]
            },
            {
                "id": 1880320,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "It must be tagged as easy"
                    },
                    {
                        "username": "pritul2020",
                        "content": "explain it bro ,i not understand it"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Just go for the brute force solution, n<=50 only :)"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Why is this testcase invalid?\\nA = [3,1,1,2,4]\\nB = [1,3,1,2,4]\\n\\nIs there any metion regarding this invalidness in question? Plz point me that !!\\nLeetcode gives this error for this testcase\\n`\\nexpected variables A[0]:1 and A[2]:1 to have different values\\n`\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement mentions that both A and B are permutations of n integers, where n is the length of A and B. \\n\\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once. This is a fundamental property of a permutation.\\n\\nIn the case of A = [3,1,1,2,4], it\\'s not a valid permutation of the integers from 1 to 5 because it contains the number 1 twice and the number 5 is missing. So, this test case is indeed invalid because it violates the stated conditions of the problem. \\n\\nThus, the error message you see from Leetcode is correct and indicates that all elements in the permutation should be unique. In the problematic test case, the elements A[0] and A[2] are both 1, which is not allowed in a permutation."
                    },
                    {
                        "username": "botan",
                        "content": "\"You are given two 0-indexed integer permutations A and B of length n.\"\\n\"A sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.\"\\n\\nYou\\'d have to fish for this information though, so your point is totally valid.\\nPerhaps a point should be added to the constraints about values of A and B being distinct."
                    },
                    {
                        "username": "botan",
                        "content": "I have the JS solution that beats 100% submissions by using 2 bitmasks.\nhttps://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/solutions/3477139/top-100-javascript-o-n-time-o-1-space-bitmask/"
                    },
                    {
                        "username": "Abhinav_Shaw",
                        "content": "what if the size of the arrays are not same?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement, it\\'s explicitly mentioned that the size of both arrays A and B is equal to n. \\n\\nIf the sizes of the two arrays are not the same, then it will violate the problem constraints, thus rendering the situation invalid for this problem. \\n\\nThe problem is designed to compare corresponding elements in the two arrays. If the arrays are of different sizes, this comparison would not be possible for all elements. Thus, the problem assumes and requires that both arrays are of the same size."
                    },
                    {
                        "username": "botan",
                        "content": "Then the longer array will just get a tail with the same value at each position.\\n\\nE.g. A = [1, 2, 3], B = [1, 2, 3, 4, 5, 6, 7], result = [1, 2, 3, 3, 3, 3, 3]"
                    },
                    {
                        "username": "aquaman55",
                        "content": "1 <= A.length == B.length == n <= 50 \\n\\nRead the constraint"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "did it using a stack \\n"
                    },
                    {
                        "username": "sanchitdeshmukh23",
                        "content": "using hashmap was much more easier.\\n"
                    }
                ]
            },
            {
                "id": 1880083,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "It must be tagged as easy"
                    },
                    {
                        "username": "pritul2020",
                        "content": "explain it bro ,i not understand it"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Just go for the brute force solution, n<=50 only :)"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Why is this testcase invalid?\\nA = [3,1,1,2,4]\\nB = [1,3,1,2,4]\\n\\nIs there any metion regarding this invalidness in question? Plz point me that !!\\nLeetcode gives this error for this testcase\\n`\\nexpected variables A[0]:1 and A[2]:1 to have different values\\n`\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement mentions that both A and B are permutations of n integers, where n is the length of A and B. \\n\\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once. This is a fundamental property of a permutation.\\n\\nIn the case of A = [3,1,1,2,4], it\\'s not a valid permutation of the integers from 1 to 5 because it contains the number 1 twice and the number 5 is missing. So, this test case is indeed invalid because it violates the stated conditions of the problem. \\n\\nThus, the error message you see from Leetcode is correct and indicates that all elements in the permutation should be unique. In the problematic test case, the elements A[0] and A[2] are both 1, which is not allowed in a permutation."
                    },
                    {
                        "username": "botan",
                        "content": "\"You are given two 0-indexed integer permutations A and B of length n.\"\\n\"A sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.\"\\n\\nYou\\'d have to fish for this information though, so your point is totally valid.\\nPerhaps a point should be added to the constraints about values of A and B being distinct."
                    },
                    {
                        "username": "botan",
                        "content": "I have the JS solution that beats 100% submissions by using 2 bitmasks.\nhttps://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/solutions/3477139/top-100-javascript-o-n-time-o-1-space-bitmask/"
                    },
                    {
                        "username": "Abhinav_Shaw",
                        "content": "what if the size of the arrays are not same?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement, it\\'s explicitly mentioned that the size of both arrays A and B is equal to n. \\n\\nIf the sizes of the two arrays are not the same, then it will violate the problem constraints, thus rendering the situation invalid for this problem. \\n\\nThe problem is designed to compare corresponding elements in the two arrays. If the arrays are of different sizes, this comparison would not be possible for all elements. Thus, the problem assumes and requires that both arrays are of the same size."
                    },
                    {
                        "username": "botan",
                        "content": "Then the longer array will just get a tail with the same value at each position.\\n\\nE.g. A = [1, 2, 3], B = [1, 2, 3, 4, 5, 6, 7], result = [1, 2, 3, 3, 3, 3, 3]"
                    },
                    {
                        "username": "aquaman55",
                        "content": "1 <= A.length == B.length == n <= 50 \\n\\nRead the constraint"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "did it using a stack \\n"
                    },
                    {
                        "username": "sanchitdeshmukh23",
                        "content": "using hashmap was much more easier.\\n"
                    }
                ]
            },
            {
                "id": 1877672,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "It must be tagged as easy"
                    },
                    {
                        "username": "pritul2020",
                        "content": "explain it bro ,i not understand it"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Just go for the brute force solution, n<=50 only :)"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Why is this testcase invalid?\\nA = [3,1,1,2,4]\\nB = [1,3,1,2,4]\\n\\nIs there any metion regarding this invalidness in question? Plz point me that !!\\nLeetcode gives this error for this testcase\\n`\\nexpected variables A[0]:1 and A[2]:1 to have different values\\n`\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement mentions that both A and B are permutations of n integers, where n is the length of A and B. \\n\\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once. This is a fundamental property of a permutation.\\n\\nIn the case of A = [3,1,1,2,4], it\\'s not a valid permutation of the integers from 1 to 5 because it contains the number 1 twice and the number 5 is missing. So, this test case is indeed invalid because it violates the stated conditions of the problem. \\n\\nThus, the error message you see from Leetcode is correct and indicates that all elements in the permutation should be unique. In the problematic test case, the elements A[0] and A[2] are both 1, which is not allowed in a permutation."
                    },
                    {
                        "username": "botan",
                        "content": "\"You are given two 0-indexed integer permutations A and B of length n.\"\\n\"A sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.\"\\n\\nYou\\'d have to fish for this information though, so your point is totally valid.\\nPerhaps a point should be added to the constraints about values of A and B being distinct."
                    },
                    {
                        "username": "botan",
                        "content": "I have the JS solution that beats 100% submissions by using 2 bitmasks.\nhttps://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/solutions/3477139/top-100-javascript-o-n-time-o-1-space-bitmask/"
                    },
                    {
                        "username": "Abhinav_Shaw",
                        "content": "what if the size of the arrays are not same?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement, it\\'s explicitly mentioned that the size of both arrays A and B is equal to n. \\n\\nIf the sizes of the two arrays are not the same, then it will violate the problem constraints, thus rendering the situation invalid for this problem. \\n\\nThe problem is designed to compare corresponding elements in the two arrays. If the arrays are of different sizes, this comparison would not be possible for all elements. Thus, the problem assumes and requires that both arrays are of the same size."
                    },
                    {
                        "username": "botan",
                        "content": "Then the longer array will just get a tail with the same value at each position.\\n\\nE.g. A = [1, 2, 3], B = [1, 2, 3, 4, 5, 6, 7], result = [1, 2, 3, 3, 3, 3, 3]"
                    },
                    {
                        "username": "aquaman55",
                        "content": "1 <= A.length == B.length == n <= 50 \\n\\nRead the constraint"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "did it using a stack \\n"
                    },
                    {
                        "username": "sanchitdeshmukh23",
                        "content": "using hashmap was much more easier.\\n"
                    }
                ]
            },
            {
                "id": 1876990,
                "content": [
                    {
                        "username": "karan_cpp_py",
                        "content": "It must be tagged as easy"
                    },
                    {
                        "username": "pritul2020",
                        "content": "explain it bro ,i not understand it"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Just go for the brute force solution, n<=50 only :)"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Why is this testcase invalid?\\nA = [3,1,1,2,4]\\nB = [1,3,1,2,4]\\n\\nIs there any metion regarding this invalidness in question? Plz point me that !!\\nLeetcode gives this error for this testcase\\n`\\nexpected variables A[0]:1 and A[2]:1 to have different values\\n`\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement mentions that both A and B are permutations of n integers, where n is the length of A and B. \\n\\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once. This is a fundamental property of a permutation.\\n\\nIn the case of A = [3,1,1,2,4], it\\'s not a valid permutation of the integers from 1 to 5 because it contains the number 1 twice and the number 5 is missing. So, this test case is indeed invalid because it violates the stated conditions of the problem. \\n\\nThus, the error message you see from Leetcode is correct and indicates that all elements in the permutation should be unique. In the problematic test case, the elements A[0] and A[2] are both 1, which is not allowed in a permutation."
                    },
                    {
                        "username": "botan",
                        "content": "\"You are given two 0-indexed integer permutations A and B of length n.\"\\n\"A sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.\"\\n\\nYou\\'d have to fish for this information though, so your point is totally valid.\\nPerhaps a point should be added to the constraints about values of A and B being distinct."
                    },
                    {
                        "username": "botan",
                        "content": "I have the JS solution that beats 100% submissions by using 2 bitmasks.\nhttps://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/solutions/3477139/top-100-javascript-o-n-time-o-1-space-bitmask/"
                    },
                    {
                        "username": "Abhinav_Shaw",
                        "content": "what if the size of the arrays are not same?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement, it\\'s explicitly mentioned that the size of both arrays A and B is equal to n. \\n\\nIf the sizes of the two arrays are not the same, then it will violate the problem constraints, thus rendering the situation invalid for this problem. \\n\\nThe problem is designed to compare corresponding elements in the two arrays. If the arrays are of different sizes, this comparison would not be possible for all elements. Thus, the problem assumes and requires that both arrays are of the same size."
                    },
                    {
                        "username": "botan",
                        "content": "Then the longer array will just get a tail with the same value at each position.\\n\\nE.g. A = [1, 2, 3], B = [1, 2, 3, 4, 5, 6, 7], result = [1, 2, 3, 3, 3, 3, 3]"
                    },
                    {
                        "username": "aquaman55",
                        "content": "1 <= A.length == B.length == n <= 50 \\n\\nRead the constraint"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "did it using a stack \\n"
                    },
                    {
                        "username": "sanchitdeshmukh23",
                        "content": "using hashmap was much more easier.\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Number of Adjacent Elements With the Same Color",
        "question_content": "<p>There is a <strong>0-indexed</strong> array <code>nums</code> of length <code>n</code>. Initially, all elements are <strong>uncolored </strong>(has a value of <code>0</code>).</p>\n\n<p>You are given a 2D integer array <code>queries</code> where <code>queries[i] = [index<sub>i</sub>, color<sub>i</sub>]</code>.</p>\n\n<p>For each query, you color the index <code>index<sub>i</sub></code> with the color <code>color<sub>i</sub></code> in the array <code>nums</code>.</p>\n\n<p>Return <em>an array </em><code>answer</code><em> of the same length as </em><code>queries</code><em> where </em><code>answer[i]</code><em> is the number of adjacent elements with the same color <strong>after</strong> the </em><code>i<sup>th</sup></code><em> query</em>.</p>\n\n<p>More formally, <code>answer[i]</code> is the number of indices <code>j</code>, such that <code>0 &lt;= j &lt; n - 1</code> and <code>nums[j] == nums[j + 1]</code> and <code>nums[j] != 0</code> after the <code>i<sup>th</sup></code> query.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 4, queries = [[0,2],[1,2],[3,1],[1,1],[2,1]]\n<strong>Output:</strong> [0,1,1,0,2]\n<strong>Explanation:</strong> Initially array nums = [0,0,0,0], where 0 denotes uncolored elements of the array.\n- After the 1<sup>st</sup> query nums = [2,0,0,0]. The count of adjacent elements with the same color is 0.\n- After the 2<sup>nd</sup> query nums = [2,2,0,0]. The count of adjacent elements with the same color is 1.\n- After the 3<sup>rd</sup>&nbsp;query nums = [2,2,0,1]. The count of adjacent elements with the same color is 1.\n- After the 4<sup>th</sup>&nbsp;query nums = [2,1,0,1]. The count of adjacent elements with the same color is 0.\n- After the 5<sup>th</sup>&nbsp;query nums = [2,1,1,1]. The count of adjacent elements with the same color is 2.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1, queries = [[0,100000]]\n<strong>Output:</strong> [0]\n<strong>Explanation:</strong> Initially array nums = [0], where 0 denotes uncolored elements of the array.\n- After the 1<sup>st</sup> query nums = [100000]. The count of adjacent elements with the same color is 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>queries[i].length&nbsp;== 2</code></li>\n\t<li><code>0 &lt;= index<sub>i</sub>&nbsp;&lt;= n - 1</code></li>\n\t<li><code>1 &lt;=&nbsp; color<sub>i</sub>&nbsp;&lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3494883,
                "title": "c-java-python3-simple-counting",
                "content": "\\n\\n# Intuition\\nCreate the nums array and track the count of adjacent numbers that are same\\n\\n# Approach\\n* Create the array `nums`\\n* For each query first check if the values at `index - 1` or `index + 1` are the same as `nums[index]`. If any of them are equal, **decrement** the counter\\n* Update the value of `nums[index]`\\n* Now check if values at `index - 1` or `index + 1` are the same as `nums[index]`. If any of them are equal, **increment** the counter\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n**Python3**:\\n```\\ndef colorTheArray(self, n: int, queries):\\n    nums, c = [0] * n, 0\\n    for index, color in queries:\\n        pre, nex = nums[index - 1] if index > 0 else 0, nums[index + 1] if index < n-1 else 0\\n        if nums[index] and nums[index] == pre: c -= 1\\n        if nums[index] and nums[index] == nex: c -= 1\\n        nums[index] = color\\n        if nums[index] == pre: c += 1\\n        if nums[index] == nex: c += 1\\n        yield c\\n```\\n\\n**C++**:\\n```\\nvector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n    vector<int> nums(n, 0), result;\\n    int c = 0;\\n\\n    for (auto query : queries) {\\n        int index = query[0], color = query[1];\\n        int pre = (index > 0) ? nums[index - 1] : 0;\\n        int nex = (index < n-1) ? nums[index + 1] : 0;\\n\\n        if (nums[index] && nums[index] == pre) c--;\\n        if (nums[index] && nums[index] == nex) c--;\\n        nums[index] = color;\\n        if (nums[index] == pre) c++;\\n        if (nums[index] == nex) c++;\\n\\n        result.push_back(c);\\n    }\\n    return result;\\n}\\n```\\n\\n**Java**:\\n```\\npublic int[] colorTheArray(int n, int[][] queries) {\\n    int[] nums = new int[n], result = new int[queries.length];\\n    int c = 0;\\n\\n    for (int i = 0; i < queries.length; i++) {\\n        int index = queries[i][0], color = queries[i][1];\\n        int pre = (index > 0) ? nums[index - 1] : 0;\\n        int nex = (index < n-1) ? nums[index + 1] : 0;\\n\\n        if (nums[index] != 0 && nums[index] == pre) c--;\\n        if (nums[index] != 0 && nums[index] == nex) c--;\\n        nums[index] = color;\\n        if (nums[index] == pre) c++;\\n        if (nums[index] == nex) c++;\\n\\n        result[i] = c;\\n    }\\n    return result;\\n}\\n```\\n\\n## Shorter Version\\n**Python3**:\\n```\\ndef colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n    nums, c = [0] * n, 0\\n    for index, color in queries:\\n        pre, nex = nums[index-1] if index > 0 else 0, nums[index+1] if index < n-1 else 0\\n        if nums[index]: c -= (nums[index] == pre) + (nums[index] == nex)\\n        nums[index] = color\\n        c += (nums[index] == pre) + (nums[index] == nex)\\n        yield c\\n```\\n\\n**C++**:\\n```\\nvector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n    vector<int> nums(n, 0), result;\\n    int c = 0;\\n\\n    for (auto query : queries) {\\n        int index = query[0], color = query[1];\\n        int pre = (index > 0) ? nums[index - 1] : 0;\\n        int nex = (index < n-1) ? nums[index + 1] : 0;\\n        if (nums[index]) c -= (nums[index] == pre) + (nums[index] == nex);\\n        nums[index] = color;\\n        c += (nums[index] == pre) + (nums[index] == nex);\\n        result.push_back(c);\\n    }\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```\\ndef colorTheArray(self, n: int, queries):\\n    nums, c = [0] * n, 0\\n    for index, color in queries:\\n        pre, nex = nums[index - 1] if index > 0 else 0, nums[index + 1] if index < n-1 else 0\\n        if nums[index] and nums[index] == pre: c -= 1\\n        if nums[index] and nums[index] == nex: c -= 1\\n        nums[index] = color\\n        if nums[index] == pre: c += 1\\n        if nums[index] == nex: c += 1\\n        yield c\\n```\n```\\nvector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n    vector<int> nums(n, 0), result;\\n    int c = 0;\\n\\n    for (auto query : queries) {\\n        int index = query[0], color = query[1];\\n        int pre = (index > 0) ? nums[index - 1] : 0;\\n        int nex = (index < n-1) ? nums[index + 1] : 0;\\n\\n        if (nums[index] && nums[index] == pre) c--;\\n        if (nums[index] && nums[index] == nex) c--;\\n        nums[index] = color;\\n        if (nums[index] == pre) c++;\\n        if (nums[index] == nex) c++;\\n\\n        result.push_back(c);\\n    }\\n    return result;\\n}\\n```\n```\\npublic int[] colorTheArray(int n, int[][] queries) {\\n    int[] nums = new int[n], result = new int[queries.length];\\n    int c = 0;\\n\\n    for (int i = 0; i < queries.length; i++) {\\n        int index = queries[i][0], color = queries[i][1];\\n        int pre = (index > 0) ? nums[index - 1] : 0;\\n        int nex = (index < n-1) ? nums[index + 1] : 0;\\n\\n        if (nums[index] != 0 && nums[index] == pre) c--;\\n        if (nums[index] != 0 && nums[index] == nex) c--;\\n        nums[index] = color;\\n        if (nums[index] == pre) c++;\\n        if (nums[index] == nex) c++;\\n\\n        result[i] = c;\\n    }\\n    return result;\\n}\\n```\n```\\ndef colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n    nums, c = [0] * n, 0\\n    for index, color in queries:\\n        pre, nex = nums[index-1] if index > 0 else 0, nums[index+1] if index < n-1 else 0\\n        if nums[index]: c -= (nums[index] == pre) + (nums[index] == nex)\\n        nums[index] = color\\n        c += (nums[index] == pre) + (nums[index] == nex)\\n        yield c\\n```\n```\\nvector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n    vector<int> nums(n, 0), result;\\n    int c = 0;\\n\\n    for (auto query : queries) {\\n        int index = query[0], color = query[1];\\n        int pre = (index > 0) ? nums[index - 1] : 0;\\n        int nex = (index < n-1) ? nums[index + 1] : 0;\\n        if (nums[index]) c -= (nums[index] == pre) + (nums[index] == nex);\\n        nums[index] = color;\\n        c += (nums[index] == pre) + (nums[index] == nex);\\n        result.push_back(c);\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3494948,
                "title": "explained-very-simple-and-easy-to-understand",
                "content": "<b> Up vote if you like the solution </b>\\n# Intution \\nWhen we add one number to nums then only impact of this to left & right adacent values. Like it can have same adjacent to the previous or to the next one only. So we have to check the status of adjacent equality before updating the index and after updating the index.\\n\\n# Approach\\n\\nSimply traverse the querries and keep subtracting the previously same adjacent count \\nand then add the newly formed same adjacent count.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> ans, nums(n, 0);\\n        int count = 0;\\n        for(auto q: queries){\\n            int i = q[0], val = q[1], tc = 0;\\n            if(nums[i] && i - 1 >= 0 && nums[i-1] == nums[i]) count--;  \\n            if(nums[i] && i + 1 < n && nums[i+1] == nums[i]) count--;\\n            nums[i] = val;\\n            if( i - 1 >= 0 && nums[i-1] == nums[i]) count++;\\n            if( i + 1 < n && nums[i+1] == nums[i]) count++;\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n<b>Here is an article of my last interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> ans, nums(n, 0);\\n        int count = 0;\\n        for(auto q: queries){\\n            int i = q[0], val = q[1], tc = 0;\\n            if(nums[i] && i - 1 >= 0 && nums[i-1] == nums[i]) count--;  \\n            if(nums[i] && i + 1 < n && nums[i+1] == nums[i]) count--;\\n            nums[i] = val;\\n            if( i - 1 >= 0 && nums[i-1] == nums[i]) count++;\\n            if( i + 1 < n && nums[i+1] == nums[i]) count++;\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494899,
                "title": "centinel",
                "content": "We use a number line (`c`), and track the number of adjacent elements (`adj`).\\n\\nTo make it simple, the number line is shifted/padded on the left and right, so that `i - 1` and `i + 1` positions are always valid.\\n\\n**C++**\\n```cpp\\nvector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n    int c[100003] = {}, adj = 0;\\n    vector<int> res;\\n    for (const auto &q : queries) {\\n        int i = q[0] + 1, color_i = q[1];\\n        if (c[i])\\n            adj -= (c[i - 1] == c[i]) + (c[i + 1] == c[i]);\\n        c[i] = color_i;\\n        adj += (c[i - 1] == c[i]) + (c[i + 1] == c[i]);\\n        res.push_back(adj);\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nvector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n    int c[100003] = {}, adj = 0;\\n    vector<int> res;\\n    for (const auto &q : queries) {\\n        int i = q[0] + 1, color_i = q[1];\\n        if (c[i])\\n            adj -= (c[i - 1] == c[i]) + (c[i + 1] == c[i]);\\n        c[i] = color_i;\\n        adj += (c[i - 1] == c[i]) + (c[i + 1] == c[i]);\\n        res.push_back(adj);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3495129,
                "title": "c-easy-to-understand-counting",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) \\n    {\\n        vector<int>ans(queries.size(), 0);\\n        vector<int>nums(n, 0);\\n        int count = 0;\\n        for (int i = 0; i < queries.size(); i++)\\n        {\\n            int index = queries[i][0];\\n            int newCol = queries[i][1];\\n            \\n            int prevCol = (index - 1 < 0)? 0 : nums[index - 1];\\n            int nextCol = (index + 1 >= n)? 0 : nums[index + 1];\\n            int oldCol = nums[index];\\n            \\n            nums[index] = newCol;\\n            //===========================================================\\n            //CHECK CONTRIBUTIONS BEFORE COLORING WITH NEW COLOR\\n            if (oldCol != 0 && oldCol == prevCol) count--;\\n            if (oldCol != 0 && oldCol == nextCol) count--;\\n            //===============================================================\\n            //CHECK CONTRIBUTIONS AFTER COLORING WITH NEW COLOR\\n            if (newCol == prevCol) count++;\\n            if (newCol == nextCol) count++;\\n            //====================================================================\\n            ans[i] = count;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) \\n    {\\n        vector<int>ans(queries.size(), 0);\\n        vector<int>nums(n, 0);\\n        int count = 0;\\n        for (int i = 0; i < queries.size(); i++)\\n        {\\n            int index = queries[i][0];\\n            int newCol = queries[i][1];\\n            \\n            int prevCol = (index - 1 < 0)? 0 : nums[index - 1];\\n            int nextCol = (index + 1 >= n)? 0 : nums[index + 1];\\n            int oldCol = nums[index];\\n            \\n            nums[index] = newCol;\\n            //===========================================================\\n            //CHECK CONTRIBUTIONS BEFORE COLORING WITH NEW COLOR\\n            if (oldCol != 0 && oldCol == prevCol) count--;\\n            if (oldCol != 0 && oldCol == nextCol) count--;\\n            //===============================================================\\n            //CHECK CONTRIBUTIONS AFTER COLORING WITH NEW COLOR\\n            if (newCol == prevCol) count++;\\n            if (newCol == nextCol) count++;\\n            //====================================================================\\n            ans[i] = count;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495439,
                "title": "110-understandable-simple-o-n-solution",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n**Just think when new element is added to nums then there will be two case** *(nums is our final array of length n that has intially all values is equal to 0)* :\\n\\n---\\n\\n\\ncase 1: **nums[i]==0** (where 0<=i<n) then check its both side  \\n\\n    if new element that we want to insert in nums[i] is equal to nums[i-1]    then do cnt++ (bcoz it will contribute in our answer).\\n    if new element that we want to insert  in nums[i] is equal to nums[i+1]   then do cnt++.\\n\\n---\\n\\n\\n\\ncase 2 : **nums[i]!=0** (where 0<=i<n) then there will be 4 conditions \\n```\\n\\nif element that is already present in nums[i] is equal to nums[i-1] then we have to do cnt-- (bcoz this element is no more contributing after inserting new element)\\nif element that is already present in nums[i] is equal to nums[i+1] then we have to do again cnt-- (bcoz this element is no more contributing after inserting new element)\\nif new element that we want to insert  in nums[i] is equal to nums[i-1]   then do cnt++.\\nif new element that we want to insert  in nums[i] is equal to nums[i+1]   then do cnt++.`\\n```\\n\\n##### NOTE : please see the code !  you will understand 110%\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n*please upvote if you like it!*\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& q) {\\n        \\n        vector<int> ans(q.size());\\n        vector<int> nums(n,0);\\n        \\n        int cnt=0;\\n        ans[0]=0;\\n        nums[q[0][0]]=q[0][1];\\n        for(int i=1;i<q.size();i++)\\n        {\\n            if(nums[q[i][0]]==0)\\n            {\\n                if(q[i][0]-1>=0 &&  nums[q[i][0]-1]==q[i][1]) cnt++;\\n                if(q[i][0]+1 <n &&  nums[q[i][0]+1]==q[i][1]) cnt++;\\n              \\n                nums[q[i][0]]=q[i][1];\\n                ans[i]=cnt;\\n                \\n            }\\n            else \\n            {\\n                if(q[i][0]-1>=0 &&  nums[q[i][0]]==nums[q[i][0]-1]) cnt--;\\n                 if(q[i][0]+1 <n && nums[q[i][0]]==nums[q[i][0]+1]) cnt--;  \\n                                         \\n                 if(q[i][0]-1>=0 &&  nums[q[i][0]-1]==q[i][1]) cnt++;\\n                 if(q[i][0]+1 <n &&  nums[q[i][0]+1]==q[i][1]) cnt++;\\n                                         \\n                nums[q[i][0]]=q[i][1];\\n                ans[i]=cnt;\\n            }\\n        }\\n        return ans;                                 \\n                                        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Brainteaser",
                    "Counting"
                ],
                "code": "```\\n\\nif element that is already present in nums[i] is equal to nums[i-1] then we have to do cnt-- (bcoz this element is no more contributing after inserting new element)\\nif element that is already present in nums[i] is equal to nums[i+1] then we have to do again cnt-- (bcoz this element is no more contributing after inserting new element)\\nif new element that we want to insert  in nums[i] is equal to nums[i-1]   then do cnt++.\\nif new element that we want to insert  in nums[i] is equal to nums[i+1]   then do cnt++.`\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& q) {\\n        \\n        vector<int> ans(q.size());\\n        vector<int> nums(n,0);\\n        \\n        int cnt=0;\\n        ans[0]=0;\\n        nums[q[0][0]]=q[0][1];\\n        for(int i=1;i<q.size();i++)\\n        {\\n            if(nums[q[i][0]]==0)\\n            {\\n                if(q[i][0]-1>=0 &&  nums[q[i][0]-1]==q[i][1]) cnt++;\\n                if(q[i][0]+1 <n &&  nums[q[i][0]+1]==q[i][1]) cnt++;\\n              \\n                nums[q[i][0]]=q[i][1];\\n                ans[i]=cnt;\\n                \\n            }\\n            else \\n            {\\n                if(q[i][0]-1>=0 &&  nums[q[i][0]]==nums[q[i][0]-1]) cnt--;\\n                 if(q[i][0]+1 <n && nums[q[i][0]]==nums[q[i][0]+1]) cnt--;  \\n                                         \\n                 if(q[i][0]-1>=0 &&  nums[q[i][0]-1]==q[i][1]) cnt++;\\n                 if(q[i][0]+1 <n &&  nums[q[i][0]+1]==q[i][1]) cnt++;\\n                                         \\n                nums[q[i][0]]=q[i][1];\\n                ans[i]=cnt;\\n            }\\n        }\\n        return ans;                                 \\n                                        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497262,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(m)$$, m-> length of queries array\\n\\n- Space complexity: $$O(n + m)$$ \\n\\n# Code\\n```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n      int a[]=new int[n];\\n      int len=queries.length;\\n      int res[]=new int[len];\\n      int count=0;\\n      for(int i=0;i<len;i++)\\n      {\\n          int ind=queries[i][0], color=queries[i][1];\\n          int prev = ind>0 ? a[ind-1] : 0;\\n          int next = ind>=n-1 ? 0 : a[ind+1];\\n          if(a[ind]!=0 && a[ind] == prev)\\n          {\\n              count--;\\n          }\\n          if(a[ind]!=0 && a[ind] == next)\\n          {\\n              count--;\\n          }\\n          a[ind]=color;\\n          if(a[ind] == prev)\\n          {\\n              count++;\\n          }\\n          if(a[ind] == next)\\n          {\\n              count++;\\n          }\\n          res[i]=count;\\n      }\\n      return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n      int a[]=new int[n];\\n      int len=queries.length;\\n      int res[]=new int[len];\\n      int count=0;\\n      for(int i=0;i<len;i++)\\n      {\\n          int ind=queries[i][0], color=queries[i][1];\\n          int prev = ind>0 ? a[ind-1] : 0;\\n          int next = ind>=n-1 ? 0 : a[ind+1];\\n          if(a[ind]!=0 && a[ind] == prev)\\n          {\\n              count--;\\n          }\\n          if(a[ind]!=0 && a[ind] == next)\\n          {\\n              count--;\\n          }\\n          a[ind]=color;\\n          if(a[ind] == prev)\\n          {\\n              count++;\\n          }\\n          if(a[ind] == next)\\n          {\\n              count++;\\n          }\\n          res[i]=count;\\n      }\\n      return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495014,
                "title": "maintain-the-colors-directly",
                "content": "# Intuition\\nSimply count.\\n\\n# Approach\\nWhen change the color of one cell, consider the neighbors, update the counts.\\n\\n# Complexity\\n- Time complexity:\\nO(1) per operation.\\n\\n- Space complexity:\\nO(n) in total.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> v(n), r;\\n        int num = 0;\\n        for (const auto& q : queries) {\\n            if (v[q[0]]) {\\n                if (q[0] >= 1 && v[q[0] - 1] == v[q[0]]) {\\n                    --num;\\n                }\\n                if (q[0] + 1 < n && v[q[0] + 1] == v[q[0]]) {\\n                    --num;\\n                }\\n            }\\n            v[q[0]] = q[1];\\n            if (q[0] >= 1 && v[q[0] - 1] == v[q[0]]) {\\n                ++num;\\n            }\\n            if (q[0] + 1 < n && v[q[0] + 1] == v[q[0]]) {\\n                ++num;\\n            }\\n            r.push_back(num);\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> v(n), r;\\n        int num = 0;\\n        for (const auto& q : queries) {\\n            if (v[q[0]]) {\\n                if (q[0] >= 1 && v[q[0] - 1] == v[q[0]]) {\\n                    --num;\\n                }\\n                if (q[0] + 1 < n && v[q[0] + 1] == v[q[0]]) {\\n                    --num;\\n                }\\n            }\\n            v[q[0]] = q[1];\\n            if (q[0] >= 1 && v[q[0] - 1] == v[q[0]]) {\\n                ++num;\\n            }\\n            if (q[0] + 1 < n && v[q[0] + 1] == v[q[0]]) {\\n                ++num;\\n            }\\n            r.push_back(num);\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496243,
                "title": "just-store-the-pairs-whose-color-matches-easy-to-understand-approach-clean-code",
                "content": "\\n# Complexity\\n- Time complexity: O(q log q), where q is the number of queries.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void fn1(vector<int> &v, set<pair<int,int>> &s, int x){\\n        pair<int, int> p = {x - 1, x};\\n        if (v[x] == v[x - 1]) s.insert(p);\\n        else if (s.count(p)) s.erase(p);\\n    }\\n    void fn2(vector<int> &v, set<pair<int,int>> &s, int x){\\n        pair<int, int> p = {x, x + 1};\\n        if (v[x] == v[x + 1]) s.insert(p);\\n        else if (s.count(p)) s.erase(p);\\n    }\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        if(n == 1){\\n            vector<int> ans;\\n            for(auto i: queries) ans.push_back(0);\\n            return ans;\\n        }\\n        vector<int> v(n, 0);\\n        vector<int> ans;\\n        set<pair<int,int>> s;\\n        for(auto i: queries){\\n            int x = i[0], y = i[1];\\n            v[x] = y;\\n            if (x == n - 1) fn1(v, s, x);\\n            else if (x == 0) fn2(v, s, x);\\n            else {\\n                fn1(v, s, x);\\n                fn2(v, s, x);\\n            }\\n            ans.push_back(s.size());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void fn1(vector<int> &v, set<pair<int,int>> &s, int x){\\n        pair<int, int> p = {x - 1, x};\\n        if (v[x] == v[x - 1]) s.insert(p);\\n        else if (s.count(p)) s.erase(p);\\n    }\\n    void fn2(vector<int> &v, set<pair<int,int>> &s, int x){\\n        pair<int, int> p = {x, x + 1};\\n        if (v[x] == v[x + 1]) s.insert(p);\\n        else if (s.count(p)) s.erase(p);\\n    }\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        if(n == 1){\\n            vector<int> ans;\\n            for(auto i: queries) ans.push_back(0);\\n            return ans;\\n        }\\n        vector<int> v(n, 0);\\n        vector<int> ans;\\n        set<pair<int,int>> s;\\n        for(auto i: queries){\\n            int x = i[0], y = i[1];\\n            v[x] = y;\\n            if (x == n - 1) fn1(v, s, x);\\n            else if (x == 0) fn2(v, s, x);\\n            else {\\n                fn1(v, s, x);\\n                fn2(v, s, x);\\n            }\\n            ans.push_back(s.size());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495191,
                "title": "too-lazy-to-explain",
                "content": "# Intuition\\nAs given in hints just focus on neighbours of the element whose color you are changing \\n\\n# Approach\\n<!-- before changing color of an index  , check if it contributes i.e. have adjacents with same color , then you need to decrease your current answer.  -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        \\n        int[] arr = new int[n]; \\n        \\n        int[] ans = new int[queries.length]; \\n        \\n        int adj = 0; \\n        \\n        for(int i = 0; i < queries.length; i++ ){\\n            \\n            int index = queries[i][0]; \\n            int color = queries[i][1]; \\n            \\n            if( color == arr[index] ){\\n                ans[i] = adj; \\n                continue; \\n            }\\n            \\n            int count = 0; \\n            \\n            if( index != 0 &&  arr[index] != 0 && arr[index-1] == arr[index] ) count++; \\n            if(index != n-1 && arr[index] != 0 && arr[index+1] == arr[index] ) count++; \\n            \\n            arr[index] = color; \\n            \\n            adj -= count;\\n            \\n             if( index != 0 && arr[index] != 0 && arr[index-1] == arr[index] ) adj++; \\n            if(index != n-1 && arr[index] != 0 && arr[index+1] == arr[index] ) adj++; \\n            \\n            ans[i] = adj; \\n        }\\n        \\n        return ans; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        \\n        int[] arr = new int[n]; \\n        \\n        int[] ans = new int[queries.length]; \\n        \\n        int adj = 0; \\n        \\n        for(int i = 0; i < queries.length; i++ ){\\n            \\n            int index = queries[i][0]; \\n            int color = queries[i][1]; \\n            \\n            if( color == arr[index] ){\\n                ans[i] = adj; \\n                continue; \\n            }\\n            \\n            int count = 0; \\n            \\n            if( index != 0 &&  arr[index] != 0 && arr[index-1] == arr[index] ) count++; \\n            if(index != n-1 && arr[index] != 0 && arr[index+1] == arr[index] ) count++; \\n            \\n            arr[index] = color; \\n            \\n            adj -= count;\\n            \\n             if( index != 0 && arr[index] != 0 && arr[index-1] == arr[index] ) adj++; \\n            if(index != n-1 && arr[index] != 0 && arr[index+1] == arr[index] ) adj++; \\n            \\n            ans[i] = adj; \\n        }\\n        \\n        return ans; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3498620,
                "title": "python-3-7-lines-dict-t-m-2675-ms-58-mb",
                "content": "```\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n\\n        ans, d, cnt = [], defaultdict(int), 0\\n\\n        for i, color in queries:\\n\\n            if d[i]: cnt-= (d[i-1] == d[i])+(d[i+1] == d[i])\\n            d[i] = color\\n            if d[i]: cnt+= (d[i-1] == d[i])+(d[i+1] == d[i])\\n\\n            ans.append(cnt)\\n\\n        return ans\\n```\\n[https://leetcode.com/problems/number-of-adjacent-elements-with-the-same-color/submissions/946358857/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n\\n        ans, d, cnt = [], defaultdict(int), 0\\n\\n        for i, color in queries:\\n\\n            if d[i]: cnt-= (d[i-1] == d[i])+(d[i+1] == d[i])\\n            d[i] = color\\n            if d[i]: cnt+= (d[i-1] == d[i])+(d[i+1] == d[i])\\n\\n            ans.append(cnt)\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496169,
                "title": "image-explanation-easy-c-solution",
                "content": "# Intuition\\nCheck for equality of nums[i] with nums[i-1] & nums[i+1] both.\\n**NOTE:** `Check if nums[i] is already present.` \\n\\n# Approach\\n\\n![Lc_page-0001.jpg](https://assets.leetcode.com/users/images/422ba2de-ae07-406a-b6d8-88622100dfb6_1683450011.98934.jpeg)\\n\\n**STEP 1:** If nums[ind] is already present then check for equality on left\\n\\n```\\nif(nums[ind] && ind - 1 >= 0 && nums[ind-1] == nums[ind]) cnt--;  \\n```\\n\\n**STEP 2:** If nums[ind] is already present then check for equality on right\\n\\n```\\nif(nums[ind] && ind + 1 < n && nums[ind+1] == nums[ind]) cnt--;\\n```\\n\\n**STEP 3:** Assign the color to the nums[ind]\\n\\n```\\n nums[ind] = color;\\n```\\n\\n **STEP 4:** Check for equality on left\\n\\n```\\nif( ind - 1 >= 0 && nums[ind-1] == nums[ind]) cnt++;\\n```\\n\\n**Step 5:** Check for equality on right\\n\\n```\\nif( ind + 1 < n && nums[ind+1] == nums[ind]) cnt++;\\n```\\n\\n**STEP 6:** Add cnt to the ans\\n\\n```\\nans.push_back(cnt);\\n```\\n# Complexity\\n- Time complexity: $$ O(q) $$ where q = size of queries\\n- Space complexity: $$ O(n) $$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        vector<int> nums(n,0);\\n        int cnt = 0;\\n        for(auto it: queries) {\\n            int ind = it[0];\\n            int color = it[1];\\n         \\n            // STEP 1: if nums[ind] is already present then check for equality on left\\n            if(nums[ind] && ind - 1 >= 0 && nums[ind-1] == nums[ind]) cnt--;  \\n            // STEP 2: if nums[ind] is already present then check for equality on right\\n            if(nums[ind] && ind + 1 < n && nums[ind+1] == nums[ind]) cnt--;\\n\\n            // STEP 3: Assign the color to the nums[ind]\\n            nums[ind] = color;\\n\\n            // Step 4: Check for equality on left\\n            if( ind - 1 >= 0 && nums[ind-1] == nums[ind]) cnt++;\\n            // Step 5: Check for equality on right\\n            if( ind + 1 < n && nums[ind+1] == nums[ind]) cnt++;\\n\\n            // STEP 6: add to the ans\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nif(nums[ind] && ind - 1 >= 0 && nums[ind-1] == nums[ind]) cnt--;  \\n```\n```\\nif(nums[ind] && ind + 1 < n && nums[ind+1] == nums[ind]) cnt--;\\n```\n```\\n nums[ind] = color;\\n```\n```\\nif( ind - 1 >= 0 && nums[ind-1] == nums[ind]) cnt++;\\n```\n```\\nif( ind + 1 < n && nums[ind+1] == nums[ind]) cnt++;\\n```\n```\\nans.push_back(cnt);\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        vector<int> nums(n,0);\\n        int cnt = 0;\\n        for(auto it: queries) {\\n            int ind = it[0];\\n            int color = it[1];\\n         \\n            // STEP 1: if nums[ind] is already present then check for equality on left\\n            if(nums[ind] && ind - 1 >= 0 && nums[ind-1] == nums[ind]) cnt--;  \\n            // STEP 2: if nums[ind] is already present then check for equality on right\\n            if(nums[ind] && ind + 1 < n && nums[ind+1] == nums[ind]) cnt--;\\n\\n            // STEP 3: Assign the color to the nums[ind]\\n            nums[ind] = color;\\n\\n            // Step 4: Check for equality on left\\n            if( ind - 1 >= 0 && nums[ind-1] == nums[ind]) cnt++;\\n            // Step 5: Check for equality on right\\n            if( ind + 1 < n && nums[ind+1] == nums[ind]) cnt++;\\n\\n            // STEP 6: add to the ans\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495015,
                "title": "easy-understandable-c-o-q-time-o-n-space",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIntialise count with 0\\nWhile inserting check if the inserting element will distrub the count\\nIf Distrubing decrement and increment accordingly...\\n\\n# Complexity\\n- Time complexity:O(Q)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& q) {\\n        vector<int>v(n,0);\\n        vector<int>ans;\\n        int cnt=0;\\n        for(int i=0;i<q.size();i++){\\n            int idx=q[i][0]; // At idx the new ele is added\\n            int col=q[i][1]; // the color to be added is col\\n            int prev=0;     // the previou elem at idx-1, which may contribute the cnt (also next)\\n            int next=0;\\n            if((idx-1)>=0){\\n                prev=v[idx-1];\\n            }\\n            if((idx+1)<n){\\n                next=v[idx+1];\\n            }\\n            if(v[idx]==prev and prev!=0){\\n                // if the v[idx] equal prev then decrement cnt\\n                cnt--;\\n            }\\n            if(v[idx]==next and next!=0){\\n                // if the v[idx] equal next then decrement cnt\\n                cnt--;\\n            }\\n            v[idx]=col; // new color is added at idx \\n\\n            if(v[idx]==prev and prev!=0){\\n                // if the v[idx] equal prev then increment cnt\\n                cnt++;\\n            }\\n            if(v[idx]==next and next!=0){\\n                // if the v[idx] equal next then increment cnt\\n                cnt++;\\n            }\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& q) {\\n        vector<int>v(n,0);\\n        vector<int>ans;\\n        int cnt=0;\\n        for(int i=0;i<q.size();i++){\\n            int idx=q[i][0]; // At idx the new ele is added\\n            int col=q[i][1]; // the color to be added is col\\n            int prev=0;     // the previou elem at idx-1, which may contribute the cnt (also next)\\n            int next=0;\\n            if((idx-1)>=0){\\n                prev=v[idx-1];\\n            }\\n            if((idx+1)<n){\\n                next=v[idx+1];\\n            }\\n            if(v[idx]==prev and prev!=0){\\n                // if the v[idx] equal prev then decrement cnt\\n                cnt--;\\n            }\\n            if(v[idx]==next and next!=0){\\n                // if the v[idx] equal next then decrement cnt\\n                cnt--;\\n            }\\n            v[idx]=col; // new color is added at idx \\n\\n            if(v[idx]==prev and prev!=0){\\n                // if the v[idx] equal prev then increment cnt\\n                cnt++;\\n            }\\n            if(v[idx]==next and next!=0){\\n                // if the v[idx] equal next then increment cnt\\n                cnt++;\\n            }\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3517717,
                "title": "java-simple-counting-15-lines-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe just need to keep track of the number of adjacent cells with the same color after every query. So for every query we check the 2 neighboring cells of `queries[i][0]` and update the count factoring in the old color that is going to be removed and the new color that is going to be added. The code should be self-explanatory.\\n\\n# Complexity\\n- Time complexity: $$O(m)$$ where `m = queries.length`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n + m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int[] colorTheArray(int n, int[][] queries) {\\n    var nums = new int[n];\\n    var m = queries.length;\\n    var ans = new int[m];\\n    var cnt = 0;\\n\\n    for (var i=0; i<m; i++) {\\n      var j = queries[i][0];\\n\\n      if (nums[j] != 0) {\\n        cnt -= j == 0 || nums[j - 1] != nums[j] ? 0 : 1;\\n        cnt -= j == n-1 || nums[j + 1] != nums[j] ? 0 : 1;\\n      }\\n      nums[j] = queries[i][1];\\n\\n      cnt += j == 0 || nums[j - 1] != nums[j] ? 0 : 1;\\n      cnt += j == n-1 || nums[j + 1] != nums[j] ? 0 : 1;\\n\\n      ans[i] = cnt;\\n    }\\n    return ans;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n  public int[] colorTheArray(int n, int[][] queries) {\\n    var nums = new int[n];\\n    var m = queries.length;\\n    var ans = new int[m];\\n    var cnt = 0;\\n\\n    for (var i=0; i<m; i++) {\\n      var j = queries[i][0];\\n\\n      if (nums[j] != 0) {\\n        cnt -= j == 0 || nums[j - 1] != nums[j] ? 0 : 1;\\n        cnt -= j == n-1 || nums[j + 1] != nums[j] ? 0 : 1;\\n      }\\n      nums[j] = queries[i][1];\\n\\n      cnt += j == 0 || nums[j - 1] != nums[j] ? 0 : 1;\\n      cnt += j == n-1 || nums[j + 1] != nums[j] ? 0 : 1;\\n\\n      ans[i] = cnt;\\n    }\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495848,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def colorTheArray(self, n, queries):\\n        ans, nums, count = [], [0]*n, 0\\n\\n        for i in range(len(queries)):\\n            index, color = queries[i][0], queries[i][1]\\n\\n            if index-1 >= 0 and nums[index] != 0 and nums[index-1] == nums[index]:\\n                count -= 1\\n            if index+1 < n and nums[index] != 0 and nums[index+1] == nums[index]:\\n                count -= 1\\n\\n            nums[index] = color\\n\\n            if index-1 >= 0 and nums[index] != 0 and nums[index-1] == nums[index]:\\n                count += 1\\n            if index+1 < n and nums[index] != 0 and nums[index+1] == nums[index]:\\n                count += 1\\n\\n            ans.append(count)\\n\\n        return ans\\n\\n            \\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def colorTheArray(self, n, queries):\\n        ans, nums, count = [], [0]*n, 0\\n\\n        for i in range(len(queries)):\\n            index, color = queries[i][0], queries[i][1]\\n\\n            if index-1 >= 0 and nums[index] != 0 and nums[index-1] == nums[index]:\\n                count -= 1\\n            if index+1 < n and nums[index] != 0 and nums[index+1] == nums[index]:\\n                count -= 1\\n\\n            nums[index] = color\\n\\n            if index-1 >= 0 and nums[index] != 0 and nums[index-1] == nums[index]:\\n                count += 1\\n            if index+1 < n and nums[index] != 0 and nums[index+1] == nums[index]:\\n                count += 1\\n\\n            ans.append(count)\\n\\n        return ans\\n\\n            \\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495785,
                "title": "using-map-c-easy-to-understnad",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& v) {\\n        unordered_map<int,int> mp;\\n        int x = 0;\\n        vector<int> ans;\\n        for(auto &i: v){\\n            if(mp.count(i[0]-1)&&mp[i[0]-1]==mp[i[0]])x--;\\n            if(mp.count(i[0]+1)&&mp[i[0]+1]==mp[i[0]])x--;\\n            mp[i[0]] = i[1];\\n            if(mp.count(i[0]-1)&&mp[i[0]-1]==i[1])x++;\\n            if(mp.count(i[0]+1)&&mp[i[0]+1]==i[1])x++;\\n            ans.push_back(x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& v) {\\n        unordered_map<int,int> mp;\\n        int x = 0;\\n        vector<int> ans;\\n        for(auto &i: v){\\n            if(mp.count(i[0]-1)&&mp[i[0]-1]==mp[i[0]])x--;\\n            if(mp.count(i[0]+1)&&mp[i[0]+1]==mp[i[0]])x--;\\n            mp[i[0]] = i[1];\\n            if(mp.count(i[0]-1)&&mp[i[0]-1]==i[1])x++;\\n            if(mp.count(i[0]+1)&&mp[i[0]+1]==i[1])x++;\\n            ans.push_back(x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495524,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int>ans,arr(n);\\n        int prev=0,ind,color,i=0;\\n        for(vector<int>&a:queries)\\n        {\\n            ind=a[0];\\n            color=a[1];\\n         \\n            if(color!=arr[ind]){\\n            if(prev>0)\\n            {\\n                if(ind<=n-2) {\\n                    if(arr[ind]==arr[ind+1]&&color!=arr[ind])\\n                    {\\n                       if(arr[ind]!=0)  prev--;\\n                      \\n                    }\\n                }\\n                if(ind>=1)\\n                {\\n                     if(arr[ind]==arr[ind-1]&&color!=arr[ind])\\n                    {\\n                       if(arr[ind]!=0)  prev--;\\n                    }\\n                }\\n                        \\n            }\\n            arr[ind]=color;\\n          \\n            if(ind>=1) \\n            {\\n                 if(arr[ind-1]==arr[ind]) prev++;\\n            }\\n            if(ind<=n-2)\\n            {\\n                if(arr[ind]==arr[ind+1]) prev++;\\n            }\\n           \\n            }\\n            ans.push_back(prev);\\n           \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int>ans,arr(n);\\n        int prev=0,ind,color,i=0;\\n        for(vector<int>&a:queries)\\n        {\\n            ind=a[0];\\n            color=a[1];\\n         \\n            if(color!=arr[ind]){\\n            if(prev>0)\\n            {\\n                if(ind<=n-2) {\\n                    if(arr[ind]==arr[ind+1]&&color!=arr[ind])\\n                    {\\n                       if(arr[ind]!=0)  prev--;\\n                      \\n                    }\\n                }\\n                if(ind>=1)\\n                {\\n                     if(arr[ind]==arr[ind-1]&&color!=arr[ind])\\n                    {\\n                       if(arr[ind]!=0)  prev--;\\n                    }\\n                }\\n                        \\n            }\\n            arr[ind]=color;\\n          \\n            if(ind>=1) \\n            {\\n                 if(arr[ind-1]==arr[ind]) prev++;\\n            }\\n            if(ind<=n-2)\\n            {\\n                if(arr[ind]==arr[ind+1]) prev++;\\n            }\\n           \\n            }\\n            ans.push_back(prev);\\n           \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494954,
                "title": "check-contribution-simple-c-concise-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& q) {\\n        \\n        vector<int> res(q.size());\\n        vector<int> arr(n,0);\\n        \\n        int cnt=0;\\n        res[0]=0;\\n        arr[q[0][0]]=q[0][1];\\n        for(int i=1;i<q.size();i++)\\n        {\\n            if(arr[q[i][0]]==0)\\n            {\\n                if(q[i][0]-1>=0 &&  arr[q[i][0]-1]==q[i][1]) cnt++;\\n                if(q[i][0]+1 <n &&  arr[q[i][0]+1]==q[i][1]) cnt++;\\n              \\n              \\n            }\\n            else \\n            {\\n                if(q[i][0]-1>=0 &&  arr[q[i][0]]==arr[q[i][0]-1]) cnt--;\\n                 if(q[i][0]+1 <n && arr[q[i][0]]==arr[q[i][0]+1]) cnt--;  \\n                                         \\n                 if(q[i][0]-1>=0 &&  arr[q[i][0]-1]==q[i][1]) cnt++;\\n                 if(q[i][0]+1 <n &&  arr[q[i][0]+1]==q[i][1]) cnt++;\\n                                         \\n              \\n            }\\n              arr[q[i][0]]=q[i][1];\\n                res[i]=cnt;\\n                \\n        }\\n        return res;                                 \\n                                        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& q) {\\n        \\n        vector<int> res(q.size());\\n        vector<int> arr(n,0);\\n        \\n        int cnt=0;\\n        res[0]=0;\\n        arr[q[0][0]]=q[0][1];\\n        for(int i=1;i<q.size();i++)\\n        {\\n            if(arr[q[i][0]]==0)\\n            {\\n                if(q[i][0]-1>=0 &&  arr[q[i][0]-1]==q[i][1]) cnt++;\\n                if(q[i][0]+1 <n &&  arr[q[i][0]+1]==q[i][1]) cnt++;\\n              \\n              \\n            }\\n            else \\n            {\\n                if(q[i][0]-1>=0 &&  arr[q[i][0]]==arr[q[i][0]-1]) cnt--;\\n                 if(q[i][0]+1 <n && arr[q[i][0]]==arr[q[i][0]+1]) cnt--;  \\n                                         \\n                 if(q[i][0]-1>=0 &&  arr[q[i][0]-1]==q[i][1]) cnt++;\\n                 if(q[i][0]+1 <n &&  arr[q[i][0]+1]==q[i][1]) cnt++;\\n                                         \\n              \\n            }\\n              arr[q[i][0]]=q[i][1];\\n                res[i]=cnt;\\n                \\n        }\\n        return res;                                 \\n                                        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494927,
                "title": "maintain-a-count-c-java-python-o-q-easy-stright-forward",
                "content": "```\\n1. Easy Question And Easy Solution.\\n2. Don\\'t need to do or use any fancy data structure.\\n3. Just maintain a count of number of adjacent elements with the same color and \\n   update the count according to queries\\n4. for index in each query just check the previous and next element and update the count \\n```\\n**C++ CODE**\\n```\\nvector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n      \\n        int count = 0;\\n        \\n        vector<int> nums(n,0), result;\\n        \\n        for(auto &q: queries) {\\n            \\n            int idx = q[0], val = q[1];\\n            \\n            if(idx > 0) {\\n                if(nums[idx-1] == 0);//don\\'t do anything\\n                else if(nums[idx] == nums[idx-1]) {\\n                    if(nums[idx] != val)if(count > 0)count--;\\n                }\\n                else {\\n                    if(val == nums[idx-1])count++;\\n                }\\n            }\\n\\t\\t\\t\\n            if(idx+1 < n) {\\n                if(nums[idx+1] == 0);//don\\'t do anything\\n                else if(nums[idx] == nums[idx+1]) {\\n                    if(nums[idx] != val)if(count > 0)count--;\\n                }\\n                else {\\n                    if(val == nums[idx+1])count++;\\n                }\\n            }\\n            \\n            nums[idx] = val;\\n            result.push_back(count);\\n        }\\n        \\n        return result;\\n    }\\n```\\n\\n**JAVA CODE**\\n```\\npublic int[] colorTheArray(int n, int[][] queries) {\\n        int count = 0;\\n        int[] nums = new int[n];\\n        int[] result = new int[queries.length];\\n        \\n        for(int i = 0; i < queries.length; i++) {\\n            int idx = queries[i][0], val = queries[i][1];\\n            \\n            if(idx > 0) {\\n                if(nums[idx-1] == 0);\\n                else if(nums[idx] == nums[idx-1]) {\\n                    if(nums[idx] != val && count > 0) count--;\\n                }\\n                else {\\n                    if(val == nums[idx-1]) count++;\\n                }\\n            }\\n\\t\\t\\t\\n            if(idx+1 < n) {\\n                if(nums[idx+1] == 0);\\n                else if(nums[idx] == nums[idx+1]) {\\n                    if(nums[idx] != val && count > 0) count--;\\n                }\\n                else {\\n                    if(val == nums[idx+1]) count++;\\n                }\\n            }\\n            \\n            nums[idx] = val;\\n            result[i] = count;\\n        }\\n        \\n        return result;\\n    }\\n```\\n\\n**PYTHON CODE**\\n```\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n        count = 0\\n        nums = [0] * n\\n        result = []\\n        \\n        for q in queries:\\n            idx, val = q\\n            \\n            if idx > 0:\\n                if nums[idx-1] == 0:\\n                    pass\\n                elif nums[idx] == nums[idx-1]:\\n                    if nums[idx] != val and count > 0:\\n                        count -= 1\\n                else:\\n                    if val == nums[idx-1]:\\n                        count += 1\\n\\t\\t\\t\\n            if idx+1 < n:\\n                if nums[idx+1] == 0:\\n                    pass\\n                elif nums[idx] == nums[idx+1]:\\n                    if nums[idx] != val and count > 0:\\n                        count -= 1\\n                else:\\n                    if val == nums[idx+1]:\\n                        count += 1\\n            \\n            nums[idx] = val\\n            result.append(count)\\n        \\n        return result\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "Array"
                ],
                "code": "```\\n1. Easy Question And Easy Solution.\\n2. Don\\'t need to do or use any fancy data structure.\\n3. Just maintain a count of number of adjacent elements with the same color and \\n   update the count according to queries\\n4. for index in each query just check the previous and next element and update the count \\n```\n```\\nvector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n      \\n        int count = 0;\\n        \\n        vector<int> nums(n,0), result;\\n        \\n        for(auto &q: queries) {\\n            \\n            int idx = q[0], val = q[1];\\n            \\n            if(idx > 0) {\\n                if(nums[idx-1] == 0);//don\\'t do anything\\n                else if(nums[idx] == nums[idx-1]) {\\n                    if(nums[idx] != val)if(count > 0)count--;\\n                }\\n                else {\\n                    if(val == nums[idx-1])count++;\\n                }\\n            }\\n\\t\\t\\t\\n            if(idx+1 < n) {\\n                if(nums[idx+1] == 0);//don\\'t do anything\\n                else if(nums[idx] == nums[idx+1]) {\\n                    if(nums[idx] != val)if(count > 0)count--;\\n                }\\n                else {\\n                    if(val == nums[idx+1])count++;\\n                }\\n            }\\n            \\n            nums[idx] = val;\\n            result.push_back(count);\\n        }\\n        \\n        return result;\\n    }\\n```\n```\\npublic int[] colorTheArray(int n, int[][] queries) {\\n        int count = 0;\\n        int[] nums = new int[n];\\n        int[] result = new int[queries.length];\\n        \\n        for(int i = 0; i < queries.length; i++) {\\n            int idx = queries[i][0], val = queries[i][1];\\n            \\n            if(idx > 0) {\\n                if(nums[idx-1] == 0);\\n                else if(nums[idx] == nums[idx-1]) {\\n                    if(nums[idx] != val && count > 0) count--;\\n                }\\n                else {\\n                    if(val == nums[idx-1]) count++;\\n                }\\n            }\\n\\t\\t\\t\\n            if(idx+1 < n) {\\n                if(nums[idx+1] == 0);\\n                else if(nums[idx] == nums[idx+1]) {\\n                    if(nums[idx] != val && count > 0) count--;\\n                }\\n                else {\\n                    if(val == nums[idx+1]) count++;\\n                }\\n            }\\n            \\n            nums[idx] = val;\\n            result[i] = count;\\n        }\\n        \\n        return result;\\n    }\\n```\n```\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n        count = 0\\n        nums = [0] * n\\n        result = []\\n        \\n        for q in queries:\\n            idx, val = q\\n            \\n            if idx > 0:\\n                if nums[idx-1] == 0:\\n                    pass\\n                elif nums[idx] == nums[idx-1]:\\n                    if nums[idx] != val and count > 0:\\n                        count -= 1\\n                else:\\n                    if val == nums[idx-1]:\\n                        count += 1\\n\\t\\t\\t\\n            if idx+1 < n:\\n                if nums[idx+1] == 0:\\n                    pass\\n                elif nums[idx] == nums[idx+1]:\\n                    if nums[idx] != val and count > 0:\\n                        count -= 1\\n                else:\\n                    if val == nums[idx+1]:\\n                        count += 1\\n            \\n            nums[idx] = val\\n            result.append(count)\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598865,
                "title": "c-solution-simple-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n    vector<int>color(n,0);\\n\\n    vector<int>wholeans;\\n\\n    int ans=0;\\n\\n        for(int i=0;i<queries.size();i++){\\n            int  index = queries[i][0],newcolor = queries[i][1];\\n            \\n            int leftside = index-1 < 0 ? 0 :color[index-1];\\n            int rightside = index+1 == n ? 0 :color[index+1];\\n\\n            if( color[index]!=0 && leftside == color[index] )ans--;\\n            if( color[index]!=0 && rightside == color[index] )ans--;\\n\\n            color[index]=newcolor;\\n\\n            if( leftside==color[index] )ans++;\\n            if( rightside==color[index] )ans++;\\n\\n            wholeans.push_back(ans);\\n        }\\n        return wholeans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n    vector<int>color(n,0);\\n\\n    vector<int>wholeans;\\n\\n    int ans=0;\\n\\n        for(int i=0;i<queries.size();i++){\\n            int  index = queries[i][0],newcolor = queries[i][1];\\n            \\n            int leftside = index-1 < 0 ? 0 :color[index-1];\\n            int rightside = index+1 == n ? 0 :color[index+1];\\n\\n            if( color[index]!=0 && leftside == color[index] )ans--;\\n            if( color[index]!=0 && rightside == color[index] )ans--;\\n\\n            color[index]=newcolor;\\n\\n            if( leftside==color[index] )ans++;\\n            if( rightside==color[index] )ans++;\\n\\n            wholeans.push_back(ans);\\n        }\\n        return wholeans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496911,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n        count = 0\\n        nums = [0] * n\\n        ans = []\\n        \\n        for q in queries:\\n            idx, val = q\\n            \\n            if idx > 0:\\n                if nums[idx-1] == 0:\\n                    pass\\n                elif nums[idx] == nums[idx-1]:\\n                    if nums[idx] != val and count > 0:\\n                        count -= 1\\n                else:\\n                    if val == nums[idx-1]:\\n                        count += 1\\n\\t\\t\\t\\n            if idx+1 < n:\\n                if nums[idx+1] == 0:\\n                    pass\\n                elif nums[idx] == nums[idx+1]:\\n                    if nums[idx] != val and count > 0:\\n                        count -= 1\\n                else:\\n                    if val == nums[idx+1]:\\n                        count += 1\\n            \\n            nums[idx] = val\\n            ans.append(count)\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n        count = 0\\n        nums = [0] * n\\n        ans = []\\n        \\n        for q in queries:\\n            idx, val = q\\n            \\n            if idx > 0:\\n                if nums[idx-1] == 0:\\n                    pass\\n                elif nums[idx] == nums[idx-1]:\\n                    if nums[idx] != val and count > 0:\\n                        count -= 1\\n                else:\\n                    if val == nums[idx-1]:\\n                        count += 1\\n\\t\\t\\t\\n            if idx+1 < n:\\n                if nums[idx+1] == 0:\\n                    pass\\n                elif nums[idx] == nums[idx+1]:\\n                    if nums[idx] != val and count > 0:\\n                        count -= 1\\n                else:\\n                    if val == nums[idx+1]:\\n                        count += 1\\n            \\n            nums[idx] = val\\n            ans.append(count)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496152,
                "title": "day-402-brute-better-optimal-100-0ms-python-java-c-explained-approach",
                "content": "# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99 \\n# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nCOMMING SOON\\n\\n# Code\\n```JAVA []\\npublic int[] colorTheArray(int n, int[][] q) {\\n    int nums[] = new int[n];\\n    int len = q.length;\\n    int answer[] = new int[len];\\n    int cnt =0;\\n    for(int i=0;i<len;i++){\\n        int ind=q[i][0],col=q[i][1];\\n        int prev = (ind>0)?nums[ind-1]:0;\\n        int next = (ind<n-1)?nums[ind+1]:0;\\n        if(nums[ind]!=0 && (nums[ind]==prev))cnt--;\\n        if(nums[ind]!=0 && (nums[ind]==next))cnt--;\\n        nums[ind]=col;\\n        if(nums[ind]==prev)cnt++;\\n        if( nums[ind]==next)cnt++;\\n        answer[i]=cnt;\\n    }return answer;\\n}\\n```\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```JAVA []\\npublic int[] colorTheArray(int n, int[][] q) {\\n    int nums[] = new int[n];\\n    int len = q.length;\\n    int answer[] = new int[len];\\n    int cnt =0;\\n    for(int i=0;i<len;i++){\\n        int ind=q[i][0],col=q[i][1];\\n        int prev = (ind>0)?nums[ind-1]:0;\\n        int next = (ind<n-1)?nums[ind+1]:0;\\n        if(nums[ind]!=0 && (nums[ind]==prev))cnt--;\\n        if(nums[ind]!=0 && (nums[ind]==next))cnt--;\\n        nums[ind]=col;\\n        if(nums[ind]==prev)cnt++;\\n        if( nums[ind]==next)cnt++;\\n        answer[i]=cnt;\\n    }return answer;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3495354,
                "title": "c-best-solution-o-n-easy-to-understand",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> arr(n, 0), ans;\\n        int cnt = 0;\\n        for(auto it : queries)  {\\n            int ind = it[0], color = it[1];\\n            if(ind - 1 >= 0 && arr[ind - 1] == arr[ind] && arr[ind] != 0)    cnt--;\\n            if(ind+1<n && arr[ind+1] == arr[ind] && arr[ind] != 0)  cnt--;\\n            if(ind - 1 >= 0 && arr[ind - 1] == color)    cnt++;\\n            if(ind+1<n && arr[ind+1] == color)  cnt++;\\n            arr[ind] = color;\\n            ans.push_back(cnt);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Simulation",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> arr(n, 0), ans;\\n        int cnt = 0;\\n        for(auto it : queries)  {\\n            int ind = it[0], color = it[1];\\n            if(ind - 1 >= 0 && arr[ind - 1] == arr[ind] && arr[ind] != 0)    cnt--;\\n            if(ind+1<n && arr[ind+1] == arr[ind] && arr[ind] != 0)  cnt--;\\n            if(ind - 1 >= 0 && arr[ind - 1] == color)    cnt++;\\n            if(ind+1<n && arr[ind+1] == color)  cnt++;\\n            arr[ind] = color;\\n            ans.push_back(cnt);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495293,
                "title": "very-simple-and-beginner-friendly-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse last matching adjacent colors to calculate for current query.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor every query we will save matching adjacent colors and use it in next query. And check if on changing current query if no of matching adjacent colors increases or decreases.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int>ans;\\n        int x=0;\\n        vector<int>color(n+2,0);\\n        ans.push_back(0);\\n        color[queries[0][0]+1]=queries[0][1];\\n        for(int i=1;i<queries.size();i++)\\n        {\\n            int p=0,q=0;\\n            if(color[queries[i][0]+1]==color[queries[i][0]] && color[queries[i][0]+1]!=0)\\n                p++;\\n            if(color[queries[i][0]+1]==color[queries[i][0]+2] && color[queries[i][0]+1]!=0)\\n                p++;\\n            color[queries[i][0]+1]=queries[i][1];\\n            if(color[queries[i][0]+1]==color[queries[i][0]])\\n                q++;\\n            if(color[queries[i][0]+1]==color[queries[i][0]+2])\\n                q++;\\n            x+=(q-p);\\n            ans.push_back(x);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int>ans;\\n        int x=0;\\n        vector<int>color(n+2,0);\\n        ans.push_back(0);\\n        color[queries[0][0]+1]=queries[0][1];\\n        for(int i=1;i<queries.size();i++)\\n        {\\n            int p=0,q=0;\\n            if(color[queries[i][0]+1]==color[queries[i][0]] && color[queries[i][0]+1]!=0)\\n                p++;\\n            if(color[queries[i][0]+1]==color[queries[i][0]+2] && color[queries[i][0]+1]!=0)\\n                p++;\\n            color[queries[i][0]+1]=queries[i][1];\\n            if(color[queries[i][0]+1]==color[queries[i][0]])\\n                q++;\\n            if(color[queries[i][0]+1]==color[queries[i][0]+2])\\n                q++;\\n            x+=(q-p);\\n            ans.push_back(x);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495200,
                "title": "easy-c-solution-o-queries-size-time-complexity-solution",
                "content": "# Intuition\\nBefore painting an index just check how the color present at the index is reducing the number of adjacent elements. Now check the new color that we are going to paint at that index is increaing the adjacent element or not.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> res;\\n        vector<int> arr(n,0);\\n        int m = queries.size();\\n        int ans = 0;\\n        for(int i = 0; i < m; i++){\\n            if(i == 0){\\n                ans = 0;\\n                arr[queries[i][0]] = queries[i][1];\\n            } else {\\n                int ind = queries[i][0];\\n                if(ind > 0 && arr[ind - 1] == arr[ind] && arr[ind - 1] != 0) ans--;\\n                if(ind < n - 1 && arr[ind + 1] == arr[ind] && arr[ind + 1] != 0) ans--;\\n                arr[ind] = queries[i][1];\\n                if(ind > 0 && arr[ind - 1] == arr[ind]) ans++;\\n                if(ind < n - 1 && arr[ind + 1] == arr[ind]) ans++;\\n            }\\n            res.push_back(ans);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> res;\\n        vector<int> arr(n,0);\\n        int m = queries.size();\\n        int ans = 0;\\n        for(int i = 0; i < m; i++){\\n            if(i == 0){\\n                ans = 0;\\n                arr[queries[i][0]] = queries[i][1];\\n            } else {\\n                int ind = queries[i][0];\\n                if(ind > 0 && arr[ind - 1] == arr[ind] && arr[ind - 1] != 0) ans--;\\n                if(ind < n - 1 && arr[ind + 1] == arr[ind] && arr[ind + 1] != 0) ans--;\\n                arr[ind] = queries[i][1];\\n                if(ind > 0 && arr[ind - 1] == arr[ind]) ans++;\\n                if(ind < n - 1 && arr[ind + 1] == arr[ind]) ans++;\\n            }\\n            res.push_back(ans);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495099,
                "title": "c-easy-to-understand-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& q) {\\n        vector<int> ans;\\n        vector<int> v(n, 0);\\n        int adjacentColorCount = 0;\\n        for(int i = 0; i < q.size(); i++) {\\n            int index = q[i][0];\\n            int color = q[i][1];\\n            int prevColorAtIndex = v[index];\\n            // color with current color at index.\\n            v[index] = color;\\n            // if adjacent color is same means we have to increase the adjacentColorCount\\n            if(index > 0 && v[index - 1] == v[index]) adjacentColorCount++;\\n            if(index < n - 1 && v[index + 1] == v[index]) adjacentColorCount++;\\n            // if previously adjacent color is changed after coloring with new color, means we have to decrease the adjacentColorCount\\n            if(index > 0 && prevColorAtIndex > 0 && v[index - 1] == prevColorAtIndex) adjacentColorCount--;\\n            if(index < n - 1 && prevColorAtIndex > 0 && v[index + 1] == prevColorAtIndex) adjacentColorCount--;\\n            ans.push_back(adjacentColorCount);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& q) {\\n        vector<int> ans;\\n        vector<int> v(n, 0);\\n        int adjacentColorCount = 0;\\n        for(int i = 0; i < q.size(); i++) {\\n            int index = q[i][0];\\n            int color = q[i][1];\\n            int prevColorAtIndex = v[index];\\n            // color with current color at index.\\n            v[index] = color;\\n            // if adjacent color is same means we have to increase the adjacentColorCount\\n            if(index > 0 && v[index - 1] == v[index]) adjacentColorCount++;\\n            if(index < n - 1 && v[index + 1] == v[index]) adjacentColorCount++;\\n            // if previously adjacent color is changed after coloring with new color, means we have to decrease the adjacentColorCount\\n            if(index > 0 && prevColorAtIndex > 0 && v[index - 1] == prevColorAtIndex) adjacentColorCount--;\\n            if(index < n - 1 && prevColorAtIndex > 0 && v[index + 1] == prevColorAtIndex) adjacentColorCount--;\\n            ans.push_back(adjacentColorCount);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495059,
                "title": "easy-c-solution-compare-1-before-and-after-element-only",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialized nums of size n, ans of size querr.size() and a map for checking 1st time occurance of any index.\\n2. In every querry we checking firstly if it have adjacent same than decrementing counter else incrementing.\\n3. then adding that count in ans;\\n\\n# Complexity\\n- Time complexity: $$O(m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& q) {\\n        vector<int> nums(n,0);\\n        int m = q.size();\\n        vector<int> ans(m,0);\\n        unordered_map<int,int> y;\\n        int x=0;\\n        for(int i=0;i<m;i++){\\n            if(y[q[i][0]]!=0){\\n                if(q[i][0]!=0 && nums[q[i][0]]==nums[q[i][0]-1]) x--;\\n                if(q[i][0]!=n-1 && nums[q[i][0]]==nums[q[i][0]+1]) x--;\\n            }\\n            y[q[i][0]]++;\\n            nums[q[i][0]]=q[i][1];\\n            if(q[i][0]!=0 && nums[q[i][0]]==nums[q[i][0]-1]) x++;\\n            if(q[i][0]!=n-1 && nums[q[i][0]]==nums[q[i][0]+1]) x++;\\n            ans[i]=x;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& q) {\\n        vector<int> nums(n,0);\\n        int m = q.size();\\n        vector<int> ans(m,0);\\n        unordered_map<int,int> y;\\n        int x=0;\\n        for(int i=0;i<m;i++){\\n            if(y[q[i][0]]!=0){\\n                if(q[i][0]!=0 && nums[q[i][0]]==nums[q[i][0]-1]) x--;\\n                if(q[i][0]!=n-1 && nums[q[i][0]]==nums[q[i][0]+1]) x--;\\n            }\\n            y[q[i][0]]++;\\n            nums[q[i][0]]=q[i][1];\\n            if(q[i][0]!=0 && nums[q[i][0]]==nums[q[i][0]-1]) x++;\\n            if(q[i][0]!=n-1 && nums[q[i][0]]==nums[q[i][0]+1]) x++;\\n            ans[i]=x;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495047,
                "title": "o-n-solution",
                "content": "# Intuition\\n\\nSince n can be 10^5 so we need to have solution in O(n) or O(nlogn) to avoid TLE and it can be observed that we can keep a counter which represents current adjacent equals and simply update it after the query[i].\\n\\nThere can be two cases\\n1. If the currentColor already matches the color being added. Then we do nothing and simply push the current count to the result array.\\n2. If it doesn\\'t then there can be two cases\\n - If the current color at that index is 0 i.e. it is uncolored then we check whether the color that we want to add to that index matches any of the adjacent colors, if yes then we increment the count and udate the index\\'s color to query[i][1]\\n- If the index is colored then we check if existing color matches any of the existing colors. If yes, decrement the count accordingly and then we update the index\\'s to query[i] color and again compute the new count based on the current situation of adjacent index\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> colors(n, 0);\\n        int count = 0;\\n        vector<int> ans;\\n        for(int i=0;i<queries.size();i++) {\\n            int index = queries[i][0];\\n            int color = queries[i][1];\\n            if(colors[index] == color) {\\n                ans.push_back(count);\\n            } else {\\n                int currentColor = colors[index];\\n                if(currentColor == 0) {\\n                    if(index > 0 && colors[index-1] == color) {\\n                        count++;\\n                    }\\n                    if(index < n-1 && colors[index+1] == color) {\\n                        count++;\\n                    }\\n\\n                    colors[index] = color;\\n                    ans.push_back(count);\\n                } \\n                else {\\n                    if(index > 0 && colors[index-1] == colors[index]) {\\n                        count--;\\n                    }\\n                    if(index < n-1 && colors[index+1] == colors[index]) {\\n                        count--;\\n                    }\\n\\n                    colors[index] = color;\\n                    if(index > 0 && colors[index-1] == colors[index]) {\\n                        count++;\\n                    }\\n                    if(index < n-1 && colors[index+1] == colors[index]) {\\n                        count++;\\n                    }\\n\\n                    ans.push_back(count);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> colors(n, 0);\\n        int count = 0;\\n        vector<int> ans;\\n        for(int i=0;i<queries.size();i++) {\\n            int index = queries[i][0];\\n            int color = queries[i][1];\\n            if(colors[index] == color) {\\n                ans.push_back(count);\\n            } else {\\n                int currentColor = colors[index];\\n                if(currentColor == 0) {\\n                    if(index > 0 && colors[index-1] == color) {\\n                        count++;\\n                    }\\n                    if(index < n-1 && colors[index+1] == color) {\\n                        count++;\\n                    }\\n\\n                    colors[index] = color;\\n                    ans.push_back(count);\\n                } \\n                else {\\n                    if(index > 0 && colors[index-1] == colors[index]) {\\n                        count--;\\n                    }\\n                    if(index < n-1 && colors[index+1] == colors[index]) {\\n                        count--;\\n                    }\\n\\n                    colors[index] = color;\\n                    if(index > 0 && colors[index-1] == colors[index]) {\\n                        count++;\\n                    }\\n                    if(index < n-1 && colors[index+1] == colors[index]) {\\n                        count++;\\n                    }\\n\\n                    ans.push_back(count);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4049338,
                "title": "c-o-n-simple-counting-easy-to-understand",
                "content": "**Idea :**\\n1. During each iteration, we set the values of two variables - oldT, newT. oldT checks the immediate left and right position if they are equal to the current index as it is going to be modified.\\n2. After setting oldT, we perform the required modification.\\n3. Now, we set the value of newT, performing the same operation as for oldT. \\n4. The differenct of newT and oldT i.e. newT-oldT is the effective change in count which is added into the variable \"cnt\" which is being maintained from start.\\n\\n```\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int>colors(n+1,0);\\n        vector<int>ans;\\n        int cnt = 0;\\n        \\n        for(auto i : queries){\\n            int idx = i[0];\\n            int oldT = 0, newT = 0;\\n            \\n            // calculate old effect from (i-1)th and (i+1)th position\\n            if(idx!=0){\\n                if(colors[idx-1]==colors[idx] && colors[idx]!=0){oldT++;}\\n            }            \\n            if(colors[idx+1]==colors[idx] && colors[idx]!=0){\\n                oldT++;\\n            }\\n            \\n            // perform the required change\\n            colors[idx] = i[1];\\n            \\n            // calculate new effect from (i-1)th and (i+1)th position\\n            if(idx!=0){\\n                if(colors[idx-1]==colors[idx] && colors[idx]!=0){newT++;}\\n            }            \\n            if(colors[idx+1]==colors[idx] && colors[idx]!=0){\\n                newT++;\\n            }\\n            \\n            // add the difference of new and old effects into the count\\n            cnt+=newT - oldT;\\n            ans.push_back(cnt);\\n        }\\n        \\n        return ans;\\n    }\\n```\\n\\nTime : O(N)\\nSpace : O(N)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Simulation",
                    "Counting"
                ],
                "code": "```\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int>colors(n+1,0);\\n        vector<int>ans;\\n        int cnt = 0;\\n        \\n        for(auto i : queries){\\n            int idx = i[0];\\n            int oldT = 0, newT = 0;\\n            \\n            // calculate old effect from (i-1)th and (i+1)th position\\n            if(idx!=0){\\n                if(colors[idx-1]==colors[idx] && colors[idx]!=0){oldT++;}\\n            }            \\n            if(colors[idx+1]==colors[idx] && colors[idx]!=0){\\n                oldT++;\\n            }\\n            \\n            // perform the required change\\n            colors[idx] = i[1];\\n            \\n            // calculate new effect from (i-1)th and (i+1)th position\\n            if(idx!=0){\\n                if(colors[idx-1]==colors[idx] && colors[idx]!=0){newT++;}\\n            }            \\n            if(colors[idx+1]==colors[idx] && colors[idx]!=0){\\n                newT++;\\n            }\\n            \\n            // add the difference of new and old effects into the count\\n            cnt+=newT - oldT;\\n            ans.push_back(cnt);\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3578004,
                "title": "self-explanatory-easy-to-understand-solution",
                "content": "# Complexity\\n- Time complexity : $$O(Q)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> color(n,0);\\n        \\n        int cnt = 0;\\n        vector<int> ans(queries.size());\\n        for(int x=0 ; x<queries.size() ; x++) {\\n            int i = queries[x][0];\\n            int col = queries[x][1];\\n            \\n            // count will decrease only when the \"i\"th index is already colored\\n            if(color[i] != 0) {\\n                if(i>=1 && color[i]==color[i-1]) cnt--;\\n                if(i<n-1 && color[i]==color[i+1]) cnt--;\\n            }\\n            \\n            // change the color of index \"i\" and update the count\\n            color[i] = col;\\n            if(i>=1 && color[i]==color[i-1]) cnt++;\\n            if(i<n-1 && color[i]==color[i+1]) cnt++;\\n            \\n            ans[x] = cnt;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> color(n,0);\\n        \\n        int cnt = 0;\\n        vector<int> ans(queries.size());\\n        for(int x=0 ; x<queries.size() ; x++) {\\n            int i = queries[x][0];\\n            int col = queries[x][1];\\n            \\n            // count will decrease only when the \"i\"th index is already colored\\n            if(color[i] != 0) {\\n                if(i>=1 && color[i]==color[i-1]) cnt--;\\n                if(i<n-1 && color[i]==color[i+1]) cnt--;\\n            }\\n            \\n            // change the color of index \"i\" and update the count\\n            color[i] = col;\\n            if(i>=1 && color[i]==color[i-1]) cnt++;\\n            if(i<n-1 && color[i]==color[i+1]) cnt++;\\n            \\n            ans[x] = cnt;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511155,
                "title": "easy-solution-in-c",
                "content": "# Complexity\\n- Time complexity: O(q), where q is the number of queries.\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        int m = queries.size();\\n        vector<int> nums(n, 0);\\n        vector<int> ans(m, 0);\\n        for(int i=0; i<m; i++){\\n            auto v = queries[i];\\n            int temp = 0;\\n            if(nums[v[0]]==0){\\n                nums[v[0]]=v[1];\\n                if(v[0] > 0 && nums[v[0]-1]==nums[v[0]]) temp++;\\n                if(v[0]!=n-1 && nums[v[0]]==nums[v[0]+1]) temp++;\\n                if(i!=0) ans[i]=ans[i-1] + temp;\\n            }\\n            else{\\n                if(v[0] > 0 && nums[v[0]-1]==nums[v[0]]) temp++;\\n                if(v[0]!=n-1 && nums[v[0]]==nums[v[0]+1]) temp++;\\n                nums[v[0]]=v[1];\\n                if(v[0] > 0 && nums[v[0]-1]==nums[v[0]]) temp--;\\n                if(v[0]!=n-1 && nums[v[0]]==nums[v[0]+1]) temp--;\\n                if(i!=0) ans[i] = ans[i-1]-temp;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        int m = queries.size();\\n        vector<int> nums(n, 0);\\n        vector<int> ans(m, 0);\\n        for(int i=0; i<m; i++){\\n            auto v = queries[i];\\n            int temp = 0;\\n            if(nums[v[0]]==0){\\n                nums[v[0]]=v[1];\\n                if(v[0] > 0 && nums[v[0]-1]==nums[v[0]]) temp++;\\n                if(v[0]!=n-1 && nums[v[0]]==nums[v[0]+1]) temp++;\\n                if(i!=0) ans[i]=ans[i-1] + temp;\\n            }\\n            else{\\n                if(v[0] > 0 && nums[v[0]-1]==nums[v[0]]) temp++;\\n                if(v[0]!=n-1 && nums[v[0]]==nums[v[0]+1]) temp++;\\n                nums[v[0]]=v[1];\\n                if(v[0] > 0 && nums[v[0]-1]==nums[v[0]]) temp--;\\n                if(v[0]!=n-1 && nums[v[0]]==nums[v[0]+1]) temp--;\\n                if(i!=0) ans[i] = ans[i-1]-temp;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503325,
                "title": "java-basic-approach-o-n-time-o-n-space",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        if(n==1) return new int[queries.length];\\n        \\n        int ans[]=new int[queries.length];  // for storing the answer of each query\\n        int color[]=new int[n];  \\n        int findPair=0;     // it will keep track of total Number of Pair(adject)\\n\\n        for(int i=0;i<queries.length;i++){\\n\\n                int index=queries[i][0];     // index which we need to color\\n                int assignColor=queries[i][1];  // given color for current index;\\n\\n// find the adjecent leftColor and rightColor of the current Index\\n                int leftColor=(index-1)>=0?color[index-1]:0;    \\n                int rightColor=(index+1)<n?color[index+1]:0;    \\n\\n// if current index color is forming pair to left or right ,then we need to decrease the findPair by 1 because we are going to \\n// color the current index with a new color\\n                if(color[index]!=0 && leftColor==color[index] ) findPair--;  // if current index color matches with left one\\n                if(color[index]!=0 && rightColor==color[index]) findPair--;  // if current index color matches with right one\\n\\n// color the current index with given new Color\\n                color[index]=assignColor;\\n\\n// Now check if, after assigning the new Color to the current index ,it is forming any new Pair,if it is  then increase the \\n// findPair by 1;\\n                if(leftColor!=0 && color[index]==leftColor) findPair++;  // if color matches with leftColor\\n                if(rightColor!=0 && color[index]==rightColor) findPair++; // if color matches with rightColor\\n\\n        // assign the calculated pair to the answer\\n                ans[i]=findPair;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        if(n==1) return new int[queries.length];\\n        \\n        int ans[]=new int[queries.length];  // for storing the answer of each query\\n        int color[]=new int[n];  \\n        int findPair=0;     // it will keep track of total Number of Pair(adject)\\n\\n        for(int i=0;i<queries.length;i++){\\n\\n                int index=queries[i][0];     // index which we need to color\\n                int assignColor=queries[i][1];  // given color for current index;\\n\\n// find the adjecent leftColor and rightColor of the current Index\\n                int leftColor=(index-1)>=0?color[index-1]:0;    \\n                int rightColor=(index+1)<n?color[index+1]:0;    \\n\\n// if current index color is forming pair to left or right ,then we need to decrease the findPair by 1 because we are going to \\n// color the current index with a new color\\n                if(color[index]!=0 && leftColor==color[index] ) findPair--;  // if current index color matches with left one\\n                if(color[index]!=0 && rightColor==color[index]) findPair--;  // if current index color matches with right one\\n\\n// color the current index with given new Color\\n                color[index]=assignColor;\\n\\n// Now check if, after assigning the new Color to the current index ,it is forming any new Pair,if it is  then increase the \\n// findPair by 1;\\n                if(leftColor!=0 && color[index]==leftColor) findPair++;  // if color matches with leftColor\\n                if(rightColor!=0 && color[index]==rightColor) findPair++; // if color matches with rightColor\\n\\n        // assign the calculated pair to the answer\\n                ans[i]=findPair;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503318,
                "title": "python-track-status-of-adjacent-values-after-changes",
                "content": "After the first hint I was able to solve it. Yeah! STRONG NO HIRE!\\nWas thinking about some DSU, anti-DSU and etc, but did not figure out that we do **1 change at a time**:\\n\\nThis allows us to figure out that when before we make a change to `nums[i]`\\nif `nums[i] == nums[i - 1]` but the new one will break this equation we `count -= 1`\\nif `nums[i] == nums[i + 1]` but the new one will break this equation we `count -= 1`\\nchange `nums[i]` to new color\\nif `nums[i] == nums[i - 1]` and the new one will make this equation valid we `count += 1`\\nif `nums[i] == nums[i + 1]` and the new one will make this equation valid we `count += 1`\\n\\nWe need to be careful with the case when old `nums[i]` == new `nums[i]` to avoid double counting.\\nTo avoid boundary checking I just do nothing here. With an array you\\'ll have to check the out of boundaries for +1/-1.\\n\\n```\\nclass Solution:\\n    def colorTheArray(self, N: int, queries: List[List[int]]) -> List[int]:\\n        count = 0\\n        nums = defaultdict(int)\\n        res = []\\n        for i,c in queries:\\n            count -= (nums[i - 1] == nums[i] != 0) + (0 != nums[i] == nums[i + 1])\\n            nums[i] = c\\n            count += (nums[i - 1] == nums[i] == c) + (c == nums[i] == nums[i + 1])\\n            res.append(count)\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def colorTheArray(self, N: int, queries: List[List[int]]) -> List[int]:\\n        count = 0\\n        nums = defaultdict(int)\\n        res = []\\n        for i,c in queries:\\n            count -= (nums[i - 1] == nums[i] != 0) + (0 != nums[i] == nums[i + 1])\\n            nums[i] = c\\n            count += (nums[i - 1] == nums[i] == c) + (c == nums[i] == nums[i + 1])\\n            res.append(count)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3501399,
                "title": "simple-logical-problem-cpp-solution",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        vector<int> colorTheArray(int n, vector<vector < int>> &queries)\\n        {\\n            vector<int> vec(n + 2, 0);//making size+2 array so that it reduce multiple conditional statements like for i+1 exists for i==n-1 or not i-1 exists for i==0 or i in between 0 to n etc.\\n\\t\\t\\t// consider addition of one extra zero at start and end so that element always has one element before and after it.\\n            int cnt = 0;\\n            vector<int> ans;\\n            for (int i = 0; i < queries.size(); i++)\\n            {\\n                int pos = queries[i][0] + 1;\\n                int col = queries[i][1];\\n                if (vec[pos] != 0)//for deletion of adjacent elements.\\n                {\\n                    if (vec[pos] == vec[pos + 1]) cnt--;\\n                    if (vec[pos] == vec[pos - 1]) cnt--;\\n                }\\n                vec[pos] = col;\\n                if (vec[pos] == vec[pos + 1]) cnt++;)//for addition of adjacent elements.\\n                if (vec[pos] == vec[pos - 1]) cnt++;\\n\\n                ans.push_back(cnt);\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        vector<int> colorTheArray(int n, vector<vector < int>> &queries)\\n        {\\n            vector<int> vec(n + 2, 0);//making size+2 array so that it reduce multiple conditional statements like for i+1 exists for i==n-1 or not i-1 exists for i==0 or i in between 0 to n etc.\\n\\t\\t\\t// consider addition of one extra zero at start and end so that element always has one element before and after it.\\n            int cnt = 0;\\n            vector<int> ans;\\n            for (int i = 0; i < queries.size(); i++)\\n            {\\n                int pos = queries[i][0] + 1;\\n                int col = queries[i][1];\\n                if (vec[pos] != 0)//for deletion of adjacent elements.\\n                {\\n                    if (vec[pos] == vec[pos + 1]) cnt--;\\n                    if (vec[pos] == vec[pos - 1]) cnt--;\\n                }\\n                vec[pos] = col;\\n                if (vec[pos] == vec[pos + 1]) cnt++;)//for addition of adjacent elements.\\n                if (vec[pos] == vec[pos - 1]) cnt++;\\n\\n                ans.push_back(cnt);\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3498115,
                "title": "c-best-solution-for-this-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nJust see the solution code ....inside the code ihave told told the concept to solve this question....This is a very good question to solve and this  type of question can be \\nasked in onlice assesmenet of the companies as well as many interview also...so\\nwe have to try to cover this type of question before the interview\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        \\n        int N = queries.size();\\n        vector<int> ans(n+2,0);\\n        vector<int> nums;\\n        int count = 0;\\n        for(int i=0;i<N;i++){\\n            int ind = queries[i][0] +1;\\n            int color = queries[i][1];\\n            //at first we have to cheek if the current index which i want to color now is already clored ot not \\n            // if it is already colored then we have to cheek if the previous color is same as he adjacent color or not \\n            //if the previous color is same as the adjacent color then we have to remove count factor for this \\n            //after removing the count factor for this we have to color the index and after coloring the current index \\n            //we have to cheek if the current color is same as the adjacent color or not \\n            //if the current color is same as the adjacent color then we have to add the count factor for this ind what we have \\n            //colored right now \\n            if(ans[ind]!=0 && ans[ind] == ans[ind+1])count--;\\n            if(ans[ind]!=0 && ans[ind] == ans[ind-1])count--;\\n            \\n            ans[ind] = color;//color the current index \\n            if(ans[ind] == ans[ind-1])count++;//cheek the factor that the adjacent color is same as the color of the current index what we have colored right now ...if same then  please add the count factor for this index \\n            if(ans[ind] == ans[ind+1])count++;// add the count factor for this index \\n            \\n            nums.push_back(count);//find in the current state we have to cheek how many count is there means\\n            //count no = number of index for which nums[j] == nums[j-1] or nums[j] == nums[j+1] occurs\\n        }\\n        return nums;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        \\n        int N = queries.size();\\n        vector<int> ans(n+2,0);\\n        vector<int> nums;\\n        int count = 0;\\n        for(int i=0;i<N;i++){\\n            int ind = queries[i][0] +1;\\n            int color = queries[i][1];\\n            //at first we have to cheek if the current index which i want to color now is already clored ot not \\n            // if it is already colored then we have to cheek if the previous color is same as he adjacent color or not \\n            //if the previous color is same as the adjacent color then we have to remove count factor for this \\n            //after removing the count factor for this we have to color the index and after coloring the current index \\n            //we have to cheek if the current color is same as the adjacent color or not \\n            //if the current color is same as the adjacent color then we have to add the count factor for this ind what we have \\n            //colored right now \\n            if(ans[ind]!=0 && ans[ind] == ans[ind+1])count--;\\n            if(ans[ind]!=0 && ans[ind] == ans[ind-1])count--;\\n            \\n            ans[ind] = color;//color the current index \\n            if(ans[ind] == ans[ind-1])count++;//cheek the factor that the adjacent color is same as the color of the current index what we have colored right now ...if same then  please add the count factor for this index \\n            if(ans[ind] == ans[ind+1])count++;// add the count factor for this index \\n            \\n            nums.push_back(count);//find in the current state we have to cheek how many count is there means\\n            //count no = number of index for which nums[j] == nums[j-1] or nums[j] == nums[j+1] occurs\\n        }\\n        return nums;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496614,
                "title": "c-maintain-result-at-each-query",
                "content": "# Complexity\\n- Time complexity:`O(n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:`O(n)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        \\n        // length of queries\\n        int qn = queries.size();\\n\\n        vector<int>nums(n,0); // nums which stores colors initially uncolored(means all values 0)\\n        vector<int>result;    // result (number of adjacent elements which has same color)\\n\\n        // running count of pairs which has same colors\\n        int pairs = 0;\\n\\n        for(int i = 0; i < qn; i++){\\n            \\n            int index = queries[i][0];        // current index where we update color\\n            int currentColor = queries[i][1]; // current color which will replace old color of index\\n\\n            // get previous & next adjacent of current index\\n            int prevAdjacent = 0 , nextAdjacent = 0;\\n\\n            // fetching adjacent values in range of 0 to n-1\\n            if(index - 1 >= 0) prevAdjacent = nums[index-1];\\n            if(index + 1 < n ) nextAdjacent = nums[index+1];\\n\\n\\n            int prevColor = nums[index]; // previous color of current index \\n            nums[index] = currentColor;  // assign current color to current index\\n\\n            // we use previous color for checking that previous color had pairs with its adjancent or not\\n            // if yes than we need to decrease the number of pairs bcoz current color will disturb the pairs\\n            // in below example [prevColor = 1] at index 1 and currentColor is 2 which replace 1\\n            // [[1 1 1]  |  [1 2 1]]  | 2 disturbing the pairs\\n            if(prevColor != 0 && prevColor == prevAdjacent) pairs--;\\n            if(prevColor != 0 && prevColor == nextAdjacent) pairs--;\\n\\n            // now check current color is forming pairs with adjancents or not\\n            if(currentColor == prevAdjacent) pairs++;\\n            if(currentColor == nextAdjacent) pairs++;\\n\\n            // update result after each query\\n            result.push_back(pairs);\\n\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Simulation",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        \\n        // length of queries\\n        int qn = queries.size();\\n\\n        vector<int>nums(n,0); // nums which stores colors initially uncolored(means all values 0)\\n        vector<int>result;    // result (number of adjacent elements which has same color)\\n\\n        // running count of pairs which has same colors\\n        int pairs = 0;\\n\\n        for(int i = 0; i < qn; i++){\\n            \\n            int index = queries[i][0];        // current index where we update color\\n            int currentColor = queries[i][1]; // current color which will replace old color of index\\n\\n            // get previous & next adjacent of current index\\n            int prevAdjacent = 0 , nextAdjacent = 0;\\n\\n            // fetching adjacent values in range of 0 to n-1\\n            if(index - 1 >= 0) prevAdjacent = nums[index-1];\\n            if(index + 1 < n ) nextAdjacent = nums[index+1];\\n\\n\\n            int prevColor = nums[index]; // previous color of current index \\n            nums[index] = currentColor;  // assign current color to current index\\n\\n            // we use previous color for checking that previous color had pairs with its adjancent or not\\n            // if yes than we need to decrease the number of pairs bcoz current color will disturb the pairs\\n            // in below example [prevColor = 1] at index 1 and currentColor is 2 which replace 1\\n            // [[1 1 1]  |  [1 2 1]]  | 2 disturbing the pairs\\n            if(prevColor != 0 && prevColor == prevAdjacent) pairs--;\\n            if(prevColor != 0 && prevColor == nextAdjacent) pairs--;\\n\\n            // now check current color is forming pairs with adjancents or not\\n            if(currentColor == prevAdjacent) pairs++;\\n            if(currentColor == nextAdjacent) pairs++;\\n\\n            // update result after each query\\n            result.push_back(pairs);\\n\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496608,
                "title": "map-of-pairs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        map<pair<int,int>,pair<int,int>>m;\\n        vector<int>color(n,0);\\n        for(int i=0;i<n-1;i++)\\n        {\\n            m[{i,i+1}]={color[i],color[i+1]};\\n        }\\n        int ans=0;\\n        vector<int>res;\\n        for(auto ele:queries)\\n        {\\n            int i=ele[0];\\n            int c=ele[1];\\n            \\n            //initial\\n            int initial=0;\\n            if(m.find({i-1,i})!=m.end())\\n            {\\n                if(m[{i-1,i}].first==m[{i-1,i}].second && m[{i-1,i}].first!=0)\\n                    initial++;\\n            }\\n            if(m.find({i,i+1})!=m.end())\\n            {\\n                if(m[{i,i+1}].first==m[{i,i+1}].second && m[{i,i+1}].first!=0)\\n                    initial++;\\n            }\\n            \\n            //after\\n            int after=0;\\n            color[i]=c;\\n            \\n            if(m.find({i-1,i})!=m.end())\\n            {\\n                m[{i-1,i}]={color[i-1],color[i]};\\n                if(m[{i-1,i}].first==m[{i-1,i}].second && m[{i-1,i}].first!=0)\\n                    after++;\\n            }\\n            if(m.find({i,i+1})!=m.end())\\n            {\\n                m[{i,i+1}]={color[i],color[i+1]};\\n                if(m[{i,i+1}].first==m[{i,i+1}].second && m[{i,i+1}].first!=0)\\n                    after++;\\n            }\\n            ans+=(after-initial);\\n            res.push_back(ans);\\n        }\\n        return res;\\n    }\\n}; \\n```",
                "solutionTags": [
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        map<pair<int,int>,pair<int,int>>m;\\n        vector<int>color(n,0);\\n        for(int i=0;i<n-1;i++)\\n        {\\n            m[{i,i+1}]={color[i],color[i+1]};\\n        }\\n        int ans=0;\\n        vector<int>res;\\n        for(auto ele:queries)\\n        {\\n            int i=ele[0];\\n            int c=ele[1];\\n            \\n            //initial\\n            int initial=0;\\n            if(m.find({i-1,i})!=m.end())\\n            {\\n                if(m[{i-1,i}].first==m[{i-1,i}].second && m[{i-1,i}].first!=0)\\n                    initial++;\\n            }\\n            if(m.find({i,i+1})!=m.end())\\n            {\\n                if(m[{i,i+1}].first==m[{i,i+1}].second && m[{i,i+1}].first!=0)\\n                    initial++;\\n            }\\n            \\n            //after\\n            int after=0;\\n            color[i]=c;\\n            \\n            if(m.find({i-1,i})!=m.end())\\n            {\\n                m[{i-1,i}]={color[i-1],color[i]};\\n                if(m[{i-1,i}].first==m[{i-1,i}].second && m[{i-1,i}].first!=0)\\n                    after++;\\n            }\\n            if(m.find({i,i+1})!=m.end())\\n            {\\n                m[{i,i+1}]={color[i],color[i+1]};\\n                if(m[{i,i+1}].first==m[{i,i+1}].second && m[{i,i+1}].first!=0)\\n                    after++;\\n            }\\n            ans+=(after-initial);\\n            res.push_back(ans);\\n        }\\n        return res;\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496137,
                "title": "o-n-c-solution-easy-approach",
                "content": "\\n\\n# Approach\\nMake a Color array of size N.\\nNow Traverse on the Queries and Check for Following:\\n- if index to be colored is 0, then we will check the index+1 cell and check whether it is previously making pair or not. If its a pair then we will decrease the answer and also it shouldn\\'t be equal to 0. After that we will update the color according to queries and again we will check for pair if its a pair then we will increase the ans by 1.\\n- if index to be colored is N-1, then we will check the index-1 cell and check whether it is previously making pair or not. If its a pair then we will decrease the answer and also it shouldn\\'t be equal to 0. After that we will update the color according to queries and again we will check for pair if its a pair then we will increase the ans by 1.\\n- if index to be colored is greater than 0 and smaller that N-1, then we will check the index+1 cell  and index-1 cell and check whether it is previously making pair or not. If its a pair then we will decrease the answer and also it shouldn\\'t be equal to 0. After that we will update the color according to queries and again we will check for pair if its a pair then we will increase the ans.\\nAt the End we will return the Resulting array.\\n\\n# Complexity\\n- Time complexity: **O(N)**\\n\\n- Space complexity: **O(N)+O(M)**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        int size=queries.size();\\n        vector<int> res(size,0),col(n,0);\\n        if(n==1) return res;\\n        int ans=0;\\n        for(int i=0;i<size;i++)\\n        {\\n            int ind=queries[i][0];\\n            int cl=queries[i][1];\\n            if(ind==0)\\n            {\\n                int prev=(col[ind]==col[ind+1]);\\n                if(col[ind]!=0) ans-=prev;\\n                col[ind]=cl;\\n                ans+=(col[ind]==col[ind+1]);\\n                res[i]=ans;\\n            }\\n            else if(ind==n-1)\\n            {\\n                int prev=(col[ind]==col[ind-1]);\\n                if(col[ind]!=0) ans-=prev;\\n                col[ind]=cl;\\n                ans+=(col[ind]==col[ind-1]);\\n                res[i]=ans;\\n            }\\n            else\\n            {\\n                int prev=(col[ind]==col[ind+1])+(col[ind]==col[ind-1]);\\n                if(col[ind]!=0) ans-=prev;\\n                col[ind]=cl;\\n                ans+=(col[ind]==col[ind+1])+(col[ind]==col[ind-1]);\\n                res[i]=ans;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n![7dr99c.jpg](https://assets.leetcode.com/users/images/76ab304e-d2c4-4795-b683-26d8c7d91332_1683449649.8341496.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        int size=queries.size();\\n        vector<int> res(size,0),col(n,0);\\n        if(n==1) return res;\\n        int ans=0;\\n        for(int i=0;i<size;i++)\\n        {\\n            int ind=queries[i][0];\\n            int cl=queries[i][1];\\n            if(ind==0)\\n            {\\n                int prev=(col[ind]==col[ind+1]);\\n                if(col[ind]!=0) ans-=prev;\\n                col[ind]=cl;\\n                ans+=(col[ind]==col[ind+1]);\\n                res[i]=ans;\\n            }\\n            else if(ind==n-1)\\n            {\\n                int prev=(col[ind]==col[ind-1]);\\n                if(col[ind]!=0) ans-=prev;\\n                col[ind]=cl;\\n                ans+=(col[ind]==col[ind-1]);\\n                res[i]=ans;\\n            }\\n            else\\n            {\\n                int prev=(col[ind]==col[ind+1])+(col[ind]==col[ind-1]);\\n                if(col[ind]!=0) ans-=prev;\\n                col[ind]=cl;\\n                ans+=(col[ind]==col[ind+1])+(col[ind]==col[ind-1]);\\n                res[i]=ans;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495666,
                "title": "simple-counting-c-intuition",
                "content": "# Intuition\\nCreate the nums array and track the count of adjacent numbers that are same\\n\\nApproach\\nCreate the array nums\\nFor each query first check if the values at index - 1 or index + 1 are the same as nums[index]. If any of them are equal, decrement the counter\\nUpdate the value of nums[index]\\nNow check if values at index - 1 or index + 1 are the same as nums[index]. If any of them are equal, increment the counter\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) \\n    {\\n      int count=0;\\n      vector<int> res,nums(n+2,0);\\n      for (auto& q : queries) \\n      {\\n        int i = q[0];\\n        int color = q[1];\\n        // Check if element have same color then decrement count\\n        if(i!=0 and nums[i]==nums[i-1] and nums[i]!=0)count--;\\n        if(i!=n-1 and nums[i]!=0 and nums[i]==nums[i+1])count--;\\n        nums[i]=color;\\n        // Check if element have same color then increment count\\n        if(i!=0 and nums[i]==nums[i-1] and nums[i]!=0)count++;\\n        if(i!=n-1 and nums[i]!=0 and nums[i]==nums[i+1])count++;\\n        res.push_back(count);\\n      }\\n    return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) \\n    {\\n      int count=0;\\n      vector<int> res,nums(n+2,0);\\n      for (auto& q : queries) \\n      {\\n        int i = q[0];\\n        int color = q[1];\\n        // Check if element have same color then decrement count\\n        if(i!=0 and nums[i]==nums[i-1] and nums[i]!=0)count--;\\n        if(i!=n-1 and nums[i]!=0 and nums[i]==nums[i+1])count--;\\n        nums[i]=color;\\n        // Check if element have same color then increment count\\n        if(i!=0 and nums[i]==nums[i-1] and nums[i]!=0)count++;\\n        if(i!=n-1 and nums[i]!=0 and nums[i]==nums[i+1])count++;\\n        res.push_back(count);\\n      }\\n    return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495601,
                "title": "c-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int vis[100005];\\n    vector<int> colorTheArray(int n, vector<vector<int>>& q) {\\n        int c=0;\\n        vector<int>ans;\\n        for(int i=0; i<q.size(); i++) {\\n            int x=q[i][0];\\n            int y=q[i][1];\\n            \\n            if(x==0) {\\n                if(vis[x] && vis[x+1] && vis[x]==vis[x+1]) c--;\\n                vis[x]=y;\\n                if(vis[x+1] && vis[x]==vis[x+1]) c++;     \\n            }\\n            else if(x==n-1) {\\n                if(vis[x] && vis[x-1] && vis[x-1]==vis[x]) c--;\\n                 vis[x]=y;\\n                if(vis[x-1] && vis[x-1]==vis[x]) c++; \\n            }\\n            else {\\n                if(vis[x] && vis[x+1] && vis[x]==vis[x+1]) c--;\\n                if(vis[x] && vis[x-1] && vis[x-1]==vis[x]) c--;\\n                vis[x]=y;\\n                if(vis[x+1] && vis[x]==vis[x+1]) c++;\\n                if(vis[x-1] && vis[x-1]==vis[x]) c++; \\n            }\\n            ans.push_back(c);\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int vis[100005];\\n    vector<int> colorTheArray(int n, vector<vector<int>>& q) {\\n        int c=0;\\n        vector<int>ans;\\n        for(int i=0; i<q.size(); i++) {\\n            int x=q[i][0];\\n            int y=q[i][1];\\n            \\n            if(x==0) {\\n                if(vis[x] && vis[x+1] && vis[x]==vis[x+1]) c--;\\n                vis[x]=y;\\n                if(vis[x+1] && vis[x]==vis[x+1]) c++;     \\n            }\\n            else if(x==n-1) {\\n                if(vis[x] && vis[x-1] && vis[x-1]==vis[x]) c--;\\n                 vis[x]=y;\\n                if(vis[x-1] && vis[x-1]==vis[x]) c++; \\n            }\\n            else {\\n                if(vis[x] && vis[x+1] && vis[x]==vis[x+1]) c--;\\n                if(vis[x] && vis[x-1] && vis[x-1]==vis[x]) c--;\\n                vis[x]=y;\\n                if(vis[x+1] && vis[x]==vis[x+1]) c++;\\n                if(vis[x-1] && vis[x-1]==vis[x]) c++; \\n            }\\n            ans.push_back(c);\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495586,
                "title": "easy-counting-implementation-approach",
                "content": "We Will keep track of adjacent count of same element for the coming query index.\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> ans,nums(n,0);\\n        int cnt=0;\\n        for(auto it:queries){\\n            int i=it[0];\\n            int color=it[1];\\n            if(nums[i] and i-1>=0 and nums[i-1]==nums[i]){\\n                cnt--;\\n            }\\n            if(nums[i] and i+1<n and nums[i+1]==nums[i]){\\n                cnt--;\\n            }\\n            nums[i]=color;\\n            if(i-1>=0 and nums[i-1]==nums[i]){\\n                cnt++;\\n            }\\n            if(i+1<n and nums[i+1]==nums[i]){\\n                cnt++;\\n            }\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> ans,nums(n,0);\\n        int cnt=0;\\n        for(auto it:queries){\\n            int i=it[0];\\n            int color=it[1];\\n            if(nums[i] and i-1>=0 and nums[i-1]==nums[i]){\\n                cnt--;\\n            }\\n            if(nums[i] and i+1<n and nums[i+1]==nums[i]){\\n                cnt--;\\n            }\\n            nums[i]=color;\\n            if(i-1>=0 and nums[i-1]==nums[i]){\\n                cnt++;\\n            }\\n            if(i+1<n and nums[i+1]==nums[i]){\\n                cnt++;\\n            }\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495461,
                "title": "c-counting-with-simulation",
                "content": "**Algorithm :**\\n\\n1. Extract the color and index of the current index from the query.\\n2. Check if the current index has an existing color. If it does, it updates the map of sets accordingly.\\n3. Check if the adjacent nodes have the same color as the current node in the map of sets. If they do, it decrements ans.\\n4. Update the color of the current index and the map of sets.\\n5. Check if the adjacent index have a same color as the new current index color in the map of sets. If they do, it increments ans.\\n6. Append the current value of ans to the result vector v.\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        map<int,set<int>> mp;\\n        int ans = 0;\\n        vector<int> v;\\n        vector<int> nums(n,0);\\n        for(int i = 0;i<queries.size();i++){\\n            int color = queries[i][1];\\n            int index = queries[i][0];\\n            if(nums[index] != 0){\\n               if(mp[nums[index]].find(index - 1) != mp[nums[index]].end()) ans--;\\n               if(mp[nums[index]].find(index + 1) != mp[nums[index]].end()) ans--;\\n               mp[nums[index]].erase(index);\\n            }\\n            if(mp[color].find(index - 1) != mp[color].end()) ans++;\\n            if(mp[color].find(index + 1) != mp[color].end()) ans++;\\n            v.push_back(ans); nums[index] = color; mp[color].insert(index);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        map<int,set<int>> mp;\\n        int ans = 0;\\n        vector<int> v;\\n        vector<int> nums(n,0);\\n        for(int i = 0;i<queries.size();i++){\\n            int color = queries[i][1];\\n            int index = queries[i][0];\\n            if(nums[index] != 0){\\n               if(mp[nums[index]].find(index - 1) != mp[nums[index]].end()) ans--;\\n               if(mp[nums[index]].find(index + 1) != mp[nums[index]].end()) ans--;\\n               mp[nums[index]].erase(index);\\n            }\\n            if(mp[color].find(index - 1) != mp[color].end()) ans++;\\n            if(mp[color].find(index + 1) != mp[color].end()) ans++;\\n            v.push_back(ans); nums[index] = color; mp[color].insert(index);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495388,
                "title": "simple-and-easy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasic thing is when color is changed then we only need to focus on neighbors not on others. If the location for which we need to change color matches with neighbors then we need to reduce value and if the changed color matches with neighbors then we need to increase value and add to the previous calculated matches. \\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n1, vector<vector<int>>& que) {\\n        int n=que.size();\\n        int val=0,ad=0;\\n\\n        vector<int>nums(1000001,0);vector<int>ans(n,0);\\n        for(int i=0;i<que.size();i++){\\n            int temp=que[i][0];\\n            val=0;\\n            if(nums[temp]!=0){\\n                if((temp-1)>=0 and nums[temp]==nums[temp-1])\\n                    val+=1;\\n                if(nums[temp]==nums[temp+1])\\n                    val+=1;\\n            }\\n            nums[temp]=que[i][1];\\n            ad=0;\\n            if((temp-1)>=0 and nums[temp]==nums[temp-1])\\n                ad+=1;\\n            if(nums[temp]==nums[temp+1])\\n                ad+=1;\\n            if(i==0)\\n                ans[i]=ad;\\n            else\\n                ans[i]=ans[i-1]+ad-val;\\n                \\n        }\\n        // for(int x:nums)\\n        //     cout <<x<<\",\";\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n1, vector<vector<int>>& que) {\\n        int n=que.size();\\n        int val=0,ad=0;\\n\\n        vector<int>nums(1000001,0);vector<int>ans(n,0);\\n        for(int i=0;i<que.size();i++){\\n            int temp=que[i][0];\\n            val=0;\\n            if(nums[temp]!=0){\\n                if((temp-1)>=0 and nums[temp]==nums[temp-1])\\n                    val+=1;\\n                if(nums[temp]==nums[temp+1])\\n                    val+=1;\\n            }\\n            nums[temp]=que[i][1];\\n            ad=0;\\n            if((temp-1)>=0 and nums[temp]==nums[temp-1])\\n                ad+=1;\\n            if(nums[temp]==nums[temp+1])\\n                ad+=1;\\n            if(i==0)\\n                ans[i]=ad;\\n            else\\n                ans[i]=ans[i-1]+ad-val;\\n                \\n        }\\n        // for(int x:nums)\\n        //     cout <<x<<\",\";\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3495365,
                "title": "simple-c-solution-linear-time",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- nums is a vector of size n to store the color changes initiated with all zeros\\n- initially total number (t) of adjacent elements with the same color is 0 \\n- Now iterate through the queries, idx has index in query and val has value to which it has to be changed\\n- if (idx-1 is in range )and (nu[idx - 1] is not zero) and (element present  at index is not equal to element at index -1) and (element at index -1 is equal to val) then we got a new pair of adjacent elements with the same color so increment total count t by 1\\n-  if (idx-1 is in range )and (nu[idx - 1] is not zero) and (element present  at index is  equal to element at index -1) and (element at index -1 is not equal to val) then we loose  a  pair of adjacent elements with the  same color so decrement  total count t by 1\\n- do the same for idx+1\\n- push t in ans and finally change the index in nums with val i.e. make change as per the query\\n- Thank You !!\\n\\n\\n# Complexity\\n- Time complexity: O(q.size())\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n+queries.size())\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n const static auto fast = []\\n{\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n    return 0;\\n}();\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n         vector<int>nums(n,0);\\n        vector<int>ans;\\n        int t=0;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int idx=queries[i][0],val=queries[i][1];\\n            if(idx-1>=0 && nums[idx-1]!=0 && nums[idx-1]!=nums[idx] && nums[idx-1]==val)t++;\\n            else if(idx-1>=0 && nums[idx-1]!=0 && nums[idx-1]==nums[idx] && nums[idx-1]!=val)t--;\\n            if(idx+1<n && nums[idx+1]!=0 && nums[idx+1]!=nums[idx] && nums[idx+1]==val)t++;\\n            else if(idx+1<n && nums[idx+1]!=0 && nums[idx+1]==nums[idx] && nums[idx+1]!=val)t--;\\n            ans.push_back(t);\\n            nums[idx]=val;    \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n const static auto fast = []\\n{\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n    return 0;\\n}();\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n         vector<int>nums(n,0);\\n        vector<int>ans;\\n        int t=0;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int idx=queries[i][0],val=queries[i][1];\\n            if(idx-1>=0 && nums[idx-1]!=0 && nums[idx-1]!=nums[idx] && nums[idx-1]==val)t++;\\n            else if(idx-1>=0 && nums[idx-1]!=0 && nums[idx-1]==nums[idx] && nums[idx-1]!=val)t--;\\n            if(idx+1<n && nums[idx+1]!=0 && nums[idx+1]!=nums[idx] && nums[idx+1]==val)t++;\\n            else if(idx+1<n && nums[idx+1]!=0 && nums[idx+1]==nums[idx] && nums[idx+1]!=val)t--;\\n            ans.push_back(t);\\n            nums[idx]=val;    \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3495159,
                "title": "c-multiple-if",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$ \\n\\n- Space complexity: $$O(n)$$ \\n\\n# Code\\n```\\npublic class Solution \\n{\\n    public int[] ColorTheArray(int n, int[][] queries) \\n    {\\n        int[] nums = new int[n];\\n        int[] answer = new int[queries.Length];\\n        int currAdjacent = 0;\\n\\n        for (int i = 0; i < queries.Length; i++)\\n        {\\n            int index = queries[i][0];\\n            int color = queries[i][1];\\n\\n            int prevColor = nums[index];\\n            nums[index] = color;\\n\\n            if (index > 0 && nums[index - 1] == prevColor && prevColor != 0)\\n                currAdjacent--;\\n            if (index < n - 1 && nums[index + 1] == prevColor && prevColor != 0)\\n                currAdjacent--;\\n            if (index > 0 && nums[index - 1] == color && color != 0)\\n                currAdjacent++;\\n            if (index < n - 1 && nums[index + 1] == color && color != 0)\\n                currAdjacent++;\\n\\n            answer[i] = currAdjacent;\\n        }\\n\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int[] ColorTheArray(int n, int[][] queries) \\n    {\\n        int[] nums = new int[n];\\n        int[] answer = new int[queries.Length];\\n        int currAdjacent = 0;\\n\\n        for (int i = 0; i < queries.Length; i++)\\n        {\\n            int index = queries[i][0];\\n            int color = queries[i][1];\\n\\n            int prevColor = nums[index];\\n            nums[index] = color;\\n\\n            if (index > 0 && nums[index - 1] == prevColor && prevColor != 0)\\n                currAdjacent--;\\n            if (index < n - 1 && nums[index + 1] == prevColor && prevColor != 0)\\n                currAdjacent--;\\n            if (index > 0 && nums[index - 1] == color && color != 0)\\n                currAdjacent++;\\n            if (index < n - 1 && nums[index + 1] == color && color != 0)\\n                currAdjacent++;\\n\\n            answer[i] = currAdjacent;\\n        }\\n\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495096,
                "title": "easy-counting-based-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to check adjacent element and maintain a count of pair where adjacent color are same\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialise array as 0 of size n, array of ans and a counter c.\\n2. for each query, we will check if(i>0) then check if current and preivious color are same then c--, if(i<n-1) then check if current and next color is same then c--.\\n3. change color of arr[ind] with new color, and then check if(i>0) the check current and previous element is same then c++ and if(i<n-1) then check if current and next element is same then c++\\n4. Push c in ans at end of query\\n\\n# Complexity\\n- Time complexity:(O(m)) where m is number of queries\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: max(n,m) where n is size of array and m is number of queriescount\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> arr(n,0);\\n        vector<int> ans;\\n        int c=0;\\n       for(auto x:queries)\\n       {\\n           int ind=x[0];\\n           int co=x[1];\\n           if(ind>0 )\\n           {\\n               if((arr[ind]==arr[ind-1] && arr[ind]>0 ))\\n               c--;\\n           }\\n           if(ind<n-1 )\\n           {\\n               if(arr[ind]==arr[ind+1] && arr[ind]>0)\\n               c--;\\n           }\\n           arr[ind]=co;\\n           if(ind>0 )\\n           {\\n               if((arr[ind]==arr[ind-1] && arr[ind]>0 ))\\n               c++;\\n               \\n           }\\n           if(ind<n-1 )\\n           {\\n               if(arr[ind]==arr[ind+1] && arr[ind]>0)\\n                 c++;\\n           }\\n           ans.push_back(c);\\n       }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Simulation",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> arr(n,0);\\n        vector<int> ans;\\n        int c=0;\\n       for(auto x:queries)\\n       {\\n           int ind=x[0];\\n           int co=x[1];\\n           if(ind>0 )\\n           {\\n               if((arr[ind]==arr[ind-1] && arr[ind]>0 ))\\n               c--;\\n           }\\n           if(ind<n-1 )\\n           {\\n               if(arr[ind]==arr[ind+1] && arr[ind]>0)\\n               c--;\\n           }\\n           arr[ind]=co;\\n           if(ind>0 )\\n           {\\n               if((arr[ind]==arr[ind-1] && arr[ind]>0 ))\\n               c++;\\n               \\n           }\\n           if(ind<n-1 )\\n           {\\n               if(arr[ind]==arr[ind+1] && arr[ind]>0)\\n                 c++;\\n           }\\n           ans.push_back(c);\\n       }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495001,
                "title": "easy-java-solution-100-beat",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        int c = 0;\\n        int[] a = new int[n];\\n        int[] ans = new int[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            int p = queries[i][0];\\n            int  m = queries[i][1];\\n            c = update_color(c, a, p, false);\\n            a[p] = m;\\n            c = update_color(c, a, p, true);\\n            ans[i] = c;\\n        }\\n        \\n        return ans;\\n    }\\n    public int update_color(int c, int[] a, int p, boolean inc) {\\n        if (p > 0 && a[p - 1] == a[p] && a[p - 1] != 0) {\\n            c += inc ? 1 : -1;\\n        }\\n        if (p < a.length - 1 && a[p + 1] == a[p] && a[p + 1] != 0) {\\n            c += inc ? 1 : -1;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        int c = 0;\\n        int[] a = new int[n];\\n        int[] ans = new int[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            int p = queries[i][0];\\n            int  m = queries[i][1];\\n            c = update_color(c, a, p, false);\\n            a[p] = m;\\n            c = update_color(c, a, p, true);\\n            ans[i] = c;\\n        }\\n        \\n        return ans;\\n    }\\n    public int update_color(int c, int[] a, int p, boolean inc) {\\n        if (p > 0 && a[p - 1] == a[p] && a[p - 1] != 0) {\\n            c += inc ? 1 : -1;\\n        }\\n        if (p < a.length - 1 && a[p + 1] == a[p] && a[p + 1] != 0) {\\n            c += inc ? 1 : -1;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494928,
                "title": "explaining-like-you-are-five-years-old",
                "content": "# Intuition\\nYou just need to check previous color and next color and modify number of current adjacent element with same color\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n```\\n1. Simulate the change in color on index\\n2. Note down the current color on index\\n    a. check index-1 color\\n        if index-1 color is same to current color that means the number of adjacent elements with same color will be reduced by one\\n        if index-1 color is same to new color that means the number of adjacent elements with same color will be increased by one\\n    b. check index+1 color\\n        if index+1 color is same to current color that means the number of adjacent elements with same color will be reduced by one\\n        if index+1 color is same to new color that means the number of adjacent elements with same color will be increased by one\\n3. Update the new color to that index\\n        \\n```\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n        \\n        \\n        elements = [0] * n # This will simulate the problem\\n        \\n        result = 0  # keeps record of current adjacent element with same color\\n        \\n        array = [] # This array will be our output\\n        \\n        # check function takes \\n            # number of current adjacent element with same color\\n            # earlier color on index we about to change\\n            # index to check = comp_index\\n            # index which will have color change\\n            # color on new index\\n            \\n        def check(result, earlier_color, comp_index, index, color): \\n            \\n            # if the comp_index is in bounds\\n            if 0 <= comp_index < n :\\n                \\n                # check if colored and comp_index has same earlier_color if yes that means the number of adjacent element with same color will be reduced by 1\\n                if earlier_color and elements[comp_index] == earlier_color:\\n                    result-=1\\n                # check if colored and comp_index has same color if yes that means the number of adjacent elements with same color will increase by 1\\n                if color and color == elements[comp_index]:\\n                    result +=1\\n                    \\n            return result\\n            \\n        \\n        for index, color in queries:\\n            earlier_color = elements[index]\\n            # check for previous element\\n            result = check(result, earlier_color, index - 1, index, color)\\n            # check for next element\\n            result = check(result, earlier_color, index + 1, index, color)\\n            \\n            elements[index] = color\\n            \\n            array.append(result)\\n            \\n        return array\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n1. Simulate the change in color on index\\n2. Note down the current color on index\\n    a. check index-1 color\\n        if index-1 color is same to current color that means the number of adjacent elements with same color will be reduced by one\\n        if index-1 color is same to new color that means the number of adjacent elements with same color will be increased by one\\n    b. check index+1 color\\n        if index+1 color is same to current color that means the number of adjacent elements with same color will be reduced by one\\n        if index+1 color is same to new color that means the number of adjacent elements with same color will be increased by one\\n3. Update the new color to that index\\n        \\n```\n```\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n        \\n        \\n        elements = [0] * n # This will simulate the problem\\n        \\n        result = 0  # keeps record of current adjacent element with same color\\n        \\n        array = [] # This array will be our output\\n        \\n        # check function takes \\n            # number of current adjacent element with same color\\n            # earlier color on index we about to change\\n            # index to check = comp_index\\n            # index which will have color change\\n            # color on new index\\n            \\n        def check(result, earlier_color, comp_index, index, color): \\n            \\n            # if the comp_index is in bounds\\n            if 0 <= comp_index < n :\\n                \\n                # check if colored and comp_index has same earlier_color if yes that means the number of adjacent element with same color will be reduced by 1\\n                if earlier_color and elements[comp_index] == earlier_color:\\n                    result-=1\\n                # check if colored and comp_index has same color if yes that means the number of adjacent elements with same color will increase by 1\\n                if color and color == elements[comp_index]:\\n                    result +=1\\n                    \\n            return result\\n            \\n        \\n        for index, color in queries:\\n            earlier_color = elements[index]\\n            # check for previous element\\n            result = check(result, earlier_color, index - 1, index, color)\\n            # check for next element\\n            result = check(result, earlier_color, index + 1, index, color)\\n            \\n            elements[index] = color\\n            \\n            array.append(result)\\n            \\n        return array\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494926,
                "title": "simple-c-solution-easy-maintainance",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> vals(n, 0), res;\\n        int ans = 0;\\n        for(int i = 0; i<queries.size(); i++){\\n            auto v = queries[i];\\n            int idx = v[0], val = v[1];\\n            if(idx-1>=0 and val == vals[idx-1]) ans++;\\n            if(idx+1<n and val == vals[idx+1]) ans++;\\n            if(idx-1>=0 and vals[idx] == vals[idx-1] and vals[idx] != 0) ans--;\\n            if(idx+1<n and vals[idx] == vals[idx+1] and vals[idx] != 0) ans--;\\n            vals[idx] = val;\\n            res.push_back(ans);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> vals(n, 0), res;\\n        int ans = 0;\\n        for(int i = 0; i<queries.size(); i++){\\n            auto v = queries[i];\\n            int idx = v[0], val = v[1];\\n            if(idx-1>=0 and val == vals[idx-1]) ans++;\\n            if(idx+1<n and val == vals[idx+1]) ans++;\\n            if(idx-1>=0 and vals[idx] == vals[idx-1] and vals[idx] != 0) ans--;\\n            if(idx+1<n and vals[idx] == vals[idx+1] and vals[idx] != 0) ans--;\\n            vals[idx] = val;\\n            res.push_back(ans);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4080376,
                "title": "simple-2-step-approach-explained-in-comments",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> vec(n,0), ans;\\n        int adj = 0;\\n        for(auto it : queries)\\n        {\\n          int index = it[0];\\n          int color = it[1];\\n          \\n          //if the index is already colored\\n          if(vec[index]) \\n          { //decrement adj if current index is same colored as its left or right\\n           adj -= (index > 0 && vec[index-1] == vec[index]) ? 1 : 0;\\n           adj -= (index < n-1 && vec[index+1] == vec[index]) ? 1 : 0;\\n          }\\n\\n          vec[index] = color; //color the current index\\n\\n          //increment adj, if current index becomes same colored as its left or right\\n          adj += (index > 0 && vec[index-1] == color) ? 1 : 0;\\n          adj += (index < n-1 && vec[index+1] == color) ? 1 : 0;  \\n        ans.push_back(adj);\\n        }\\n     return ans;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> vec(n,0), ans;\\n        int adj = 0;\\n        for(auto it : queries)\\n        {\\n          int index = it[0];\\n          int color = it[1];\\n          \\n          //if the index is already colored\\n          if(vec[index]) \\n          { //decrement adj if current index is same colored as its left or right\\n           adj -= (index > 0 && vec[index-1] == vec[index]) ? 1 : 0;\\n           adj -= (index < n-1 && vec[index+1] == vec[index]) ? 1 : 0;\\n          }\\n\\n          vec[index] = color; //color the current index\\n\\n          //increment adj, if current index becomes same colored as its left or right\\n          adj += (index > 0 && vec[index-1] == color) ? 1 : 0;\\n          adj += (index < n-1 && vec[index+1] == color) ? 1 : 0;  \\n        ans.push_back(adj);\\n        }\\n     return ans;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930234,
                "title": "c-solution-using-just-count-variable-easy-peasy",
                "content": "# Intuition\\nWe just need to maintain the count of adjacent element.\\n\\n# Approach\\nChecking if previous and next index contains the same color that we are going to color, then we will increment the count and similarly decrement the count if the same colour was already present.\\n\\n# Complexity\\n- Time complexity:\\n $$O(n)$$ \\n\\n- Space complexity:\\n $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> nums(n, 0);\\n        int adjCnt = 0;\\n        vector<int> res(queries.size(), 0);\\n\\n        for(int i = 0; i < queries.size(); i++){\\n            int idx = queries[i][0], color = queries[i][1];\\n            if(idx - 1 >= 0 && nums[idx - 1] == color) adjCnt++;\\n            if(idx + 1 < n && nums[idx + 1] == color) adjCnt++;\\n            \\n            if(nums[idx] != 0){\\n                if(idx - 1 >= 0 && nums[idx - 1] == nums[idx]) adjCnt--;\\n                if(idx + 1 < n && nums[idx + 1] == nums[idx]) adjCnt--;\\n            }\\n            nums[idx] = color;\\n            res[i] = adjCnt;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> nums(n, 0);\\n        int adjCnt = 0;\\n        vector<int> res(queries.size(), 0);\\n\\n        for(int i = 0; i < queries.size(); i++){\\n            int idx = queries[i][0], color = queries[i][1];\\n            if(idx - 1 >= 0 && nums[idx - 1] == color) adjCnt++;\\n            if(idx + 1 < n && nums[idx + 1] == color) adjCnt++;\\n            \\n            if(nums[idx] != 0){\\n                if(idx - 1 >= 0 && nums[idx - 1] == nums[idx]) adjCnt--;\\n                if(idx + 1 < n && nums[idx + 1] == nums[idx]) adjCnt--;\\n            }\\n            nums[idx] = color;\\n            res[i] = adjCnt;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929381,
                "title": "c-simple-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries)\\n    {\\n        int m = queries.size();\\n        if(m==1){return {0};} \\n        vector<int> ans(m, 0);\\n        vector<int> clr(n, 0);\\n        int curr = 0;\\n        for(int i=0;i<m;i++)\\n        {\\n            int ind = queries[i][0];\\n            int newc = queries[i][1];\\n            int pm = 0;\\n            if(ind>0){if(newc==clr[ind-1]){pm--;}}\\n            if(ind<n-1){if(newc==clr[ind+1]){pm--;}}\\n            if(clr[ind]!=0)\\n            {\\n                if(ind>0){if(clr[ind]==clr[ind-1]){pm++;}}\\n                if(ind<n-1){if(clr[ind]==clr[ind+1]){pm++;}}\\n            }\\n            curr-=pm;\\n            ans[i]=curr;\\n            clr[queries[i][0]]=queries[i][1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries)\\n    {\\n        int m = queries.size();\\n        if(m==1){return {0};} \\n        vector<int> ans(m, 0);\\n        vector<int> clr(n, 0);\\n        int curr = 0;\\n        for(int i=0;i<m;i++)\\n        {\\n            int ind = queries[i][0];\\n            int newc = queries[i][1];\\n            int pm = 0;\\n            if(ind>0){if(newc==clr[ind-1]){pm--;}}\\n            if(ind<n-1){if(newc==clr[ind+1]){pm--;}}\\n            if(clr[ind]!=0)\\n            {\\n                if(ind>0){if(clr[ind]==clr[ind-1]){pm++;}}\\n                if(ind<n-1){if(clr[ind]==clr[ind+1]){pm++;}}\\n            }\\n            curr-=pm;\\n            ans[i]=curr;\\n            clr[queries[i][0]]=queries[i][1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903903,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n    vector<int> ans;\\n    vector<int> arr(n);\\n    int sameColors = 0;\\n\\n    for (const vector<int>& query : queries) {\\n      const int i = query[0];\\n      const int color = query[1];\\n      if (i + 1 < n) {\\n        if (arr[i + 1] > 0 && arr[i + 1] == arr[i])\\n          --sameColors;\\n        if (arr[i + 1] == color)\\n          ++sameColors;\\n      }\\n      if (i > 0) {\\n        if (arr[i - 1] > 0 && arr[i - 1] == arr[i])\\n          --sameColors;\\n        if (arr[i - 1] == color)\\n          ++sameColors;\\n      }\\n      arr[i] = color;\\n      ans.push_back(sameColors);\\n    }\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n    vector<int> ans;\\n    vector<int> arr(n);\\n    int sameColors = 0;\\n\\n    for (const vector<int>& query : queries) {\\n      const int i = query[0];\\n      const int color = query[1];\\n      if (i + 1 < n) {\\n        if (arr[i + 1] > 0 && arr[i + 1] == arr[i])\\n          --sameColors;\\n        if (arr[i + 1] == color)\\n          ++sameColors;\\n      }\\n      if (i > 0) {\\n        if (arr[i - 1] > 0 && arr[i - 1] == arr[i])\\n          --sameColors;\\n        if (arr[i - 1] == color)\\n          ++sameColors;\\n      }\\n      arr[i] = color;\\n      ans.push_back(sameColors);\\n    }\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3898463,
                "title": "c-easy-clean-code-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& q) {\\n        vector<int> v,a(n,0);\\n        int c=0;\\n        map<int,int> p;\\n        for(auto i : q)\\n        {     \\n              if(p[i[0]]>0)\\n              {\\n                if(i[0]-1>=0 && a[i[0]]==a[i[0]-1])\\n                c--;\\n                if(i[0]+1<n && a[i[0]]==a[i[0]+1])\\n                c--;\\n              }\\n\\n               a[i[0]]=i[1];\\n               p[i[0]]++;\\n               if(i[0]-1>=0 && i[1]==a[i[0]-1])\\n                c++;\\n               if(i[0]+1<n && i[1]==a[i[0]+1])\\n                c++;\\n               v.push_back(c);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& q) {\\n        vector<int> v,a(n,0);\\n        int c=0;\\n        map<int,int> p;\\n        for(auto i : q)\\n        {     \\n              if(p[i[0]]>0)\\n              {\\n                if(i[0]-1>=0 && a[i[0]]==a[i[0]-1])\\n                c--;\\n                if(i[0]+1<n && a[i[0]]==a[i[0]+1])\\n                c--;\\n              }\\n\\n               a[i[0]]=i[1];\\n               p[i[0]]++;\\n               if(i[0]-1>=0 && i[1]==a[i[0]-1])\\n                c++;\\n               if(i[0]+1<n && i[1]==a[i[0]+1])\\n                c++;\\n               v.push_back(c);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886278,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func colorTheArray(_ n: Int, _ q: [[Int]]) -> [Int] {\\n\\n        var n = Array(repeating: 0, count: n)\\n        var r = [Int]()\\n\\n        for q in q {\\n            r.append(r.last ?? 0)\\n\\n            if n[q[0]] != 0 {\\n                if q[0] > 0, n[q[0] - 1] == n[q[0]] { r[r.count - 1] -= 1 }\\n                if q[0] < n.count - 1, n[q[0]] == n[q[0] + 1] { r[r.count - 1] -= 1 }\\n            }\\n            \\n            n[q[0]] = q[1]\\n            \\n            if q[0] > 0, n[q[0] - 1] == n[q[0]] { r[r.count - 1] += 1 }\\n            if q[0] < n.count - 1, n[q[0]] == n[q[0] + 1] { r[r.count - 1] += 1 }\\n        }\\n\\n        return r\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func colorTheArray(_ n: Int, _ q: [[Int]]) -> [Int] {\\n\\n        var n = Array(repeating: 0, count: n)\\n        var r = [Int]()\\n\\n        for q in q {\\n            r.append(r.last ?? 0)\\n\\n            if n[q[0]] != 0 {\\n                if q[0] > 0, n[q[0] - 1] == n[q[0]] { r[r.count - 1] -= 1 }\\n                if q[0] < n.count - 1, n[q[0]] == n[q[0] + 1] { r[r.count - 1] -= 1 }\\n            }\\n            \\n            n[q[0]] = q[1]\\n            \\n            if q[0] > 0, n[q[0] - 1] == n[q[0]] { r[r.count - 1] += 1 }\\n            if q[0] < n.count - 1, n[q[0]] == n[q[0] + 1] { r[r.count - 1] += 1 }\\n        }\\n\\n        return r\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884459,
                "title": "my-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n      int a[]=new int[n];\\n      int len=queries.length;\\n      int res[]=new int[len];\\n      int count=0;\\n      for(int i=0;i<len;i++)\\n      {\\n          int ind=queries[i][0], color=queries[i][1];\\n          int prev = ind>0 ? a[ind-1] : 0;\\n          int next = ind>=n-1 ? 0 : a[ind+1];\\n          if(a[ind]!=0 && a[ind] == prev)\\n          {\\n              count--;\\n          }\\n          if(a[ind]!=0 && a[ind] == next)\\n          {\\n              count--;\\n          }\\n          a[ind]=color;\\n          if(a[ind] == prev)\\n          {\\n              count++;\\n          }\\n          if(a[ind] == next)\\n          {\\n              count++;\\n          }\\n          res[i]=count;\\n      }\\n      return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n      int a[]=new int[n];\\n      int len=queries.length;\\n      int res[]=new int[len];\\n      int count=0;\\n      for(int i=0;i<len;i++)\\n      {\\n          int ind=queries[i][0], color=queries[i][1];\\n          int prev = ind>0 ? a[ind-1] : 0;\\n          int next = ind>=n-1 ? 0 : a[ind+1];\\n          if(a[ind]!=0 && a[ind] == prev)\\n          {\\n              count--;\\n          }\\n          if(a[ind]!=0 && a[ind] == next)\\n          {\\n              count--;\\n          }\\n          a[ind]=color;\\n          if(a[ind] == prev)\\n          {\\n              count++;\\n          }\\n          if(a[ind] == next)\\n          {\\n              count++;\\n          }\\n          res[i]=count;\\n      }\\n      return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840996,
                "title": "c-simple-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int>v(n,0);\\n        int size=queries.size();\\n        vector<int>ans(size,0);\\n        if(n==1) return ans;\\n        int count=0;\\n        for(int i=0;i<size;i++){\\n            int j=queries[i][0];\\n            int clr=queries[i][1];\\n            // check if it is alreay colored or not\\n            if(v[j]!=0){\\n                if(j==0) {\\n                   if(v[0]==v[1]) count--;\\n                }    \\n                else if(j==n-1){\\n                  if(v[n-2]==v[n-1]) count--;\\n                }  \\n                else{\\n                    if(v[j+1]==v[j]) count--;\\n                    if(v[j-1]==v[j]) count--;\\n                }\\n            }\\n            v[j]=clr;\\n            // conditions for adjacent elements\\n                if(j==0) {\\n                    if(v[0]==v[1]) count++;\\n                }\\n                else if(j==n-1){\\n                    if(v[n-2]==v[n-1]) count++;\\n                }    \\n                else{\\n                    if(v[j+1]==v[j]) count++;\\n                    if(v[j-1]==v[j]) count++;\\n                }\\n            ans[i]=count;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int>v(n,0);\\n        int size=queries.size();\\n        vector<int>ans(size,0);\\n        if(n==1) return ans;\\n        int count=0;\\n        for(int i=0;i<size;i++){\\n            int j=queries[i][0];\\n            int clr=queries[i][1];\\n            // check if it is alreay colored or not\\n            if(v[j]!=0){\\n                if(j==0) {\\n                   if(v[0]==v[1]) count--;\\n                }    \\n                else if(j==n-1){\\n                  if(v[n-2]==v[n-1]) count--;\\n                }  \\n                else{\\n                    if(v[j+1]==v[j]) count--;\\n                    if(v[j-1]==v[j]) count--;\\n                }\\n            }\\n            v[j]=clr;\\n            // conditions for adjacent elements\\n                if(j==0) {\\n                    if(v[0]==v[1]) count++;\\n                }\\n                else if(j==n-1){\\n                    if(v[n-2]==v[n-1]) count++;\\n                }    \\n                else{\\n                    if(v[j+1]==v[j]) count++;\\n                    if(v[j-1]==v[j]) count++;\\n                }\\n            ans[i]=count;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808813,
                "title": "easy-to-understand-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] q) {\\n        if(n == 1){\\n            return new int[q.length];\\n        }\\n\\n        int[] ans = new int[q.length];\\n        int[] color = new int[n];\\n\\n        int cnt = 0;\\n\\n        for(int i = 0; i < q.length; i++){\\n            int ind = q[i][0];\\n            int assColor = q[i][1];\\n\\n            int leftColor = 0;\\n            int rytColor = 0;\\n\\n            if(ind - 1 >= 0){\\n                leftColor = color[ind - 1];\\n            }\\n            if(ind + 1 < n){\\n                rytColor = color[ind + 1];\\n            }\\n\\n            if(color[ind] != 0 && leftColor  == color[ind]){\\n                cnt--;\\n            }\\n            if(color[ind] != 0 && rytColor == color[ind]){\\n                cnt--;\\n            }\\n\\n            color[ind] = assColor;\\n\\n            if(color[ind] != 0 && leftColor  == color[ind]){\\n                cnt++;\\n            }\\n            if(color[ind] != 0 && rytColor == color[ind]){\\n                cnt++;\\n            }\\n\\n            ans[i] = cnt;\\n        }\\n\\n\\n        return ans;\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] q) {\\n        if(n == 1){\\n            return new int[q.length];\\n        }\\n\\n        int[] ans = new int[q.length];\\n        int[] color = new int[n];\\n\\n        int cnt = 0;\\n\\n        for(int i = 0; i < q.length; i++){\\n            int ind = q[i][0];\\n            int assColor = q[i][1];\\n\\n            int leftColor = 0;\\n            int rytColor = 0;\\n\\n            if(ind - 1 >= 0){\\n                leftColor = color[ind - 1];\\n            }\\n            if(ind + 1 < n){\\n                rytColor = color[ind + 1];\\n            }\\n\\n            if(color[ind] != 0 && leftColor  == color[ind]){\\n                cnt--;\\n            }\\n            if(color[ind] != 0 && rytColor == color[ind]){\\n                cnt--;\\n            }\\n\\n            color[ind] = assColor;\\n\\n            if(color[ind] != 0 && leftColor  == color[ind]){\\n                cnt++;\\n            }\\n            if(color[ind] != 0 && rytColor == color[ind]){\\n                cnt++;\\n            }\\n\\n            ans[i] = cnt;\\n        }\\n\\n\\n        return ans;\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3769748,
                "title": "segment-trees-unique-solution-different-approach",
                "content": "# Intuition\\nPerformed update and query operation in O(log n) using segment Tree\\n\\n# Approach\\nCompared mid and mid+1 while doing point update\\n\\n# Complexity\\n- Time complexity:\\no(QlogN)\\n\\n- Space complexity:\\nO(N)\\nNote: Reinitialize global variables to avoid unnecesary test case failure\\n# Code\\n```\\nconst int MAX=4e5+10;\\nvector<int> segTree;\\nvector<int> arr;\\nclass Solution {\\npublic:    \\n    void buildTree(int TN,int start,int end){\\n        if(start==end){\\n            arr[start]=0;\\n            segTree[TN]=0;\\n            return;\\n        }\\n        int mid=(start+end)/2;\\n        buildTree(2*TN,start,mid);\\n        buildTree(2*TN,mid+1,end);\\n    }\\n    void update(int TN,int start,int end,int idx,int val){\\n        if(start==end){\\n            arr[start]=val;\\n            segTree[TN]=0;\\n            return;\\n        }\\n        int mid=(start+end)/2;\\n        if(idx>mid){\\n            update(2*TN+1,mid+1,end,idx,val);\\n        }else{\\n            update(2*TN,start,mid,idx,val);\\n        }\\n        segTree[TN]=segTree[2*TN+1]+segTree[2*TN];\\n        if(arr[mid]!=0 && arr[mid]==arr[mid+1]){\\n            //cout<<mid<<\" \"<<mid+1<<endl;\\n            segTree[TN]+=1;\\n        }\\n    }\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        segTree=vector<int>(4*n,0);\\n        arr=vector<int>(n,0);\\n        buildTree(1,0,n-1);\\n        int q=queries.size();\\n        vector<int> ans(q);\\n        for(int i=0;i<q;i++){\\n            int idx=queries[i][0];int val=queries[i][1];\\n            //cout<<i<<endl;\\n            update(1,0,n-1,idx,val);\\n            ans[i]=segTree[1];\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nconst int MAX=4e5+10;\\nvector<int> segTree;\\nvector<int> arr;\\nclass Solution {\\npublic:    \\n    void buildTree(int TN,int start,int end){\\n        if(start==end){\\n            arr[start]=0;\\n            segTree[TN]=0;\\n            return;\\n        }\\n        int mid=(start+end)/2;\\n        buildTree(2*TN,start,mid);\\n        buildTree(2*TN,mid+1,end);\\n    }\\n    void update(int TN,int start,int end,int idx,int val){\\n        if(start==end){\\n            arr[start]=val;\\n            segTree[TN]=0;\\n            return;\\n        }\\n        int mid=(start+end)/2;\\n        if(idx>mid){\\n            update(2*TN+1,mid+1,end,idx,val);\\n        }else{\\n            update(2*TN,start,mid,idx,val);\\n        }\\n        segTree[TN]=segTree[2*TN+1]+segTree[2*TN];\\n        if(arr[mid]!=0 && arr[mid]==arr[mid+1]){\\n            //cout<<mid<<\" \"<<mid+1<<endl;\\n            segTree[TN]+=1;\\n        }\\n    }\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        segTree=vector<int>(4*n,0);\\n        arr=vector<int>(n,0);\\n        buildTree(1,0,n-1);\\n        int q=queries.size();\\n        vector<int> ans(q);\\n        for(int i=0;i<q;i++){\\n            int idx=queries[i][0];int val=queries[i][1];\\n            //cout<<i<<endl;\\n            update(1,0,n-1,idx,val);\\n            ans[i]=segTree[1];\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3769747,
                "title": "segment-trees-unique-solution-different-approach",
                "content": "# Intuition\\nPerformed update and query operation in O(log n) using segment Tree\\n\\n# Approach\\nCompared mid and mid+1 while doing point update\\n\\n# Complexity\\n- Time complexity:\\no(QlogN)\\n\\n- Space complexity:\\nO(N)\\nNote: Reinitialize global variables to avoid unnecesary test case failure\\n# Code\\n```\\nconst int MAX=4e5+10;\\nvector<int> segTree;\\nvector<int> arr;\\nclass Solution {\\npublic:    \\n    void buildTree(int TN,int start,int end){\\n        if(start==end){\\n            arr[start]=0;\\n            segTree[TN]=0;\\n            return;\\n        }\\n        int mid=(start+end)/2;\\n        buildTree(2*TN,start,mid);\\n        buildTree(2*TN,mid+1,end);\\n    }\\n    void update(int TN,int start,int end,int idx,int val){\\n        if(start==end){\\n            arr[start]=val;\\n            segTree[TN]=0;\\n            return;\\n        }\\n        int mid=(start+end)/2;\\n        if(idx>mid){\\n            update(2*TN+1,mid+1,end,idx,val);\\n        }else{\\n            update(2*TN,start,mid,idx,val);\\n        }\\n        segTree[TN]=segTree[2*TN+1]+segTree[2*TN];\\n        if(arr[mid]!=0 && arr[mid]==arr[mid+1]){\\n            //cout<<mid<<\" \"<<mid+1<<endl;\\n            segTree[TN]+=1;\\n        }\\n    }\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        segTree=vector<int>(4*n,0);\\n        arr=vector<int>(n,0);\\n        buildTree(1,0,n-1);\\n        int q=queries.size();\\n        vector<int> ans(q);\\n        for(int i=0;i<q;i++){\\n            int idx=queries[i][0];int val=queries[i][1];\\n            //cout<<i<<endl;\\n            update(1,0,n-1,idx,val);\\n            ans[i]=segTree[1];\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nconst int MAX=4e5+10;\\nvector<int> segTree;\\nvector<int> arr;\\nclass Solution {\\npublic:    \\n    void buildTree(int TN,int start,int end){\\n        if(start==end){\\n            arr[start]=0;\\n            segTree[TN]=0;\\n            return;\\n        }\\n        int mid=(start+end)/2;\\n        buildTree(2*TN,start,mid);\\n        buildTree(2*TN,mid+1,end);\\n    }\\n    void update(int TN,int start,int end,int idx,int val){\\n        if(start==end){\\n            arr[start]=val;\\n            segTree[TN]=0;\\n            return;\\n        }\\n        int mid=(start+end)/2;\\n        if(idx>mid){\\n            update(2*TN+1,mid+1,end,idx,val);\\n        }else{\\n            update(2*TN,start,mid,idx,val);\\n        }\\n        segTree[TN]=segTree[2*TN+1]+segTree[2*TN];\\n        if(arr[mid]!=0 && arr[mid]==arr[mid+1]){\\n            //cout<<mid<<\" \"<<mid+1<<endl;\\n            segTree[TN]+=1;\\n        }\\n    }\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        segTree=vector<int>(4*n,0);\\n        arr=vector<int>(n,0);\\n        buildTree(1,0,n-1);\\n        int q=queries.size();\\n        vector<int> ans(q);\\n        for(int i=0;i<q;i++){\\n            int idx=queries[i][0];int val=queries[i][1];\\n            //cout<<i<<endl;\\n            update(1,0,n-1,idx,val);\\n            ans[i]=segTree[1];\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3765648,
                "title": "as-simple-as-this",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        int q=queries.size();\\n        vector<int> ans(q,0);\\n        int curr=0,i;\\n        vector<int> mat(n,0);\\n        for(i=0;i<q;i++){\\n            int a=queries[i][0],b=queries[i][1];\\n            if(mat[a]==b){ ans[i]=curr;continue;}\\n            if(a-1>=0 && mat[a]!=0 && mat[a]==mat[a-1]) curr--; \\n            if(a+1<n && mat[a]!=0 && mat[a]==mat[a+1]) curr--;\\n            if(a-1>=0 && b==mat[a-1]) curr++;\\n            if(a+1<n && b==mat[a+1]) curr++;\\n            mat[a]=b;\\n            ans[i]=curr;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        int q=queries.size();\\n        vector<int> ans(q,0);\\n        int curr=0,i;\\n        vector<int> mat(n,0);\\n        for(i=0;i<q;i++){\\n            int a=queries[i][0],b=queries[i][1];\\n            if(mat[a]==b){ ans[i]=curr;continue;}\\n            if(a-1>=0 && mat[a]!=0 && mat[a]==mat[a-1]) curr--; \\n            if(a+1<n && mat[a]!=0 && mat[a]==mat[a+1]) curr--;\\n            if(a-1>=0 && b==mat[a-1]) curr++;\\n            if(a+1<n && b==mat[a+1]) curr++;\\n            mat[a]=b;\\n            ans[i]=curr;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3756437,
                "title": "the-easiest-and-the-most-elaborate-java-code",
                "content": "# Complexity\\n- Time complexity: O ( N )\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O ( N )\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] query) {\\n        int []a = new int [query.length];\\n        int []nums = new int[n];\\n        int answer=0;\\n        for (int i=0;i<query.length;i++)\\n        {\\n            int preadjacency=0;\\n            int curradjacency=0;\\n\\n            int index=query[i][0];\\n            int colornow= query[i][1];\\n            int colorpre=nums[index];\\n\\n            if (nums[index]!=0)\\n            {\\n                int left=0;\\n                int right=0;\\n                if (index-1>=0)\\n                left= (nums[index-1]==nums[index])? 1:0;\\n                if (index+1<nums.length)\\n                right= (nums[index+1]==nums[index])? 1:0;\\n\\n                preadjacency=left+right;\\n            }\\n            nums[index]=colornow;\\n            int l=0;\\n            int r=0;\\n            if (index-1>=0)\\n            l = (nums[index-1]==nums[index])? 1:0;\\n            if (index+1<nums.length)\\n            r= (nums[index+1]==nums[index])? 1:0;\\n            curradjacency=l+r;\\n\\n            answer+= curradjacency-preadjacency;\\n            a[i]=answer;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] query) {\\n        int []a = new int [query.length];\\n        int []nums = new int[n];\\n        int answer=0;\\n        for (int i=0;i<query.length;i++)\\n        {\\n            int preadjacency=0;\\n            int curradjacency=0;\\n\\n            int index=query[i][0];\\n            int colornow= query[i][1];\\n            int colorpre=nums[index];\\n\\n            if (nums[index]!=0)\\n            {\\n                int left=0;\\n                int right=0;\\n                if (index-1>=0)\\n                left= (nums[index-1]==nums[index])? 1:0;\\n                if (index+1<nums.length)\\n                right= (nums[index+1]==nums[index])? 1:0;\\n\\n                preadjacency=left+right;\\n            }\\n            nums[index]=colornow;\\n            int l=0;\\n            int r=0;\\n            if (index-1>=0)\\n            l = (nums[index-1]==nums[index])? 1:0;\\n            if (index+1<nums.length)\\n            r= (nums[index+1]==nums[index])? 1:0;\\n            curradjacency=l+r;\\n\\n            answer+= curradjacency-preadjacency;\\n            a[i]=answer;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3755916,
                "title": "straight-forward-c-solution-easy-code",
                "content": "\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> nums(n, 0), result;\\n        int c = 0;\\n    \\n        for (auto query : queries) {\\n            int index = query[0], color = query[1];\\n            int pre = (index > 0) ? nums[index - 1] : 0;\\n            int nex = (index < n-1) ? nums[index + 1] : 0;\\n    \\n            if (nums[index] && nums[index] == pre) c--;\\n            if (nums[index] && nums[index] == nex) c--;\\n            nums[index] = color;\\n            if (nums[index] == pre) c++;\\n            if (nums[index] == nex) c++;\\n    \\n            result.push_back(c);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> nums(n, 0), result;\\n        int c = 0;\\n    \\n        for (auto query : queries) {\\n            int index = query[0], color = query[1];\\n            int pre = (index > 0) ? nums[index - 1] : 0;\\n            int nex = (index < n-1) ? nums[index + 1] : 0;\\n    \\n            if (nums[index] && nums[index] == pre) c--;\\n            if (nums[index] && nums[index] == nex) c--;\\n            nums[index] = color;\\n            if (nums[index] == pre) c++;\\n            if (nums[index] == nex) c++;\\n    \\n            result.push_back(c);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3694959,
                "title": "c-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int[] ColorTheArray(int n, int[][] queries) {\\n        var arr = new int[n];\\n        var res = new int[queries.Length];\\n        var count = 0;\\n        for(var i = 0; i < queries.Length; i++){\\n            res[i] = count;\\n            var pre = arr[queries[i][0]];\\n            var cur = queries[i][1];\\n            arr[queries[i][0]] =  cur;\\n            var leftIndex = queries[i][0] - 1;\\n            var rightIndex = queries[i][0] + 1;\\n            if(pre == cur) continue;\\n            if(pre != 0 && leftIndex >= 0 && pre == arr[leftIndex])\\n                res[i]--;\\n            if(pre != 0 && rightIndex <= arr.Length - 1 && pre == arr[rightIndex])\\n                res[i]--;\\n            if(cur != 0  && leftIndex >= 0 && cur == arr[leftIndex])\\n                res[i]++;\\n            if(cur != 0 && rightIndex <= arr.Length - 1 && cur == arr[rightIndex])\\n                res[i]++;\\n            count = res[i];\\n        } \\n        return res;\\n    } \\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] ColorTheArray(int n, int[][] queries) {\\n        var arr = new int[n];\\n        var res = new int[queries.Length];\\n        var count = 0;\\n        for(var i = 0; i < queries.Length; i++){\\n            res[i] = count;\\n            var pre = arr[queries[i][0]];\\n            var cur = queries[i][1];\\n            arr[queries[i][0]] =  cur;\\n            var leftIndex = queries[i][0] - 1;\\n            var rightIndex = queries[i][0] + 1;\\n            if(pre == cur) continue;\\n            if(pre != 0 && leftIndex >= 0 && pre == arr[leftIndex])\\n                res[i]--;\\n            if(pre != 0 && rightIndex <= arr.Length - 1 && pre == arr[rightIndex])\\n                res[i]--;\\n            if(cur != 0  && leftIndex >= 0 && cur == arr[leftIndex])\\n                res[i]++;\\n            if(cur != 0 && rightIndex <= arr.Length - 1 && cur == arr[rightIndex])\\n                res[i]++;\\n            count = res[i];\\n        } \\n        return res;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3671721,
                "title": "c-query-and-count",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        int c=0;\\n        vector<int> v(n),ans;\\n        for(auto &i:queries){\\n            if(v[i[0]] && i[0]>0 && v[i[0]]==v[i[0]-1])--c;\\n            if(v[i[0]] && i[0]<n-1 && v[i[0]]==v[i[0]+1])--c;\\n            v[i[0]]=i[1];\\n            if(i[0]>0 && v[i[0]]==v[i[0]-1])++c;\\n            if(i[0]<n-1 && v[i[0]]==v[i[0]+1])++c;\\n            ans.emplace_back(c);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        int c=0;\\n        vector<int> v(n),ans;\\n        for(auto &i:queries){\\n            if(v[i[0]] && i[0]>0 && v[i[0]]==v[i[0]-1])--c;\\n            if(v[i[0]] && i[0]<n-1 && v[i[0]]==v[i[0]+1])--c;\\n            v[i[0]]=i[1];\\n            if(i[0]>0 && v[i[0]]==v[i[0]-1])++c;\\n            if(i[0]<n-1 && v[i[0]]==v[i[0]+1])++c;\\n            ans.emplace_back(c);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667859,
                "title": "number-of-adjacent-elements-with-the-same-color-easy-approach-fast-simple",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) \\n    {\\n        vector<long long int>col(n,0);\\n        vector<int>ans;\\n        long long int t = 0;\\n        long long int idx = queries[0][0];\\n        long long int color = queries[0][1];\\n        col[idx] = color;\\n        ans.push_back(0);\\n        long long int x = 0;\\n\\n        for(long long int i = 1; i<queries.size(); i++)\\n        {\\n            long long int idx = queries[i][0];\\n            long long int color = queries[i][1];\\n            x = 0;\\n            if(col[idx]!=0 and idx!=n-1 and col[idx]==col[idx+1])\\n            {\\n                x++;\\n            }\\n            if(col[idx]!=0 and idx!=0 and col[idx]==col[idx-1])\\n            {\\n                x++;\\n            }\\n            //cout<<x<<endl;\\n            t = t-x;\\n            col[idx] = color;\\n\\n            x = 0;\\n            if(idx!=n-1 and col[idx]==col[idx+1])\\n            {\\n                x++;\\n            }\\n            if(idx!=0 and col[idx]==col[idx-1])\\n            {\\n                x++;\\n            }\\n            t = t+x;\\n            //cout<<x<<endl;\\n            ans.push_back(t);\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) \\n    {\\n        vector<long long int>col(n,0);\\n        vector<int>ans;\\n        long long int t = 0;\\n        long long int idx = queries[0][0];\\n        long long int color = queries[0][1];\\n        col[idx] = color;\\n        ans.push_back(0);\\n        long long int x = 0;\\n\\n        for(long long int i = 1; i<queries.size(); i++)\\n        {\\n            long long int idx = queries[i][0];\\n            long long int color = queries[i][1];\\n            x = 0;\\n            if(col[idx]!=0 and idx!=n-1 and col[idx]==col[idx+1])\\n            {\\n                x++;\\n            }\\n            if(col[idx]!=0 and idx!=0 and col[idx]==col[idx-1])\\n            {\\n                x++;\\n            }\\n            //cout<<x<<endl;\\n            t = t-x;\\n            col[idx] = color;\\n\\n            x = 0;\\n            if(idx!=n-1 and col[idx]==col[idx+1])\\n            {\\n                x++;\\n            }\\n            if(idx!=0 and col[idx]==col[idx-1])\\n            {\\n                x++;\\n            }\\n            t = t+x;\\n            //cout<<x<<endl;\\n            ans.push_back(t);\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3641655,
                "title": "c-simple-observations-simple-implementation-starightforward-o-k-queries-size-1-k-4",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        vector<int>nums(n,0);\\n        int prev=0;\\n        int sz=queries.size();\\n        for(int x=0;x<sz;x++){\\n            int curr=0;\\n            int idx=queries[x][0];\\n            int colour=queries[x][1];\\n            int prevcolour=nums[idx];\\n            if(nums[idx]==colour){\\n                curr+=0;\\n                curr+=prev;\\n                ans.push_back(curr);\\n                prev=curr;\\n                nums[idx]=colour;\\n            }\\n            else{\\n                int sub=0;\\n         if((idx-1)>=0 and (idx)<=(n-1) and nums[idx]==nums[idx-1] and nums[idx]!=0)sub++;\\n         if((idx+1)<=(n-1) and idx>=0 and (nums[idx+1]==nums[idx]) and nums[idx]!=0)sub++;\\n        nums[idx]=colour;\\n        if((idx-1)>=0 and (idx)<=n-1 and nums[idx]==nums[idx-1] and nums[idx]!=0)curr++;\\n         if(idx>=0 and (idx+1)<=(n-1) and nums[idx]==nums[idx+1] and nums[idx]!=0)curr++;\\n                curr+=prev;\\n                curr-=sub;\\n                ans.push_back(curr);\\n                prev=curr;\\n            }\\n        }\\n        for(auto x:ans)cout<<x<<\" \";\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        vector<int>nums(n,0);\\n        int prev=0;\\n        int sz=queries.size();\\n        for(int x=0;x<sz;x++){\\n            int curr=0;\\n            int idx=queries[x][0];\\n            int colour=queries[x][1];\\n            int prevcolour=nums[idx];\\n            if(nums[idx]==colour){\\n                curr+=0;\\n                curr+=prev;\\n                ans.push_back(curr);\\n                prev=curr;\\n                nums[idx]=colour;\\n            }\\n            else{\\n                int sub=0;\\n         if((idx-1)>=0 and (idx)<=(n-1) and nums[idx]==nums[idx-1] and nums[idx]!=0)sub++;\\n         if((idx+1)<=(n-1) and idx>=0 and (nums[idx+1]==nums[idx]) and nums[idx]!=0)sub++;\\n        nums[idx]=colour;\\n        if((idx-1)>=0 and (idx)<=n-1 and nums[idx]==nums[idx-1] and nums[idx]!=0)curr++;\\n         if(idx>=0 and (idx+1)<=(n-1) and nums[idx]==nums[idx+1] and nums[idx]!=0)curr++;\\n                curr+=prev;\\n                curr-=sub;\\n                ans.push_back(curr);\\n                prev=curr;\\n            }\\n        }\\n        for(auto x:ans)cout<<x<<\" \";\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3635438,
                "title": "golang-simple-solution-check-left-and-right",
                "content": "# Code\\n```\\nfunc colorTheArray(n int, queries [][]int) []int {\\n  arr := make([]int, n)\\n  answer := make([]int, len(queries))\\n  var cnt int\\n  for i, query := range queries {\\n    idx, col := query[0], query[1]\\n    if arr[idx] == col {\\n      answer[i] = cnt\\n      continue // no change\\n    }\\n    if idx > 0 {\\n      if arr[idx-1] == col {\\n        // New color can be paired up with left\\n        cnt++\\n      }\\n      if arr[idx] != 0 && arr[idx-1] == arr[idx] {\\n        // Previous color was contributing to left previously; not anymore\\n        cnt--\\n      }\\n    }\\n    if idx < n-1 {\\n      if arr[idx+1] == col {\\n        // New color can be paired with right\\n        cnt++\\n      }\\n      if arr[idx] != 0 && arr[idx+1] == arr[idx] {\\n        // Previous color was contributing to right previously; not anymore\\n        cnt--\\n      }\\n    }\\n    arr[idx] = col // update the color\\n    answer[i] = cnt // set the answer for the current query\\n  }\\n  return answer\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc colorTheArray(n int, queries [][]int) []int {\\n  arr := make([]int, n)\\n  answer := make([]int, len(queries))\\n  var cnt int\\n  for i, query := range queries {\\n    idx, col := query[0], query[1]\\n    if arr[idx] == col {\\n      answer[i] = cnt\\n      continue // no change\\n    }\\n    if idx > 0 {\\n      if arr[idx-1] == col {\\n        // New color can be paired up with left\\n        cnt++\\n      }\\n      if arr[idx] != 0 && arr[idx-1] == arr[idx] {\\n        // Previous color was contributing to left previously; not anymore\\n        cnt--\\n      }\\n    }\\n    if idx < n-1 {\\n      if arr[idx+1] == col {\\n        // New color can be paired with right\\n        cnt++\\n      }\\n      if arr[idx] != 0 && arr[idx+1] == arr[idx] {\\n        // Previous color was contributing to right previously; not anymore\\n        cnt--\\n      }\\n    }\\n    arr[idx] = col // update the color\\n    answer[i] = cnt // set the answer for the current query\\n  }\\n  return answer\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3632279,
                "title": "simple-easy-to-understand-maintaining-the-count-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust maintain the count of equal adjacent elements .\\nAlso remember adjacent means both ahead and behind, so we will check both.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int>v(n,0);\\n        int ct=0;\\n        vector<int>ans;\\n        for(int i=0;i<queries.size();i++){\\n            int index=queries[i][0];\\n            int color=queries[i][1];\\n            if(index-1>=0){\\n                if(v[index-1]==color && v[index-1]!=v[index]){\\n                    ct++;\\n                }\\n                else if(v[index-1] == v[index] && v[index]!=color && v[index]!=0){\\n                    ct--;\\n                }\\n            }\\n            if(index+1<n){\\n                if(v[index+1]==color && v[index+1]!=v[index]){\\n                    ct++;\\n                }\\n                else if(v[index+1]==v[index] && v[index]!=color && v[index]!=0){\\n                    ct--;\\n                }\\n            }\\n            v[index]=color;\\n            ans.push_back(ct);\\n        }\\n        return  ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int>v(n,0);\\n        int ct=0;\\n        vector<int>ans;\\n        for(int i=0;i<queries.size();i++){\\n            int index=queries[i][0];\\n            int color=queries[i][1];\\n            if(index-1>=0){\\n                if(v[index-1]==color && v[index-1]!=v[index]){\\n                    ct++;\\n                }\\n                else if(v[index-1] == v[index] && v[index]!=color && v[index]!=0){\\n                    ct--;\\n                }\\n            }\\n            if(index+1<n){\\n                if(v[index+1]==color && v[index+1]!=v[index]){\\n                    ct++;\\n                }\\n                else if(v[index+1]==v[index] && v[index]!=color && v[index]!=0){\\n                    ct--;\\n                }\\n            }\\n            v[index]=color;\\n            ans.push_back(ct);\\n        }\\n        return  ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3628213,
                "title": "easy-to-understand-basic-code-simplest-code-one-pass",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust keep track of the temporary state of the array and have a variable storing the adjacent count.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n<--N---i----N-->\\nassume N elements of same color on left and n elements of same color on right and now you put an element at i at the middle joining this chain.\\n\\nWhat would be the new adjacent count?\\nsoln. previous_adjacent_count + 2.\\n\\nWhat if the situation was like - <---N--i > \\nSoln. previous_adjacent_count + 1.\\n\\n\\nNow one case left : we change the color of the element at index i?\\nSoln Just decrease like we increased earlier.\\n \\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n\\n        vector<int>v(n,0); // stores the temporary states of the vector.\\n        int temp = 0;\\n        vector<int>res;\\n\\n        for(int i = 0 ;i < queries.size() ;i++){\\n\\n            int ind = queries[i][0]; // query at index ind\\n            int col = queries[i][1]; // query for color col.\\n\\n            // decrease the temp count if there exists  similar adjacent elements.\\n            if(ind != 0 && v[ind-1] == v[ind] &&v[ind] != 0 )temp--; // left side same but not 0\\n            if(ind != n-1 && v[ind+1] == v[ind]&&v[ind] != 0 )temp--; // right side same but not 0\\n\\n            v[ind] = col; // change the color.\\n\\n            // increase the temp count if there exists new similar adjacent elements.\\n            if(ind != 0 && v[ind-1] == v[ind] )temp++; // left same\\n            if(ind != n-1 && v[ind+1] == v[ind])temp++; // right same\\n\\n            res.push_back(temp);\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n\\n        vector<int>v(n,0); // stores the temporary states of the vector.\\n        int temp = 0;\\n        vector<int>res;\\n\\n        for(int i = 0 ;i < queries.size() ;i++){\\n\\n            int ind = queries[i][0]; // query at index ind\\n            int col = queries[i][1]; // query for color col.\\n\\n            // decrease the temp count if there exists  similar adjacent elements.\\n            if(ind != 0 && v[ind-1] == v[ind] &&v[ind] != 0 )temp--; // left side same but not 0\\n            if(ind != n-1 && v[ind+1] == v[ind]&&v[ind] != 0 )temp--; // right side same but not 0\\n\\n            v[ind] = col; // change the color.\\n\\n            // increase the temp count if there exists new similar adjacent elements.\\n            if(ind != 0 && v[ind-1] == v[ind] )temp++; // left same\\n            if(ind != n-1 && v[ind+1] == v[ind])temp++; // right same\\n\\n            res.push_back(temp);\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617189,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        int count = 0;\\n        int[] nums = new int[n];\\n        int[] result = new int[queries.length];\\n        \\n        for(int i = 0; i < queries.length; i++) {\\n            int idx = queries[i][0], val = queries[i][1];\\n            \\n            if(idx > 0) {\\n                if(nums[idx-1] == 0);\\n                else if(nums[idx] == nums[idx-1]) {\\n                    if(nums[idx] != val && count > 0) count--;\\n                }\\n                else {\\n                    if(val == nums[idx-1]) count++;\\n                }\\n            }\\n\\t\\t\\t\\n            if(idx+1 < n) {\\n                if(nums[idx+1] == 0);\\n                else if(nums[idx] == nums[idx+1]) {\\n                    if(nums[idx] != val && count > 0) count--;\\n                }\\n                else {\\n                    if(val == nums[idx+1]) count++;\\n                }\\n            }\\n            \\n            nums[idx] = val;\\n            result[i] = count;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        int count = 0;\\n        int[] nums = new int[n];\\n        int[] result = new int[queries.length];\\n        \\n        for(int i = 0; i < queries.length; i++) {\\n            int idx = queries[i][0], val = queries[i][1];\\n            \\n            if(idx > 0) {\\n                if(nums[idx-1] == 0);\\n                else if(nums[idx] == nums[idx-1]) {\\n                    if(nums[idx] != val && count > 0) count--;\\n                }\\n                else {\\n                    if(val == nums[idx-1]) count++;\\n                }\\n            }\\n\\t\\t\\t\\n            if(idx+1 < n) {\\n                if(nums[idx+1] == 0);\\n                else if(nums[idx] == nums[idx+1]) {\\n                    if(nums[idx] != val && count > 0) count--;\\n                }\\n                else {\\n                    if(val == nums[idx+1]) count++;\\n                }\\n            }\\n            \\n            nums[idx] = val;\\n            result[i] = count;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3603948,
                "title": "simple-if-else-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& q) {\\n        int m=q.size();\\n        vector<int> nums(n,0);\\n        vector<int> ans(m,0);\\n        int count=0;\\n\\n        for(int i=0;i<m;i++){\\n            int flag=0;\\n\\n            int index=q[i][0];\\n            int color=q[i][1];\\n\\n            int x=index+1;\\n            int y=index-1;\\n\\n\\n            \\n            if(x<n){\\n                if(nums[index]!=0 && nums[index]==nums[x]){\\n                    flag++;\\n\\n                }\\n            }\\n            if(y>=0){\\n                if(nums[index]!=0 && nums[index]==nums[y]){\\n                    flag++;\\n                }\\n            }\\n\\n            nums[index]=color;\\n\\n            if(x<n){\\n                if(nums[index]!=0 && nums[index]==nums[x]){\\n                    count++;\\n                }\\n            }\\n             if(y>=0){\\n                if(nums[index]!=0 && nums[index]==nums[y]){\\n                        count++;\\n                }\\n            }\\n\\n            count=count-flag;\\n\\n            ans[i]=count;\\n            \\n\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& q) {\\n        int m=q.size();\\n        vector<int> nums(n,0);\\n        vector<int> ans(m,0);\\n        int count=0;\\n\\n        for(int i=0;i<m;i++){\\n            int flag=0;\\n\\n            int index=q[i][0];\\n            int color=q[i][1];\\n\\n            int x=index+1;\\n            int y=index-1;\\n\\n\\n            \\n            if(x<n){\\n                if(nums[index]!=0 && nums[index]==nums[x]){\\n                    flag++;\\n\\n                }\\n            }\\n            if(y>=0){\\n                if(nums[index]!=0 && nums[index]==nums[y]){\\n                    flag++;\\n                }\\n            }\\n\\n            nums[index]=color;\\n\\n            if(x<n){\\n                if(nums[index]!=0 && nums[index]==nums[x]){\\n                    count++;\\n                }\\n            }\\n             if(y>=0){\\n                if(nums[index]!=0 && nums[index]==nums[y]){\\n                        count++;\\n                }\\n            }\\n\\n            count=count-flag;\\n\\n            ans[i]=count;\\n            \\n\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3599619,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> ans, nums(n, 0);\\n        int count = 0;\\n        for(auto q: queries){\\n            int i = q[0], val = q[1], tc = 0;\\n            if(nums[i] && i - 1 >= 0 && nums[i-1] == nums[i]) count--;  \\n            if(nums[i] && i + 1 < n && nums[i+1] == nums[i]) count--;\\n            nums[i] = val;\\n            if( i - 1 >= 0 && nums[i-1] == nums[i]) count++;\\n            if( i + 1 < n && nums[i+1] == nums[i]) count++;\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> ans, nums(n, 0);\\n        int count = 0;\\n        for(auto q: queries){\\n            int i = q[0], val = q[1], tc = 0;\\n            if(nums[i] && i - 1 >= 0 && nums[i-1] == nums[i]) count--;  \\n            if(nums[i] && i + 1 < n && nums[i+1] == nums[i]) count--;\\n            nums[i] = val;\\n            if( i - 1 >= 0 && nums[i-1] == nums[i]) count++;\\n            if( i + 1 < n && nums[i+1] == nums[i]) count++;\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586827,
                "title": "super-complicated-solution-mustsee",
                "content": "# Intuition\\nYes,\\nit\\'s time to implement storing of segments of the same color with update query.\\n\\n# Approach\\nWe need to know to which segment a point from a query relates. If all segments are sorted by right side (or left, since they are disjoint), then the first right side that is greater or equal to the given point is a one that is needed. That is exactly what lower_bound is supposed to be. Alternatively, segment of a given point has left side \\'the first greater\\' minus one. Introducing `map<int,int> rl`.\\n\\nNOW (for point `p` and segment `[l, r]` inclusive, when `color[p]!=new_color`):\\n1. l==r. `p` can join two segments (to the left and to the right) into one. `\\n2. l==r. `p` can join to a segment on the right. \\n3. l==r. `p` can join to a segment on the left.\\n4. l==r. `p` might not join anything.\\n5. p==r. `p` can join to a segment on the right.\\n6. p==r. `p` might not join anything.\\n7. p==l. `p` can join to a segment on the left.\\n8. p==l. `p` might not join anything.\\n9. otherwise `p` is in a middle of `[l, r]` and will break it into three pieces.\\n\\nThis cases were created with a thought to be able to update `rl`. So, all things that a given point with a given color can do to a data of `rl`.\\n\\nIf someone knows a better approach to the problem of storing and updating segments with color, a comment is appreciated.\\n\\nA good thing about this problem is that it is a one of easy debug. I\\'m not a person to speak for the programming in a general way, but if I were asked, what is the most important thing about a problem/program, what is the most important aspect, I would answer - complexity of debug, everything else is less time/effort consuming.\\n\\n# Complexity\\n- Time complexity: $$O(q\\\\cdot log(n))$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& q) {\\n        map<int,int> rl{{n-1, 0}};\\n        vector<int> color(n);\\n        int cnt{};\\n        vector<int> answer;\\n        for(auto q : q){\\n            int p{q[0]}, c{q[1]};\\n            //cout << p << \\' \\' << c << \\':\\' <<\\'\\\\n\\';\\n            //for(auto [_, __] : rl)\\n            //    cout << __ << \\'*\\' << _ << \\' \\';\\n            //cout << \\'\\\\n\\';\\n            if(c!=color[p]){\\n                auto i{rl.lower_bound(p)};\\n                auto [r, l] {*i};\\n                if(r==l){\\n                    if(p<n-1 && p>0 && color[p+1]==color[p-1] && color[p+1]==c){\\n                        auto jl{prev(i)}, jr{next(i)};\\n                        rl.erase(i);\\n                        int L{jl->second}, R{jr->first};\\n                        rl.erase(jl);\\n                        rl.erase(jr);\\n                        rl.insert({R,L});\\n                        cnt += 2;\\n                    }\\n                    else if(p<n-1 && color[p+1]==c){\\n                        auto j{next(i)};\\n                        rl.erase(i);\\n                        --j->second;\\n                        cnt += 1;\\n                    }\\n                    else if(p>0 && color[p-1]==c){\\n                        auto j{prev(i)};\\n                        rl.erase(i);\\n                        auto handle{rl.extract(j)};\\n                        ++handle.key();\\n                        rl.insert(move(handle));\\n                        cnt += 1;\\n                    }\\n                }else if(p==r){\\n                    auto handle{rl.extract(i)};\\n                    --handle.key();\\n                    rl.insert(move(handle));\\n                    if(p<n-1){\\n                        if(color[p+1]!=c){\\n                            rl.insert({p,p});\\n                            cnt -= 1 * (color[p]>0);\\n                        }else{\\n                            auto j{next(i)};\\n                            --j->second;\\n                            cnt -= 1 * (color[p] > 0);\\n                            cnt += 1 * (color[p+1]>0);\\n                        }\\n                    }\\n                    else{\\n                        rl.insert({p,p});\\n                        cnt -= 1 * (color[p]>0);\\n                    }\\n                }\\n                else if(p==l){\\n                    ++i->second;\\n                    if(p>0){\\n                        if(color[p-1]!=c){\\n                            rl.insert({p,p});\\n                            cnt -= 1 * (color[p]>0);\\n                        }else{\\n                            auto j{prev(i)};\\n                            auto handle{rl.extract(j)};\\n                            ++handle.key();\\n                            rl.insert(move(handle));\\n                            cnt -= 1 * (color[p] > 0);\\n                            cnt += 1 * (color[p-1]>0);\\n                        }\\n                    }\\n                    else{\\n                        rl.insert({p,p});\\n                        cnt -= 1 * (color[p]>0);\\n                    }\\n                }\\n                else{\\n                    rl.erase(i);\\n                    rl.insert({p-1,l});\\n                    rl.insert({p,p});\\n                    rl.insert({r,p+1});\\n                    cnt -= 2 * (color[p]>0);\\n                }\\n                color[p] = c;\\n            }\\n            answer.push_back(cnt);\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& q) {\\n        map<int,int> rl{{n-1, 0}};\\n        vector<int> color(n);\\n        int cnt{};\\n        vector<int> answer;\\n        for(auto q : q){\\n            int p{q[0]}, c{q[1]};\\n            //cout << p << \\' \\' << c << \\':\\' <<\\'\\\\n\\';\\n            //for(auto [_, __] : rl)\\n            //    cout << __ << \\'*\\' << _ << \\' \\';\\n            //cout << \\'\\\\n\\';\\n            if(c!=color[p]){\\n                auto i{rl.lower_bound(p)};\\n                auto [r, l] {*i};\\n                if(r==l){\\n                    if(p<n-1 && p>0 && color[p+1]==color[p-1] && color[p+1]==c){\\n                        auto jl{prev(i)}, jr{next(i)};\\n                        rl.erase(i);\\n                        int L{jl->second}, R{jr->first};\\n                        rl.erase(jl);\\n                        rl.erase(jr);\\n                        rl.insert({R,L});\\n                        cnt += 2;\\n                    }\\n                    else if(p<n-1 && color[p+1]==c){\\n                        auto j{next(i)};\\n                        rl.erase(i);\\n                        --j->second;\\n                        cnt += 1;\\n                    }\\n                    else if(p>0 && color[p-1]==c){\\n                        auto j{prev(i)};\\n                        rl.erase(i);\\n                        auto handle{rl.extract(j)};\\n                        ++handle.key();\\n                        rl.insert(move(handle));\\n                        cnt += 1;\\n                    }\\n                }else if(p==r){\\n                    auto handle{rl.extract(i)};\\n                    --handle.key();\\n                    rl.insert(move(handle));\\n                    if(p<n-1){\\n                        if(color[p+1]!=c){\\n                            rl.insert({p,p});\\n                            cnt -= 1 * (color[p]>0);\\n                        }else{\\n                            auto j{next(i)};\\n                            --j->second;\\n                            cnt -= 1 * (color[p] > 0);\\n                            cnt += 1 * (color[p+1]>0);\\n                        }\\n                    }\\n                    else{\\n                        rl.insert({p,p});\\n                        cnt -= 1 * (color[p]>0);\\n                    }\\n                }\\n                else if(p==l){\\n                    ++i->second;\\n                    if(p>0){\\n                        if(color[p-1]!=c){\\n                            rl.insert({p,p});\\n                            cnt -= 1 * (color[p]>0);\\n                        }else{\\n                            auto j{prev(i)};\\n                            auto handle{rl.extract(j)};\\n                            ++handle.key();\\n                            rl.insert(move(handle));\\n                            cnt -= 1 * (color[p] > 0);\\n                            cnt += 1 * (color[p-1]>0);\\n                        }\\n                    }\\n                    else{\\n                        rl.insert({p,p});\\n                        cnt -= 1 * (color[p]>0);\\n                    }\\n                }\\n                else{\\n                    rl.erase(i);\\n                    rl.insert({p-1,l});\\n                    rl.insert({p,p});\\n                    rl.insert({r,p+1});\\n                    cnt -= 2 * (color[p]>0);\\n                }\\n                color[p] = c;\\n            }\\n            answer.push_back(cnt);\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3583839,
                "title": "java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        int freq = 0;\\n        int color[] = new int[n];\\n        int answer[] = new int[queries.length];\\n        for(int i=0;i<queries.length;i++){\\n            int index = queries[i][0];\\n            int col = queries[i][1];\\n            \\n            if(color[index]!=0 && index!=0 && color[index-1]==color[index]){\\n                freq--;\\n            }\\n            if(color[index]!=0 && index!=(n-1) && color[index]==color[index+1]){\\n                freq--;\\n            }\\n            color[index] = col;\\n            if(index!=(n-1) && color[index]==color[index+1]){\\n                freq++;\\n            }\\n            if(index!=0 && color[index]==color[index-1]){\\n                freq++;\\n            }\\n            \\n            answer[i] = freq;\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        int freq = 0;\\n        int color[] = new int[n];\\n        int answer[] = new int[queries.length];\\n        for(int i=0;i<queries.length;i++){\\n            int index = queries[i][0];\\n            int col = queries[i][1];\\n            \\n            if(color[index]!=0 && index!=0 && color[index-1]==color[index]){\\n                freq--;\\n            }\\n            if(color[index]!=0 && index!=(n-1) && color[index]==color[index+1]){\\n                freq--;\\n            }\\n            color[index] = col;\\n            if(index!=(n-1) && color[index]==color[index+1]){\\n                freq++;\\n            }\\n            if(index!=0 && color[index]==color[index-1]){\\n                freq++;\\n            }\\n            \\n            answer[i] = freq;\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3561559,
                "title": "easy-best-optimal-code-in-c",
                "content": "\\n# Code\\n## PLease Upvote if u liked my Solution\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        int size = queries.size(), prevAns = 0;\\n        vector<int> nums(n),ans(size);\\n        for(int i = 0; i < size; i++){ \\n            int ind = queries[i][0], color = queries[i][1];\\n            if(nums[ind] != 0){\\n                if(ind - 1 >= 0)\\n                    if(nums[ind] == nums[ind - 1])\\n                        prevAns --;\\n                if(ind + 1 < n)\\n                    if(nums[ind] == nums[ind + 1])\\n                        prevAns --;\\n            }\\n            nums[ind] = color;\\n            if(ind - 1 >= 0)\\n                if(nums[ind] == nums[ind - 1])\\n                    prevAns ++;\\n            if(ind + 1 < n)\\n                if(nums[ind] == nums[ind + 1])\\n                    prevAns ++;\\n            ans[i] = prevAns;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        int size = queries.size(), prevAns = 0;\\n        vector<int> nums(n),ans(size);\\n        for(int i = 0; i < size; i++){ \\n            int ind = queries[i][0], color = queries[i][1];\\n            if(nums[ind] != 0){\\n                if(ind - 1 >= 0)\\n                    if(nums[ind] == nums[ind - 1])\\n                        prevAns --;\\n                if(ind + 1 < n)\\n                    if(nums[ind] == nums[ind + 1])\\n                        prevAns --;\\n            }\\n            nums[ind] = color;\\n            if(ind - 1 >= 0)\\n                if(nums[ind] == nums[ind - 1])\\n                    prevAns ++;\\n            if(ind + 1 < n)\\n                if(nums[ind] == nums[ind + 1])\\n                    prevAns ++;\\n            ans[i] = prevAns;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3550080,
                "title": "a-few-solutions",
                "content": "Let the function `f` update the array `A` by assigning the `A[i] = x` along with updating and returning the ongoing total `t` adjacent element count via helper functions `L` and `R` which return true if-and-only-if two adjacent *non-zero* elements exist in `A` to-the-left and to-the-right of index `i` inclusive, ie. `i - 1` and `i + 1` correspondingly.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun colorTheArray(N: Int, updates: Array<IntArray>): IntArray {\\n        var t = 0\\n        var A = IntArray(N) { 0 }\\n        var L = { i: Int -> A[i] != 0 && 0 <= i - 1 && A[i - 1] == A[i] }\\n        var R = { i: Int -> A[i] != 0 && i + 1 < N && A[i] == A[i + 1] }\\n        fun f(i: Int, x: Int): Int {\\n            if (L(i)) --t\\n            if (R(i)) --t\\n            A[i] = x\\n            if (L(i)) ++t\\n            if (R(i)) ++t\\n            return t\\n        }\\n        return updates.map{ (i, x) -> f(i, x) }.toIntArray()\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet colorTheArray = (N, updates, A = Array(N).fill(0), t = 0) => {\\n    let L = i => A[i] && 0 <= i - 1 && A[i - 1] == A[i],\\n        R = i => A[i] && i + 1 < N && A[i] == A[i + 1];\\n    let f = (i, x) => {\\n        t -= Number(L(i)) + Number(R(i));\\n        A[i] = x;\\n        t += Number(L(i)) + Number(R(i));\\n        return t;\\n    };\\n    return updates.map(([i, x]) => f(i, x));\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def colorTheArray(self, N: int, updates: List[List[int]], t = 0) -> List[int]:\\n        A = [0] * N\\n        L = lambda i: A[i] and 0 <= i - 1 and A[i - 1] == A[i]\\n        R = lambda i: A[i] and i + 1 < N and A[i] == A[i + 1]\\n        def f(i, x):\\n            nonlocal t\\n            t -= int(L(i)) + int(R(i))\\n            A[i] = x\\n            t += int(L(i)) + int(R(i))\\n            return t\\n        return [f(i, x) for i, x in updates]\\n```\\n\\n*Rust*\\n```\\n// FIXME: we cannot borrow A as immutable and mutable\\ntype VI = Vec<i32>;\\ntype VVI = Vec<VI>;\\nimpl Solution {\\n    pub fn color_the_array(N: i32, updates: VVI) -> VI {\\n        let N = N as usize;\\n        let mut t = 0;\\n        let mut A = vec![0; N];\\n        let L = (|i| A[i] != 0 && 0 <= i as i32 - 1 && A[i - 1] == A[i]);\\n        let R = (|i| A[i] != 0 && i + 1 < N && A[i] == A[i + 1]);\\n        let mut f = (|pair: VI| {\\n            let (i, x) = (pair[0] as usize, pair[1]);\\n            if L(i) { t -= 1; }\\n            if R(i) { t -= 1; }\\n            A[i] = x;\\n            if L(i) { t += 1; }\\n            if R(i) { t += 1; }\\n            t\\n        });\\n        updates.into_iter().map(|pair| f(pair)).collect::<VI>()\\n    }\\n}\\n/*\\nLine 10, Char 22: cannot borrow `A` as mutable because it is also borrowed as immutable (solution.rs)\\n   |\\n8  |         let L = (|i| A[i] != 0 && 0 <= i as i32 - 1 && A[i - 1] == A[i]);\\n   |                  --- - first borrow occurs due to use of `A` in closure\\n   |                  |\\n   |                  immutable borrow occurs here\\n9 |         let R = (|i| A[i] != 0 && i + 1 < N && A[i] == A[i + 1]);\\n10 |         let mut f = (|pair: VI| {\\n   |                      ^^^^^^^^^^ mutable borrow occurs here\\n11 |             let (i, x) = (pair[0] as usize, pair[1]);\\n12 |             if L(i) { t -= 1; }\\n   |                - immutable borrow later captured here by closure\\n13 |             if R(i) { t -= 1; }\\n14 |             A[i] = x;\\n   |             - second borrow occurs due to use of `A` in closure\\nFor more information about this error, try `rustc --explain E0502`.\\nerror: could not compile `prog` due to previous error\\nmv: cannot stat \\'/leetcode/rust_compile/target/release/prog\\': No such file or directory\\n*/\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    VI colorTheArray(int N, VVI& updates, int t = 0, VI ans = {}) {\\n        auto A = VI(N);\\n        auto L = [&](auto i) { return A[i] && 0 <= i - 1 && A[i - 1] == A[i]; }; \\n        auto R = [&](auto i) { return A[i] && i + 1 < N && A[i] == A[i + 1]; };\\n        auto f = [&](auto i, auto x) {\\n            t -= int(L(i)) + int(R(i));\\n            A[i] = x;\\n            t += int(L(i)) + int(R(i));\\n            return t;\\n        };\\n        transform(updates.begin(), updates.end(), back_inserter(ans), [&](auto& pair) { return f(pair[0], pair[1]); });\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun colorTheArray(N: Int, updates: Array<IntArray>): IntArray {\\n        var t = 0\\n        var A = IntArray(N) { 0 }\\n        var L = { i: Int -> A[i] != 0 && 0 <= i - 1 && A[i - 1] == A[i] }\\n        var R = { i: Int -> A[i] != 0 && i + 1 < N && A[i] == A[i + 1] }\\n        fun f(i: Int, x: Int): Int {\\n            if (L(i)) --t\\n            if (R(i)) --t\\n            A[i] = x\\n            if (L(i)) ++t\\n            if (R(i)) ++t\\n            return t\\n        }\\n        return updates.map{ (i, x) -> f(i, x) }.toIntArray()\\n    }\\n}\\n```\n```\\nlet colorTheArray = (N, updates, A = Array(N).fill(0), t = 0) => {\\n    let L = i => A[i] && 0 <= i - 1 && A[i - 1] == A[i],\\n        R = i => A[i] && i + 1 < N && A[i] == A[i + 1];\\n    let f = (i, x) => {\\n        t -= Number(L(i)) + Number(R(i));\\n        A[i] = x;\\n        t += Number(L(i)) + Number(R(i));\\n        return t;\\n    };\\n    return updates.map(([i, x]) => f(i, x));\\n};\\n```\n```\\nclass Solution:\\n    def colorTheArray(self, N: int, updates: List[List[int]], t = 0) -> List[int]:\\n        A = [0] * N\\n        L = lambda i: A[i] and 0 <= i - 1 and A[i - 1] == A[i]\\n        R = lambda i: A[i] and i + 1 < N and A[i] == A[i + 1]\\n        def f(i, x):\\n            nonlocal t\\n            t -= int(L(i)) + int(R(i))\\n            A[i] = x\\n            t += int(L(i)) + int(R(i))\\n            return t\\n        return [f(i, x) for i, x in updates]\\n```\n```\\n// FIXME: we cannot borrow A as immutable and mutable\\ntype VI = Vec<i32>;\\ntype VVI = Vec<VI>;\\nimpl Solution {\\n    pub fn color_the_array(N: i32, updates: VVI) -> VI {\\n        let N = N as usize;\\n        let mut t = 0;\\n        let mut A = vec![0; N];\\n        let L = (|i| A[i] != 0 && 0 <= i as i32 - 1 && A[i - 1] == A[i]);\\n        let R = (|i| A[i] != 0 && i + 1 < N && A[i] == A[i + 1]);\\n        let mut f = (|pair: VI| {\\n            let (i, x) = (pair[0] as usize, pair[1]);\\n            if L(i) { t -= 1; }\\n            if R(i) { t -= 1; }\\n            A[i] = x;\\n            if L(i) { t += 1; }\\n            if R(i) { t += 1; }\\n            t\\n        });\\n        updates.into_iter().map(|pair| f(pair)).collect::<VI>()\\n    }\\n}\\n/*\\nLine 10, Char 22: cannot borrow `A` as mutable because it is also borrowed as immutable (solution.rs)\\n   |\\n8  |         let L = (|i| A[i] != 0 && 0 <= i as i32 - 1 && A[i - 1] == A[i]);\\n   |                  --- - first borrow occurs due to use of `A` in closure\\n   |                  |\\n   |                  immutable borrow occurs here\\n9 |         let R = (|i| A[i] != 0 && i + 1 < N && A[i] == A[i + 1]);\\n10 |         let mut f = (|pair: VI| {\\n   |                      ^^^^^^^^^^ mutable borrow occurs here\\n11 |             let (i, x) = (pair[0] as usize, pair[1]);\\n12 |             if L(i) { t -= 1; }\\n   |                - immutable borrow later captured here by closure\\n13 |             if R(i) { t -= 1; }\\n14 |             A[i] = x;\\n   |             - second borrow occurs due to use of `A` in closure\\nFor more information about this error, try `rustc --explain E0502`.\\nerror: could not compile `prog` due to previous error\\nmv: cannot stat \\'/leetcode/rust_compile/target/release/prog\\': No such file or directory\\n*/\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    VI colorTheArray(int N, VVI& updates, int t = 0, VI ans = {}) {\\n        auto A = VI(N);\\n        auto L = [&](auto i) { return A[i] && 0 <= i - 1 && A[i - 1] == A[i]; }; \\n        auto R = [&](auto i) { return A[i] && i + 1 < N && A[i] == A[i + 1]; };\\n        auto f = [&](auto i, auto x) {\\n            t -= int(L(i)) + int(R(i));\\n            A[i] = x;\\n            t += int(L(i)) + int(R(i));\\n            return t;\\n        };\\n        transform(updates.begin(), updates.end(), back_inserter(ans), [&](auto& pair) { return f(pair[0], pair[1]); });\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3542799,
                "title": "faster-than-98-just-a-bunch-of-ifs",
                "content": "# Code\\n```\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n        col = [0] * (n+1)  # to make sure ends are accounted for\\n        ret = []\\n        cur = 0\\n        for i, c in queries:\\n            if c != col[i]:\\n                # removal:\\n                if col[i] != 0:\\n                    if col[i-1] == col[i]:\\n                        cur -= 1\\n                    if col[i+1] == col[i]:\\n                        cur -= 1\\n                # addition\\n                if col[i-1] == c:\\n                    cur += 1\\n                if col[i+1] == c:\\n                    cur += 1\\n            ret.append(cur)\\n            col[i] = c\\n        return ret\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n        col = [0] * (n+1)  # to make sure ends are accounted for\\n        ret = []\\n        cur = 0\\n        for i, c in queries:\\n            if c != col[i]:\\n                # removal:\\n                if col[i] != 0:\\n                    if col[i-1] == col[i]:\\n                        cur -= 1\\n                    if col[i+1] == col[i]:\\n                        cur -= 1\\n                # addition\\n                if col[i-1] == c:\\n                    cur += 1\\n                if col[i+1] == c:\\n                    cur += 1\\n            ret.append(cur)\\n            col[i] = c\\n        return ret\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3541643,
                "title": "python-explained-simple-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt iteration of from Queries , we are provided the index of element of array to color and the color . After each iteration of Queries we have to cheak how element have same color value as of it\\'s adjacent element .\\nStore the above and return Array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs we have are inserting only one element at a time , it will only effect it\\'s adjacent element not the whole array .\\nSo instead of monitoring the whole array after each iteration , we will just monitor the effect of insertion on adjacent element . \\nFor Example\\n```\\narr=[1,2,3,2,1]\\nQuery=[2,2]\\n```\\nSo we have to insert Color 2 at index 2 \\nInitially there are 0 pairs with same color .\\nSo we will just see if the index we are updating have any adjacent element with same color value .\\n[ No in above example as 2!=3 and 3!=2 ]\\nIf yes and we are updating the index with different value then that pairs will no longer there so we will subtract 1 from previos result for each pair (maximum -2 as it can have only 2 adjacent element).\\n\\nNow we will cheak if new color value have any adjacent element with same value . In case we found any we will add 1 for each pair(maximum 2 ) in previous result.\\n[Yes Inserting 2 in place of 3 will give as two pairs at index (1,2) and (2,3) so we add 2 in previos result i.e. 0+2==> 2 and this is our answer]\\n\\n# Complexity\\n- Time complexity:\\n $$O(n)$$\\n\\n- Space complexity:\\n $$O(n+len(queries))$$\\n\\n# Code\\n```\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n        out=[0]*len(queries)\\n        op=[0]*n\\n        i=1\\n        for i in range(len(queries)):\\n            query=queries[i]\\n            if i>0:\\n                out[i]=out[i-1]\\n            if query[0]!=n-1:\\n                if op[query[0]+1] != op[query[0]] and op[query[0]+1]==query[1] and op[query[0]+1]!=0:\\n                    out[i]+=1\\n                if op[query[0]+1] == op[query[0]] and op[query[0]+1]!=query[1] and op[query[0]+1]!=0:\\n                    out[i]-=1\\n            if query[0]!=0:\\n                if op[query[0]-1] != op[query[0]] and op[query[0]-1]==query[1] and op[query[0]-1]!=0:\\n                    out[i]+=1\\n                if op[query[0]-1] == op[query[0]] and op[query[0]-1]!=query[1] and op[query[0]-1]!=0:\\n                    out[i]-=1\\n            op[query[0]]=query[1]\\n        return out\\n            \\n            \\n                \\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\narr=[1,2,3,2,1]\\nQuery=[2,2]\\n```\n```\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n        out=[0]*len(queries)\\n        op=[0]*n\\n        i=1\\n        for i in range(len(queries)):\\n            query=queries[i]\\n            if i>0:\\n                out[i]=out[i-1]\\n            if query[0]!=n-1:\\n                if op[query[0]+1] != op[query[0]] and op[query[0]+1]==query[1] and op[query[0]+1]!=0:\\n                    out[i]+=1\\n                if op[query[0]+1] == op[query[0]] and op[query[0]+1]!=query[1] and op[query[0]+1]!=0:\\n                    out[i]-=1\\n            if query[0]!=0:\\n                if op[query[0]-1] != op[query[0]] and op[query[0]-1]==query[1] and op[query[0]-1]!=0:\\n                    out[i]+=1\\n                if op[query[0]-1] == op[query[0]] and op[query[0]-1]!=query[1] and op[query[0]-1]!=0:\\n                    out[i]-=1\\n            op[query[0]]=query[1]\\n        return out\\n            \\n            \\n                \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538726,
                "title": "java-c-o-n-solution-with-in-depth-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe need to run the queries, for every query we need to iterate the nums and check the how many adjacent colors\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLook carefully: for the above intuition take n^2 time we need to optimize the iteration of the nums to check adj color \\n\\nFor that we need to write preprocessing kind of code it will help you to get adj color in O(1) time\\n\\n- Before update, 1st check nums [i-1] == [i] or [i+1] == [i] if it is adjacent present we need to decrease in samecolor\\n- After update, again check nums [i-1] == [i] or [i+1] == [i] if it is adjacent present increase the samecolor\\n\\nAt last store answer[i] = scolor and return\\uD83D\\uDE42\\n\\nUpvote if it is helpfull\\uD83E\\uDD18\\n\\n# Complexity\\n- Time complexity: O(q) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(q)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nq - length of the queries\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        int nums[] = new int[n];\\n        int q = queries.length;\\n        int answer[] = new int[q];\\n        int scolor = 0;\\n        for(int i = 0; i<q; i++){\\n            int index = queries[i][0];\\n            int color = queries[i][1];\\n            int dcolor = 0;\\n            if(nums[index] != 0){\\n                if(index > 0 && nums[index]==nums[index-1]) dcolor++;\\n                if(index < n-1 && nums[index] == nums[index+1]) dcolor++;\\n            }\\n            nums[index] = color;\\n            if(index > 0 && nums[index]==nums[index-1]) scolor += 1;\\n            if(index < n-1 && nums[index] == nums[index+1]) scolor += 1;\\n            scolor -= dcolor;\\n            answer[i] = scolor;\\n        }\\n\\n        return answer;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        int nums[] = new int[n];\\n        int q = queries.length;\\n        int answer[] = new int[q];\\n        int scolor = 0;\\n        for(int i = 0; i<q; i++){\\n            int index = queries[i][0];\\n            int color = queries[i][1];\\n            int dcolor = 0;\\n            if(nums[index] != 0){\\n                if(index > 0 && nums[index]==nums[index-1]) dcolor++;\\n                if(index < n-1 && nums[index] == nums[index+1]) dcolor++;\\n            }\\n            nums[index] = color;\\n            if(index > 0 && nums[index]==nums[index-1]) scolor += 1;\\n            if(index < n-1 && nums[index] == nums[index+1]) scolor += 1;\\n            scolor -= dcolor;\\n            answer[i] = scolor;\\n        }\\n\\n        return answer;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535867,
                "title": "easy-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& q) {\\n            \\n            vector<int> nums(n,0);\\n            vector<int> ans(q.size(),0);\\n            int cnt = 0; \\n            for(int i = 0; i < q.size();i++){\\n                    if(nums[q[i][0]] == 0){\\n                      nums[q[i][0]] = q[i][1];\\n                      if(q[i][0] > 0){\\n                          if(nums[q[i][0]] == nums[q[i][0]-1] && nums[q[i][0]] != 0){\\n                                   cnt++;\\n                          }\\n                      }\\n                          if(q[i][0] < n-1){\\n                           if(nums[q[i][0]] == nums[q[i][0]+1] && nums[q[i][0]] != 0){\\n                                   cnt++;\\n                          } \\n                          }\\n                      \\n                    }\\n                    else{\\n                         if(q[i][0] > 0){\\n                          if(nums[q[i][0]] == nums[q[i][0]-1] && nums[q[i][0]] != 0){\\n                                   cnt--;\\n                          }\\n                        }\\n                          if(q[i][0] < n-1){\\n                           if(nums[q[i][0]] == nums[q[i][0]+1] && nums[q[i][0]] != 0){\\n                                   cnt--;\\n                          } \\n                          }\\n\\n                        nums[q[i][0]] = q[i][1];\\n                        \\n                        if(q[i][0] > 0){\\n                          if(nums[q[i][0]] == nums[q[i][0]-1] && nums[q[i][0]] != 0){\\n                                   cnt++;\\n                          }\\n                        }\\n                          if(q[i][0] < n-1){\\n                           if(nums[q[i][0]] == nums[q[i][0]+1] && nums[q[i][0]] != 0){\\n                                   cnt++;\\n                          } \\n                          }\\n                            \\n\\n                    }\\n\\n                    //ans[i] = cnt;\\n                    \\n                    \\n\\n                    ans[i] = cnt;\\n            }\\n\\n            return ans;\\n            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& q) {\\n            \\n            vector<int> nums(n,0);\\n            vector<int> ans(q.size(),0);\\n            int cnt = 0; \\n            for(int i = 0; i < q.size();i++){\\n                    if(nums[q[i][0]] == 0){\\n                      nums[q[i][0]] = q[i][1];\\n                      if(q[i][0] > 0){\\n                          if(nums[q[i][0]] == nums[q[i][0]-1] && nums[q[i][0]] != 0){\\n                                   cnt++;\\n                          }\\n                      }\\n                          if(q[i][0] < n-1){\\n                           if(nums[q[i][0]] == nums[q[i][0]+1] && nums[q[i][0]] != 0){\\n                                   cnt++;\\n                          } \\n                          }\\n                      \\n                    }\\n                    else{\\n                         if(q[i][0] > 0){\\n                          if(nums[q[i][0]] == nums[q[i][0]-1] && nums[q[i][0]] != 0){\\n                                   cnt--;\\n                          }\\n                        }\\n                          if(q[i][0] < n-1){\\n                           if(nums[q[i][0]] == nums[q[i][0]+1] && nums[q[i][0]] != 0){\\n                                   cnt--;\\n                          } \\n                          }\\n\\n                        nums[q[i][0]] = q[i][1];\\n                        \\n                        if(q[i][0] > 0){\\n                          if(nums[q[i][0]] == nums[q[i][0]-1] && nums[q[i][0]] != 0){\\n                                   cnt++;\\n                          }\\n                        }\\n                          if(q[i][0] < n-1){\\n                           if(nums[q[i][0]] == nums[q[i][0]+1] && nums[q[i][0]] != 0){\\n                                   cnt++;\\n                          } \\n                          }\\n                            \\n\\n                    }\\n\\n                    //ans[i] = cnt;\\n                    \\n                    \\n\\n                    ans[i] = cnt;\\n            }\\n\\n            return ans;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534338,
                "title": "c-easy-count-pairs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& vec) {\\n     vector<int>po(n,0);\\n        int  pair=0;\\n        vector<int>k;\\n        if(n==1)\\n        {\\n            vector<int> ppp(vec.size(),0);\\n            return ppp;\\n            \\n        }\\n        for(int i=0;i<vec.size();i++)\\n        {\\n            int p= vec[i][0];\\n            int v= vec[i][1];\\n            if(p>0 and p<po.size()-1)\\n            {\\n            if(po[p]!=v){\\n            if(po[p]==po[p-1] and po[p]!=0 and po[p-1]!=0)\\n            {\\n               pair--;\\n            } \\n            if(po[p]==po[p+1] and po[p]!=0 and po[p+1]!=0)\\n            {\\n               pair--;\\n            }\\n            po[p]=v;\\n            if(po[p]==po[p-1] and po[p]!=0 and po[p-1]!=0)\\n            {\\n               pair++;\\n            } \\n            if(po[p]==po[p+1] and po[p]!=0 and po[p+1]!=0)\\n            {\\n               pair++;\\n            }\\n            }\\n            } else \\n            if(p==0)\\n            {\\n            if(po[p]!=v){\\n            if(po[p]==po[p+1] and po[p]!=0 and po[p+1]!=0)\\n            {\\n               pair--;\\n            }\\n            po[p]=v; \\n            if(po[p]==po[p+1] and po[p]!=0 and po[p+1]!=0)\\n            {\\n               pair++;\\n            }\\n            }\\n            } else if(p==po.size()-1){\\n            if(po[p]!=v){\\n            if(po[p]==po[p-1] and po[p]!=0 and po[p-1]!=0)\\n            {\\n               pair--;\\n            } \\n            po[p]=v;\\n            if(po[p]==po[p-1] and po[p]!=0 and po[p-1]!=0)\\n            {\\n               pair++;\\n            }\\n            }\\n            }\\n            k.push_back(pair);\\n        }\\n        \\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& vec) {\\n     vector<int>po(n,0);\\n        int  pair=0;\\n        vector<int>k;\\n        if(n==1)\\n        {\\n            vector<int> ppp(vec.size(),0);\\n            return ppp;\\n            \\n        }\\n        for(int i=0;i<vec.size();i++)\\n        {\\n            int p= vec[i][0];\\n            int v= vec[i][1];\\n            if(p>0 and p<po.size()-1)\\n            {\\n            if(po[p]!=v){\\n            if(po[p]==po[p-1] and po[p]!=0 and po[p-1]!=0)\\n            {\\n               pair--;\\n            } \\n            if(po[p]==po[p+1] and po[p]!=0 and po[p+1]!=0)\\n            {\\n               pair--;\\n            }\\n            po[p]=v;\\n            if(po[p]==po[p-1] and po[p]!=0 and po[p-1]!=0)\\n            {\\n               pair++;\\n            } \\n            if(po[p]==po[p+1] and po[p]!=0 and po[p+1]!=0)\\n            {\\n               pair++;\\n            }\\n            }\\n            } else \\n            if(p==0)\\n            {\\n            if(po[p]!=v){\\n            if(po[p]==po[p+1] and po[p]!=0 and po[p+1]!=0)\\n            {\\n               pair--;\\n            }\\n            po[p]=v; \\n            if(po[p]==po[p+1] and po[p]!=0 and po[p+1]!=0)\\n            {\\n               pair++;\\n            }\\n            }\\n            } else if(p==po.size()-1){\\n            if(po[p]!=v){\\n            if(po[p]==po[p-1] and po[p]!=0 and po[p-1]!=0)\\n            {\\n               pair--;\\n            } \\n            po[p]=v;\\n            if(po[p]==po[p-1] and po[p]!=0 and po[p-1]!=0)\\n            {\\n               pair++;\\n            }\\n            }\\n            }\\n            k.push_back(pair);\\n        }\\n        \\n        return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532125,
                "title": "java-c-python-o-m-with-explanation",
                "content": "# TL;DR\\n\\n``` java []\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        var nums = new int[n];\\n        var adjacentSameColor = new int[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            if (i > 0) {\\n                adjacentSameColor[i] = adjacentSameColor[i - 1];\\n            }\\n\\n            int index = queries[i][0];\\n            int newColor = queries[i][1];\\n            int oldColor = nums[index];\\n            nums[index] = newColor;\\n\\n\\n            if (newColor == oldColor) {\\n                continue;\\n            }\\n            if (index > 0) {\\n                if (oldColor != 0 && nums[index - 1] == oldColor) {\\n                    adjacentSameColor[i]--;\\n                }\\n                if (nums[index - 1] == newColor) {\\n                    adjacentSameColor[i]++;\\n                }\\n            }\\n            if (index < n - 1) {\\n                if (oldColor != 0 && nums[index + 1] == oldColor) {\\n                    adjacentSameColor[i]--;\\n                }\\n                if (nums[index + 1] == newColor) {\\n                    adjacentSameColor[i]++;\\n                }\\n            }\\n        }\\n        return adjacentSameColor;\\n    }\\n}\\n```\\n``` cpp []\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        std::vector<int> nums(n, 0);\\n        std::vector<int> adjacentSameColor(queries.size(), 0);\\n        for (int i = 0; i < queries.size(); i++) {\\n            if (i > 0) {\\n                adjacentSameColor[i] = adjacentSameColor[i - 1];\\n            }\\n\\n            int index = queries[i][0];\\n            int newColor = queries[i][1];\\n            int oldColor = nums[index];\\n            nums[index] = newColor;\\n\\n            if (newColor == oldColor) {\\n                continue;\\n            }\\n            if (index > 0) {\\n                if (oldColor != 0 && nums[index - 1] == oldColor) {\\n                    adjacentSameColor[i]--;\\n                }\\n                if (nums[index - 1] == newColor) {\\n                    adjacentSameColor[i]++;\\n                }\\n            }\\n            if (index < n - 1) {\\n                if (oldColor != 0 && nums[index + 1] == oldColor) {\\n                    adjacentSameColor[i]--;\\n                }\\n                if (nums[index + 1] == newColor) {\\n                    adjacentSameColor[i]++;\\n                }\\n            }\\n        }\\n        return adjacentSameColor;\\n    }\\n};\\n```\\n``` python3 []\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n        nums = [0] * n\\n        adjacentSameColor = [0] * len(queries)\\n        for i in range(len(queries)):\\n            if i > 0:\\n                adjacentSameColor[i] = adjacentSameColor[i - 1]\\n\\n            index = queries[i][0]\\n            newColor = queries[i][1]\\n            oldColor = nums[index]\\n            nums[index] = newColor\\n\\n            if newColor == oldColor:\\n                continue\\n            if index > 0:\\n                if oldColor != 0 and nums[index - 1] == oldColor:\\n                    adjacentSameColor[i] -= 1\\n                if nums[index - 1] == newColor:\\n                    adjacentSameColor[i] += 1\\n            if index < n - 1:\\n                if oldColor != 0 and nums[index + 1] == oldColor:\\n                    adjacentSameColor[i] -= 1\\n                if nums[index + 1] == newColor:\\n                    adjacentSameColor[i] += 1\\n        return adjacentSameColor\\n```\\n\\n---\\n#### \\u26A0\\uFE0F Don\\'t forget to upvote if you like the content below. \\uD83D\\uDE43\\n---\\n\\n\\n# Intuition \\n\\nIn the problem, we\\'re only changing the color of one element at a time, and we need to find the number of adjacent elements with the same color. This tells us that after each operation, the number of adjacent elements with the same color can change by at most 2 (one on either side of the colored index). Therefore, instead of recalculating the number of adjacent elements with the same color for the whole array after each operation, we can just track the changes at the colored index.\\n\\n# Approach\\n\\n1. **Initialize `nums` and `adjacentSameColor` arrays**: Create an array `nums` of size `n` initialized with zeros to represent the uncolored elements, and an array `adjacentSameColor` of the same size as `queries` to store the number of adjacent elements with the same color for each query.\\n\\n2. **Iterate over `queries`**: For each query, get the index `index` and the new color `newColor` to be applied. Also, store the old color of the element at index `index` in the `nums` array.\\n\\n3. **Update color and count adjacent elements with same color**: Update the color at `index` in `nums` with `newColor`. If `newColor` is different from `oldColor`, check the elements adjacent to `index` in `nums`. If any of them have the same color as `oldColor` or `newColor`, update the count in `adjacentSameColor` accordingly.\\n\\n4. **Return the result**: After iterating over all queries, return the `adjacentSameColor` array.\\n\\n# Complexity Analysis\\n\\n- **Time Complexity**: The time complexity is $$O(m)$$, where $$m$$ is the number of queries. This is because we\\'re iterating over the list of queries once.\\n\\n- **Space Complexity**: The space complexity is $$O(n + m)$$, as we use an array to store the colors of the elements and another array to store the results for each query.",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        var nums = new int[n];\\n        var adjacentSameColor = new int[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            if (i > 0) {\\n                adjacentSameColor[i] = adjacentSameColor[i - 1];\\n            }\\n\\n            int index = queries[i][0];\\n            int newColor = queries[i][1];\\n            int oldColor = nums[index];\\n            nums[index] = newColor;\\n\\n\\n            if (newColor == oldColor) {\\n                continue;\\n            }\\n            if (index > 0) {\\n                if (oldColor != 0 && nums[index - 1] == oldColor) {\\n                    adjacentSameColor[i]--;\\n                }\\n                if (nums[index - 1] == newColor) {\\n                    adjacentSameColor[i]++;\\n                }\\n            }\\n            if (index < n - 1) {\\n                if (oldColor != 0 && nums[index + 1] == oldColor) {\\n                    adjacentSameColor[i]--;\\n                }\\n                if (nums[index + 1] == newColor) {\\n                    adjacentSameColor[i]++;\\n                }\\n            }\\n        }\\n        return adjacentSameColor;\\n    }\\n}\\n```\n``` cpp []\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        std::vector<int> nums(n, 0);\\n        std::vector<int> adjacentSameColor(queries.size(), 0);\\n        for (int i = 0; i < queries.size(); i++) {\\n            if (i > 0) {\\n                adjacentSameColor[i] = adjacentSameColor[i - 1];\\n            }\\n\\n            int index = queries[i][0];\\n            int newColor = queries[i][1];\\n            int oldColor = nums[index];\\n            nums[index] = newColor;\\n\\n            if (newColor == oldColor) {\\n                continue;\\n            }\\n            if (index > 0) {\\n                if (oldColor != 0 && nums[index - 1] == oldColor) {\\n                    adjacentSameColor[i]--;\\n                }\\n                if (nums[index - 1] == newColor) {\\n                    adjacentSameColor[i]++;\\n                }\\n            }\\n            if (index < n - 1) {\\n                if (oldColor != 0 && nums[index + 1] == oldColor) {\\n                    adjacentSameColor[i]--;\\n                }\\n                if (nums[index + 1] == newColor) {\\n                    adjacentSameColor[i]++;\\n                }\\n            }\\n        }\\n        return adjacentSameColor;\\n    }\\n};\\n```\n``` python3 []\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n        nums = [0] * n\\n        adjacentSameColor = [0] * len(queries)\\n        for i in range(len(queries)):\\n            if i > 0:\\n                adjacentSameColor[i] = adjacentSameColor[i - 1]\\n\\n            index = queries[i][0]\\n            newColor = queries[i][1]\\n            oldColor = nums[index]\\n            nums[index] = newColor\\n\\n            if newColor == oldColor:\\n                continue\\n            if index > 0:\\n                if oldColor != 0 and nums[index - 1] == oldColor:\\n                    adjacentSameColor[i] -= 1\\n                if nums[index - 1] == newColor:\\n                    adjacentSameColor[i] += 1\\n            if index < n - 1:\\n                if oldColor != 0 and nums[index + 1] == oldColor:\\n                    adjacentSameColor[i] -= 1\\n                if nums[index + 1] == newColor:\\n                    adjacentSameColor[i] += 1\\n        return adjacentSameColor\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529769,
                "title": "easy-approach-with-comment-as-per-hint",
                "content": "```\\nclass Solution\\n{\\n\\tpublic:\\n\\t\\tvector<int> colorTheArray(int n, vector<vector < int>> &queries)\\n\\t\\t{\\n\\t\\t\\tvector<int> nums(n, 0);\\n\\t\\t\\tvector<int> ans(queries.size());\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor (int i = 0; i < queries.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint idx = queries[i][0];\\n\\n\\t\\t\\t\\t// If an element that is changed on the i-th query had the same color as its right  element answer decreases by 1. Similarly contributes its left element too.\\n\\n\\t\\t\\t\\tif (nums[idx] != 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (idx != 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif (nums[idx] == nums[idx - 1])\\n\\t\\t\\t\\t\\t\\t\\tcount--;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif (idx != n - 1)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif (nums[idx] == nums[idx + 1])\\n\\t\\t\\t\\t\\t\\t\\tcount--;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n      \\n\\t     // puting the color of queries in nums \\n\\t\\t\\t\\tnums[queries[i][0]] = queries[i][1];\\n\\n\\t\\t\\t\\t// After changing the color, if the element has the same color as its right element   answer increases by 1. Similarly contributes its left element too.\\n\\t\\t\\t\\tif (nums[idx] != 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (idx != 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif (queries[i][1] == nums[idx - 1])\\n\\t\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif (idx != n - 1)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif (queries[i][1] == nums[idx + 1])\\n\\t\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tans[i] = count;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\n\\tpublic:\\n\\t\\tvector<int> colorTheArray(int n, vector<vector < int>> &queries)\\n\\t\\t{\\n\\t\\t\\tvector<int> nums(n, 0);\\n\\t\\t\\tvector<int> ans(queries.size());\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor (int i = 0; i < queries.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint idx = queries[i][0];\\n\\n\\t\\t\\t\\t// If an element that is changed on the i-th query had the same color as its right  element answer decreases by 1. Similarly contributes its left element too.\\n\\n\\t\\t\\t\\tif (nums[idx] != 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (idx != 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif (nums[idx] == nums[idx - 1])\\n\\t\\t\\t\\t\\t\\t\\tcount--;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif (idx != n - 1)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif (nums[idx] == nums[idx + 1])\\n\\t\\t\\t\\t\\t\\t\\tcount--;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n      \\n\\t     // puting the color of queries in nums \\n\\t\\t\\t\\tnums[queries[i][0]] = queries[i][1];\\n\\n\\t\\t\\t\\t// After changing the color, if the element has the same color as its right element   answer increases by 1. Similarly contributes its left element too.\\n\\t\\t\\t\\tif (nums[idx] != 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (idx != 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif (queries[i][1] == nums[idx - 1])\\n\\t\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif (idx != n - 1)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif (queries[i][1] == nums[idx + 1])\\n\\t\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tans[i] = count;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525936,
                "title": "counting-solution-for-c-explanation-complexity",
                "content": "# Approach\\nIt\\'s the task of counting. For each query, we will track if there is a difference between the current and neighboring values.\\nWe need to check two variants: if the neighbor is equal to the new value, and if we break the same color, like:\\n - Input array: 0 0 0 0, counter: 0\\n - Query 1: 0 1 0 0, counter: 0\\n - Query 2: 0 1 1 0, counter: 1\\n - Query 3: 0 1 1 1, counter: 2\\n  - Query 4: 0 1 0 1, counter: 0\\n\\nSo:\\n- We check index and index+1. If the old value equals index+1 value then decrement the counter (query 4);\\n- If the new value equals index+1 value then increment the counter (query 2 and 3).\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\npublic int[] ColorAdjacentElements(int[][] queries, int n)\\n{\\n    var result = new int[queries.Length];\\n\\n    var colors = new int[n];\\n    var currentNeighbors = 0;\\n\\n    for (var i = 0; i < queries.Length; i++)\\n    {\\n        var index = queries[i][0];\\n        var color = queries[i][1];\\n\\n        currentNeighbors += Check(colors, colors[index], color, index - 1);\\n        currentNeighbors += Check(colors, colors[index], color, index + 1);\\n\\n        colors[index] = color;\\n        result[i] = currentNeighbors;\\n    }\\n\\n    return result;\\n}\\n\\nprivate int Check(int[] colors, int oldColor, int newColor, int neighborIndex)\\n{\\n    if (neighborIndex == -1 || neighborIndex == colors.Length)\\n    {\\n        return 0;\\n    }\\n\\n    if (oldColor == newColor)\\n    {\\n        return 0;\\n    }\\n\\n    if (colors[neighborIndex] == 0)\\n    {\\n        return 0;\\n    }\\n\\n    var neighborColor = colors[neighborIndex];\\n\\n    if (newColor == neighborColor)\\n    {\\n        return 1;\\n    }\\n\\n    return oldColor == neighborColor ? -1 : 0;\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic int[] ColorAdjacentElements(int[][] queries, int n)\\n{\\n    var result = new int[queries.Length];\\n\\n    var colors = new int[n];\\n    var currentNeighbors = 0;\\n\\n    for (var i = 0; i < queries.Length; i++)\\n    {\\n        var index = queries[i][0];\\n        var color = queries[i][1];\\n\\n        currentNeighbors += Check(colors, colors[index], color, index - 1);\\n        currentNeighbors += Check(colors, colors[index], color, index + 1);\\n\\n        colors[index] = color;\\n        result[i] = currentNeighbors;\\n    }\\n\\n    return result;\\n}\\n\\nprivate int Check(int[] colors, int oldColor, int newColor, int neighborIndex)\\n{\\n    if (neighborIndex == -1 || neighborIndex == colors.Length)\\n    {\\n        return 0;\\n    }\\n\\n    if (oldColor == newColor)\\n    {\\n        return 0;\\n    }\\n\\n    if (colors[neighborIndex] == 0)\\n    {\\n        return 0;\\n    }\\n\\n    var neighborColor = colors[neighborIndex];\\n\\n    if (newColor == neighborColor)\\n    {\\n        return 1;\\n    }\\n\\n    return oldColor == neighborColor ? -1 : 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3520100,
                "title": "java-o-m-optimal-solution-easy-explanation-beginner-friendly",
                "content": "\\n\\n# Complexity\\n- Time complexity: **O(m)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(m+n)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# PLEASE UPVOTE !! **If you liked my solution**\\n\\n**Code WITHOUT COMMENTS BELOW**\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] q) {\\n        int m=q.length;\\n        int[] ans=new int[m];    //ans array\\n        int[] ar=new int[n];    // array to store color\\n\\n        for(int i=0;i<m;i++){\\n            int p=q[i][0];     //position of element to be changed color of\\n            int c=q[i][1];     // new color\\n            int k=0;           //no. of adjeacent elements with same colors changed can be negative if new color breaks the adjaceny and positive if new color is equal to adjacent\\n            if(ar[p]==0){\\n                //if element has no color just check if new color is equal to adjacent color ans increment k\\n                ar[p]=c;\\n                if(p-1>=0 && ar[p-1]==c){\\n                    k++;\\n                    \\n                }\\n                if(p+1<n && ar[p+1]==c){\\n                    k++;\\n                }\\n\\n            }else{\\n\\n                int j=ar[p];  //old color at position p\\n                ar[p]=c;       // changed to new color\\n\\n                //if old color equal to adjecent elements decrement k and if equal to new color increment k\\n                if(p-1>=0){\\n                    if(ar[p-1]==j){\\n                    \\n                        k--;\\n                    }\\n                    if(ar[p-1]==c){\\n                        k++;\\n                    }\\n                }\\n                if(p+1<n){\\n                     if(ar[p+1]==j){\\n                        k--;\\n                    }\\n                    if(ar[p+1]==c){\\n                        k++;\\n                    }\\n                }\\n            }\\n            if(i>0){\\n                ans[i]=ans[i-1] + k;   //add k to prev ans\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n# Code Without Comments\\n```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] q) {\\n        int m=q.length;\\n        int[] ans=new int[m];    \\n        int[] ar=new int[n];   \\n\\n        for(int i=0;i<m;i++){\\n            int p=q[i][0];    \\n            int c=q[i][1];     \\n            int k=0;           \\n            if(ar[p]==0){\\n                ar[p]=c;\\n                if(p-1>=0 && ar[p-1]==c){\\n                    k++;\\n                }\\n                if(p+1<n && ar[p+1]==c){\\n                    k++;\\n                }\\n            }else{\\n                int j=ar[p];\\n                ar[p]=c;\\n                if(p-1>=0){\\n                    if(ar[p-1]==j){\\n                        k--;\\n                    }\\n                    if(ar[p-1]==c){\\n                        k++;\\n                    }\\n                }\\n                if(p+1<n){\\n                     if(ar[p+1]==j){\\n                        k--;\\n                    }\\n                    if(ar[p+1]==c){\\n                        k++;\\n                    }\\n                }\\n            }\\n            if(i>0){\\n                ans[i]=ans[i-1] + k;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] q) {\\n        int m=q.length;\\n        int[] ans=new int[m];    //ans array\\n        int[] ar=new int[n];    // array to store color\\n\\n        for(int i=0;i<m;i++){\\n            int p=q[i][0];     //position of element to be changed color of\\n            int c=q[i][1];     // new color\\n            int k=0;           //no. of adjeacent elements with same colors changed can be negative if new color breaks the adjaceny and positive if new color is equal to adjacent\\n            if(ar[p]==0){\\n                //if element has no color just check if new color is equal to adjacent color ans increment k\\n                ar[p]=c;\\n                if(p-1>=0 && ar[p-1]==c){\\n                    k++;\\n                    \\n                }\\n                if(p+1<n && ar[p+1]==c){\\n                    k++;\\n                }\\n\\n            }else{\\n\\n                int j=ar[p];  //old color at position p\\n                ar[p]=c;       // changed to new color\\n\\n                //if old color equal to adjecent elements decrement k and if equal to new color increment k\\n                if(p-1>=0){\\n                    if(ar[p-1]==j){\\n                    \\n                        k--;\\n                    }\\n                    if(ar[p-1]==c){\\n                        k++;\\n                    }\\n                }\\n                if(p+1<n){\\n                     if(ar[p+1]==j){\\n                        k--;\\n                    }\\n                    if(ar[p+1]==c){\\n                        k++;\\n                    }\\n                }\\n            }\\n            if(i>0){\\n                ans[i]=ans[i-1] + k;   //add k to prev ans\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] q) {\\n        int m=q.length;\\n        int[] ans=new int[m];    \\n        int[] ar=new int[n];   \\n\\n        for(int i=0;i<m;i++){\\n            int p=q[i][0];    \\n            int c=q[i][1];     \\n            int k=0;           \\n            if(ar[p]==0){\\n                ar[p]=c;\\n                if(p-1>=0 && ar[p-1]==c){\\n                    k++;\\n                }\\n                if(p+1<n && ar[p+1]==c){\\n                    k++;\\n                }\\n            }else{\\n                int j=ar[p];\\n                ar[p]=c;\\n                if(p-1>=0){\\n                    if(ar[p-1]==j){\\n                        k--;\\n                    }\\n                    if(ar[p-1]==c){\\n                        k++;\\n                    }\\n                }\\n                if(p+1<n){\\n                     if(ar[p+1]==j){\\n                        k--;\\n                    }\\n                    if(ar[p+1]==c){\\n                        k++;\\n                    }\\n                }\\n            }\\n            if(i>0){\\n                ans[i]=ans[i-1] + k;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519954,
                "title": "python-n-2-linear-with-example",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    typically with problems like this i always ask if its really needed to \\n    to check the entire array for the matching neighbors\\n\\n    try to think about what the change effects and if it affects the entire\\n    colors array or not\\n\\n    you see that it only changes the relationship to its buddys next to it\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    on color change look at its neighbors\\n\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def colorTheArray(self, n, queries):\\n        \"\"\"\\n        :type n: int\\n        :type queries: List[List[int]]\\n        :rtype: List[int]\\n\\n\\n\\n        my basic starting soln\\n\\n        colors = [0]*n\\n        ans = [0]*len(queries)\\n        for i in range(len(queries)):\\n            idx,c = queries[i]\\n            colors[idx] = c\\n            # check for adj color\\n            amt = 0\\n        .  we optimize this by only looking at the neighbors of the changed idx\\n            # as a change at idx only affects the two neighbors next to it\\n\\n            for j in range(len(colors)-1):\\n                if colors[j] and colors[j] ==colors[j+1]:\\n                    amt+=1\\n            ans[i] = amt\\n\\n        return ans\\n\\n\\n        how change affects neighbors \\n        when the changing idx is the middle number\\n        101 -- > 111        amt + 2 \\n        102 -- > 112        amt + 1 \\n        102 -- > 132        amt + 0\\n        112 -- > 102        amt - 1\\n        111 -- > 101        amt  2 \\n\\n        color not changing \\n        111 -- > 111        amt + 0\\n        111 -- > 112        amt + 0\\n\\n        \"\"\"\\n\\n\\n        \\n        # edge ase\\n        if n == 1:\\n            return [0]*len(queries)\\n\\n\\n        colors = [0]*n\\n        ans = [0]*len(queries)\\n\\n        # total same color next to each other\\n        self.amt = 0\\n\\n        def calc_change(idx,nc):\\n\\n            # no change to color at idx\\n            if colors[idx] == nc:\\n                return \\n\\n            # forward 1 neighbor only \\n            if idx == 0:\\n                neighbors = [1]\\n\\n            # back 1 neighbor only \\n            elif idx == len(colors)-1:\\n                neighbors = [-1]\\n\\n            # both forward and back neighbors\\n            else:\\n                neighbors = [1,-1]\\n\\n            # for each neighbor see the change\\n            for dx in neighbors:\\n                # neighbors colors were not eq but now WILL be after change\\n                if colors[idx+dx] and colors[idx+dx] != colors[idx] and colors[idx+dx] == nc:\\n                    self.amt += 1\\n                # neighbors colors were eq but now will NOT be after change\\n                elif colors[idx+dx] and colors[idx+dx] == colors[idx] and colors[idx+dx] != nc:\\n                    self.amt -= 1\\n            # color\\n            colors[idx] = nc\\n\\n            \\n\\n\\n\\n        for i in range(len(queries)):\\n\\n            idx,c = queries[i]\\n\\n            calc_change(idx,c)\\n            \\n            ans[i] = self.amt\\n\\n        return ans\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def colorTheArray(self, n, queries):\\n        \"\"\"\\n        :type n: int\\n        :type queries: List[List[int]]\\n        :rtype: List[int]\\n\\n\\n\\n        my basic starting soln\\n\\n        colors = [0]*n\\n        ans = [0]*len(queries)\\n        for i in range(len(queries)):\\n            idx,c = queries[i]\\n            colors[idx] = c\\n            # check for adj color\\n            amt = 0\\n        .  we optimize this by only looking at the neighbors of the changed idx\\n            # as a change at idx only affects the two neighbors next to it\\n\\n            for j in range(len(colors)-1):\\n                if colors[j] and colors[j] ==colors[j+1]:\\n                    amt+=1\\n            ans[i] = amt\\n\\n        return ans\\n\\n\\n        how change affects neighbors \\n        when the changing idx is the middle number\\n        101 -- > 111        amt + 2 \\n        102 -- > 112        amt + 1 \\n        102 -- > 132        amt + 0\\n        112 -- > 102        amt - 1\\n        111 -- > 101        amt  2 \\n\\n        color not changing \\n        111 -- > 111        amt + 0\\n        111 -- > 112        amt + 0\\n\\n        \"\"\"\\n\\n\\n        \\n        # edge ase\\n        if n == 1:\\n            return [0]*len(queries)\\n\\n\\n        colors = [0]*n\\n        ans = [0]*len(queries)\\n\\n        # total same color next to each other\\n        self.amt = 0\\n\\n        def calc_change(idx,nc):\\n\\n            # no change to color at idx\\n            if colors[idx] == nc:\\n                return \\n\\n            # forward 1 neighbor only \\n            if idx == 0:\\n                neighbors = [1]\\n\\n            # back 1 neighbor only \\n            elif idx == len(colors)-1:\\n                neighbors = [-1]\\n\\n            # both forward and back neighbors\\n            else:\\n                neighbors = [1,-1]\\n\\n            # for each neighbor see the change\\n            for dx in neighbors:\\n                # neighbors colors were not eq but now WILL be after change\\n                if colors[idx+dx] and colors[idx+dx] != colors[idx] and colors[idx+dx] == nc:\\n                    self.amt += 1\\n                # neighbors colors were eq but now will NOT be after change\\n                elif colors[idx+dx] and colors[idx+dx] == colors[idx] and colors[idx+dx] != nc:\\n                    self.amt -= 1\\n            # color\\n            colors[idx] = nc\\n\\n            \\n\\n\\n\\n        for i in range(len(queries)):\\n\\n            idx,c = queries[i]\\n\\n            calc_change(idx,c)\\n            \\n            ans[i] = self.amt\\n\\n        return ans\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518901,
                "title": "easy-solution-checking-prev-and-next-value-in-each-query-c",
                "content": "# Approach\\n\\nCheck the previous and next place throughout each query if that place is contributing the adjacent condition then decrease (unpaint it) the counter (check for next value and previous value) and after painting it then check again if it is contributing then inc the counter and push the counter value in the answer array.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        int c=0;\\n        vector<int> arr(n,0),ans;\\n        for(auto i:queries){      \\nint prev=i[0]-1;\\nint next=i[0]+1;\\n\\n//checking that if that place satisfies the adjacent condition\\n\\n//if yes then dec the counter for prev and next value respectively\\n            if(prev>=0&&arr[prev]==arr[i[0]]&&arr[i[0]]!=0){\\n                c--;\\n            }\\n            if(next<n&&arr[next]==arr[i[0]]&&arr[i[0]]!=0){\\n                c--;\\n            }\\n\\n//now checking that if the new color would satify the adjacent condition\\n\\n            if(prev>=0&&arr[prev]==i[1]){\\n                c++;\\n            }\\n            if(next<n&&arr[next]==i[1]){\\n                c++;\\n            }\\n\\n//updating the paint array\\n            arr[i[0]]=i[1];\\n//saving c for that query in the ans array\\n            ans.push_back(c);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        int c=0;\\n        vector<int> arr(n,0),ans;\\n        for(auto i:queries){      \\nint prev=i[0]-1;\\nint next=i[0]+1;\\n\\n//checking that if that place satisfies the adjacent condition\\n\\n//if yes then dec the counter for prev and next value respectively\\n            if(prev>=0&&arr[prev]==arr[i[0]]&&arr[i[0]]!=0){\\n                c--;\\n            }\\n            if(next<n&&arr[next]==arr[i[0]]&&arr[i[0]]!=0){\\n                c--;\\n            }\\n\\n//now checking that if the new color would satify the adjacent condition\\n\\n            if(prev>=0&&arr[prev]==i[1]){\\n                c++;\\n            }\\n            if(next<n&&arr[next]==i[1]){\\n                c++;\\n            }\\n\\n//updating the paint array\\n            arr[i[0]]=i[1];\\n//saving c for that query in the ans array\\n            ans.push_back(c);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518473,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        int[] nums = new int[n];\\n        int[] ans = new int[queries.length];\\n        int cnt = 0;\\n        for(int i = 0; i < queries.length; i++)\\n        {\\n            int idx = queries[i][0];\\n            int color = queries[i][1];\\n            int prev = idx > 0 ? nums[idx - 1] : 0;\\n            int nxt  = idx < nums.length - 1 ? nums[idx + 1] : 0;\\n            if(nums[idx] != 0 && nums[idx] == prev)\\n                cnt--;\\n\\n            if(nums[idx] != 0 && nums[idx] == nxt)\\n                cnt--;\\n\\n            nums[idx] = color;\\n\\n            if(nums[idx] != 0 && nums[idx] == prev)\\n                cnt++;\\n\\n            if(nums[idx] != 0 && nums[idx] == nxt)\\n                cnt++;\\n\\n            ans[i] = cnt;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        int[] nums = new int[n];\\n        int[] ans = new int[queries.length];\\n        int cnt = 0;\\n        for(int i = 0; i < queries.length; i++)\\n        {\\n            int idx = queries[i][0];\\n            int color = queries[i][1];\\n            int prev = idx > 0 ? nums[idx - 1] : 0;\\n            int nxt  = idx < nums.length - 1 ? nums[idx + 1] : 0;\\n            if(nums[idx] != 0 && nums[idx] == prev)\\n                cnt--;\\n\\n            if(nums[idx] != 0 && nums[idx] == nxt)\\n                cnt--;\\n\\n            nums[idx] = color;\\n\\n            if(nums[idx] != 0 && nums[idx] == prev)\\n                cnt++;\\n\\n            if(nums[idx] != 0 && nums[idx] == nxt)\\n                cnt++;\\n\\n            ans[i] = cnt;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516673,
                "title": "c-easy-to-understand-just-some-bunch-of-if-else-counting",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries){\\n        vector<int>arr(n,0);\\n        vector<int>ans(queries.size(),0);\\n        int count=0;\\n        if(n<=1)return ans;\\n        for(int i=0;i<ans.size();i++){\\n            \\n            int index=queries[i][0];\\n            int val=queries[i][1];\\n            //blank position\\n            if(arr[index]==0){\\n                \\n                if(index==0 || index==n-1){\\n                    if(index==0){\\n                    arr[index]=val;\\n                    if(arr[index]==arr[index+1])count++;\\n                    }else{\\n                    arr[index]=val;\\n                    if(arr[index]==arr[index-1])count++;\\n                    }\\n                }\\n                else{\\n                if(arr[index-1]==val && arr[index+1]==val && val!=arr[index])count+=2;\\n                else if(arr[index-1]==val && val!=arr[index])count++;\\n                else if(arr[index+1]==val && val!=arr[index])count++;\\n                arr[index]=val;\\n                }\\n            }\\n            else{\\n                if(arr[index]==val){\\n                    ans[i]=count;\\n                    /*for(auto i:arr)cout<<i<<\" \";\\n                    cout<<\" \"<<count<<endl;*/\\n                    continue;\\n                }\\n                if(index==0 || index==n-1){\\n                    if(index==0){\\n                        \\n                        if(arr[index]==arr[index+1] && val!=arr[index])count--;\\n                        arr[index]=val;\\n                        if(arr[index]==arr[index+1])count++;\\n                        \\n                    }else{\\n                        \\n                        if(arr[index]==arr[index-1] && val!=arr[index])count--;\\n                        arr[index]=val;\\n                        if(arr[index]==arr[index-1])count++;\\n                    }\\n                }\\n                else{\\n                \\n\\n                if((arr[index]==arr[index-1] || arr[index]==arr[index+1])){\\n                    if(arr[index]==arr[index-1] && arr[index]==arr[index+1])count-=2;\\n                    else if(arr[index-1]==arr[index]){\\n                        count--;\\n                    }\\n                    else if(arr[index+1]==arr[index]){\\n                        count--;\\n                    }\\n                }\\n                arr[index]=val;\\n                if(arr[index]==arr[index-1])count++;\\n                if(arr[index]==arr[index+1])count++;\\n                }\\n            }\\n            /*for(auto i:arr)cout<<i<<\" \";\\n            cout<<\" \"<<count<<endl;*/\\n            ans[i]=count;\\n        }\\n        return ans;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries){\\n        vector<int>arr(n,0);\\n        vector<int>ans(queries.size(),0);\\n        int count=0;\\n        if(n<=1)return ans;\\n        for(int i=0;i<ans.size();i++){\\n            \\n            int index=queries[i][0];\\n            int val=queries[i][1];\\n            //blank position\\n            if(arr[index]==0){\\n                \\n                if(index==0 || index==n-1){\\n                    if(index==0){\\n                    arr[index]=val;\\n                    if(arr[index]==arr[index+1])count++;\\n                    }else{\\n                    arr[index]=val;\\n                    if(arr[index]==arr[index-1])count++;\\n                    }\\n                }\\n                else{\\n                if(arr[index-1]==val && arr[index+1]==val && val!=arr[index])count+=2;\\n                else if(arr[index-1]==val && val!=arr[index])count++;\\n                else if(arr[index+1]==val && val!=arr[index])count++;\\n                arr[index]=val;\\n                }\\n            }\\n            else{\\n                if(arr[index]==val){\\n                    ans[i]=count;\\n                    /*for(auto i:arr)cout<<i<<\" \";\\n                    cout<<\" \"<<count<<endl;*/\\n                    continue;\\n                }\\n                if(index==0 || index==n-1){\\n                    if(index==0){\\n                        \\n                        if(arr[index]==arr[index+1] && val!=arr[index])count--;\\n                        arr[index]=val;\\n                        if(arr[index]==arr[index+1])count++;\\n                        \\n                    }else{\\n                        \\n                        if(arr[index]==arr[index-1] && val!=arr[index])count--;\\n                        arr[index]=val;\\n                        if(arr[index]==arr[index-1])count++;\\n                    }\\n                }\\n                else{\\n                \\n\\n                if((arr[index]==arr[index-1] || arr[index]==arr[index+1])){\\n                    if(arr[index]==arr[index-1] && arr[index]==arr[index+1])count-=2;\\n                    else if(arr[index-1]==arr[index]){\\n                        count--;\\n                    }\\n                    else if(arr[index+1]==arr[index]){\\n                        count--;\\n                    }\\n                }\\n                arr[index]=val;\\n                if(arr[index]==arr[index-1])count++;\\n                if(arr[index]==arr[index+1])count++;\\n                }\\n            }\\n            /*for(auto i:arr)cout<<i<<\" \";\\n            cout<<\" \"<<count<<endl;*/\\n            ans[i]=count;\\n        }\\n        return ans;  \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3513783,
                "title": "2672-number-of-adjacent-elements-with-the-same-color",
                "content": "Explanation:\\nTaking a count variable to track before changing the color at concerned index if in its right or left same color was present decrement count respectively in both positions however, if after changing color same color is present in either left or right neighbour increase the count respectively. Please upvote if you like:\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        int m = queries.size();\\n        vector<int> answer(m,0);\\n        vector<int> nums(n,0);\\n        int count=0;\\n        for(int i=0;i<m;i++){\\n            vector<int> jk = queries[i];\\n            int ind = jk[0];\\n            int color = jk[1];\\n            if(ind+1<n && nums[ind] != 0 && (nums[ind+1]==nums[ind])){\\n                count--;\\n            }\\n            if(ind-1>=0 && nums[ind] != 0 && (nums[ind-1]==nums[ind])){\\n                count--;\\n            }\\n             nums[ind]=color;\\n            if(ind+1<n && (nums[ind+1]==color)){\\n                count++;\\n            }\\n            if(ind-1>=0 && (nums[ind-1]==color)){\\n                count++;\\n            }\\n          answer[i]=count;\\n            \\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        int m = queries.size();\\n        vector<int> answer(m,0);\\n        vector<int> nums(n,0);\\n        int count=0;\\n        for(int i=0;i<m;i++){\\n            vector<int> jk = queries[i];\\n            int ind = jk[0];\\n            int color = jk[1];\\n            if(ind+1<n && nums[ind] != 0 && (nums[ind+1]==nums[ind])){\\n                count--;\\n            }\\n            if(ind-1>=0 && nums[ind] != 0 && (nums[ind-1]==nums[ind])){\\n                count--;\\n            }\\n             nums[ind]=color;\\n            if(ind+1<n && (nums[ind+1]==color)){\\n                count++;\\n            }\\n            if(ind-1>=0 && (nums[ind-1]==color)){\\n                count++;\\n            }\\n          answer[i]=count;\\n            \\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513528,
                "title": "c-counting-based-solution",
                "content": "# Intuition\\nSimple Counting Based Solution\\n\\n# Approach\\nTry adjusting both the neighbours using an array (initially all elements = 0)\\n\\n# Complexity\\n- Time complexity:  $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int>ans;\\n        vector<int>curr(n,0);\\n        int c = 0;\\n        for(auto x:queries)\\n        {\\n             int pos = x[0];\\n             int col = x[1];\\n           \\n            if(pos-1>=0&&curr[pos]==curr[pos-1]&&curr[pos]>0)\\n                  c--;\\n            if(pos-1>=0&&curr[pos-1]==col)\\n                 c++;\\n            if(pos+1<n&&curr[pos]==curr[pos+1]&&curr[pos]>0)\\n                 c--;\\n            if(pos+1<n&&curr[pos+1]==col)\\n                  c++;\\n\\n            curr[pos] = col;\\n            ans.push_back(c);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int>ans;\\n        vector<int>curr(n,0);\\n        int c = 0;\\n        for(auto x:queries)\\n        {\\n             int pos = x[0];\\n             int col = x[1];\\n           \\n            if(pos-1>=0&&curr[pos]==curr[pos-1]&&curr[pos]>0)\\n                  c--;\\n            if(pos-1>=0&&curr[pos-1]==col)\\n                 c++;\\n            if(pos+1<n&&curr[pos]==curr[pos+1]&&curr[pos]>0)\\n                 c--;\\n            if(pos+1<n&&curr[pos+1]==col)\\n                  c++;\\n\\n            curr[pos] = col;\\n            ans.push_back(c);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513323,
                "title": "easy-cpp-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        \\n        int arr[n];\\n        \\n        for(int x=0;x<n;x++)\\n            arr[x]=0;\\n        \\n        vector<int>ans;\\n        int count = 0;\\n        \\n        for(int x=0;x<queries.size();x++){\\n            \\n            int i = queries[x][0];\\n            int c = queries[x][1];\\n            \\n            if(c!=arr[i]){\\n                \\n                if(i>0 && arr[i]==arr[i-1] && arr[i]>0){\\n                    count--;\\n                }\\n                if(i<n-1 && arr[i]==arr[i+1] && arr[i]>0){\\n                    count--;\\n                }\\n                \\n                arr[i] = c;\\n                \\n                if(i>0 && arr[i]==arr[i-1] && arr[i]>0){\\n                    count++;\\n                }\\n                if(i<n-1 && arr[i]==arr[i+1] && arr[i]>0){\\n                    count++;\\n                }\\n                \\n            }\\n            \\n            ans.push_back(count);\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        \\n        int arr[n];\\n        \\n        for(int x=0;x<n;x++)\\n            arr[x]=0;\\n        \\n        vector<int>ans;\\n        int count = 0;\\n        \\n        for(int x=0;x<queries.size();x++){\\n            \\n            int i = queries[x][0];\\n            int c = queries[x][1];\\n            \\n            if(c!=arr[i]){\\n                \\n                if(i>0 && arr[i]==arr[i-1] && arr[i]>0){\\n                    count--;\\n                }\\n                if(i<n-1 && arr[i]==arr[i+1] && arr[i]>0){\\n                    count--;\\n                }\\n                \\n                arr[i] = c;\\n                \\n                if(i>0 && arr[i]==arr[i-1] && arr[i]>0){\\n                    count++;\\n                }\\n                if(i<n-1 && arr[i]==arr[i+1] && arr[i]>0){\\n                    count++;\\n                }\\n                \\n            }\\n            \\n            ans.push_back(count);\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3512932,
                "title": "intuitive-approach-c",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsimply keep in mind that the maximum number of times the ans may change by altering one colour is simply 2, once on the left and once on the right, while the rest stays the same. When you understand this, it is quite easy.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        vector<int> arr(n, 0); // Array to store the colors\\n        int tans = 0; // Variable to track the count of adjacent elements with the same color\\n\\n        for (int i = 0; i < queries.size(); i++) {\\n            int index = queries[i][0];\\n            int newColor = queries[i][1];\\n            int oldColor = arr[index];\\n\\n            if (oldColor) {\\n                // Check if the old color is non-zero, which means it\\'s already colored\\n                // Need to subtract the adjacent count if reducing the number of adjacent elements\\n\\n                // Check the element after the current index\\n                if (index != n - 1 && arr[index] == arr[index + 1]) {\\n                    tans--;\\n                }\\n\\n                // Check the element before the current index\\n                if (index != 0 && arr[index] == arr[index - 1]) {\\n                    tans--;\\n                }\\n            }\\n\\n            // Assign the new color to the array\\n            arr[index] = newColor;\\n\\n            // Check the element after the current index\\n            if (index != n - 1 && arr[index] == arr[index + 1]) {\\n                tans++;\\n            }\\n\\n            // Check the element before the current index\\n            if (index != 0 && arr[index] == arr[index - 1]) {\\n                tans++;\\n            }\\n\\n            ans.push_back(tans); // Store the current count in the result vector\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        vector<int> arr(n, 0); // Array to store the colors\\n        int tans = 0; // Variable to track the count of adjacent elements with the same color\\n\\n        for (int i = 0; i < queries.size(); i++) {\\n            int index = queries[i][0];\\n            int newColor = queries[i][1];\\n            int oldColor = arr[index];\\n\\n            if (oldColor) {\\n                // Check if the old color is non-zero, which means it\\'s already colored\\n                // Need to subtract the adjacent count if reducing the number of adjacent elements\\n\\n                // Check the element after the current index\\n                if (index != n - 1 && arr[index] == arr[index + 1]) {\\n                    tans--;\\n                }\\n\\n                // Check the element before the current index\\n                if (index != 0 && arr[index] == arr[index - 1]) {\\n                    tans--;\\n                }\\n            }\\n\\n            // Assign the new color to the array\\n            arr[index] = newColor;\\n\\n            // Check the element after the current index\\n            if (index != n - 1 && arr[index] == arr[index + 1]) {\\n                tans++;\\n            }\\n\\n            // Check the element before the current index\\n            if (index != 0 && arr[index] == arr[index - 1]) {\\n                tans++;\\n            }\\n\\n            ans.push_back(tans); // Store the current count in the result vector\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3512532,
                "title": "c-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        \\n        int m = queries.size();\\n        vector<int> v(n,0);\\n        \\n        map<int,int> mp;\\n        vector<int> res(m,0);\\n        int cnt = 0;\\n        \\n        for(int i=0 ; i<n ; ++i) mp[i] = 0;\\n        \\n        for(int i=0 ; i<m ; ++i){\\n            \\n            int idx = queries[i][0];\\n            int val = queries[i][1];\\n            int prev = v[idx];\\n            \\n            if(prev == val){\\n                res[i] = cnt;\\n                continue;\\n            }\\n            \\n            if(idx != 0 && v[idx - 1] != 0){\\n                if(v[idx - 1] == val){\\n                   mp[v[idx - 1]] += 1;\\n                   cnt += 1; \\n                }\\n                \\n                if(v[idx - 1] == prev){\\n                    mp[v[idx - 1]] -= 1;\\n                    cnt -= 1;\\n                }\\n            }\\n            \\n            \\n            if(idx != n - 1 && v[idx + 1] != 0){\\n                if(v[idx + 1] == val){\\n                    mp[v[idx]] += 1;\\n                    cnt += 1;\\n                }\\n                \\n                if(v[idx + 1] == prev){\\n                    mp[v[idx]] -= 1;\\n                    cnt -= 1;\\n                }\\n            }\\n            \\n            v[idx] = val;\\n            res[i] = cnt;\\n            \\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        \\n        int m = queries.size();\\n        vector<int> v(n,0);\\n        \\n        map<int,int> mp;\\n        vector<int> res(m,0);\\n        int cnt = 0;\\n        \\n        for(int i=0 ; i<n ; ++i) mp[i] = 0;\\n        \\n        for(int i=0 ; i<m ; ++i){\\n            \\n            int idx = queries[i][0];\\n            int val = queries[i][1];\\n            int prev = v[idx];\\n            \\n            if(prev == val){\\n                res[i] = cnt;\\n                continue;\\n            }\\n            \\n            if(idx != 0 && v[idx - 1] != 0){\\n                if(v[idx - 1] == val){\\n                   mp[v[idx - 1]] += 1;\\n                   cnt += 1; \\n                }\\n                \\n                if(v[idx - 1] == prev){\\n                    mp[v[idx - 1]] -= 1;\\n                    cnt -= 1;\\n                }\\n            }\\n            \\n            \\n            if(idx != n - 1 && v[idx + 1] != 0){\\n                if(v[idx + 1] == val){\\n                    mp[v[idx]] += 1;\\n                    cnt += 1;\\n                }\\n                \\n                if(v[idx + 1] == prev){\\n                    mp[v[idx]] -= 1;\\n                    cnt -= 1;\\n                }\\n            }\\n            \\n            v[idx] = val;\\n            res[i] = cnt;\\n            \\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511172,
                "title": "simple-python3-solution-upto-90-faster-o-n",
                "content": "# Intuition\\nAs we add new element  to the respective index we check if any previous colors are getting affected or not. And as we add the new color to the index position we check if any new similar color pairs are forming and increase or decrease the count(Same color count).\\n\\nAfter each iteration we append the count to the list and return it.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n\\n        res = [0]*(n+1)\\n        same_count = 0\\n\\n        same_count_list =[]\\n        for ind,i in queries:\\n            if res[ind] == 0:\\n                res[ind] = i\\n\\n                if ind-1>=0:\\n                    if res[ind] == res[ind-1]:\\n                        same_count += 1\\n                    \\n                if ind+1<n+1:\\n                    if res[ind] == res[ind+1]:\\n                        same_count += 1\\n            \\n            else:\\n                if ind-1>=0:\\n                    if res[ind] == res[ind-1]:\\n                        same_count -= 1\\n                    \\n                if ind+1<n+1:\\n                    if res[ind] == res[ind+1]:\\n                        same_count -= 1\\n                \\n                res[ind] = i\\n\\n                if ind-1>=0:\\n                    if res[ind] == res[ind-1]:\\n                        same_count += 1\\n                    \\n                if ind+1<n+1:\\n                    if res[ind] == res[ind+1]:\\n                        same_count += 1\\n\\n            same_count_list.append(same_count)\\n\\n        return same_count_list\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n\\n        res = [0]*(n+1)\\n        same_count = 0\\n\\n        same_count_list =[]\\n        for ind,i in queries:\\n            if res[ind] == 0:\\n                res[ind] = i\\n\\n                if ind-1>=0:\\n                    if res[ind] == res[ind-1]:\\n                        same_count += 1\\n                    \\n                if ind+1<n+1:\\n                    if res[ind] == res[ind+1]:\\n                        same_count += 1\\n            \\n            else:\\n                if ind-1>=0:\\n                    if res[ind] == res[ind-1]:\\n                        same_count -= 1\\n                    \\n                if ind+1<n+1:\\n                    if res[ind] == res[ind+1]:\\n                        same_count -= 1\\n                \\n                res[ind] = i\\n\\n                if ind-1>=0:\\n                    if res[ind] == res[ind-1]:\\n                        same_count += 1\\n                    \\n                if ind+1<n+1:\\n                    if res[ind] == res[ind+1]:\\n                        same_count += 1\\n\\n            same_count_list.append(same_count)\\n\\n        return same_count_list\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3508284,
                "title": "counting-adj-same-colors-using-easy-trick-arrays",
                "content": "# Intuition\\nThis problem has a striaght forward intuition that we need to use Arrays for maintaining the colors and count for each query.\\nColors can be stored in array bcoz array size(n) <= 10^5\\n\\n# Approach\\nIn order to evaluate the adjacent count, first of all we should be able to track the number of adjacent elements getting created on each query.\\nlet query has index=i and color=C\\nthen it will be possible to evaluate the contribution it does to the current number of adjacent elements by using:\\n    current adj count = ( (is same as left) + (is same as right) )\\n    i.e. curr += ((color[i-1]==color[i]) + (color[i] == color[i+1]))\\n\\nfor -> color[i-1], either we can add (i>0) in the condition,\\n. . . -> color[i+1], either we can add (i<n) in the condition\\nor else, we can simply create an array of bigger size i.e. n+2\\nand then use 1 based indexing for performing all computations.\\n\\nThe trick is while decreasing the current adjacent element count.\\nWe need to check if the current cell has been already colored or not.\\n\\n# Complexity\\n- Time complexity:\\nHere we are iterating over all queries and computing the current outcome using simple math in O(1). So the time complexity will be O(queries.length)\\n\\n- Space complexity:\\nAs we have created an array of size n (or, n+2)\\nand an array of size queries.length (let queries.length be qlen)\\nIt means that the space complexity will be the max(n,qlen)\\ni.e. O(max(n,qlen))\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> color(n+2, 0);\\n        int i,col,curr(0);\\n        vector<int> ans;\\n\\n        for(auto q : queries){\\n            i = q[0] + 1;\\n            col = q[1];\\n\\n            if(color[i])\\n                curr = curr - ( (color[i-1]==color[i]) + (color[i]==color[i+1]));\\n            color[i] = col;\\n\\n            curr = curr + ( (color[i-1]==color[i]) + (color[i] == color[i+1]));\\n            ans.push_back(curr);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> color(n+2, 0);\\n        int i,col,curr(0);\\n        vector<int> ans;\\n\\n        for(auto q : queries){\\n            i = q[0] + 1;\\n            col = q[1];\\n\\n            if(color[i])\\n                curr = curr - ( (color[i-1]==color[i]) + (color[i]==color[i+1]));\\n            color[i] = col;\\n\\n            curr = curr + ( (color[i-1]==color[i]) + (color[i] == color[i+1]));\\n            ans.push_back(curr);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506420,
                "title": "swift-one-liner",
                "content": "**One-Liner, terse (accepted answer)**\\n```\\nclass Solution {\\n    func colorTheArray(_ n: Int, _ queries: [[Int]]) -> [Int] { \\n        queries.reduce(into: ([Int](),Array(repeating: 0, count: n+2))) { d, q in let i=q[0]+1;func f(_ n:Int) -> Int {(n>0 && n==d.1[i-1] ? 1 : 0) + (n>0 && n==d.1[i+1] ? 1 : 0)};d.0+=[(d.0.last ?? 0)-f(d.1[i])+f(q[1])];d.1[i]=q[1]}.0\\n    }\\n}\\n```\\n**NOTE:** This is technically a one-liner, since the `return` keyword could be omitted.\\n\\n---\\n\\n**One-Liner, expanded and annotated (accepted answer)**\\n```\\nclass Solution {\\n    func colorTheArray(_ n: Int, _ queries: [[Int]]) -> [Int] { \\n        queries.reduce(into: (\\n                result: [Int](),\\n                nums: Array(repeating: 0, count: n+1)\\n        )) { data, q in\\n            func countAdjacents(_ n:Int) -> Int {\\n                n > 0 ? (q[0] > 0 && n==data.nums[q[0]-1] ? 1:0) + (n==data.nums[q[0]+1] ? 1:0) : 0\\n            }                                 \\n            data.result.append((data.result.last ?? 0) - countAdjacents(data.nums[q[0]]) + countAdjacents(q[1]))\\n            data.nums[q[0]] = q[1]\\n        }.result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func colorTheArray(_ n: Int, _ queries: [[Int]]) -> [Int] { \\n        queries.reduce(into: ([Int](),Array(repeating: 0, count: n+2))) { d, q in let i=q[0]+1;func f(_ n:Int) -> Int {(n>0 && n==d.1[i-1] ? 1 : 0) + (n>0 && n==d.1[i+1] ? 1 : 0)};d.0+=[(d.0.last ?? 0)-f(d.1[i])+f(q[1])];d.1[i]=q[1]}.0\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func colorTheArray(_ n: Int, _ queries: [[Int]]) -> [Int] { \\n        queries.reduce(into: (\\n                result: [Int](),\\n                nums: Array(repeating: 0, count: n+1)\\n        )) { data, q in\\n            func countAdjacents(_ n:Int) -> Int {\\n                n > 0 ? (q[0] > 0 && n==data.nums[q[0]-1] ? 1:0) + (n==data.nums[q[0]+1] ? 1:0) : 0\\n            }                                 \\n            data.result.append((data.result.last ?? 0) - countAdjacents(data.nums[q[0]]) + countAdjacents(q[1]))\\n            data.nums[q[0]] = q[1]\\n        }.result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3505362,
                "title": "easy-prefix-sum-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- for first query answer will be zero always \\n- for second query answer will previous answer + something or previous answer-something.\\n- we will add something to previous answer if after coloring the shell its color become same as previous cell or its color become same as next shell\\n- we will subtract something if the cell is alredy colored \\n=> then there is two possibilty \\n    --- previous configuration get disturbed \\n            -----previous config got disturbed \\nif v[ind]==v[ind-1]or v[ind]==v[ind+1]\\n    --- previous configuration does not get disturbed\\n    - subtract as per no. of configuration get destroyed .\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& q) \\n    {\\n        vector<int>ans(q.size(),0);\\n        if (q.size()<=1)\\n        {\\n            return ans; \\n        }\\n        vector<int>v(n,0);\\n        v[q[0][0]]=q[0][1];\\n        for(int i=1;i<q.size();i++)\\n        {\\n            int temp=0;\\n            int ind=q[i][0];\\n            int col=q[i][1];\\n            if (v[ind]==0)\\n            {\\n                if (ind-1>=0 && v[ind-1]==col)\\n                {\\n                    temp++;\\n                }\\n                if (ind+1<v.size() && v[ind+1]==col)\\n                {\\n                    temp++;\\n                }\\n            }\\n            else \\n            {\\n                \\n                if (ind-1>=0 && v[ind-1]==v[ind])\\n                {\\n                    temp--;\\n                }\\n                if (ind+1<v.size() && v[ind+1]==v[ind])\\n                {\\n                    temp--;\\n                }\\n                if (ind-1>=0 && v[ind-1]==col)\\n                {\\n                    temp++;\\n                }\\n                if (ind+1<v.size() && v[ind+1]==col)\\n                {\\n                    temp++;\\n                }\\n            }\\n            temp+=ans[i-1];\\n            ans[i]=temp;\\n            v[ind]=col;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& q) \\n    {\\n        vector<int>ans(q.size(),0);\\n        if (q.size()<=1)\\n        {\\n            return ans; \\n        }\\n        vector<int>v(n,0);\\n        v[q[0][0]]=q[0][1];\\n        for(int i=1;i<q.size();i++)\\n        {\\n            int temp=0;\\n            int ind=q[i][0];\\n            int col=q[i][1];\\n            if (v[ind]==0)\\n            {\\n                if (ind-1>=0 && v[ind-1]==col)\\n                {\\n                    temp++;\\n                }\\n                if (ind+1<v.size() && v[ind+1]==col)\\n                {\\n                    temp++;\\n                }\\n            }\\n            else \\n            {\\n                \\n                if (ind-1>=0 && v[ind-1]==v[ind])\\n                {\\n                    temp--;\\n                }\\n                if (ind+1<v.size() && v[ind+1]==v[ind])\\n                {\\n                    temp--;\\n                }\\n                if (ind-1>=0 && v[ind-1]==col)\\n                {\\n                    temp++;\\n                }\\n                if (ind+1<v.size() && v[ind+1]==col)\\n                {\\n                    temp++;\\n                }\\n            }\\n            temp+=ans[i-1];\\n            ans[i]=temp;\\n            v[ind]=col;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3505297,
                "title": "typescript-solution",
                "content": "```\\nconst colorTheArray = (n: number, queries: number[][]): number[] => {\\n  const colorArr = Array(n);\\n  const adjacentElements = Array(queries.length).fill(0);\\n  let count = 0;\\n\\n  queries.forEach(([index, color], i) => {\\n    const prevColor = colorArr[index];\\n    colorArr[index] = color;\\n\\n    if (prevColor === color) {\\n      adjacentElements[i] = count;\\n      return;\\n    }\\n\\n    if (count && prevColor && colorArr[index - 1] === prevColor) count--;\\n    if (count && prevColor && colorArr[index + 1] === prevColor) count--;\\n\\n    if (colorArr[index - 1] === color) count++;\\n    if (colorArr[index + 1] === color) count++;\\n\\n    adjacentElements[i] = count;\\n  });\\n\\n  return adjacentElements;\\n};\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nconst colorTheArray = (n: number, queries: number[][]): number[] => {\\n  const colorArr = Array(n);\\n  const adjacentElements = Array(queries.length).fill(0);\\n  let count = 0;\\n\\n  queries.forEach(([index, color], i) => {\\n    const prevColor = colorArr[index];\\n    colorArr[index] = color;\\n\\n    if (prevColor === color) {\\n      adjacentElements[i] = count;\\n      return;\\n    }\\n\\n    if (count && prevColor && colorArr[index - 1] === prevColor) count--;\\n    if (count && prevColor && colorArr[index + 1] === prevColor) count--;\\n\\n    if (colorArr[index - 1] === color) count++;\\n    if (colorArr[index + 1] === color) count++;\\n\\n    adjacentElements[i] = count;\\n  });\\n\\n  return adjacentElements;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3505161,
                "title": "simple-observation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int>a(n,0);\\n        int ans=0;\\n        vector<int>result;\\n        for(auto it:queries)\\n        {\\n            int index=it[0];\\n            int col=it[1];\\n            if(a[index]==col)\\n            {\\n                result.push_back(ans);\\n                continue;\\n            }\\n            if(index-1>=0 && a[index-1]==a[index] && a[index]!=0)ans--;\\n            if(index+1<n && a[index+1]==a[index] && a[index]!=0)ans--;\\n            if(index-1>=0 && col==a[index-1])ans++;\\n            if(index+1<n && col==a[index+1])ans++;\\n            a[index]=col;\\n            result.push_back(ans);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int>a(n,0);\\n        int ans=0;\\n        vector<int>result;\\n        for(auto it:queries)\\n        {\\n            int index=it[0];\\n            int col=it[1];\\n            if(a[index]==col)\\n            {\\n                result.push_back(ans);\\n                continue;\\n            }\\n            if(index-1>=0 && a[index-1]==a[index] && a[index]!=0)ans--;\\n            if(index+1<n && a[index+1]==a[index] && a[index]!=0)ans--;\\n            if(index-1>=0 && col==a[index-1])ans++;\\n            if(index+1<n && col==a[index+1])ans++;\\n            a[index]=col;\\n            result.push_back(ans);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3505024,
                "title": "simple-c-solution-with-cases",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> res;\\n        vector<int> org(n,0);\\n        int count = 0;\\n        for(int i=0;i<queries.size();i++){\\n            int ind = queries[i][0], color = queries[i][1], curr = org[ind];\\n            // Case 1.2 - If Current is Not Coloured AND Left Index has same color value\\n            if(curr == 0 && ind-1 >=0 && org[ind-1] == color)\\n               count++;\\n            \\n            // Case 1.2 - If Current is Not Coloured AND Right Index has same color value\\n            if(curr == 0 && ind+1 < n && org[ind+1] == color)\\n                count++;\\n            \\n            \\n            // Case 2.1 - If Current is Coloured AND Left Index color matches with Current AND color being applied is diff\\n            if(curr != 0 &&  ind-1 >= 0 && org[ind-1] == curr && org[ind-1] != color)\\n               count--;\\n            \\n            // Case 2.1 - If Current->Coloured AND Left Index color doesn\\'t matches with Current AND color being applied matches\\n            if(curr != 0 &&  ind-1 >= 0 && org[ind-1] != curr && org[ind-1] == color)\\n                count++;\\n            \\n            // Case 2.3 - If Current is Coloured AND Right Index color matches with Current AND color being applied is diff\\n            if(curr != 0 &&  ind+1 < n && org[ind+1] == curr && org[ind+1] != color)\\n               count--;\\n            \\n            // Case 2.4 - If Current->Coloured AND Right Index color doesn\\'t matches with Current AND color being applied matches\\n            if(curr != 0 &&  ind+1 < n && org[ind+1] != curr && org[ind+1] == color)\\n                count++;\\n            \\n            res.push_back(count);\\n            org[ind] = color;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> res;\\n        vector<int> org(n,0);\\n        int count = 0;\\n        for(int i=0;i<queries.size();i++){\\n            int ind = queries[i][0], color = queries[i][1], curr = org[ind];\\n            // Case 1.2 - If Current is Not Coloured AND Left Index has same color value\\n            if(curr == 0 && ind-1 >=0 && org[ind-1] == color)\\n               count++;\\n            \\n            // Case 1.2 - If Current is Not Coloured AND Right Index has same color value\\n            if(curr == 0 && ind+1 < n && org[ind+1] == color)\\n                count++;\\n            \\n            \\n            // Case 2.1 - If Current is Coloured AND Left Index color matches with Current AND color being applied is diff\\n            if(curr != 0 &&  ind-1 >= 0 && org[ind-1] == curr && org[ind-1] != color)\\n               count--;\\n            \\n            // Case 2.1 - If Current->Coloured AND Left Index color doesn\\'t matches with Current AND color being applied matches\\n            if(curr != 0 &&  ind-1 >= 0 && org[ind-1] != curr && org[ind-1] == color)\\n                count++;\\n            \\n            // Case 2.3 - If Current is Coloured AND Right Index color matches with Current AND color being applied is diff\\n            if(curr != 0 &&  ind+1 < n && org[ind+1] == curr && org[ind+1] != color)\\n               count--;\\n            \\n            // Case 2.4 - If Current->Coloured AND Right Index color doesn\\'t matches with Current AND color being applied matches\\n            if(curr != 0 &&  ind+1 < n && org[ind+1] != curr && org[ind+1] == color)\\n                count++;\\n            \\n            res.push_back(count);\\n            org[ind] = color;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503548,
                "title": "python-solution-o-m-beats-100-solns",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind all the cases where adjacent elements can change.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThere are four main cases where adjacent elements can change : \\n1. If previous index has same color.\\n2. if next index has same color.\\n3. if previous and current index already had same color,i.e, they were already adjacent elements.\\n4. if current and next indexes already had same color,i.e, they were already adjacent elements.\\n\\n# Complexity\\n- Time complexity: O(m) , where m is number of queries. \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) , if we account for the answer array that should be returned.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n        nums = n*[0] #nums is an array of length n, initially uncolored\\n        adj_elements = 0\\n        answer = len(queries)*[0]\\n        for i in range(len(queries)):\\n            index = queries[i][0] #current query index\\n            color = queries[i][1] #current query color\\n            \\n            #if index == 0, there are no previous elements\\n            if index !=0 :\\n                if nums[index - 1] == color:\\n                    adj_elements += 1\\n                if nums[index - 1] == nums[index] and nums[index] != 0:\\n                    adj_elements -=1\\n            #if index == last index then there are no next index\\n            if index != n-1:\\n                if nums[index + 1] == color:\\n                    adj_elements += 1\\n                if nums[index + 1] == nums[index] and nums[index] != 0:\\n                    adj_elements -=1  \\n            answer[i] = adj_elements\\n            nums[index] = color\\n            \\n        return answer\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n        nums = n*[0] #nums is an array of length n, initially uncolored\\n        adj_elements = 0\\n        answer = len(queries)*[0]\\n        for i in range(len(queries)):\\n            index = queries[i][0] #current query index\\n            color = queries[i][1] #current query color\\n            \\n            #if index == 0, there are no previous elements\\n            if index !=0 :\\n                if nums[index - 1] == color:\\n                    adj_elements += 1\\n                if nums[index - 1] == nums[index] and nums[index] != 0:\\n                    adj_elements -=1\\n            #if index == last index then there are no next index\\n            if index != n-1:\\n                if nums[index + 1] == color:\\n                    adj_elements += 1\\n                if nums[index + 1] == nums[index] and nums[index] != 0:\\n                    adj_elements -=1  \\n            answer[i] = adj_elements\\n            nums[index] = color\\n            \\n        return answer\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503296,
                "title": "simple-counting-c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries)\\n    {\\n        int size = queries.size(); \\n        vector<int> ans(size,0);\\n        vector<int> temp(n,0);\\n        int count =0;\\n        for(int i=0; i<size;i++)\\n        {\\n            int index = queries[i][0];\\n            int color = queries[i][1];\\n\\n            int prevcol = (index-1<0)?0:temp[index-1];    \\n            int nextcol = (index+1>=n)?0:temp[index+1];\\n            int oldcol = temp[index];\\n            \\n            temp[index] = color;\\n//checking old color contribution if there remove it\\n            if(oldcol!=0 && oldcol==prevcol)\\n            count--;\\n            if(oldcol!=0 && oldcol==nextcol)\\n            count--;\\n//adding new color contribution\\n            if(color==prevcol)\\n            count++;\\n            if(color==nextcol)\\n            count++;\\n\\n            ans[i] = count;\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries)\\n    {\\n        int size = queries.size(); \\n        vector<int> ans(size,0);\\n        vector<int> temp(n,0);\\n        int count =0;\\n        for(int i=0; i<size;i++)\\n        {\\n            int index = queries[i][0];\\n            int color = queries[i][1];\\n\\n            int prevcol = (index-1<0)?0:temp[index-1];    \\n            int nextcol = (index+1>=n)?0:temp[index+1];\\n            int oldcol = temp[index];\\n            \\n            temp[index] = color;\\n//checking old color contribution if there remove it\\n            if(oldcol!=0 && oldcol==prevcol)\\n            count--;\\n            if(oldcol!=0 && oldcol==nextcol)\\n            count--;\\n//adding new color contribution\\n            if(color==prevcol)\\n            count++;\\n            if(color==nextcol)\\n            count++;\\n\\n            ans[i] = count;\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503272,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        int qlen=queries.length;\\n        int ans[]=new int[qlen];\\n        int color[]=new int[n];\\n        int prevAdj=0;\\n        for(int i=0;i<qlen;i++){\\n            int left=0,right=0,qidx=queries[i][0],qcol=queries[i][1];\\n            if(qidx>0&&color[qidx]!=0) left=color[qidx]==color[qidx-1]?1:0;\\n            if(qidx<n-1&&color[qidx]!=0) right=color[qidx]==color[qidx+1]?1:0;\\n            ans[i]+=prevAdj-left-right;\\n            color[qidx]=qcol;\\n            if(qidx>0&&color[qidx]!=0) left=color[qidx]==color[qidx-1]?1:0;\\n            if(qidx<n-1&&color[qidx]!=0) right=color[qidx]==color[qidx+1]?1:0;\\n            ans[i]+=left+right;\\n            prevAdj=ans[i];\\n        }\\n        return ans;\\n    }\\n}//upvote if helpful...\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        int qlen=queries.length;\\n        int ans[]=new int[qlen];\\n        int color[]=new int[n];\\n        int prevAdj=0;\\n        for(int i=0;i<qlen;i++){\\n            int left=0,right=0,qidx=queries[i][0],qcol=queries[i][1];\\n            if(qidx>0&&color[qidx]!=0) left=color[qidx]==color[qidx-1]?1:0;\\n            if(qidx<n-1&&color[qidx]!=0) right=color[qidx]==color[qidx+1]?1:0;\\n            ans[i]+=prevAdj-left-right;\\n            color[qidx]=qcol;\\n            if(qidx>0&&color[qidx]!=0) left=color[qidx]==color[qidx-1]?1:0;\\n            if(qidx<n-1&&color[qidx]!=0) right=color[qidx]==color[qidx+1]?1:0;\\n            ans[i]+=left+right;\\n            prevAdj=ans[i];\\n        }\\n        return ans;\\n    }\\n}//upvote if helpful...\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502431,
                "title": "rust-solution",
                "content": "\\n```\\nimpl Solution {\\n    pub fn color_the_array(n: i32, queries: Vec<Vec<i32>>) -> Vec<i32> {\\n        let mut colours = vec![0; n as usize + 2];\\n        let mut res = vec![];\\n        let mut adjacent = 0;\\n\\n        for q in queries {\\n            let (i, colour) = (q[0] as usize + 1, q[1]);\\n\\n            if colours[i] != 0 {\\n                // Check the previous colour against its adjacent colours.\\n                match (colours[i - 1] == colours[i], colours[i + 1] == colours[i]) {\\n                    (true, true) => adjacent -= 2,\\n                    (false, false) => (),\\n                    _ => adjacent -= 1,\\n                }\\n            }\\n\\n            colours[i] = colour;\\n            // Check the new colour against its adjacent colours.\\n            match (colours[i - 1] == colours[i], colours[i + 1] == colours[i]) {\\n                (true, true) => adjacent += 2,\\n                (false, false) => (),\\n                _ => adjacent += 1,\\n            }\\n\\n            res.push(adjacent)\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn color_the_array(n: i32, queries: Vec<Vec<i32>>) -> Vec<i32> {\\n        let mut colours = vec![0; n as usize + 2];\\n        let mut res = vec![];\\n        let mut adjacent = 0;\\n\\n        for q in queries {\\n            let (i, colour) = (q[0] as usize + 1, q[1]);\\n\\n            if colours[i] != 0 {\\n                // Check the previous colour against its adjacent colours.\\n                match (colours[i - 1] == colours[i], colours[i + 1] == colours[i]) {\\n                    (true, true) => adjacent -= 2,\\n                    (false, false) => (),\\n                    _ => adjacent -= 1,\\n                }\\n            }\\n\\n            colours[i] = colour;\\n            // Check the new colour against its adjacent colours.\\n            match (colours[i - 1] == colours[i], colours[i + 1] == colours[i]) {\\n                (true, true) => adjacent += 2,\\n                (false, false) => (),\\n                _ => adjacent += 1,\\n            }\\n\\n            res.push(adjacent)\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3502290,
                "title": "c-counting",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> color(n), ans;\\n        int count = 0;\\n        for(vector<int> query: queries) {\\n            if(query[0] != 0) \\n                count -= color[query[0]] != 0? color[query[0]] == color[query[0] - 1]: 0;\\n            if(query[0] != n - 1) \\n                count -= color[query[0]] != 0? color[query[0]] == color[query[0] + 1]: 0;\\n            color[query[0]] = query[1];\\n            if(query[0] != 0) \\n                count += color[query[0]] == color[query[0] - 1];\\n            if(query[0] != n - 1) \\n                count += color[query[0]] == color[query[0] + 1];\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> color(n), ans;\\n        int count = 0;\\n        for(vector<int> query: queries) {\\n            if(query[0] != 0) \\n                count -= color[query[0]] != 0? color[query[0]] == color[query[0] - 1]: 0;\\n            if(query[0] != n - 1) \\n                count -= color[query[0]] != 0? color[query[0]] == color[query[0] + 1]: 0;\\n            color[query[0]] = query[1];\\n            if(query[0] != 0) \\n                count += color[query[0]] == color[query[0] - 1];\\n            if(query[0] != n - 1) \\n                count += color[query[0]] == color[query[0] + 1];\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502245,
                "title": "direct-counting-increment-decrement-solution-python",
                "content": "Note that the problem asks to find answer[i]\\'s where answer[i] is the number of adjacent elements with the same color after the ith query. So it is an accumulated counting. Therefore, after each querey in the for-loop, we do not reset the running variable `cnt`.\\n\\n```\\n\"\"\"\\nWhen the color at index i is changed, we check the the colors at indices i-1 and\\ni+1 when they are in bound.\\n\\nIn the solution, to avoid check i - 1 >= 0 and i + 1 < n, we made an array of size\\nn + 2, and making the indexing in queries to be 1-indexing. This is purely for convenience.\\n\"\"\"\\n\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n        \\n        array = [0] * (n + 2)\\n        \\n        res = []\\n        cnt = 0\\n        for q in queries:\\n            i, color = q[0] + 1, q[1]\\n            if array[i] != 0:\\n                if array[i] == array[i+1]:\\n                    cnt -= 1\\n                if array[i] == array[i-1]:\\n                    cnt -= 1\\n                \\n            array[i] = color\\n            if array[i] == array[i+1]:\\n                cnt += 1\\n            if array[i] == array[i-1]:\\n                cnt += 1\\n                \\n            res.append(cnt)\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\"\"\"\\nWhen the color at index i is changed, we check the the colors at indices i-1 and\\ni+1 when they are in bound.\\n\\nIn the solution, to avoid check i - 1 >= 0 and i + 1 < n, we made an array of size\\nn + 2, and making the indexing in queries to be 1-indexing. This is purely for convenience.\\n\"\"\"\\n\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n        \\n        array = [0] * (n + 2)\\n        \\n        res = []\\n        cnt = 0\\n        for q in queries:\\n            i, color = q[0] + 1, q[1]\\n            if array[i] != 0:\\n                if array[i] == array[i+1]:\\n                    cnt -= 1\\n                if array[i] == array[i-1]:\\n                    cnt -= 1\\n                \\n            array[i] = color\\n            if array[i] == array[i+1]:\\n                cnt += 1\\n            if array[i] == array[i-1]:\\n                cnt += 1\\n                \\n            res.append(cnt)\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3501529,
                "title": "fast-elegant-rust-solution",
                "content": "```rust\\nimpl Solution {\\n  pub fn color_the_array(n: i32, queries: Vec<Vec<i32>>) -> Vec<i32> {\\n    let n = n as usize;\\n    let m = n - 1;\\n    let mut colors = vec![0; n];\\n    let mut sum = 0;\\n    queries\\n      .iter()\\n      .map(|query| {\\n        let index = query[0] as usize;\\n        let curr = query[1];\\n        let prev = colors[index];\\n        if prev == curr {\\n          return sum;\\n        }\\n        let mut f = |color, aug| {\\n          if index > 0 && colors[index - 1] == color {\\n            sum += aug;\\n          }\\n          if index < m && colors[index + 1] == color {\\n            sum += aug;\\n          }\\n          true\\n        };\\n        prev > 0 && f(prev, -1);\\n        f(curr, 1);\\n        colors[index] = curr;\\n        return sum;\\n      })\\n      .collect()\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n  pub fn color_the_array(n: i32, queries: Vec<Vec<i32>>) -> Vec<i32> {\\n    let n = n as usize;\\n    let m = n - 1;\\n    let mut colors = vec![0; n];\\n    let mut sum = 0;\\n    queries\\n      .iter()\\n      .map(|query| {\\n        let index = query[0] as usize;\\n        let curr = query[1];\\n        let prev = colors[index];\\n        if prev == curr {\\n          return sum;\\n        }\\n        let mut f = |color, aug| {\\n          if index > 0 && colors[index - 1] == color {\\n            sum += aug;\\n          }\\n          if index < m && colors[index + 1] == color {\\n            sum += aug;\\n          }\\n          true\\n        };\\n        prev > 0 && f(prev, -1);\\n        f(curr, 1);\\n        colors[index] = curr;\\n        return sum;\\n      })\\n      .collect()\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3501417,
                "title": "java-o-n-solution-addduplicates-minusduplicates",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(k) k is the length of queries.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n + k) k is the length of queries.\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        int[] colors = new int[n];\\n        int[] res = new int[queries.length];\\n        int duplicate = 0;\\n        for(int i = 0; i < queries.length; ++i){\\n            int idx = queries[i][0];\\n            int color = colors[idx];\\n            if(color != 0){\\n                if(idx >= 1 && color == colors[idx - 1])\\n                    duplicate--;\\n                if(idx < n - 1 && color == colors[idx + 1])\\n                    duplicate--;\\n            }\\n            color = queries[i][1];\\n            if(idx >= 1 && color == colors[idx - 1])\\n                duplicate++;\\n            if(idx < n - 1 && color == colors[idx + 1])\\n                duplicate++;\\n            colors[idx] = color;\\n            res[i] = duplicate;\\n            // System.out.println(Arrays.toString(colors) + \" \" + duplicate);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        int[] colors = new int[n];\\n        int[] res = new int[queries.length];\\n        int duplicate = 0;\\n        for(int i = 0; i < queries.length; ++i){\\n            int idx = queries[i][0];\\n            int color = colors[idx];\\n            if(color != 0){\\n                if(idx >= 1 && color == colors[idx - 1])\\n                    duplicate--;\\n                if(idx < n - 1 && color == colors[idx + 1])\\n                    duplicate--;\\n            }\\n            color = queries[i][1];\\n            if(idx >= 1 && color == colors[idx - 1])\\n                duplicate++;\\n            if(idx < n - 1 && color == colors[idx + 1])\\n                duplicate++;\\n            colors[idx] = color;\\n            res[i] = duplicate;\\n            // System.out.println(Arrays.toString(colors) + \" \" + duplicate);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3501070,
                "title": "java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        int[] arr=new int[n];\\n        int[] ans=new int[queries.length];\\n        int c=0;\\n        for(int i=0;i<queries.length;i++){\\n            int ind=queries[i][0];\\n            int col=queries[i][1];\\n            if(ind>=1&&arr[ind-1]==arr[ind]&&arr[ind]!=0){\\n                c--;\\n            }\\n            if(ind+1<n&&arr[ind+1]==arr[ind]&&arr[ind]!=0){\\n                c--;\\n            }\\n            arr[ind]=col;\\n            if(ind>=1&&arr[ind-1]==arr[ind]&&arr[ind]!=0){\\n                c++;\\n            }\\n            if(ind+1<n&&arr[ind+1]==arr[ind]&&arr[ind]!=0){\\n                c++;\\n            }\\n            ans[i]=c;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        int[] arr=new int[n];\\n        int[] ans=new int[queries.length];\\n        int c=0;\\n        for(int i=0;i<queries.length;i++){\\n            int ind=queries[i][0];\\n            int col=queries[i][1];\\n            if(ind>=1&&arr[ind-1]==arr[ind]&&arr[ind]!=0){\\n                c--;\\n            }\\n            if(ind+1<n&&arr[ind+1]==arr[ind]&&arr[ind]!=0){\\n                c--;\\n            }\\n            arr[ind]=col;\\n            if(ind>=1&&arr[ind-1]==arr[ind]&&arr[ind]!=0){\\n                c++;\\n            }\\n            if(ind+1<n&&arr[ind+1]==arr[ind]&&arr[ind]!=0){\\n                c++;\\n            }\\n            ans[i]=c;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3500861,
                "title": "you-won-t-regret-reading-it-intuition-explained-very-easy-to-understand",
                "content": "**Please upvote if useful!** \\n\\nThe given problem involves coloring elements in an array and counting the number of adjacent elements with the same color after each query.\\n\\nHere\\'s the **intuition** behind it:\\n\\n1.  ***\\'colors\\'*** array will store the colors assigned to each element in the array, and ***\\'answer\\'*** will store the count of adjacent elements with the same color after each query.\\n2. ***\\'numberOfPairs\\'*** variable is used to keep track of the count of adjacent pairs with the same color.\\n3.  Iterate through each query in the ***\\'queries\\'*** array. For each query:\\n\\t* Check if the color at the given index is already assigned in the ***\\'colors\\'*** array. If it is, it means that we are overriding the color at that index with a new color.\\n\\t\\t1. If the color at the previous index (index-1) is the same as the current color, it implies that we had a pair of adjacent elements with the same color before the query. By overriding the color, we lose one pair, **so we decrement \\'numberOfPairs\\' by 1**.\\n\\t\\t2. If the color at the next index (index+1) is the same as the current color, it means we had a pair of adjacent elements with the same color after the query. **Again, we decrement \\'numberOfPairs\\' by 1**.\\n\\t* Update the \\'colors\\' array with the new color at the given index. After updating color:\\n\\t* Check if the color at the previous index (index-1) is the same as the current color. If it is, we have a new pair of adjacent elements with the same color, **so we increment \\'numberOfPairs\\' by 1**.\\n\\t* Check if the color at the next index (index+1) is the same as the current color. If it is, we have another pair of adjacent elements with the same color, **so we increment \\'numberOfPairs\\' by 1**.\\n4.  Store the current value of \\'numberOfPairs\\' in the \\'answer\\' array for the corresponding query.\\n\\n```\\npublic int[] colorTheArray(int n, int[][] queries) {\\n        int [] colors = new int[n];\\n        int [] answer = new int[queries.length];\\n        \\n        int numberOfPairs = 0;\\n        \\n        for(int i=0;i<queries.length;i++){\\n            int index = queries[i][0];\\n            int color = queries[i][1];\\n            \\n            if(colors[index] != 0){\\n                if(index-1 >= 0 && colors[index-1] == colors[index]){\\n                    numberOfPairs--;\\n                }\\n                if(index+1 < n && colors[index+1] == colors[index]){\\n                    numberOfPairs--;\\n                }\\n            }\\n            \\n            colors[index] = color;\\n            \\n            if(index-1 >= 0 && colors[index-1] == colors[index]){\\n                numberOfPairs++;\\n            }\\n            if(index+1 < n && colors[index+1] == colors[index]){\\n                numberOfPairs++;\\n            }\\n            \\n            answer[i] = numberOfPairs;\\n        }\\n        \\n        return answer;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Counting"
                ],
                "code": "```\\npublic int[] colorTheArray(int n, int[][] queries) {\\n        int [] colors = new int[n];\\n        int [] answer = new int[queries.length];\\n        \\n        int numberOfPairs = 0;\\n        \\n        for(int i=0;i<queries.length;i++){\\n            int index = queries[i][0];\\n            int color = queries[i][1];\\n            \\n            if(colors[index] != 0){\\n                if(index-1 >= 0 && colors[index-1] == colors[index]){\\n                    numberOfPairs--;\\n                }\\n                if(index+1 < n && colors[index+1] == colors[index]){\\n                    numberOfPairs--;\\n                }\\n            }\\n            \\n            colors[index] = color;\\n            \\n            if(index-1 >= 0 && colors[index-1] == colors[index]){\\n                numberOfPairs++;\\n            }\\n            if(index+1 < n && colors[index+1] == colors[index]){\\n                numberOfPairs++;\\n            }\\n            \\n            answer[i] = numberOfPairs;\\n        }\\n        \\n        return answer;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3500698,
                "title": "c-straight-solution-faster-than-67",
                "content": "# Complexity\\n- Time complexity: O(m), here m = query.size() \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) and not O(n+m) as we do not consider the size that we have to return for the answer.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {  \\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& q) {\\n        vector<int> ans (q.size());\\n        vector<int> nums(n+1,0);\\n        int count=0;\\n\\n        for(int i=0;i<q.size();i++)\\n        {   \\n            int index = q[i][0], newcolor = q[i][1];\\n            int initial = nums[index];\\n            nums[index]=newcolor;\\n            \\n            if(initial==newcolor)\\n                {\\n                ans[i]=count;\\n                continue;\\n                }\\n            if(index!=0 && nums[index-1]!=0)\\n            {\\n                if(nums[index-1]==newcolor)\\n                    count++;\\n                else if(nums[index-1]==initial)\\n                    count--;\\n            }\\n            if(index<n && nums[index+1]!=0)\\n            {\\n                if(nums[index+1]==newcolor)\\n                    count++;\\n                else if(nums[index+1]==initial)\\n                   count--;\\n            }     \\n            ans[i]=count;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {  \\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& q) {\\n        vector<int> ans (q.size());\\n        vector<int> nums(n+1,0);\\n        int count=0;\\n\\n        for(int i=0;i<q.size();i++)\\n        {   \\n            int index = q[i][0], newcolor = q[i][1];\\n            int initial = nums[index];\\n            nums[index]=newcolor;\\n            \\n            if(initial==newcolor)\\n                {\\n                ans[i]=count;\\n                continue;\\n                }\\n            if(index!=0 && nums[index-1]!=0)\\n            {\\n                if(nums[index-1]==newcolor)\\n                    count++;\\n                else if(nums[index-1]==initial)\\n                    count--;\\n            }\\n            if(index<n && nums[index+1]!=0)\\n            {\\n                if(nums[index+1]==newcolor)\\n                    count++;\\n                else if(nums[index+1]==initial)\\n                   count--;\\n            }     \\n            ans[i]=count;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3500667,
                "title": "simple-c-solution",
                "content": "C++:\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n\\t\\n        vector<int> col(n,0);   //track color\\n        int ans=0;    //total adjacent \\n        vector<int> adj;   //final vector\\n\\t\\t\\n        for(int i=0;i<queries.size();i++){\\n            int ind=queries[i][0];     //position\\n\\t\\t\\t\\n\\t\\t\\t//checking is changed before or not\\n            if(col[ind]!=0){\\n                if(ind>0 && col[ind-1]==col[ind]){\\n                    ans--;\\n                }\\n                if(ind+1<n && col[ind]==col[ind+1]){\\n                    ans--;\\n                }\\n            }\\n\\t\\t\\t\\n\\t\\t\\t//changing and checking for new color\\n            col[ind]=queries[i][1];\\n            if(ind>0 && col[ind-1]==col[ind]){\\n                ans++;\\n            }\\n            if(ind+1<n && col[ind]==col[ind+1]){\\n                ans++;\\n            }\\n            adj.push_back(ans);\\n        }\\n        return adj;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n\\t\\n        vector<int> col(n,0);   //track color\\n        int ans=0;    //total adjacent \\n        vector<int> adj;   //final vector\\n\\t\\t\\n        for(int i=0;i<queries.size();i++){\\n            int ind=queries[i][0];     //position\\n\\t\\t\\t\\n\\t\\t\\t//checking is changed before or not\\n            if(col[ind]!=0){\\n                if(ind>0 && col[ind-1]==col[ind]){\\n                    ans--;\\n                }\\n                if(ind+1<n && col[ind]==col[ind+1]){\\n                    ans--;\\n                }\\n            }\\n\\t\\t\\t\\n\\t\\t\\t//changing and checking for new color\\n            col[ind]=queries[i][1];\\n            if(ind>0 && col[ind-1]==col[ind]){\\n                ans++;\\n            }\\n            if(ind+1<n && col[ind]==col[ind+1]){\\n                ans++;\\n            }\\n            adj.push_back(ans);\\n        }\\n        return adj;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3500417,
                "title": "easy-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n        A=[0]*n\\n        ans=[]\\n        \\n        for i in queries:\\n            \\n            count=ans[-1] if len(ans)>0 else 0\\n            if i[0] >0 and A[i[0]-1]==A[i[0]] and A[i[0]]!=0:\\n                count-=1\\n            if i[0] <n-1 and A[i[0]+1]==A[i[0]] and A[i[0]]!=0:\\n                count-=1\\n            A[i[0]]=i[1]\\n            if i[0] >0 and A[i[0]-1]==i[1] and A[i[0]]!=0:\\n                count+=1\\n            if i[0] <n-1 and A[i[0]+1]==i[1] and A[i[0]]!=0:\\n                count+=1\\n            \\n            ans.append(count)\\n        return ans\\n    \\n    \\n    \\n   \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n        A=[0]*n\\n        ans=[]\\n        \\n        for i in queries:\\n            \\n            count=ans[-1] if len(ans)>0 else 0\\n            if i[0] >0 and A[i[0]-1]==A[i[0]] and A[i[0]]!=0:\\n                count-=1\\n            if i[0] <n-1 and A[i[0]+1]==A[i[0]] and A[i[0]]!=0:\\n                count-=1\\n            A[i[0]]=i[1]\\n            if i[0] >0 and A[i[0]-1]==i[1] and A[i[0]]!=0:\\n                count+=1\\n            if i[0] <n-1 and A[i[0]+1]==i[1] and A[i[0]]!=0:\\n                count+=1\\n            \\n            ans.append(count)\\n        return ans\\n    \\n    \\n    \\n   \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3500409,
                "title": "c-carry-a-global-variable-for-counting-equal-adj-eles-before-after-executing-coloring-arr-q-i",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf you like explanation,You \\'can\\'..NOT FORCING AT ALL,Upvote! \\nThanks in advance :-)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)..brought from O(n^2) brute force..only due to global variable temp/cnt wise usage!!\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& q) {\\n        int m=q.size(),temp=0,i;\\n        vector<int> nums(n,0),ans(m,0);\\n        for(i=0;i<m;i++){\\n            int idx=q[i][0],clr=q[i][1];\\n            if(idx>0 and nums[idx-1]!=0 and nums[idx-1]==nums[idx]) temp--;\\n            if(idx<n-1 and nums[idx]!=0 and nums[idx]==nums[idx+1]) temp--;\\n            nums[idx]=clr;\\n            if(idx>0 and nums[idx-1]!=0 and nums[idx-1]==nums[idx]) temp++;\\n            if(idx<n-1 and nums[idx]!=0 and nums[idx]==nums[idx+1]) temp++;\\n            ans[i]=temp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& q) {\\n        int m=q.size(),temp=0,i;\\n        vector<int> nums(n,0),ans(m,0);\\n        for(i=0;i<m;i++){\\n            int idx=q[i][0],clr=q[i][1];\\n            if(idx>0 and nums[idx-1]!=0 and nums[idx-1]==nums[idx]) temp--;\\n            if(idx<n-1 and nums[idx]!=0 and nums[idx]==nums[idx+1]) temp--;\\n            nums[idx]=clr;\\n            if(idx>0 and nums[idx-1]!=0 and nums[idx-1]==nums[idx]) temp++;\\n            if(idx<n-1 and nums[idx]!=0 and nums[idx]==nums[idx+1]) temp++;\\n            ans[i]=temp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499151,
                "title": "change-the-score-as-your-color-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> color(n,0);\\n        vector<int> ans;\\n        int score=0;\\n        for (vector<int> &query:queries)\\n        {\\n            int index=query[0];\\n            int new_color=query[1];\\n            if (index-1>=0 && color[index-1]==color[index] && color[index]!=0)\\n               score--;\\n            if (index+1<n && color[index+1]==color[index] && color[index]!=0)\\n               score--;\\n            color[index]=new_color;\\n            if (index-1>=0 && color[index-1]==color[index] && color[index]!=0)\\n               score++;\\n            if (index+1<n && color[index+1]==color[index] && color[index]!=0)\\n               score++;\\n            ans.push_back(score);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> color(n,0);\\n        vector<int> ans;\\n        int score=0;\\n        for (vector<int> &query:queries)\\n        {\\n            int index=query[0];\\n            int new_color=query[1];\\n            if (index-1>=0 && color[index-1]==color[index] && color[index]!=0)\\n               score--;\\n            if (index+1<n && color[index+1]==color[index] && color[index]!=0)\\n               score--;\\n            color[index]=new_color;\\n            if (index-1>=0 && color[index-1]==color[index] && color[index]!=0)\\n               score++;\\n            if (index+1<n && color[index+1]==color[index] && color[index]!=0)\\n               score++;\\n            ans.push_back(score);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3498564,
                "title": "python-dict-with-sets",
                "content": "```\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n        s=0\\n        d=defaultdict(set)\\n        arr=[0 for x in range(n)]\\n        r=[]\\n        for q in queries:\\n            if arr[q[0]]!=0:\\n                d[arr[q[0]]].remove(q[0])\\n                if q[0]+1 in d[arr[q[0]]]:s-=1\\n                if q[0]-1 in d[arr[q[0]]]:s-=1\\n            arr[q[0]]=q[1]\\n            if q[0]+1 in d[arr[q[0]]]:s+=1\\n            if q[0]-1 in d[arr[q[0]]]:s+=1\\n            d[arr[q[0]]].add(q[0])\\n            r.append(s)\\n        return r\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n        s=0\\n        d=defaultdict(set)\\n        arr=[0 for x in range(n)]\\n        r=[]\\n        for q in queries:\\n            if arr[q[0]]!=0:\\n                d[arr[q[0]]].remove(q[0])\\n                if q[0]+1 in d[arr[q[0]]]:s-=1\\n                if q[0]-1 in d[arr[q[0]]]:s-=1\\n            arr[q[0]]=q[1]\\n            if q[0]+1 in d[arr[q[0]]]:s+=1\\n            if q[0]-1 in d[arr[q[0]]]:s+=1\\n            d[arr[q[0]]].add(q[0])\\n            r.append(s)\\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3498549,
                "title": "easy-simple-intuitive-solution-breaking-and-adding-links-using-1-var",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust store value of adjacent occurrences and when new color comes break the link, substract prev occ if it was there and count adjacent colors again add to store value.\\n\\n# Complexity\\n- Time complexity: O(n)\\n     where n=queries.size\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n+m)\\n    where n= n input array size\\n    where m= queries size\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nvector<int> colorTheArray(int n, vector<vector<int>> &queries)\\n{\\n    int qsize = queries.size();\\n    vector<int> res(n);\\n    int curr=0;\\n    vector<int> ans(qsize);\\n\\n    for (int i = 0; i < qsize; i++)\\n    {\\n        int ind = queries[i][0];\\n        int color = queries[i][1];\\n\\n        if (res[ind] != color)\\n        {\\n            int temp = 0;\\n            if (ind-1>=0 && res[ind - 1] == res[ind] && res[ind]!=0)\\n                temp++;\\n            if (ind+1<n && res[ind] == res[ind + 1] && res[ind]!=0)\\n                temp++;\\n\\n            curr -= temp;\\n            temp = 0;\\n            res[ind] = color;\\n            if (ind-1>=0 && res[ind - 1] == res[ind] && res[ind]!=0)\\n                temp++;\\n            if ( ind+1<n && res[ind] == res[ind + 1] && res[ind]!=0)\\n                temp++;\\n            curr += temp;\\n        }\\n        ans[i] = curr;\\n    }\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nvector<int> colorTheArray(int n, vector<vector<int>> &queries)\\n{\\n    int qsize = queries.size();\\n    vector<int> res(n);\\n    int curr=0;\\n    vector<int> ans(qsize);\\n\\n    for (int i = 0; i < qsize; i++)\\n    {\\n        int ind = queries[i][0];\\n        int color = queries[i][1];\\n\\n        if (res[ind] != color)\\n        {\\n            int temp = 0;\\n            if (ind-1>=0 && res[ind - 1] == res[ind] && res[ind]!=0)\\n                temp++;\\n            if (ind+1<n && res[ind] == res[ind + 1] && res[ind]!=0)\\n                temp++;\\n\\n            curr -= temp;\\n            temp = 0;\\n            res[ind] = color;\\n            if (ind-1>=0 && res[ind - 1] == res[ind] && res[ind]!=0)\\n                temp++;\\n            if ( ind+1<n && res[ind] == res[ind + 1] && res[ind]!=0)\\n                temp++;\\n            curr += temp;\\n        }\\n        ans[i] = curr;\\n    }\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3498314,
                "title": "simple-using-set",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& q) {\\n        set<pair<int,int>>s;\\n        vector<int>v(n,0);\\n        vector<int>ans;\\n        for(int i=0;i<q.size();i++){\\n            int id=q[i][0];\\n            int val=q[i][1];\\n            if(s.find({id-1,id})!=s.end()){\\n                s.erase({id-1,id});\\n            }\\n            if(s.find({id,id+1})!=s.end()){\\n                s.erase({id,id+1});\\n            }\\n            \\n            v[id]=val;\\n            if(id>0 && v[id-1]==v[id] && v[id-1]!=0 && v[id]!=0){\\n                s.insert({id-1,id});    \\n            }\\n            if(id<n-1 && v[id]==v[id+1] && v[id+1]!=0 && v[id]!=0){\\n                s.insert({id,id+1});\\n            }\\n            ans.push_back(s.size());\\n            \\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& q) {\\n        set<pair<int,int>>s;\\n        vector<int>v(n,0);\\n        vector<int>ans;\\n        for(int i=0;i<q.size();i++){\\n            int id=q[i][0];\\n            int val=q[i][1];\\n            if(s.find({id-1,id})!=s.end()){\\n                s.erase({id-1,id});\\n            }\\n            if(s.find({id,id+1})!=s.end()){\\n                s.erase({id,id+1});\\n            }\\n            \\n            v[id]=val;\\n            if(id>0 && v[id-1]==v[id] && v[id-1]!=0 && v[id]!=0){\\n                s.insert({id-1,id});    \\n            }\\n            if(id<n-1 && v[id]==v[id+1] && v[id+1]!=0 && v[id]!=0){\\n                s.insert({id,id+1});\\n            }\\n            ans.push_back(s.size());\\n            \\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3498192,
                "title": "javascript-counting",
                "content": "# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} queries\\n * @return {number[]}\\n */\\nvar colorTheArray = function (n, queries) {\\n  let counter = 0;\\n  const colors = new Array(n).fill(0);\\n  const ans = new Array(queries.length).fill();\\n\\n  for (let i = 0; i < queries.length; i++) {\\n    const [idx, color] = queries[i];\\n    const prev = idx - 1 >= 0 ? colors[idx - 1] : 0;\\n    const next = idx + 1 < n ? colors[idx + 1] : 0;\\n\\n    if (colors[idx] === prev && colors[idx] > 0) counter--;\\n    if (colors[idx] === next && colors[idx] > 0) counter--;\\n\\n    colors[idx] = color;\\n\\n    if (colors[idx] === prev && colors[idx] > 0) counter++;\\n    if (colors[idx] === next && colors[idx] > 0) counter++;\\n\\n    ans[i] = counter;\\n  }\\n\\n  return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} queries\\n * @return {number[]}\\n */\\nvar colorTheArray = function (n, queries) {\\n  let counter = 0;\\n  const colors = new Array(n).fill(0);\\n  const ans = new Array(queries.length).fill();\\n\\n  for (let i = 0; i < queries.length; i++) {\\n    const [idx, color] = queries[i];\\n    const prev = idx - 1 >= 0 ? colors[idx - 1] : 0;\\n    const next = idx + 1 < n ? colors[idx + 1] : 0;\\n\\n    if (colors[idx] === prev && colors[idx] > 0) counter--;\\n    if (colors[idx] === next && colors[idx] > 0) counter--;\\n\\n    colors[idx] = color;\\n\\n    if (colors[idx] === prev && colors[idx] > 0) counter++;\\n    if (colors[idx] === next && colors[idx] > 0) counter++;\\n\\n    ans[i] = counter;\\n  }\\n\\n  return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3498185,
                "title": "3-approaches-count-count-with-sentinel-frequency-and-segments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(q)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    // use an array of size n\\n    // maintain a count of adjacent elements\\n    vector<int> colorTheArrayDirectly(int n, vector<vector<int>>& queries) {\\n        vector<int> arr(n, 0);\\n        vector<int> ret;\\n        \\n        int adj = 0;\\n        for (int i = 0; i < queries.size(); i++) {\\n            int idx = queries[i][0];\\n            int color = queries[i][1];\\n\\n            // original color not 0\\n            if (arr[idx] > 0) {\\n                // making arr[idx - 1] not adjacent element\\n                if (idx > 0 && arr[idx - 1] == arr[idx]) {\\n                    adj--;\\n                }\\n                // making add[idx] not an adjacent element\\n                if (idx + 1 < n && arr[idx + 1] == arr[idx]) {\\n                    adj--;\\n                }\\n            }\\n\\n            arr[idx] = color;\\n            if (idx > 0 && arr[idx - 1] == arr[idx]) {\\n                adj++;\\n            }\\n            if (idx + 1 < n && arr[idx] == arr[idx + 1]) {\\n                adj++;\\n            }\\n\\n            ret.push_back(adj);\\n        }\\n\\n        return ret;\\n    }\\n\\n    /*\\n    array of size n:       _ _ _ _ _\\n    array of size n + 2: _ _ _ _ _ _ _\\n    arr[0] and arr[n + 1] act as sentinel of array\\n    so that arr[1] can freely access arr[0] and arr[n] access arr[n + 1]\\n    */\\n    vector<int> colorTheArraySentinel(int n, vector<vector<int>>& queries) {\\n        vector<int> arr(n + 2, 0);\\n        vector<int> ret;\\n\\n        int adj = 0;\\n        for (int i = 0; i < queries.size(); i++) {\\n            // [0, n-1] -> [1, n], arr[0] and arr[n+1] act as sentinel\\n            int idx = queries[i][0] + 1;\\n            int color = queries[i][1];\\n\\n            if (arr[idx] > 0) {\\n                adj -= arr[idx - 1] == arr[idx];\\n                adj -= arr[idx] == arr[idx + 1];\\n            }\\n\\n            arr[idx] = color;\\n            adj += arr[idx - 1] == arr[idx];\\n            adj += arr[idx] == arr[idx + 1];\\n\\n            ret.push_back(adj);\\n        }\\n\\n        return ret;\\n    }\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        // return colorTheArrayDirectly(n, queries);\\n        // return colorTheArraySentinel(n, queries);\\n\\n        /*\\n        adj elements of color = color frequency - color segments\\n        */\\n        vector<int> arr(n, 0), ret;\\n        // total number count\\n        unordered_map<int, int> freq;\\n        // number of segments for each number\\n        unordered_map<int, int> segs;\\n        \\n        // current number of adjacent elements\\n        int curr = 0;\\n        for (int i = 0; i < queries.size(); i++) {\\n            int idx = queries[i][0];\\n            int color = queries[i][1];\\n            \\n            /*\\n            if (arr[idx] == color) {\\n                ret.push_back(curr);\\n                continue;\\n            }\\n            */\\n            \\n            if (arr[idx] > 0) {\\n                bool left = idx > 0 && arr[idx - 1] == arr[idx];\\n                bool right = idx + 1 < n && arr[idx] == arr[idx + 1];\\n                curr -= freq[arr[idx]] - segs[arr[idx]];\\n                \\n                freq[arr[idx]]--;\\n                if (left && right) {\\n                    segs[arr[idx]]++;\\n                } else if (left || right) {\\n                    \\n                } else {\\n                    segs[arr[idx]]--;\\n                }\\n                curr += freq[arr[idx]] - segs[arr[idx]];\\n            }\\n            \\n            // update arr[idx] with color\\n            bool left = idx > 0 && arr[idx - 1] == color;\\n            bool right = idx + 1 < n && arr[idx + 1] == color;\\n            curr -= freq[color] - segs[color];\\n            \\n            freq[color]++;\\n            if (left && right) {\\n                segs[color]--;\\n            } else if (left || right) {\\n                \\n            } else {\\n                segs[color]++;\\n            }\\n            curr += freq[color] - segs[color];\\n            \\n            // std::cout << idx << \" \" << color << \" \" << curr << std::endl;\\n            ret.push_back(curr);\\n            arr[idx] = color;\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    // use an array of size n\\n    // maintain a count of adjacent elements\\n    vector<int> colorTheArrayDirectly(int n, vector<vector<int>>& queries) {\\n        vector<int> arr(n, 0);\\n        vector<int> ret;\\n        \\n        int adj = 0;\\n        for (int i = 0; i < queries.size(); i++) {\\n            int idx = queries[i][0];\\n            int color = queries[i][1];\\n\\n            // original color not 0\\n            if (arr[idx] > 0) {\\n                // making arr[idx - 1] not adjacent element\\n                if (idx > 0 && arr[idx - 1] == arr[idx]) {\\n                    adj--;\\n                }\\n                // making add[idx] not an adjacent element\\n                if (idx + 1 < n && arr[idx + 1] == arr[idx]) {\\n                    adj--;\\n                }\\n            }\\n\\n            arr[idx] = color;\\n            if (idx > 0 && arr[idx - 1] == arr[idx]) {\\n                adj++;\\n            }\\n            if (idx + 1 < n && arr[idx] == arr[idx + 1]) {\\n                adj++;\\n            }\\n\\n            ret.push_back(adj);\\n        }\\n\\n        return ret;\\n    }\\n\\n    /*\\n    array of size n:       _ _ _ _ _\\n    array of size n + 2: _ _ _ _ _ _ _\\n    arr[0] and arr[n + 1] act as sentinel of array\\n    so that arr[1] can freely access arr[0] and arr[n] access arr[n + 1]\\n    */\\n    vector<int> colorTheArraySentinel(int n, vector<vector<int>>& queries) {\\n        vector<int> arr(n + 2, 0);\\n        vector<int> ret;\\n\\n        int adj = 0;\\n        for (int i = 0; i < queries.size(); i++) {\\n            // [0, n-1] -> [1, n], arr[0] and arr[n+1] act as sentinel\\n            int idx = queries[i][0] + 1;\\n            int color = queries[i][1];\\n\\n            if (arr[idx] > 0) {\\n                adj -= arr[idx - 1] == arr[idx];\\n                adj -= arr[idx] == arr[idx + 1];\\n            }\\n\\n            arr[idx] = color;\\n            adj += arr[idx - 1] == arr[idx];\\n            adj += arr[idx] == arr[idx + 1];\\n\\n            ret.push_back(adj);\\n        }\\n\\n        return ret;\\n    }\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        // return colorTheArrayDirectly(n, queries);\\n        // return colorTheArraySentinel(n, queries);\\n\\n        /*\\n        adj elements of color = color frequency - color segments\\n        */\\n        vector<int> arr(n, 0), ret;\\n        // total number count\\n        unordered_map<int, int> freq;\\n        // number of segments for each number\\n        unordered_map<int, int> segs;\\n        \\n        // current number of adjacent elements\\n        int curr = 0;\\n        for (int i = 0; i < queries.size(); i++) {\\n            int idx = queries[i][0];\\n            int color = queries[i][1];\\n            \\n            /*\\n            if (arr[idx] == color) {\\n                ret.push_back(curr);\\n                continue;\\n            }\\n            */\\n            \\n            if (arr[idx] > 0) {\\n                bool left = idx > 0 && arr[idx - 1] == arr[idx];\\n                bool right = idx + 1 < n && arr[idx] == arr[idx + 1];\\n                curr -= freq[arr[idx]] - segs[arr[idx]];\\n                \\n                freq[arr[idx]]--;\\n                if (left && right) {\\n                    segs[arr[idx]]++;\\n                } else if (left || right) {\\n                    \\n                } else {\\n                    segs[arr[idx]]--;\\n                }\\n                curr += freq[arr[idx]] - segs[arr[idx]];\\n            }\\n            \\n            // update arr[idx] with color\\n            bool left = idx > 0 && arr[idx - 1] == color;\\n            bool right = idx + 1 < n && arr[idx + 1] == color;\\n            curr -= freq[color] - segs[color];\\n            \\n            freq[color]++;\\n            if (left && right) {\\n                segs[color]--;\\n            } else if (left || right) {\\n                \\n            } else {\\n                segs[color]++;\\n            }\\n            curr += freq[color] - segs[color];\\n            \\n            // std::cout << idx << \" \" << color << \" \" << curr << std::endl;\\n            ret.push_back(curr);\\n            arr[idx] = color;\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3497938,
                "title": "kotlin-o-n",
                "content": "# Approach\\nWe keep track of color of adjecent neighbours as go through `queries` and make changes. We check color for `i - 1` and `i + 1` both **before** and **after** each change and update our count of number of adjecent elements of color variable `count` and set `res[i]` to `count`\\n\\nTime complexity is $$O(q)$$ where $$q$$ is the size of queries, and space complexity is $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    fun colorTheArray(n: Int, queries: Array<IntArray>): IntArray {\\n        val nums = IntArray(n)\\n\\n        val res = IntArray(queries.size)\\n        var count = 0\\n        for ((i, q) in queries.withIndex()) {\\n            val (e, c) = q\\n            \\n            if (e > 0 && nums[e] != 0 && nums[e - 1] == nums[e]) count--\\n            if (e < n - 1 && nums[e] != 0 && nums[e + 1] == nums[e]) count--\\n\\n            nums[e] = c\\n\\n            if (e > 0 && nums[e] != 0 && nums[e - 1] == nums[e]) count++\\n            if (e < n - 1 && nums[e] != 0 && nums[e + 1] == nums[e]) count++\\n\\n            res[i] = count\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun colorTheArray(n: Int, queries: Array<IntArray>): IntArray {\\n        val nums = IntArray(n)\\n\\n        val res = IntArray(queries.size)\\n        var count = 0\\n        for ((i, q) in queries.withIndex()) {\\n            val (e, c) = q\\n            \\n            if (e > 0 && nums[e] != 0 && nums[e - 1] == nums[e]) count--\\n            if (e < n - 1 && nums[e] != 0 && nums[e + 1] == nums[e]) count--\\n\\n            nums[e] = c\\n\\n            if (e > 0 && nums[e] != 0 && nums[e - 1] == nums[e]) count++\\n            if (e < n - 1 && nums[e] != 0 && nums[e + 1] == nums[e]) count++\\n\\n            res[i] = count\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497911,
                "title": "java-100-speed-43-memory-o-n-in-line-comments",
                "content": "```\\n// Runtime: 5 ms, faster than 100.00% of Java online submissions for Number of Adjacent Elements With the Same Color.\\n// Memory Usage: 105.1 MB, less than 42.86% of Java online submissions for Number of Adjacent Elements With the Same Color.\\n    \\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        // let\\'s use array to store data about color and it position\\n\\t\\t// +2 in size we need to avoid checking is it first or last element in array\\n        int[] array = new int[n + 2];\\n\\t\\t// result array\\n        int[] result = new int[queries.length];\\n\\t\\t// counter of adjacent elements with the same color\\n        int count = 0;\\n        \\n        for (int i = 0; i < queries.length; i++) {\\n            // color number\\n            int col = queries[i][1];\\n\\t\\t\\t// position number, we need make +1 to shift right because we have n+2 array length\\n            int pos = queries[i][0] + 1;\\n            \\n\\t\\t\\t// if this pos was \\'colored\\' already we need to check if we need decrease our counter \\n\\t\\t\\t// due to changing color value\\n            if (array[pos] != 0) {\\n                if (array[pos] == array[pos - 1]) {\\n                  count--;\\n                }\\n                \\n                if (array[pos] == array[pos + 1]) {\\n                count--;\\n                }            \\n            }\\n            \\n\\t\\t\\t// setting new color value\\n            array[pos] = col;\\n            \\n\\t\\t\\t// checking of we have same color value near by\\n            if (array[pos - 1] == col) {\\n               count++;\\n            }\\n            if (array[pos + 1] == col) {\\n               count++;\\n            }\\n            \\n            result[i] = count;\\n        }\\n        return result;\\n     }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        // let\\'s use array to store data about color and it position\\n\\t\\t// +2 in size we need to avoid checking is it first or last element in array\\n        int[] array = new int[n + 2];\\n\\t\\t// result array\\n        int[] result = new int[queries.length];\\n\\t\\t// counter of adjacent elements with the same color\\n        int count = 0;\\n        \\n        for (int i = 0; i < queries.length; i++) {\\n            // color number\\n            int col = queries[i][1];\\n\\t\\t\\t// position number, we need make +1 to shift right because we have n+2 array length\\n            int pos = queries[i][0] + 1;\\n            \\n\\t\\t\\t// if this pos was \\'colored\\' already we need to check if we need decrease our counter \\n\\t\\t\\t// due to changing color value\\n            if (array[pos] != 0) {\\n                if (array[pos] == array[pos - 1]) {\\n                  count--;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3497844,
                "title": "javascript-counting-neighbors",
                "content": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} queries\\n * @return {number[]}\\n */\\nvar colorTheArray = function(n, queries) {\\n    const nums = Array(n).fill(0);\\n    let count = 0;\\n    const res = [];\\n    \\n    for (const [index, color] of queries) {\\n        if (nums[index] === color) {\\n            res.push(count);\\n            \\n            continue;\\n        }    \\n        \\n        // change previous color on `index` position\\n        const old = nums[index];\\n        \\n        if (old !== 0) {\\n            let reduce = 0;\\n\\n            if (index > 0 && nums[index - 1] === old) {\\n                reduce += 1;\\n            }\\n\\n            if (index < nums.length - 1 && nums[index + 1] === old) {\\n                reduce += 1;\\n            }\\n\\n            count -= reduce;\\n        }\\n        \\n        // update new color on `index` position\\n        nums[index] = color;\\n        let add = 0;\\n        \\n        if (index > 0 && nums[index - 1] === color) {\\n            add += 1;\\n        }\\n        \\n        if (index < nums.length - 1 && nums[index + 1] === color) {\\n            add += 1;\\n        }\\n        \\n        count += add;\\n        \\n        res.push(count);\\n    }\\n    \\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} queries\\n * @return {number[]}\\n */\\nvar colorTheArray = function(n, queries) {\\n    const nums = Array(n).fill(0);\\n    let count = 0;\\n    const res = [];\\n    \\n    for (const [index, color] of queries) {\\n        if (nums[index] === color) {\\n            res.push(count);\\n            \\n            continue;\\n        }    \\n        \\n        // change previous color on `index` position\\n        const old = nums[index];\\n        \\n        if (old !== 0) {\\n            let reduce = 0;\\n\\n            if (index > 0 && nums[index - 1] === old) {\\n                reduce += 1;\\n            }\\n\\n            if (index < nums.length - 1 && nums[index + 1] === old) {\\n                reduce += 1;\\n            }\\n\\n            count -= reduce;\\n        }\\n        \\n        // update new color on `index` position\\n        nums[index] = color;\\n        let add = 0;\\n        \\n        if (index > 0 && nums[index - 1] === color) {\\n            add += 1;\\n        }\\n        \\n        if (index < nums.length - 1 && nums[index + 1] === color) {\\n            add += 1;\\n        }\\n        \\n        count += add;\\n        \\n        res.push(count);\\n    }\\n    \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3497462,
                "title": "best-and-easy-approach-c-with-o-n-tc-and-constant-sc",
                "content": "# Intuition\\nThe intuition comes from understanding that we have to take ans while updating the array simultaneously and also we are only concerned with next and prev adjacent elements and not on others.\\n\\n# Approach\\nI have used a cnt variable which keeps the track of no of adjacent pairs having same colors and after each query i am checking is it was involved previously in any pair if so then reduce cnt and if after updating it make ant pair then increase cnt.\\n\\n# Complexity\\n- Time complexity:\\nTC - O(n)\\n\\n\\n- Space complexity:\\nSC - O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n      vector<int> nums(n,0);\\n      int cnt=0;\\n      int m=queries.size();\\n      vector<int> ans(m,0);\\n      for(int i=0;i<m;i++){\\n          int ind=queries[i][0];\\n          int col=queries[i][1];\\n          int pre=nums[ind];\\n          //if previously equal to adjacent elements then reduce the cnt\\n          if(ind-1>=0 && nums[ind-1]!=0 && nums[ind-1]==pre) cnt--;\\n          if(ind+1<n && nums[ind+1]!=0 && nums[ind+1]==pre) cnt--;\\n          //update the color\\n          nums[ind]=col;\\n          //if after updating become equal to adjacent elements the increase the cnt\\n          if(ind-1>=0 && nums[ind-1]!=0 && nums[ind-1]==col) cnt++;\\n          if(ind+1<n && nums[ind+1]!=0 && nums[ind+1]==col) cnt++;\\n          //pushing the current cnt in ans array\\n          ans[i]=cnt;\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n      vector<int> nums(n,0);\\n      int cnt=0;\\n      int m=queries.size();\\n      vector<int> ans(m,0);\\n      for(int i=0;i<m;i++){\\n          int ind=queries[i][0];\\n          int col=queries[i][1];\\n          int pre=nums[ind];\\n          //if previously equal to adjacent elements then reduce the cnt\\n          if(ind-1>=0 && nums[ind-1]!=0 && nums[ind-1]==pre) cnt--;\\n          if(ind+1<n && nums[ind+1]!=0 && nums[ind+1]==pre) cnt--;\\n          //update the color\\n          nums[ind]=col;\\n          //if after updating become equal to adjacent elements the increase the cnt\\n          if(ind-1>=0 && nums[ind-1]!=0 && nums[ind-1]==col) cnt++;\\n          if(ind+1<n && nums[ind+1]!=0 && nums[ind+1]==col) cnt++;\\n          //pushing the current cnt in ans array\\n          ans[i]=cnt;\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496988,
                "title": "easy-solution-in-c-with-commented-explaination",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsimply checking no of contribution before adding color and after adding color will give the no of adjacent after sub after - before adj \\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int>nums(n);\\n        vector<int>ans;\\n        int c=0;\\n        for(auto i :queries){\\n             int color= i[1];\\n             int indx= i[0];\\n               \\n\\n            if(nums[indx]==color){\\n                ans.push_back(c);\\n            }\\n            else{\\n                int Bcnt=0; //checking before coloring the value \\n                if((indx-1)>=0){\\n                    if(nums[indx-1]==nums[indx] && nums[indx]!=0){\\n                        Bcnt++;\\n                    }\\n                }\\n                   //checking cur and +1\\n                if((indx+1)<n){\\n                    if(nums[indx+1]==nums[indx] && nums[indx]!=0){\\n                        Bcnt++;\\n                    }\\n                }\\n\\n                //checking after coloring of ele\\n                int Acnt=0; //checking before coloring the value \\n                nums[indx]= color;\\n                if((indx-1)>=0){\\n                    if(nums[indx-1]==nums[indx] ){\\n                        Acnt++;\\n                    }\\n                }\\n                   //checking cur and +1\\n                if((indx+1)<n){\\n                    if(nums[indx+1]==nums[indx] ){\\n                        Acnt++;\\n                    }\\n                }\\n          //FINAL ANS \\n              c+=(Acnt-Bcnt);\\n              ans.push_back(c);\\n            }\\n\\n        }\\n   return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int>nums(n);\\n        vector<int>ans;\\n        int c=0;\\n        for(auto i :queries){\\n             int color= i[1];\\n             int indx= i[0];\\n               \\n\\n            if(nums[indx]==color){\\n                ans.push_back(c);\\n            }\\n            else{\\n                int Bcnt=0; //checking before coloring the value \\n                if((indx-1)>=0){\\n                    if(nums[indx-1]==nums[indx] && nums[indx]!=0){\\n                        Bcnt++;\\n                    }\\n                }\\n                   //checking cur and +1\\n                if((indx+1)<n){\\n                    if(nums[indx+1]==nums[indx] && nums[indx]!=0){\\n                        Bcnt++;\\n                    }\\n                }\\n\\n                //checking after coloring of ele\\n                int Acnt=0; //checking before coloring the value \\n                nums[indx]= color;\\n                if((indx-1)>=0){\\n                    if(nums[indx-1]==nums[indx] ){\\n                        Acnt++;\\n                    }\\n                }\\n                   //checking cur and +1\\n                if((indx+1)<n){\\n                    if(nums[indx+1]==nums[indx] ){\\n                        Acnt++;\\n                    }\\n                }\\n          //FINAL ANS \\n              c+=(Acnt-Bcnt);\\n              ans.push_back(c);\\n            }\\n\\n        }\\n   return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496962,
                "title": "simple-c-sol-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int qsize,n1;\\n    bool prevColor(int i,vector<int>&color){\\n        if(i==0) return false;\\n        return color[i-1]==color[i];\\n        \\n    }\\n    \\n     bool nxtColor(int i,vector<int>&color){\\n        if(i==n1-1) return false;\\n        return color[i+1]==color[i];\\n        \\n    }\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        n1=n;\\n        vector<int>color(n,0);\\n        int totalAdj=0;\\n         qsize=queries.size();\\n        vector<int>ans(qsize,0);\\n        for(int i=0;i<qsize;i++){\\n            int ind=queries[i][0],col=queries[i][1];\\n            if(color[ind]!=0){\\n                if(prevColor(ind,color)){\\n                    totalAdj--;\\n                }\\n                if(nxtColor(ind,color)){\\n                    totalAdj--;\\n                }\\n            }\\n            color[ind]=col;\\n             if(prevColor(ind,color)){\\n                    totalAdj++;\\n                }\\n                if(nxtColor(ind,color)){\\n                    totalAdj++;\\n                }\\n            ans[i]=totalAdj;\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int qsize,n1;\\n    bool prevColor(int i,vector<int>&color){\\n        if(i==0) return false;\\n        return color[i-1]==color[i];\\n        \\n    }\\n    \\n     bool nxtColor(int i,vector<int>&color){\\n        if(i==n1-1) return false;\\n        return color[i+1]==color[i];\\n        \\n    }\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        n1=n;\\n        vector<int>color(n,0);\\n        int totalAdj=0;\\n         qsize=queries.size();\\n        vector<int>ans(qsize,0);\\n        for(int i=0;i<qsize;i++){\\n            int ind=queries[i][0],col=queries[i][1];\\n            if(color[ind]!=0){\\n                if(prevColor(ind,color)){\\n                    totalAdj--;\\n                }\\n                if(nxtColor(ind,color)){\\n                    totalAdj--;\\n                }\\n            }\\n            color[ind]=col;\\n             if(prevColor(ind,color)){\\n                    totalAdj++;\\n                }\\n                if(nxtColor(ind,color)){\\n                    totalAdj++;\\n                }\\n            ans[i]=totalAdj;\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496922,
                "title": "c-easy-and-beginner-friendly",
                "content": "# Intuition\\nfocus only on neighbour colors,\\ne.g. \\nRRR\\nchanging rightmost to new color -> one adjacent will be affected\\nchanging leftmost to new color -> one adjacent will be affected\\nchanging middle to new color -> two adjacents will be affected\\n\\n# Approach\\nfor every color change -> count how many adjacents are affected and keep track of sum of all adjacents\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N) : for using auxillary color array\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> ans, color(n,0);\\n        int adjacents=0;\\n        \\n        for(auto it: queries) {\\n            int index=it[0], newcolor=it[1], oldcolor=color[index];\\n            \\n            //old color\\n            int adj=0;\\n            if(index>0 && oldcolor==color[index-1] && oldcolor!=0) adj++;\\n            if(index<n-1 && oldcolor==color[index+1] && oldcolor!=0) adj++;\\n            adjacents-=adj;\\n            \\n            //new color\\n            adj=0;\\n            if(index>0 && newcolor==color[index-1]) adj++;\\n            if(index<n-1 && newcolor==color[index+1]) adj++;\\n            adjacents+=adj;\\n            \\n            color[index]=newcolor;\\n            ans.push_back(adjacents);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> ans, color(n,0);\\n        int adjacents=0;\\n        \\n        for(auto it: queries) {\\n            int index=it[0], newcolor=it[1], oldcolor=color[index];\\n            \\n            //old color\\n            int adj=0;\\n            if(index>0 && oldcolor==color[index-1] && oldcolor!=0) adj++;\\n            if(index<n-1 && oldcolor==color[index+1] && oldcolor!=0) adj++;\\n            adjacents-=adj;\\n            \\n            //new color\\n            adj=0;\\n            if(index>0 && newcolor==color[index-1]) adj++;\\n            if(index<n-1 && newcolor==color[index+1]) adj++;\\n            adjacents+=adj;\\n            \\n            color[index]=newcolor;\\n            ans.push_back(adjacents);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496610,
                "title": "python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nInitially everything would be zero so the result is zero.  \\nFrom the first query the result will start changing, the idea is that whenever we change the color of an element it would only affect the neighbors and others would not be affected. So we need to add or subtract to the previous state of the color array based on whether the elements were satisfying before and not satisfying now or vice versa\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n).     \\n- Space complexity:\\n$$O(n+len(queries))\\n\\n# Code\\n```\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n        color_arr = [0]*n\\n        res = [0]\\n        \\n        def find_res_delta(curr_color1,next_color1,color2):\\n            curr_satisfying = curr_color1 == color2 and color2 != 0\\n            next_satisfying = next_color1 == color2 and color2 != 0\\n            \\n            if curr_satisfying and not next_satisfying:\\n                return -1\\n            elif not curr_satisfying and next_satisfying:\\n                return 1\\n            else:\\n                return 0\\n            \\n        \\n        for e_idx,color in queries:\\n            sub_res = res[-1]\\n            \\n            curr_color = color_arr[e_idx]\\n            next_color = color\\n            \\n            if e_idx > 0:\\n                sub_res += find_res_delta(curr_color,next_color,color_arr[e_idx-1])\\n                if e_idx < n-1:\\n                    sub_res += find_res_delta(curr_color,next_color,color_arr[e_idx+1])\\n            else:\\n                if n > 1:\\n                    sub_res += find_res_delta(curr_color,next_color,color_arr[e_idx+1])\\n            \\n            color_arr[e_idx] = color\\n            \\n            res.append(sub_res)\\n                    \\n        return res[1:]\\n                \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n        color_arr = [0]*n\\n        res = [0]\\n        \\n        def find_res_delta(curr_color1,next_color1,color2):\\n            curr_satisfying = curr_color1 == color2 and color2 != 0\\n            next_satisfying = next_color1 == color2 and color2 != 0\\n            \\n            if curr_satisfying and not next_satisfying:\\n                return -1\\n            elif not curr_satisfying and next_satisfying:\\n                return 1\\n            else:\\n                return 0\\n            \\n        \\n        for e_idx,color in queries:\\n            sub_res = res[-1]\\n            \\n            curr_color = color_arr[e_idx]\\n            next_color = color\\n            \\n            if e_idx > 0:\\n                sub_res += find_res_delta(curr_color,next_color,color_arr[e_idx-1])\\n                if e_idx < n-1:\\n                    sub_res += find_res_delta(curr_color,next_color,color_arr[e_idx+1])\\n            else:\\n                if n > 1:\\n                    sub_res += find_res_delta(curr_color,next_color,color_arr[e_idx+1])\\n            \\n            color_arr[e_idx] = color\\n            \\n            res.append(sub_res)\\n                    \\n        return res[1:]\\n                \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496559,
                "title": "brute-force-python-easy-understanding",
                "content": "```\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n        \\n        arr = [0 for i in range(n)]\\n        count = 0\\n        ans = [0 for i in range(len(queries))]\\n        i = 0\\n        for idx,color in queries:\\n            \\n            if idx-1 >= 0 and arr[idx-1] == arr[idx]  and arr[idx-1] != 0:\\n                count -= 1\\n            if idx + 1 < n and arr[idx+1]  == arr[idx] and arr[idx+1] != 0 :\\n                count -= 1 \\n                \\n            arr[idx] = color\\n            \\n            if idx -1 >=0 and arr[idx-1] == arr[idx]:\\n                count += 1\\n            \\n            if idx + 1 < n and arr[idx] == arr[idx+1]:\\n                count += 1\\n            \\n            ans[i] = count\\n            i += 1\\n        \\n        return ans\\n            \\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n        \\n        arr = [0 for i in range(n)]\\n        count = 0\\n        ans = [0 for i in range(len(queries))]\\n        i = 0\\n        for idx,color in queries:\\n            \\n            if idx-1 >= 0 and arr[idx-1] == arr[idx]  and arr[idx-1] != 0:\\n                count -= 1\\n            if idx + 1 < n and arr[idx+1]  == arr[idx] and arr[idx+1] != 0 :\\n                count -= 1 \\n                \\n            arr[idx] = color\\n            \\n            if idx -1 >=0 and arr[idx-1] == arr[idx]:\\n                count += 1\\n            \\n            if idx + 1 < n and arr[idx] == arr[idx+1]:\\n                count += 1\\n            \\n            ans[i] = count\\n            i += 1\\n        \\n        return ans\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496454,
                "title": "c-simulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can simulate the process of painting cells. When painting the cell, all we should take into account are the left and right neighbours, what was `before` and `after` painting.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSentinel: in order not to check boundaries, we can add additional cells to the array.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] ColorTheArray(int n, int[][] queries) {\\n        int[] result = new int[queries.Length];\\n        int[] array = new int[n + 2];\\n\\n        for (int index = 0, count = 0; index < queries.Length; ++index) {\\n            int at = queries[index][0] + 1;\\n            int before = (array[at] == array[at - 1] && array[at] != 0 ? 1 : 0) + \\n                         (array[at] == array[at + 1] && array[at] != 0 ? 1 : 0);\\n            \\n            array[at] = queries[index][1];\\n            \\n            int after = (array[at] == array[at - 1] ? 1 : 0) + (array[at] == array[at + 1] ? 1 : 0);  \\n\\n            result[index] = (count += after - before);\\n        }\\n\\n        return result;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] ColorTheArray(int n, int[][] queries) {\\n        int[] result = new int[queries.Length];\\n        int[] array = new int[n + 2];\\n\\n        for (int index = 0, count = 0; index < queries.Length; ++index) {\\n            int at = queries[index][0] + 1;\\n            int before = (array[at] == array[at - 1] && array[at] != 0 ? 1 : 0) + \\n                         (array[at] == array[at + 1] && array[at] != 0 ? 1 : 0);\\n            \\n            array[at] = queries[index][1];\\n            \\n            int after = (array[at] == array[at - 1] ? 1 : 0) + (array[at] == array[at + 1] ? 1 : 0);  \\n\\n            result[index] = (count += after - before);\\n        }\\n\\n        return result;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496443,
                "title": "from-o-n-q-to-o-q-track-the-count-of-adjacent-elements-with-the-same-color-as-we-go-along",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea here is that we check the adjacent elements with the same color as we go along.\\n\\n# Naive Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, we will need to update the nums array with the new color for each query, and then for each query, loop through the nums array to count the number of adjacent elements that have the same color.\\n\\n## Complexity\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Time complexity: $$O(n * q)$$ \\n Here, n is the length of the array and q is the number of queries. This is because we loop through the entire `nums` array for each query. As the size of the array and the number of queries increase, this approach becomes very slow and inefficient.\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: $$O(n)$$, where n is the length of the array.\\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        int s = queries.size();\\n        vector<int> nums(n, 0);\\n        vector<int> answer(s, 0);\\n\\n        for (int i = 0; i < s; i++) {\\n            nums[queries[i][0]] = queries[i][1];\\n            int count = 0;\\n            for (int j = 0; j < n - 1; j++) {\\n                if (nums[j] != 0 && nums[j] == nums[j+1]) {\\n                    count++;\\n                }\\n            }\\n            answer[i] = count;\\n        }\\n\\n        return answer;\\n    }\\n};\\n```\\nAs the Code has a time complexity of $$O(n * q)$$; it will not work when the query.length is 10<sup>5</sup> and array length is also 10<sup>5</sup>.\\n\\n# Approach 2: A bit optimal\\nHere, I need to reduce the loop or decrease the complexity of the code from $$O(n \\\\cdot q)$$ to O(q) (processing the query does not take any time).*Italic* \\nIf I can keep the track of the count of adjacent elements with the same color as we go along, so that we don\\'t need to iterate over the entire nums array for each query. This way, we can compute the answer for each query in constant time.\\n\\nWe can keep track of a running `count` of the number of adjacent elements with the same color. \\nFor each query, \\n- We update the color at the specified index and check the adjacent elements to the left and right of the updated index. \\n- We increment the count if any of these adjacent elements have the same color as the new color. \\n- We also check the adjacent elements to the left and right of the updated index to see if they had the same color as the old color, and decrement the count if this is the case. \\n- Finally, we append the current count to the answer array and return it.\\n\\n## Complexity\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Time complexity: $$O(q)$$, where q is the number of queries (we process each query in constant time).\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: $$O(n)$$, where n is the length of the array.\\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> nums(n, 0);\\n        vector<int> answer;\\n        int count = 0;\\n\\n        for (int i = 0; i < queries.size(); i++) {\\n            int index = queries[i][0];\\n            int color = queries[i][1];\\n\\n            int prevColor = nums[index];\\n            nums[index] = color;\\n\\n            if (index > 0 && nums[index-1] != 0 && nums[index-1] == color) {\\n                count++;\\n            }\\n\\n            if (index < n-1 && nums[index+1] != 0 && nums[index+1] == color) {\\n                count++;\\n            }\\n\\n            if (prevColor != 0) {\\n                if (index > 0 && nums[index-1] != 0 && nums[index-1] == prevColor) {\\n                    count--;\\n                }\\n\\n                if (index < n-1 && nums[index+1] != 0 && nums[index+1] == prevColor) {\\n                    count--;\\n                }\\n            }\\n\\n            answer.push_back(count);\\n        }\\n\\n        return answer;\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        int s = queries.size();\\n        vector<int> nums(n, 0);\\n        vector<int> answer(s, 0);\\n\\n        for (int i = 0; i < s; i++) {\\n            nums[queries[i][0]] = queries[i][1];\\n            int count = 0;\\n            for (int j = 0; j < n - 1; j++) {\\n                if (nums[j] != 0 && nums[j] == nums[j+1]) {\\n                    count++;\\n                }\\n            }\\n            answer[i] = count;\\n        }\\n\\n        return answer;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> nums(n, 0);\\n        vector<int> answer;\\n        int count = 0;\\n\\n        for (int i = 0; i < queries.size(); i++) {\\n            int index = queries[i][0];\\n            int color = queries[i][1];\\n\\n            int prevColor = nums[index];\\n            nums[index] = color;\\n\\n            if (index > 0 && nums[index-1] != 0 && nums[index-1] == color) {\\n                count++;\\n            }\\n\\n            if (index < n-1 && nums[index+1] != 0 && nums[index+1] == color) {\\n                count++;\\n            }\\n\\n            if (prevColor != 0) {\\n                if (index > 0 && nums[index-1] != 0 && nums[index-1] == prevColor) {\\n                    count--;\\n                }\\n\\n                if (index < n-1 && nums[index+1] != 0 && nums[index+1] == prevColor) {\\n                    count--;\\n                }\\n            }\\n\\n            answer.push_back(count);\\n        }\\n\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496420,
                "title": "most-optimized-solution-in-c-with-proper-explanation",
                "content": "# Intuition\\nThe intuition behind the given code is to simulate the color updates in an array and keep track of the count of adjacent elements with the same color before and after each update.\\n\\n# Approach\\nThe helper function takes the current count of adjacent elements with the same color, the array of colors, the index p of the element that was just colored, and a boolean flag to indicate whether we are adding or subtracting from the count. The function checks if the neighboring elements of the indexed element have the same color as the indexed element and are not uncolored (0). If so, it updates the count accordingly.\\n\\nIn the main function, we iterate through the queries one by one. For each query, we first call the helper function with the flag set to false to subtract the count of adjacent elements with the same color before changing the color of the indexed element. We then update the color of the indexed element in the temporary array \\'temp\\'. Finally, we call the helper function again with the flag set to true to add the count of adjacent elements with the same color after changing the color of the indexed element. We store the updated count in the \\'cur\\' variable and append it to the result array \\'res\\'.\\n\\nAt the end of the loop, we return the \\'res\\' array containing the counts of adjacent elements with the same color after each query.\\n\\n# Complexity\\n- Time complexity: $$O(nq)$$\\n\\n- Space complexity: $$O(n + q)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int helper(int temp, vector<int>& arr, int p, bool flag) {\\n        if (p > 0 && arr[p - 1] == arr[p] && arr[p - 1] != 0) temp += flag ? 1 : -1;\\n        \\n        if (p < arr.size() - 1 && arr[p + 1] == arr[p] && arr[p + 1] != 0) temp += flag ? 1 : -1;\\n        \\n        return temp;\\n    }\\n\\n    vector<int> colorTheArray(int n, vector<vector<int>>& inp) {\\n        int cur = 0;\\n        vector<int> temp(n, 0);\\n        vector<int> res;\\n\\n        for (auto q : inp) {\\n            int p = q[0];\\n            int c = q[1];\\n            cur = helper(cur, temp, p, false);\\n            temp[p] = c;\\n            cur = helper(cur, temp, p, true);\\n            res.emplace_back(cur);\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(int temp, vector<int>& arr, int p, bool flag) {\\n        if (p > 0 && arr[p - 1] == arr[p] && arr[p - 1] != 0) temp += flag ? 1 : -1;\\n        \\n        if (p < arr.size() - 1 && arr[p + 1] == arr[p] && arr[p + 1] != 0) temp += flag ? 1 : -1;\\n        \\n        return temp;\\n    }\\n\\n    vector<int> colorTheArray(int n, vector<vector<int>>& inp) {\\n        int cur = 0;\\n        vector<int> temp(n, 0);\\n        vector<int> res;\\n\\n        for (auto q : inp) {\\n            int p = q[0];\\n            int c = q[1];\\n            cur = helper(cur, temp, p, false);\\n            temp[p] = c;\\n            cur = helper(cur, temp, p, true);\\n            res.emplace_back(cur);\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496356,
                "title": "easy-and-understandable-c-solution",
                "content": "# Complexity\\n- Time complexity:**O(N)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:**O(N)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n           vector<int> nums(n, 0);\\n           vector<int> ans(queries.size(), 0);           \\n           int count = 0;\\n           \\n           nums[queries[0][0]] = queries[0][1];\\n\\n          for(int i=1; i<queries.size(); i++)\\n           {\\n               int index= queries[i][0];\\n               int color = queries[i][1];\\n                   \\n        if(index>0 && nums[index]==nums[index-1] \\n                        && nums[index]!=0 && nums[index-1]!=0)\\n          {\\n                   count--;\\n          } \\n        if(index<n-1 && nums[index]==nums[index+1] \\n                         && nums[index]!=0 && nums[index+1]!=0)\\n          {\\n              count--;\\n          }\\n\\n        nums[index] = color;\\n\\n        if(index>0 && nums[index]==nums[index-1] \\n                        && nums[index]!=0 && nums[index-1]!=0)\\n          {\\n                   count++;\\n          } \\n        if(index<n-1 && nums[index]==nums[index+1] \\n                        && nums[index]!=0 && nums[index+1]!=0)\\n          {\\n              count++;\\n          }\\n\\n         ans[i] = count;\\n           }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n           vector<int> nums(n, 0);\\n           vector<int> ans(queries.size(), 0);           \\n           int count = 0;\\n           \\n           nums[queries[0][0]] = queries[0][1];\\n\\n          for(int i=1; i<queries.size(); i++)\\n           {\\n               int index= queries[i][0];\\n               int color = queries[i][1];\\n                   \\n        if(index>0 && nums[index]==nums[index-1] \\n                        && nums[index]!=0 && nums[index-1]!=0)\\n          {\\n                   count--;\\n          } \\n        if(index<n-1 && nums[index]==nums[index+1] \\n                         && nums[index]!=0 && nums[index+1]!=0)\\n          {\\n              count--;\\n          }\\n\\n        nums[index] = color;\\n\\n        if(index>0 && nums[index]==nums[index-1] \\n                        && nums[index]!=0 && nums[index-1]!=0)\\n          {\\n                   count++;\\n          } \\n        if(index<n-1 && nums[index]==nums[index+1] \\n                        && nums[index]!=0 && nums[index+1]!=0)\\n          {\\n              count++;\\n          }\\n\\n         ans[i] = count;\\n           }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496330,
                "title": "simple-manipulation-based-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        int a[]=new int[n];\\n        int res[]=new int[queries.length];\\n        int s=0;\\n        for(int i=0;i<queries.length;i++){\\n            int x=queries[i][0];\\n            int c=queries[i][1];\\n            int cnt=0;\\n            if((x-1)>=0){\\n                if(a[x-1]==c){\\n                    cnt++;\\n                }\\n            }\\n            if((x+1)<n){\\n                if(a[x+1]==c){\\n                    cnt++;\\n                }\\n            }\\n            if(a[x]!=0){\\n                if((x-1)>=0){\\n                    if(a[x-1]==a[x]){\\n                        s--;\\n                    }\\n                }\\n                if((x+1)<n){\\n                    if(a[x+1]==a[x]){\\n                        s--;\\n                    }\\n                }\\n            }\\n            a[x]=c;\\n            s+=cnt;\\n            res[i]=s;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        int a[]=new int[n];\\n        int res[]=new int[queries.length];\\n        int s=0;\\n        for(int i=0;i<queries.length;i++){\\n            int x=queries[i][0];\\n            int c=queries[i][1];\\n            int cnt=0;\\n            if((x-1)>=0){\\n                if(a[x-1]==c){\\n                    cnt++;\\n                }\\n            }\\n            if((x+1)<n){\\n                if(a[x+1]==c){\\n                    cnt++;\\n                }\\n            }\\n            if(a[x]!=0){\\n                if((x-1)>=0){\\n                    if(a[x-1]==a[x]){\\n                        s--;\\n                    }\\n                }\\n                if((x+1)<n){\\n                    if(a[x+1]==a[x]){\\n                        s--;\\n                    }\\n                }\\n            }\\n            a[x]=c;\\n            s+=cnt;\\n            res[i]=s;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496305,
                "title": "simple-c-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(q)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int>m(n,0);\\n        vector<int>ans;\\n        int mn=queries.size();\\n        int cnt=0;\\n        for(int i=0;i<mn;i++){\\n           int idx=queries[i][0];\\n           int val=queries[i][1];\\n           int prev=0;\\n           int next=0;\\n           if(idx-1>=0){\\n               prev=m[idx-1];\\n               \\n           }\\n           if(idx+1<n){\\n               next=m[idx+1];\\n           }\\n           if(m[idx]==prev && prev!=0){\\n               cnt--;\\n           }\\n           if(m[idx]==next && next!=0){\\n               cnt--;\\n           }\\n           m[idx]=val;\\n           if(m[idx]==prev && prev!=0){\\n               cnt++;\\n           }\\n           if(m[idx]==next && next!=0){\\n               cnt++;\\n           }\\n           ans.push_back(cnt);\\n        }return ans;\\n    }\\n};\\n```\\n**Please, UPVOTE**",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int>m(n,0);\\n        vector<int>ans;\\n        int mn=queries.size();\\n        int cnt=0;\\n        for(int i=0;i<mn;i++){\\n           int idx=queries[i][0];\\n           int val=queries[i][1];\\n           int prev=0;\\n           int next=0;\\n           if(idx-1>=0){\\n               prev=m[idx-1];\\n               \\n           }\\n           if(idx+1<n){\\n               next=m[idx+1];\\n           }\\n           if(m[idx]==prev && prev!=0){\\n               cnt--;\\n           }\\n           if(m[idx]==next && next!=0){\\n               cnt--;\\n           }\\n           m[idx]=val;\\n           if(m[idx]==prev && prev!=0){\\n               cnt++;\\n           }\\n           if(m[idx]==next && next!=0){\\n               cnt++;\\n           }\\n           ans.push_back(cnt);\\n        }return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496214,
                "title": "c-solution-with-approach-and-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nJust remember that the max number by which the ans can change by changing one colour is just 2, one for the left side and one for the right side, and all others remain same. Once you get this, it is very simple\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector <int> ans;\\n        vector <int> arr(n,0);\\n        int tans = 0;\\n        for(int i=0;i<queries.size();i++){\\n            int index = queries[i][0];\\n            int newColor = queries[i][1];\\n            int oldColor = arr[index];\\n            if(oldColor){\\n                // need to take care of before math... that is subtract if you are reducing the adjacement elements.\\n                if(index != n-1){\\n                    if(arr[index] == arr[index+1]){\\n                        tans--;\\n                    }\\n                }\\n                if(index != 0){\\n                    if(arr[index] == arr[index-1]){\\n                        tans--;\\n                    }\\n                }\\n            }\\n            // after changing the color, adding the newly formed adjacement elements.\\n            arr[index] = newColor;\\n            if(index != n-1){\\n                    if(arr[index] == arr[index+1]){\\n                        tans++;\\n                    }\\n                }\\n                if(index != 0){\\n                    if(arr[index] == arr[index-1]){\\n                        tans++;\\n                    }\\n                }\\n            ans.push_back(tans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector <int> ans;\\n        vector <int> arr(n,0);\\n        int tans = 0;\\n        for(int i=0;i<queries.size();i++){\\n            int index = queries[i][0];\\n            int newColor = queries[i][1];\\n            int oldColor = arr[index];\\n            if(oldColor){\\n                // need to take care of before math... that is subtract if you are reducing the adjacement elements.\\n                if(index != n-1){\\n                    if(arr[index] == arr[index+1]){\\n                        tans--;\\n                    }\\n                }\\n                if(index != 0){\\n                    if(arr[index] == arr[index-1]){\\n                        tans--;\\n                    }\\n                }\\n            }\\n            // after changing the color, adding the newly formed adjacement elements.\\n            arr[index] = newColor;\\n            if(index != n-1){\\n                    if(arr[index] == arr[index+1]){\\n                        tans++;\\n                    }\\n                }\\n                if(index != 0){\\n                    if(arr[index] == arr[index-1]){\\n                        tans++;\\n                    }\\n                }\\n            ans.push_back(tans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496189,
                "title": "easy-to-follow",
                "content": "```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        \\n        int[] res = new int[queries.length];\\n        int[] freq = new int[n+2];\\n            \\n        for(int i = 0; i < queries.length; i++){\\n            int[] nums = queries[i];\\n            int index = nums[0];\\n            int value = nums[1];\\n            int prev = freq[index];\\n            if(i == 0){\\n                freq[index] = value;\\n                continue;\\n            }\\n            if(prev == value){\\n                res[i]= res[i-1];\\n                continue;\\n            }\\n            int minus = 0;\\n            int add = 0;\\n            if(index != 0 && freq[index-1] !=0 && freq[index-1] == prev){\\n                --minus;\\n            }\\n            if(freq[index+1] != 0 && freq[index+1] == prev){\\n                --minus;\\n            }\\n            if(index != 0 && value == freq[index-1]) add++;\\n            if(value == freq[index+1]) add++;\\n            \\n            freq[index] = value;\\n            res[i] = res[i-1] + add + minus;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        \\n        int[] res = new int[queries.length];\\n        int[] freq = new int[n+2];\\n            \\n        for(int i = 0; i < queries.length; i++){\\n            int[] nums = queries[i];\\n            int index = nums[0];\\n            int value = nums[1];\\n            int prev = freq[index];\\n            if(i == 0){\\n                freq[index] = value;\\n                continue;\\n            }\\n            if(prev == value){\\n                res[i]= res[i-1];\\n                continue;\\n            }\\n            int minus = 0;\\n            int add = 0;\\n            if(index != 0 && freq[index-1] !=0 && freq[index-1] == prev){\\n                --minus;\\n            }\\n            if(freq[index+1] != 0 && freq[index+1] == prev){\\n                --minus;\\n            }\\n            if(index != 0 && value == freq[index-1]) add++;\\n            if(value == freq[index+1]) add++;\\n            \\n            freq[index] = value;\\n            res[i] = res[i-1] + add + minus;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496081,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int>data(n) ;\\n        vector<int>ret ;\\n        int sum = 0 ;\\n        for(auto q : queries){\\n            int idx = q[0] ;\\n            int color = q[1] ;\\n            if(data[idx] == color){\\n                ret.push_back(sum) ;\\n                continue ;\\n            }\\n            if(data[idx] == 0){\\n                data[idx] = color ;\\n                if(idx > 0){\\n                    if(data[idx-1] == data[idx])\\n                        sum++ ;\\n                }\\n                if(idx < n-1)\\n                    if(data[idx] == data[idx+1])\\n                        sum++ ;\\n            }\\n            else{\\n                if(idx > 0){\\n                    if(data[idx-1] == data[idx])\\n                        sum-- ;\\n                }\\n                if(idx < n-1)\\n                    if(data[idx] == data[idx+1])\\n                        sum-- ;\\n                data[idx] = color ;\\n                if(idx > 0){\\n                    if(data[idx-1] == data[idx])\\n                        sum++ ;\\n                }\\n                if(idx < n-1)\\n                    if(data[idx] == data[idx+1])\\n                        sum++ ;\\n            }\\n            ret.push_back(sum) ;\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int>data(n) ;\\n        vector<int>ret ;\\n        int sum = 0 ;\\n        for(auto q : queries){\\n            int idx = q[0] ;\\n            int color = q[1] ;\\n            if(data[idx] == color){\\n                ret.push_back(sum) ;\\n                continue ;\\n            }\\n            if(data[idx] == 0){\\n                data[idx] = color ;\\n                if(idx > 0){\\n                    if(data[idx-1] == data[idx])\\n                        sum++ ;\\n                }\\n                if(idx < n-1)\\n                    if(data[idx] == data[idx+1])\\n                        sum++ ;\\n            }\\n            else{\\n                if(idx > 0){\\n                    if(data[idx-1] == data[idx])\\n                        sum-- ;\\n                }\\n                if(idx < n-1)\\n                    if(data[idx] == data[idx+1])\\n                        sum-- ;\\n                data[idx] = color ;\\n                if(idx > 0){\\n                    if(data[idx-1] == data[idx])\\n                        sum++ ;\\n                }\\n                if(idx < n-1)\\n                    if(data[idx] == data[idx+1])\\n                        sum++ ;\\n            }\\n            ret.push_back(sum) ;\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496075,
                "title": "c-easy-counting-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> col(n,0),ans;int count=0;\\n        for(auto it : queries){\\n            int idx = it[0],c = it[1];\\n            if(col[idx]==0){\\n               if(idx-1>=0 && c==col[idx-1])count++;\\n                if(idx+1<n && c==col[idx+1])count++;\\n              }\\n            else if(c!=col[idx]){\\n                if(idx-1>=0 && col[idx]==col[idx-1])count--;\\n                if(idx+1<n && col[idx]==col[idx+1])count--;\\n                if(idx-1>=0 && c==col[idx-1])count++;\\n                if(idx+1<n && c==col[idx+1])count++;\\n            }\\n                col[idx] = c;\\n                ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> col(n,0),ans;int count=0;\\n        for(auto it : queries){\\n            int idx = it[0],c = it[1];\\n            if(col[idx]==0){\\n               if(idx-1>=0 && c==col[idx-1])count++;\\n                if(idx+1<n && c==col[idx+1])count++;\\n              }\\n            else if(c!=col[idx]){\\n                if(idx-1>=0 && col[idx]==col[idx-1])count--;\\n                if(idx+1<n && col[idx]==col[idx+1])count--;\\n                if(idx-1>=0 && c==col[idx-1])count++;\\n                if(idx+1<n && c==col[idx+1])count++;\\n            }\\n                col[idx] = c;\\n                ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496022,
                "title": "easy-solution-with-explanations",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nif prev and next is same before we need to reduce count,due to previous count of same element and then we count current same elements\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(1)\\n# Code\\n```\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n        temp = [0] * n\\n        res = []\\n        count = 0\\n        \\n        for i, j in queries:\\n            # print(count,res,temp,(i,j))\\n            prev, next = i - 1, i + 1\\n            # count=0\\n            \\n            if prev >= 0 and temp[prev] == temp[i] and temp[i] != 0:\\n                count -= 1\\n            if next < n and temp[next] == temp[i] and temp[i] != 0:\\n                count -= 1\\n            temp[i] = j\\n            \\n            if prev >= 0 and temp[prev] == temp[i] and temp[i] != 0:\\n                count += 1\\n            if next < n and temp[next] == temp[i] and temp[i] != 0:\\n                count += 1\\n            res.append(count)\\n            \\n            \\n        return res\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n        temp = [0] * n\\n        res = []\\n        count = 0\\n        \\n        for i, j in queries:\\n            # print(count,res,temp,(i,j))\\n            prev, next = i - 1, i + 1\\n            # count=0\\n            \\n            if prev >= 0 and temp[prev] == temp[i] and temp[i] != 0:\\n                count -= 1\\n            if next < n and temp[next] == temp[i] and temp[i] != 0:\\n                count -= 1\\n            temp[i] = j\\n            \\n            if prev >= 0 and temp[prev] == temp[i] and temp[i] != 0:\\n                count += 1\\n            if next < n and temp[next] == temp[i] and temp[i] != 0:\\n                count += 1\\n            res.append(count)\\n            \\n            \\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495990,
                "title": "c-very-easy-solution",
                "content": "```\\nvector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        int k = queries.size();\\n        vector<int> ans(k,0);\\n        vector<int> v(n, 0);\\n        v[queries[0][0]] = queries[0][1];\\n        ans[0] = 0;\\n        \\n        int count = 0;\\n        for(int i=1; i<k; i++)\\n        {\\n            int index = queries[i][0];\\n            int color = queries[i][1];\\n            \\n            //color nahi hai pehle se\\n            if(v[index] == 0)\\n            {\\n                v[index] = color;\\n                if(index-1 >=0 && v[index-1] == color) count++;\\n                if(index+1 < n && v[index+1] == color) count++;\\n                ans[i] = count;\\n            }\\n            else\\n            {\\n                //pehle wala color ka ans data do count se kyuki new update hoga color ka\\n                if(index-1 >=0 && v[index-1] == v[index]) count--;\\n                if(index+1 < n && v[index+1] == v[index]) count--;\\n                \\n                v[index] = color;\\n                if(index-1 >=0 && v[index-1] == color) count++;\\n                if(index+1 < n && v[index+1] == color) count++;\\n                ans[i] = count;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Counting"
                ],
                "code": "```\\nvector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        int k = queries.size();\\n        vector<int> ans(k,0);\\n        vector<int> v(n, 0);\\n        v[queries[0][0]] = queries[0][1];\\n        ans[0] = 0;\\n        \\n        int count = 0;\\n        for(int i=1; i<k; i++)\\n        {\\n            int index = queries[i][0];\\n            int color = queries[i][1];\\n            \\n            //color nahi hai pehle se\\n            if(v[index] == 0)\\n            {\\n                v[index] = color;\\n                if(index-1 >=0 && v[index-1] == color) count++;\\n                if(index+1 < n && v[index+1] == color) count++;\\n                ans[i] = count;\\n            }\\n            else\\n            {\\n                //pehle wala color ka ans data do count se kyuki new update hoga color ka\\n                if(index-1 >=0 && v[index-1] == v[index]) count--;\\n                if(index+1 < n && v[index+1] == v[index]) count--;\\n                \\n                v[index] = color;\\n                if(index-1 >=0 && v[index-1] == color) count++;\\n                if(index+1 < n && v[index+1] == color) count++;\\n                ans[i] = count;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3495965,
                "title": "simple-cakewalk-10-line-code-o-n-time-specially-designed-for-beginner-s-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        int ans=0; // storing the current existing value of the possible number of adjacent pairs count\\n        vector<int>arr(n,0); // initialise al of them initially with 0\\n        vector<int>res;\\n        for(auto x: queries){\\n            int i = x[0], val = x[1];\\n            // before inserting firstly check and subtract\\n            if(i-1>=0 and arr[i-1]!=0 and arr[i-1]==arr[i]) ans--;\\n            if(i+1<n  and arr[i+1]!=0 and arr[i+1]==arr[i]) ans--;\\n            arr[i]=val;\\n\\t\\t\\t// now after inserting check the same steps\\n            if(i-1>=0 and arr[i-1]!=0 and arr[i-1]==arr[i]) ans++;\\n            if(i+1<n  and arr[i+1]!=0 and arr[i+1]==arr[i]) ans++;\\n            res.push_back(ans);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\nTime Complexity -> O(n)\\nSpace Complexity -> O(n)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        int ans=0; // storing the current existing value of the possible number of adjacent pairs count\\n        vector<int>arr(n,0); // initialise al of them initially with 0\\n        vector<int>res;\\n        for(auto x: queries){\\n            int i = x[0], val = x[1];\\n            // before inserting firstly check and subtract\\n            if(i-1>=0 and arr[i-1]!=0 and arr[i-1]==arr[i]) ans--;\\n            if(i+1<n  and arr[i+1]!=0 and arr[i+1]==arr[i]) ans--;\\n            arr[i]=val;\\n\\t\\t\\t// now after inserting check the same steps\\n            if(i-1>=0 and arr[i-1]!=0 and arr[i-1]==arr[i]) ans++;\\n            if(i+1<n  and arr[i+1]!=0 and arr[i+1]==arr[i]) ans++;\\n            res.push_back(ans);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495943,
                "title": "c-conditional-statements-easy-solution",
                "content": "# Intuition\\nAfter every query we only need to care about the left and right element of the changed index.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> nums(n);\\n        int cnt = 0;\\n        int k = queries.size();\\n        vector<int> ans(k);\\n        for(int i=0;i<k;i++)\\n        {\\n            int idx = queries[i][0];\\n            int col = queries[i][1];\\n            if(idx-1>=0 && idx+1<n)\\n            {\\n                if(nums[idx]==nums[idx-1] && nums[idx]==nums[idx+1] && nums[idx]!=0)\\n                {\\n                    if(nums[idx]!=col)\\n                    cnt-=2;\\n                    nums[idx] = col;\\n                }\\n                else if(nums[idx]==nums[idx+1] && nums[idx]!=0)\\n                {\\n                    nums[idx] = col;\\n                    if(nums[idx]!=nums[idx+1])\\n                    cnt--;\\n                    if(nums[idx]==nums[idx-1])\\n                    cnt++;\\n                }\\n                else if(nums[idx]==nums[idx-1] && nums[idx]!=0)\\n                {\\n                    nums[idx] = col;\\n                    if(nums[idx]!=nums[idx-1])\\n                    cnt--;\\n                    if(nums[idx]==nums[idx+1])\\n                    cnt++;\\n                }\\n                else \\n                {\\n                    nums[idx] = col; \\n                    if(nums[idx]==nums[idx-1])\\n                    cnt++;\\n                    if(nums[idx]==nums[idx+1])\\n                    cnt++;   \\n                }\\n            }\\n            else if(idx-1>=0)\\n            {\\n                if(nums[idx]==nums[idx-1] && nums[idx]!=0)\\n                {\\n                    nums[idx] = col;\\n                    if(nums[idx]!=nums[idx-1])\\n                    cnt--;\\n                }\\n                else\\n                {\\n                    nums[idx] = col;\\n                    if(nums[idx]==nums[idx-1])\\n                    cnt++;\\n                }\\n            }\\n            else if(idx+1<n)\\n            {\\n                if(nums[idx]==nums[idx+1] && nums[idx]!=0)\\n                {\\n                    nums[idx] = col;\\n                    if(nums[idx]!=nums[idx+1])\\n                    cnt--;\\n                }\\n                else\\n                {\\n                    nums[idx] = col;\\n                    if(nums[idx]==nums[idx+1])\\n                    cnt++;\\n                }\\n            }\\n            ans[i] = cnt;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        vector<int> nums(n);\\n        int cnt = 0;\\n        int k = queries.size();\\n        vector<int> ans(k);\\n        for(int i=0;i<k;i++)\\n        {\\n            int idx = queries[i][0];\\n            int col = queries[i][1];\\n            if(idx-1>=0 && idx+1<n)\\n            {\\n                if(nums[idx]==nums[idx-1] && nums[idx]==nums[idx+1] && nums[idx]!=0)\\n                {\\n                    if(nums[idx]!=col)\\n                    cnt-=2;\\n                    nums[idx] = col;\\n                }\\n                else if(nums[idx]==nums[idx+1] && nums[idx]!=0)\\n                {\\n                    nums[idx] = col;\\n                    if(nums[idx]!=nums[idx+1])\\n                    cnt--;\\n                    if(nums[idx]==nums[idx-1])\\n                    cnt++;\\n                }\\n                else if(nums[idx]==nums[idx-1] && nums[idx]!=0)\\n                {\\n                    nums[idx] = col;\\n                    if(nums[idx]!=nums[idx-1])\\n                    cnt--;\\n                    if(nums[idx]==nums[idx+1])\\n                    cnt++;\\n                }\\n                else \\n                {\\n                    nums[idx] = col; \\n                    if(nums[idx]==nums[idx-1])\\n                    cnt++;\\n                    if(nums[idx]==nums[idx+1])\\n                    cnt++;   \\n                }\\n            }\\n            else if(idx-1>=0)\\n            {\\n                if(nums[idx]==nums[idx-1] && nums[idx]!=0)\\n                {\\n                    nums[idx] = col;\\n                    if(nums[idx]!=nums[idx-1])\\n                    cnt--;\\n                }\\n                else\\n                {\\n                    nums[idx] = col;\\n                    if(nums[idx]==nums[idx-1])\\n                    cnt++;\\n                }\\n            }\\n            else if(idx+1<n)\\n            {\\n                if(nums[idx]==nums[idx+1] && nums[idx]!=0)\\n                {\\n                    nums[idx] = col;\\n                    if(nums[idx]!=nums[idx+1])\\n                    cnt--;\\n                }\\n                else\\n                {\\n                    nums[idx] = col;\\n                    if(nums[idx]==nums[idx+1])\\n                    cnt++;\\n                }\\n            }\\n            ans[i] = cnt;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495931,
                "title": "just-focus-on-those-neighbor-blocks-before-and-after-colored-index",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn color_the_array(n: i32, queries: Vec<Vec<i32>>) -> Vec<i32> {\\n        let mut graph = vec![0; n as usize];\\n        let mut result = vec![];\\n        let mut temp = 0;\\n\\n        for query in queries.iter() {\\n            let index = query[0] as usize;\\n            let color = query[1];\\n\\n            for index_graph in [index-1, index+1] {\\n                // valid index between 0 ~ n-1\\n                if index_graph < 0 || index_graph >= graph.len() {\\n                    continue;\\n                }\\n\\n                // original color isn\\'t 0 && new color != old color\\n                if graph[index] != 0 && color != graph[index] {\\n                    // before colored: 2 neighbor colors both equal\\n                    if graph[index_graph] == graph[index] {\\n                        temp -= 1;\\n                    }\\n                    // after colored: 2 neighbor colors both equal\\n                    else if graph[index_graph] == color {\\n                        temp += 1;\\n                    }\\n                }\\n                // original color is 0 && color in both positions are equal after colored\\n                else if graph[index] == 0 && graph[index_graph] == color {\\n                    temp += 1;\\n                }\\n            }\\n            result.push(temp);\\n\\n            graph[index] = color;\\n        }\\n\\n        result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn color_the_array(n: i32, queries: Vec<Vec<i32>>) -> Vec<i32> {\\n        let mut graph = vec![0; n as usize];\\n        let mut result = vec![];\\n        let mut temp = 0;\\n\\n        for query in queries.iter() {\\n            let index = query[0] as usize;\\n            let color = query[1];\\n\\n            for index_graph in [index-1, index+1] {\\n                // valid index between 0 ~ n-1\\n                if index_graph < 0 || index_graph >= graph.len() {\\n                    continue;\\n                }\\n\\n                // original color isn\\'t 0 && new color != old color\\n                if graph[index] != 0 && color != graph[index] {\\n                    // before colored: 2 neighbor colors both equal\\n                    if graph[index_graph] == graph[index] {\\n                        temp -= 1;\\n                    }\\n                    // after colored: 2 neighbor colors both equal\\n                    else if graph[index_graph] == color {\\n                        temp += 1;\\n                    }\\n                }\\n                // original color is 0 && color in both positions are equal after colored\\n                else if graph[index] == 0 && graph[index_graph] == color {\\n                    temp += 1;\\n                }\\n            }\\n            result.push(temp);\\n\\n            graph[index] = color;\\n        }\\n\\n        result\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3495897,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        int[] arr = new int[n];\\n        int res[] = new int[queries.length], prevRes = 0, count = 0;\\n        for(int query[]: queries){\\n            int ind = query[0];\\n            if(ind > 0 && ind < n - 1 && arr[ind] != 0){\\n                if(arr[ind - 1] == arr[ind] && arr[ind] == arr[ind + 1]) prevRes -= 2;\\n                else if(arr[ind - 1] == arr[ind]) prevRes --;\\n                else if(arr[ind] == arr[ind + 1]) prevRes --;\\n            }\\n            if(ind == 0 && ind + 1 < n && arr[ind] != 0){\\n                if(arr[ind] == arr[ind + 1]) prevRes -= 1;\\n            }else if(ind == n - 1 && ind - 1 >= 0 && arr[ind] != 0){\\n                if(arr[ind] == arr[ind - 1]) prevRes -= 1;\\n            }\\n            \\n            arr[ind] = query[1];\\n            if(ind > 0 && ind < n - 1){\\n                if(arr[ind - 1] == arr[ind] && arr[ind] == arr[ind + 1]) prevRes += 2;\\n                else if(arr[ind - 1] == arr[ind]) prevRes ++;\\n                else if(arr[ind] == arr[ind + 1]) prevRes ++;\\n            }\\n            if(ind == 0 && ind + 1 < n){\\n                if(arr[ind] == arr[ind + 1]) prevRes += 1;\\n            }else if(ind == n - 1 && ind - 1 >= 0){\\n                if(arr[ind] == arr[ind - 1]) prevRes += 1;\\n            }\\n            res[count] = prevRes;\\n            count ++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n        int[] arr = new int[n];\\n        int res[] = new int[queries.length], prevRes = 0, count = 0;\\n        for(int query[]: queries){\\n            int ind = query[0];\\n            if(ind > 0 && ind < n - 1 && arr[ind] != 0){\\n                if(arr[ind - 1] == arr[ind] && arr[ind] == arr[ind + 1]) prevRes -= 2;\\n                else if(arr[ind - 1] == arr[ind]) prevRes --;\\n                else if(arr[ind] == arr[ind + 1]) prevRes --;\\n            }\\n            if(ind == 0 && ind + 1 < n && arr[ind] != 0){\\n                if(arr[ind] == arr[ind + 1]) prevRes -= 1;\\n            }else if(ind == n - 1 && ind - 1 >= 0 && arr[ind] != 0){\\n                if(arr[ind] == arr[ind - 1]) prevRes -= 1;\\n            }\\n            \\n            arr[ind] = query[1];\\n            if(ind > 0 && ind < n - 1){\\n                if(arr[ind - 1] == arr[ind] && arr[ind] == arr[ind + 1]) prevRes += 2;\\n                else if(arr[ind - 1] == arr[ind]) prevRes ++;\\n                else if(arr[ind] == arr[ind + 1]) prevRes ++;\\n            }\\n            if(ind == 0 && ind + 1 < n){\\n                if(arr[ind] == arr[ind + 1]) prevRes += 1;\\n            }else if(ind == n - 1 && ind - 1 >= 0){\\n                if(arr[ind] == arr[ind - 1]) prevRes += 1;\\n            }\\n            res[count] = prevRes;\\n            count ++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495880,
                "title": "properly-commented-beginner-friendly-fast-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n    int[]ans=new int[queries.length];//this is the answer array\\n    int []nums=new int[n];//nums array of length n\\n    int count=0;//it stores the number of adjacent element\\n    for(int i=0;i<queries.length;i++){\\n    int index=queries[i][0];\\n    int prevval=nums[index];//it store the previous value of the index\\n    //guyz before panting the index we check that if the previous value is contributing to the count variable or not in simple words we are gonna check that if the previous value has the same colored adjacent values or not if yes then we are gonna subtract 2(if both adjacent were same) or 1(if only one adjacent is same)\\n    if(prevval!=0)\\n    {\\n    if(index>0&&prevval==nums[index-1]&&index<nums.length-1&&prevval==nums[index+1]){\\n        count-=2;\\n    }\\n    else if(index>0&&prevval==nums[index-1]||index<nums.length-1&&prevval==nums[index+1]){\\n        count-=1;\\n    }\\n    }\\n    nums[index]=queries[i][1];\\n//now after coloring the index we check whether the index have same colored adjacent or not if yes then we will add values in the count variable accordingly\\n    if(index>0&&nums[index]==nums[index-1]&&index<nums.length-1&&nums[index]==nums[index+1]){\\n        count+=2;\\n    }\\n    else if(index>0&&nums[index]==nums[index-1]||index<nums.length-1&&nums[index]==nums[index+1]){\\n        count+=1;\\n    }\\n\\n    ans[i]=count;//storing the count variable value into answer array\\n\\n    }\\n\\n    return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] colorTheArray(int n, int[][] queries) {\\n    int[]ans=new int[queries.length];//this is the answer array\\n    int []nums=new int[n];//nums array of length n\\n    int count=0;//it stores the number of adjacent element\\n    for(int i=0;i<queries.length;i++){\\n    int index=queries[i][0];\\n    int prevval=nums[index];//it store the previous value of the index\\n    //guyz before panting the index we check that if the previous value is contributing to the count variable or not in simple words we are gonna check that if the previous value has the same colored adjacent values or not if yes then we are gonna subtract 2(if both adjacent were same) or 1(if only one adjacent is same)\\n    if(prevval!=0)\\n    {\\n    if(index>0&&prevval==nums[index-1]&&index<nums.length-1&&prevval==nums[index+1]){\\n        count-=2;\\n    }\\n    else if(index>0&&prevval==nums[index-1]||index<nums.length-1&&prevval==nums[index+1]){\\n        count-=1;\\n    }\\n    }\\n    nums[index]=queries[i][1];\\n//now after coloring the index we check whether the index have same colored adjacent or not if yes then we will add values in the count variable accordingly\\n    if(index>0&&nums[index]==nums[index-1]&&index<nums.length-1&&nums[index]==nums[index+1]){\\n        count+=2;\\n    }\\n    else if(index>0&&nums[index]==nums[index-1]||index<nums.length-1&&nums[index]==nums[index+1]){\\n        count+=1;\\n    }\\n\\n    ans[i]=count;//storing the count variable value into answer array\\n\\n    }\\n\\n    return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495771,
                "title": "python-with-explain-is-cumulative-count",
                "content": "# Intuition\\n Each query operation colors an element at a specific index. The color array and counter are updated accordingly. After each query, the ***cumulative count*** of adjacent elements with the same non-zero color is calculated. The previous adjacent elements are checked and updated (-1) before adding the new element, and then the neighboring elements are checked again to determine if they should be counted (+1).\\n\\n\\nI didn\\'t notice the problem of calculating the accumulation ...\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n        \\n        res = []\\n        nums = [0]*n\\n        count = 0\\n\\n        for i in range(len(queries)):\\n            \\n            index, color = queries[i][0], queries[i][1]\\n\\n            if index-1 >= 0 and nums[index] != 0 and nums[index-1] == nums[index]:\\n                count -= 1\\n            if index+1 < len(nums) and nums[index] != 0 and nums[index+1] == nums[index]:\\n                count -= 1\\n            \\n            nums[index] = color\\n\\n            if index-1 >= 0 and nums[index] != 0 and nums[index-1] == nums[index]:\\n                count += 1\\n            if index+1 < len(nums) and nums[index] != 0 and nums[index+1] == nums[index]:\\n                count += 1\\n\\n            res.append(count)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\\n        \\n        res = []\\n        nums = [0]*n\\n        count = 0\\n\\n        for i in range(len(queries)):\\n            \\n            index, color = queries[i][0], queries[i][1]\\n\\n            if index-1 >= 0 and nums[index] != 0 and nums[index-1] == nums[index]:\\n                count -= 1\\n            if index+1 < len(nums) and nums[index] != 0 and nums[index+1] == nums[index]:\\n                count -= 1\\n            \\n            nums[index] = color\\n\\n            if index-1 >= 0 and nums[index] != 0 and nums[index-1] == nums[index]:\\n                count += 1\\n            if index+1 < len(nums) and nums[index] != 0 and nums[index+1] == nums[index]:\\n                count += 1\\n\\n            res.append(count)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495650,
                "title": "c-o-length-of-queries-using-map",
                "content": "# Intuition\\nKeep a count of the values as we iterate inside a map. Any change to that index, check if it still maintains its adjacent rule. If not, decrease the count!\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        unordered_map<int,int>mp;\\n        vector<int> ans;\\n        vector<int> arr(n,0);\\n        for(int i=0;i<queries.size();i++){\\n            int idx=queries[i][0];\\n            int col = queries[i][1];\\n            arr[idx]=col;\\n                           \\n            if(idx>0 && idx<n && arr[idx-1]==arr[idx]){\\n cout<<\",\"<<mp.size();\\n                mp[idx]=1;\\n            }\\n            if(idx<n-1 && idx>=0 && arr[idx]==arr[idx+1]){\\n  cout<<\",\"<<mp.size();\\n                mp[idx+1]=1;\\n            }\\n            if(idx>0 && idx<n && arr[idx-1]!=arr[idx] && mp.count(idx)>0){\\n\\n                mp.erase(idx);\\n            }\\n            if(idx<n-1 && idx>=0 && arr[idx]!=arr[idx+1] && mp.count(idx+1)>0){\\n \\n                mp.erase(idx+1);\\n            }\\n\\n            ans.push_back(mp.size());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\\n        unordered_map<int,int>mp;\\n        vector<int> ans;\\n        vector<int> arr(n,0);\\n        for(int i=0;i<queries.size();i++){\\n            int idx=queries[i][0];\\n            int col = queries[i][1];\\n            arr[idx]=col;\\n                           \\n            if(idx>0 && idx<n && arr[idx-1]==arr[idx]){\\n cout<<\",\"<<mp.size();\\n                mp[idx]=1;\\n            }\\n            if(idx<n-1 && idx>=0 && arr[idx]==arr[idx+1]){\\n  cout<<\",\"<<mp.size();\\n                mp[idx+1]=1;\\n            }\\n            if(idx>0 && idx<n && arr[idx-1]!=arr[idx] && mp.count(idx)>0){\\n\\n                mp.erase(idx);\\n            }\\n            if(idx<n-1 && idx>=0 && arr[idx]!=arr[idx+1] && mp.count(idx+1)>0){\\n \\n                mp.erase(idx+1);\\n            }\\n\\n            ans.push_back(mp.size());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3495552,
                "title": "runtime-and-memory-beats-100-using-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} queries\\n * @return {number[]}\\n */\\nvar colorTheArray = function(n, queries) {\\n    let nums = Array(n).fill(0);\\n    let ans = [];\\n    let memo = 0;\\n    for (let i = 0; i < queries.length; i++) {\\n        let [index, color] = queries[i];\\n\\n        if (index > 0 && index < n && nums[index] !== 0 && nums[index - 1] === nums[index]) {\\n            memo--;\\n        }\\n        if (index >= 0 && index < n - 1 && nums[index] !== 0 && nums[index + 1] === nums[index]) {\\n            memo--;\\n        }\\n\\n        nums[index] = color;\\n\\n        if (index > 0 && index < n && nums[index] !== 0 && nums[index - 1] === nums[index]) {\\n            memo++;\\n        }\\n        if (index >= 0 && index < n - 1 && nums[index] !== 0 && nums[index + 1] === nums[index]) {\\n            memo++;\\n        }\\n        ans.push(memo);\\n\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} queries\\n * @return {number[]}\\n */\\nvar colorTheArray = function(n, queries) {\\n    let nums = Array(n).fill(0);\\n    let ans = [];\\n    let memo = 0;\\n    for (let i = 0; i < queries.length; i++) {\\n        let [index, color] = queries[i];\\n\\n        if (index > 0 && index < n && nums[index] !== 0 && nums[index - 1] === nums[index]) {\\n            memo--;\\n        }\\n        if (index >= 0 && index < n - 1 && nums[index] !== 0 && nums[index + 1] === nums[index]) {\\n            memo--;\\n        }\\n\\n        nums[index] = color;\\n\\n        if (index > 0 && index < n && nums[index] !== 0 && nums[index - 1] === nums[index]) {\\n            memo++;\\n        }\\n        if (index >= 0 && index < n - 1 && nums[index] !== 0 && nums[index + 1] === nums[index]) {\\n            memo++;\\n        }\\n        ans.push(memo);\\n\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1885909,
                "content": [
                    {
                        "username": "shivamchaurasia2912",
                        "content": "The Problem Statement can be improved!  :)\\n"
                    },
                    {
                        "username": "dondublon",
                        "content": "The description in really unclear. \"adjacent\" to what? \"same color\" with which one?"
                    },
                    {
                        "username": "victCh",
                        "content": "Simple solution, but a very complex and unclear condition of the problem."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "TLE !! any help ?"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "Don't overcomplicate things , just focus on hints given\n\nYou can refer to this solution:   (https://leetcode.com/problems/number-of-adjacent-elements-with-the-same-color/solutions/3495191/too-lazy-to-explain/[leetcode)"
                    }
                ]
            },
            {
                "id": 1938646,
                "content": [
                    {
                        "username": "shivamchaurasia2912",
                        "content": "The Problem Statement can be improved!  :)\\n"
                    },
                    {
                        "username": "dondublon",
                        "content": "The description in really unclear. \"adjacent\" to what? \"same color\" with which one?"
                    },
                    {
                        "username": "victCh",
                        "content": "Simple solution, but a very complex and unclear condition of the problem."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "TLE !! any help ?"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "Don't overcomplicate things , just focus on hints given\n\nYou can refer to this solution:   (https://leetcode.com/problems/number-of-adjacent-elements-with-the-same-color/solutions/3495191/too-lazy-to-explain/[leetcode)"
                    }
                ]
            },
            {
                "id": 1887072,
                "content": [
                    {
                        "username": "shivamchaurasia2912",
                        "content": "The Problem Statement can be improved!  :)\\n"
                    },
                    {
                        "username": "dondublon",
                        "content": "The description in really unclear. \"adjacent\" to what? \"same color\" with which one?"
                    },
                    {
                        "username": "victCh",
                        "content": "Simple solution, but a very complex and unclear condition of the problem."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "TLE !! any help ?"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "Don't overcomplicate things , just focus on hints given\n\nYou can refer to this solution:   (https://leetcode.com/problems/number-of-adjacent-elements-with-the-same-color/solutions/3495191/too-lazy-to-explain/[leetcode)"
                    }
                ]
            },
            {
                "id": 1936711,
                "content": [
                    {
                        "username": "shivamchaurasia2912",
                        "content": "The Problem Statement can be improved!  :)\\n"
                    },
                    {
                        "username": "dondublon",
                        "content": "The description in really unclear. \"adjacent\" to what? \"same color\" with which one?"
                    },
                    {
                        "username": "victCh",
                        "content": "Simple solution, but a very complex and unclear condition of the problem."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "TLE !! any help ?"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "Don't overcomplicate things , just focus on hints given\n\nYou can refer to this solution:   (https://leetcode.com/problems/number-of-adjacent-elements-with-the-same-color/solutions/3495191/too-lazy-to-explain/[leetcode)"
                    }
                ]
            },
            {
                "id": 1885455,
                "content": [
                    {
                        "username": "shivamchaurasia2912",
                        "content": "The Problem Statement can be improved!  :)\\n"
                    },
                    {
                        "username": "dondublon",
                        "content": "The description in really unclear. \"adjacent\" to what? \"same color\" with which one?"
                    },
                    {
                        "username": "victCh",
                        "content": "Simple solution, but a very complex and unclear condition of the problem."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "TLE !! any help ?"
                    },
                    {
                        "username": "Cdr_Rjt",
                        "content": "Don't overcomplicate things , just focus on hints given\n\nYou can refer to this solution:   (https://leetcode.com/problems/number-of-adjacent-elements-with-the-same-color/solutions/3495191/too-lazy-to-explain/[leetcode)"
                    }
                ]
            }
        ]
    },
    {
        "title": "Find the Losers of the Circular Game",
        "question_content": "<p>There are <code>n</code> friends that are playing a game. The friends are sitting in a circle and are numbered from <code>1</code> to <code>n</code> in <strong>clockwise order</strong>. More formally, moving clockwise from the <code>i<sup>th</sup></code> friend brings you to the <code>(i+1)<sup>th</sup></code> friend for <code>1 &lt;= i &lt; n</code>, and moving clockwise from the <code>n<sup>th</sup></code> friend brings you to the <code>1<sup>st</sup></code> friend.</p>\n\n<p>The rules of the game are as follows:</p>\n\n<p><code>1<sup>st</sup></code> friend receives the ball.</p>\n\n<ul>\n\t<li>After that, <code>1<sup>st</sup></code> friend passes it to the friend who is <code>k</code> steps away from them in the <strong>clockwise</strong> direction.</li>\n\t<li>After that, the friend who receives the ball should pass it to the friend who is <code>2 * k</code> steps away from them in the <strong>clockwise</strong> direction.</li>\n\t<li>After that, the friend who receives the ball should pass it to the friend who is <code>3 * k</code> steps away from them in the <strong>clockwise</strong> direction, and so on and so forth.</li>\n</ul>\n\n<p>In other words, on the <code>i<sup>th</sup></code> turn, the friend holding the ball should pass it to the friend who is <code>i * k</code> steps away from them in the <strong>clockwise</strong> direction.</p>\n\n<p>The game is finished when some friend receives the ball for the second time.</p>\n\n<p>The <strong>losers</strong> of the game are friends who did not receive the ball in the entire game.</p>\n\n<p>Given the number of friends, <code>n</code>, and an integer <code>k</code>, return <em>the array answer, which contains the losers of the game in the <strong>ascending</strong> order</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 5, k = 2\n<strong>Output:</strong> [4,5]\n<strong>Explanation:</strong> The game goes as follows:\n1) Start at 1<sup>st</sup>&nbsp;friend and pass the ball to the friend who is 2 steps away from them - 3<sup>rd</sup>&nbsp;friend.\n2) 3<sup>rd</sup>&nbsp;friend passes the ball to the friend who is 4 steps away from them - 2<sup>nd</sup>&nbsp;friend.\n3) 2<sup>nd</sup>&nbsp;friend passes the ball to the friend who is 6 steps away from them  - 3<sup>rd</sup>&nbsp;friend.\n4) The game ends as 3<sup>rd</sup>&nbsp;friend receives the ball for the second time.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 4, k = 4\n<strong>Output:</strong> [2,3,4]\n<strong>Explanation:</strong> The game goes as follows:\n1) Start at the 1<sup>st</sup>&nbsp;friend and pass the ball to the friend who is 4 steps away from them - 1<sup>st</sup>&nbsp;friend.\n2) The game ends as 1<sup>st</sup>&nbsp;friend receives the ball for the second time.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= n &lt;= 50</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3522190,
                "title": "simulation",
                "content": "We pre-populate the result array with all numbers, and set a number to zero once visited.\\n\\nAfter the simulation, we return remaining non-zero numbers.\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        s = set([i for i in range(1, n + 1)])\\n        for mul in accumulate([i for i in range(n)]):\\n            if k * mul % n + 1 not in s:\\n                break\\n            s.remove(k * mul % n + 1)\\n        return s\\n```\\n\\n**C++**\\n``` cpp\\nvector<int> circularGameLosers(int n, int k) {\\n    vector<int> res(n);\\n    iota(begin(res), end(res), 1);\\n    for (int cur = 0, mul = 1; res[cur]; ++mul) {\\n        res[cur] = 0;\\n        cur = (cur + mul * k) % n;\\n    }\\n    res.erase(remove(begin(res), end(res), 0), end(res));\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "Python3",
                    "C"
                ],
                "code": "```python\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        s = set([i for i in range(1, n + 1)])\\n        for mul in accumulate([i for i in range(n)]):\\n            if k * mul % n + 1 not in s:\\n                break\\n            s.remove(k * mul % n + 1)\\n        return s\\n```\n``` cpp\\nvector<int> circularGameLosers(int n, int k) {\\n    vector<int> res(n);\\n    iota(begin(res), end(res), 1);\\n    for (int cur = 0, mul = 1; res[cur]; ++mul) {\\n        res[cur] = 0;\\n        cur = (cur + mul * k) % n;\\n    }\\n    res.erase(remove(begin(res), end(res), 0), end(res));\\n    return res;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521949,
                "title": "simple-bruteforce",
                "content": "\\n<b>Up vote if you like the solution</b>\\n\\n# Approach \\n1. Just take an array and keep tracking its value with bruteforce.\\n    \\n# Code\\n\\n```\\nvector<int> circularGameLosers(int n, int k) {\\n    vector<int> v(n, 0);\\n    int i = 1, t = 0; \\n    while(v[i-1] == 0){\\n        v[i-1] = 1;\\n        t = t + k;\\n        i = (i + t)%n;\\n        if(i == 0) i = n;\\n    }\\n    vector<int> ans;\\n    for(int i = 0; i < v.size(); ++i){\\n        if(v[i] == 0) ans.push_back(i+1);\\n    }\\n    return ans;\\n}\\n```\\n\\n<b>Here is an article of my last interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nvector<int> circularGameLosers(int n, int k) {\\n    vector<int> v(n, 0);\\n    int i = 1, t = 0; \\n    while(v[i-1] == 0){\\n        v[i-1] = 1;\\n        t = t + k;\\n        i = (i + t)%n;\\n        if(i == 0) i = n;\\n    }\\n    vector<int> ans;\\n    for(int i = 0; i < v.size(); ++i){\\n        if(v[i] == 0) ans.push_back(i+1);\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3521902,
                "title": "simple-clean-java-solution",
                "content": "\\n```java []\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        boolean visited[] = new boolean[n];\\n        int v = 0, i=0;\\n        while(visited[i%n] == false){\\n            v++;\\n            visited[i%n] = true;\\n            i += v*k;\\n        }\\n        int[] res = new int[n-v];\\n        int j=0;\\n        for(i=0; i<visited.length; i++){\\n            if(visited[i] == false) res[j++]=i+1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        boolean visited[] = new boolean[n];\\n        int v = 0, i=0;\\n        while(visited[i%n] == false){\\n            v++;\\n            visited[i%n] = true;\\n            i += v*k;\\n        }\\n        int[] res = new int[n-v];\\n        int j=0;\\n        for(i=0; i<visited.length; i++){\\n            if(visited[i] == false) res[j++]=i+1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522531,
                "title": "most-optimised-c-easy-to-understnad",
                "content": "make an array of size n. initially no one have ball so all are false.\\n1st person have ball\\nthan 1+i*k person have ball (i = ith step)\\nmodulo is use for circular\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        int x = 1,y=1;\\n        vector<int> v(n+1,false);\\n            // cout<<y<<\" \";\\n        while(!v[y]){\\n            v[y] = true;\\n            y = ((y+x*k)%n);\\n            if(y==0)y = n;\\n            // cout<<y<<\" \";\\n            x++;\\n        }\\n        vector<int> ans;\\n        for(x = 1; x <= n; x++){\\n            if(!v[x])ans.push_back(x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Game Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        int x = 1,y=1;\\n        vector<int> v(n+1,false);\\n            // cout<<y<<\" \";\\n        while(!v[y]){\\n            v[y] = true;\\n            y = ((y+x*k)%n);\\n            if(y==0)y = n;\\n            // cout<<y<<\" \";\\n            x++;\\n        }\\n        vector<int> ans;\\n        for(x = 1; x <= n; x++){\\n            if(!v[x])ans.push_back(x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3522350,
                "title": "c-best-solution-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> vis(n, 0);\\n        int i=0, j=1;\\n        while(1)    {\\n            if(vis[i] == 1) break;\\n            vis[i] = 1;\\n            i = (i + j*k) % n;\\n            j++;\\n        }\\n        vector<int> ans;\\n        for(int i=0; i<n; i++)  {\\n            if(vis[i] == 0) ans.push_back(i+1);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> vis(n, 0);\\n        int i=0, j=1;\\n        while(1)    {\\n            if(vis[i] == 1) break;\\n            vis[i] = 1;\\n            i = (i + j*k) % n;\\n            j++;\\n        }\\n        vector<int> ans;\\n        for(int i=0; i<n; i++)  {\\n            if(vis[i] == 0) ans.push_back(i+1);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3528741,
                "title": "java-beats-99-10-lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Maintain a boolean map of size `n`.\\n2. Simulate the scenario described in the problem statement and keep marking each player that receives the ball in the map.\\n3. Break the loop once the ball reaches a player that had already got it before.\\n4. Parse through the boolean map and extract the indices of the players that didn\\'t receive the ball at all.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int[] circularGameLosers(int n, int k) {\\n    var map = new boolean[n];\\n    int x = 0, i;\\n    \\n    for (i=1; !map[x]; i++) {\\n      map[x] = true;\\n      x = (x + i*k) % n;\\n    }\\n    var ans = new int[n-i+1];\\n    var j = 0;\\n\\n    for (i=0; i<n; i++)\\n      if (!map[i])\\n        ans[j++] = i+1;\\n\\n    return ans;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n  public int[] circularGameLosers(int n, int k) {\\n    var map = new boolean[n];\\n    int x = 0, i;\\n    \\n    for (i=1; !map[x]; i++) {\\n      map[x] = true;\\n      x = (x + i*k) % n;\\n    }\\n    var ans = new int[n-i+1];\\n    var j = 0;\\n\\n    for (i=0; i<n; i++)\\n      if (!map[i])\\n        ans[j++] = i+1;\\n\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522093,
                "title": "simulation-easy-python-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        start = 0\\n        sset = set()\\n        p = 1\\n        while start not in sset:\\n            sset.add(start)\\n            start += p*k\\n            start = start%n\\n            p += 1\\n        ans = []\\n        for i in range(n):\\n            if i not in sset:\\n                ans.append(i+1)\\n        return ans\\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        start = 0\\n        sset = set()\\n        p = 1\\n        while start not in sset:\\n            sset.add(start)\\n            start += p*k\\n            start = start%n\\n            p += 1\\n        ans = []\\n        for i in range(n):\\n            if i not in sset:\\n                ans.append(i+1)\\n        return ans\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531491,
                "title": "python-3-7-lines-w-example-t-m-100-78",
                "content": "```\\nclass Solution:\\n    def circularGameLosers(self, n, k):\\n\\n        remain, ball, nxt = set(N:=range(1,n)), k,0\\n\\n        for _ in N:                         #  Example: n = 5   k = 2\\n\\n            nxt = (nxt + ball)%n            #  ball     nxt    remain\\n            if nxt not in remain: break     #  -----   -----   -----\\n                                            #    2       0     [1, 2, 3, 4]\\n            remain.remove(nxt)              #    4       2     [1, 3, 4]\\n            ball+= k                        #    6       1     [3, 4]\\n                                            #    6       2     [3, 4] <-- 2 appears again\\n\\n        return [i+1 for i in remain]        #  return [3+1, 4+1] --> [4, 5]\\n```\\n[https://leetcode.com/problems/find-the-losers-of-the-circular-game/submissions/1006269450/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*).\\n\\n[Edited 7/28/23] See [@almostmonday](/almostmonday) in comments.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def circularGameLosers(self, n, k):\\n\\n        remain, ball, nxt = set(N:=range(1,n)), k,0\\n\\n        for _ in N:                         #  Example: n = 5   k = 2\\n\\n            nxt = (nxt + ball)%n            #  ball     nxt    remain\\n            if nxt not in remain: break     #  -----   -----   -----\\n                                            #    2       0     [1, 2, 3, 4]\\n            remain.remove(nxt)              #    4       2     [1, 3, 4]\\n            ball+= k                        #    6       1     [3, 4]\\n                                            #    6       2     [3, 4] <-- 2 appears again\\n\\n        return [i+1 for i in remain]        #  return [3+1, 4+1] --> [4, 5]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3523206,
                "title": "poetic-solution-experimental-solution-c",
                "content": "# Code in Poem\\n\\nAmidst a circle of players fair,\\nA game is played with utmost care.\\nEvery kth player must be gone,\\nUntil just one is left alone.\\n\\nTo simulate this game we\\'ll try,\\nUsing a map to bid goodbye.\\nEliminating till the end,\\nKeeping track of all our friends.\\n\\nWith time complexity of n,\\nAnd space complexity of the same yen.\\nThe code we\\'ll write in just a snap,\\nTo solve the problem with a tap.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n         vector<int> ans;\\n        map<int,int> mp;\\n        int i=1,j=k;\\n       \\n        \\n        while(mp.find(i)==mp.end())\\n        {\\n            mp[i]++;\\n            i = (i+k)%n;\\n            if(i == 0)\\n            {\\n                i = n;\\n            }\\n            \\n            k=k+j;\\n            \\n        }\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            if(mp.find(i) == mp.end())\\n            {\\n                ans.push_back(i);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n         vector<int> ans;\\n        map<int,int> mp;\\n        int i=1,j=k;\\n       \\n        \\n        while(mp.find(i)==mp.end())\\n        {\\n            mp[i]++;\\n            i = (i+k)%n;\\n            if(i == 0)\\n            {\\n                i = n;\\n            }\\n            \\n            k=k+j;\\n            \\n        }\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            if(mp.find(i) == mp.end())\\n            {\\n                ans.push_back(i);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535150,
                "title": "python-simple-and-clean-beats-99-99",
                "content": "### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n\\n*This is an NFT*\\n\\n\\n# Intuition\\nThe problem asks us to find the losers of a circular game played by n friends sitting in a circle. The game involves passing a ball between friends according to certain rules. The losers of the game are friends who did not receive the ball in the entire game. Our first thought might be to simulate the game and keep track of the friends who have received the ball.\\n\\n# Approach\\n1. We can use an array `visited` of size n to keep track of the friends who have received the ball. We initialize all elements of `visited` to 0.\\n2. We then use a while loop to simulate the game. In each iteration of the loop, we calculate the next friend to receive the ball using the formula `pos = (pos+(count*k))%n` where `pos` is the current friend holding the ball, `count` is the turn number, and `k` is the number of steps to move in the clockwise direction.\\n3. We increment `visited[pos]` by 1 to indicate that this friend has received the ball. If `visited[pos]` becomes 2, it means that this friend has received the ball for the second time and the game is finished.\\n4. After simulating the game, we can iterate over `visited` and add all friends who have not received the ball to a list `res`. We then return `res` which contains the losers of the game.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ where n is the number of friends. This is because we need to simulate n turns of the game and each turn takes constant time.\\n- Space complexity: $$O(n)$$ since we use an array of size n to keep track of the friends who have received the ball.\\n\\n# Code\\n```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        visited = [0] * n\\n        count = 1\\n        pos = 0\\n        visited[pos] = 1\\n        while (visited[pos]!=2):\\n            pos = (pos+(count*k))%n\\n            visited[pos]+=1\\n            count+=1\\n        res = []\\n        for i in range(n):\\n            if not visited[i]:\\n                res.append(i+1)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        visited = [0] * n\\n        count = 1\\n        pos = 0\\n        visited[pos] = 1\\n        while (visited[pos]!=2):\\n            pos = (pos+(count*k))%n\\n            visited[pos]+=1\\n            count+=1\\n        res = []\\n        for i in range(n):\\n            if not visited[i]:\\n                res.append(i+1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534872,
                "title": "python-simple-and-clean-beats-93-99",
                "content": "# Intuition\\nThe problem asks us to find the losers of a circular game played by n friends sitting in a circle. The game involves passing a ball between friends according to certain rules. The losers of the game are friends who did not receive the ball in the entire game. Our first thought might be to simulate the game and keep track of the friends who have not received the ball yet.\\n\\n# Approach\\n1. We can use a list `res` to keep track of the friends who have not received the ball yet. We initialize `res` with all the friends from 1 to n and remove the first friend since they receive the ball first.\\n2. We then use a while loop to simulate the game. In each iteration of the loop, we calculate the next friend to receive the ball using the formula `curr = (curr+(count*k))%n` where `curr` is the current friend holding the ball, `count` is the turn number, and `k` is the number of steps to move in the clockwise direction.\\n3. If `curr` is not in `res`, it means that this friend has already received the ball and the game is finished. In this case, we return `res` which contains the losers of the game. Otherwise, we remove `curr` from `res` and increment `count`.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$ where n is the number of friends. This is because in the worst case, we need to remove n-1 elements from `res`, and removing an element from a list takes $$O(n)$$ time.\\n- Space complexity: $$O(n)$$ since we use a list of size n to keep track of the friends who have not received the ball yet.\\n\\n# Code\\n```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        res = [i for i in range(1,n+1)]\\n        res.remove(1)\\n        curr = 1\\n        count = 1\\n        while True:\\n            curr = (curr+(count*k))%n\\n            if curr == 0:\\n                curr = n\\n            if curr not in res:\\n                return res\\n            else:\\n                res.remove(curr)\\n            count+=1                \\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        res = [i for i in range(1,n+1)]\\n        res.remove(1)\\n        curr = 1\\n        count = 1\\n        while True:\\n            curr = (curr+(count*k))%n\\n            if curr == 0:\\n                curr = n\\n            if curr not in res:\\n                return res\\n            else:\\n                res.remove(curr)\\n            count+=1                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522915,
                "title": "easy-brute-force",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        Set<Integer> gotBall = new HashSet<>();\\n        \\n        for(int i=1,mul=1;!gotBall.contains(i); i = (i+(k*mul))%n,mul++){\\n            gotBall.add(i);\\n        }\\n        if(gotBall.contains(0)){\\n            gotBall.add(n);\\n            gotBall.remove(0);\\n        }\\n        int[] ans = new int[n-gotBall.size()];\\n        int index = 0;\\n        for(int i=1;i<=n;i++) if(!gotBall.contains(i)) ans[index++] = i;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        Set<Integer> gotBall = new HashSet<>();\\n        \\n        for(int i=1,mul=1;!gotBall.contains(i); i = (i+(k*mul))%n,mul++){\\n            gotBall.add(i);\\n        }\\n        if(gotBall.contains(0)){\\n            gotBall.add(n);\\n            gotBall.remove(0);\\n        }\\n        int[] ans = new int[n-gotBall.size()];\\n        int index = 0;\\n        for(int i=1;i<=n;i++) if(!gotBall.contains(i)) ans[index++] = i;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525573,
                "title": "java-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEach time it goes to the Remaider\\'s friend. Use hashMap to cache all the friend (remainder) caught the ball.\\n\\nNote it is 1 indexed, so has to transform to 0 indexed for easy to adop remaineder.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\npublic int[] circularGameLosers(int n, int k) {\\n    Set<Integer> vis = new HashSet<>();\\n    int i = 0, rem = 0;\\n    while(true) {\\n        rem = (rem + k * i++) % n;\\n        if (!vis.add(rem)) break; //rem has been visited\\n    }\\n    int j = 0, res[] = new int[n - vis.size()];\\n    for (i = 0; i < n; i++) {\\n        if (!vis.contains(i)) res[j++] = i + 1;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] circularGameLosers(int n, int k) {\\n    Set<Integer> vis = new HashSet<>();\\n    int i = 0, rem = 0;\\n    while(true) {\\n        rem = (rem + k * i++) % n;\\n        if (!vis.add(rem)) break; //rem has been visited\\n    }\\n    int j = 0, res[] = new int[n - vis.size()];\\n    for (i = 0; i < n; i++) {\\n        if (!vis.contains(i)) res[j++] = i + 1;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3522056,
                "title": "c-easy-to-understand-hashing-brute-force-approach",
                "content": "## Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        map<int,int> mp;\\n        int i=1; int turn=1;\\n        while (mp[i]!=1){\\n            mp[i]++;\\n            int addy= (i+(turn*k));\\n            if (addy%n==0)i=n;\\n            else i= addy%n;\\n            turn++;\\n        }\\n        vector<int> ans;\\n        for (int i=1; i<=n; i++){\\n            if (mp[i]==0)ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        map<int,int> mp;\\n        int i=1; int turn=1;\\n        while (mp[i]!=1){\\n            mp[i]++;\\n            int addy= (i+(turn*k));\\n            if (addy%n==0)i=n;\\n            else i= addy%n;\\n            turn++;\\n        }\\n        vector<int> ans;\\n        for (int i=1; i<=n; i++){\\n            if (mp[i]==0)ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521921,
                "title": "java-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        boolean[] visited = new boolean[n];\\n        visited[0] = true;\\n        \\n        int i = 0;\\n        int x = 1;      \\n        while(!visited[(i + (x*k)) % n]) {\\n            visited[(i + (x*k)) % n] = true;\\n            i = (i + (x*k)) % n;\\n            x++;\\n        }\\n        \\n        int count = 0; \\n        for(boolean b : visited) {\\n            if(!b) {\\n                count++;\\n            }\\n        }\\n        \\n        int[]ans = new int[count];\\n        int index = 0;\\n        for(int j = 0; j < visited.length; j++) {\\n            if(!visited[j]) {\\n                ans[index++] = j+1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        boolean[] visited = new boolean[n];\\n        visited[0] = true;\\n        \\n        int i = 0;\\n        int x = 1;      \\n        while(!visited[(i + (x*k)) % n]) {\\n            visited[(i + (x*k)) % n] = true;\\n            i = (i + (x*k)) % n;\\n            x++;\\n        }\\n        \\n        int count = 0; \\n        for(boolean b : visited) {\\n            if(!b) {\\n                count++;\\n            }\\n        }\\n        \\n        int[]ans = new int[count];\\n        int index = 0;\\n        for(int j = 0; j < visited.length; j++) {\\n            if(!visited[j]) {\\n                ans[index++] = j+1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971113,
                "title": "c-bool-array",
                "content": "```\\npublic class Solution {\\n    public int[] CircularGameLosers(int n, int k)\\n    {\\n        bool[] game = new bool[n];\\n\\n        for (int i = 0, j = 0; !game[i]; i = (i + ++j * k) % n)\\n        {\\n            game[i] = true;\\n        }\\n\\n        var losers = new List<int>();\\n\\n        for (int i = 0; i < game.Length; i++)\\n        {\\n            if (!game[i])\\n            {\\n                losers.Add(i + 1);\\n            }\\n        }\\n\\n        return losers.ToArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] CircularGameLosers(int n, int k)\\n    {\\n        bool[] game = new bool[n];\\n\\n        for (int i = 0, j = 0; !game[i]; i = (i + ++j * k) % n)\\n        {\\n            game[i] = true;\\n        }\\n\\n        var losers = new List<int>();\\n\\n        for (int i = 0; i < game.Length; i++)\\n        {\\n            if (!game[i])\\n            {\\n                losers.Add(i + 1);\\n            }\\n        }\\n\\n        return losers.ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688006,
                "title": "java-clean-code-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n\\n        // the game simulation\\n        final boolean[] friends = new boolean[n];\\n        int index = 0;\\n        int counter = 0;\\n        int loosersAmount = n;\\n\\n        // the game is finished when some friend receives the ball for the second time\\n        while (!friends[index]) {\\n            friends[index] = true;\\n            --loosersAmount;\\n\\n            index = (index + ++counter * k) % n;\\n        }\\n\\n        // let\\'s gather the loosers\\n        final int[] loosers = new int[loosersAmount];\\n        int loosersCount = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (!friends[i]) {\\n                loosers[loosersCount++] = i + 1;\\n            }\\n        }\\n\\n        return loosers;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n\\n        // the game simulation\\n        final boolean[] friends = new boolean[n];\\n        int index = 0;\\n        int counter = 0;\\n        int loosersAmount = n;\\n\\n        // the game is finished when some friend receives the ball for the second time\\n        while (!friends[index]) {\\n            friends[index] = true;\\n            --loosersAmount;\\n\\n            index = (index + ++counter * k) % n;\\n        }\\n\\n        // let\\'s gather the loosers\\n        final int[] loosers = new int[loosersAmount];\\n        int loosersCount = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (!friends[i]) {\\n                loosers[loosersCount++] = i + 1;\\n            }\\n        }\\n\\n        return loosers;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3646969,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        int i=0,rem=0;\\n        ArrayList<Integer> set=new ArrayList<>();\\n        while(true){\\n            rem=(rem+(k*i))%n;\\n            if(set.contains(rem+1)){\\n                break;\\n            }\\n            else{\\n                set.add(rem+1);\\n            }\\n            i++;\\n        }\\n        ArrayList<Integer> list=new ArrayList<>();\\n        for(i=1;i<=n;i++){\\n           if(!set.contains(i)){\\n               list.add(i);\\n           }\\n        }\\n        int ans[]=new int[list.size()];\\n        for( i=0;i<list.size();i++){\\n            ans[i]=list.get(i);\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        int i=0,rem=0;\\n        ArrayList<Integer> set=new ArrayList<>();\\n        while(true){\\n            rem=(rem+(k*i))%n;\\n            if(set.contains(rem+1)){\\n                break;\\n            }\\n            else{\\n                set.add(rem+1);\\n            }\\n            i++;\\n        }\\n        ArrayList<Integer> list=new ArrayList<>();\\n        for(i=1;i<=n;i++){\\n           if(!set.contains(i)){\\n               list.add(i);\\n           }\\n        }\\n        int ans[]=new int[list.size()];\\n        for( i=0;i<list.size();i++){\\n            ans[i]=list.get(i);\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3556352,
                "title": "c-solution-frequency-vector",
                "content": "# Intuition\\nfrequency vector\\n\\n# Approach\\nCreate a vector of length n with initial values 0, Simulate whole process and increment the corresponding index value in vector till frequency of any index reaches 2,\\n\\nfinally Return indexes whose value is 0.\\n\\n# Complexity\\n- Time complexity:\\n\\n- Space complexity:\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n      vector<int> v(n,0);\\n      vector<int> ans;\\n      int i = 1;\\n      int index = 0;\\n      v[index]=1;\\n\\n      while(1){\\n        if(v[index]>1){\\n          break;\\n        }\\n        index=(index+(i*k))%n;\\n        v[index]++;\\n        i++;\\n      }\\n      for(int j=0;j<n;j++){\\n        if(v[j]==0){\\n          ans.push_back(j+1);\\n        }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n      vector<int> v(n,0);\\n      vector<int> ans;\\n      int i = 1;\\n      int index = 0;\\n      v[index]=1;\\n\\n      while(1){\\n        if(v[index]>1){\\n          break;\\n        }\\n        index=(index+(i*k))%n;\\n        v[index]++;\\n        i++;\\n      }\\n      for(int j=0;j<n;j++){\\n        if(v[j]==0){\\n          ans.push_back(j+1);\\n        }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3554819,
                "title": "c-solution-using-set-and-vector",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code using Set\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> ans;\\n        unordered_set<int> s;\\n        int turn=1;\\n        int curr=1;\\n        while(1){\\n            s.insert(curr);\\n            curr+=turn*k;\\n            if(curr>n) curr%=n;\\n            if(curr==0) curr=n;\\n            turn++;\\n            if(s.find(curr)!=s.end())\\n                break;\\n            \\n        }\\n        for(int i=1;i<=n;i++){\\n            if(s.find(i)==s.end())\\n                ans.push_back(i);\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n\\n# Code using Vector\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> v(n+1,0);\\n        int curr=1,turn=1;\\n         while(v[curr]==0){\\n             v[curr]++;\\n             curr=(curr+turn*k)%n;\\n             if(curr==0) curr=n;\\n             turn++;\\n        }\\n        vector<int> ans;\\n        for(int i=1;i<=n;i++){\\n            if(v[i]==0)\\n              ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> ans;\\n        unordered_set<int> s;\\n        int turn=1;\\n        int curr=1;\\n        while(1){\\n            s.insert(curr);\\n            curr+=turn*k;\\n            if(curr>n) curr%=n;\\n            if(curr==0) curr=n;\\n            turn++;\\n            if(s.find(curr)!=s.end())\\n                break;\\n            \\n        }\\n        for(int i=1;i<=n;i++){\\n            if(s.find(i)==s.end())\\n                ans.push_back(i);\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> v(n+1,0);\\n        int curr=1,turn=1;\\n         while(v[curr]==0){\\n             v[curr]++;\\n             curr=(curr+turn*k)%n;\\n             if(curr==0) curr=n;\\n             turn++;\\n        }\\n        vector<int> ans;\\n        for(int i=1;i<=n;i++){\\n            if(v[i]==0)\\n              ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3527224,
                "title": "c-iterative",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n\\t\\t// Here I\\'ve used 0 based indexing, so range will be [0, ..., n-1].\\n\\t\\t\\n\\t\\t// Assign the ball count for all friends to 0.\\n        vector<int> count(n, 0), res;\\n\\t\\t\\n\\t\\t// We start from the first friend, \\n\\t\\t// so assign starting value for first friend to 1.\\n        int start = 0, i = 1;\\n        count[start] = 1;\\n        \\n\\t\\t// Loop until we found the friend which got 2nd time ball\\n        while(count[start] != 2)\\n        {\\n            start = (start + (i * k)) % n;\\n            count[start]++;\\n            i++;\\n        }\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(count[i] == 0)\\n                res.push_back(i + 1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n\\t\\t// Here I\\'ve used 0 based indexing, so range will be [0, ..., n-1].\\n\\t\\t\\n\\t\\t// Assign the ball count for all friends to 0.\\n        vector<int> count(n, 0), res;\\n\\t\\t\\n\\t\\t// We start from the first friend, \\n\\t\\t// so assign starting value for first friend to 1.\\n        int start = 0, i = 1;\\n        count[start] = 1;\\n        \\n\\t\\t// Loop until we found the friend which got 2nd time ball\\n        while(count[start] != 2)\\n        {\\n            start = (start + (i * k)) % n;\\n            count[start]++;\\n            i++;\\n        }\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(count[i] == 0)\\n                res.push_back(i + 1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3524615,
                "title": "c-best-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int>ans(n,1);\\n        vector<int>ans2;\\n        int i=2;\\n        ans[0]=0;\\n        int first=0,temp=k;\\n       \\n        while(true)\\n        {\\n            \\n            first=(first+temp)%n;\\n            if(ans[first]==0) break;\\n            else\\n            {\\n\\n            ans[first]=0;\\n            temp=k*i;\\n            i++;\\n            }\\n        }\\n        for(int j=0;j<ans.size();j++)\\n        {\\n            if(ans[j]==1) {ans2.push_back(j+1);}\\n        }\\n        return ans2;\\n        \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int>ans(n,1);\\n        vector<int>ans2;\\n        int i=2;\\n        ans[0]=0;\\n        int first=0,temp=k;\\n       \\n        while(true)\\n        {\\n            \\n            first=(first+temp)%n;\\n            if(ans[first]==0) break;\\n            else\\n            {\\n\\n            ans[first]=0;\\n            temp=k*i;\\n            i++;\\n            }\\n        }\\n        for(int j=0;j<ans.size();j++)\\n        {\\n            if(ans[j]==1) {ans2.push_back(j+1);}\\n        }\\n        return ans2;\\n        \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3523304,
                "title": "c-easy-set-solution",
                "content": "\\n        vector<int> circularGameLosers(int n, int k)\\n        {\\n            unordered_set<int> s;\\n            \\n            int curr = 1, i = 1;\\n            \\n            while (s.find(curr) == s.end())//stopping condition\\n            {\\n                s.insert(curr);//mask as visited\\n                curr = (curr + i *k ) % n;\\n                if (curr == 0) curr = n;\\n                i++;\\n            }\\n            vector<int> ans;\\n            for (int i = 1; i <= n; i++)//check which are not visited\\n            {\\n                if (s.find(i) == s.end())\\n                    ans.push_back(i);\\n            }\\n            return ans;\\n        }\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "\\n        vector<int> circularGameLosers(int n, int k)\\n        {\\n            unordered_set<int> s;\\n            \\n            int curr = 1, i = 1;\\n            \\n            while (s.find(curr) == s.end())//stopping condition\\n            {\\n                s.insert(curr);//mask as visited\\n                curr = (curr + i *k ) % n;\\n                if (curr == 0) curr = n;\\n                i++;\\n            }\\n            vector<int> ans;\\n            for (int i = 1; i <= n; i++)//check which are not visited\\n            {\\n                if (s.find(i) == s.end())\\n                    ans.push_back(i);\\n            }\\n            return ans;\\n        }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3523215,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        ans=[0]\\n        m=k\\n        while True:\\n            if (ans[-1]+m)%n not in ans:\\n                ans.append((ans[-1]+m)%n)\\n                m=m+k\\n\\n            else:\\n                break\\n\\n\\n        return [i+1 for i in range(n) if i not in ans]            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        ans=[0]\\n        m=k\\n        while True:\\n            if (ans[-1]+m)%n not in ans:\\n                ans.append((ans[-1]+m)%n)\\n                m=m+k\\n\\n            else:\\n                break\\n\\n\\n        return [i+1 for i in range(n) if i not in ans]            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522987,
                "title": "implementation",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        unordered_map<int,bool> mp;\\n        vector<int> ans;\\n        long long st = 0, i = 1;\\n        while(!mp.count(st)){\\n            mp[st] = true;\\n            st += i*k;\\n            st %= n;\\n            i++;\\n        }\\n        for(int i=0; i<n; ++i)\\n            if(!mp.count(i)) ans.push_back(i+1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        unordered_map<int,bool> mp;\\n        vector<int> ans;\\n        long long st = 0, i = 1;\\n        while(!mp.count(st)){\\n            mp[st] = true;\\n            st += i*k;\\n            st %= n;\\n            i++;\\n        }\\n        for(int i=0; i<n; ++i)\\n            if(!mp.count(i)) ans.push_back(i+1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522527,
                "title": "easy-to-read-simulation-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar circularGameLosers = function(n, k) {\\n    const players = new Array(n).fill(0);\\n    let index = 0;\\n    let turn = 1;\\n    \\n    while (true) {\\n        ++players[index];\\n        if (players[index] === 2) break;\\n        index += turn++ * k;\\n        index %= n;\\n    }\\n\\n    const result = [];\\n\\n    for (let i = 1; i < n; ++i) {\\n        if (players[i] === 0) result.push(i + 1);\\n    }\\n\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar circularGameLosers = function(n, k) {\\n    const players = new Array(n).fill(0);\\n    let index = 0;\\n    let turn = 1;\\n    \\n    while (true) {\\n        ++players[index];\\n        if (players[index] === 2) break;\\n        index += turn++ * k;\\n        index %= n;\\n    }\\n\\n    const result = [];\\n\\n    for (let i = 1; i < n; ++i) {\\n        if (players[i] === 0) result.push(i + 1);\\n    }\\n\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3522323,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int>v(n, 0), ans;\\n        int i=0, turn=1;\\n        while(v[i]!=1){\\n            v[i]=1;\\n            cout<<i<<\" \"<<(turn*k)%n<<endl;\\n            i=(i+(turn*k)%n)%n;\\n            turn++;\\n        }\\n        for(int k=0; k<n; k++){\\n            if(!v[k]){\\n                ans.push_back(k+1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int>v(n, 0), ans;\\n        int i=0, turn=1;\\n        while(v[i]!=1){\\n            v[i]=1;\\n            cout<<i<<\" \"<<(turn*k)%n<<endl;\\n            i=(i+(turn*k)%n)%n;\\n            turn++;\\n        }\\n        for(int k=0; k<n; k++){\\n            if(!v[k]){\\n                ans.push_back(k+1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3522312,
                "title": "cpp-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n       vector<int>frq(n+1,0);\\n        vector<int>ans;\\n        int i = 0;\\n        int round = 1;\\n       while(true){\\n           frq[i]++;\\n           if(frq[i] >= 2) break;\\n            i = (i + ( round++ * k))%n;\\n       }\\n        for(int  i = 0 ; i<n ; i++)\\n            if( frq[i] == 0) ans.push_back(i+1);\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n       vector<int>frq(n+1,0);\\n        vector<int>ans;\\n        int i = 0;\\n        int round = 1;\\n       while(true){\\n           frq[i]++;\\n           if(frq[i] >= 2) break;\\n            i = (i + ( round++ * k))%n;\\n       }\\n        for(int  i = 0 ; i<n ; i++)\\n            if( frq[i] == 0) ans.push_back(i+1);\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522305,
                "title": "steps-explained-beginner-friendly-java",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSince, the index of an array starts from 0 there will be a huge confusion during the circular traversal.\\nThe cicular traversal of an array is always a hectic process until or unless you don\\'t know how to handle the edge cases.\\n\\nHere, by following the gven above conditions:\\n\\nOur Solution includes 3 steps\\n1. Passing the ball and marking the **visited** friends in visited array.\\n2. Finding the no of losers(unvisited) from visited array.\\n3. Adding the losers(unvisited) to the resultant array and returning it.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$\\n\\n# Code\\n\\n\\n```java []\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n       \\n        boolean[] vis=new boolean[n+1];\\n        \\n        //Step - 1\\n        int curr_friend=1,i=1;\\n        do\\n        {\\n            vis[curr_friend]=true;\\n            curr_friend=(curr_friend+i*k)%n;\\n            if(curr_friend==0)\\n            {\\n                curr_friend=n;\\n            }\\n            i++;\\n        }while(vis[curr_friend]==false);\\n        \\n        \\n        //Step-2\\n        int size=0;\\n        for( i=1;i<=n;i++)\\n        {\\n            if(!vis[i])\\n                size++;\\n        }\\n\\n        //Step-3\\n        int[] res=new int[size];\\n        int j=0;\\n        for( i=1;i<=n;i++)\\n        {\\n            if(!vis[i])\\n                res[j++]=i;\\n        }\\n        \\n        return res;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Game Theory"
                ],
                "code": "```java []\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n       \\n        boolean[] vis=new boolean[n+1];\\n        \\n        //Step - 1\\n        int curr_friend=1,i=1;\\n        do\\n        {\\n            vis[curr_friend]=true;\\n            curr_friend=(curr_friend+i*k)%n;\\n            if(curr_friend==0)\\n            {\\n                curr_friend=n;\\n            }\\n            i++;\\n        }while(vis[curr_friend]==false);\\n        \\n        \\n        //Step-2\\n        int size=0;\\n        for( i=1;i<=n;i++)\\n        {\\n            if(!vis[i])\\n                size++;\\n        }\\n\\n        //Step-3\\n        int[] res=new int[size];\\n        int j=0;\\n        for( i=1;i<=n;i++)\\n        {\\n            if(!vis[i])\\n                res[j++]=i;\\n        }\\n        \\n        return res;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522257,
                "title": "java-easy-simulation-fully-explained",
                "content": "Feel free to suggest any improvements, corrections\\uD83D\\uDC4D\\uD83C\\uDFFB\\nDo **UPVOTE**\\uD83D\\uDD3A\\n```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        int[] map = new int[n];\\n\\t\\t//map[i] tracks the number of times ith member recieves the ball\\n        \\n        int i = 0, cnt = 1;\\n        while(true){\\n            map[i]++;\\n            if(map[i] == 2) break; //break out of the loop whenever any member recieves the ball 2nd time, i.e. GAME_OVER\\n            i = (i + (cnt * k)) % n;\\n            cnt++; //to increase the multiple of k: k, 2*k, 3*k, 4*k, etc\\n        }\\n        \\n        int len = 0; //For storing how many members are the losers, i.e. did not recieve the ball even once\\n        for(int num : map) if(num == 0) len++;\\n        \\n        \\n        int index = 0, ans[] = new int[len];\\n        for(int j=0;j<n;j++){\\n          if(map[j] == 0) ans[index++] = j+1;  \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        int[] map = new int[n];\\n\\t\\t//map[i] tracks the number of times ith member recieves the ball\\n        \\n        int i = 0, cnt = 1;\\n        while(true){\\n            map[i]++;\\n            if(map[i] == 2) break; //break out of the loop whenever any member recieves the ball 2nd time, i.e. GAME_OVER\\n            i = (i + (cnt * k)) % n;\\n            cnt++; //to increase the multiple of k: k, 2*k, 3*k, 4*k, etc\\n        }\\n        \\n        int len = 0; //For storing how many members are the losers, i.e. did not recieve the ball even once\\n        for(int num : map) if(num == 0) len++;\\n        \\n        \\n        int index = 0, ans[] = new int[len];\\n        for(int j=0;j<n;j++){\\n          if(map[j] == 0) ans[index++] = j+1;  \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522240,
                "title": "hashing-c-solution",
                "content": "# Intuition\\n we will decleare a hash array of size n+1 intially marked with zero . freind will start 1 to  n . we will mark hash(i)=1 as we get the ball pass to freind  . before marking we will check that wether it is previously marked or not , if it is marked as 1 then that  freind is geeting ball second time and the game end by break out of loop    \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)+O(n) = O(2n)   ; \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  O(n) for hash array \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n       \\n        vector<int>hash(n+1,0) ; \\n         hash[1]=1 ; \\n        vector<int>ans ; \\n        \\n          int prev  = 1 ;  \\n       int  i =1 ; \\n            while(1) \\n            {\\n               int nextstep = i*k ; \\n                int move = (prev+nextstep)%n ; \\n              if (move%n==0)move=n;\\n              \\n                if(hash[move]==0) \\n                {\\n                    hash[move] =1 ; \\n                    prev = move ;\\n                \\n                }\\n                else \\n                {\\n                    break ; \\n                } \\n                i++ ; \\n                \\n            }\\n         for( int i = 1 ; i<=n ; i++) \\n         {\\n             if(hash[i]==0) \\n                  ans.push_back(i)  ; \\n         }\\n      \\n        \\n        return ans ; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n       \\n        vector<int>hash(n+1,0) ; \\n         hash[1]=1 ; \\n        vector<int>ans ; \\n        \\n          int prev  = 1 ;  \\n       int  i =1 ; \\n            while(1) \\n            {\\n               int nextstep = i*k ; \\n                int move = (prev+nextstep)%n ; \\n              if (move%n==0)move=n;\\n              \\n                if(hash[move]==0) \\n                {\\n                    hash[move] =1 ; \\n                    prev = move ;\\n                \\n                }\\n                else \\n                {\\n                    break ; \\n                } \\n                i++ ; \\n                \\n            }\\n         for( int i = 1 ; i<=n ; i++) \\n         {\\n             if(hash[i]==0) \\n                  ans.push_back(i)  ; \\n         }\\n      \\n        \\n        return ans ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522017,
                "title": "only-map-explained-easy-to-understand",
                "content": "# Intuition\\nuse map to mark the friend that received the ball\\n\\n# Approach\\nbe carefull when your next friends value come to zero then you make that value equal to n because 0 is not a friend and for finding the next value of friend simply int** **nf=(currf + (i+1)*k) % n;**** and make your current friend cf  equal to newfriend nf, \\n\\n1.Also store the number of friend at vector or any datastructure to keep track of marked one and lastly return the unmarked one\\n\\n# Complexity\\n- Time complexity:\\n appx O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        if(k>n) return {};\\n        vector<int> ans;\\n        vector<int> temp;\\n        for(int i=0;i<n;i++)\\n        {\\n            temp.push_back(i+1);\\n        }\\n        map<int , int> mp;\\n        mp[1]=1;\\n        int currf=1;\\n        for(int i=0;i<1000;i++)\\n        {\\n            \\n            int nf=(currf + (i+1)*k) % n;\\n            if (nf == 0) {\\n            nf = n;\\n            }\\n            if(mp[nf]==1) break;\\n            mp[nf]=1;\\n            currf=nf; \\n        }\\n        for(auto i:temp)\\n        {\\n            if(mp[i]==0)\\n            {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        if(k>n) return {};\\n        vector<int> ans;\\n        vector<int> temp;\\n        for(int i=0;i<n;i++)\\n        {\\n            temp.push_back(i+1);\\n        }\\n        map<int , int> mp;\\n        mp[1]=1;\\n        int currf=1;\\n        for(int i=0;i<1000;i++)\\n        {\\n            \\n            int nf=(currf + (i+1)*k) % n;\\n            if (nf == 0) {\\n            nf = n;\\n            }\\n            if(mp[nf]==1) break;\\n            mp[nf]=1;\\n            currf=nf; \\n        }\\n        for(auto i:temp)\\n        {\\n            if(mp[i]==0)\\n            {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521979,
                "title": "c-o-n-solution-beats-95-24",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        int turn = 2;\\n        vector<int> vec, vis(n);\\n        int i = k;\\n        while(i >= n) i -= n;\\n        vis[0] = 1;\\n\\n        while(true) {\\n            if(vis[i]) break;\\n            vis[i] = 1;\\n            i += (k * turn);\\n            while(i >= n) i = i - n;\\n            turn++;\\n        }\\n\\n        for(int i = 0; i < n; i++) {\\n            if(!vis[i]) vec.push_back(i + 1);\\n        }\\n        return vec;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        int turn = 2;\\n        vector<int> vec, vis(n);\\n        int i = k;\\n        while(i >= n) i -= n;\\n        vis[0] = 1;\\n\\n        while(true) {\\n            if(vis[i]) break;\\n            vis[i] = 1;\\n            i += (k * turn);\\n            while(i >= n) i = i - n;\\n            turn++;\\n        }\\n\\n        for(int i = 0; i < n; i++) {\\n            if(!vis[i]) vec.push_back(i + 1);\\n        }\\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521946,
                "title": "rust-python-linear-track-people-who-have-been-selected",
                "content": "# Intuition\\nStore all positions of people who has already been selected. Then iterate over all jumps (there will be at most n of them) until you will see a selected person. \\n\\nThen return all people who has not been selected.\\n\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n- Space complexity: $O(n)$\\n\\n# Code\\n\\n\\n\\n```Python []\\nclass Solution:\\n  def circularGameLosers(self, n: int, k: int) -> List[int]:\\n    seen = [0] * n\\n    seen[0] = 1\\n    \\n    pos, jump = 0, k\\n    while True:\\n      pos = (pos + jump) % n\\n      if seen[pos]:\\n        break\\n      \\n      seen[pos] = 1\\n      jump += k\\n    \\n    return [i + 1 for i in range(n) if seen[i] == 0]\\n```\\n```Rust []\\nimpl Solution {\\n  pub fn circular_game_losers(n: i32, k: i32) -> Vec<i32> {\\n    let mut seen = vec![false; n as usize];\\n    seen[0] = true;\\n\\n    let (mut pos, mut jump) = (0, k);\\n    loop {\\n      pos = (pos + jump) % n;\\n      if seen[pos as usize] {\\n        break;\\n      }\\n      \\n      seen[pos as usize] = true;\\n      jump += k;\\n    }\\n    \\n    let mut res = vec![];\\n    for i in 0 .. n {\\n      if !seen[i as usize] {\\n        res.push(i + 1);\\n      }\\n    }\\n    \\n    return res;\\n  }\\n}\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Rust"
                ],
                "code": "```Python []\\nclass Solution:\\n  def circularGameLosers(self, n: int, k: int) -> List[int]:\\n    seen = [0] * n\\n    seen[0] = 1\\n    \\n    pos, jump = 0, k\\n    while True:\\n      pos = (pos + jump) % n\\n      if seen[pos]:\\n        break\\n      \\n      seen[pos] = 1\\n      jump += k\\n    \\n    return [i + 1 for i in range(n) if seen[i] == 0]\\n```\n```Rust []\\nimpl Solution {\\n  pub fn circular_game_losers(n: i32, k: i32) -> Vec<i32> {\\n    let mut seen = vec![false; n as usize];\\n    seen[0] = true;\\n\\n    let (mut pos, mut jump) = (0, k);\\n    loop {\\n      pos = (pos + jump) % n;\\n      if seen[pos as usize] {\\n        break;\\n      }\\n      \\n      seen[pos as usize] = true;\\n      jump += k;\\n    }\\n    \\n    let mut res = vec![];\\n    for i in 0 .. n {\\n      if !seen[i as usize] {\\n        res.push(i + 1);\\n      }\\n    }\\n    \\n    return res;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521881,
                "title": "day-409-easy-100-python-java-c-explained",
                "content": "# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\ncreate an array vis of the same size as n and fill it with zeros. Then they iterate over the array and update the value of p using the given formula. They also check if p has already been visited before and break the loop if it has. Finally, they create a list of all the elements that have not been visited and return it.\\n\\n# Complexity\\n- Time complexity:o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java []\\npublic int[] circularGameLosers(int n, int k) {\\n    int  vis[] = new int[n+1];\\n    vis[1]=1;\\n    int p = 1;\\n    for(int i=1;i<=n;i++){\\n        p=(p+(k*i) )%(n);\\n        if(p==0) p=n;\\n        if(vis[p]==1) break;\\n        vis[p]=1;\\n        \\n    }\\n    var list = new ArrayList<Integer>();\\n    for(int i=1;i<=n;i++){\\n        if(vis[i]==0){\\n            list.add(i);\\n        }\\n    }return list.stream().mapToInt(i->i).toArray();\\n}\\n```\\n\\n```python []\\ndef circularGameLosers(self, n: int, k: int) -> List[int]:\\n        vis = [0] * (n + 1)\\n        vis[1] = 1\\n        p = 1\\n        for i in range(1, n + 1):\\n            p = (p + k * i) % n\\n            if p == 0:\\n                p = n\\n            if vis[p] == 1:\\n                break\\n            vis[p] = 1\\n        return [i for i in range(1, n + 1) if vis[i] == 0]\\n```\\n```c++ []\\nvector<int> circularGameLosers(int n, int k) {\\n        vector<int> vis(n + 1, 0);\\n        vis[1] = 1;\\n        int p = 1;\\n        for (int i = 1; i <= n; i++) {\\n            p = (p + k * i) % n;\\n            if (p == 0) {\\n                p = n;\\n            }\\n            if (vis[p] == 1) {\\n                break;\\n            }\\n            vis[p] = 1;\\n        }\\n        vector<int> res;\\n        for (int i = 1; i <= n; i++) {\\n            if (vis[i] == 0) {\\n                res.push_back(i);\\n            }\\n        }\\n        return res;\\n    }\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```java []\\npublic int[] circularGameLosers(int n, int k) {\\n    int  vis[] = new int[n+1];\\n    vis[1]=1;\\n    int p = 1;\\n    for(int i=1;i<=n;i++){\\n        p=(p+(k*i) )%(n);\\n        if(p==0) p=n;\\n        if(vis[p]==1) break;\\n        vis[p]=1;\\n        \\n    }\\n    var list = new ArrayList<Integer>();\\n    for(int i=1;i<=n;i++){\\n        if(vis[i]==0){\\n            list.add(i);\\n        }\\n    }return list.stream().mapToInt(i->i).toArray();\\n}\\n```\n```python []\\ndef circularGameLosers(self, n: int, k: int) -> List[int]:\\n        vis = [0] * (n + 1)\\n        vis[1] = 1\\n        p = 1\\n        for i in range(1, n + 1):\\n            p = (p + k * i) % n\\n            if p == 0:\\n                p = n\\n            if vis[p] == 1:\\n                break\\n            vis[p] = 1\\n        return [i for i in range(1, n + 1) if vis[i] == 0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3521872,
                "title": "2682-find-the-losers-of-the-circular-game-java-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n    int[] result = new int[n];\\n    int[] p = new int[n + 1];\\n    int i = 1, j = 1, count = 0; \\n    while (p[i] == 0) {\\n        p[i] = -1;\\n        i = (i + (j * k));\\n        while (i > n)\\n            i -= n;\\n        j++;\\n    }\\n    for (i = 1; i <= n; i++) {\\n        if (p[i] != -1) {\\n            result[count++] = i;\\n        }\\n    }\\n    return Arrays.copyOf(result, count);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n    int[] result = new int[n];\\n    int[] p = new int[n + 1];\\n    int i = 1, j = 1, count = 0; \\n    while (p[i] == 0) {\\n        p[i] = -1;\\n        i = (i + (j * k));\\n        while (i > n)\\n            i -= n;\\n        j++;\\n    }\\n    for (i = 1; i <= n; i++) {\\n        if (p[i] != -1) {\\n            result[count++] = i;\\n        }\\n    }\\n    return Arrays.copyOf(result, count);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521870,
                "title": "python-using-mod-beginners",
                "content": "```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        losers = [0]*n\\n        losers[0] = 1\\n        index = 0\\n        turn = 1\\n        while losers[index] != 2:\\n            index = ((turn * k) + index) % n\\n            losers[index] += 1\\n            turn += 1\\n            \\n        answer = []\\n        for index, loser in enumerate(losers):\\n            if loser == 0:\\n                answer.append(index + 1)\\n                \\n        return answer\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        losers = [0]*n\\n        losers[0] = 1\\n        index = 0\\n        turn = 1\\n        while losers[index] != 2:\\n            index = ((turn * k) + index) % n\\n            losers[index] += 1\\n            turn += 1\\n            \\n        answer = []\\n        for index, loser in enumerate(losers):\\n            if loser == 0:\\n                answer.append(index + 1)\\n                \\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088359,
                "title": "simple-elegant",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n\\n        unordered_map<int, bool> visited{};\\n\\n        int currFriend = 1, turn = 1;\\n\\n        while(visited[currFriend] == false){\\n\\n            visited[currFriend] = true;\\n\\n            currFriend += turn * k;\\n\\n            if(currFriend % n != 0) currFriend %= n;     \\n            else currFriend = n;\\n            \\n            turn++;\\n        }\\n\\n        vector<int> ans{};\\n\\n        for(int i = 1; i <= n; i++){\\n            if(visited[i] == false) \\n                ans.push_back(i);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n\\n        unordered_map<int, bool> visited{};\\n\\n        int currFriend = 1, turn = 1;\\n\\n        while(visited[currFriend] == false){\\n\\n            visited[currFriend] = true;\\n\\n            currFriend += turn * k;\\n\\n            if(currFriend % n != 0) currFriend %= n;     \\n            else currFriend = n;\\n            \\n            turn++;\\n        }\\n\\n        vector<int> ans{};\\n\\n        for(int i = 1; i <= n; i++){\\n            if(visited[i] == false) \\n                ans.push_back(i);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079969,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n      public int[] circularGameLosers(int n, int k) {\\n        List<Integer> players = new ArrayList<>();\\n        int temp = 0;\\n        int lastPlayer = 1;\\n        players.add(1);\\n        for(int i = 1; i <= n; i++){\\n            temp = i * k;\\n            lastPlayer = (temp + lastPlayer) % n == 0 ? n :  (temp + lastPlayer) % n;\\n           \\n            if(players.contains(lastPlayer)){\\n                break;\\n            }else{\\n                players.add(lastPlayer);\\n            }\\n        }\\n        int[] losers = new int[n - players.size()]; \\n        int index = 0;\\n        for(int i = 1; i <=n ; i++){\\n            if(!players.contains(i)){\\n                losers[index] = i;\\n                index++;\\n            }\\n        }\\n    \\n        return losers;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n      public int[] circularGameLosers(int n, int k) {\\n        List<Integer> players = new ArrayList<>();\\n        int temp = 0;\\n        int lastPlayer = 1;\\n        players.add(1);\\n        for(int i = 1; i <= n; i++){\\n            temp = i * k;\\n            lastPlayer = (temp + lastPlayer) % n == 0 ? n :  (temp + lastPlayer) % n;\\n           \\n            if(players.contains(lastPlayer)){\\n                break;\\n            }else{\\n                players.add(lastPlayer);\\n            }\\n        }\\n        int[] losers = new int[n - players.size()]; \\n        int index = 0;\\n        for(int i = 1; i <=n ; i++){\\n            if(!players.contains(i)){\\n                losers[index] = i;\\n                index++;\\n            }\\n        }\\n    \\n        return losers;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4061344,
                "title": "5-line-javascript-typescript-solution-beats-100",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst circularGameLosers = (n: number, k: number): number[] => {\\n  const losers = new Set<number>(Array.from({ length: n }, (_el, i) => i + 1));\\n  let cur = 1;\\n  let round = 1;\\n  while (losers.delete(cur)) cur = ((cur - 1 + k * round++) % n) + 1;\\n  return [...losers.values()];\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nconst circularGameLosers = (n: number, k: number): number[] => {\\n  const losers = new Set<number>(Array.from({ length: n }, (_el, i) => i + 1));\\n  let cur = 1;\\n  let round = 1;\\n  while (losers.delete(cur)) cur = ((cur - 1 + k * round++) % n) + 1;\\n  return [...losers.values()];\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4060796,
                "title": "python3-easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        numSet = set()\\n        start = 0\\n        index = 1\\n\\n        while start not in numSet:\\n            numSet.add(start)\\n            start += index * k\\n            start = start % n\\n            index += 1\\n\\n        res = []\\n        for i in range(n):\\n            if i not in numSet:\\n                res.append(i + 1)\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        numSet = set()\\n        start = 0\\n        index = 1\\n\\n        while start not in numSet:\\n            numSet.add(start)\\n            start += index * k\\n            start = start % n\\n            index += 1\\n\\n        res = []\\n        for i in range(n):\\n            if i not in numSet:\\n                res.append(i + 1)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4057085,
                "title": "1ms-simplest-java-solution",
                "content": "TC: O(n); Space: O(n)\\nNo intermediate List used\\n\\n```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        \\n        if(n==0 || k ==0) return new int[]{};\\n        \\n        int[] arr = new int[n];\\n        Arrays.fill(arr,1);\\n        \\n        int pass =1; //an iterating variable to maintain passing\\n        int idx =0; //index as it says\\n        int times =k;\\n        arr[0]++;\\n        \\n        while(true)\\n        {\\n            idx = (pass*times) + idx;\\n            if(arr[idx%n] == 2)  // when index is > n; we do modulo operation to stay in array bounds - giving circular connection in array\\n                break;\\n            arr[idx%n]++;\\n            pass++;\\n        }\\n        \\n        //based on pass value make a new array, remeber after last pass nothing \\n\\t\\t//occured because we broke out of while lopp, \\n\\t\\t//so new array size  = n - pass;\\n        \\n        //System.out.println(\" Total pass : \"+ pass + \"  && new len = \" + (n-pass) );\\n        \\n        int[] res = new int[n - pass];\\n        for(int i=0, j=0 ; i<n; i++)\\n        {\\n            if(arr[i] == 1)\\n                res[j++] = i+1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        \\n        if(n==0 || k ==0) return new int[]{};\\n        \\n        int[] arr = new int[n];\\n        Arrays.fill(arr,1);\\n        \\n        int pass =1; //an iterating variable to maintain passing\\n        int idx =0; //index as it says\\n        int times =k;\\n        arr[0]++;\\n        \\n        while(true)\\n        {\\n            idx = (pass*times) + idx;\\n            if(arr[idx%n] == 2)  // when index is > n; we do modulo operation to stay in array bounds - giving circular connection in array\\n                break;\\n            arr[idx%n]++;\\n            pass++;\\n        }\\n        \\n        //based on pass value make a new array, remeber after last pass nothing \\n\\t\\t//occured because we broke out of while lopp, \\n\\t\\t//so new array size  = n - pass;\\n        \\n        //System.out.println(\" Total pass : \"+ pass + \"  && new len = \" + (n-pass) );\\n        \\n        int[] res = new int[n - pass];\\n        for(int i=0, j=0 ; i<n; i++)\\n        {\\n            if(arr[i] == 1)\\n                res[j++] = i+1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055851,
                "title": "easy-to-understand-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        d = {}\\n        d[1] = 1\\n\\n        start, place = 1, 1\\n        while True:\\n            jump = start + k * place\\n\\n            while jump > n:\\n                jump -= n\\n            \\n            if jump in d:\\n                break\\n            \\n            d[jump] = 1\\n            start = jump\\n            place += 1\\n        \\n        print(d)\\n        # {1: 1, 3: 1, 2: 1}\\n        res = []\\n\\n        for i in range(1, n+1):\\n            if i not in d:\\n                res.append(i)\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        d = {}\\n        d[1] = 1\\n\\n        start, place = 1, 1\\n        while True:\\n            jump = start + k * place\\n\\n            while jump > n:\\n                jump -= n\\n            \\n            if jump in d:\\n                break\\n            \\n            d[jump] = 1\\n            start = jump\\n            place += 1\\n        \\n        print(d)\\n        # {1: 1, 3: 1, 2: 1}\\n        res = []\\n\\n        for i in range(1, n+1):\\n            if i not in d:\\n                res.append(i)\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4027429,
                "title": "php-simple",
                "content": "\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer $n\\n     * @param Integer $k\\n     * @return Integer[]\\n     */\\n    function circularGameLosers($n, $k) {\\n        $players =  range(1, $n);\\n        $carry = [];\\n        $player = 1;\\n        $turn = 1;\\n\\n        while(1) {\\n            if (in_array($player, $carry)) {\\n                return array_diff($players, $carry);\\n            }\\n\\n            $carry[] = $player;\\n            $next = $k * $turn;\\n            $turn++;\\n\\n            while($next > 0) {\\n                if ($player === $n) {\\n                    $player = 1;\\n                } else {\\n                    $player++;\\n                }\\n\\n                $next--;\\n            }\\n        }\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer $n\\n     * @param Integer $k\\n     * @return Integer[]\\n     */\\n    function circularGameLosers($n, $k) {\\n        $players =  range(1, $n);\\n        $carry = [];\\n        $player = 1;\\n        $turn = 1;\\n\\n        while(1) {\\n            if (in_array($player, $carry)) {\\n                return array_diff($players, $carry);\\n            }\\n\\n            $carry[] = $player;\\n            $next = $k * $turn;\\n            $turn++;\\n\\n            while($next > 0) {\\n                if ($player === $n) {\\n                    $player = 1;\\n                } else {\\n                    $player++;\\n                }\\n\\n                $next--;\\n            }\\n        }\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002610,
                "title": "simple-c-using-vector",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> mp(n,0);\\n        mp[0]++;\\n        bool f=true;\\n        vector<int> a;\\n        int i=1;\\n        int srt=0;\\n        while(mp[srt]!=2){\\n            srt=(srt+(k*i))%n;\\n            mp[srt]++;\\n            i++;\\n            \\n        }\\n        for(int i=0;i<n;i++){\\n            if(mp[i]==0){\\n                a.push_back(i+1);\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> mp(n,0);\\n        mp[0]++;\\n        bool f=true;\\n        vector<int> a;\\n        int i=1;\\n        int srt=0;\\n        while(mp[srt]!=2){\\n            srt=(srt+(k*i))%n;\\n            mp[srt]++;\\n            i++;\\n            \\n        }\\n        for(int i=0;i<n;i++){\\n            if(mp[i]==0){\\n                a.push_back(i+1);\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999639,
                "title": "java-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        Map<Integer, Integer> map = new LinkedHashMap<>();\\n        for (int i = 1; i <= n; i++) {\\n            if (i == 1) map.put(1, 1);\\n            else map.put(i, 0);\\n        }\\n        int temp = 1;\\n        int current = 1;\\n        while (!map.entrySet().stream().filter(x -> x.getValue() >= 2).findFirst().isPresent()) {\\n            current += (temp * k);\\n            if (current > n) {\\n                while (current > n) {\\n                    current -= n;\\n                }\\n            }\\n\\n            map.put(current, map.get(current) + 1);\\n            temp++;\\n        }\\n\\n        List<Integer> l = map.entrySet().stream().filter(x -> x.getValue() == 0).map(x -> x.getKey()).toList();\\n        int[] arr = new int[l.size()];\\n        for (int i = 0; i < l.size(); i++) {\\n            arr[i] = l.get(i);\\n        }\\n        \\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        Map<Integer, Integer> map = new LinkedHashMap<>();\\n        for (int i = 1; i <= n; i++) {\\n            if (i == 1) map.put(1, 1);\\n            else map.put(i, 0);\\n        }\\n        int temp = 1;\\n        int current = 1;\\n        while (!map.entrySet().stream().filter(x -> x.getValue() >= 2).findFirst().isPresent()) {\\n            current += (temp * k);\\n            if (current > n) {\\n                while (current > n) {\\n                    current -= n;\\n                }\\n            }\\n\\n            map.put(current, map.get(current) + 1);\\n            temp++;\\n        }\\n\\n        List<Integer> l = map.entrySet().stream().filter(x -> x.getValue() == 0).map(x -> x.getKey()).toList();\\n        int[] arr = new int[l.size()];\\n        for (int i = 0; i < l.size(); i++) {\\n            arr[i] = l.get(i);\\n        }\\n        \\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3970857,
                "title": "java-clear-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:  $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        List<Integer> list = new ArrayList<>();\\n        int[] table = new int[n];\\n        int i = 1, current = 0;\\n        \\n        table[0] = 1;\\n\\n        while(true){\\n            current = (i * k + current) % n;\\n            table[current]++;\\n            i++;\\n            if(table[current] == 2)\\n              break;\\n        }\\n\\n        for(int j = 0; j < n; j++)\\n            if(table[j] == 0) list.add(j+1);\\n        \\n        int[] array = new int[list.size()];\\n        for(int j = 0; j < list.size(); j++) \\n            array[j] = list.get(j);\\n        \\n        return array;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        List<Integer> list = new ArrayList<>();\\n        int[] table = new int[n];\\n        int i = 1, current = 0;\\n        \\n        table[0] = 1;\\n\\n        while(true){\\n            current = (i * k + current) % n;\\n            table[current]++;\\n            i++;\\n            if(table[current] == 2)\\n              break;\\n        }\\n\\n        for(int j = 0; j < n; j++)\\n            if(table[j] == 0) list.add(j+1);\\n        \\n        int[] array = new int[list.size()];\\n        for(int j = 0; j < list.size(); j++) \\n            array[j] = list.get(j);\\n        \\n        return array;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3967861,
                "title": "python-game-simulation-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGiven the nature of the problem, it\\'s evident that a circular structure such as a circular linked list or an array with wrap-around indexing would be beneficial. Since the ball is passed in a repeating pattern, modulo arithmetic will be essential to keep the pointer within the bounds of the array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.Initialization: Create a list friends that contains the numbers from 1 to n. Also, initialize an empty list visited_friends to keep track of friends who received the ball. A pointer initialized to 0 will indicate the current friend with the ball.\\n2.Passing the Ball: Use a loop to pass the ball among friends:\\nFor the ith pass, compute the position of the friend to receive the ball as (pointer + i * k) % n.\\n3.Add this friend to the visited_friends list.\\n4.Stop the loop when a friend receives the ball for the second time.\\n5.Finding Losers: Any friend not in visited_friends is a loser. Identify these friends and return them in ascending order.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        friends = []\\n        visited_friends = []\\n        res = []\\n\\n        for i in range(1, n+1):\\n            friends.append(i)\\n        pointer = 0\\n\\n        cur_circle_count = 1\\n        while friends[pointer] not in visited_friends:\\n            visited_friends.append(friends[pointer])\\n            next_pointer_pos = (pointer + k * cur_circle_count) % n\\n            cur_circle_count += 1\\n            pointer = next_pointer_pos\\n\\n        for f in friends:\\n            if f not in visited_friends:\\n                res.append(f)\\n        return sorted(res)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        friends = []\\n        visited_friends = []\\n        res = []\\n\\n        for i in range(1, n+1):\\n            friends.append(i)\\n        pointer = 0\\n\\n        cur_circle_count = 1\\n        while friends[pointer] not in visited_friends:\\n            visited_friends.append(friends[pointer])\\n            next_pointer_pos = (pointer + k * cur_circle_count) % n\\n            cur_circle_count += 1\\n            pointer = next_pointer_pos\\n\\n        for f in friends:\\n            if f not in visited_friends:\\n                res.append(f)\\n        return sorted(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930295,
                "title": "python-rust-solution-3-ms",
                "content": "# Code\\n```python []\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        scores = [0 for _ in range(n + 1)]\\n        scores[0], scores[1] = 1, 1\\n        rounds, player = 1, 1\\n\\n        while scores[player] <= 1:\\n            pos = player + (rounds * k) % n\\n            if pos > n:\\n                player = pos - n\\n            else:\\n                player = pos\\n\\n            scores[player] += 1\\n            rounds += 1\\n\\n        return [index for index, score in enumerate(scores) if score == 0]\\n```\\n```rust []\\nimpl Solution {\\n    pub fn circular_game_losers(n: i32, k: i32) -> Vec<i32> {\\n        let mut scores = vec![0; n as usize + 1];\\n        let (mut round, mut player) = (1, 1);\\n        scores[0] = 1; \\n        scores[1] = 1;\\n\\n        while scores[player as usize] <= 1 {\\n            let pos = player + (round * k) % n;\\n            player = if pos > n { pos - n } else { pos };\\n            scores[player as usize] += 1;\\n            round += 1;\\n        }\\n\\n        scores\\n            .iter()\\n            .enumerate()\\n            .filter(|(_, &score)| score == 0)\\n            .map(|(index, _)| index as i32)\\n            .collect::<Vec<i32>>()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python []\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        scores = [0 for _ in range(n + 1)]\\n        scores[0], scores[1] = 1, 1\\n        rounds, player = 1, 1\\n\\n        while scores[player] <= 1:\\n            pos = player + (rounds * k) % n\\n            if pos > n:\\n                player = pos - n\\n            else:\\n                player = pos\\n\\n            scores[player] += 1\\n            rounds += 1\\n\\n        return [index for index, score in enumerate(scores) if score == 0]\\n```\n```rust []\\nimpl Solution {\\n    pub fn circular_game_losers(n: i32, k: i32) -> Vec<i32> {\\n        let mut scores = vec![0; n as usize + 1];\\n        let (mut round, mut player) = (1, 1);\\n        scores[0] = 1; \\n        scores[1] = 1;\\n\\n        while scores[player as usize] <= 1 {\\n            let pos = player + (round * k) % n;\\n            player = if pos > n { pos - n } else { pos };\\n            scores[player as usize] += 1;\\n            round += 1;\\n        }\\n\\n        scores\\n            .iter()\\n            .enumerate()\\n            .filter(|(_, &score)| score == 0)\\n            .map(|(index, _)| index as i32)\\n            .collect::<Vec<i32>>()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916218,
                "title": "simple-beginner-level-c-solution-slow-but-easy-to-understand-beats-69-23-in-runtime",
                "content": "\\n# Complexity\\n- Time complexity: ```O(n)```\\n- Space complexity: ```O(n)```\\n\\n\\n# Code\\n```cpp\\n// Runtime 13 ms Beats 69.23% Memory 7.8 MB Beats 84.62%\\nint* circularGameLosers(int n, int k, int* returnSize) {\\n    // Simulation + Hashtable\\n\\n    // Time complexity: O(n)\\n    // Space complexity: O(n)\\n\\n    bool* seen = (bool*)calloc(n, sizeof(bool));\\n    \\n    for (int friendIndex = 0, turn = 1; !seen[friendIndex]; ) {\\n        seen[friendIndex] = true;\\n        friendIndex += (turn++) * k;\\n        friendIndex %= n;\\n    }\\n\\n    int* result = (int*)calloc(n, sizeof(int));\\n    int arrSize = 0;\\n    for (int friendIndex = 0; friendIndex < n; friendIndex++) {\\n        if (seen[friendIndex]) continue;\\n        result[arrSize++] = friendIndex + 1;\\n    }\\n\\n    *returnSize = arrSize;\\n    free(seen);\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Hash Table",
                    "Simulation"
                ],
                "code": "```O(n)```\n```O(n)```\n```cpp\\n// Runtime 13 ms Beats 69.23% Memory 7.8 MB Beats 84.62%\\nint* circularGameLosers(int n, int k, int* returnSize) {\\n    // Simulation + Hashtable\\n\\n    // Time complexity: O(n)\\n    // Space complexity: O(n)\\n\\n    bool* seen = (bool*)calloc(n, sizeof(bool));\\n    \\n    for (int friendIndex = 0, turn = 1; !seen[friendIndex]; ) {\\n        seen[friendIndex] = true;\\n        friendIndex += (turn++) * k;\\n        friendIndex %= n;\\n    }\\n\\n    int* result = (int*)calloc(n, sizeof(int));\\n    int arrSize = 0;\\n    for (int friendIndex = 0; friendIndex < n; friendIndex++) {\\n        if (seen[friendIndex]) continue;\\n        result[arrSize++] = friendIndex + 1;\\n    }\\n\\n    *returnSize = arrSize;\\n    free(seen);\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3910833,
                "title": "c-single-parse-with-increasing-step-100-time-0ms-99-space-8-12mb",
                "content": "Funny problem we can solve by basically coding what we are told should happen.\\n\\nTo do so, we will start with our usual support variables:\\n* `w` is our pointer to first walk and then write (more about that in a moment), initially set to `0`, since we always start from the first cell;\\n* `step` will store how much we move at each new round, initially set to be `k`;\\n* `unexplored` in an array of `n` booleans we will use to keep track of where we have been or not;\\n* `res` is our usual result variable, preset to be `n` cells this time, to avoid too many reallocations laters.\\n\\nWe will then go and prepare `unexplored`, setting all its cells to `true`, then we will loop `while` the current cell `unexplored[w]` is `true` and:\\n* flag the current cell `unexplored[w]` as `false`;\\n* increase our pointer `w` by step;\\n* make sure `w` stays `< n`, by reducing it to `% n` when it exceeds this value;\\n* increase `step` by `k` (cheaper than multiplying by `k` each time).\\n\\nNow that we have flagged all the cells we would touch before the game ends (ie: before we land in an already explored cell), we can confidently populate `res` by:\\n* resetting `w` to be `0`, this time to write in `res`;\\n* loop through all the values in `unexplored` from the second (index `1`, remember we know the first one will always be visited) and:\\n    * when we find a cell we did not touch (ie: `unexplored[i] == true`), we will:\\n        * increase `i` by `1` (since the original problem was `1`-based);\\n        * write its value in `res[w]`\\n        * advance `w` by `1`, ready to write in the next cell;\\n    * if the cell was visited, we will just advance `i` by `1`\\n* finally, we will `resize` `res` to be only `w` cells.\\n\\nOnce done, we can `return` `res` :)\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        // support variables\\n        int w = 0, step = k;\\n        bool unexplored[n];\\n        vector<int> res(n);\\n        // preparing unexplored\\n        memset(unexplored, 1, n * sizeof(bool));\\n        while (unexplored[w]) {\\n            unexplored[w] = 0;\\n            w += step;\\n            if (w >= n) w %= n;\\n            step += k;\\n        }\\n        // populating res\\n        w = 0;\\n        for (int i = 1; i < n;) {\\n            if (unexplored[i]) res[w++] = ++i;\\n            else ++i;\\n        }\\n        res.resize(w);\\n        return res;\\n    }\\n};\\n```\\n\\n#Brag\\n![image.png](https://assets.leetcode.com/users/images/2b781d23-8eef-43a3-bbec-e352eefbe752_1692055030.28059.png)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Simulation"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        // support variables\\n        int w = 0, step = k;\\n        bool unexplored[n];\\n        vector<int> res(n);\\n        // preparing unexplored\\n        memset(unexplored, 1, n * sizeof(bool));\\n        while (unexplored[w]) {\\n            unexplored[w] = 0;\\n            w += step;\\n            if (w >= n) w %= n;\\n            step += k;\\n        }\\n        // populating res\\n        w = 0;\\n        for (int i = 1; i < n;) {\\n            if (unexplored[i]) res[w++] = ++i;\\n            else ++i;\\n        }\\n        res.resize(w);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887814,
                "title": "c-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI think we should have flag vector to check whether a player received ball yet\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> ans(n,1);\\n        int i = 0;\\n        int j = 1;\\n        while(ans[i] == 1)\\n        {\\n            ans[i] = 0;\\n            i = (i+j*k) > n ? (i+j*k)%n : (i+j*k)%n;\\n            j++;\\n        }\\n        vector<int> res; \\n        for(int i = 0;i<n;i++)\\n        {\\n            if(ans[i] == 1) res.push_back(i+1);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> ans(n,1);\\n        int i = 0;\\n        int j = 1;\\n        while(ans[i] == 1)\\n        {\\n            ans[i] = 0;\\n            i = (i+j*k) > n ? (i+j*k)%n : (i+j*k)%n;\\n            j++;\\n        }\\n        vector<int> res; \\n        for(int i = 0;i<n;i++)\\n        {\\n            if(ans[i] == 1) res.push_back(i+1);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3880111,
                "title": "begineers-friendly-c-easy-to-understand",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> ans, res(n, 0);\\n        int temp = 0;\\n        int i = 1;\\n        res[temp] = 1;\\n\\n        while(res[temp] != 2){\\n            temp = (temp + i*k)%n;\\n            res[temp]++;\\n            i++;\\n        }\\n        for(int i = 0; i < n; i++){\\n            if(res[i] == 0)\\n            ans.push_back(i+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> ans, res(n, 0);\\n        int temp = 0;\\n        int i = 1;\\n        res[temp] = 1;\\n\\n        while(res[temp] != 2){\\n            temp = (temp + i*k)%n;\\n            res[temp]++;\\n            i++;\\n        }\\n        for(int i = 0; i < n; i++){\\n            if(res[i] == 0)\\n            ans.push_back(i+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876783,
                "title": "find-the-losers-of-the-game",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        lst=[i for i in range(1,n+1)]\\n        i=0\\n        j=1\\n        while True:\\n            if lst[i]==0:\\n                while 0 in lst:\\n                    lst.remove(0)\\n                return lst\\n            lst[i]=0\\n            i=(i+j*k)%n\\n            j+=1\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        lst=[i for i in range(1,n+1)]\\n        i=0\\n        j=1\\n        while True:\\n            if lst[i]==0:\\n                while 0 in lst:\\n                    lst.remove(0)\\n                return lst\\n            lst[i]=0\\n            i=(i+j*k)%n\\n            j+=1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3875518,
                "title": "masum-code-c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int>v(n,0);\\n        vector<int>ans;\\n        int i=0;\\n        int turn=1;\\n        while(v[i]!=1)\\n        {\\n            v[i]=1;\\n            i=(i+(turn*k)%n)%n;\\n            turn++;\\n        }\\n\\n        for(int k=0;k<n;k++)\\n        {\\n            if(!v[k])\\n            {\\n                ans.push_back(k+1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int>v(n,0);\\n        vector<int>ans;\\n        int i=0;\\n        int turn=1;\\n        while(v[i]!=1)\\n        {\\n            v[i]=1;\\n            i=(i+(turn*k)%n)%n;\\n            turn++;\\n        }\\n\\n        for(int k=0;k<n;k++)\\n        {\\n            if(!v[k])\\n            {\\n                ans.push_back(k+1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874775,
                "title": "java-2ms-beats-97-94",
                "content": "\\n\\n# Code\\n```\\n// build int[] `losers_array` manually: 2ms Beats 97.94%\\n// stream `losers_list` to int[]: 6ms beats 20.99%\\n\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n\\n        // strategy: simulation.\\n        // in my implementation, list of friends is zero-indexed\\n\\n        boolean[] hasReceivedBall = new boolean[n];\\n\\n        int round = 1;\\n        int curFriend = 0;\\n        hasReceivedBall[0] = true;\\n\\n        while (true) {\\n            int nextFriend = (curFriend + k * round++) % n;\\n\\n            if (hasReceivedBall[nextFriend]) {\\n                break;\\n            }\\n\\n            hasReceivedBall[nextFriend] = true;\\n            curFriend = nextFriend;\\n        }\\n\\n        // assemble list of losers\\n        LinkedList<Integer> losers_list = new LinkedList<>();\\n        for (int i = 0; i < hasReceivedBall.length; ++i) {\\n            if (!hasReceivedBall[i]) {\\n                losers_list.add(i + 1);\\n            }\\n        }\\n\\n        // return losers_list.stream().mapToInt(Integer::intValue).toArray();\\n\\n        int[] losers_array = new int[losers_list.size()];\\n        int idxIntoLosersArray = 0;\\n        while (!losers_list.isEmpty()) {\\n            losers_array[idxIntoLosersArray++] = losers_list.removeFirst();\\n        }\\n\\n        return losers_array;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// build int[] `losers_array` manually: 2ms Beats 97.94%\\n// stream `losers_list` to int[]: 6ms beats 20.99%\\n\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n\\n        // strategy: simulation.\\n        // in my implementation, list of friends is zero-indexed\\n\\n        boolean[] hasReceivedBall = new boolean[n];\\n\\n        int round = 1;\\n        int curFriend = 0;\\n        hasReceivedBall[0] = true;\\n\\n        while (true) {\\n            int nextFriend = (curFriend + k * round++) % n;\\n\\n            if (hasReceivedBall[nextFriend]) {\\n                break;\\n            }\\n\\n            hasReceivedBall[nextFriend] = true;\\n            curFriend = nextFriend;\\n        }\\n\\n        // assemble list of losers\\n        LinkedList<Integer> losers_list = new LinkedList<>();\\n        for (int i = 0; i < hasReceivedBall.length; ++i) {\\n            if (!hasReceivedBall[i]) {\\n                losers_list.add(i + 1);\\n            }\\n        }\\n\\n        // return losers_list.stream().mapToInt(Integer::intValue).toArray();\\n\\n        int[] losers_array = new int[losers_list.size()];\\n        int idxIntoLosersArray = 0;\\n        while (!losers_list.isEmpty()) {\\n            losers_array[idxIntoLosersArray++] = losers_list.removeFirst();\\n        }\\n\\n        return losers_array;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3871896,
                "title": "find-the-losers-of-the-circular-game",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        if(n==1&&k==1)\\n        return new int[0];\\n        ArrayList<Integer> arr = new ArrayList<Integer>();\\n        boolean flag = true;\\n        int i=1;\\n        int l=1;\\n        while(flag==true&&i<=n)\\n        {\\n            if(arr.contains(i))\\n            {flag = false;}\\n            if(arr.contains(i)==false)\\n            arr.add(i);\\n            i=(i+l*k)%n;\\n            l++;\\n        }\\n        int[] arr1 = new int[n-arr.size()];\\n        i=1;\\n        int j=0;\\n        while(i<=n&&j<arr1.length)\\n        {\\n            if(arr.contains(i)==false)\\n            {\\n                arr1[j] = i;\\n                j++;\\n            }\\n            i++;\\n        }\\n        return arr1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        if(n==1&&k==1)\\n        return new int[0];\\n        ArrayList<Integer> arr = new ArrayList<Integer>();\\n        boolean flag = true;\\n        int i=1;\\n        int l=1;\\n        while(flag==true&&i<=n)\\n        {\\n            if(arr.contains(i))\\n            {flag = false;}\\n            if(arr.contains(i)==false)\\n            arr.add(i);\\n            i=(i+l*k)%n;\\n            l++;\\n        }\\n        int[] arr1 = new int[n-arr.size()];\\n        i=1;\\n        int j=0;\\n        while(i<=n&&j<arr1.length)\\n        {\\n            if(arr.contains(i)==false)\\n            {\\n                arr1[j] = i;\\n                j++;\\n            }\\n            i++;\\n        }\\n        return arr1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3870920,
                "title": "kotlin-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    fun circularGameLosers(n: Int, k: Int): IntArray {\\n        var result = mutableListOf<Int>()\\n        var set = mutableSetOf<Int>()\\n        var i = 1\\n        var landing = 1\\n\\n        while (!set.contains(landing)) {\\n            set.add(landing)\\n            landing = (landing + (i * k)) % n\\n            if (landing == 0) landing = n\\n            i++\\n        }\\n\\n        for (i in 1..n) {\\n            if (!set.contains(i)) result.add(i)\\n        }\\n\\n        return result.toIntArray()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun circularGameLosers(n: Int, k: Int): IntArray {\\n        var result = mutableListOf<Int>()\\n        var set = mutableSetOf<Int>()\\n        var i = 1\\n        var landing = 1\\n\\n        while (!set.contains(landing)) {\\n            set.add(landing)\\n            landing = (landing + (i * k)) % n\\n            if (landing == 0) landing = n\\n            i++\\n        }\\n\\n        for (i in 1..n) {\\n            if (!set.contains(i)) result.add(i)\\n        }\\n\\n        return result.toIntArray()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3830863,
                "title": "memory-optimized-version-similar-to-dodgeball",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ when step_size (k) == 1\\n\\n- Space complexity:\\nWe start with $$O(n)$$ \\nIn worst case we end with $$O(n-1)$$ \\n==> step_size == number_of_players ==> only Player 1 gets to play \\n\\n# Code\\n```\\nclass Solution:\\n    def circularGameLosers(self, numer_of_players: int, step_size: int) -> List[int]:\\n\\n        players = list(range(1, numer_of_players + 1))  # +1 ==> includes the numer_of_players in range as the last player\\n\\n        # we start at INDEX 0 ==> Player #1\\n        current_player = 1\\n\\n        # we keep track of how often the ball was touched\\n        ball_touched = 1\\n\\n        # O(n) when step_size == 1\\n        while current_player in players:\\n            # with the current player value still intact ... we calculate the next step width\\n            # (current_player - 1) ==> this is the index\\n            speed = ((current_player - 1) + ball_touched * step_size)  # accelerate the \\'speed\\'\\n\\n            # remove player from players list\\n            players.remove(current_player)\\n\\n            # this helps us get the correct player wrapping around at the end of the array\\n            current_player = speed % numer_of_players + 1\\n\\n            ball_touched += 1  # each time the ball is passed we increment by 1\\n\\n        # We only return all loosers (never played) players\\n        return players\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def circularGameLosers(self, numer_of_players: int, step_size: int) -> List[int]:\\n\\n        players = list(range(1, numer_of_players + 1))  # +1 ==> includes the numer_of_players in range as the last player\\n\\n        # we start at INDEX 0 ==> Player #1\\n        current_player = 1\\n\\n        # we keep track of how often the ball was touched\\n        ball_touched = 1\\n\\n        # O(n) when step_size == 1\\n        while current_player in players:\\n            # with the current player value still intact ... we calculate the next step width\\n            # (current_player - 1) ==> this is the index\\n            speed = ((current_player - 1) + ball_touched * step_size)  # accelerate the \\'speed\\'\\n\\n            # remove player from players list\\n            players.remove(current_player)\\n\\n            # this helps us get the correct player wrapping around at the end of the array\\n            current_player = speed % numer_of_players + 1\\n\\n            ball_touched += 1  # each time the ball is passed we increment by 1\\n\\n        # We only return all loosers (never played) players\\n        return players\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3830559,
                "title": "while-loop-until-finished",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def circularGameLosers(self, numer_of_players: int, step_size: int) -> List[int]:\\n\\n         # set the # of hits to 0 for all players\\n        player_hit = [0] * numer_of_players\\n\\n        # we start at INDEX 0 ==> Player #1\\n        next = 0\\n\\n        # we keep track of how often the ball was touched\\n        ball_touched = 1\\n\\n        while True:\\n\\n            player_hit[next] += 1\\n\\n            # The game is finished when some friend receives the ball for the second time.\\n            if player_hit[next] == 2:\\n                # we look at all values of the player_hit array and return the ones which have NEVER been hit\\n                # The losers of the game are friends who did not receive the ball in the entire game.\\n                return [index + 1 for index, value in enumerate(player_hit) if value == 0]\\n\\n            next = (next + ball_touched * step_size) % numer_of_players  # accelerate the \\'speed\\'\\n            ball_touched += 1  # each time the ball is passed we increment by 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def circularGameLosers(self, numer_of_players: int, step_size: int) -> List[int]:\\n\\n         # set the # of hits to 0 for all players\\n        player_hit = [0] * numer_of_players\\n\\n        # we start at INDEX 0 ==> Player #1\\n        next = 0\\n\\n        # we keep track of how often the ball was touched\\n        ball_touched = 1\\n\\n        while True:\\n\\n            player_hit[next] += 1\\n\\n            # The game is finished when some friend receives the ball for the second time.\\n            if player_hit[next] == 2:\\n                # we look at all values of the player_hit array and return the ones which have NEVER been hit\\n                # The losers of the game are friends who did not receive the ball in the entire game.\\n                return [index + 1 for index, value in enumerate(player_hit) if value == 0]\\n\\n            next = (next + ball_touched * step_size) % numer_of_players  # accelerate the \\'speed\\'\\n            ball_touched += 1  # each time the ball is passed we increment by 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827554,
                "title": "c-easy-understanding",
                "content": "# Code\\n```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* circularGameLosers(int n, int k, int* returnSize){\\n    int *res = malloc(sizeof(int)*n);\\n    memset(res, 0, n*sizeof(int) );\\n    int i=1,s=0;\\n    res[0]=1;\\n    while(1){\\n        res[(s+i*k)%n]++;\\n        if(res[(s+i*k)%n]==2){\\n            break;\\n        }\\n        s = (s+i*k)%n;\\n        i++;\\n    }\\n    int x=0;\\n    int *ans = malloc(sizeof(int)*n);\\n    memset(ans, 0, sizeof(int)*n);\\n    for(int i=0;i<n;i++){\\n        if(res[i]==0){\\n            ans[x]=i+1;\\n            x++;\\n        }\\n    }\\n    *returnSize=x;\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* circularGameLosers(int n, int k, int* returnSize){\\n    int *res = malloc(sizeof(int)*n);\\n    memset(res, 0, n*sizeof(int) );\\n    int i=1,s=0;\\n    res[0]=1;\\n    while(1){\\n        res[(s+i*k)%n]++;\\n        if(res[(s+i*k)%n]==2){\\n            break;\\n        }\\n        s = (s+i*k)%n;\\n        i++;\\n    }\\n    int x=0;\\n    int *ans = malloc(sizeof(int)*n);\\n    memset(ans, 0, sizeof(int)*n);\\n    for(int i=0;i<n;i++){\\n        if(res[i]==0){\\n            ans[x]=i+1;\\n            x++;\\n        }\\n    }\\n    *returnSize=x;\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3817792,
                "title": "c-easy-to-understand-solution-o-n-solution-beats-97-75-runtime",
                "content": "# Intuition\\nThe function aims to simulate a circular game of elimination, where n players are standing in a circle, and every k-th player gets eliminated. The function then returns the list of players who are losers in this game.\\n\\n# Approach\\n1. Initialize an array visited of size 100 (it could be any large enough constant) to keep track of visited players. Set all elements in the array to false.\\n2. Start from the first player (index 0) and mark it as visited (visited[0] = true).\\n3. Use two variables i and j to keep track of the current step and player index, respectively. Start with i = 1 and j = 0.\\n4. Iterate until the first player (visited[0]) is visited again:\\n    a. Calculate the new player index j as (j + (i * k)) % n, where n is   the total number of players.\\n    b. If the new player j is already visited (visited[j] == true), it means we have reached the starting player again, and we break the loop.\\n    c. Otherwise, mark the new player j as visited (visited[j] = true) and increment i.\\n5. After the loop, create a vector ans to store the losers\\' indices.\\n6. Iterate over the entire array to find the players whose corresponding indices are not visited (i.e., they are losers) and add them to the ans vector.\\n7. Return the ans vector containing the indices of the losers.\\n\\n\\n# Complexity\\n- Time complexity:\\nTime complexity: The time complexity of the circularGameLosers function is O(n) since it iterates through the array once to find the losers.\\n\\n- Space complexity:\\nSpace complexity: The space complexity is O(n) since the function uses an array of size 100 (or any large enough constant) to track visited players, and the ans vector can store at most n/2 players (losers).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        bool visited[100]={false};\\n        visited[0]=true;\\n        int i=1;\\n        int j=0;\\n        while(visited[0]){\\n            j=(j+(i*k))%n;\\n            if(visited[j]==true){\\n                break;\\n            }\\n            else{\\n                visited[j]=true;\\n                i++;\\n            }\\n        }\\n        vector<int> ans;\\n        for(int h=0;h<n;h++){\\n            if(visited[h]==false){\\n                ans.push_back(h+1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        bool visited[100]={false};\\n        visited[0]=true;\\n        int i=1;\\n        int j=0;\\n        while(visited[0]){\\n            j=(j+(i*k))%n;\\n            if(visited[j]==true){\\n                break;\\n            }\\n            else{\\n                visited[j]=true;\\n                i++;\\n            }\\n        }\\n        vector<int> ans;\\n        for(int h=0;h<n;h++){\\n            if(visited[h]==false){\\n                ans.push_back(h+1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3809281,
                "title": "simple-c-solution-faster-than-97",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int>ans;\\n        vector<bool>visited(n+1, false);\\n        int step = 1;\\n        int i = 1;\\n\\n        while(1){\\n            int nextFriend = i%n;\\n            if(nextFriend == 0){\\n                nextFriend = n;\\n            }\\n            if(visited[nextFriend]){\\n                break;\\n            }\\n            visited[nextFriend] = true;\\n            \\n            i = i + (step*k);\\n            step++;\\n        }\\n\\n        for(int i=1; i<visited.size(); i++){\\n            if(!visited[i]){\\n                ans.push_back(i);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int>ans;\\n        vector<bool>visited(n+1, false);\\n        int step = 1;\\n        int i = 1;\\n\\n        while(1){\\n            int nextFriend = i%n;\\n            if(nextFriend == 0){\\n                nextFriend = n;\\n            }\\n            if(visited[nextFriend]){\\n                break;\\n            }\\n            visited[nextFriend] = true;\\n            \\n            i = i + (step*k);\\n            step++;\\n        }\\n\\n        for(int i=1; i<visited.size(); i++){\\n            if(!visited[i]){\\n                ans.push_back(i);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799457,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        int x = 0;\\n        \\n        int z = 1;\\n        \\n        vector<int>vis(n,0);\\n        vector<int>ans;\\n        set<int>st;\\n        for(int i=1; i <= n; i++)st.insert(i);\\n        while(!vis[x])\\n        {\\n            vis[x] = 1;\\n            st.erase(x+1);\\n            x = (x%n + z*k)%n;\\n            z++;\\n            \\n        }\\n        \\n        for(auto i : st)ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        int x = 0;\\n        \\n        int z = 1;\\n        \\n        vector<int>vis(n,0);\\n        vector<int>ans;\\n        set<int>st;\\n        for(int i=1; i <= n; i++)st.insert(i);\\n        while(!vis[x])\\n        {\\n            vis[x] = 1;\\n            st.erase(x+1);\\n            x = (x%n + z*k)%n;\\n            z++;\\n            \\n        }\\n        \\n        for(auto i : st)ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3781458,
                "title": "simple-traversal",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<bool>visited(n,false);\\n        vector<int>res;\\n        int i = 0;\\n        visited[0] = true;\\n        int count = 1;\\n        while(1)\\n        {\\n            i = (i + count * k) % n;\\n            if(visited[i] == true)\\n                break;\\n            visited[i] = true;\\n            count++;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(visited[i] == false)\\n                res.push_back(i+1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<bool>visited(n,false);\\n        vector<int>res;\\n        int i = 0;\\n        visited[0] = true;\\n        int count = 1;\\n        while(1)\\n        {\\n            i = (i + count * k) % n;\\n            if(visited[i] == true)\\n                break;\\n            visited[i] = true;\\n            count++;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(visited[i] == false)\\n                res.push_back(i+1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777942,
                "title": "worst-solution-ever-must-see-tried-very-hard-but-at-last-success",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(2n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        int[] a=new int[n+1];\\n        int i=1;\\n        int curr=1;\\n        a[1]++;\\n        while(true){\\n            if(curr+i*k>n){\\n                curr = (curr + k * i - 1) % n + 1;\\n                if(a[curr]>0){\\n                    break;\\n                }\\n                else{\\n                    a[curr]++;\\n                }\\n            }\\n            else{\\n                if(a[curr+i*k]>0){\\n                    break;\\n                }\\n                else{\\n                    \\n                    curr=curr+i*k;\\n                    a[curr]++;\\n                }\\n            }\\n            i++;\\n        }\\n        int s=0;\\n        for(int j : a){\\n            if(j==0){\\n                s++;\\n            }\\n        }\\n        int idx=0;\\n        int[] ans=new int[s-1];\\n        System.out.println(Arrays.toString(a));\\n        for(int j=1;j<a.length;j++){\\n            if(a[j]==0){\\n                ans[idx++]=j;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        int[] a=new int[n+1];\\n        int i=1;\\n        int curr=1;\\n        a[1]++;\\n        while(true){\\n            if(curr+i*k>n){\\n                curr = (curr + k * i - 1) % n + 1;\\n                if(a[curr]>0){\\n                    break;\\n                }\\n                else{\\n                    a[curr]++;\\n                }\\n            }\\n            else{\\n                if(a[curr+i*k]>0){\\n                    break;\\n                }\\n                else{\\n                    \\n                    curr=curr+i*k;\\n                    a[curr]++;\\n                }\\n            }\\n            i++;\\n        }\\n        int s=0;\\n        for(int j : a){\\n            if(j==0){\\n                s++;\\n            }\\n        }\\n        int idx=0;\\n        int[] ans=new int[s-1];\\n        System.out.println(Arrays.toString(a));\\n        for(int j=1;j<a.length;j++){\\n            if(a[j]==0){\\n                ans[idx++]=j;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3774351,
                "title": "kotlin-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    fun circularGameLosers(n: Int, k: Int): IntArray {\\n        val pointsMap = IntArray(n)\\n        var friend = 0\\n        var turn = 1\\n\\n        while (true) {\\n            pointsMap[friend] = pointsMap[friend] + 1\\n\\n            if (pointsMap[friend] == 2)\\n                break\\n\\n            friend = (friend + turn * k) % n\\n            turn++\\n        }\\n\\n        val result = IntArray(n - (turn - 1))\\n        var i = 0\\n\\n        pointsMap.forEachIndexed { index, points ->\\n            if (points == 0) {\\n                result[i] = index + 1\\n                i++\\n            }\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun circularGameLosers(n: Int, k: Int): IntArray {\\n        val pointsMap = IntArray(n)\\n        var friend = 0\\n        var turn = 1\\n\\n        while (true) {\\n            pointsMap[friend] = pointsMap[friend] + 1\\n\\n            if (pointsMap[friend] == 2)\\n                break\\n\\n            friend = (friend + turn * k) % n\\n            turn++\\n        }\\n\\n        val result = IntArray(n - (turn - 1))\\n        var i = 0\\n\\n        pointsMap.forEachIndexed { index, points ->\\n            if (points == 0) {\\n                result[i] = index + 1\\n                i++\\n            }\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766614,
                "title": "simple-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar circularGameLosers = function(n, k) {\\n    const visited = new Set()\\n    let currunt = 0, count = 1;\\n    while(!visited.has(currunt)) {\\n        visited.add(currunt);\\n        currunt = (currunt + k * count) % n;\\n        count++;\\n    }\\n    const result = [];\\n    for(let i = 1; i<=n; i++) {\\n        if(!visited.has(i-1)) result.push(i);\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar circularGameLosers = function(n, k) {\\n    const visited = new Set()\\n    let currunt = 0, count = 1;\\n    while(!visited.has(currunt)) {\\n        visited.add(currunt);\\n        currunt = (currunt + k * count) % n;\\n        count++;\\n    }\\n    const result = [];\\n    for(let i = 1; i<=n; i++) {\\n        if(!visited.has(i-1)) result.push(i);\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3760991,
                "title": "hash-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n       vector<int>visited(n,0);\\n       visited[0]=1;vector<int>ans;\\n       int i=1;int j=0;\\n       while(visited[j]<2){\\n           j=(j+i*k)%n;\\n           visited[j]++;\\n           i++;\\n       }\\n       for(int i=0;i<n;i++){\\n           if(visited[i]==0){\\n               ans.push_back(i+1);\\n           }\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n       vector<int>visited(n,0);\\n       visited[0]=1;vector<int>ans;\\n       int i=1;int j=0;\\n       while(visited[j]<2){\\n           j=(j+i*k)%n;\\n           visited[j]++;\\n           i++;\\n       }\\n       for(int i=0;i<n;i++){\\n           if(visited[i]==0){\\n               ans.push_back(i+1);\\n           }\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3757758,
                "title": "c-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nclass Solution \\n{\\npublic:\\n    vector<int> circularGameLosers(int n, int k) \\n    {\\n        vector<int> players(n, 0);\\n        vector<int> result {};\\n        int time = 1;\\n        int current = 0;\\n        bool stop = false;\\n        while (true)\\n        {\\n            for (int i=0; i<n; ++i)\\n            {\\n                if (players[i] == 2)\\n                {\\n                    stop = true;\\n                    break;\\n                }\\n            }\\n            if (stop)\\n            {\\n                break;\\n            }\\n            players[current] ++;\\n            current = (current + time * k) % n;\\n            time ++;\\n        }\\n\\n        for (int i=0; i<n; ++i)\\n        {\\n            if (players[i] == 0)\\n            {\\n                result.push_back(i + 1);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Simulation"
                ],
                "code": "```\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nclass Solution \\n{\\npublic:\\n    vector<int> circularGameLosers(int n, int k) \\n    {\\n        vector<int> players(n, 0);\\n        vector<int> result {};\\n        int time = 1;\\n        int current = 0;\\n        bool stop = false;\\n        while (true)\\n        {\\n            for (int i=0; i<n; ++i)\\n            {\\n                if (players[i] == 2)\\n                {\\n                    stop = true;\\n                    break;\\n                }\\n            }\\n            if (stop)\\n            {\\n                break;\\n            }\\n            players[current] ++;\\n            current = (current + time * k) % n;\\n            time ++;\\n        }\\n\\n        for (int i=0; i<n; ++i)\\n        {\\n            if (players[i] == 0)\\n            {\\n                result.push_back(i + 1);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3756087,
                "title": "java-easy-array-without-collection-o-n-magic-of-while-loop",
                "content": "# Approach\\nloop in while until we get true again and increase count each time\\nnow remaining `n-count+1` is the number of people who didn\\'t get the ball in the game.\\ndefine new array with size of `n-count+1` and add each person who has false in its index\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        boolean[] visited = new boolean[n];\\n        int i = 0;\\n        int count = 1;\\n        while(visited[i]!=true){\\n            visited[i] = true;\\n            i = (i + count*k)%n;\\n            count++;\\n        }\\n        count = n-count+1; // these many people didn\\'t get the ball\\n        int[] answer = new int[count];\\n        i=0;\\n        for(int j=0; j<visited.length ; j++){\\n            if(visited[j]==false){\\n                answer[i++]=j+1;\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        boolean[] visited = new boolean[n];\\n        int i = 0;\\n        int count = 1;\\n        while(visited[i]!=true){\\n            visited[i] = true;\\n            i = (i + count*k)%n;\\n            count++;\\n        }\\n        count = n-count+1; // these many people didn\\'t get the ball\\n        int[] answer = new int[count];\\n        i=0;\\n        for(int j=0; j<visited.length ; j++){\\n            if(visited[j]==false){\\n                answer[i++]=j+1;\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754110,
                "title": "c-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) \\n    {\\n        vector<int> v;\\n        for(int i=1;i<=n;i++) v.push_back(i);\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<n;i++) mp[v[i]]=0;\\n        int iter=0;\\n        for(int i=0;;i=(i+iter*k)%n)\\n        {\\n            if(mp[v[i]]==1)break;\\n            mp[v[i]]++;\\n            iter++;\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(mp[v[i]]==0) ans.push_back(v[i]);\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) \\n    {\\n        vector<int> v;\\n        for(int i=1;i<=n;i++) v.push_back(i);\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<n;i++) mp[v[i]]=0;\\n        int iter=0;\\n        for(int i=0;;i=(i+iter*k)%n)\\n        {\\n            if(mp[v[i]]==1)break;\\n            mp[v[i]]++;\\n            iter++;\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(mp[v[i]]==0) ans.push_back(v[i]);\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754099,
                "title": "java-solution-using-recursion-and-circular-linked-list",
                "content": "# Approach\\nStraight forward approach by using recursion and circular linked list\\n\\n# Code\\n```\\nclass Solution {\\n    private class ListNode {\\n        public int num;\\n        public boolean visited = false;\\n\\n        public ListNode next;\\n\\n        public ListNode(int num, ListNode next) {\\n            this.num = num;\\n            this.next = next;\\n        }\\n    }\\n\\n    public int[] circularGameLosers(int n, int k) {\\n        ListNode head = createLinkedList(n);\\n\\n        passTheBall(head, k, 1);\\n\\n        ListNode cur = head.next;\\n        List<Integer> losers = new ArrayList<>();\\n        while(cur != head) {\\n            if(!cur.visited) {\\n                losers.add(cur.num);\\n            }\\n            cur = cur.next;\\n        }\\n\\n        return losers.stream().mapToInt(i->i).toArray();\\n    }\\n\\n    public void passTheBall(ListNode head, int step, int i) {\\n        if(!head.visited) {\\n            head.visited = true;\\n            int k = i * step;\\n            while(k != 0) {\\n                head = head.next;\\n                k--;\\n            }\\n            passTheBall(head, step, (i+1));\\n        }\\n    }\\n\\n    private ListNode createLinkedList(int n) {\\n        ListNode head = new ListNode(1, null);\\n        ListNode cur = head;\\n        for(int i = 2; i <= n; i++) {\\n            ListNode node = new ListNode(i, null);\\n            cur.next = node;\\n            cur = node;\\n        }\\n        cur.next = head;\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    private class ListNode {\\n        public int num;\\n        public boolean visited = false;\\n\\n        public ListNode next;\\n\\n        public ListNode(int num, ListNode next) {\\n            this.num = num;\\n            this.next = next;\\n        }\\n    }\\n\\n    public int[] circularGameLosers(int n, int k) {\\n        ListNode head = createLinkedList(n);\\n\\n        passTheBall(head, k, 1);\\n\\n        ListNode cur = head.next;\\n        List<Integer> losers = new ArrayList<>();\\n        while(cur != head) {\\n            if(!cur.visited) {\\n                losers.add(cur.num);\\n            }\\n            cur = cur.next;\\n        }\\n\\n        return losers.stream().mapToInt(i->i).toArray();\\n    }\\n\\n    public void passTheBall(ListNode head, int step, int i) {\\n        if(!head.visited) {\\n            head.visited = true;\\n            int k = i * step;\\n            while(k != 0) {\\n                head = head.next;\\n                k--;\\n            }\\n            passTheBall(head, step, (i+1));\\n        }\\n    }\\n\\n    private ListNode createLinkedList(int n) {\\n        ListNode head = new ListNode(1, null);\\n        ListNode cur = head;\\n        for(int i = 2; i <= n; i++) {\\n            ListNode node = new ListNode(i, null);\\n            cur.next = node;\\n            cur = node;\\n        }\\n        cur.next = head;\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744366,
                "title": "java-hashing-explained",
                "content": "**Idea:** Hash the people who have received the ball, then create `losers` array for who those who didn\\'t get the ball\\n>**T/S:** O(n)/O(n)\\n```\\npublic int[] circularGameLosers(int n, int k) {\\n\\tvar received = new boolean[n];\\n\\tvar current = 0;\\n\\tvar i = 1;\\n\\tvar m = 0;\\n\\n\\tfor (; !received[current]; i++) {\\n\\t\\treceived[current] = true;\\n\\t\\tcurrent = (current + i * k) % n;\\n\\t}\\n\\n\\tvar losers = new int[n - --i];\\n\\n\\tfor (var j = 0; j < n; j++)\\n\\t\\tif (!received[j])\\n\\t\\t\\tlosers[m++] = j + 1;\\n\\n\\treturn losers;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] circularGameLosers(int n, int k) {\\n\\tvar received = new boolean[n];\\n\\tvar current = 0;\\n\\tvar i = 1;\\n\\tvar m = 0;\\n\\n\\tfor (; !received[current]; i++) {\\n\\t\\treceived[current] = true;\\n\\t\\tcurrent = (current + i * k) % n;\\n\\t}\\n\\n\\tvar losers = new int[n - --i];\\n\\n\\tfor (var j = 0; j < n; j++)\\n\\t\\tif (!received[j])\\n\\t\\t\\tlosers[m++] = j + 1;\\n\\n\\treturn losers;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3727744,
                "title": "simple-java-solution-beats-99",
                "content": "\\nStore the players in an array.\\n```\\narr = [1,2,3,4,5]\\n```\\nIf a player has the ball, update the value by ```-1``` at that index. At every iteration check if the value is -1. If yes then the game is completed.\\nThe catch here is this: we need to store the current index (the index at which the ball is present). Now we need to add ```i*k``` value to the current index and then do a ```%n```. \\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        int[] players = new int[n];\\n        for(int i = 0; i < n; i++) players[i] = i+1;        \\n        int a = 0; \\n        int currentIndex = 0;\\n        \\n        while(true){\\n            int index = (a*k);\\n            currentIndex = currentIndex + index;\\n            currentIndex = currentIndex % n;\\n            if(players[currentIndex] == -1) break;\\n            players[currentIndex] = -1;\\n            a++;\\n        }        \\n        int[] r = new int[n-a];\\n        int j = 0;\\n        for(int i = 0; i < n; i++){\\n            if(players[i] != -1) r[j++] = players[i];\\n        } \\n        return r;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\narr = [1,2,3,4,5]\\n```\n```-1```\n```i*k```\n```%n```\n```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        int[] players = new int[n];\\n        for(int i = 0; i < n; i++) players[i] = i+1;        \\n        int a = 0; \\n        int currentIndex = 0;\\n        \\n        while(true){\\n            int index = (a*k);\\n            currentIndex = currentIndex + index;\\n            currentIndex = currentIndex % n;\\n            if(players[currentIndex] == -1) break;\\n            players[currentIndex] = -1;\\n            a++;\\n        }        \\n        int[] r = new int[n-a];\\n        int j = 0;\\n        for(int i = 0; i < n; i++){\\n            if(players[i] != -1) r[j++] = players[i];\\n        } \\n        return r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3699824,
                "title": "dart-solution",
                "content": "# Code\\n```\\nclass Solution {\\n  List<int> circularGameLosers(int n, int k) {\\n    List<int> count = List<int>.filled(n, 0);\\n    int currentFriend = 1;\\n    int turn = 1;\\n\\n    while (true) {\\n      count[currentFriend - 1]++;\\n      if (count[currentFriend - 1] == 2) {\\n        break;\\n      }\\n      currentFriend = (currentFriend + turn * k) % n;\\n      if (currentFriend == 0) {\\n        currentFriend = n;\\n      }\\n      turn++;\\n    }\\n\\n    List<int> losers = [];\\n    for (int i = 0; i < n; i++) {\\n      if (count[i] == 0) {\\n        losers.add(i + 1);\\n      }\\n    }\\n\\n    return losers;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  List<int> circularGameLosers(int n, int k) {\\n    List<int> count = List<int>.filled(n, 0);\\n    int currentFriend = 1;\\n    int turn = 1;\\n\\n    while (true) {\\n      count[currentFriend - 1]++;\\n      if (count[currentFriend - 1] == 2) {\\n        break;\\n      }\\n      currentFriend = (currentFriend + turn * k) % n;\\n      if (currentFriend == 0) {\\n        currentFriend = n;\\n      }\\n      turn++;\\n    }\\n\\n    List<int> losers = [];\\n    for (int i = 0; i < n; i++) {\\n      if (count[i] == 0) {\\n        losers.add(i + 1);\\n      }\\n    }\\n\\n    return losers;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3698194,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> vis(n+1 , 0);\\n        vector<int> ans;\\n\\n        int i=1 , j=1;\\n        while (true){\\n            if (vis[i]==1){\\n                break;\\n            }\\n            vis[i] = 1;\\n            i += j*k;\\n            j++;\\n            if (i>n){\\n                while (i>n){\\n                    i -= n;\\n                }\\n            }\\n        } \\n\\n        for (int i=1 ; i<n+1 ; i++){\\n            if (vis[i]==0)\\n                ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> vis(n+1 , 0);\\n        vector<int> ans;\\n\\n        int i=1 , j=1;\\n        while (true){\\n            if (vis[i]==1){\\n                break;\\n            }\\n            vis[i] = 1;\\n            i += j*k;\\n            j++;\\n            if (i>n){\\n                while (i>n){\\n                    i -= n;\\n                }\\n            }\\n        } \\n\\n        for (int i=1 ; i<n+1 ; i++){\\n            if (vis[i]==0)\\n                ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3693047,
                "title": "very-easy-ts-js-solution-using-hashmap-and-circular-queue",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe question is very simple, we have to stop the game as soon as someone gets the ball for the second time.\\n1) First we declar a hashmap to store the points of all the players. Initialy its zero for all. \\n2) We declar a counter that tracks how many times we iterate over the array of players. Each time we iterate over the array of players we increase the k value by counter times and increase the points of the plyer in hashmap which is present at k index. \\n3) We our index go out of bound we compute the circular index using the modulo operator (index = (index + kn) % arr.length) . \\n4) Every time we increase the score/points of a player in the hashmap we first check if its previous score is less than or equal to 1 or not. If its more than one we break the loop there itself.\\n5) Once we come out of the loop we iterate over the hashmap and check which all players have zero score and thats our answer.\\n\\n**If you like my solution, please upvote. It motivates me a lot.**\\n**Happy Coding !!**\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction circularGameLosers(n: number, k: number): number[] {\\n    let arr = []\\n    let hash = {}\\n    for(let i = 0 ; i < n ; i++){\\n        arr.push(i+1)\\n        hash[i+1] = 0\\n    }\\n\\n    let status = true\\n    let count = 0\\n    let index = 0\\n    while(status){\\n        let kn = count * k\\n        index = (index + kn) % arr.length\\n        if(hash[arr[index]] + 1 <= 1){\\n            hash[arr[index]] = hash[arr[index]] + 1\\n        }else{\\n            break\\n        }\\n    \\n        count ++ \\n    }\\n\\n    let res = []\\n    for(let i in hash){\\n        if(hash[i] == 0){\\n            res.push(+i)\\n        }\\n    }\\n\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array",
                    "Hash Table",
                    "Queue"
                ],
                "code": "```\\nfunction circularGameLosers(n: number, k: number): number[] {\\n    let arr = []\\n    let hash = {}\\n    for(let i = 0 ; i < n ; i++){\\n        arr.push(i+1)\\n        hash[i+1] = 0\\n    }\\n\\n    let status = true\\n    let count = 0\\n    let index = 0\\n    while(status){\\n        let kn = count * k\\n        index = (index + kn) % arr.length\\n        if(hash[arr[index]] + 1 <= 1){\\n            hash[arr[index]] = hash[arr[index]] + 1\\n        }else{\\n            break\\n        }\\n    \\n        count ++ \\n    }\\n\\n    let res = []\\n    for(let i in hash){\\n        if(hash[i] == 0){\\n            res.push(+i)\\n        }\\n    }\\n\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3685898,
                "title": "easy-hashing-type",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> count(n, 0);\\n        int start = 0, i = 1;\\n        count[start] = 1;\\n        while(count[start] != 2)\\n        {\\n            start = (start + (i * k)) % n;\\n            count[start]++;\\n            i++;\\n        }\\n        vector<int> ans;        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(count[i] == 0)\\n                ans.push_back(i + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> count(n, 0);\\n        int start = 0, i = 1;\\n        count[start] = 1;\\n        while(count[start] != 2)\\n        {\\n            start = (start + (i * k)) % n;\\n            count[start]++;\\n            i++;\\n        }\\n        vector<int> ans;        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(count[i] == 0)\\n                ans.push_back(i + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683179,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        \\n        vector<int>ans;\\n        int start=1;\\n        int i=1;\\n        map<int,bool>umap;\\n        for(int i =1;i<=n;i++){\\n            umap[i]=false;\\n        }\\n        int helper=1;\\n\\n        while(umap[start]==false){\\n\\n            if(umap[start] !=true){\\n                umap[start]=true;\\n                  helper = (k*i+start);\\n                start= (k*i+start)%(n);\\n              \\n                if(start==0){\\n                   start=n;\\n                }\\n            }\\n            i++;\\n        }\\n        for(auto x:umap){\\n            if(x.second==false){\\n                ans.push_back(x.first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        \\n        vector<int>ans;\\n        int start=1;\\n        int i=1;\\n        map<int,bool>umap;\\n        for(int i =1;i<=n;i++){\\n            umap[i]=false;\\n        }\\n        int helper=1;\\n\\n        while(umap[start]==false){\\n\\n            if(umap[start] !=true){\\n                umap[start]=true;\\n                  helper = (k*i+start);\\n                start= (k*i+start)%(n);\\n              \\n                if(start==0){\\n                   start=n;\\n                }\\n            }\\n            i++;\\n        }\\n        for(auto x:umap){\\n            if(x.second==false){\\n                ans.push_back(x.first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682409,
                "title": "java-1ms-99-10-fast-bitwise",
                "content": "# Complexity\\n- Time complexity:\\nO(n) - in worst case we give ball to every friend.\\n\\n- Space complexity:\\nO(1) - since we know that number of friends cannot exceed 50 we can always use one var of LONG type\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        long friends = 2L, mask = 0L;\\n        int resultI = 0, turn = 1;\\n        for (int currFriend = 1, nextFriend = 0; ; friends |= mask, currFriend = nextFriend) {\\n            nextFriend = (currFriend + k * turn++) % n;\\n            if (nextFriend == 0) nextFriend = n;\\n            mask = 1L << nextFriend;\\n            if ( (friends & mask) == mask) break;\\n        }\\n        final int[] result = new int[n - turn + 1];\\n        for (int i = 1; i <= n; i++)\\n            if ( ((friends >> i) & 1L) != 1L)\\n                result[resultI++] = i;\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        long friends = 2L, mask = 0L;\\n        int resultI = 0, turn = 1;\\n        for (int currFriend = 1, nextFriend = 0; ; friends |= mask, currFriend = nextFriend) {\\n            nextFriend = (currFriend + k * turn++) % n;\\n            if (nextFriend == 0) nextFriend = n;\\n            mask = 1L << nextFriend;\\n            if ( (friends & mask) == mask) break;\\n        }\\n        final int[] result = new int[n - turn + 1];\\n        for (int i = 1; i <= n; i++)\\n            if ( ((friends >> i) & 1L) != 1L)\\n                result[resultI++] = i;\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3673733,
                "title": "brute-force-approach-java-simple-solution-clean-code",
                "content": "# Complexity\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        Set<Integer> st = new LinkedHashSet<>();\\n        for(int i = 1;i <= n;i++){\\n            st.add(i);\\n        }\\n        int curr = 1;\\n        for(int turn = 1;st.contains(curr);turn++){\\n            st.remove(curr);\\n            curr = (curr + (turn * k) % n) % n;\\n            if(curr == 0) curr = n;\\n            \\n        }\\n        int ans[] = new int[st.size()];\\n        int i = 0;\\n        for(var e:st) ans[i++] = e;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        Set<Integer> st = new LinkedHashSet<>();\\n        for(int i = 1;i <= n;i++){\\n            st.add(i);\\n        }\\n        int curr = 1;\\n        for(int turn = 1;st.contains(curr);turn++){\\n            st.remove(curr);\\n            curr = (curr + (turn * k) % n) % n;\\n            if(curr == 0) curr = n;\\n            \\n        }\\n        int ans[] = new int[st.size()];\\n        int i = 0;\\n        for(var e:st) ans[i++] = e;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3672708,
                "title": "python-dictionary-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        current_num = 1\\n        ans_dict = {1:1}\\n        i = 1\\n        while current_num not in ans_dict or ans_dict[current_num] == 1:\\n            next_num = current_num + i * k\\n            print(next_num)\\n            if next_num > n:\\n                next_num = next_num % n\\n                if next_num == 0:\\n                    next_num = n\\n            if next_num not in ans_dict:\\n                ans_dict[next_num] = 1\\n            else:\\n                break\\n            current_num = next_num\\n            i += 1\\n\\n        ans = list(set(list(range(1, n+1))) - set(ans_dict.keys()))\\n        ans.sort()\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        current_num = 1\\n        ans_dict = {1:1}\\n        i = 1\\n        while current_num not in ans_dict or ans_dict[current_num] == 1:\\n            next_num = current_num + i * k\\n            print(next_num)\\n            if next_num > n:\\n                next_num = next_num % n\\n                if next_num == 0:\\n                    next_num = n\\n            if next_num not in ans_dict:\\n                ans_dict[next_num] = 1\\n            else:\\n                break\\n            current_num = next_num\\n            i += 1\\n\\n        ans = list(set(list(range(1, n+1))) - set(ans_dict.keys()))\\n        ans.sort()\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663771,
                "title": "c-basic-simulation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int>v(n,0),ans;\\n        for(int i=0,j=1;!v[i];++j){\\n            v[i]=1;\\n            i=(i+j*k)%n;\\n        }\\n        for(int i=0;i<n;++i)if(!v[i])ans.push_back(i+1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int>v(n,0),ans;\\n        for(int i=0,j=1;!v[i];++j){\\n            v[i]=1;\\n            i=(i+j*k)%n;\\n        }\\n        for(int i=0;i<n;++i)if(!v[i])ans.push_back(i+1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3657133,
                "title": "c-easy-and-fast-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int[] CircularGameLosers(int n, int k) {\\n            SortedSet<int> te = new SortedSet<int>();\\n            int pos = 1;\\n            te.Add(pos);\\n            int loop = 1;\\n            while(true)\\n            {\\n                pos = pos + k*loop;\\n                int th = pos % n;\\n                if(th==0)\\n                {\\n                    th = n;\\n                }\\n                if (!te.Add(th))\\n                {\\n                    break;\\n                }\\n                loop++;\\n            }\\n            int el = n - te.Count;\\n            int[] res = new int[el];\\n            int cou = 0;\\n            for(int i=1; i <= n; i++)\\n            {\\n                if(!te.Contains(i))\\n                {\\n                    res[cou] = i;\\n                    cou++;\\n                }\\n            }\\n            return res;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] CircularGameLosers(int n, int k) {\\n            SortedSet<int> te = new SortedSet<int>();\\n            int pos = 1;\\n            te.Add(pos);\\n            int loop = 1;\\n            while(true)\\n            {\\n                pos = pos + k*loop;\\n                int th = pos % n;\\n                if(th==0)\\n                {\\n                    th = n;\\n                }\\n                if (!te.Add(th))\\n                {\\n                    break;\\n                }\\n                loop++;\\n            }\\n            int el = n - te.Count;\\n            int[] res = new int[el];\\n            int cou = 0;\\n            for(int i=1; i <= n; i++)\\n            {\\n                if(!te.Contains(i))\\n                {\\n                    res[cou] = i;\\n                    cou++;\\n                }\\n            }\\n            return res;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652370,
                "title": "simulation-linq",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] CircularGameLosers(int n, int k) {\\n        int[] counts = new int[n];        \\n        int iTurn = 1;\\n        int iBall = 0;\\n        while (true)\\n        {            \\n            counts[iBall]++;\\n            if (counts[iBall] == 2)\\n                break;\\n            iBall = (iBall + iTurn * k) % n;\\n            iTurn++;\\n        }\\n        \\n        return counts.Select((item, index) => (item, index)).\\n                      Where(x => x.item == 0).\\n                      Select(x => x.index + 1).\\n                      ToArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] CircularGameLosers(int n, int k) {\\n        int[] counts = new int[n];        \\n        int iTurn = 1;\\n        int iBall = 0;\\n        while (true)\\n        {            \\n            counts[iBall]++;\\n            if (counts[iBall] == 2)\\n                break;\\n            iBall = (iBall + iTurn * k) % n;\\n            iTurn++;\\n        }\\n        \\n        return counts.Select((item, index) => (item, index)).\\n                      Where(x => x.item == 0).\\n                      Select(x => x.index + 1).\\n                      ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651369,
                "title": "beats-99-faster-solution-c-optimised-easy-approach-maths-bruteforce",
                "content": "# Intuition\\njust doing the mathematics based on the question as mentioned \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: < O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        // vector<int> ans;\\n        vector<bool> visited(n+1,false);\\n        visited[1] = true;\\n        int i=1;\\n        int curri = 0;\\n        for(int j=1;j<=n;j++){\\n            int steps = i*k;\\n            int index = (steps + curri)%n;\\n            if(visited[index+1] == true){\\n                break;\\n            }else{\\n                visited[index+1] = true;\\n                i+=1;\\n                curri = index;\\n            }\\n        }\\n        vector<int> ans ;\\n\\n        for(int i=1;i<n+1;i++){\\n            if(visited[i] == false){\\n                ans.push_back(i);\\n            }\\n        }\\n        return (ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        // vector<int> ans;\\n        vector<bool> visited(n+1,false);\\n        visited[1] = true;\\n        int i=1;\\n        int curri = 0;\\n        for(int j=1;j<=n;j++){\\n            int steps = i*k;\\n            int index = (steps + curri)%n;\\n            if(visited[index+1] == true){\\n                break;\\n            }else{\\n                visited[index+1] = true;\\n                i+=1;\\n                curri = index;\\n            }\\n        }\\n        vector<int> ans ;\\n\\n        for(int i=1;i<n+1;i++){\\n            if(visited[i] == false){\\n                ans.push_back(i);\\n            }\\n        }\\n        return (ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3648617,
                "title": "javascript-map-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\n  O(N)\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar circularGameLosers = function(n, k) {\\n    let map=new Map()\\n    let i=1\\n    let count=1\\n    while(true){\\n        i=i%n\\n        if(i==0){\\n            i=n\\n        }\\n        if(!map.has(i)){\\n           map.set(i,1)\\n        }\\n        else{\\n            break\\n        }\\n        i+=count*k\\n        count++\\n    }\\n    console.log(map)\\n    let arr=[]\\n    for(let i=1;i<=n;i++){\\n        if(map.has(i)){\\n            continue\\n        }\\n        else{\\n            arr.push(i)\\n        }\\n\\n\\n    }\\n    return arr\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar circularGameLosers = function(n, k) {\\n    let map=new Map()\\n    let i=1\\n    let count=1\\n    while(true){\\n        i=i%n\\n        if(i==0){\\n            i=n\\n        }\\n        if(!map.has(i)){\\n           map.set(i,1)\\n        }\\n        else{\\n            break\\n        }\\n        i+=count*k\\n        count++\\n    }\\n    console.log(map)\\n    let arr=[]\\n    for(let i=1;i<=n;i++){\\n        if(map.has(i)){\\n            continue\\n        }\\n        else{\\n            arr.push(i)\\n        }\\n\\n\\n    }\\n    return arr\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3635557,
                "title": "trivial-c-beats-100",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> result;\\n        bool players[50] = {};\\n        auto current = 0, turn = 1;\\n        do {\\n            players[current] = true;\\n            current = (current + turn++ * k) % n;\\n        } while (!players[current]);\\n        for (auto i = 0; i < n; ++i)\\n            if (!players[i])\\n                result.push_back(i + 1);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> result;\\n        bool players[50] = {};\\n        auto current = 0, turn = 1;\\n        do {\\n            players[current] = true;\\n            current = (current + turn++ * k) % n;\\n        } while (!players[current]);\\n        for (auto i = 0; i < n; ++i)\\n            if (!players[i])\\n                result.push_back(i + 1);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630425,
                "title": "java-hashset-very-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n   public int[] circularGameLosers(int n, int k) {\\n    Set<Integer> set = new HashSet<>();\\n    int number = 1, step = 1;\\n\\n    while (true) {\\n        if (set.contains(number))\\n            break;\\n\\n        set.add(number);\\n        number = ((step * k) + number) % n;\\n        step++;\\n    }\\n\\n   if(set.contains(0)){\\n       set.remove(0);\\n       set.add(n);\\n   }\\n    int arr[]=new int[n-set.size()];\\n    int p=0;\\n    for (int i = 1; i <= n; i++) {\\n        if (!set.contains(i)) {\\n            arr[p++] = i;\\n        }\\n    }\\n\\n    return arr;\\n}\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public int[] circularGameLosers(int n, int k) {\\n    Set<Integer> set = new HashSet<>();\\n    int number = 1, step = 1;\\n\\n    while (true) {\\n        if (set.contains(number))\\n            break;\\n\\n        set.add(number);\\n        number = ((step * k) + number) % n;\\n        step++;\\n    }\\n\\n   if(set.contains(0)){\\n       set.remove(0);\\n       set.add(n);\\n   }\\n    int arr[]=new int[n-set.size()];\\n    int p=0;\\n    for (int i = 1; i <= n; i++) {\\n        if (!set.contains(i)) {\\n            arr[p++] = i;\\n        }\\n    }\\n\\n    return arr;\\n}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618964,
                "title": "python3-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        friends = [i for i in range(1, n + 1)]\\n        winners = {1}\\n        index = 0\\n        i = 1\\n        while True:\\n            index = (index + (i * k)) % n\\n            if friends[index] in winners:\\n                break\\n            else:\\n                winners.add(friends[index])\\n            i += 1\\n        return sorted(set(friends) - winners)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        friends = [i for i in range(1, n + 1)]\\n        winners = {1}\\n        index = 0\\n        i = 1\\n        while True:\\n            index = (index + (i * k)) % n\\n            if friends[index] in winners:\\n                break\\n            else:\\n                winners.add(friends[index])\\n            i += 1\\n        return sorted(set(friends) - winners)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3610175,
                "title": "simple-python-solution-beats-85",
                "content": "# Code\\n```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        not_recieved = {i for i in range(1, n + 1)}\\n        current = 0\\n        for i in range(50):\\n            current = (current + (k * i)) % n\\n            if current + 1 not in not_recieved:\\n                break\\n            not_recieved.remove(current + 1)\\n        return not_recieved\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        not_recieved = {i for i in range(1, n + 1)}\\n        current = 0\\n        for i in range(50):\\n            current = (current + (k * i)) % n\\n            if current + 1 not in not_recieved:\\n                break\\n            not_recieved.remove(current + 1)\\n        return not_recieved\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3609571,
                "title": "very-readable-and-easy-to-understand-python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        has_played_map = {i: False for i in range (n)}\\n\\n        curr_ball_holder = 0\\n        multiplier = 1\\n\\n        while has_played_map[curr_ball_holder] == False:\\n            has_played_map[curr_ball_holder] = True\\n            curr_ball_holder  = (curr_ball_holder + (multiplier * k)) % n\\n            multiplier += 1\\n        \\n        return [player_no + 1 for player_no, has_played in has_played_map.items() if not has_played]\\n```\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        has_played_map = {i: False for i in range (n)}\\n\\n        curr_ball_holder = 0\\n        multiplier = 1\\n\\n        while has_played_map[curr_ball_holder] == False:\\n            has_played_map[curr_ball_holder] = True\\n            curr_ball_holder  = (curr_ball_holder + (multiplier * k)) % n\\n            multiplier += 1\\n        \\n        return [player_no + 1 for player_no, has_played in has_played_map.items() if not has_played]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608593,
                "title": "operating-with-player-number-not-index-o-n",
                "content": "# Intuition\\nWe are playing the game\\n\\n# Approach\\nWe will be operating with player number, not index\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    fun circularGameLosers(n: Int, k: Int): IntArray {\\n        val gotBall = mutableListOf(1)\\n        var turn = 1\\n        while (true) {\\n            var nextPlayer =  (gotBall.last() + k * turn++) % n\\n            // if the last player receives the ball\\n            if (nextPlayer == 0) nextPlayer = n\\n\\n            if (nextPlayer in gotBall) break\\n            gotBall.add(nextPlayer)\\n        }\\n\\n        return (1..n).filter { it !in gotBall }.toIntArray()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun circularGameLosers(n: Int, k: Int): IntArray {\\n        val gotBall = mutableListOf(1)\\n        var turn = 1\\n        while (true) {\\n            var nextPlayer =  (gotBall.last() + k * turn++) % n\\n            // if the last player receives the ball\\n            if (nextPlayer == 0) nextPlayer = n\\n\\n            if (nextPlayer in gotBall) break\\n            gotBall.add(nextPlayer)\\n        }\\n\\n        return (1..n).filter { it !in gotBall }.toIntArray()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3603981,
                "title": "elixir-simulation-solution",
                "content": "`i` means (\"the friend holding the ball\" - 1).\\n`j` means the number of steps to pass the ball.\\n`set` contains all the friends who never held the ball.\\n# Code\\n```Elixir\\ndefmodule Solution do\\n  @spec circular_game_losers(n :: integer, k :: integer) :: [integer]\\n  def circular_game_losers(n, k) do\\n    play(MapSet.new(1..n), 0, k, n, k)\\n  end\\n\\n  defp play(set, i, j, n, k) do\\n    if MapSet.member?(set, i + 1) do\\n      MapSet.delete(set, i + 1)\\n      |> play(rem(i + j, n), j + k, n, k)\\n    else\\n      Enum.sort(set)\\n    end\\n  end\\nend\\n```",
                "solutionTags": [
                    "Elixir",
                    "Hash Table",
                    "Simulation"
                ],
                "code": "```Elixir\\ndefmodule Solution do\\n  @spec circular_game_losers(n :: integer, k :: integer) :: [integer]\\n  def circular_game_losers(n, k) do\\n    play(MapSet.new(1..n), 0, k, n, k)\\n  end\\n\\n  defp play(set, i, j, n, k) do\\n    if MapSet.member?(set, i + 1) do\\n      MapSet.delete(set, i + 1)\\n      |> play(rem(i + j, n), j + k, n, k)\\n    else\\n      Enum.sort(set)\\n    end\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3602093,
                "title": "3ms-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.HashSet;\\npublic class Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        HashSet<Integer> list = new HashSet<>();\\n\\n        int j = 1;\\n        int initial = 1;\\n        while (!list.contains(initial)){\\n            list.add(initial);\\n            initial = (initial+(k*j))%n;\\n            if (initial == 0)initial=n;\\n            j++;\\n        }\\n\\n        j=0;\\n        int[] result = new int[n - list.size()];\\n        for (int i = 1; i < n+1; i++) {\\n            if (!list.contains(i)) {\\n                result[j] = i;\\n                j++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.HashSet;\\npublic class Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        HashSet<Integer> list = new HashSet<>();\\n\\n        int j = 1;\\n        int initial = 1;\\n        while (!list.contains(initial)){\\n            list.add(initial);\\n            initial = (initial+(k*j))%n;\\n            if (initial == 0)initial=n;\\n            j++;\\n        }\\n\\n        j=0;\\n        int[] result = new int[n - list.size()];\\n        for (int i = 1; i < n+1; i++) {\\n            if (!list.contains(i)) {\\n                result[j] = i;\\n                j++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595936,
                "title": "c-python-easy-simple-solution-brute-force-o-n-o-n",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code : C++\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<pair<int,int>> vec;\\n        for(int i=1;i<=n;i++){\\n            pair<int,int> p;\\n            p.first = i;\\n            p.second = 0;\\n            vec.push_back(p);\\n        }\\n        int ptr = 0;\\n        int i = 1;\\n        while(vec[ptr].second != 1){\\n            vec[ptr].second = 1;\\n            ptr += (i++)*k ;\\n            ptr %= n;\\n        }\\n        vector<int>ans;\\n        for(auto x: vec) if(x.second==0) ans.push_back(x.first);\\n        return ans;\\n    }\\n};\\n```\\n\\n# Code : Python\\n```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        nums = [i+1 for i in range(n)]\\n        status = [0]*n\\n        ptr, i = 0, 1\\n        while(status[ptr] != 1):\\n            status[ptr] = 1\\n            ptr = ptr + i*k\\n            i = i + 1\\n            ptr = ptr % n\\n        \\n        ans = []\\n        for i in range(len(status)):\\n            if(status[i] == 0):\\n                ans.append(nums[i])\\n        return ans\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<pair<int,int>> vec;\\n        for(int i=1;i<=n;i++){\\n            pair<int,int> p;\\n            p.first = i;\\n            p.second = 0;\\n            vec.push_back(p);\\n        }\\n        int ptr = 0;\\n        int i = 1;\\n        while(vec[ptr].second != 1){\\n            vec[ptr].second = 1;\\n            ptr += (i++)*k ;\\n            ptr %= n;\\n        }\\n        vector<int>ans;\\n        for(auto x: vec) if(x.second==0) ans.push_back(x.first);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        nums = [i+1 for i in range(n)]\\n        status = [0]*n\\n        ptr, i = 0, 1\\n        while(status[ptr] != 1):\\n            status[ptr] = 1\\n            ptr = ptr + i*k\\n            i = i + 1\\n            ptr = ptr % n\\n        \\n        ans = []\\n        for i in range(len(status)):\\n            if(status[i] == 0):\\n                ans.append(nums[i])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3589652,
                "title": "c-simulation-convert-visualization-into-coding",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        \\n        vector<int> vis(n,0);\\n        int i = 0 ; \\n        int t = k ; \\n        vis[0] = 1;\\n        while(1)\\n        {\\n            if(vis[(i+k)%n] ) break; \\n            cout<<(i+k)%n<<\" \";            \\n            vis[(i+k)%n] = 1 ;\\n            i = (i+k)%n;\\n            k  += t; \\n            \\n        }\\n        \\n        vector<int> ans;\\n        \\n        for( int i = 0 ; i < n ; ++i )\\n        {\\n            if(!vis[i]) ans.push_back(i+1);\\n        }\\n        \\n        return ans;\\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        \\n        vector<int> vis(n,0);\\n        int i = 0 ; \\n        int t = k ; \\n        vis[0] = 1;\\n        while(1)\\n        {\\n            if(vis[(i+k)%n] ) break; \\n            cout<<(i+k)%n<<\" \";            \\n            vis[(i+k)%n] = 1 ;\\n            i = (i+k)%n;\\n            k  += t; \\n            \\n        }\\n        \\n        vector<int> ans;\\n        \\n        for( int i = 0 ; i < n ; ++i )\\n        {\\n            if(!vis[i]) ans.push_back(i+1);\\n        }\\n        \\n        return ans;\\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3583625,
                "title": "go-simple-solution",
                "content": "# Complexity\\n- Time complexity:\\n- $$O(n)$$\\n\\n- Space complexity:\\n- $$O(n)$$\\n\\n# Code\\n```\\nfunc circularGameLosers(n int, k int) []int {\\n\\twinnerMap := map[int]bool{0: true}\\n\\tcurIdx := 0\\n\\tround := 1\\n\\n\\tfor true {\\n\\t\\tcurIdx = (curIdx + round*k) % n\\n\\n\\t\\tif true == winnerMap[curIdx] {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\twinnerMap[curIdx] = true\\n\\t\\tround++\\n\\t}\\n\\n\\tres := []int{}\\n\\n\\tfor i := 1; i < n; i++ {\\n\\t\\tif false == winnerMap[i] {\\n\\t\\t\\tres = append(res, i+1)\\n\\t\\t}\\n\\t}\\n\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc circularGameLosers(n int, k int) []int {\\n\\twinnerMap := map[int]bool{0: true}\\n\\tcurIdx := 0\\n\\tround := 1\\n\\n\\tfor true {\\n\\t\\tcurIdx = (curIdx + round*k) % n\\n\\n\\t\\tif true == winnerMap[curIdx] {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\twinnerMap[curIdx] = true\\n\\t\\tround++\\n\\t}\\n\\n\\tres := []int{}\\n\\n\\tfor i := 1; i < n; i++ {\\n\\t\\tif false == winnerMap[i] {\\n\\t\\t\\tres = append(res, i+1)\\n\\t\\t}\\n\\t}\\n\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3583578,
                "title": "simple-kotlin-solution",
                "content": "\\n# Approach\\nJust play the game. Since we generally like to work in 0 indexed fashion but the result needs to be 1 indexed, convert at the end when taking indices that aren\\'t in the visited set.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    fun circularGameLosers(n: Int, k: Int): IntArray {\\n        val set = mutableSetOf<Int>()\\n        var current = 0\\n        var turn = 1\\n\\n        while (!set.contains(current)) {\\n            set.add(current)\\n            current = (current + turn++ * k) % n\\n        }\\n\\n        val result = IntArray(n - set.size)\\n        var index = 0\\n        \\n        for (i in 0 until n) {\\n            if (!set.contains(i)) {\\n                result[index++] = i + 1\\n            }\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun circularGameLosers(n: Int, k: Int): IntArray {\\n        val set = mutableSetOf<Int>()\\n        var current = 0\\n        var turn = 1\\n\\n        while (!set.contains(current)) {\\n            set.add(current)\\n            current = (current + turn++ * k) % n\\n        }\\n\\n        val result = IntArray(n - set.size)\\n        var index = 0\\n        \\n        for (i in 0 until n) {\\n            if (!set.contains(i)) {\\n                result[index++] = i + 1\\n            }\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3575470,
                "title": "java-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        \\n        int[] arr = new int[n];\\n        int i = 0;\\n        int j = 1;\\n\\n        while(arr[i%n] == 0){\\n            \\n            arr[i%n] = 1;\\n            i += k*j;\\n            j++;\\n            \\n        }\\n        \\n        int len = 0;\\n\\n        for(int l : arr) if(l == 0) len++;\\n\\n        int[] ans = new int[len];\\n\\n        int index = 0;\\n\\n        for(int l=0; l<arr.length; l++) if(arr[l] == 0) ans[index++] = l+1;\\n\\n        return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        \\n        int[] arr = new int[n];\\n        int i = 0;\\n        int j = 1;\\n\\n        while(arr[i%n] == 0){\\n            \\n            arr[i%n] = 1;\\n            i += k*j;\\n            j++;\\n            \\n        }\\n        \\n        int len = 0;\\n\\n        for(int l : arr) if(l == 0) len++;\\n\\n        int[] ans = new int[len];\\n\\n        int index = 0;\\n\\n        for(int l=0; l<arr.length; l++) if(arr[l] == 0) ans[index++] = l+1;\\n\\n        return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574127,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfirstly ,for keep track of visited number we need a map. \\n# Approach\\nBrute force.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        \\n        int p=1,q;\\n        vector<int>v;\\n        map<int ,int >mp;\\n        for(int i=1;i<=5;i++)\\n        {\\n            mp[i]=0;\\n        }\\n        if(k==1 && n<=2)\\n        {\\n            return v;\\n        }\\n        int i=1;\\n        mp[1]++;\\n        while(1)\\n        {\\n           q= (p+k*i);\\n           if(q>n)\\n           {\\n               q=q%n;\\n               if(q==0)\\n               {\\n                   q=n;\\n               }\\n           }\\n           mp[q]++;\\n           if(mp[q]==2)\\n           {\\n               break;\\n           }\\n           p=q;\\n           i++;\\n\\n        }\\n\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(mp[i]==0)\\n            {\\n                v.push_back(i);\\n            }\\n        }\\n\\n    return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        \\n        int p=1,q;\\n        vector<int>v;\\n        map<int ,int >mp;\\n        for(int i=1;i<=5;i++)\\n        {\\n            mp[i]=0;\\n        }\\n        if(k==1 && n<=2)\\n        {\\n            return v;\\n        }\\n        int i=1;\\n        mp[1]++;\\n        while(1)\\n        {\\n           q= (p+k*i);\\n           if(q>n)\\n           {\\n               q=q%n;\\n               if(q==0)\\n               {\\n                   q=n;\\n               }\\n           }\\n           mp[q]++;\\n           if(mp[q]==2)\\n           {\\n               break;\\n           }\\n           p=q;\\n           i++;\\n\\n        }\\n\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(mp[i]==0)\\n            {\\n                v.push_back(i);\\n            }\\n        }\\n\\n    return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568404,
                "title": "video-in-arabic-language-for-how-to-think-on-the-solution-python-code",
                "content": "\\n# Think how to solve the problem \\n<!-- Describe your approach to solving the problem. -->\\n[https://www.youtube.com/watch?v=itaExMDMoO0]()\\n\\n# Code\\n```\\nclass Solution(object):\\n    def circularGameLosers(self, n, k):\\n        \"\"\"\\n        :type n: int\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        if n == k:\\n            return  list(range(2,n+1))\\n        \\n        res_dict = {}\\n        res_dict[1] = 1\\n        for i in range(2,n+1):\\n            res_dict[i] = 0\\n        \\n        iterationNumber = 1\\n        playerNumber = 1\\n        while(1):\\n            nextPlayer = (playerNumber + ( k * iterationNumber ) ) % n \\n            \\n           \\n        \\n            if (nextPlayer == 0 ):\\n                nextPlayer = n \\n            \\n            if(res_dict.get(nextPlayer) == 1):\\n                return [k for k, v in res_dict.items() if v == 0]\\n            \\n            else:\\n                res_dict[nextPlayer] = 1\\n             \\n            playerNumber = nextPlayer\\n            iterationNumber += 1\\n                \\n            \\n      \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def circularGameLosers(self, n, k):\\n        \"\"\"\\n        :type n: int\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        if n == k:\\n            return  list(range(2,n+1))\\n        \\n        res_dict = {}\\n        res_dict[1] = 1\\n        for i in range(2,n+1):\\n            res_dict[i] = 0\\n        \\n        iterationNumber = 1\\n        playerNumber = 1\\n        while(1):\\n            nextPlayer = (playerNumber + ( k * iterationNumber ) ) % n \\n            \\n           \\n        \\n            if (nextPlayer == 0 ):\\n                nextPlayer = n \\n            \\n            if(res_dict.get(nextPlayer) == 1):\\n                return [k for k, v in res_dict.items() if v == 0]\\n            \\n            else:\\n                res_dict[nextPlayer] = 1\\n             \\n            playerNumber = nextPlayer\\n            iterationNumber += 1\\n                \\n            \\n      \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567413,
                "title": "java-javascript-c-c-solution",
                "content": "**Java**\\n```\\npublic class Solution {\\n\\n    public int[] circularGameLosers(int totalPlayers, int steps) {\\n        boolean[] ballReceivedByPlayer = new boolean[totalPlayers];\\n        int uniqueBallReceptions = countUniqueBallReceptions(ballReceivedByPlayer, totalPlayers, steps);\\n        return extractLosersFromAllPlayers(ballReceivedByPlayer, totalPlayers, uniqueBallReceptions);\\n    }\\n\\n    private int countUniqueBallReceptions(boolean[] ballReceivedByPlayer, int totalPlayers, int steps) {\\n        int currentPlayer = 0;\\n        int uniqueBallReceptions = 1;\\n        ballReceivedByPlayer[currentPlayer] = true;\\n\\n        while (true) {\\n            int nextPlayer = (currentPlayer + uniqueBallReceptions * steps) % totalPlayers;\\n            if (ballReceivedByPlayer[nextPlayer]) {\\n                break;\\n            }\\n\\n            ++uniqueBallReceptions;\\n            currentPlayer = nextPlayer;\\n            ballReceivedByPlayer[nextPlayer] = true;\\n        }\\n        return uniqueBallReceptions;\\n    }\\n\\n    private int[] extractLosersFromAllPlayers(boolean[] ballReceivedByPlayer, int totalPlayers, int countUniqueBallReceptions) {\\n        int index = 0;\\n        int[] circularGameLosers = new int[totalPlayers - countUniqueBallReceptions];\\n        for (int i = 0; i < totalPlayers; ++i) {\\n            if (!ballReceivedByPlayer[i]) {\\n                circularGameLosers[index] = i + 1;//PlayerID for the results start from 1.\\n                ++index;\\n            }\\n        }\\n        return circularGameLosers;\\n    }\\n}\\n```\\n**JavaScript**\\n```\\n/**\\n * @param {number} totalPlayers\\n * @param {number} steps\\n * @return {number[]}\\n */\\nvar circularGameLosers = function (totalPlayers, steps) {\\n    const ballReceivedByPlayer = new Array(totalPlayers).fill(false);\\n    let uniqueBallReceptions = countUniqueBallReceptions(ballReceivedByPlayer, totalPlayers, steps);\\n    return extractLosersFromAllPlayers(ballReceivedByPlayer, totalPlayers, uniqueBallReceptions);\\n};\\n\\n/**\\n * @param {boolean[]} ballReceivedByPlayer\\n * @param {number} totalPlayers\\n * @param {number} steps \\n * @return {number}\\n */\\nfunction countUniqueBallReceptions(ballReceivedByPlayer, totalPlayers, steps) {\\n    let currentPlayer = 0;\\n    let uniqueBallReceptions = 1;\\n    ballReceivedByPlayer[currentPlayer] = true;\\n\\n    while (true) {\\n        let nextPlayer = (currentPlayer + uniqueBallReceptions * steps) % totalPlayers;\\n        if (ballReceivedByPlayer[nextPlayer]) {\\n            break;\\n        }\\n\\n        ++uniqueBallReceptions;\\n        currentPlayer = nextPlayer;\\n        ballReceivedByPlayer[nextPlayer] = true;\\n    }\\n    return uniqueBallReceptions;\\n}\\n\\n/**\\n * @param {boolean[]} ballReceivedByPlayer\\n * @param {number} totalPlayers\\n * @param {number} countUniqueBallReceptions \\n * @return {number[]}\\n */\\nfunction extractLosersFromAllPlayers(ballReceivedByPlayer, totalPlayers, countUniqueBallReceptions) {\\n    let index = 0;\\n    const circularGameLosers = new Array(totalPlayers - countUniqueBallReceptions);\\n    for (let i = 0; i < totalPlayers; ++i) {\\n        if (!ballReceivedByPlayer[i]) {\\n            circularGameLosers[index] = i + 1;//PlayerID for the results start from 1.\\n            ++index;\\n        }\\n    }\\n    return circularGameLosers;\\n}\\n```\\n**C++**\\n```\\n#include <vector>\\nusing namespace std;\\n\\nclass Solution {\\n    \\npublic:\\n    vector<int> circularGameLosers(int totalPlayers, int steps) const {\\n        vector<bool> ballReceivedByPlayer(totalPlayers);\\n        int uniqueBallReceptions = countUniqueBallReceptions(ballReceivedByPlayer, totalPlayers, steps);\\n        return extractLosersFromAllPlayers(ballReceivedByPlayer, totalPlayers, uniqueBallReceptions);\\n    }\\n\\nprivate:\\n    int countUniqueBallReceptions(vector<bool>& ballReceivedByPlayer, int totalPlayers, int steps) const {\\n        int currentPlayer = 0;\\n        int uniqueBallReceptions = 1;\\n        ballReceivedByPlayer[currentPlayer] = true;\\n\\n        while (true) {\\n            int nextPlayer = (currentPlayer + uniqueBallReceptions * steps) % totalPlayers;\\n            if (ballReceivedByPlayer[nextPlayer]) {\\n                break;\\n            }\\n\\n            ++uniqueBallReceptions;\\n            currentPlayer = nextPlayer;\\n            ballReceivedByPlayer[nextPlayer] = true;\\n        }\\n        return uniqueBallReceptions;\\n    }\\n\\n    vector<int> extractLosersFromAllPlayers(const vector<bool>& ballReceivedByPlayer, int totalPlayers, int countUniqueBallReceptions) const {\\n        int index = 0;\\n        vector<int> circularGameLosers(totalPlayers - countUniqueBallReceptions);\\n        for (int i = 0; i < totalPlayers; ++i) {\\n            if (!ballReceivedByPlayer[i]) {\\n                circularGameLosers[index] = i + 1; //PlayerID for the results start from 1.\\n                ++index;\\n            }\\n        }\\n        return circularGameLosers;\\n    }\\n};\\n```\\n**C#**\\n```\\nusing System;\\n\\npublic class Solution\\n{\\n    public int[] CircularGameLosers(int totalPlayers, int steps)\\n    {\\n        bool[] ballReceivedByPlayer = new bool[totalPlayers];\\n        int uniqueBallReceptions = countUniqueBallReceptions(ballReceivedByPlayer, totalPlayers, steps);\\n        return extractLosersFromAllPlayers(ballReceivedByPlayer, totalPlayers, uniqueBallReceptions);\\n    }\\n\\n    private int countUniqueBallReceptions(bool[] ballReceivedByPlayer, int totalPlayers, int steps)\\n    {\\n        int currentPlayer = 0;\\n        int uniqueBallReceptions = 1;\\n        ballReceivedByPlayer[currentPlayer] = true;\\n\\n        while (true)\\n        {\\n            int nextPlayer = (currentPlayer + uniqueBallReceptions * steps) % totalPlayers;\\n            if (ballReceivedByPlayer[nextPlayer])\\n            {\\n                break;\\n            }\\n\\n            ++uniqueBallReceptions;\\n            currentPlayer = nextPlayer;\\n            ballReceivedByPlayer[nextPlayer] = true;\\n        }\\n        return uniqueBallReceptions;\\n    }\\n\\n    private int[] extractLosersFromAllPlayers(bool[] ballReceivedByPlayer, int totalPlayers, int countUniqueBallReceptions)\\n    {\\n        int index = 0;\\n        int[] circularGameLosers = new int[totalPlayers - countUniqueBallReceptions];\\n        for (int i = 0; i < totalPlayers; ++i)\\n        {\\n            if (!ballReceivedByPlayer[i])\\n            {\\n                circularGameLosers[index] = i + 1;//PlayerID for the results start from 1.\\n                ++index;\\n            }\\n        }\\n        return circularGameLosers;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C#",
                    "JavaScript"
                ],
                "code": "```\\npublic class Solution {\\n\\n    public int[] circularGameLosers(int totalPlayers, int steps) {\\n        boolean[] ballReceivedByPlayer = new boolean[totalPlayers];\\n        int uniqueBallReceptions = countUniqueBallReceptions(ballReceivedByPlayer, totalPlayers, steps);\\n        return extractLosersFromAllPlayers(ballReceivedByPlayer, totalPlayers, uniqueBallReceptions);\\n    }\\n\\n    private int countUniqueBallReceptions(boolean[] ballReceivedByPlayer, int totalPlayers, int steps) {\\n        int currentPlayer = 0;\\n        int uniqueBallReceptions = 1;\\n        ballReceivedByPlayer[currentPlayer] = true;\\n\\n        while (true) {\\n            int nextPlayer = (currentPlayer + uniqueBallReceptions * steps) % totalPlayers;\\n            if (ballReceivedByPlayer[nextPlayer]) {\\n                break;\\n            }\\n\\n            ++uniqueBallReceptions;\\n            currentPlayer = nextPlayer;\\n            ballReceivedByPlayer[nextPlayer] = true;\\n        }\\n        return uniqueBallReceptions;\\n    }\\n\\n    private int[] extractLosersFromAllPlayers(boolean[] ballReceivedByPlayer, int totalPlayers, int countUniqueBallReceptions) {\\n        int index = 0;\\n        int[] circularGameLosers = new int[totalPlayers - countUniqueBallReceptions];\\n        for (int i = 0; i < totalPlayers; ++i) {\\n            if (!ballReceivedByPlayer[i]) {\\n                circularGameLosers[index] = i + 1;//PlayerID for the results start from 1.\\n                ++index;\\n            }\\n        }\\n        return circularGameLosers;\\n    }\\n}\\n```\n```\\n/**\\n * @param {number} totalPlayers\\n * @param {number} steps\\n * @return {number[]}\\n */\\nvar circularGameLosers = function (totalPlayers, steps) {\\n    const ballReceivedByPlayer = new Array(totalPlayers).fill(false);\\n    let uniqueBallReceptions = countUniqueBallReceptions(ballReceivedByPlayer, totalPlayers, steps);\\n    return extractLosersFromAllPlayers(ballReceivedByPlayer, totalPlayers, uniqueBallReceptions);\\n};\\n\\n/**\\n * @param {boolean[]} ballReceivedByPlayer\\n * @param {number} totalPlayers\\n * @param {number} steps \\n * @return {number}\\n */\\nfunction countUniqueBallReceptions(ballReceivedByPlayer, totalPlayers, steps) {\\n    let currentPlayer = 0;\\n    let uniqueBallReceptions = 1;\\n    ballReceivedByPlayer[currentPlayer] = true;\\n\\n    while (true) {\\n        let nextPlayer = (currentPlayer + uniqueBallReceptions * steps) % totalPlayers;\\n        if (ballReceivedByPlayer[nextPlayer]) {\\n            break;\\n        }\\n\\n        ++uniqueBallReceptions;\\n        currentPlayer = nextPlayer;\\n        ballReceivedByPlayer[nextPlayer] = true;\\n    }\\n    return uniqueBallReceptions;\\n}\\n\\n/**\\n * @param {boolean[]} ballReceivedByPlayer\\n * @param {number} totalPlayers\\n * @param {number} countUniqueBallReceptions \\n * @return {number[]}\\n */\\nfunction extractLosersFromAllPlayers(ballReceivedByPlayer, totalPlayers, countUniqueBallReceptions) {\\n    let index = 0;\\n    const circularGameLosers = new Array(totalPlayers - countUniqueBallReceptions);\\n    for (let i = 0; i < totalPlayers; ++i) {\\n        if (!ballReceivedByPlayer[i]) {\\n            circularGameLosers[index] = i + 1;//PlayerID for the results start from 1.\\n            ++index;\\n        }\\n    }\\n    return circularGameLosers;\\n}\\n```\n```\\n#include <vector>\\nusing namespace std;\\n\\nclass Solution {\\n    \\npublic:\\n    vector<int> circularGameLosers(int totalPlayers, int steps) const {\\n        vector<bool> ballReceivedByPlayer(totalPlayers);\\n        int uniqueBallReceptions = countUniqueBallReceptions(ballReceivedByPlayer, totalPlayers, steps);\\n        return extractLosersFromAllPlayers(ballReceivedByPlayer, totalPlayers, uniqueBallReceptions);\\n    }\\n\\nprivate:\\n    int countUniqueBallReceptions(vector<bool>& ballReceivedByPlayer, int totalPlayers, int steps) const {\\n        int currentPlayer = 0;\\n        int uniqueBallReceptions = 1;\\n        ballReceivedByPlayer[currentPlayer] = true;\\n\\n        while (true) {\\n            int nextPlayer = (currentPlayer + uniqueBallReceptions * steps) % totalPlayers;\\n            if (ballReceivedByPlayer[nextPlayer]) {\\n                break;\\n            }\\n\\n            ++uniqueBallReceptions;\\n            currentPlayer = nextPlayer;\\n            ballReceivedByPlayer[nextPlayer] = true;\\n        }\\n        return uniqueBallReceptions;\\n    }\\n\\n    vector<int> extractLosersFromAllPlayers(const vector<bool>& ballReceivedByPlayer, int totalPlayers, int countUniqueBallReceptions) const {\\n        int index = 0;\\n        vector<int> circularGameLosers(totalPlayers - countUniqueBallReceptions);\\n        for (int i = 0; i < totalPlayers; ++i) {\\n            if (!ballReceivedByPlayer[i]) {\\n                circularGameLosers[index] = i + 1; //PlayerID for the results start from 1.\\n                ++index;\\n            }\\n        }\\n        return circularGameLosers;\\n    }\\n};\\n```\n```\\nusing System;\\n\\npublic class Solution\\n{\\n    public int[] CircularGameLosers(int totalPlayers, int steps)\\n    {\\n        bool[] ballReceivedByPlayer = new bool[totalPlayers];\\n        int uniqueBallReceptions = countUniqueBallReceptions(ballReceivedByPlayer, totalPlayers, steps);\\n        return extractLosersFromAllPlayers(ballReceivedByPlayer, totalPlayers, uniqueBallReceptions);\\n    }\\n\\n    private int countUniqueBallReceptions(bool[] ballReceivedByPlayer, int totalPlayers, int steps)\\n    {\\n        int currentPlayer = 0;\\n        int uniqueBallReceptions = 1;\\n        ballReceivedByPlayer[currentPlayer] = true;\\n\\n        while (true)\\n        {\\n            int nextPlayer = (currentPlayer + uniqueBallReceptions * steps) % totalPlayers;\\n            if (ballReceivedByPlayer[nextPlayer])\\n            {\\n                break;\\n            }\\n\\n            ++uniqueBallReceptions;\\n            currentPlayer = nextPlayer;\\n            ballReceivedByPlayer[nextPlayer] = true;\\n        }\\n        return uniqueBallReceptions;\\n    }\\n\\n    private int[] extractLosersFromAllPlayers(bool[] ballReceivedByPlayer, int totalPlayers, int countUniqueBallReceptions)\\n    {\\n        int index = 0;\\n        int[] circularGameLosers = new int[totalPlayers - countUniqueBallReceptions];\\n        for (int i = 0; i < totalPlayers; ++i)\\n        {\\n            if (!ballReceivedByPlayer[i])\\n            {\\n                circularGameLosers[index] = i + 1;//PlayerID for the results start from 1.\\n                ++index;\\n            }\\n        }\\n        return circularGameLosers;\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3558433,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func circularGameLosers(_ n: Int, _ k: Int) -> [Int] {\\n        \\n        var win = Array(repeating: false, count: n)\\n        var i = 0\\n        var j = 1\\n\\n        while !win[i] {\\n            win[i] = true\\n            i = (i + k * j) % n\\n            j += 1\\n        }\\n\\n        return win\\n            .indices\\n            .filter { !win[$0] }\\n            .map { $0 + 1 }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func circularGameLosers(_ n: Int, _ k: Int) -> [Int] {\\n        \\n        var win = Array(repeating: false, count: n)\\n        var i = 0\\n        var j = 1\\n\\n        while !win[i] {\\n            win[i] = true\\n            i = (i + k * j) % n\\n            j += 1\\n        }\\n\\n        return win\\n            .indices\\n            .filter { !win[$0] }\\n            .map { $0 + 1 }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3557513,
                "title": "javascript-track-players-with-index-0-to-n-1-output-uses-index-i-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar circularGameLosers = function(n, k) {\\n    \\n    let visited = new Set()\\n    visited.add(0)\\n    let numK = 1\\n    let current = (0 + numK * k) % n\\n\\n    while (!visited.has(current)) {\\n        visited.add(current)\\n        numK+=1\\n        current = (current + numK * k) % n    \\n    }\\n    \\n    let output = []\\n    let visitedArr = [...visited]\\n    for (let i = 0; i < n; i++) {\\n        if (!visitedArr.includes(i)) output.push(i + 1) // need to push i + 1 because the seat starts from 1\\n    }\\n    \\n    return output\\n};\\n\\n\\n/*\\n# Rank 179,825\\n# Date 5/21/2023\\n# Runtime: 97 ms, faster than 39.02%\\n# Memory Usage: 44.4 MB, less than 92.33%  \\n=======test case ========\\n2\\n1\\n*/\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar circularGameLosers = function(n, k) {\\n    \\n    let visited = new Set()\\n    visited.add(0)\\n    let numK = 1\\n    let current = (0 + numK * k) % n\\n\\n    while (!visited.has(current)) {\\n        visited.add(current)\\n        numK+=1\\n        current = (current + numK * k) % n    \\n    }\\n    \\n    let output = []\\n    let visitedArr = [...visited]\\n    for (let i = 0; i < n; i++) {\\n        if (!visitedArr.includes(i)) output.push(i + 1) // need to push i + 1 because the seat starts from 1\\n    }\\n    \\n    return output\\n};\\n\\n\\n/*\\n# Rank 179,825\\n# Date 5/21/2023\\n# Runtime: 97 ms, faster than 39.02%\\n# Memory Usage: 44.4 MB, less than 92.33%  \\n=======test case ========\\n2\\n1\\n*/\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3556228,
                "title": "easy-solution-with-c-faster-than-82-29",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> player;\\n        vector<int> res;\\n        int i = 1;//first person\\n        int count = 1; //first time\\n        int final = 0;\\n        bool check = false;\\n        player.push_back(i);\\n        while(true){\\n            if(count*k + i <= n){\\n                auto idx = find(player.begin(), player.end(), count*k + i);\\n                if(idx!= player.end()) {\\n                    final = count*k + i;\\n                    check = true;\\n                    break;\\n                }\\n                else {\\n                    player.push_back(count*k + i);\\n                    i += count*k;\\n                    count++;\\n                }\\n            }\\n            else {\\n                int res = count*k - (n - i);\\n                int div = res % n == 0 ? n : (res %n );\\n                auto idx = find(player.begin(), player.end(), div);\\n                if(idx!= player.end()) {\\n                    final = div;\\n                    check = true;\\n                    break;\\n                } else {\\n                    player.push_back(div);\\n                    i = div;\\n                    count++;\\n                }\\n            }\\n        }\\n        if(check){\\n            for(int i = 1 ; i <= n; i++) {\\n                auto idx = find(player.begin(), player.end(), i);\\n                if(idx != player.end())\\n                    continue;\\n                else\\n                    res.push_back(i);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> player;\\n        vector<int> res;\\n        int i = 1;//first person\\n        int count = 1; //first time\\n        int final = 0;\\n        bool check = false;\\n        player.push_back(i);\\n        while(true){\\n            if(count*k + i <= n){\\n                auto idx = find(player.begin(), player.end(), count*k + i);\\n                if(idx!= player.end()) {\\n                    final = count*k + i;\\n                    check = true;\\n                    break;\\n                }\\n                else {\\n                    player.push_back(count*k + i);\\n                    i += count*k;\\n                    count++;\\n                }\\n            }\\n            else {\\n                int res = count*k - (n - i);\\n                int div = res % n == 0 ? n : (res %n );\\n                auto idx = find(player.begin(), player.end(), div);\\n                if(idx!= player.end()) {\\n                    final = div;\\n                    check = true;\\n                    break;\\n                } else {\\n                    player.push_back(div);\\n                    i = div;\\n                    count++;\\n                }\\n            }\\n        }\\n        if(check){\\n            for(int i = 1 ; i <= n; i++) {\\n                auto idx = find(player.begin(), player.end(), i);\\n                if(idx != player.end())\\n                    continue;\\n                else\\n                    res.push_back(i);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3556199,
                "title": "super-simple-bruteforce-with-no-data-structures-used",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n       int a[]=new int[n];\\n       int i=0;\\n       for(i=0;i<n;i++)\\n       a[i]=i;\\n       i=0; \\n       int m=1,x=1,y=0,b=0;\\n       a[0]=0;\\n       while(b!=1){\\n          x=m*k+y;\\n          m++;\\n          while(x>=n){\\n              \\n              x=x-n;\\n          }\\n          if(a[x]==0)\\n          b=1;\\n          a[x]=0;\\n          y=x;\\n       }\\n       a[y]=0;\\n       int c=0;\\n       for(int j=0;j<n;j++)\\n       { \\n           a[j]=a[j]+1;\\n           if(a[j]==1)\\n           c++;\\n       }\\n       c=n-c;\\n       int f[]=new int[c];\\n       int d=0;\\n       for(int j=0;j<n;j++){\\n           if(a[j]!=1){ \\n          f[d]=a[j];\\n          d++;}\\n       }\\n      return f;\\n       \\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n       int a[]=new int[n];\\n       int i=0;\\n       for(i=0;i<n;i++)\\n       a[i]=i;\\n       i=0; \\n       int m=1,x=1,y=0,b=0;\\n       a[0]=0;\\n       while(b!=1){\\n          x=m*k+y;\\n          m++;\\n          while(x>=n){\\n              \\n              x=x-n;\\n          }\\n          if(a[x]==0)\\n          b=1;\\n          a[x]=0;\\n          y=x;\\n       }\\n       a[y]=0;\\n       int c=0;\\n       for(int j=0;j<n;j++)\\n       { \\n           a[j]=a[j]+1;\\n           if(a[j]==1)\\n           c++;\\n       }\\n       c=n-c;\\n       int f[]=new int[c];\\n       int d=0;\\n       for(int j=0;j<n;j++){\\n           if(a[j]!=1){ \\n          f[d]=a[j];\\n          d++;}\\n       }\\n      return f;\\n       \\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553283,
                "title": "brute-force-but-eazy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) \\n\\t{\\n        //we can create the boolean array for the players\\n        vector<bool>v;\\n        v.resize(n,false);   //intially none of the player got the ball in the hand\\n        int ptr = 0;\\n        v[ptr] = true;\\n        \\n        int offset = 1;  //for offset trun --> (offset * k)\\n        while(true)    //now the game begins \\n        {\\n        \\tint dis = offset * k;\\n        \\twhile(dis > 0)\\n        \\t{\\n        \\t\\tif(ptr == (v.size()-1))\\n        \\t\\t{\\n        \\t\\t\\tptr = 0;\\n        \\t\\t\\tdis--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse \\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tptr++;\\n\\t\\t\\t\\t\\tdis--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(v[ptr] == true)   //if the current cell is already true\\n\\t\\t\\t{\\n\\t\\t\\t\\tvector<int>ans;\\n\\t\\t\\t\\tfor(int i=0;i<v.size();i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(v[i] == false)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tans.push_back(i+1);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\t\\t\\tv[ptr] = true;\\n\\t\\t\\toffset++;\\n\\t\\t}\\n\\t\\treturn {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) \\n\\t{\\n        //we can create the boolean array for the players\\n        vector<bool>v;\\n        v.resize(n,false);   //intially none of the player got the ball in the hand\\n        int ptr = 0;\\n        v[ptr] = true;\\n        \\n        int offset = 1;  //for offset trun --> (offset * k)\\n        while(true)    //now the game begins \\n        {\\n        \\tint dis = offset * k;\\n        \\twhile(dis > 0)\\n        \\t{\\n        \\t\\tif(ptr == (v.size()-1))\\n        \\t\\t{\\n        \\t\\t\\tptr = 0;\\n        \\t\\t\\tdis--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse \\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tptr++;\\n\\t\\t\\t\\t\\tdis--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(v[ptr] == true)   //if the current cell is already true\\n\\t\\t\\t{\\n\\t\\t\\t\\tvector<int>ans;\\n\\t\\t\\t\\tfor(int i=0;i<v.size();i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(v[i] == false)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tans.push_back(i+1);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\t\\t\\tv[ptr] = true;\\n\\t\\t\\toffset++;\\n\\t\\t}\\n\\t\\treturn {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549778,
                "title": "find-the-losers-of-the-circular-game-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> num(n+1,1);\\n        num[1]=0;\\n        int x=1;\\n        int i=1;\\n        int y=x+(i*k);\\n        if(y>n)\\n        {\\n            y=y%n;\\n            if(y==0)\\n            {\\n                y=n;\\n            }\\n        }\\n        while(num[y]!=0)\\n        {\\n            num[y]=0;\\n            i++;\\n            x=y;\\n            y=x+(i*k);\\n            if(y>n)\\n            {\\n                y=y%n;\\n                if(y==0)\\n                {\\n                    y=n;\\n                }\\n            }\\n        }\\n        vector<int> ans;\\n        for(int i=1;i<n+1;i++)\\n        {\\n            if(num[i]==1)\\n            {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Hash Table",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> num(n+1,1);\\n        num[1]=0;\\n        int x=1;\\n        int i=1;\\n        int y=x+(i*k);\\n        if(y>n)\\n        {\\n            y=y%n;\\n            if(y==0)\\n            {\\n                y=n;\\n            }\\n        }\\n        while(num[y]!=0)\\n        {\\n            num[y]=0;\\n            i++;\\n            x=y;\\n            y=x+(i*k);\\n            if(y>n)\\n            {\\n                y=y%n;\\n                if(y==0)\\n                {\\n                    y=n;\\n                }\\n            }\\n        }\\n        vector<int> ans;\\n        for(int i=1;i<n+1;i++)\\n        {\\n            if(num[i]==1)\\n            {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546426,
                "title": "java-solution-set-based-approach",
                "content": "# Intuition\\nSet based approach where keep track of the players who are receiving the balls.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Keep all the players added in a set.\\n2. Also maintain another set who receive the balls starting with the first player.\\n3. Finally find the difference between these 2 sets.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        \\n        Set<Integer> players = new HashSet<>();\\n        Set<Integer> receivers = new HashSet<>();\\n        int nextPlayer = 1;\\n        int count = 2;\\n        int [] loosers = null;\\n        int originalSteps = k;\\n        for(int i=1; i<=n; i++)\\n        {\\n            players.add(i);\\n        }\\n        boolean added = receivers.add(nextPlayer);\\n        while(added)\\n        {\\n            nextPlayer += k;\\n            while(nextPlayer > n)\\n            {\\n                nextPlayer = nextPlayer - n;\\n            }\\n            k = originalSteps * count;\\n            count++;\\n            added = receivers.add(nextPlayer);\\n        } \\n        players.removeAll(receivers);\\n        loosers = new int[players.size()];\\n        count = 0;\\n        for(int i : players)\\n        {\\n            loosers[count++] = i;\\n        }\\n        return loosers;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        \\n        Set<Integer> players = new HashSet<>();\\n        Set<Integer> receivers = new HashSet<>();\\n        int nextPlayer = 1;\\n        int count = 2;\\n        int [] loosers = null;\\n        int originalSteps = k;\\n        for(int i=1; i<=n; i++)\\n        {\\n            players.add(i);\\n        }\\n        boolean added = receivers.add(nextPlayer);\\n        while(added)\\n        {\\n            nextPlayer += k;\\n            while(nextPlayer > n)\\n            {\\n                nextPlayer = nextPlayer - n;\\n            }\\n            k = originalSteps * count;\\n            count++;\\n            added = receivers.add(nextPlayer);\\n        } \\n        players.removeAll(receivers);\\n        loosers = new int[players.size()];\\n        count = 0;\\n        for(int i : players)\\n        {\\n            loosers[count++] = i;\\n        }\\n        return loosers;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546388,
                "title": "c-set",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        unordered_set<int> s;\\n        vector<int> ans;\\n        int v = 0;\\n        int i = 1;\\n        while(!s.count(v+1)){\\n            s.insert(v+1);\\n            v = (v + i * k) % n;\\n            i++;\\n        }\\n        for(int i = 1 ; i <= n; i++) if(!s.count(i)) ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        unordered_set<int> s;\\n        vector<int> ans;\\n        int v = 0;\\n        int i = 1;\\n        while(!s.count(v+1)){\\n            s.insert(v+1);\\n            v = (v + i * k) % n;\\n            i++;\\n        }\\n        for(int i = 1 ; i <= n; i++) if(!s.count(i)) ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546225,
                "title": "good-problem-d",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        players=list(range(1,n+1))\\n        count={1:1}\\n        multiplier=k\\n        i=1\\n        new_player=1\\n        while multiplier>0:\\n            k=i*multiplier\\n            #print(\"In {} iteration, k is {}\".format(i,k))\\n            new_index=players.index(new_player)+k\\n            #print(\"Index incremental is {}\".format(new_index))\\n            if new_index>len(players)-1:\\n                new_index=new_index%len(players)\\n            #print(\"Final Index incremental is {}\".format(new_index))\\n            new_player=players[new_index]\\n            #print(\"Ball is now with {}\".format(new_player))\\n            \\n            if new_player in count:\\n                count[new_player]+=1\\n            else:\\n                count[new_player]=1\\n            #print(count)\\n            #print(\"\")\\n            if count[new_player]==2:\\n                break\\n            i+=1\\n        a=list(count.keys())\\n        b=list(set(players)-set(a))\\n        b.sort()\\n        return b\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        players=list(range(1,n+1))\\n        count={1:1}\\n        multiplier=k\\n        i=1\\n        new_player=1\\n        while multiplier>0:\\n            k=i*multiplier\\n            #print(\"In {} iteration, k is {}\".format(i,k))\\n            new_index=players.index(new_player)+k\\n            #print(\"Index incremental is {}\".format(new_index))\\n            if new_index>len(players)-1:\\n                new_index=new_index%len(players)\\n            #print(\"Final Index incremental is {}\".format(new_index))\\n            new_player=players[new_index]\\n            #print(\"Ball is now with {}\".format(new_player))\\n            \\n            if new_player in count:\\n                count[new_player]+=1\\n            else:\\n                count[new_player]=1\\n            #print(count)\\n            #print(\"\")\\n            if count[new_player]==2:\\n                break\\n            i+=1\\n        a=list(count.keys())\\n        b=list(set(players)-set(a))\\n        b.sort()\\n        return b\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545740,
                "title": "easy-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCreated an array of n+1 size to track visited players, initally 0 (not visited). \\nGame starts from position 1, so marking it as visited.\\nModulo for maintaning circular numbers. \\nIf curr is zero, it means current player is \\'nth\\' (tricky part!)\\nFinally returning the players who didn\\'t receive the ball.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n\\n        int vis[51] = {0}; vector<int> ans;\\n        vis[1] = 1; int curr = 1; int i=1;\\n\\n        while(true){\\n            curr = (curr+i*k)%n ;\\n            if(curr==0){\\n                curr = n; \\n            }\\n            if(vis[curr]){\\n                break;\\n            }\\n            vis[curr] = 1;\\n            i++;\\n        }\\n        for(int i=1; i<=n; i++){\\n            if(!vis[i]){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n\\n        int vis[51] = {0}; vector<int> ans;\\n        vis[1] = 1; int curr = 1; int i=1;\\n\\n        while(true){\\n            curr = (curr+i*k)%n ;\\n            if(curr==0){\\n                curr = n; \\n            }\\n            if(vis[curr]){\\n                break;\\n            }\\n            vis[curr] = 1;\\n            i++;\\n        }\\n        for(int i=1; i<=n; i++){\\n            if(!vis[i]){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545530,
                "title": "easy-array-runtime-3-ms-beats-57-87",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {        \\n        int c = 1, l = 1;\\n        boolean[] used = new boolean[n + 1];\\n        while(true){\\n            if(used[l]) break;\\n            used[l] = true;\\n            l += c * k;\\n            l %= n;\\n            if(l == 0) l = n;\\n            c++;\\n        }\\n        List< Integer > list = new ArrayList<>();\\n        for(int i = 1; i <= n; i++) if(!used[i]) list.add(i);\\n        int[] res = new int[list.size()];\\n        for(int i = 0; i < list.size(); i++) res[i] = list.get(i);\\n        return res;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {        \\n        int c = 1, l = 1;\\n        boolean[] used = new boolean[n + 1];\\n        while(true){\\n            if(used[l]) break;\\n            used[l] = true;\\n            l += c * k;\\n            l %= n;\\n            if(l == 0) l = n;\\n            c++;\\n        }\\n        List< Integer > list = new ArrayList<>();\\n        for(int i = 1; i <= n; i++) if(!used[i]) list.add(i);\\n        int[] res = new int[list.size()];\\n        for(int i = 0; i < list.size(); i++) res[i] = list.get(i);\\n        return res;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545246,
                "title": "python3-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        lis=[0]*n\\n        res=[]\\n        i=0\\n        j=1\\n        while(1):\\n            if lis[i]==1:\\n                break\\n            else:\\n                lis[i]=1\\n                i=(i+j*k)%n\\n                \\n                j+=1\\n        for i in range(n):\\n            if lis[i]==0:\\n                res.append(i+1)\\n        return res\\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        lis=[0]*n\\n        res=[]\\n        i=0\\n        j=1\\n        while(1):\\n            if lis[i]==1:\\n                break\\n            else:\\n                lis[i]=1\\n                i=(i+j*k)%n\\n                \\n                j+=1\\n        for i in range(n):\\n            if lis[i]==0:\\n                res.append(i+1)\\n        return res\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545064,
                "title": "brute-force-java-using-hasmap-crystal-clear",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n  public int[] circularGameLosers(int n, int k) {\\n      int currentPass = 1,currentPlayer = 0, j =0 ;\\n      Map<Integer,Integer> playerTurnHashmap = new HashMap<>();\\n      playerTurnHashmap.put(0,1);\\n      for (int i=1 ;i< n;i++) {\\n          playerTurnHashmap.put(i,0);\\n      }\\n      while (playerTurnHashmap.get(currentPlayer) <=1) {\\n         currentPlayer = (currentPlayer + (currentPass * k)) % n;\\n          playerTurnHashmap.put(currentPlayer,playerTurnHashmap.get(currentPlayer) + 1);\\n          currentPass ++ ;\\n      }\\n       int[] losersArray = new int[playerTurnHashmap.size()];\\n      \\n      for(Map.Entry<Integer,Integer> entry : playerTurnHashmap.entrySet()) {\\n          if (entry.getValue() == 0 ) {\\n              losersArray[j++] = entry.getKey() + 1;\\n          }\\n      } \\n    return  losersArray = Arrays.copyOfRange(losersArray, 0, j );\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n  public int[] circularGameLosers(int n, int k) {\\n      int currentPass = 1,currentPlayer = 0, j =0 ;\\n      Map<Integer,Integer> playerTurnHashmap = new HashMap<>();\\n      playerTurnHashmap.put(0,1);\\n      for (int i=1 ;i< n;i++) {\\n          playerTurnHashmap.put(i,0);\\n      }\\n      while (playerTurnHashmap.get(currentPlayer) <=1) {\\n         currentPlayer = (currentPlayer + (currentPass * k)) % n;\\n          playerTurnHashmap.put(currentPlayer,playerTurnHashmap.get(currentPlayer) + 1);\\n          currentPass ++ ;\\n      }\\n       int[] losersArray = new int[playerTurnHashmap.size()];\\n      \\n      for(Map.Entry<Integer,Integer> entry : playerTurnHashmap.entrySet()) {\\n          if (entry.getValue() == 0 ) {\\n              losersArray[j++] = entry.getKey() + 1;\\n          }\\n      } \\n    return  losersArray = Arrays.copyOfRange(losersArray, 0, j );\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544822,
                "title": "c-easy-and-readable-solution-less-than-87",
                "content": "![image.png](https://assets.leetcode.com/users/images/f4742bc2-a302-40de-983f-3229e1d07f0e_1684584515.91254.png)\\n\\n**Don\\'t hesitate to suggest or ask bellow about something that you don\\'t understand**\\n\\n```\\npublic class Solution {\\n    public int[] CircularGameLosers(int n, int k) {\\n        int current = 0;\\n        HashSet<int> visited = new() {current};\\n        int turn = 1;\\n        while (true)\\n        {\\n            current = (current + k * turn) % n;\\n            if (visited.Contains(current))\\n                break;\\n            visited.Add(current);\\n            turn++;\\n        }\\n        int[] losers = new int[n - visited.Count];\\n        int index = 0;\\n        for (int i = 0; i < n; i++)\\n            if (!visited.Contains(i))\\n            {\\n                losers[index] = i + 1;\\n                index++;\\n            }\\n        return losers;\\n    }\\n}\\n```\\n\\nIf you like it don\\'t forget to **upvote!**",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] CircularGameLosers(int n, int k) {\\n        int current = 0;\\n        HashSet<int> visited = new() {current};\\n        int turn = 1;\\n        while (true)\\n        {\\n            current = (current + k * turn) % n;\\n            if (visited.Contains(current))\\n                break;\\n            visited.Add(current);\\n            turn++;\\n        }\\n        int[] losers = new int[n - visited.Count];\\n        int index = 0;\\n        for (int i = 0; i < n; i++)\\n            if (!visited.Contains(i))\\n            {\\n                losers[index] = i + 1;\\n                index++;\\n            }\\n        return losers;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544775,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        List<Integer> visited = new ArrayList<>();\\n        int[] ans = new int[n];\\n        int friend = 1;\\n        for(int i = 1; i <= n && !visited.contains(friend); i++)\\n        {\\n            int steps = i * k;\\n            visited.add(friend);\\n            friend = (friend + steps)%n;\\n            if(friend == 0)\\n            {\\n                friend = n;\\n            }\\n        }\\n        int z = 0;\\n        for(int i = 1; i <= n; i++)\\n        {\\n            if(!visited.contains(i))\\n            {\\n                ans[z++] = i;\\n            }\\n        }\\n        return Arrays.copyOfRange(ans, 0, z);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        List<Integer> visited = new ArrayList<>();\\n        int[] ans = new int[n];\\n        int friend = 1;\\n        for(int i = 1; i <= n && !visited.contains(friend); i++)\\n        {\\n            int steps = i * k;\\n            visited.add(friend);\\n            friend = (friend + steps)%n;\\n            if(friend == 0)\\n            {\\n                friend = n;\\n            }\\n        }\\n        int z = 0;\\n        for(int i = 1; i <= n; i++)\\n        {\\n            if(!visited.contains(i))\\n            {\\n                ans[z++] = i;\\n            }\\n        }\\n        return Arrays.copyOfRange(ans, 0, z);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544323,
                "title": "anurag-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        boolean[] arr = new boolean[n];\\n        boolean ball = true;\\n        int start = 0;\\n        arr[start] = true;\\n        int turn = 1;\\n        while (ball){\\n            int step = turn*k;\\n            start = (start+step)%n;\\n            turn++;\\n            if (arr[start]){\\n                break;\\n            } else{\\n                arr[start] = true;\\n            }\\n        }\\n\\n        ArrayList<Integer> res = new ArrayList<Integer>();\\n        for(int i = 0; i < n; i++){\\n            if (!arr[i])\\n                res.add(i+1);\\n        }\\n\\n        int[] x = new int[res.size()];\\n        int index = 0;\\n        for (final Integer value: res) {\\n            x[index++] = value;\\n        }\\n\\n        return x;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        boolean[] arr = new boolean[n];\\n        boolean ball = true;\\n        int start = 0;\\n        arr[start] = true;\\n        int turn = 1;\\n        while (ball){\\n            int step = turn*k;\\n            start = (start+step)%n;\\n            turn++;\\n            if (arr[start]){\\n                break;\\n            } else{\\n                arr[start] = true;\\n            }\\n        }\\n\\n        ArrayList<Integer> res = new ArrayList<Integer>();\\n        for(int i = 0; i < n; i++){\\n            if (!arr[i])\\n                res.add(i+1);\\n        }\\n\\n        int[] x = new int[res.size()];\\n        int index = 0;\\n        for (final Integer value: res) {\\n            x[index++] = value;\\n        }\\n\\n        return x;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544262,
                "title": "java-simple-solution-using-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n      HashSet<Integer> set = new HashSet<>();\\n\\n        int i=0;\\n        int count=0;\\n    while(true)\\n        {\\n        \\n            i=i+k*count++;\\n            i=i%n;\\n         if(set.contains(i)) break;\\n         else set.add(i);\\n        \\n        }\\n     int[]  result = new int[n-set.size()];\\n     int j=0;\\n        for( i=0;i<n;i++)\\n        {\\n            if(!set.contains(i))\\n            {\\n               result[j++]=i+1;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n      HashSet<Integer> set = new HashSet<>();\\n\\n        int i=0;\\n        int count=0;\\n    while(true)\\n        {\\n        \\n            i=i+k*count++;\\n            i=i%n;\\n         if(set.contains(i)) break;\\n         else set.add(i);\\n        \\n        }\\n     int[]  result = new int[n-set.size()];\\n     int j=0;\\n        for( i=0;i<n;i++)\\n        {\\n            if(!set.contains(i))\\n            {\\n               result[j++]=i+1;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3543633,
                "title": "easy-c-solution-using-brute-force-approach-100-working-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe have to continue the game untill anyone gets the ball for the second time.\\nwe keep a visited array of size n+1 for tracking the same.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe move forward in the circular setup as give in the question.\\nhave to keep in check the modular addition as we might cross the end of the circle.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> v;\\n        vector<int> visited(n+1,0);\\n        int i = 1;\\n        int temp = 1;\\n        while(visited[i]!=1)\\n        {\\n            visited[i] = 1;\\n            i += (temp*k);\\n            i %= n;\\n            if(i==0)\\n            {\\n                i=n;\\n            }\\n            temp++;\\n        }\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            if(visited[i]==0)\\n            {\\n                v.push_back(i);\\n            }\\n        }\\n        \\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> v;\\n        vector<int> visited(n+1,0);\\n        int i = 1;\\n        int temp = 1;\\n        while(visited[i]!=1)\\n        {\\n            visited[i] = 1;\\n            i += (temp*k);\\n            i %= n;\\n            if(i==0)\\n            {\\n                i=n;\\n            }\\n            temp++;\\n        }\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            if(visited[i]==0)\\n            {\\n                v.push_back(i);\\n            }\\n        }\\n        \\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3542345,
                "title": "simple-c-solution-faster-than-94-5",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) \\n    {\\n        int i=1,value=1;\\n        vector<int> v(n+1),res;\\n        v[1]=1;\\n        while(1)\\n        {\\n            int a=((i*k)+value)%n;\\n            if(a==0)\\n            {\\n                v[n]++;\\n                if(v[n]>1) break;\\n            }\\n            else\\n            {\\n                v[a]++;\\n                if(v[a]>1) break;\\n            }\\n            i++;\\n            value=a;\\n        }\\n        for(int i=2;i<=n;i++)\\n        {\\n            if(v[i]==0) res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) \\n    {\\n        int i=1,value=1;\\n        vector<int> v(n+1),res;\\n        v[1]=1;\\n        while(1)\\n        {\\n            int a=((i*k)+value)%n;\\n            if(a==0)\\n            {\\n                v[n]++;\\n                if(v[n]>1) break;\\n            }\\n            else\\n            {\\n                v[a]++;\\n                if(v[a]>1) break;\\n            }\\n            i++;\\n            value=a;\\n        }\\n        for(int i=2;i<=n;i++)\\n        {\\n            if(v[i]==0) res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540181,
                "title": "python-solution",
                "content": "```Python\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        i = cur = 1\\n        nums = set(range(1, n + 1))\\n        while cur in nums:\\n            nums.remove(cur)\\n            cur = (k * i + cur) % n\\n            if cur == 0:\\n                cur = n\\n            i += 1\\n        return nums\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```Python\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        i = cur = 1\\n        nums = set(range(1, n + 1))\\n        while cur in nums:\\n            nums.remove(cur)\\n            cur = (k * i + cur) % n\\n            if cur == 0:\\n                cur = n\\n            i += 1\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3539837,
                "title": "simple-hashing-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n       \\n        vector<int> vec(n+1,0);\\n        int i=0;\\n        int j=1;\\n        while(vec[i]==0){\\n          \\n            vec[i]=1;\\n            i=(i+j*k)%n;\\n            j++;\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<n;++i){\\n            if(vec[i]==0)\\n                ans.push_back(i+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n       \\n        vector<int> vec(n+1,0);\\n        int i=0;\\n        int j=1;\\n        while(vec[i]==0){\\n          \\n            vec[i]=1;\\n            i=(i+j*k)%n;\\n            j++;\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<n;++i){\\n            if(vec[i]==0)\\n                ans.push_back(i+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3539621,
                "title": "c-visited-array-solution-89ms-97",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int[] CircularGameLosers(int n, int k) \\n    {\\n        var visited = new bool[n];\\n\\n        var current = 0;\\n\\n        var step = 1;\\n\\n        do\\n        {\\n            visited[current] = true;\\n\\n            current = (current + step * k) % n;\\n\\n            step++;\\n        }\\n        while(!visited[current]);\\n\\n        var r = new List<int>(n);\\n\\n        for(var i=0; i<n; i++)\\n        {\\n            if(!visited[i]) r.Add(i+1);\\n        }\\n\\n        return r.ToArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] CircularGameLosers(int n, int k) \\n    {\\n        var visited = new bool[n];\\n\\n        var current = 0;\\n\\n        var step = 1;\\n\\n        do\\n        {\\n            visited[current] = true;\\n\\n            current = (current + step * k) % n;\\n\\n            step++;\\n        }\\n        while(!visited[current]);\\n\\n        var r = new List<int>(n);\\n\\n        for(var i=0; i<n; i++)\\n        {\\n            if(!visited[i]) r.Add(i+1);\\n        }\\n\\n        return r.ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3539443,
                "title": "c-easy-and-simple-solution",
                "content": "***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int>vis(n,0);\\n        int curr=0;\\n        int steps=1;\\n        int counter=1;\\n        vis[curr]=1;\\n\\n        steps=k*counter;\\n        curr=curr+steps;\\n        while(vis[curr%n]!=1){\\n            vis[curr%n]=1;\\n            counter++;\\n            steps=counter*k;\\n            curr=curr+steps;\\n            \\n\\n        }        \\n    \\n    \\n    vector<int>ans;\\n    for(int i=0;i<n;i++){\\n        if(vis[i]==0){\\n            ans.push_back(i+1);\\n        }\\n    }\\n    \\n    return ans;\\n    }\\n};\\n// step=4 \\n// curr=4;\\n// k=2\\n// counter=2;\\n\\n```\\n***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int>vis(n,0);\\n        int curr=0;\\n        int steps=1;\\n        int counter=1;\\n        vis[curr]=1;\\n\\n        steps=k*counter;\\n        curr=curr+steps;\\n        while(vis[curr%n]!=1){\\n            vis[curr%n]=1;\\n            counter++;\\n            steps=counter*k;\\n            curr=curr+steps;\\n            \\n\\n        }        \\n    \\n    \\n    vector<int>ans;\\n    for(int i=0;i<n;i++){\\n        if(vis[i]==0){\\n            ans.push_back(i+1);\\n        }\\n    }\\n    \\n    return ans;\\n    }\\n};\\n// step=4 \\n// curr=4;\\n// k=2\\n// counter=2;\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538651,
                "title": "rust",
                "content": "```\\nimpl Solution {\\n    pub fn circular_game_losers(n: i32, k: i32) -> Vec<i32> {\\n        let k = k as usize;\\n        let n = n as usize;\\n        let mut step = k;\\n        \\n        let mut visited = vec![false; n];\\n        let mut i = 0;\\n        \\n        while visited[i] == false {\\n            visited[i] = true;\\n            i = (i + step) % n;\\n            step += k;\\n        }\\n        \\n        visited\\n         .into_iter()\\n         .enumerate()\\n         .filter(|&(i, x)| x == false)\\n         .map(|(i, x)| i as i32 + 1)\\n         .collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn circular_game_losers(n: i32, k: i32) -> Vec<i32> {\\n        let k = k as usize;\\n        let n = n as usize;\\n        let mut step = k;\\n        \\n        let mut visited = vec![false; n];\\n        let mut i = 0;\\n        \\n        while visited[i] == false {\\n            visited[i] = true;\\n            i = (i + step) % n;\\n            step += k;\\n        }\\n        \\n        visited\\n         .into_iter()\\n         .enumerate()\\n         .filter(|&(i, x)| x == false)\\n         .map(|(i, x)| i as i32 + 1)\\n         .collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3538170,
                "title": "java-simple-solution-boolean-array-marker-100-faster",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int[] circularGameLosers(int n, int k) {\\n        boolean[] players = new boolean[n];\\n        int turn = 1;\\n        int index = 0;\\n        while (!players[index]) {\\n            players[index] = true;\\n            index = (index + turn * k) % n;            \\n            turn++;\\n        }\\n\\n        int losersIndex = 0;\\n        int[] losers = new int[n - turn + 1];\\n        for (int i = 0; i < n; i++) {\\n            if (!players[i]) {\\n                losers[losersIndex++] = i + 1;\\n            }\\n        }\\n\\n        return losers;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int[] circularGameLosers(int n, int k) {\\n        boolean[] players = new boolean[n];\\n        int turn = 1;\\n        int index = 0;\\n        while (!players[index]) {\\n            players[index] = true;\\n            index = (index + turn * k) % n;            \\n            turn++;\\n        }\\n\\n        int losersIndex = 0;\\n        int[] losers = new int[n - turn + 1];\\n        for (int i = 0; i < n; i++) {\\n            if (!players[i]) {\\n                losers[losersIndex++] = i + 1;\\n            }\\n        }\\n\\n        return losers;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3537581,
                "title": "c-easy-to-understand-commented-and-explained",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        // vector to store the no of times ith element occurs\\n        vector<int> v(n, 0);\\n        //result vector\\n        vector<int> res;\\n        int temp = k;\\n        //Current value for the increment offset\\n        int i=1;\\n        //base case i.e, first chance is always of the first person\\n        v[0]++;\\n        //variable that stores which is the current person that have the ball\\n        int currPerson = 0;\\n\\n        //infinte loop that will break when a person reaceaves the ball for the second time\\n        while(1){\\n            int offset = i*k;\\n            //% is done so that we can maintian our calculations for circular loop\\n            currPerson = (currPerson + offset)%n;\\n            v[currPerson]++;\\n            if(v[currPerson]>=2)break;\\n            \\n            i++;\\n        }\\n        // loop to check if the ith person did not receive the ball even a single time\\n        for(int i=0; i<n; i++){\\n            if(v[i]==0){\\n                res.push_back(i+1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        // vector to store the no of times ith element occurs\\n        vector<int> v(n, 0);\\n        //result vector\\n        vector<int> res;\\n        int temp = k;\\n        //Current value for the increment offset\\n        int i=1;\\n        //base case i.e, first chance is always of the first person\\n        v[0]++;\\n        //variable that stores which is the current person that have the ball\\n        int currPerson = 0;\\n\\n        //infinte loop that will break when a person reaceaves the ball for the second time\\n        while(1){\\n            int offset = i*k;\\n            //% is done so that we can maintian our calculations for circular loop\\n            currPerson = (currPerson + offset)%n;\\n            v[currPerson]++;\\n            if(v[currPerson]>=2)break;\\n            \\n            i++;\\n        }\\n        // loop to check if the ith person did not receive the ball even a single time\\n        for(int i=0; i<n; i++){\\n            if(v[i]==0){\\n                res.push_back(i+1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535952,
                "title": "day-45-60",
                "content": "# Code\\n```\\nclass Solution\\n{\\npublic:\\n    std::vector<int> circularGameLosers(int n, int k)\\n    {\\n        std::vector<int> check(n + 1, 0), ans;\\n        int i = 1, steps = 1;\\n        while (true && check[i] != 2)\\n        {\\n            check[i]++;\\n            if(check[i]==2)\\n            {\\n                break;\\n            }\\n            i += (steps * k);\\n            i%=n;\\n            if(i==0)\\n            {\\n                i = n;\\n            }\\n            steps++;\\n        }\\n        i = 1;\\n        while (i < check.size())\\n        {\\n            if (check[i] == 0)\\n            {\\n                ans.push_back(i);\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    std::vector<int> circularGameLosers(int n, int k)\\n    {\\n        std::vector<int> check(n + 1, 0), ans;\\n        int i = 1, steps = 1;\\n        while (true && check[i] != 2)\\n        {\\n            check[i]++;\\n            if(check[i]==2)\\n            {\\n                break;\\n            }\\n            i += (steps * k);\\n            i%=n;\\n            if(i==0)\\n            {\\n                i = n;\\n            }\\n            steps++;\\n        }\\n        i = 1;\\n        while (i < check.size())\\n        {\\n            if (check[i] == 0)\\n            {\\n                ans.push_back(i);\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535912,
                "title": "c-4-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> friends(n);\\n        int pass = 0, step = 0;\\n        while(!friends[pass]) {\\n            friends[pass] = 1;\\n            pass += step += k;\\n            pass %= n;\\n        }\\n\\n        vector<int> answer;\\n        for(size_t i = 0; i < friends.size(); ++i)\\n            if(!friends[i]) answer.push_back(i+1);\\n\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> friends(n);\\n        int pass = 0, step = 0;\\n        while(!friends[pass]) {\\n            friends[pass] = 1;\\n            pass += step += k;\\n            pass %= n;\\n        }\\n\\n        vector<int> answer;\\n        for(size_t i = 0; i < friends.size(); ++i)\\n            if(!friends[i]) answer.push_back(i+1);\\n\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535892,
                "title": "elixir-my-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 363ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 62.9MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndefmodule Solution do\\n  @spec circular_game_losers(n :: integer, k :: integer) :: [integer]\\n  def circular_game_losers(n, k) do\\n    check = create_check_map(n, k, 1, 0, %{})\\n    Enum.reduce(1..n-1, [], fn i, ans ->\\n      cond do\\n        Map.get(check, i) == true ->\\n          ans\\n        i + 1 <= n ->\\n          [i + 1 | ans]\\n        true ->\\n          ans\\n      end\\n    end) |> Enum.reverse()\\n  end\\n\\n  @spec create_check_map(n :: integer, k :: integer, i :: integer, pre :: integer, check :: %{}) :: %{}\\n  def create_check_map(n, k, i, pre, check) do\\n    if Map.get(check, pre) == true do\\n      check\\n    else\\n      create_check_map(n, k, i + 1, rem(i*k + pre, n), Map.put(check, pre, true))\\n    end\\n  end\\nend\\n\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec circular_game_losers(n :: integer, k :: integer) :: [integer]\\n  def circular_game_losers(n, k) do\\n    check = create_check_map(n, k, 1, 0, %{})\\n    Enum.reduce(1..n-1, [], fn i, ans ->\\n      cond do\\n        Map.get(check, i) == true ->\\n          ans\\n        i + 1 <= n ->\\n          [i + 1 | ans]\\n        true ->\\n          ans\\n      end\\n    end) |> Enum.reverse()\\n  end\\n\\n  @spec create_check_map(n :: integer, k :: integer, i :: integer, pre :: integer, check :: %{}) :: %{}\\n  def create_check_map(n, k, i, pre, check) do\\n    if Map.get(check, pre) == true do\\n      check\\n    else\\n      create_check_map(n, k, i + 1, rem(i*k + pre, n), Map.put(check, pre, true))\\n    end\\n  end\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3535750,
                "title": "cpp-soln-using-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        set<int> s;\\n        \\n        for(int i=1;i<=n;i++) s.insert(i);\\n        int i=1,j=0;\\n        \\n        while(s.find(i)!=s.end()){\\n            s.erase(i);\\n            j=j+k;\\n            i=(i+j)%n;\\n            if(i == 0) i = n;\\n            \\n        }\\n        vector<int> v;\\n        for(auto &it:s) v.push_back(it);\\n        return v;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        set<int> s;\\n        \\n        for(int i=1;i<=n;i++) s.insert(i);\\n        int i=1,j=0;\\n        \\n        while(s.find(i)!=s.end()){\\n            s.erase(i);\\n            j=j+k;\\n            i=(i+j)%n;\\n            if(i == 0) i = n;\\n            \\n        }\\n        vector<int> v;\\n        for(auto &it:s) v.push_back(it);\\n        return v;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535252,
                "title": "java-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        int v[] = new int[n], i = 0, tot = n, step = 0;\\n        v[0] = 1;\\n        while(true){\\n          if( (i += (step += k)) >= n) i %= n;\\n          if( v[i] == 0) {--tot; v[i] = 1;}\\n          else break;\\n        }\\n        \\n        int ans[] = new int[tot-1], id = -1;\\n        for(int j = 0; j != n; ++j)\\n          if(v[j] == 0) ans[++id] = j+1;\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        int v[] = new int[n], i = 0, tot = n, step = 0;\\n        v[0] = 1;\\n        while(true){\\n          if( (i += (step += k)) >= n) i %= n;\\n          if( v[i] == 0) {--tot; v[i] = 1;}\\n          else break;\\n        }\\n        \\n        int ans[] = new int[tot-1], id = -1;\\n        for(int j = 0; j != n; ++j)\\n          if(v[j] == 0) ans[++id] = j+1;\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535212,
                "title": "favourable-easy-beginner-friendly-approach-can-get-it-just-by-seeing-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> store;\\n        map<int,int> data;\\n        for(int x=1;x<=n;x++)\\n        {\\n            store.push_back(x);\\n            data[x]++;\\n        }\\n        int i=0,c=0;\\n        while(data[store[i]]==1)\\n        {\\n            data[store[i]]++;\\n            c++;\\n            i=(i+(c*k))%n;\\n        }\\n        store.clear();\\n        for(auto x:data)\\n        {\\n            if(x.second==1)\\n            {\\n                store.push_back(x.first);\\n            }\\n        }\\n        return store;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> store;\\n        map<int,int> data;\\n        for(int x=1;x<=n;x++)\\n        {\\n            store.push_back(x);\\n            data[x]++;\\n        }\\n        int i=0,c=0;\\n        while(data[store[i]]==1)\\n        {\\n            data[store[i]]++;\\n            c++;\\n            i=(i+(c*k))%n;\\n        }\\n        store.clear();\\n        for(auto x:data)\\n        {\\n            if(x.second==1)\\n            {\\n                store.push_back(x.first);\\n            }\\n        }\\n        return store;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535054,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int>ans;\\n        unordered_set<int>st;\\n        int c=1;\\n        int i=1;\\n        while(true)\\n        {\\n            if(st.find(c)!=st.end())\\n            {\\n                break;\\n            }\\n            st.insert(c);\\n            c=(c+(i*k));\\n            if(c>n){\\n                if(c%n==0)\\n                {\\n                    c=n;\\n                }\\n                else\\n                {\\n                    c=c%n;\\n                }\\n            }\\n            i++;\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(st.find(i)==st.end())\\n            {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int>ans;\\n        unordered_set<int>st;\\n        int c=1;\\n        int i=1;\\n        while(true)\\n        {\\n            if(st.find(c)!=st.end())\\n            {\\n                break;\\n            }\\n            st.insert(c);\\n            c=(c+(i*k));\\n            if(c>n){\\n                if(c%n==0)\\n                {\\n                    c=n;\\n                }\\n                else\\n                {\\n                    c=c%n;\\n                }\\n            }\\n            i++;\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(st.find(i)==st.end())\\n            {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534706,
                "title": "java-sollution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        int arr[] = new int[n];\\n        Set<Integer> st = new HashSet<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            arr[i] = i+1;\\n            \\n        }\\n        \\n        boolean barr[] = new boolean[n];\\n        barr[0] = true;\\n        int index =0;\\n        int multiplier = 1;\\n\\n        while(!st.contains(index))\\n        {\\n            st.add(index);\\n            System.out.println((index+multiplier*k)%n);\\n            barr[(index+multiplier*k)%n] =true;\\n            index = (index+multiplier*k)%n;\\n            System.out.println(\"index\"+index);\\n            multiplier++;\\n            \\n           \\n        }\\n        \\n        ArrayList<Integer> ansList = new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(barr[i]==false)\\n            {\\n                ansList.add(i+1);\\n            }\\n        }\\n    \\n        return ansList.stream().mapToInt(Integer::valueOf).toArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        int arr[] = new int[n];\\n        Set<Integer> st = new HashSet<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            arr[i] = i+1;\\n            \\n        }\\n        \\n        boolean barr[] = new boolean[n];\\n        barr[0] = true;\\n        int index =0;\\n        int multiplier = 1;\\n\\n        while(!st.contains(index))\\n        {\\n            st.add(index);\\n            System.out.println((index+multiplier*k)%n);\\n            barr[(index+multiplier*k)%n] =true;\\n            index = (index+multiplier*k)%n;\\n            System.out.println(\"index\"+index);\\n            multiplier++;\\n            \\n           \\n        }\\n        \\n        ArrayList<Integer> ansList = new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(barr[i]==false)\\n            {\\n                ansList.add(i+1);\\n            }\\n        }\\n    \\n        return ansList.stream().mapToInt(Integer::valueOf).toArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3533563,
                "title": "find-the-losers-of-the-circular-game-with-set",
                "content": "# Code\\n```\\n\\'use strict\\';\\n\\n/**\\n * @param {number} n\\n * @param {number} k\\n * @return {number[]}\\n */\\n\\nconst circularGameLosers = function(n, k) {\\n    const set = new Set([...Array(n)].map((el, i) => i + 1));\\n    let i = 1;\\n    let val = 1;\\n    while (set.has(val)) {\\n        set.delete(val);\\n        if ((val + i * k) % n === 0) {\\n            val = n;\\n        } else {\\n            val = (val + i * k) % n;\\n        }\\n        i++;\\n    }\\n    return [...set];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```\\n\\'use strict\\';\\n\\n/**\\n * @param {number} n\\n * @param {number} k\\n * @return {number[]}\\n */\\n\\nconst circularGameLosers = function(n, k) {\\n    const set = new Set([...Array(n)].map((el, i) => i + 1));\\n    let i = 1;\\n    let val = 1;\\n    while (set.has(val)) {\\n        set.delete(val);\\n        if ((val + i * k) % n === 0) {\\n            val = n;\\n        } else {\\n            val = (val + i * k) % n;\\n        }\\n        i++;\\n    }\\n    return [...set];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3533374,
                "title": "easy-c-solution-o-n-modular-approach",
                "content": "\\n# Approach\\n- Initiate a boolean vector of size \\'n\\' and all entries as false \\n- While iterating through the vector, if flag == true, break the loop\\n- else keep on marking the indexes as true\\n- update the current index as $$currIndex = (currIndex+i*k)%n$$\\n- whenever we encounter an index with flag == true, we exit the loop and call the gameOverNow() function which populates the answer array\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> gameOverNow( vector<bool> flagArray, int n){\\n        vector<int> loserArr;\\n        for(int i = 0; i< n; i++){\\n            if(flagArray[i]==false)loserArr.push_back(i+1);\\n        }\\n        return loserArr;\\n    }\\n    \\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<bool> flagArray(n,false);\\n        int currIndex = 0;\\n        flagArray[currIndex] = true;\\n        int i = 1;\\n        while(true){\\n            currIndex = (currIndex+i*k)%n;\\n            if(flagArray[currIndex] == false){\\n                flagArray[currIndex] = true;\\n                i++;\\n            }\\n            else break;\\n        }\\n        return gameOverNow(flagArray, n);\\n    }\\n};\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> gameOverNow( vector<bool> flagArray, int n){\\n        vector<int> loserArr;\\n        for(int i = 0; i< n; i++){\\n            if(flagArray[i]==false)loserArr.push_back(i+1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3532818,
                "title": "c",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int[] CircularGameLosers(int n, int k) {\\n        var count = new int[n + 1];\\n        var list = new List<int>();\\n        var cur = 1;\\n        var steps = 1;\\n        count[cur]++;\\n        \\n        while(true){\\n            cur = cur + steps * k;\\n            while( cur > n)\\n                cur -= n;\\n            count[cur]++;\\n            if(count[cur] == 2)\\n                break; \\n            steps++;\\n        }\\n\\n        for(var i = 1; i < count.Length; i++){\\n            if(count[i] == 0)\\n                list.Add(i);\\n        }\\n\\n        return list.ToArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] CircularGameLosers(int n, int k) {\\n        var count = new int[n + 1];\\n        var list = new List<int>();\\n        var cur = 1;\\n        var steps = 1;\\n        count[cur]++;\\n        \\n        while(true){\\n            cur = cur + steps * k;\\n            while( cur > n)\\n                cur -= n;\\n            count[cur]++;\\n            if(count[cur] == 2)\\n                break; \\n            steps++;\\n        }\\n\\n        for(var i = 1; i < count.Length; i++){\\n            if(count[i] == 0)\\n                list.Add(i);\\n        }\\n\\n        return list.ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532618,
                "title": "c-simulation-with-hashset-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- `var set = new HashSet<int>();` Used to track visited players\\n- `x` - Multiplier, `k*x, k*(x+1)...`\\n- `curPlayer` Current player, use 0 indexed to `0...n-1`. Insted `1...N`, to correctly identify player position in circle. If `n=4`, players=[0,1,2]. correct `pos = (curPlayer)%4`\\n- `var res = new List<int>();` Store result, and finally put players with `index + 1`, because initial requirements by `1...n` players\\n\\n\\n# Complexity\\n- Time complexity: As players size is small up to `50`, In worst case think that every playes visits only ones:$$O(n)$$, where `n = 50`  \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$, where `n = players size`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] CircularGameLosers(int n, int k) {\\n        var set = new HashSet<int>();\\n        int x = 1, curPlayer = 0;\\n        var res = new List<int>();\\n\\n        while (!set.Contains(curPlayer)) {\\n            set.Add(curPlayer);\\n            curPlayer = (curPlayer + x * k) % n;\\n            x++;\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            if (!set.Contains(i)) res.Add(i + 1);\\n        }\\n\\n        return res.ToArray();\\n    }\\n}\\n\\n```\\n\\n# The same solution with Array\\n```\\npublic class Solution {\\n    public int[] CircularGameLosers(int n, int k) {\\n        var arr = new bool[n];\\n        int x = 1, curPlayer = 0;\\n        var res = new List<int>();\\n\\n        while (!arr[curPlayer]) {\\n            arr[curPlayer] = true;\\n            curPlayer = (curPlayer + x * k) % n;\\n            x++;\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            if (!arr[i]) res.Add(i + 1);\\n        }\\n\\n        return res.ToArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] CircularGameLosers(int n, int k) {\\n        var set = new HashSet<int>();\\n        int x = 1, curPlayer = 0;\\n        var res = new List<int>();\\n\\n        while (!set.Contains(curPlayer)) {\\n            set.Add(curPlayer);\\n            curPlayer = (curPlayer + x * k) % n;\\n            x++;\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            if (!set.Contains(i)) res.Add(i + 1);\\n        }\\n\\n        return res.ToArray();\\n    }\\n}\\n\\n```\n```\\npublic class Solution {\\n    public int[] CircularGameLosers(int n, int k) {\\n        var arr = new bool[n];\\n        int x = 1, curPlayer = 0;\\n        var res = new List<int>();\\n\\n        while (!arr[curPlayer]) {\\n            arr[curPlayer] = true;\\n            curPlayer = (curPlayer + x * k) % n;\\n            x++;\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            if (!arr[i]) res.Add(i + 1);\\n        }\\n\\n        return res.ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532547,
                "title": "98-beats-easy-to-understand-simplest-by-using-queue-data-structure",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsimple just push all the element from 2 to n and then push -1.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        queue<int>q;\\n        vector<int>v;\\n        for(int i=2;i<=n;i++)\\n        {\\n            q.push(i);\\n        }\\n        q.push(-1);\\n        /*while(!q.empty())\\n        {\\n            cout<<q.front()<<\" \";q.pop();\\n        }*/\\n        int a=1;\\n        while(1)\\n        {\\n           int k1=k*a-1;\\n           while(k1--)\\n           {\\n               int a=q.front();\\n              //cout<<a<<\" \";\\n               q.pop();q.push(a);\\n           }\\n         //  cout<<endl;\\n           if(q.front()==-1)\\n           {\\n               break;\\n           }\\n           else\\n           {\\n           cout<<q.front()<<\" \";\\n           q.pop();q.push(-1);\\n           a++;\\n           }\\n        }\\n        while(!q.empty())\\n        {   \\n            if(q.front()!=-1)\\n            {\\n            v.push_back(q.front());q.pop();\\n            }\\n            else\\n            {\\n            q.pop();\\n            }\\n        }\\n        sort(v.begin(),v.end());\\n        return v;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Queue",
                    "Game Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        queue<int>q;\\n        vector<int>v;\\n        for(int i=2;i<=n;i++)\\n        {\\n            q.push(i);\\n        }\\n        q.push(-1);\\n        /*while(!q.empty())\\n        {\\n            cout<<q.front()<<\" \";q.pop();\\n        }*/\\n        int a=1;\\n        while(1)\\n        {\\n           int k1=k*a-1;\\n           while(k1--)\\n           {\\n               int a=q.front();\\n              //cout<<a<<\" \";\\n               q.pop();q.push(a);\\n           }\\n         //  cout<<endl;\\n           if(q.front()==-1)\\n           {\\n               break;\\n           }\\n           else\\n           {\\n           cout<<q.front()<<\" \";\\n           q.pop();q.push(-1);\\n           a++;\\n           }\\n        }\\n        while(!q.empty())\\n        {   \\n            if(q.front()!=-1)\\n            {\\n            v.push_back(q.front());q.pop();\\n            }\\n            else\\n            {\\n            q.pop();\\n            }\\n        }\\n        sort(v.begin(),v.end());\\n        return v;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3532240,
                "title": "python-easy-solution-runtime-beats-94-56",
                "content": "# Code\\n```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        step = 1\\n        distance = k\\n        receive_list = [1]  # first receive friend\\n        nums = [num for num in range(1, n+1)]\\n        while nums[k % n] not in receive_list:\\n            receive_list.append(nums[k % n])\\n            step += 1\\n            k += step * distance \\n        return sorted(list(set(nums) - set(receive_list)))\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        step = 1\\n        distance = k\\n        receive_list = [1]  # first receive friend\\n        nums = [num for num in range(1, n+1)]\\n        while nums[k % n] not in receive_list:\\n            receive_list.append(nums[k % n])\\n            step += 1\\n            k += step * distance \\n        return sorted(list(set(nums) - set(receive_list)))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531681,
                "title": "swift-easy-to-understand-solution-using-array-and-while-loop",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    func circularGameLosers(_ n: Int, _ k: Int) -> [Int] {\\n        // Store if friend touched ball or not:\\n        // didTouchBall[i] means friend[i+1] has touched ball:\\n        var didTouchBall = Array(repeating: false, count: n)\\n\\n        var hasBallIndex = 0 // index for friend who has ball\\n        var passCount = 1 // times ball has been passed\\n\\n        // Repeat until one friend receives ball a second time:\\n        while didTouchBall[hasBallIndex] != true {\\n            didTouchBall[hasBallIndex] = true // Set friend at hasBallIndex in didTouchBall to true (touched ball)\\n            hasBallIndex = ((passCount * k) + hasBallIndex) % n  // pass ball to next friend using modulo n\\n            passCount += 1 // increment pass count\\n        }\\n\\n        // Loop finished, which means one friend has touch the ball twice:\\n        var result = [Int]()\\n\\n        // Iterate through didTouchBall and add any friend \\n        // who did not touch the ball (false) to result array.\\n        // Since we are iterating in ascending order, the result\\n        // array will be in ascending order:\\n        for index in 0..<didTouchBall.count {\\n            if !didTouchBall[index] {\\n                // Friend did not touch ball.\\n                // Add their index + 1 to result:\\n                result.append(index+1) // +1 because we started at zero\\n            }\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func circularGameLosers(_ n: Int, _ k: Int) -> [Int] {\\n        // Store if friend touched ball or not:\\n        // didTouchBall[i] means friend[i+1] has touched ball:\\n        var didTouchBall = Array(repeating: false, count: n)\\n\\n        var hasBallIndex = 0 // index for friend who has ball\\n        var passCount = 1 // times ball has been passed\\n\\n        // Repeat until one friend receives ball a second time:\\n        while didTouchBall[hasBallIndex] != true {\\n            didTouchBall[hasBallIndex] = true // Set friend at hasBallIndex in didTouchBall to true (touched ball)\\n            hasBallIndex = ((passCount * k) + hasBallIndex) % n  // pass ball to next friend using modulo n\\n            passCount += 1 // increment pass count\\n        }\\n\\n        // Loop finished, which means one friend has touch the ball twice:\\n        var result = [Int]()\\n\\n        // Iterate through didTouchBall and add any friend \\n        // who did not touch the ball (false) to result array.\\n        // Since we are iterating in ascending order, the result\\n        // array will be in ascending order:\\n        for index in 0..<didTouchBall.count {\\n            if !didTouchBall[index] {\\n                // Friend did not touch ball.\\n                // Add their index + 1 to result:\\n                result.append(index+1) // +1 because we started at zero\\n            }\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531410,
                "title": "mark-the-friends-if-its-their-turn-map-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> v,ans;\\n        unordered_map<int,int>m;\\n        for(int i=1; i<=n; i++) v.push_back(i);\\n        \\n        int x=1;\\n        int Friend = 0;\\n        \\n        while(1){\\n            m[Friend]++;\\n            cout<<v[Friend]<<endl;\\n            if(m[Friend] >= 2) break;\\n            Friend = ((x*k)+Friend)%n;\\n            x++;\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            if(m[i]==0) ans.push_back(v[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n        vector<int> v,ans;\\n        unordered_map<int,int>m;\\n        for(int i=1; i<=n; i++) v.push_back(i);\\n        \\n        int x=1;\\n        int Friend = 0;\\n        \\n        while(1){\\n            m[Friend]++;\\n            cout<<v[Friend]<<endl;\\n            if(m[Friend] >= 2) break;\\n            Friend = ((x*k)+Friend)%n;\\n            x++;\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            if(m[i]==0) ans.push_back(v[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3530920,
                "title": "a-few-solutions",
                "content": "Perform the simulation of `i`<sup>th</sup> friends, tracking `seen` values in an unordered set for O(1) lookups, then return the 1-based index of *not* seen values `i = 0..N-1` inclusive.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun circularGameLosers(N: Int, K: Int): IntArray {\\n        var (seen, i, step) = Triple(mutableSetOf<Int>(), 0, 0)\\n        while (!seen.contains(i)) {\\n            seen.add(i); step += K; i = (i + step) % N\\n        }\\n        return (0 until N).filter{ !seen.contains(it) }.map{ it + 1 }.toIntArray()\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet circularGameLosers = (N, K, seen = new Set(), i = 0, step = 0) => {\\n    while (!seen.has(i))\\n        seen.add(i), step += K, i = (i + step) % N;\\n    return _.range(0, N).filter(i => !seen.has(i)).map(i => i + 1);\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def circularGameLosers(self, N: int, K: int) -> List[int]:\\n        seen, i, step = set(), 0, 0\\n        while i not in seen:\\n            seen.add(i); step += K; i = (i + step) % N\\n        return [i + 1 for i in range(N) if i not in seen]\\n```\\n\\n*Rust*\\n```\\ntype VI = Vec<i32>;\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn circular_game_losers(N: i32, K: i32) -> VI {\\n        let (mut seen, mut i, mut step) = (HashSet::new(), 0, 0);\\n        while !seen.contains(&i) {\\n            seen.insert(i); step += K; i = (i + step) % N;\\n        }\\n        (0..N).filter(|i| !seen.contains(&i)).map(|i| i + 1).collect::<VI>()\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Set = unordered_set<int>;\\n    VI circularGameLosers(int N, int K, Set seen = Set(), int i = 0, int step = 0, VI losers = {}) {\\n        while (seen.insert(i).second)\\n            step += K, i = (i + step) % N;\\n        for (auto i{ 0 }; i < N; ++i)\\n            if (seen.find(i) == seen.end())\\n                losers.push_back(i + 1);\\n        return losers;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun circularGameLosers(N: Int, K: Int): IntArray {\\n        var (seen, i, step) = Triple(mutableSetOf<Int>(), 0, 0)\\n        while (!seen.contains(i)) {\\n            seen.add(i); step += K; i = (i + step) % N\\n        }\\n        return (0 until N).filter{ !seen.contains(it) }.map{ it + 1 }.toIntArray()\\n    }\\n}\\n```\n```\\nlet circularGameLosers = (N, K, seen = new Set(), i = 0, step = 0) => {\\n    while (!seen.has(i))\\n        seen.add(i), step += K, i = (i + step) % N;\\n    return _.range(0, N).filter(i => !seen.has(i)).map(i => i + 1);\\n};\\n```\n```\\nclass Solution:\\n    def circularGameLosers(self, N: int, K: int) -> List[int]:\\n        seen, i, step = set(), 0, 0\\n        while i not in seen:\\n            seen.add(i); step += K; i = (i + step) % N\\n        return [i + 1 for i in range(N) if i not in seen]\\n```\n```\\ntype VI = Vec<i32>;\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn circular_game_losers(N: i32, K: i32) -> VI {\\n        let (mut seen, mut i, mut step) = (HashSet::new(), 0, 0);\\n        while !seen.contains(&i) {\\n            seen.insert(i); step += K; i = (i + step) % N;\\n        }\\n        (0..N).filter(|i| !seen.contains(&i)).map(|i| i + 1).collect::<VI>()\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Set = unordered_set<int>;\\n    VI circularGameLosers(int N, int K, Set seen = Set(), int i = 0, int step = 0, VI losers = {}) {\\n        while (seen.insert(i).second)\\n            step += K, i = (i + step) % N;\\n        for (auto i{ 0 }; i < N; ++i)\\n            if (seen.find(i) == seen.end())\\n                losers.push_back(i + 1);\\n        return losers;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3530722,
                "title": "simple-iterative-hashset-and-arraylist-java-solution-no-recursion",
                "content": "```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        int i=1;\\n        int turn=1;\\n        HashSet<Integer> set = new HashSet();\\n        while(!set.contains(i) && i<=n){\\n            \\n            set.add(i);\\n            i=i+(k*turn);\\n            \\n            turn++;\\n            if(i>n){\\n                i=i%n;\\n                if(i==0){\\n                    i=n;\\n                }\\n            }\\n            \\n        }\\n       \\n        ArrayList<Integer> list = new ArrayList();\\n        for(int j=1;j<=n;j++){\\n            if(!set.contains(j)){\\n                list.add(j);\\n            }\\n        }\\n        int[] ans = new int[list.size()];\\n        for(int x=0;x<ans.length;x++){\\n            ans[x]=list.get(x);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int[] circularGameLosers(int n, int k) {\\n        int i=1;\\n        int turn=1;\\n        HashSet<Integer> set = new HashSet();\\n        while(!set.contains(i) && i<=n){\\n            \\n            set.add(i);\\n            i=i+(k*turn);\\n            \\n            turn++;\\n            if(i>n){\\n                i=i%n;\\n                if(i==0){\\n                    i=n;\\n                }\\n            }\\n            \\n        }\\n       \\n        ArrayList<Integer> list = new ArrayList();\\n        for(int j=1;j<=n;j++){\\n            if(!set.contains(j)){\\n                list.add(j);\\n            }\\n        }\\n        int[] ans = new int[list.size()];\\n        for(int x=0;x<ans.length;x++){\\n            ans[x]=list.get(x);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3530286,
                "title": "circulargamelosers-python-86-69-runtime-98-99-space",
                "content": "# Approach\\nWe can create an array with the friends, and simulate the game. \\n\\nEvery time a new player has the ball, we set its value to `-1`, as this player won\\'t lose the game.\\n\\nWe need to know which player receives the ball next by calculating `(ball + step) mod n`\\n\\nOnce a friend has had the ball twice (the current player value is `-1`), the game finishes.\\n\\nWe return the friends that still have their number.\\n\\n# Code\\n```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        friends = [i for i in range(n)]\\n\\n        ball = 0\\n        step = k\\n        while (friends[ball] != -1):\\n            friends[ball] = -1\\n            ball = (ball + step) % n\\n            step += k\\n\\n        res = []\\n        for f in friends:\\n            if f >= 0:\\n                res.append(f+1)\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Math",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\\n        friends = [i for i in range(n)]\\n\\n        ball = 0\\n        step = k\\n        while (friends[ball] != -1):\\n            friends[ball] = -1\\n            ball = (ball + step) % n\\n            step += k\\n\\n        res = []\\n        for f in friends:\\n            if f >= 0:\\n                res.append(f+1)\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529741,
                "title": "scala-set-and-recursion",
                "content": "\\n# Code\\n```\\nobject Solution {\\n  def circularGameLosers(n: Int, k: Int): Array[Int] = {\\n    def go(seen: Set[Int], i: Int, step: Int): Array[Int] = \\n      if (seen.contains(i)) (0 until n).filter(!seen.contains(_)).map(_ + 1).toArray\\n      else go(seen + i, (i + k * step) % n, step + 1)\\n\\n    go(Set.empty, 0, 1)\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def circularGameLosers(n: Int, k: Int): Array[Int] = {\\n    def go(seen: Set[Int], i: Int, step: Int): Array[Int] = \\n      if (seen.contains(i)) (0 until n).filter(!seen.contains(_)).map(_ + 1).toArray\\n      else go(seen + i, (i + k * step) % n, step + 1)\\n\\n    go(Set.empty, 0, 1)\\n  }\\n}\\n```",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 1893637,
                "content": [
                    {
                        "username": "HereComesTheMoon",
                        "content": "For an easy problem, this one is slightly tougher than you\\'d think. It could be an easy medium problem. You can do it!"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "An extremely twisted and complex description without any good reason."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "How....Howw...Howwwwwww it takes half hour to understood this problem but\\uD83D\\uDE2B\\uD83D\\uDE2B\\uD83D\\uDE2B"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "tips : \\n\\n- modulo\\n-think of a way to mark how many times a friend recieved the ball\\n-you should figure out the rest now"
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "boolean b[] = new boolean[n];\\n        \\n       \\n        int i=0;\\n        int turn = 1;\\n        while(b[i] != true){\\n            \\n            b[i] = true;\\n            i = (i+(turn)*k)%n;\\n            turn++;\\n            \\n        }\\n\\nwhat will be time complexity of this loop ?"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "O(N) in the worst case"
                    }
                ]
            },
            {
                "id": 2025836,
                "content": [
                    {
                        "username": "HereComesTheMoon",
                        "content": "For an easy problem, this one is slightly tougher than you\\'d think. It could be an easy medium problem. You can do it!"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "An extremely twisted and complex description without any good reason."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "How....Howw...Howwwwwww it takes half hour to understood this problem but\\uD83D\\uDE2B\\uD83D\\uDE2B\\uD83D\\uDE2B"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "tips : \\n\\n- modulo\\n-think of a way to mark how many times a friend recieved the ball\\n-you should figure out the rest now"
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "boolean b[] = new boolean[n];\\n        \\n       \\n        int i=0;\\n        int turn = 1;\\n        while(b[i] != true){\\n            \\n            b[i] = true;\\n            i = (i+(turn)*k)%n;\\n            turn++;\\n            \\n        }\\n\\nwhat will be time complexity of this loop ?"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "O(N) in the worst case"
                    }
                ]
            },
            {
                "id": 1893131,
                "content": [
                    {
                        "username": "HereComesTheMoon",
                        "content": "For an easy problem, this one is slightly tougher than you\\'d think. It could be an easy medium problem. You can do it!"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "An extremely twisted and complex description without any good reason."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "How....Howw...Howwwwwww it takes half hour to understood this problem but\\uD83D\\uDE2B\\uD83D\\uDE2B\\uD83D\\uDE2B"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "tips : \\n\\n- modulo\\n-think of a way to mark how many times a friend recieved the ball\\n-you should figure out the rest now"
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "boolean b[] = new boolean[n];\\n        \\n       \\n        int i=0;\\n        int turn = 1;\\n        while(b[i] != true){\\n            \\n            b[i] = true;\\n            i = (i+(turn)*k)%n;\\n            turn++;\\n            \\n        }\\n\\nwhat will be time complexity of this loop ?"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "O(N) in the worst case"
                    }
                ]
            },
            {
                "id": 1894724,
                "content": [
                    {
                        "username": "HereComesTheMoon",
                        "content": "For an easy problem, this one is slightly tougher than you\\'d think. It could be an easy medium problem. You can do it!"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "An extremely twisted and complex description without any good reason."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "How....Howw...Howwwwwww it takes half hour to understood this problem but\\uD83D\\uDE2B\\uD83D\\uDE2B\\uD83D\\uDE2B"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "tips : \\n\\n- modulo\\n-think of a way to mark how many times a friend recieved the ball\\n-you should figure out the rest now"
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "boolean b[] = new boolean[n];\\n        \\n       \\n        int i=0;\\n        int turn = 1;\\n        while(b[i] != true){\\n            \\n            b[i] = true;\\n            i = (i+(turn)*k)%n;\\n            turn++;\\n            \\n        }\\n\\nwhat will be time complexity of this loop ?"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "O(N) in the worst case"
                    }
                ]
            },
            {
                "id": 1894028,
                "content": [
                    {
                        "username": "HereComesTheMoon",
                        "content": "For an easy problem, this one is slightly tougher than you\\'d think. It could be an easy medium problem. You can do it!"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "An extremely twisted and complex description without any good reason."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "How....Howw...Howwwwwww it takes half hour to understood this problem but\\uD83D\\uDE2B\\uD83D\\uDE2B\\uD83D\\uDE2B"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "tips : \\n\\n- modulo\\n-think of a way to mark how many times a friend recieved the ball\\n-you should figure out the rest now"
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "boolean b[] = new boolean[n];\\n        \\n       \\n        int i=0;\\n        int turn = 1;\\n        while(b[i] != true){\\n            \\n            b[i] = true;\\n            i = (i+(turn)*k)%n;\\n            turn++;\\n            \\n        }\\n\\nwhat will be time complexity of this loop ?"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "O(N) in the worst case"
                    }
                ]
            }
        ]
    },
    {
        "title": "Modify Graph Edge Weights",
        "question_content": "<p>You are given an <strong>undirected weighted</strong> <strong>connected</strong> graph containing <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code>, and an integer array <code>edges</code> where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>, w<sub>i</sub>]</code> indicates that there is an edge between nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code> with weight <code>w<sub>i</sub></code>.</p>\n\n<p>Some edges have a weight of <code>-1</code> (<code>w<sub>i</sub> = -1</code>), while others have a <strong>positive</strong> weight (<code>w<sub>i</sub> &gt; 0</code>).</p>\n\n<p>Your task is to modify <strong>all edges</strong> with a weight of <code>-1</code> by assigning them <strong>positive integer values </strong>in the range <code>[1, 2 * 10<sup>9</sup>]</code> so that the <strong>shortest distance</strong> between the nodes <code>source</code> and <code>destination</code> becomes equal to an integer <code>target</code>. If there are <strong>multiple</strong> <strong>modifications</strong> that make the shortest distance between <code>source</code> and <code>destination</code> equal to <code>target</code>, any of them will be considered correct.</p>\n\n<p>Return <em>an array containing all edges (even unmodified ones) in any order if it is possible to make the shortest distance from </em><code>source</code><em> to </em><code>destination</code><em> equal to </em><code>target</code><em>, or an <strong>empty array</strong> if it&#39;s impossible.</em></p>\n\n<p><strong>Note:</strong> You are not allowed to modify the weights of edges with initial positive weights.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<p><strong class=\"example\"><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/04/18/graph.png\" style=\"width: 300px; height: 300px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> n = 5, edges = [[4,1,-1],[2,0,-1],[0,3,-1],[4,3,-1]], source = 0, destination = 1, target = 5\n<strong>Output:</strong> [[4,1,1],[2,0,1],[0,3,3],[4,3,1]]\n<strong>Explanation:</strong> The graph above shows a possible modification to the edges, making the distance from 0 to 1 equal to 5.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<p><strong class=\"example\"><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/04/18/graph-2.png\" style=\"width: 300px; height: 300px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> n = 3, edges = [[0,1,-1],[0,2,5]], source = 0, destination = 2, target = 6\n<strong>Output:</strong> []\n<strong>Explanation:</strong> The graph above contains the initial edges. It is not possible to make the distance from 0 to 2 equal to 6 by modifying the edge with weight -1. So, an empty array is returned.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<p><strong class=\"example\"><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2023/04/19/graph-3.png\" style=\"width: 300px; height: 300px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> n = 4, edges = [[1,0,4],[1,2,3],[2,3,5],[0,3,-1]], source = 0, destination = 2, target = 6\n<strong>Output:</strong> [[1,0,4],[1,2,3],[2,3,5],[0,3,1]]\n<strong>Explanation:</strong> The graph above shows a modified graph having the shortest distance from 0 to 2 as 6.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code><font face=\"monospace\">1 &lt;= edges.length &lt;= n * (n - 1) / 2</font></code></li>\n\t<li><code>edges[i].length == 3</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i&nbsp;</sub>&lt;&nbsp;n</code></li>\n\t<li><code><font face=\"monospace\">w<sub>i</sub>&nbsp;= -1&nbsp;</font></code>or <code><font face=\"monospace\">1 &lt;= w<sub>i&nbsp;</sub>&lt;= 10<sup><span style=\"font-size: 10.8333px;\">7</span></sup></font></code></li>\n\t<li><code>a<sub>i&nbsp;</sub>!=&nbsp;b<sub>i</sub></code></li>\n\t<li><code>0 &lt;= source, destination &lt; n</code></li>\n\t<li><code>source != destination</code></li>\n\t<li><code><font face=\"monospace\">1 &lt;= target &lt;= 10<sup>9</sup></font></code></li>\n\t<li>The graph is connected, and there are no self-loops or repeated edges</li>\n</ul>\n",
        "solutions": [
            {
                "id": 3546759,
                "title": "python3-dijkstra",
                "content": "Do a dijkstra from source treating mutable edges as w=1, and from destination treating mutable edges as w=inf.  Now walk from source in a shortest path towards destination.  We need the edge we are walking on to be at least `target - distR(v, inf) - walked` where `walked` is the distance we\\'ve walked so far.  If we create a heavy edge as a result (`edges[e] > 1`), then we\\'re already done as the `destination` is reachable.\\n\\n# Code\\n```\\nclass Solution:\\n    def modifiedGraphEdges(self, n: int, edges: List[List[int]], source: int, destination: int, target: int) -> List[List[int]]:\\n        adj = [[] for _ in range(n)]\\n        for u,v,w in edges:\\n            adj[u].append([v, w])\\n            adj[v].append([u, w])\\n        \\n        def dijkstra(source, adj, skip_negative):\\n            pq = [[0, source]]\\n            dist = defaultdict(lambda: inf)\\n            dist[source] = 0\\n            parent = {}\\n            while pq:\\n                d, node = heappop(pq)\\n                if d > dist[node]:\\n                    continue\\n                for nei, w in adj[node]:\\n                    if w == -1:\\n                        if skip_negative:\\n                            continue\\n                        w = 1\\n\\n                    d2 = d + w\\n                    if d2 < dist[nei]:\\n                        dist[nei] = d2\\n                        parent[nei] = node\\n                        heappush(pq, [d2, nei])\\n\\n            return dist, parent\\n        \\n        distR, parentR = dijkstra(destination, adj, skip_negative=True)\\n        if distR.get(source, inf) < target:\\n            return []\\n        dist, parent = dijkstra(source, adj, skip_negative=False)\\n        if dist[destination] > target:\\n            return []\\n        \\n        path = [destination]\\n        while path[-1] != source:\\n            path.append(parent[path[-1]])\\n        path = path[::-1]\\n        \\n        edges = {(min(u,v), max(u,v)) : w for u, v, w in edges}\\n        \\n        walked = 0\\n        for u, v in zip(path, path[1:]):\\n            e = (min(u, v), max(u, v))\\n            if edges[e] == -1:\\n                edges[e] = max(target - distR.get(v, inf) - walked, 1)\\n                if edges[e] > 1:\\n                    break\\n            walked += edges[e]\\n        \\n        for e, w in edges.items():\\n            if w == -1:\\n                edges[e] = 2 * (10 ** 9)\\n        \\n        return [[u,v,w] for (u,v), w in edges.items()]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def modifiedGraphEdges(self, n: int, edges: List[List[int]], source: int, destination: int, target: int) -> List[List[int]]:\\n        adj = [[] for _ in range(n)]\\n        for u,v,w in edges:\\n            adj[u].append([v, w])\\n            adj[v].append([u, w])\\n        \\n        def dijkstra(source, adj, skip_negative):\\n            pq = [[0, source]]\\n            dist = defaultdict(lambda: inf)\\n            dist[source] = 0\\n            parent = {}\\n            while pq:\\n                d, node = heappop(pq)\\n                if d > dist[node]:\\n                    continue\\n                for nei, w in adj[node]:\\n                    if w == -1:\\n                        if skip_negative:\\n                            continue\\n                        w = 1\\n\\n                    d2 = d + w\\n                    if d2 < dist[nei]:\\n                        dist[nei] = d2\\n                        parent[nei] = node\\n                        heappush(pq, [d2, nei])\\n\\n            return dist, parent\\n        \\n        distR, parentR = dijkstra(destination, adj, skip_negative=True)\\n        if distR.get(source, inf) < target:\\n            return []\\n        dist, parent = dijkstra(source, adj, skip_negative=False)\\n        if dist[destination] > target:\\n            return []\\n        \\n        path = [destination]\\n        while path[-1] != source:\\n            path.append(parent[path[-1]])\\n        path = path[::-1]\\n        \\n        edges = {(min(u,v), max(u,v)) : w for u, v, w in edges}\\n        \\n        walked = 0\\n        for u, v in zip(path, path[1:]):\\n            e = (min(u, v), max(u, v))\\n            if edges[e] == -1:\\n                edges[e] = max(target - distR.get(v, inf) - walked, 1)\\n                if edges[e] > 1:\\n                    break\\n            walked += edges[e]\\n        \\n        for e, w in edges.items():\\n            if w == -1:\\n                edges[e] = 2 * (10 ** 9)\\n        \\n        return [[u,v,w] for (u,v), w in edges.items()]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3548231,
                "title": "dijkstra-algorithm-approach-beats-80-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBased on the idea of finding the shortest path from the source node to the destination node in a weighted graph, where some edges have a weight of -1.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe Approach behind the code is as follows:\\n\\n1. We start by constructing an adjacency list representation of the graph. This allows us to easily access the neighbors of each node and their corresponding weights.\\n\\n2. We then use Dijkstra\\'s algorithm to find the shortest distance from the source node to all other nodes in the graph. The algorithm uses a priority queue to greedily select the node with the minimum distance at each step and updates the distances of its neighbors if a shorter path is found.\\n\\n3. After applying Dijkstra\\'s algorithm, we check if the distance from the source node to the destination node is less than the target distance. If it is, we know that it is impossible to reach the destination with the desired target distance. In this case, we return an empty array, indicating that no modifications can be made to achieve the target distance.\\n\\n4. If the distance to the destination node is exactly equal to the target distance, we modify all the -1 weighted edges in the graph by assigning them a large positive weight (2e9). This ensures that the shortest path remains the same, and we return the modified edges.\\n\\n. If the distance to the destination node is greater than the target distance, we iterate through all the edges in the graph. For each edge with a weight of -1, we temporarily modify its weight to 1 and update the adjacency list accordingly. We then reapply Dijkstra\\'s algorithm to find the new distances. If the distance to the destination node becomes less than or equal to the target distance, we adjust the weight of the modified edge by adding the difference between the target distance and the new distance. Finally, we change the weight of the remaining -1 edges to a large positive value (2e9) and return the modified edges.\\n\\n6. The code effectively uses Dijkstra\\'s algorithm and manipulates the graph by modifying the weights of the -1 edges to achieve the desired target distance. It handles various scenarios and checks for feasibility at each step.\\n\\n\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO((|V| + |E|) log |V|)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(max(|V|, |E|)).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>>dp[200];\\n    vector<int>find(int n,int src,int dist)\\n    {\\n        vector<int>dis(n+1,1e9+10);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        pq.push({0,src});\\n        dis[src]=0;\\n        vector<int>vis(n+10,0);\\n        while(pq.size())\\n        {\\n            auto [wt,node]=pq.top();\\n            pq.pop();\\n            if(vis[node])\\n            {\\n                continue;\\n            }\\n            vis[node]=1;\\n            for(auto &[current_node,current_wt]:dp[node])\\n            {\\n                if(dis[current_node]>current_wt+wt)\\n                {\\n                    dis[current_node]=current_wt+wt;\\n                    pq.push({dis[current_node],current_node});\\n                }\\n            }\\n        }\\n        return dis;\\n    }\\n    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int src, int dest, int target) \\n    {\\n        for(auto &it:edges)\\n        {\\n            if(it[2]==-1)\\n            {\\n                continue;\\n            }\\n            dp[it[0]].push_back({it[1],it[2]});\\n            dp[it[1]].push_back({it[0],it[2]});\\n        }\\n        vector<int>dist=find(n,src,dest);\\n        if(dist[dest]<target)\\n        {\\n            return {};\\n        }\\n       if(dist[dest]==target)\\n       {\\n           for(auto &it:edges)\\n           {\\n               if(it[2]==-1){\\n                   it[2]=2e9;\\n               }\\n           }\\n           return edges;\\n       }\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            int u=edges[i][0],v=edges[i][1],w=edges[i][2];\\n            if(w==-1)\\n            {\\n                edges[i][2]=1;\\n                dp[u].push_back({v,1});\\n                dp[v].push_back({u,1});\\n                vector<int>dis=find(n,src,dest);\\n                if(dis[dest]<=target)\\n                {\\n                    edges[i][2]+=(target-dis[dest]);\\n                    for(int j=i+1;j<edges.size();j++)\\n                    {\\n                        if(edges[j][2]==-1)\\n                        {\\n                            edges[j][2]=2e9;\\n                        }\\n                    }\\n                    return edges;\\n                }\\n            }\\n        }\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>>dp[200];\\n    vector<int>find(int n,int src,int dist)\\n    {\\n        vector<int>dis(n+1,1e9+10);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        pq.push({0,src});\\n        dis[src]=0;\\n        vector<int>vis(n+10,0);\\n        while(pq.size())\\n        {\\n            auto [wt,node]=pq.top();\\n            pq.pop();\\n            if(vis[node])\\n            {\\n                continue;\\n            }\\n            vis[node]=1;\\n            for(auto &[current_node,current_wt]:dp[node])\\n            {\\n                if(dis[current_node]>current_wt+wt)\\n                {\\n                    dis[current_node]=current_wt+wt;\\n                    pq.push({dis[current_node],current_node});\\n                }\\n            }\\n        }\\n        return dis;\\n    }\\n    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int src, int dest, int target) \\n    {\\n        for(auto &it:edges)\\n        {\\n            if(it[2]==-1)\\n            {\\n                continue;\\n            }\\n            dp[it[0]].push_back({it[1],it[2]});\\n            dp[it[1]].push_back({it[0],it[2]});\\n        }\\n        vector<int>dist=find(n,src,dest);\\n        if(dist[dest]<target)\\n        {\\n            return {};\\n        }\\n       if(dist[dest]==target)\\n       {\\n           for(auto &it:edges)\\n           {\\n               if(it[2]==-1){\\n                   it[2]=2e9;\\n               }\\n           }\\n           return edges;\\n       }\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            int u=edges[i][0],v=edges[i][1],w=edges[i][2];\\n            if(w==-1)\\n            {\\n                edges[i][2]=1;\\n                dp[u].push_back({v,1});\\n                dp[v].push_back({u,1});\\n                vector<int>dis=find(n,src,dest);\\n                if(dis[dest]<=target)\\n                {\\n                    edges[i][2]+=(target-dis[dest]);\\n                    for(int j=i+1;j<edges.size();j++)\\n                    {\\n                        if(edges[j][2]==-1)\\n                        {\\n                            edges[j][2]=2e9;\\n                        }\\n                    }\\n                    return edges;\\n                }\\n            }\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546829,
                "title": "c-solution",
                "content": "* First we ignore all -1 edges and run a single shortest path algorithm.\\n* If distance to destination < target, we can never achieve the same distance since we always have a shorter one.\\n* Add an new -1 edge one by one with weight as 1 and run shortest path algorithm. If at some point, the distance to destination < target, it means we can get to destination through this point with shorter distance. Just assign this point with value **target - dis[destination]**. And assign all other -1 edges as INF.\\n\\n```\\nusing ll = long long;\\n#define pb push_back\\n#define ve vector\\n#define FOR(i, a, b) for (int i = a; i < b; ++i)\\nusing namespace std;\\n\\nconst int N = 105;\\nconst int M = 1e5 + 10;\\nconst ll INF = 1000000000000000ll;\\n\\nvector<pair<int, int>> g[N];\\nll d[N];\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int s, int de, int target) {\\n        FOR(i, 0, n) {\\n            g[i].clear();\\n            d[i] = INF;\\n        }\\n        \\n        queue<int> q;\\n        FOR(i, 0, edges.size()) {\\n            auto& e = edges[i];\\n            if(e[2] == -1) {\\n                continue;\\n            }\\n            int u = e[0], v = e[1], w = e[2];\\n            g[u].pb({v, w});\\n            g[v].pb({u, w});\\n        }\\n        \\n        d[s] = 0;\\n        q.push(s);\\n        while(q.size()) {\\n            int u = q.front();\\n            q.pop();\\n            for(auto& p : g[u]) {\\n                int nxt = p.first, w = p.second;\\n                if(d[nxt] > d[u] + w) {\\n                    d[nxt] = d[u] + w;\\n                    q.push(nxt);\\n                }\\n            }\\n        }\\n        \\n        if(d[de] < target) {\\n            return {};\\n        }\\n        \\n        if(d[de] == target) {\\n            for(auto& e : edges) {\\n                if(e[2] == -1) e[2] = 1e9;\\n            }\\n            return edges;\\n        }\\n        \\n        FOR(i, 0, edges.size()) {\\n            auto& e = edges[i];\\n            int u = e[0], v = e[1], w = e[2];\\n            if(w == -1) {\\n                e[2] = 1;\\n                g[u].pb({v, 1});\\n                g[v].pb({u, 1});\\n                //run bfs\\n                while(q.size()) q.pop();\\n                FOR(i, 0, n) d[i] = INF;\\n                d[s] = 0;\\n                q.push(s);\\n                while(q.size()) {\\n                    int u = q.front();\\n                    q.pop();\\n                    for(auto& p : g[u]) {\\n                        int nxt = p.first, w = p.second;\\n                        if(d[nxt] > d[u] + w) {\\n                            d[nxt] = d[u] + w;\\n                            q.push(nxt);\\n                        }\\n                    }\\n                }\\n                \\n                if(d[de] <= target) {\\n                    e[2] += (target - d[de]);\\n                    FOR(j, i + 1, edges.size()) {\\n                        if(edges[j][2] == -1) {\\n                           edges[j][2] = 1e9; \\n                        }\\n                    }\\n                    return edges;\\n                }\\n            }\\n        }\\n        return {};\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nusing ll = long long;\\n#define pb push_back\\n#define ve vector\\n#define FOR(i, a, b) for (int i = a; i < b; ++i)\\nusing namespace std;\\n\\nconst int N = 105;\\nconst int M = 1e5 + 10;\\nconst ll INF = 1000000000000000ll;\\n\\nvector<pair<int, int>> g[N];\\nll d[N];\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int s, int de, int target) {\\n        FOR(i, 0, n) {\\n            g[i].clear();\\n            d[i] = INF;\\n        }\\n        \\n        queue<int> q;\\n        FOR(i, 0, edges.size()) {\\n            auto& e = edges[i];\\n            if(e[2] == -1) {\\n                continue;\\n            }\\n            int u = e[0], v = e[1], w = e[2];\\n            g[u].pb({v, w});\\n            g[v].pb({u, w});\\n        }\\n        \\n        d[s] = 0;\\n        q.push(s);\\n        while(q.size()) {\\n            int u = q.front();\\n            q.pop();\\n            for(auto& p : g[u]) {\\n                int nxt = p.first, w = p.second;\\n                if(d[nxt] > d[u] + w) {\\n                    d[nxt] = d[u] + w;\\n                    q.push(nxt);\\n                }\\n            }\\n        }\\n        \\n        if(d[de] < target) {\\n            return {};\\n        }\\n        \\n        if(d[de] == target) {\\n            for(auto& e : edges) {\\n                if(e[2] == -1) e[2] = 1e9;\\n            }\\n            return edges;\\n        }\\n        \\n        FOR(i, 0, edges.size()) {\\n            auto& e = edges[i];\\n            int u = e[0], v = e[1], w = e[2];\\n            if(w == -1) {\\n                e[2] = 1;\\n                g[u].pb({v, 1});\\n                g[v].pb({u, 1});\\n                //run bfs\\n                while(q.size()) q.pop();\\n                FOR(i, 0, n) d[i] = INF;\\n                d[s] = 0;\\n                q.push(s);\\n                while(q.size()) {\\n                    int u = q.front();\\n                    q.pop();\\n                    for(auto& p : g[u]) {\\n                        int nxt = p.first, w = p.second;\\n                        if(d[nxt] > d[u] + w) {\\n                            d[nxt] = d[u] + w;\\n                            q.push(nxt);\\n                        }\\n                    }\\n                }\\n                \\n                if(d[de] <= target) {\\n                    e[2] += (target - d[de]);\\n                    FOR(j, i + 1, edges.size()) {\\n                        if(edges[j][2] == -1) {\\n                           edges[j][2] = 1e9; \\n                        }\\n                    }\\n                    return edges;\\n                }\\n            }\\n        }\\n        return {};\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546824,
                "title": "binary-search-spfa",
                "content": "# Intuition\\nBinary search the number of undefined edges, give them weight = 1.\\n\\n\\n# Approach\\nBinary search the number of undefined edges, give them weight = 1.\\nDo 2 SPFAs, one from source (keep distance from source in d1) and one from destination (keep distance from destionation in d2).\\nIf for one edge (x, y) with undefined weight, d1[x] + d2[y] < target,\\nset the edge with weight = target - d1[x] - d2[y], and all remaining weights can be infinity.\\n\\n# Complexity\\n- Time complexity:\\nO(m(logm) ^ 2)\\n\\n- Space complexity:\\nO(m + n)\\n\\n# Code\\n```\\nclass Solution {\\n    void finalize(int m, vector<vector<int>>& edges) {\\n        for (auto& e : edges) {\\n            if (e[2] < 0) {\\n                if (m > 0) {\\n                    --m;\\n                    e[2] = 1;\\n                } else {\\n                    e[2] = 1234567890;\\n                }\\n            }\\n        }\\n    }\\n    \\n    vector<int> spfa(int n, int s, const vector<vector<pair<int, int>>> &con) {\\n        vector<int> d(n, -1);\\n        vector<bool> mark(n);\\n        d[s] = 0;\\n        priority_queue<pair<int, int>> q;\\n        q.push({0, s});\\n        while (!q.empty()) {\\n            const int x = q.top().second;\\n            q.pop();\\n            if (mark[x]) {\\n                continue;\\n            }\\n            mark[x] = true;\\n            for (const auto& v : con[x]) {\\n                const int y = v.first, w = v.second;\\n                if (mark[y] || (d[y] >= 0 && d[y] <= d[x] + w)) {\\n                    continue;\\n                }\\n                d[y] = d[x] + w;\\n                q.push({-d[y], y});\\n            }\\n        }\\n        return d;\\n    }\\n\\npublic:\\n    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int source, int destination, int target) {\\n        vector<int> ind;\\n        for (int i = 0; i < edges.size(); ++i) { \\n            if (edges[i][2] < 0) {\\n                ind.push_back(i);\\n            }\\n        }\\n        int left = 0, right = ind.size();\\n        while (left <= right) {\\n            const int mid = (left + right) >> 1;\\n            vector<vector<pair<int, int>>> con(n);\\n            int m = mid;\\n            for (const auto & e : edges) {\\n                int w = e[2];\\n                if (e[2] < 0) {\\n                    if (m <= 0) {\\n                        continue;\\n                    }\\n                    --m;\\n                    w = 1;\\n                }   \\n                con[e[0]].push_back({e[1], w});\\n                con[e[1]].push_back({e[0], w});\\n            }\\n            const vector<int> &d1 = spfa(n, source, con);\\n            if (d1[destination] == target) {\\n                finalize(mid, edges);\\n                return edges;\\n            }\\n            if (d1[destination] >= 0 && d1[destination] < target) {\\n                right = mid - 1;\\n                continue;\\n            }\\n            const vector<int> &d2 = spfa(n, destination, con);\\n            for (int t = mid; t < ind.size(); ++t) {\\n                const int i = ind[t];\\n                if (d1[edges[i][0]] >= 0 && d2[edges[i][1]] >= 0 && d1[edges[i][0]] + d2[edges[i][1]] < target) {\\n                    edges[i][2] = target - (d1[edges[i][0]] + d2[edges[i][1]]);\\n                    finalize(mid, edges);\\n                    return edges;\\n                }\\n                if (d1[edges[i][1]] >= 0 && d2[edges[i][0]] >= 0 && d1[edges[i][1]] + d2[edges[i][0]] < target) {\\n                    edges[i][2] = target - (d1[edges[i][1]] + d2[edges[i][0]]);\\n                    finalize(mid, edges);\\n                    return edges;\\n                }\\n            }\\n            left = mid + 1;\\n        }\\n        \\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    void finalize(int m, vector<vector<int>>& edges) {\\n        for (auto& e : edges) {\\n            if (e[2] < 0) {\\n                if (m > 0) {\\n                    --m;\\n                    e[2] = 1;\\n                } else {\\n                    e[2] = 1234567890;\\n                }\\n            }\\n        }\\n    }\\n    \\n    vector<int> spfa(int n, int s, const vector<vector<pair<int, int>>> &con) {\\n        vector<int> d(n, -1);\\n        vector<bool> mark(n);\\n        d[s] = 0;\\n        priority_queue<pair<int, int>> q;\\n        q.push({0, s});\\n        while (!q.empty()) {\\n            const int x = q.top().second;\\n            q.pop();\\n            if (mark[x]) {\\n                continue;\\n            }\\n            mark[x] = true;\\n            for (const auto& v : con[x]) {\\n                const int y = v.first, w = v.second;\\n                if (mark[y] || (d[y] >= 0 && d[y] <= d[x] + w)) {\\n                    continue;\\n                }\\n                d[y] = d[x] + w;\\n                q.push({-d[y], y});\\n            }\\n        }\\n        return d;\\n    }\\n\\npublic:\\n    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int source, int destination, int target) {\\n        vector<int> ind;\\n        for (int i = 0; i < edges.size(); ++i) { \\n            if (edges[i][2] < 0) {\\n                ind.push_back(i);\\n            }\\n        }\\n        int left = 0, right = ind.size();\\n        while (left <= right) {\\n            const int mid = (left + right) >> 1;\\n            vector<vector<pair<int, int>>> con(n);\\n            int m = mid;\\n            for (const auto & e : edges) {\\n                int w = e[2];\\n                if (e[2] < 0) {\\n                    if (m <= 0) {\\n                        continue;\\n                    }\\n                    --m;\\n                    w = 1;\\n                }   \\n                con[e[0]].push_back({e[1], w});\\n                con[e[1]].push_back({e[0], w});\\n            }\\n            const vector<int> &d1 = spfa(n, source, con);\\n            if (d1[destination] == target) {\\n                finalize(mid, edges);\\n                return edges;\\n            }\\n            if (d1[destination] >= 0 && d1[destination] < target) {\\n                right = mid - 1;\\n                continue;\\n            }\\n            const vector<int> &d2 = spfa(n, destination, con);\\n            for (int t = mid; t < ind.size(); ++t) {\\n                const int i = ind[t];\\n                if (d1[edges[i][0]] >= 0 && d2[edges[i][1]] >= 0 && d1[edges[i][0]] + d2[edges[i][1]] < target) {\\n                    edges[i][2] = target - (d1[edges[i][0]] + d2[edges[i][1]]);\\n                    finalize(mid, edges);\\n                    return edges;\\n                }\\n                if (d1[edges[i][1]] >= 0 && d2[edges[i][0]] >= 0 && d1[edges[i][1]] + d2[edges[i][0]] < target) {\\n                    edges[i][2] = target - (d1[edges[i][1]] + d2[edges[i][0]]);\\n                    finalize(mid, edges);\\n                    return edges;\\n                }\\n            }\\n            left = mid + 1;\\n        }\\n        \\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3548559,
                "title": "correction-in-hint-3",
                "content": "Hint 3 for this problem says :\\n`If the shortest path from source to destination including the edges to be modified and assigning them a temporary weight of 1, is less than the target, then it is also not possible.`\\n\\nIt should be :\\nIf the shortest path from source to destination including the edges to be modified and assigning them a temporary weight of 1, is **greater** than the target, then it is also not possible.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 3557844,
                "title": "one-by-one",
                "content": "This problem could be difficult to understand and has tons of edge cases.\\n\\nI wrote like 3 different solutions (WA) before I got what needs to be done.\\n\\nThis solution is a bit different than suggested by hints.\\n\\nIn a way, it solves a more difficult problem: the sum of modified weights is a necessary minimum.\\n\\n1. We run the Dijkstra algorithm while ignoring modifiable edges.\\n\\t- If the shortest distance is already less than the target, we return an empty list (\"impossible\").\\n2. We run the Dijkstra algorithm again, assuming the minimum (`1`) weight for modifiable edges.\\n\\t- If the shortest distance is greater than the target, we return an empty list (\"impossible\").\\n3. We also track a modifiable edge (any edge) that is a part of the shortest distance path.\\n4. If the shortest path distance is less than the target, we set the weight of the modifiable edge to `target - dist + 1`.\\n5. We repeat steps 2-4 until the shortest path distance is equal to the target.\\n6. We assign the minimum weight (`1`) to remaining modifiable edges.\\n\\n**C++**\\n```cpp\\narray<int, 2> bfs(vector<vector<array<int, 2>>> &al, vector<vector<int>> &edges, int source, int dest, int target, bool modify) {\\n    priority_queue<array<int, 2>, vector<array<int, 2>>, greater<>> q;\\n    vector<int> dist(al.size(), INT_MAX), mod_id(al.size(), INT_MAX);\\n    q.push({0, source});\\n    dist[source] = 0;\\n    while (!q.empty() && q.top()[1] != dest) {\\n        auto [d, i] = q.top(); q.pop();\\n        if (d != dist[i])\\n            continue;        \\n        for (auto [j, edge_id] : al[i]) {\\n            int w = edges[edge_id][2];\\n            if (modify || w != -1) {\\n                if (dist[j] > d + max(1, w)) {\\n                    mod_id[j] = w == -1 ? edge_id : mod_id[i];\\n                    dist[j] = d + max(1, w);\\n                    q.push({d + max(1, w), j});                    \\n                }\\n            }\\n        }\\n    }\\n    return {dist[dest], mod_id[dest]};\\n}\\nvector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int source, int dest, int target) {\\n    vector<vector<array<int, 2>>> al(n);\\n    for (int i = 0; i < edges.size(); ++i) {\\n        al[edges[i][0]].push_back({edges[i][1], i});\\n        al[edges[i][1]].push_back({edges[i][0], i});\\n    }\\n    auto [dist, _] = bfs(al, edges, source, dest, target, false);\\n    if (dist < target)\\n        return {};  \\n    while (true) {\\n        auto [dist, mod_id] = bfs(al, edges, source, dest, target, true);\\n        if (dist > target)\\n            return {};\\n        if (dist == target)\\n            break;\\n        edges[mod_id][2] = 1 + target - dist;\\n    }\\n    for (auto &e : edges)\\n        e[2] = e[2] == -1 ? 1 : e[2];\\n    return edges;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\narray<int, 2> bfs(vector<vector<array<int, 2>>> &al, vector<vector<int>> &edges, int source, int dest, int target, bool modify) {\\n    priority_queue<array<int, 2>, vector<array<int, 2>>, greater<>> q;\\n    vector<int> dist(al.size(), INT_MAX), mod_id(al.size(), INT_MAX);\\n    q.push({0, source});\\n    dist[source] = 0;\\n    while (!q.empty() && q.top()[1] != dest) {\\n        auto [d, i] = q.top(); q.pop();\\n        if (d != dist[i])\\n            continue;        \\n        for (auto [j, edge_id] : al[i]) {\\n            int w = edges[edge_id][2];\\n            if (modify || w != -1) {\\n                if (dist[j] > d + max(1, w)) {\\n                    mod_id[j] = w == -1 ? edge_id : mod_id[i];\\n                    dist[j] = d + max(1, w);\\n                    q.push({d + max(1, w), j});                    \\n                }\\n            }\\n        }\\n    }\\n    return {dist[dest], mod_id[dest]};\\n}\\nvector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int source, int dest, int target) {\\n    vector<vector<array<int, 2>>> al(n);\\n    for (int i = 0; i < edges.size(); ++i) {\\n        al[edges[i][0]].push_back({edges[i][1], i});\\n        al[edges[i][1]].push_back({edges[i][0], i});\\n    }\\n    auto [dist, _] = bfs(al, edges, source, dest, target, false);\\n    if (dist < target)\\n        return {};  \\n    while (true) {\\n        auto [dist, mod_id] = bfs(al, edges, source, dest, target, true);\\n        if (dist > target)\\n            return {};\\n        if (dist == target)\\n            break;\\n        edges[mod_id][2] = 1 + target - dist;\\n    }\\n    for (auto &e : edges)\\n        e[2] = e[2] == -1 ? 1 : e[2];\\n    return edges;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3555490,
                "title": "dijkstra-with-only-1-or-0-mutable-edge-1-infinity-detailed-explanation-with-proofs",
                "content": "Lets say this is the given graph **G**:\\n<img src=\"https://assets.leetcode.com/users/images/1468e18b-49be-4679-ba1e-d111143f8944_1684824941.6372726.png\"  width=400>\\nHere, orange edges are of positve weights and **black edges** are of weight -1 i.e. they are **mutable**.\\nThe **red** vertex is **source** and **green** vertex is **destination** throughout this discussion.\\n\\nNow lets construct 2 different graphs **H** and **T** from graph **G**:\\n<img src=\"https://assets.leetcode.com/users/images/915a885d-732d-44c3-8e8f-b49a4d1b5e47_1684825522.857312.png\"  width=800>\\ngraph **H** is made by making mutable edges **weight -> infinity** i.e. **removing them**.\\ngraph **T** is made by making mutable edges **weight = 1**. A mutable edge with weight == 1 will be represented by a **single-coloured dashed line** throughout this discussion.\\nNotice that, graph **H** is subset of graph **T,** i.e.:\\n**H \\u2286 T** &ensp; .......................................................................................................................... **property 1**\\n\\nNow, first do Dijkstra on graph **H** to compute d(i) for all nodes, where **d(i)** is **shortest distance between source and ith node** in graph **H**(i.e. one without mutable edges)\\n<img src=\"https://assets.leetcode.com/users/images/61b4ea4c-80fb-4cdf-a686-6d12e3f6b638_1684826081.2908306.png\"  width=400>\\n\\nNow, if **d(destination) < target** => we can\\'t do anything, soln is impossible. &ensp; ......... **case cover 1**\\n<img src=\"https://assets.leetcode.com/users/images/aaff8ecb-12ce-4a0b-9d86-e00e6a019a99_1684826532.271396.png\"  width=400>\\nif **d(destination) == target** -> just **return edges of graph H**. &ensp; ................................ **case cover 2**\\n\\nLets now do Dijkstra on graph **T**(either from source or target):\\n<img src=\"https://assets.leetcode.com/users/images/7218d710-e928-4ada-b950-64f6479e9eb6_1684831262.5674808.png\"  width=400>\\nNotice that we are only instrested in shortest source-destination path in this graph(**T**) and not distance to other nodes not on the path, so running Dijkstra from either source or destination will suffice.\\nNow, if this **green path > target** => we can\\'t do anything &ensp; ....................................... **case cover 3**\\n\\nNow, lets combine this green path from graph **T** with graph **H** to obtain a new graph **C**:\\n<img src=\"https://assets.leetcode.com/users/images/5ef84882-e216-4076-aefe-87986acaa63d_1684831920.7681987.png\"  width=840>\\nnotice that,\\n**H \\u2286 C \\u2286 T** &ensp; .................................................................................................................... **property 2**\\n\\nWhat this means, is that any **node x, on green path** in graph **C** has shortest path to source as well as destination along that green path. \\n=> In graph C, any other path from node x to destination >= **part of green path(without any other change)** from x to destination.\\n=>Even in **any subset of graph C**,\\nif any **node x** is connected to **destination** with part of **part of green path(without any other change)**, \\nit would be **shortest** &ensp; ................................................................................................... **property 3**\\n\\nNow, lets start with graph **H**, and start adding green path from destination, and count **weight of green path added so far = w**.\\n<img src=\"https://assets.leetcode.com/users/images/b88bab67-1f95-43b1-a0f4-1544ce2415c6_1684832863.3678186.png\"  width=512>\\nNow, let say we have green path to graph **H** till node v, and all weights so far was non-dashed(i.e. originally unmutable and positive), and now we encounter our first dashed edge **u-v** (i.e. mutable and **== 1 in unaltered green path**),\\nSo, **till v** we, have weigth of green path = **w**\\nand shortest path from **source to u** = **d(u)**, which was obtained from **original Dijkstra from source** on graph **H**, since green path doesn\\'t reach u yet.\\nNow, if **d(u) + w >= target**, then all **source-destination path are still > target**,\\nas **d(u) + u-v + w** > target.\\nSo, we move ahead along our green path, and keep adding its edges to graph **H**, without any alteration on green path.\\n\\nnow let say we encounter such a dashed edge **u-v** (i.e. mutable and **== 1 in unaltered green path**), for first time, which satisfies\\n**d(u) + w < target**\\nLets try to make u-v non dashed(i.e. change it\\'s value from 1) and add it to graph **H**.\\nLet u-v = **target - (d(u) + w)**, and add it to graph **H**,\\nindicated by **blue-green line** in figure below.\\n<img src=\"https://assets.leetcode.com/users/images/a3997416-2c4e-4ebc-9aae-48776e7f1c57_1684833750.3051062.png\"  width=512>\\nHere, **d(u**) is represented by **pink path**, w with green\\nso, **pink path + modified u-v + part of green path = target**\\n--->**_[Remember, we have added only a part of green path(from v to destination), and not all green path.]_**\\n\\nso we got a path we need, now let\\'s see if this addition of modified u-v has created any path from source to destination less than target, along with **a promise that we will not go any further in green path** :\\n\\nwe should check:\\n1. there is no other path from u to destination < w + modified u-v\\n2. there is no other path from v to destination < w\\n3. there is no other path from source to u < pink path\\n4. there is no other path from source to v < pink path + modified u-v\\n\\n**check 1:**\\nLet \\'black path in diagram from u to destination\\' < w + modified u-v\\n- sub-case 1: black path has no edge common with green path from v to destination:\\n\\tIn that case **d(u) + black path > target** otherwise it would have been caught in **case cover 1**\\n\\tbut, d(u) + w + modified u-v = target\\n\\tso, black path > w + modified u-v => **a contradiction**\\n- sub-case 2:  black path have some edge common with green path from v to destination:\\n\\tif all common green edges were non-dashed(i.e. non-mutable), then this is exactly similar to sub-case 1.\\n\\telse if some common green edges were dashed => they would have been our u-v candiate earlier:\\n\\tlet say they were u\\'-v\\'\\n\\tas pink path + black path from u to u\\' + w\\'(green path from v\\' to destination) + u\\'-v\\'\\n\\t= pink path + black path from u to destination < target(our condition for contradiction)\\n\\t=> pink path + black path from u to u\\' + w\\'(green path from v\\' to destination) + u\\'-v\\' < target\\n\\t=> d(u\\') + w\\' + u\\'-v\\' < target\\n\\t=> **d(u\\') + w\\' < target** => u\\'-v\\' were supposed to candidate first.\\n\\t=> so according to our promise we would not have reached u-v -----> **a contradiction**\\n\\t\\n**check 2:**\\n\\tLet \\'red path in diagram from v to destination\\' < w\\n\\tThis is violation of our **property 3**, as v is connected to destination with unmodified part of green path(=w)\\n\\n**check 3:**\\nLet path from source to u < pink path:\\n- subcase 1: It doesn\\'t have any undashed-edge in common:\\nthen it would have been checked in our original Dijkstra on graph **H**(without mutable edges), hence, it can\\'t be less than d(u) = pink path.\\n- subcase 2: It does have some undashed-edge in common:\\nThen those common edges would have been our u-v candiadate earlier and we would not have reached here.(see check 1: subcase 2)\\n\\n**check 4:**\\nLet path from source to v < pink path + modified u-v\\n- subcase 1: It  have some undashed-edge in common:\\nThen those common edges would have been our u-v candiadate earlier and we would not have reached here.(see check 1: subcase 2)\\n- subcase 2: It doesn\\'t have some undashed-edge in common:\\n\\t- sub-subcase i: green path from v to destination have no dashed edges:\\nthen, this edge + greenpath < target would have been caught by **case cover 1**.\\n\\t- sub-subcase ii: green path from v to destination have some dashed edges:\\nthen, that dashed edge would have become original candidate for u-v.\\n\\nSo, we are good and we found a shortest path = target.\\n\\nNow, it is **very very important** to **fulfill the promise** and  **break this walk here** and return the edges of Graph H + green path from v to destination.\\n\\nWhat happens, if we continued this walk instead of breaking?\\nWell, we can see some of the points that we made in our checks about there would have been a candidate for u-v earlier, and we would not have reached here, would not be longer be valid.\\nBut lets prove that it would have been a **problem**:\\n\\nLet, see our first u-v candidate again:\\n<img src=\"https://assets.leetcode.com/users/images/78463741-a6f7-4348-bd51-84c702278230_1684839162.557342.png\"  width=720>\\n\\nWe have shown that black path from u to destination can\\'t be less than green path from v + u-v (in our check 1),\\nbut the black path from blue node to destination in direction of **orange arrow** can be **less than** path from blue node to destination in direction of **black arrow**.\\nThat is **not a problem right now** as any path from source to blue node would not create a problem right now,(proof similar to check 1 and it is covered by default, when you extend the proof of check 1 to get the constraint of shortest path from source to a node on black path)\\n\\nBut, lets say, instead of breaking, we continued our walk, and reached another u-v candidate:\\n<img src=\"https://assets.leetcode.com/users/images/18470320-4bdc-4976-b4b2-815b234829d1_1684839842.8452427.png\"  width=720>\\nwell, then we are screwed as after v shortest path from source to destination will follow the new red path (direction of orange arrow) instead of our walk.\\nand we have set **pink-path + u-v + walk = target** when we converted u-v to non-dashed.\\nso, **pink-path + u-v + red path < target** => FAIL.\\nNote, that **check 2** is now not covering red path for us as v is **no longer connected with unmodified green path** from v to destination(there was a modification done by us earlier when we got our first u-v candidate). So, **property 3** doesn\\'t hold.\\n\\nHence, we have **fulfil our promise** and **must break** after first u-v candidate when implementing this algo.\\nSo, this algo will only lead to one non-dashed mutable path.\\n\\ni.e. only one(or zero) original negative weight will be set to something which is not 1 or infinity.  \\n(Note, there can alse be a parallel solution where more that one negative weight can be set to something which is not 1 or infinity, **along side with this solution**, but this algo will not produce that).\\n\\nlet me give my code implementation:\\nIn my code infinity = target:\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int source, int destination, int target) {\\n        vector<vector<int> > adj(n, vector<int>(n, 0));\\n        for(int i = 0; i < edges.size(); i++){\\n            adj[edges[i][0]][edges[i][1]] = edges[i][2];\\n            adj[edges[i][1]][edges[i][0]] = edges[i][2];\\n            if(edges[i][2] == -1) edges[i][2] = target;\\n        }\\n        \\n        priority_queue<vector<int>, vector<vector<int> >, greater<vector<int> > > pq;\\n        vector<int> d(n, 1e9 + 1);\\n        vector<int> fixed(n, 0);\\n        pq.push({0,source});\\n        d[source] = 0;\\n        while(!pq.empty()){\\n            int c = pq.top()[1];\\n            pq.pop();\\n            if(fixed[c]) continue;\\n            fixed[c] = 1;\\n            for(int i = 0; i < n; i++){\\n                if(adj[c][i] > 0 && d[i] > adj[c][i] + d[c]){\\n                    d[i] = adj[c][i] + d[c];\\n                    pq.push({d[i], i});\\n                }\\n            }\\n        }\\n        if(d[destination] < target) return {};\\n        if(d[destination] == target) return edges;\\n        vector<int> dist(n, 1e9 + 1);\\n        fixed = vector<int>(n, 0);\\n        vector<int> parent(n, -1);\\n        pq.push({0,source});\\n        dist[source] = 0;\\n        int c;\\n        while(!pq.empty()){\\n            c = pq.top()[1];\\n            pq.pop();\\n            if(fixed[c]) continue;\\n            fixed[c] = 1;\\n            for(int i = 0; i < n; i++){\\n                if(adj[c][i] != 0 && dist[i] > abs(adj[c][i]) + dist[c]){\\n                    dist[i] = abs(adj[c][i]) + dist[c];\\n                    pq.push({dist[i], i});\\n                    parent[i] = c;\\n                }\\n            }\\n        }\\n        if(dist[destination] > target) return {};\\n        int x = destination;\\n        int y;\\n        int rem = target;\\n        int add;\\n        while(x != source){\\n            y = parent[x];\\n            if(adj[x][y] == -1) {\\n                adj[x][y] = 1;\\n                add = max(0, rem - d[y] - 1);\\n                adj[x][y] += add;\\n                adj[y][x] = adj[x][y];\\n                if(add != 0) break;\\n            }\\n            rem -= adj[x][y];\\n            x = y;\\n        }\\n        for(int i = 0; i < edges.size(); i++){\\n            if(adj[edges[i][0]][edges[i][1]] != -1) edges[i][2] =  adj[edges[i][0]][edges[i][1]];\\n        }\\n        return edges;\\n    }\\n};\\n```\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int source, int destination, int target) {\\n        vector<vector<int> > adj(n, vector<int>(n, 0));\\n        for(int i = 0; i < edges.size(); i++){\\n            adj[edges[i][0]][edges[i][1]] = edges[i][2];\\n            adj[edges[i][1]][edges[i][0]] = edges[i][2];\\n            if(edges[i][2] == -1) edges[i][2] = target;\\n        }\\n        \\n        priority_queue<vector<int>, vector<vector<int> >, greater<vector<int> > > pq;\\n        vector<int> d(n, 1e9 + 1);\\n        vector<int> fixed(n, 0);\\n        pq.push({0,source});\\n        d[source] = 0;\\n        while(!pq.empty()){\\n            int c = pq.top()[1];\\n            pq.pop();\\n            if(fixed[c]) continue;\\n            fixed[c] = 1;\\n            for(int i = 0; i < n; i++){\\n                if(adj[c][i] > 0 && d[i] > adj[c][i] + d[c]){\\n                    d[i] = adj[c][i] + d[c];\\n                    pq.push({d[i], i});\\n                }\\n            }\\n        }\\n        if(d[destination] < target) return {};\\n        if(d[destination] == target) return edges;\\n        vector<int> dist(n, 1e9 + 1);\\n        fixed = vector<int>(n, 0);\\n        vector<int> parent(n, -1);\\n        pq.push({0,source});\\n        dist[source] = 0;\\n        int c;\\n        while(!pq.empty()){\\n            c = pq.top()[1];\\n            pq.pop();\\n            if(fixed[c]) continue;\\n            fixed[c] = 1;\\n            for(int i = 0; i < n; i++){\\n                if(adj[c][i] != 0 && dist[i] > abs(adj[c][i]) + dist[c]){\\n                    dist[i] = abs(adj[c][i]) + dist[c];\\n                    pq.push({dist[i], i});\\n                    parent[i] = c;\\n                }\\n            }\\n        }\\n        if(dist[destination] > target) return {};\\n        int x = destination;\\n        int y;\\n        int rem = target;\\n        int add;\\n        while(x != source){\\n            y = parent[x];\\n            if(adj[x][y] == -1) {\\n                adj[x][y] = 1;\\n                add = max(0, rem - d[y] - 1);\\n                adj[x][y] += add;\\n                adj[y][x] = adj[x][y];\\n                if(add != 0) break;\\n            }\\n            rem -= adj[x][y];\\n            x = y;\\n        }\\n        for(int i = 0; i < edges.size(); i++){\\n            if(adj[edges[i][0]][edges[i][1]] != -1) edges[i][2] =  adj[edges[i][0]][edges[i][1]];\\n        }\\n        return edges;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547332,
                "title": "java-dijkstra",
                "content": "# Intuition\\nAfter the initial Dijkstra traverse with all positive weights, do partial (start from middle of the path) Dijkstra traverses by changing the negative weights to 1 one by one. Repeat until the dist to destination is smaller than target, then we can set the last changed weight to the desired weight, and set all other negative weights to max value.\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] modifiedGraphEdges(int n, int[][] edges, int source, int destination, int target) {\\n        Map<Integer, Integer>[] adjs = new Map[n];\\n        for (int i = 0; i < n; i++) {\\n            adjs[i] = new HashMap<>();\\n        }\\n\\n        for (int[] edge : edges) {\\n            adjs[edge[0]].put(edge[1], edge[2]);\\n            adjs[edge[1]].put(edge[0], edge[2]);\\n        }\\n\\n        int[] distTo = new int[n];\\n        Arrays.fill(distTo, Integer.MAX_VALUE);\\n        distTo[source] = 0;\\n\\n        Queue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(i -> i[1]));\\n        pq.add(new int[] {source, 0});\\n\\n        dijkstra(adjs, distTo, pq);\\n\\n        if (distTo[destination] == target) {\\n            return fill(edges);\\n        } else if (distTo[destination] < target) {\\n            return new int[0][0];\\n        } else {\\n            for (int[] edge : edges) {\\n                if (edge[2] == -1) {\\n                    edge[2] = 1;\\n                    adjs[edge[0]].put(edge[1], 1);\\n                    adjs[edge[1]].put(edge[0], 1);\\n\\n                    pq.clear();\\n                    pq.add(new int[] {edge[0], distTo[edge[0]]});\\n                    pq.add(new int[] {edge[1], distTo[edge[1]]});\\n\\n                    dijkstra(adjs, distTo, pq);\\n\\n                    if (distTo[destination] == target) {\\n                        return fill(edges);\\n                    } else if (distTo[destination] < target) {\\n                        edge[2] += target - distTo[destination];\\n                        adjs[edge[0]].put(edge[1], edge[2]);\\n                        adjs[edge[1]].put(edge[0], edge[2]);\\n                        return fill(edges);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return new int[0][0];\\n    }\\n\\n    private int[][] fill(int[][] edges) {\\n        for (int[] edge : edges) {\\n            if (edge[2] == -1) {\\n                edge[2] = (int) (2 * 1e9);\\n            }\\n        }\\n        return edges;\\n    }\\n\\n    private void dijkstra(Map<Integer, Integer>[] adjs, int[] distTo, Queue<int[]> pq) {\\n        while (!pq.isEmpty()) {\\n            int[] curr = pq.poll();\\n\\n            for (Map.Entry<Integer, Integer> entry : adjs[curr[0]].entrySet()) {\\n                if (entry.getValue() > 0) {\\n                    int next = entry.getKey();\\n                    if (distTo[next] - entry.getValue() > distTo[curr[0]]) {\\n                        distTo[next] = distTo[curr[0]] + entry.getValue();\\n                        pq.add(new int[] {next, distTo[next]});\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] modifiedGraphEdges(int n, int[][] edges, int source, int destination, int target) {\\n        Map<Integer, Integer>[] adjs = new Map[n];\\n        for (int i = 0; i < n; i++) {\\n            adjs[i] = new HashMap<>();\\n        }\\n\\n        for (int[] edge : edges) {\\n            adjs[edge[0]].put(edge[1], edge[2]);\\n            adjs[edge[1]].put(edge[0], edge[2]);\\n        }\\n\\n        int[] distTo = new int[n];\\n        Arrays.fill(distTo, Integer.MAX_VALUE);\\n        distTo[source] = 0;\\n\\n        Queue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(i -> i[1]));\\n        pq.add(new int[] {source, 0});\\n\\n        dijkstra(adjs, distTo, pq);\\n\\n        if (distTo[destination] == target) {\\n            return fill(edges);\\n        } else if (distTo[destination] < target) {\\n            return new int[0][0];\\n        } else {\\n            for (int[] edge : edges) {\\n                if (edge[2] == -1) {\\n                    edge[2] = 1;\\n                    adjs[edge[0]].put(edge[1], 1);\\n                    adjs[edge[1]].put(edge[0], 1);\\n\\n                    pq.clear();\\n                    pq.add(new int[] {edge[0], distTo[edge[0]]});\\n                    pq.add(new int[] {edge[1], distTo[edge[1]]});\\n\\n                    dijkstra(adjs, distTo, pq);\\n\\n                    if (distTo[destination] == target) {\\n                        return fill(edges);\\n                    } else if (distTo[destination] < target) {\\n                        edge[2] += target - distTo[destination];\\n                        adjs[edge[0]].put(edge[1], edge[2]);\\n                        adjs[edge[1]].put(edge[0], edge[2]);\\n                        return fill(edges);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return new int[0][0];\\n    }\\n\\n    private int[][] fill(int[][] edges) {\\n        for (int[] edge : edges) {\\n            if (edge[2] == -1) {\\n                edge[2] = (int) (2 * 1e9);\\n            }\\n        }\\n        return edges;\\n    }\\n\\n    private void dijkstra(Map<Integer, Integer>[] adjs, int[] distTo, Queue<int[]> pq) {\\n        while (!pq.isEmpty()) {\\n            int[] curr = pq.poll();\\n\\n            for (Map.Entry<Integer, Integer> entry : adjs[curr[0]].entrySet()) {\\n                if (entry.getValue() > 0) {\\n                    int next = entry.getKey();\\n                    if (distTo[next] - entry.getValue() > distTo[curr[0]]) {\\n                        distTo[next] = distTo[curr[0]] + entry.getValue();\\n                        pq.add(new int[] {next, distTo[next]});\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546925,
                "title": "ac-2m-after-floyd-warshall-o-n-3",
                "content": "# Intuition\\nFirst I have to say that this solution will not involve passing because complexity but as long as they do not add more testcase this solution is accepted.\\n\\nThinking better it makes sense that we don\\'t need to check all edges, for the worst case would be nessesary around $n$ edges to guarantee connectivity so the complexity will be something around $O(n\\xB3)$ although I think there might be a good testcase for which you need to check a lot of until the last one to get the desired target.\\n# Approach\\nRun a first floyd warshall algorithm in $O(n\\xB3)$, then for each edge with $w = -1$ assign a weight and then try to recalculate, this will cost $O(n^2)$.\\n\\nWhat weight to put on the current edge? Let\\'s try $1$ , if the shortest path reduces and is less than $target$ then we can adjust to get the desired target, otherwise we leave the weight as $1$ and keep trying with the other edges.\\n\\n# Complexity\\n- Time complexity:\\n$O(|edges| \\\\times n^2 + n^3)$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    long long D[107][107];\\n    void floyd(int n){\\n       for (int k = 0; k < n; ++k) {\\n            for (int i = 0; i < n; ++i) {\\n                for (int j = 0; j < n; ++j) {\\n                    D[i][j] = min(D[i][j], D[i][k] + D[k][j]); \\n                }\\n            }\\n        }\\n    }\\n    \\n    void recalc(int a,int b,int x,int n){\\n        for(int i  = 0;i<n;i++){\\n            for(int j = 0;j<n;j++){\\n                D[i][j] = min({D[i][j],D[i][a]+x+D[b][j],D[i][b]+x+D[a][j]});\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int s, int d, int t) {\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<n;j++){\\n                if(i == j)D[i][j]= 0;\\n                else D[i][j] = 1e12;\\n            }\\n        }\\n        int id = 0;\\n        vector<int> test;\\n        for(auto c:edges){\\n            int u = c[0];\\n            int v = c[1];\\n            int w = c[2];\\n            if(w != -1){\\n                D[v][u] = w;   \\n                D[u][v] = w;\\n            }\\n            else\\n                test.push_back(id);\\n            id++;\\n        }\\n            \\n        floyd(n);\\n        if(D[s][d]<t)return {};\\n        \\n        \\n        for(int i = 0;i<test.size();i++){\\n            if(D[s][d]==t){\\n                edges[test[i]][2] = 2e9;\\n                continue;\\n            }\\n            int u = edges[test[i]][0];\\n            int v = edges[test[i]][1];\\n        \\n            long long nwMin1 = D[s][u]+1+D[v][d];\\n            long long nwMin2 = D[s][v]+1+D[u][d];\\n            \\n            long long mn = min(nwMin1,nwMin2);\\n            if(mn>t){\\n                recalc(u,v,1,n);\\n                edges[test[i]][2] = 1;\\n            }\\n            else{\\n                recalc(u,v,1+(t-mn),n);\\n                edges[test[i]][2] = 1+(t-mn);\\n            }\\n        }\\n        cout<<D[s][d]<<endl;\\n        if(D[s][d]!=t)return {};\\n        return edges;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long D[107][107];\\n    void floyd(int n){\\n       for (int k = 0; k < n; ++k) {\\n            for (int i = 0; i < n; ++i) {\\n                for (int j = 0; j < n; ++j) {\\n                    D[i][j] = min(D[i][j], D[i][k] + D[k][j]); \\n                }\\n            }\\n        }\\n    }\\n    \\n    void recalc(int a,int b,int x,int n){\\n        for(int i  = 0;i<n;i++){\\n            for(int j = 0;j<n;j++){\\n                D[i][j] = min({D[i][j],D[i][a]+x+D[b][j],D[i][b]+x+D[a][j]});\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int s, int d, int t) {\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<n;j++){\\n                if(i == j)D[i][j]= 0;\\n                else D[i][j] = 1e12;\\n            }\\n        }\\n        int id = 0;\\n        vector<int> test;\\n        for(auto c:edges){\\n            int u = c[0];\\n            int v = c[1];\\n            int w = c[2];\\n            if(w != -1){\\n                D[v][u] = w;   \\n                D[u][v] = w;\\n            }\\n            else\\n                test.push_back(id);\\n            id++;\\n        }\\n            \\n        floyd(n);\\n        if(D[s][d]<t)return {};\\n        \\n        \\n        for(int i = 0;i<test.size();i++){\\n            if(D[s][d]==t){\\n                edges[test[i]][2] = 2e9;\\n                continue;\\n            }\\n            int u = edges[test[i]][0];\\n            int v = edges[test[i]][1];\\n        \\n            long long nwMin1 = D[s][u]+1+D[v][d];\\n            long long nwMin2 = D[s][v]+1+D[u][d];\\n            \\n            long long mn = min(nwMin1,nwMin2);\\n            if(mn>t){\\n                recalc(u,v,1,n);\\n                edges[test[i]][2] = 1;\\n            }\\n            else{\\n                recalc(u,v,1+(t-mn),n);\\n                edges[test[i]][2] = 1+(t-mn);\\n            }\\n        }\\n        cout<<D[s][d]<<endl;\\n        if(D[s][d]!=t)return {};\\n        return edges;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3551925,
                "title": "dikeshtra-for-every-1-weight-to-just-only-2-dikeshtra-s-image-explaination-c-alot-effort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n###### Guys marvellous question so will go step by step \\n###### If you like please Upvote :\\n### What we want:\\n-   Guys note the point \"Shortest\" distance from source to destination to be equal to target . That means the target will be going to our shortest distance if possible .\\n-   If the target is not the shortest distance return an empty array \\n\\n### Approach :\\n    Firstly We will thinkk about the edge cases :\\n-   When there is a positive path to reach the destiation from source in less than target. \\n![217b7a97-72d3-4e25-b1f7-557a7267a200.jpg](https://assets.leetcode.com/users/images/f937af6d-8b9a-4998-8d25-ab7b0738e07f_1684750583.2948987.jpeg)\\n-   If we assign all the values of negative weight edges to be +1( i.e,  minimum ) Then if we got teh shortest distance greater than the target return empty .\\n![00c7b46b-75a9-49d6-95e5-41689c88185f.jpg](https://assets.leetcode.com/users/images/13496d6d-e8c6-4e6a-b434-443270475f4c_1684750615.8709826.jpeg)\\n\\n- If we assign all the -1 weight edges to maximum ansd then run from source and get a value less tahn target then also return empty subset .\\n![196206d1-7ffc-403e-a945-cb691a117ec4.jpg](https://assets.leetcode.com/users/images/a53b278f-70dd-4902-be83-de0103908a48_1684750638.9201574.jpeg)\\n\\n#### I guess you got the edges cases \\n Rest in all the cases we can get the path by assigning negative path value to some positive values \\n### Now comes to the main part \\n Now there are two approaches to get to the solution : I will give the hint for the 1 st one and the approach and will code for second one (which is best ):\\n\\n## 1st Approach(Dikestra for all negative values)\\n-    Firstly, apply Dijkstra\\'s algorithm by assigning a value of +1 to negative weights and handle edge cases.\\n- Secondly, apply Dijkstra\\'s algorithm by assigning a maximum value to negative weights and handle the edge cases.\\n- Till now you have handled the edge cases .\\n-Now, check for the edges with weight -1 and assign the value 1 (which is the minimum). Then, check if it is possible to reach the destination in less than the target value using Dijkstra\\'s algorithm again.\\n- If it is possible, assign the value target - distance  to the current edge. Assign any other negative edges a random value (e.g., 1e9) and return from there as you have reached the destination within the desired target.\\n- Here\\'s how you will apply Dijkstra\\'s algorithm in this case:\\n\\n1. Initially, exclude the negative weight edges from the adjacency list. As you traverse through -1 weight edges, start adding edges with weight initially set to 1 in the adjacency list.\\n2. If you are unable to reach the destination, it means the destination is connected by a negative node. In this case, assign the current value as 1.\\n3. When you are able to reach the destination, assign the value target - current distance to reach it.\\n4. There may be cases when distance > target, in which assigning the +1 value is appropriate\\n\\nNOTICE : Dijkstra\\'s algorithm is applied here from the source to the destination. However, in this approach, you continuously apply Dijkstra\\'s algorithm until you reach the destination in the specified target if it is not NULL..\\n\\n###### here is the image explaination\\n![9341894b-c17e-41d4-a423-293ea7f51571.jpg](https://assets.leetcode.com/users/images/36f6c816-5ff5-4b86-878c-164d2c830397_1684751614.0331495.jpeg)\\n\\nTake another case :\\nJust To explain in brief :\\n![b76f514c-79bf-42ac-a931-2e5d3d580709.jpg](https://assets.leetcode.com/users/images/510f3f7d-ccd9-4c13-a539-6b9097ef9271_1684751882.7184281.jpeg)\\n\\nNow I hope you guys can write the above code by yourself .\\n\\n### TWO times Dikeshtra Algorithm approach :\\n-   Now Here we will assign all the -1 edges as +1 and start from the source to destination and store all the values from source to destination in Dp that is the shortest distance from dikeshtra .\\n- AND here we will check whether the shortest distance by taking the - ve edge value as minimum if it is coming > target return empty .\\n- ##### A CAREFUL and Important Point : For any -1 weight value its value for making the shortest distance(==target ) will depend on the upcoming -ve edge value till we can reach to destination and previously value  to that edge from source .\\n- ##### If we store the the minimum distance from a particular source from source  and destination and if we are able to get the it equal to target then ya our job is done .If not then :\\n- We will start another dikeshtra (i.e 2 time ) By assigning all the values of the weight as max 1e9  and will reach to teh source .\\n- We will chevk the edge cases that by assigning maximum value if we reach to the source in less than the target value then return empty array \\n\\n- ##### Now the question comes why we have taken dikeshtra from destination to source . Because The approach is for any -ve weight edge node we will ask from the edges[i][0] that what is the distance of you from source if we have assign 1 value (from source to this node to all -ve edge values )  and from destination to the other point of edge (by assigning teh maximum value(to all-ve weight edge in the path destination to the other node). ............................. \\n ##### The maximum(to -ve edge) from destination because is there any path from the current -ve edge  to destination that doesnot involve the -1 and can make us reach to the destination in teh targeted value . If so we dont need to convert the upcooming - ve values \\n-   I hope You get the point Why we are taking from destination the another storing dp which will store the minimum path from destination to source (By giving maximum value to -ve edges )\\n-  Now traverse through all the negative edges If the value which should be assign to this negative value comes to be negative(target - from_souce -fro_destination)<0 then assign 1.\\n- If it is positive then assign the value as weight as (Target -from_source-from_destination) to the edge .\\n- Similarly can do for all the edges .\\n- And You will see you have learn teh problem .YAYYYYY!!!!!!!!!!!!!!\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n        Guys APProach have been taught above :\\n        If you love the approach please Upvote \\u2764\\uFE0F\\u2764\\uFE0F.\\nHope You like it rest code have been explained in the comments .\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->   \\n    O(V+Elog(V))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n        2 times made teh adjacency matrix +2 time priority queue ;\\n\\n\\n# Code\\n```\\nusing  ll = long long int ;\\nclass Solution {\\npublic:\\n    // BFS and Dikeshtra\\'s algorithm \\n    void Dikeshtra(int n ,vector<vector<pair<ll,ll>>>& adj, int source , vector<ll>&dp )\\n    {\\n        priority_queue<pair<ll,ll> , vector<pair<ll,ll>> , greater<pair<ll,ll>>> pq ; \\n       \\n        pq.push({0 , source});\\n        dp[source]=0;\\n        while(!pq.empty())\\n        {\\n            ll dis = pq.top().first;\\n            ll ind = pq.top().second ;\\n            pq.pop() ;\\n            for(int j =0 ;j<adj[ind].size() ;j++)\\n            {\\n                ll val =adj[ind][j].second;\\n                ll new_dis= dis+val;\\n                if(new_dis<dp[adj[ind][j].first])\\n                {\\n                    dp[adj[ind][j].first]=new_dis;\\n                    pq.push({new_dis, adj[ind][j].first});\\n                } \\n            }\\n        }\\n    }\\n    // Converting all -1 edges to max or 1\\n    //Assigning values when got the destination \\n    void assign(vector<vector<int>>& edges , int with )\\n    {\\n        for( int i =0 ;i<edges.size(); i++)\\n        {\\n            if(edges[i][2]==-1)\\n            {\\n                edges[i][2]=with;\\n            }\\n        }\\n    }\\n    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int source, int destination, int target) {\\n      // two adjacency list one for minmum and other maximum\\n        vector<vector<pair<ll,ll>>> adj (n) , r_adj(n);\\n        for( int i =0 ;i<edges.size() ;i++)\\n        {\\n            ll val = edges[i][2] , value= edges[i][2];\\n            if(edges[i][2]==-1)\\n            {\\n                val= 1;\\n                value =2e9;\\n            }\\n            adj[edges[i][0]].push_back({edges[i][1] ,val});\\n            adj[edges[i][1]].push_back({edges[i][0] , val});\\n            r_adj[edges[i][0]].push_back({edges[i][1] , value});\\n            r_adj[edges[i][1]].push_back({edges[i][0] , value});\\n        } \\n        // for storing the paths dp1(from source) && dp1(from destination)\\n        vector<long long > dp1(n ,INT_MAX) , dp2(n , INT_MAX);\\n\\n        Dikeshtra(n , adj, source ,dp1);\\n        //EDGE CASES BEEN handled here \\n        if(dp1[destination]>target)\\n        {\\n            return {};\\n        }\\n        // If dp[destination]== target return edgesy converting them as1 the -1 weight obviously\\n        if(dp1[destination]==target)\\n        {\\n            assign(edges, 1);\\n            return edges;\\n        }\\n        //if_not \\n        Dikeshtra(n , r_adj , destination , dp2);\\n        if(dp2[source]<target)\\n        {\\n            return {};\\n        }\\n        if(dp2[source]==target)\\n        {\\n            assign(edges, 1e9);\\n            return edges;\\n        }\\n        // Edge cases have been taken care above \\n        // Rest :\\n        for(int i =0 ;i<edges.size(); i++)\\n        {\\n            if(edges[i][2]==-1)\\n            {\\n                ll from_source = min(dp1[edges[i][0]],dp1[edges[i][1]]);\\n                ll from_destination = min(dp2[edges[i][0]], dp2[edges[i][1]]);\\n                int val = target -from_source-from_destination;\\n            // if val>0 ==> target have been reached \\n                if(val>0)\\n                {\\n                    edges[i][2]=val;\\n                }\\n                else\\n                {\\n                    // Singly converting him will not make target  so lets take it minimum\\n                    edges[i][2]=1;\\n                }\\n            }\\n        }\\n        return edges;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nusing  ll = long long int ;\\nclass Solution {\\npublic:\\n    // BFS and Dikeshtra\\'s algorithm \\n    void Dikeshtra(int n ,vector<vector<pair<ll,ll>>>& adj, int source , vector<ll>&dp )\\n    {\\n        priority_queue<pair<ll,ll> , vector<pair<ll,ll>> , greater<pair<ll,ll>>> pq ; \\n       \\n        pq.push({0 , source});\\n        dp[source]=0;\\n        while(!pq.empty())\\n        {\\n            ll dis = pq.top().first;\\n            ll ind = pq.top().second ;\\n            pq.pop() ;\\n            for(int j =0 ;j<adj[ind].size() ;j++)\\n            {\\n                ll val =adj[ind][j].second;\\n                ll new_dis= dis+val;\\n                if(new_dis<dp[adj[ind][j].first])\\n                {\\n                    dp[adj[ind][j].first]=new_dis;\\n                    pq.push({new_dis, adj[ind][j].first});\\n                } \\n            }\\n        }\\n    }\\n    // Converting all -1 edges to max or 1\\n    //Assigning values when got the destination \\n    void assign(vector<vector<int>>& edges , int with )\\n    {\\n        for( int i =0 ;i<edges.size(); i++)\\n        {\\n            if(edges[i][2]==-1)\\n            {\\n                edges[i][2]=with;\\n            }\\n        }\\n    }\\n    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int source, int destination, int target) {\\n      // two adjacency list one for minmum and other maximum\\n        vector<vector<pair<ll,ll>>> adj (n) , r_adj(n);\\n        for( int i =0 ;i<edges.size() ;i++)\\n        {\\n            ll val = edges[i][2] , value= edges[i][2];\\n            if(edges[i][2]==-1)\\n            {\\n                val= 1;\\n                value =2e9;\\n            }\\n            adj[edges[i][0]].push_back({edges[i][1] ,val});\\n            adj[edges[i][1]].push_back({edges[i][0] , val});\\n            r_adj[edges[i][0]].push_back({edges[i][1] , value});\\n            r_adj[edges[i][1]].push_back({edges[i][0] , value});\\n        } \\n        // for storing the paths dp1(from source) && dp1(from destination)\\n        vector<long long > dp1(n ,INT_MAX) , dp2(n , INT_MAX);\\n\\n        Dikeshtra(n , adj, source ,dp1);\\n        //EDGE CASES BEEN handled here \\n        if(dp1[destination]>target)\\n        {\\n            return {};\\n        }\\n        // If dp[destination]== target return edgesy converting them as1 the -1 weight obviously\\n        if(dp1[destination]==target)\\n        {\\n            assign(edges, 1);\\n            return edges;\\n        }\\n        //if_not \\n        Dikeshtra(n , r_adj , destination , dp2);\\n        if(dp2[source]<target)\\n        {\\n            return {};\\n        }\\n        if(dp2[source]==target)\\n        {\\n            assign(edges, 1e9);\\n            return edges;\\n        }\\n        // Edge cases have been taken care above \\n        // Rest :\\n        for(int i =0 ;i<edges.size(); i++)\\n        {\\n            if(edges[i][2]==-1)\\n            {\\n                ll from_source = min(dp1[edges[i][0]],dp1[edges[i][1]]);\\n                ll from_destination = min(dp2[edges[i][0]], dp2[edges[i][1]]);\\n                int val = target -from_source-from_destination;\\n            // if val>0 ==> target have been reached \\n                if(val>0)\\n                {\\n                    edges[i][2]=val;\\n                }\\n                else\\n                {\\n                    // Singly converting him will not make target  so lets take it minimum\\n                    edges[i][2]=1;\\n                }\\n            }\\n        }\\n        return edges;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3548772,
                "title": "java-dijkstra",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n##### \\u2022\\tThe problem requires modifying the weights of some edges in an undirected weighted connected to achieve a target shortest path between two nodes\\n##### \\u2022\\tThe approach use to first find the shortest path between the source and destination nodes using Dijkstra\\'s algorithm\\n##### \\u2022\\tIf the shortest path is greater than the target, the problem is unsolvable\\n##### \\u2022\\tIf the shortest path is equal to the target, the function returns the original graph with the modified and unmodified edges\\n##### \\u2022\\tIf the shortest path is less than the target, the function repeatedly modifies the first edge in the shortest path that can be modified to increase the shortest path\\n##### \\u2022\\tIt then recalculates the shortest path using Dijkstra\\'s algorithm and repeats the process until the shortest path is equal to the target or greater than the target\\n##### \\u2022\\tThe intuition behind the approach is that modifying an edge with weight -1 to a positive integer value will increase the shortest path between the source and destination nodes\\n##### \\u2022\\tBy repeatedly modifying the first edge in the shortest path that can be modified, the algorithm can gradually increase the shortest path until it reaches the target\\n##### \\u2022\\tThe algorithm terminates when the shortest path is equal to the target or greater than the target, or when there are no more edges that can be modified\\n##### \\u2022\\tThe use an adjacency matrix to represent the graph and implements Dijkstra\\'s algorithm using a priority queue\\n##### \\u2022\\tThe findFirstModifieableIndex function iterates over the nodes in the shortest path and returns the first edge that can be modified\\n##### \\u2022\\tThe fill function constructs an array of edges from the adjacency matrix, where each edge is represented as an array of three integers: the source node, the destination node, and the weight of the edge\\n##### \\u2022\\tThe Pair class is a simple class that contains two fields: the weight of a path and the parent array of the path\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n##### \\u2022\\tUse an adjacency matrix to represent the graph\\n##### \\u2022\\tThe adjacency matrix a two-dimensional array where the value of adj[i][j] represents the weight of the edge between nodes i and j\\n##### \\u2022\\tIf there is no edge between nodes i and j, the value of adj[i][j] is 0\\n##### \\u2022\\tThe modifiedGraphEdges function takes the number of nodes n, the array of edges edges, the source and destination nodes, and the target shortest path as input\\n##### \\u2022\\tIt first constructs the adjacency matrix from the array of edges\\n##### \\u2022\\tIt then uses Dijkstra\\'s algorithm to find the shortest path between the source and destination nodes\\n##### \\u2022\\tIf the shortest path is greater than the target, the function returns an empty array, as it is impossible to modify the edges to achieve the target shortest path\\n##### \\u2022\\tIf the shortest path is equal to the target, the function returns the original graph with the modified and unmodified edges\\n##### \\u2022\\tIf the shortest path is less than the target, the function repeatedly modifies the first edge in the shortest path that can be modified to increase the shortest path\\n##### \\u2022\\tIt then recalculates the shortest path using Dijkstra\\'s algorithm and repeats the process until the shortest path is equal to the target or greater than the target\\n##### \\u2022\\tThe findFirstModifieableIndex function takes the parent array of the shortest path, the destination and source nodes, and the adjacency matrix as input\\n##### \\u2022\\tIt first constructs a list of nodes in the shortest path from the source to the destination\\n##### \\u2022\\tIt then iterates over the list and returns the first edge that can be modified to increase the shortest path\\n##### \\u2022\\tThe fill function takes the adjacency matrix as input and returns an array of edges, where each edge is represented as an array of three integers: the source node, the destination node, and the weight of the edge\\n##### \\u2022\\tIf the weight of an edge is -1, it is replaced with 1\\n##### \\u2022\\tThe findPath function takes the adjacency matrix, the source and destination nodes, and the target shortest path as input\\n##### \\u2022\\tIt uses Dijkstra\\'s algorithm to find the shortest path between the source and destination nodes\\n##### \\u2022\\tIf the shortest path is greater than the target, the function returns null\\n##### \\u2022\\tOtherwise, it returns a Pair object containing the weight of the shortest path and the parent array of the path\\n##### \\u2022\\tThe Pair class is a simple class that contains two fields: the weight of a path and the parent array of the path\\n\\n\\n# Complexity\\nTime Complexity: The time complexity of the solution is O(ElogV), E is the number of edges and V is the number of vertices in the graph. This is because the solution uses Dijkstra\\'s algorithm to find the shortest path, which has a time complexity of O(ElogV). The solution also iterates over the edges to modify them, which takes O(E) time.\\n\\nSpace Complexity: The space complexity of the solution is O(V^2), where V is the number of vertices in the graph. This is because the solution uses an adjacency matrix to represent the graph, which requires O(V^2) space. The solution also uses arrays and lists to store intermediate results, which require additional space. However, the space complexity is dominated by the adjacency matrix.\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] modifiedGraphEdges(int n, int[][] edges, int source, int destination, int target) {\\n        int adj[][] = new int[n][n];\\n        for(int i [] :edges){\\n            int a = i[0];\\n            int b = i[1];\\n            int w = i[2];\\n            adj[a][b] = w;\\n            adj[b][a] = w;\\n        }\\n        Pair shortestPath = findPath(adj, source, destination, target); \\n        if(shortestPath == null){\\n            return new int[][]{};\\n        }else if(shortestPath.w == target){\\n            return fill(adj);\\n        }else{\\n            while(true){\\n                int []curr = findFirstModifieableIndex(shortestPath.parent, destination, source, adj);\\n                if(curr == null){\\n                    return new int[][]{};\\n                }\\n                adj[curr[0]][curr[1]] = target-shortestPath.w+1;\\n                adj[curr[1]][curr[0]] = target-shortestPath.w+1;\\n                shortestPath = findPath(adj,source,destination, target);\\n                if(shortestPath.w == target){\\n                    return fill(adj);\\n                }else if(shortestPath.w>target){\\n                    return new int[][]{};\\n                }\\n            }\\n        }    \\n    }\\n    \\n    int[] findFirstModifieableIndex(int []parent, int dest, int source, int adj[][]){\\n        List<Integer> list = new ArrayList<>();\\n        int curr = dest;\\n        while(curr!=-1){\\n            list.add(curr);\\n            curr = parent[curr];\\n        }\\n        Collections.reverse(list);\\n        for(int i = 0;i<list.size()-1;i++){\\n            int v = list.get(i);\\n            int v2 = list.get(i+1);\\n            if(adj[v][v2]==-1){\\n                return new int[]{v,v2};\\n            }\\n        }\\n        return null;\\n    }\\n    \\n    \\n    int[][] fill(int [][] adj){\\n        int n = adj.length;\\n        List<int[]> list = new ArrayList<>();\\n        for(int i = 0;i<n;i++){\\n            for(int j = i+1;j<n;j++){\\n                if(adj[i][j]!=0){\\n                    int c = adj[i][j];\\n                    if(c==-1){\\n                        c = 1;\\n                    }\\n                    list.add(new int[]{i,j,c});\\n                }\\n            }\\n        }\\n        int res[][] = new int[list.size()][3];\\n        for(int i = 0;i<list.size();i++){\\n            res[i] = list.get(i);\\n        }\\n        return res;\\n    }\\n    Pair findPath(int[][] adj, int source, int destination, int target){\\n        int n = adj.length;\\n        int dist[] = new int[n];\\n        int parent[] = new int[n];\\n        Arrays.fill(dist,Integer.MAX_VALUE);\\n        Arrays.fill(parent,-1);\\n        dist[source ] = 0;\\n        parent[source] = -1;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)->a[1]-b[1]);\\n        pq.offer(new int[]{source,dist[source]});\\n        while(!pq.isEmpty()){\\n            int curr [] = pq.poll();\\n            int c = curr[0], w = curr[1];\\n            if(w>target){\\n                \\n                return null;\\n            }\\n            if(c==destination){\\n                return new Pair(w,parent);\\n            }\\n            for(int i = 0;i<n;i++){\\n                if(adj[c][i] != 0 ){\\n                    int nw = adj[c][i];\\n                    if(nw == -1){\\n                        nw = 1;\\n                    }\\n                    if(nw + w < dist[i]){\\n                        dist[i] = nw+w;\\n                        parent[i] = c;\\n                        pq.offer(new int[]{i, dist[i]});\\n                    }\\n                }\\n            }\\n        }\\n        return null;\\n    }\\n    class Pair{\\n        int w;\\n        int[] parent;\\n        Pair(int w, int [] parent){\\n            this.w = w;\\n            this.parent = parent;\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] modifiedGraphEdges(int n, int[][] edges, int source, int destination, int target) {\\n        int adj[][] = new int[n][n];\\n        for(int i [] :edges){\\n            int a = i[0];\\n            int b = i[1];\\n            int w = i[2];\\n            adj[a][b] = w;\\n            adj[b][a] = w;\\n        }\\n        Pair shortestPath = findPath(adj, source, destination, target); \\n        if(shortestPath == null){\\n            return new int[][]{};\\n        }else if(shortestPath.w == target){\\n            return fill(adj);\\n        }else{\\n            while(true){\\n                int []curr = findFirstModifieableIndex(shortestPath.parent, destination, source, adj);\\n                if(curr == null){\\n                    return new int[][]{};\\n                }\\n                adj[curr[0]][curr[1]] = target-shortestPath.w+1;\\n                adj[curr[1]][curr[0]] = target-shortestPath.w+1;\\n                shortestPath = findPath(adj,source,destination, target);\\n                if(shortestPath.w == target){\\n                    return fill(adj);\\n                }else if(shortestPath.w>target){\\n                    return new int[][]{};\\n                }\\n            }\\n        }    \\n    }\\n    \\n    int[] findFirstModifieableIndex(int []parent, int dest, int source, int adj[][]){\\n        List<Integer> list = new ArrayList<>();\\n        int curr = dest;\\n        while(curr!=-1){\\n            list.add(curr);\\n            curr = parent[curr];\\n        }\\n        Collections.reverse(list);\\n        for(int i = 0;i<list.size()-1;i++){\\n            int v = list.get(i);\\n            int v2 = list.get(i+1);\\n            if(adj[v][v2]==-1){\\n                return new int[]{v,v2};\\n            }\\n        }\\n        return null;\\n    }\\n    \\n    \\n    int[][] fill(int [][] adj){\\n        int n = adj.length;\\n        List<int[]> list = new ArrayList<>();\\n        for(int i = 0;i<n;i++){\\n            for(int j = i+1;j<n;j++){\\n                if(adj[i][j]!=0){\\n                    int c = adj[i][j];\\n                    if(c==-1){\\n                        c = 1;\\n                    }\\n                    list.add(new int[]{i,j,c});\\n                }\\n            }\\n        }\\n        int res[][] = new int[list.size()][3];\\n        for(int i = 0;i<list.size();i++){\\n            res[i] = list.get(i);\\n        }\\n        return res;\\n    }\\n    Pair findPath(int[][] adj, int source, int destination, int target){\\n        int n = adj.length;\\n        int dist[] = new int[n];\\n        int parent[] = new int[n];\\n        Arrays.fill(dist,Integer.MAX_VALUE);\\n        Arrays.fill(parent,-1);\\n        dist[source ] = 0;\\n        parent[source] = -1;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)->a[1]-b[1]);\\n        pq.offer(new int[]{source,dist[source]});\\n        while(!pq.isEmpty()){\\n            int curr [] = pq.poll();\\n            int c = curr[0], w = curr[1];\\n            if(w>target){\\n                \\n                return null;\\n            }\\n            if(c==destination){\\n                return new Pair(w,parent);\\n            }\\n            for(int i = 0;i<n;i++){\\n                if(adj[c][i] != 0 ){\\n                    int nw = adj[c][i];\\n                    if(nw == -1){\\n                        nw = 1;\\n                    }\\n                    if(nw + w < dist[i]){\\n                        dist[i] = nw+w;\\n                        parent[i] = c;\\n                        pq.offer(new int[]{i, dist[i]});\\n                    }\\n                }\\n            }\\n        }\\n        return null;\\n    }\\n    class Pair{\\n        int w;\\n        int[] parent;\\n        Pair(int w, int [] parent){\\n            this.w = w;\\n            this.parent = parent;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547994,
                "title": "c-solution-shortest-path-algorithm",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>>dp[200];\\n    vector<int>find(int n,int src,int dist)\\n    {\\n        vector<int>dis(n+1,1e9+10);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        pq.push({0,src});\\n        dis[src]=0;\\n        vector<int>vis(n+10,0);\\n        while(pq.size())\\n        {\\n            auto [wt,node]=pq.top();\\n            pq.pop();\\n            if(vis[node])\\n            {\\n                continue;\\n            }\\n            vis[node]=1;\\n            for(auto &[current_node,current_wt]:dp[node])\\n            {\\n                if(dis[current_node]>current_wt+wt)\\n                {\\n                    dis[current_node]=current_wt+wt;\\n                    pq.push({dis[current_node],current_node});\\n                }\\n            }\\n        }\\n        return dis;\\n    }\\n    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int src, int dest, int target) \\n    {\\n        for(auto &it:edges)\\n        {\\n            if(it[2]==-1)\\n            {\\n                continue;\\n            }\\n            dp[it[0]].push_back({it[1],it[2]});\\n            dp[it[1]].push_back({it[0],it[2]});\\n        }\\n        vector<int>dist=find(n,src,dest);\\n        if(dist[dest]<target)\\n        {\\n            return {};\\n        }\\n       if(dist[dest]==target)\\n       {\\n           for(auto &it:edges)\\n           {\\n               if(it[2]==-1){\\n                   it[2]=2e9;\\n               }\\n           }\\n           return edges;\\n       }\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            int u=edges[i][0],v=edges[i][1],w=edges[i][2];\\n            if(w==-1)\\n            {\\n                edges[i][2]=1;\\n                dp[u].push_back({v,1});\\n                dp[v].push_back({u,1});\\n                vector<int>dis=find(n,src,dest);\\n                if(dis[dest]<=target)\\n                {\\n                    edges[i][2]+=(target-dis[dest]);\\n                    for(int j=i+1;j<edges.size();j++)\\n                    {\\n                        if(edges[j][2]==-1)\\n                        {\\n                            edges[j][2]=2e9;\\n                        }\\n                    }\\n                    return edges;\\n                }\\n            }\\n        }\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>>dp[200];\\n    vector<int>find(int n,int src,int dist)\\n    {\\n        vector<int>dis(n+1,1e9+10);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        pq.push({0,src});\\n        dis[src]=0;\\n        vector<int>vis(n+10,0);\\n        while(pq.size())\\n        {\\n            auto [wt,node]=pq.top();\\n            pq.pop();\\n            if(vis[node])\\n            {\\n                continue;\\n            }\\n            vis[node]=1;\\n            for(auto &[current_node,current_wt]:dp[node])\\n            {\\n                if(dis[current_node]>current_wt+wt)\\n                {\\n                    dis[current_node]=current_wt+wt;\\n                    pq.push({dis[current_node],current_node});\\n                }\\n            }\\n        }\\n        return dis;\\n    }\\n    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int src, int dest, int target) \\n    {\\n        for(auto &it:edges)\\n        {\\n            if(it[2]==-1)\\n            {\\n                continue;\\n            }\\n            dp[it[0]].push_back({it[1],it[2]});\\n            dp[it[1]].push_back({it[0],it[2]});\\n        }\\n        vector<int>dist=find(n,src,dest);\\n        if(dist[dest]<target)\\n        {\\n            return {};\\n        }\\n       if(dist[dest]==target)\\n       {\\n           for(auto &it:edges)\\n           {\\n               if(it[2]==-1){\\n                   it[2]=2e9;\\n               }\\n           }\\n           return edges;\\n       }\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            int u=edges[i][0],v=edges[i][1],w=edges[i][2];\\n            if(w==-1)\\n            {\\n                edges[i][2]=1;\\n                dp[u].push_back({v,1});\\n                dp[v].push_back({u,1});\\n                vector<int>dis=find(n,src,dest);\\n                if(dis[dest]<=target)\\n                {\\n                    edges[i][2]+=(target-dis[dest]);\\n                    for(int j=i+1;j<edges.size();j++)\\n                    {\\n                        if(edges[j][2]==-1)\\n                        {\\n                            edges[j][2]=2e9;\\n                        }\\n                    }\\n                    return edges;\\n                }\\n            }\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547681,
                "title": "dijkstra-c-commented-code",
                "content": "## Do consider upvoting if it adds value\\uD83D\\uDCA1 !\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int source, int destination, int target) {\\n\\n        vector<vector<pair<int,int>>> adj(n);\\n\\n        //excluding edges with weight = -1\\n        for(auto e: edges){\\n            if(e[2]!=-1){\\n                adj[e[0]].push_back({e[1],e[2]});\\n                adj[e[1]].push_back({e[0],e[2]});\\n            }\\n        }\\n\\n        //Dijkstra for shortest path\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> q;\\n        q.push({0,source});\\n        vector<int> dis(n,1e9);\\n        dis[source]=0;\\n        while(!q.empty()){\\n            int curr_dis=q.top().first;\\n            int u=q.top().second;\\n            q.pop();\\n            if(u==destination){\\n                break;\\n            }\\n            for(auto nbr : adj[u]){\\n                int v=nbr.first;\\n                int wt=nbr.second;\\n                if(curr_dis+wt<dis[v]){\\n                    dis[v]=curr_dis+wt;\\n                    q.push({dis[v],v});\\n                }\\n            }\\n        }\\n\\n        //if shortest path < target , then return empty array\\n        if(dis[destination]<target){\\n            return {};\\n        }\\n\\n        //if shortest path is equal to target\\n        if(dis[destination]==target){\\n            for(auto &e : edges){\\n                if(e[2]==-1){\\n                    e[2]=1e9;\\n                }\\n            }\\n            return edges;\\n        }\\n\\n\\n        // Now changing weight of each edge with weight -1 to 1 one by one and trying to get shortest path\\n        for(int i=0 ; i<edges.size() ; i++){\\n            auto &e=edges[i];\\n            if(e[2]==-1){\\n\\n                //change weight to 1\\n                e[2]=1;\\n                adj[e[1]].push_back({e[0],1});\\n                adj[e[0]].push_back({e[1],1});\\n                while(!q.empty()){\\n                    q.pop();\\n                }\\n\\n                //Dijkstra \\n                q.push({0,source});\\n                vector<int> dis(n,1e9);\\n                dis[source]=0;\\n                while(!q.empty()){\\n                    int curr_dis=q.top().first;\\n                    int u=q.top().second;\\n                    q.pop();\\n                    if(u==destination){\\n                        break;\\n                    }\\n                    for(auto nbr : adj[u]){\\n                        int v=nbr.first;\\n                        int wt=nbr.second;\\n                        if(curr_dis+wt<dis[v]){\\n                            dis[v]=curr_dis+wt;\\n                            q.push({dis[v],v});\\n                        }\\n                    }\\n                }\\n\\n                //adding appropriate weight to get target\\n                if(dis[destination]<=target){\\n                    e[2]+=target-dis[destination];\\n\\n                    //rest edges with weight=-1 set to 1e9\\n                    for(int j=i+1 ; j<edges.size() ; j++){\\n                        if(edges[j][2]==-1){\\n                            edges[j][2]=1e9;\\n                        }\\n                    }\\n                    return edges;\\n                }\\n            }\\n        }\\n\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int source, int destination, int target) {\\n\\n        vector<vector<pair<int,int>>> adj(n);\\n\\n        //excluding edges with weight = -1\\n        for(auto e: edges){\\n            if(e[2]!=-1){\\n                adj[e[0]].push_back({e[1],e[2]});\\n                adj[e[1]].push_back({e[0],e[2]});\\n            }\\n        }\\n\\n        //Dijkstra for shortest path\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> q;\\n        q.push({0,source});\\n        vector<int> dis(n,1e9);\\n        dis[source]=0;\\n        while(!q.empty()){\\n            int curr_dis=q.top().first;\\n            int u=q.top().second;\\n            q.pop();\\n            if(u==destination){\\n                break;\\n            }\\n            for(auto nbr : adj[u]){\\n                int v=nbr.first;\\n                int wt=nbr.second;\\n                if(curr_dis+wt<dis[v]){\\n                    dis[v]=curr_dis+wt;\\n                    q.push({dis[v],v});\\n                }\\n            }\\n        }\\n\\n        //if shortest path < target , then return empty array\\n        if(dis[destination]<target){\\n            return {};\\n        }\\n\\n        //if shortest path is equal to target\\n        if(dis[destination]==target){\\n            for(auto &e : edges){\\n                if(e[2]==-1){\\n                    e[2]=1e9;\\n                }\\n            }\\n            return edges;\\n        }\\n\\n\\n        // Now changing weight of each edge with weight -1 to 1 one by one and trying to get shortest path\\n        for(int i=0 ; i<edges.size() ; i++){\\n            auto &e=edges[i];\\n            if(e[2]==-1){\\n\\n                //change weight to 1\\n                e[2]=1;\\n                adj[e[1]].push_back({e[0],1});\\n                adj[e[0]].push_back({e[1],1});\\n                while(!q.empty()){\\n                    q.pop();\\n                }\\n\\n                //Dijkstra \\n                q.push({0,source});\\n                vector<int> dis(n,1e9);\\n                dis[source]=0;\\n                while(!q.empty()){\\n                    int curr_dis=q.top().first;\\n                    int u=q.top().second;\\n                    q.pop();\\n                    if(u==destination){\\n                        break;\\n                    }\\n                    for(auto nbr : adj[u]){\\n                        int v=nbr.first;\\n                        int wt=nbr.second;\\n                        if(curr_dis+wt<dis[v]){\\n                            dis[v]=curr_dis+wt;\\n                            q.push({dis[v],v});\\n                        }\\n                    }\\n                }\\n\\n                //adding appropriate weight to get target\\n                if(dis[destination]<=target){\\n                    e[2]+=target-dis[destination];\\n\\n                    //rest edges with weight=-1 set to 1e9\\n                    for(int j=i+1 ; j<edges.size() ; j++){\\n                        if(edges[j][2]==-1){\\n                            edges[j][2]=1e9;\\n                        }\\n                    }\\n                    return edges;\\n                }\\n            }\\n        }\\n\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3560535,
                "title": "c-solution-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dijkstra(int source, int destination, vector<vector<pair<int, int>>> &adj){\\n        vector<int> dist(adj.size(), INT_MAX);\\n        dist[source] = 0; \\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq; // {dist, node}\\n        pq.push({0, source});\\n        while (!pq.empty()){\\n            auto front = pq.top(); \\n            pq.pop(); \\n            int node = front.second;\\n            // int currdist = front.first; \\n            for (auto it: adj[node]){\\n                int neigh = it.first; \\n                int nwt = it.second; \\n                if (dist[node] + nwt < dist[neigh]){\\n                    dist[neigh] = dist[node] + nwt; \\n                    pq.push({dist[neigh], neigh});\\n                }\\n            }\\n        }\\n        return dist[destination];\\n    }\\n\\n    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int source, int destination, int target) {\\n        // first we will find the distance b/w source and destination without considering the negative edges\\n        // if the distance comes out to be less than target then return empty list\\n        // else now we will pick negative edges 1 by one and add it to the graph and apply shortest distance algo (dijkstra) and find the shortest distance if it comes out to be less than target than just update the value of the edge picked and do it for all the edges \\n        // agar abhi tak nhi mila toh return empty list \\n\\n        // main intuition or though process was that: we should first not consider the negative edges and add them one by one\\n\\n        vector<vector<pair<int, int>>> adj(n); \\n        for (auto it: edges){\\n            int wt = it[2]; \\n            if (wt == -1) continue; \\n            int u = it[0];\\n            int v = it[1];\\n            adj[u].push_back({v, wt});\\n            adj[v].push_back({u, wt});\\n        }\\n\\n        // now apply dijkstra\\n        int shortestPath = dijkstra(source, destination, adj);\\n        if (shortestPath < target){\\n            return {};\\n        }\\n        if (shortestPath == target){\\n            for (int i = 0; i<edges.size(); i++){\\n                int wt = edges[i][2];\\n                if (wt == -1){\\n                    edges[i][2] = 1e9; \\n                }\\n            }\\n            return edges; \\n        }\\n\\n        for (int i = 0; i<edges.size(); i++){\\n            int wt = edges[i][2];\\n            if (wt == -1){\\n                edges[i][2] = 1;\\n                int u = edges[i][0];\\n                int v = edges[i][1];\\n                adj[u].push_back({v, 1});\\n                adj[v].push_back({u, 1}); \\n                int shortestPath = dijkstra(source, destination, adj);\\n                if (shortestPath <= target){\\n                    edges[i][2] += (target - shortestPath);\\n                    for (int j = 0; j<edges.size(); j++){\\n                        int wt = edges[j][2];\\n                        if (wt == -1){\\n                            edges[j][2] = 1e9; \\n                        }\\n                    }\\n                    return edges;\\n                }\\n            }\\n        }\\n\\n        return {};\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Heap (Priority Queue)",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dijkstra(int source, int destination, vector<vector<pair<int, int>>> &adj){\\n        vector<int> dist(adj.size(), INT_MAX);\\n        dist[source] = 0; \\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq; // {dist, node}\\n        pq.push({0, source});\\n        while (!pq.empty()){\\n            auto front = pq.top(); \\n            pq.pop(); \\n            int node = front.second;\\n            // int currdist = front.first; \\n            for (auto it: adj[node]){\\n                int neigh = it.first; \\n                int nwt = it.second; \\n                if (dist[node] + nwt < dist[neigh]){\\n                    dist[neigh] = dist[node] + nwt; \\n                    pq.push({dist[neigh], neigh});\\n                }\\n            }\\n        }\\n        return dist[destination];\\n    }\\n\\n    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int source, int destination, int target) {\\n        // first we will find the distance b/w source and destination without considering the negative edges\\n        // if the distance comes out to be less than target then return empty list\\n        // else now we will pick negative edges 1 by one and add it to the graph and apply shortest distance algo (dijkstra) and find the shortest distance if it comes out to be less than target than just update the value of the edge picked and do it for all the edges \\n        // agar abhi tak nhi mila toh return empty list \\n\\n        // main intuition or though process was that: we should first not consider the negative edges and add them one by one\\n\\n        vector<vector<pair<int, int>>> adj(n); \\n        for (auto it: edges){\\n            int wt = it[2]; \\n            if (wt == -1) continue; \\n            int u = it[0];\\n            int v = it[1];\\n            adj[u].push_back({v, wt});\\n            adj[v].push_back({u, wt});\\n        }\\n\\n        // now apply dijkstra\\n        int shortestPath = dijkstra(source, destination, adj);\\n        if (shortestPath < target){\\n            return {};\\n        }\\n        if (shortestPath == target){\\n            for (int i = 0; i<edges.size(); i++){\\n                int wt = edges[i][2];\\n                if (wt == -1){\\n                    edges[i][2] = 1e9; \\n                }\\n            }\\n            return edges; \\n        }\\n\\n        for (int i = 0; i<edges.size(); i++){\\n            int wt = edges[i][2];\\n            if (wt == -1){\\n                edges[i][2] = 1;\\n                int u = edges[i][0];\\n                int v = edges[i][1];\\n                adj[u].push_back({v, 1});\\n                adj[v].push_back({u, 1}); \\n                int shortestPath = dijkstra(source, destination, adj);\\n                if (shortestPath <= target){\\n                    edges[i][2] += (target - shortestPath);\\n                    for (int j = 0; j<edges.size(); j++){\\n                        int wt = edges[j][2];\\n                        if (wt == -1){\\n                            edges[j][2] = 1e9; \\n                        }\\n                    }\\n                    return edges;\\n                }\\n            }\\n        }\\n\\n        return {};\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549995,
                "title": "intuition-approach-easy-explanation-modified-dijkstra-s-algo-java",
                "content": "# Intuition\\nIn the given problem we need to find **shortest distance** between **two node**. Hence, we can use ``Dijkstra\\'s Algorithm``.\\n\\n# Approach\\nIn the Question it is written that our task is to modify edge weight(wt) with ``wt==-1`` such that **distance** between source and destination node become **minimum** i.e. equal to **target**.\\n\\n**Edge Case:**\\n- What if without modifying the edge ``wt==-1`` the shortest distance came out to be smaller than target. Then in any how we cannot make target as smallest distance.\\n- What if ``-1`` does not exist. Then we cannot modify array to make shortest distance equals to target.\\n- What if even after modifying edges with `wt == -1` shortest distance between source to destination came out to be greater than target. Then we can\\'t make src to dest shortest distance equal to target.\\n\\n**Steps:**\\nObviously, we cannot use simple ``Dijkstra\\'s algorithm``. We need to divide the problem into two parts:\\n1. First Part: In the code, FIRST PART handles first edge case.\\n    Let shortest distance (without modifying ``wt``) came out to be ``d``.\\n    - if ``d < target`` then it is impossible to make the shortest distance equals to target (Remember, we can only modify edge with ``wt==-1``).    return ``[]``\\n    - if ``d == target`` then we can use any value in range [1, 2*10^9] to replace the -ve edge wt.\\n    return ``edges``\\n\\n2. Second Part: In the code, SECOND PART handles second edge case  \\n    and does modification.\\n    - if ``-1`` does not exists then no modification can be done to make smallest distance equal to target.\\n    return ``[]``\\n    - Iteratively, one by one modify -ve edge ``wt==-1`` to ``wt=1`` and then apply ``Dijkstra\\'s Algorithm``. At the end of each iteration, check if the distance between source and destination node (``d``) is less than equal to target ``d <= target``, then it might be one of the path to make smallest distance equals to target. There can be multiple path therefore, we need to modify each and every -ve edge ``wt`` accordingly. Hence, we keep iterating and modifying each and every -ve edge ``wt``. \\n    return ``edges``.\\n    \\n\\n# Complexity\\n- Time complexity:\\n$$O(eElogV)$$ where, e is the number of edge ``wt==-1``\\n\\n- Space complexity:\\n$$O(V + E)$$\\n\\n# Code\\n```\\nimport java.util.*;\\n\\nclass Pair{\\n    int val;\\n    long wt;\\n    Pair(int v, long w){\\n        val = v;\\n        wt = w;\\n    }\\n}\\nclass Solution {\\n    long inf = 1000000007;\\n    public HashMap<Integer, List<Pair>> getAdj(int edges[][]){\\n        HashMap<Integer, List<Pair>> map = new HashMap<Integer, List<Pair>>();\\n        for(int edge[]: edges){\\n            if(edge[2]==-1) continue;\\n            if(map.get(edge[0])==null) map.put(edge[0], new ArrayList<Pair>());\\n            if(map.get(edge[1])==null) map.put(edge[1], new ArrayList<Pair>());\\n            map.get(edge[0]).add(new Pair(edge[1], edge[2]));\\n            map.get(edge[1]).add(new Pair(edge[0], edge[2]));\\n        }\\n\\n        return map;\\n    }\\n    public int[][] modifiedGraphEdges(int n, int[][] edges, int source, int destination, int target) {\\n        HashMap<Integer, List<Pair>> adj = getAdj(edges);\\n        PriorityQueue<Pair> pq = new PriorityQueue<Pair>((Pair p1, Pair p2)->(int)p1.wt-(int)p2.wt);\\n        long dist[] = new long[n];\\n\\n        //              _____FIRST___PART_____\\n        Arrays.fill(dist, inf);\\n\\n        dist[source] = 0;\\n        pq.add(new Pair(source, 0));\\n        \\n        while(!pq.isEmpty()){\\n            int node = pq.poll().val;\\n\\n            if(adj.get(node)==null) continue;\\n            for(Pair p: adj.get(node)){\\n                long d = dist[node] + p.wt;\\n                if(d<dist[p.val]){\\n                    dist[p.val] = d;\\n                    pq.add(new Pair(p.val, d));\\n                }\\n            }\\n        }\\n\\n        if(dist[destination]<target) return new int[0][0];\\n\\n        if(dist[destination]==target){\\n            for(int edge[]: edges){\\n                if(edge[2]==-1) edge[2] = 1000000005;\\n            }\\n            \\n            return edges;\\n        }\\n\\n        // ___CHECK__IF__-1___EXIST \\n        boolean in = false;\\n\\n        //                _______SECOND______PART________\\n        for(int edge[]: edges){\\n            if(edge[2]==-1){\\n                in = true;\\n                if(adj.get(edge[1])==null) adj.put(edge[1], new ArrayList<Pair>());\\n                if(adj.get(edge[0])==null) adj.put(edge[0], new ArrayList<Pair>());\\n                adj.get(edge[0]).add(new Pair(edge[1], 1));\\n                adj.get(edge[1]).add(new Pair(edge[0], 1));\\n                Arrays.fill(dist, inf);\\n                dist[source] = 0;\\n                pq.add(new Pair(source, 0));\\n\\n                while(!pq.isEmpty()){\\n                    int node = pq.poll().val;\\n\\n                    if(adj.get(node)==null) continue;\\n                    for(Pair p: adj.get(node)){\\n                        long d = dist[node] + p.wt;\\n                        if(d<dist[p.val]){\\n                            dist[p.val] = d;\\n                            pq.add(new Pair(p.val, d));\\n                        }\\n                    }\\n                }\\n              \\n                if(dist[destination]<=target){\\n                    edge[2] = (int)((long)target - (long)dist[destination] + 1 );\\n                }\\n\\n                if(edge[2]==-1) edge[2] = 1;\\n            }\\n        }\\n        \\n        //________IF__SHORTEST_SRC_TO_DEST__DISTANCE_>_TARGET____3RD__EDGE_CASE__\\n        // What if even after modifying edges with wt == -1 dist[src->dest] > target\\n        if(dist[destination]>target) return new int[0][0]; // we can\\'t get dist[src->dest] == target\\n        \\n        //_____IF__-1__NOT_EXIST_RETURN__EMPTY__ARR___ELSE___MODIFIED__EDGES____\\n        return !in? new int[0][0]: edges;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Graph",
                    "Heap (Priority Queue)",
                    "Shortest Path"
                ],
                "code": "```\\nimport java.util.*;\\n\\nclass Pair{\\n    int val;\\n    long wt;\\n    Pair(int v, long w){\\n        val = v;\\n        wt = w;\\n    }\\n}\\nclass Solution {\\n    long inf = 1000000007;\\n    public HashMap<Integer, List<Pair>> getAdj(int edges[][]){\\n        HashMap<Integer, List<Pair>> map = new HashMap<Integer, List<Pair>>();\\n        for(int edge[]: edges){\\n            if(edge[2]==-1) continue;\\n            if(map.get(edge[0])==null) map.put(edge[0], new ArrayList<Pair>());\\n            if(map.get(edge[1])==null) map.put(edge[1], new ArrayList<Pair>());\\n            map.get(edge[0]).add(new Pair(edge[1], edge[2]));\\n            map.get(edge[1]).add(new Pair(edge[0], edge[2]));\\n        }\\n\\n        return map;\\n    }\\n    public int[][] modifiedGraphEdges(int n, int[][] edges, int source, int destination, int target) {\\n        HashMap<Integer, List<Pair>> adj = getAdj(edges);\\n        PriorityQueue<Pair> pq = new PriorityQueue<Pair>((Pair p1, Pair p2)->(int)p1.wt-(int)p2.wt);\\n        long dist[] = new long[n];\\n\\n        //              _____FIRST___PART_____\\n        Arrays.fill(dist, inf);\\n\\n        dist[source] = 0;\\n        pq.add(new Pair(source, 0));\\n        \\n        while(!pq.isEmpty()){\\n            int node = pq.poll().val;\\n\\n            if(adj.get(node)==null) continue;\\n            for(Pair p: adj.get(node)){\\n                long d = dist[node] + p.wt;\\n                if(d<dist[p.val]){\\n                    dist[p.val] = d;\\n                    pq.add(new Pair(p.val, d));\\n                }\\n            }\\n        }\\n\\n        if(dist[destination]<target) return new int[0][0];\\n\\n        if(dist[destination]==target){\\n            for(int edge[]: edges){\\n                if(edge[2]==-1) edge[2] = 1000000005;\\n            }\\n            \\n            return edges;\\n        }\\n\\n        // ___CHECK__IF__-1___EXIST \\n        boolean in = false;\\n\\n        //                _______SECOND______PART________\\n        for(int edge[]: edges){\\n            if(edge[2]==-1){\\n                in = true;\\n                if(adj.get(edge[1])==null) adj.put(edge[1], new ArrayList<Pair>());\\n                if(adj.get(edge[0])==null) adj.put(edge[0], new ArrayList<Pair>());\\n                adj.get(edge[0]).add(new Pair(edge[1], 1));\\n                adj.get(edge[1]).add(new Pair(edge[0], 1));\\n                Arrays.fill(dist, inf);\\n                dist[source] = 0;\\n                pq.add(new Pair(source, 0));\\n\\n                while(!pq.isEmpty()){\\n                    int node = pq.poll().val;\\n\\n                    if(adj.get(node)==null) continue;\\n                    for(Pair p: adj.get(node)){\\n                        long d = dist[node] + p.wt;\\n                        if(d<dist[p.val]){\\n                            dist[p.val] = d;\\n                            pq.add(new Pair(p.val, d));\\n                        }\\n                    }\\n                }\\n              \\n                if(dist[destination]<=target){\\n                    edge[2] = (int)((long)target - (long)dist[destination] + 1 );\\n                }\\n\\n                if(edge[2]==-1) edge[2] = 1;\\n            }\\n        }\\n        \\n        //________IF__SHORTEST_SRC_TO_DEST__DISTANCE_>_TARGET____3RD__EDGE_CASE__\\n        // What if even after modifying edges with wt == -1 dist[src->dest] > target\\n        if(dist[destination]>target) return new int[0][0]; // we can\\'t get dist[src->dest] == target\\n        \\n        //_____IF__-1__NOT_EXIST_RETURN__EMPTY__ARR___ELSE___MODIFIED__EDGES____\\n        return !in? new int[0][0]: edges;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549594,
                "title": "video-explanation-n-4-logn-n-2-logn-logn-n-2-logn",
                "content": "# Explanation\\n\\nhttps://youtu.be/FRA45jbiGwc\\n\\n[Click here if the preview above doesn\\'t works](https://youtu.be/FRA45jbiGwc)\\n\\n# Code\\n```\\n#define pii pair<int, int>\\n#define F first\\n#define S second\\n\\ntypedef long long int ll;\\nconst int INF = 2e9;\\n\\nclass Solution {\\n    \\n    vector<vector<pii>> g;\\n    \\n    void Dijkstra (int n, int src, vector<int>& parent, vector<int>& dist) {\\n        parent.clear(), dist.clear();\\n        parent.resize(n, -1), dist.resize(n, INF);\\n        parent[src] = src;\\n        dist[src] = 0;\\n        \\n        set<pii> all;\\n        for (int j = 0; j < n; j ++) all.insert({dist[j], j});\\n        \\n        while (!all.empty()) {\\n            int node = all.begin() -> S;\\n            all.erase(all.begin());\\n            \\n            for (auto edge: g[node]) {\\n                ll dist_through_node = (ll)dist[node] + edge.S;\\n                if ((ll)dist[edge.F] <= dist_through_node) continue;\\n                \\n                all.erase({dist[edge.F], edge.F});\\n                dist[edge.F] = dist_through_node;\\n                parent[edge.F] = node;\\n                all.insert({dist[edge.F], edge.F});\\n            }\\n        }\\n    }\\n    \\n    int Check (int ind, const vector<pii>& negative_edges, int src, int dst, const vector<vector<int>>& all_edges, const int n) {\\n        g.clear(), g.resize(n);\\n        for (int j = 0; j < ind; j ++) {\\n            g[negative_edges[j].F].push_back({negative_edges[j].S, 1});\\n            g[negative_edges[j].S].push_back({negative_edges[j].F, 1});\\n        }\\n        for (auto e : all_edges) {\\n            if (e[2] == -1) continue;\\n            g[e[0]].push_back({e[1], e[2]});\\n            g[e[1]].push_back({e[0], e[2]});\\n        }\\n        \\n        vector<int> parent, dist;\\n        Dijkstra (n, src, parent, dist);\\n        return dist[dst];\\n    }\\n    \\npublic:\\n    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int source, int destination, int target) {\\n        vector<pii> negative_edges;\\n        \\n        g.clear(), g.resize(n);\\n        for (auto e : edges) {\\n            if (e[2] == -1) {\\n                negative_edges.push_back({e[0], e[1]});\\n                continue;\\n            }\\n            g[e[0]].push_back({e[1], e[2]});\\n            g[e[1]].push_back({e[0], e[2]});\\n        }\\n        \\n        vector<int> parent, dist;\\n        Dijkstra (n, source, parent, dist);\\n        if (dist[destination] < target) return {};\\n        \\n        int l = 0, r = negative_edges.size();\\n        while (l < r) {\\n            int m = (l+r) >> 1;\\n            if (Check(m, negative_edges, source, destination, edges, n) <= target) r = m;\\n            else l = m+1;\\n        }\\n        \\n        int d = Check(l, negative_edges, source, destination, edges, n);\\n        if (d > target) return {};\\n        \\n        for (auto& e : edges) {\\n            if (e[2] != -1) continue;\\n            if (l == 0) {\\n                e[2] = INF;\\n                continue;\\n            }\\n            \\n            if (l == 1) e[2] = (target - d + 1);\\n            else e[2] = 1;\\n            l --;\\n        }\\n        return edges;\\n    }\\n    \\n    /*\\n    vector<int> PathToDestination (int src, int dst, const vector<int>& parent) {\\n        vector<int> path;\\n        while (dst != src) {\\n            path.push_back(dst);\\n            dst = parent[dst];\\n        }\\n        path.push_back(src);\\n        \\n        reverse(path.begin(), path.end());\\n        return path;\\n    }\\n    \\n    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int source, int destination, int target) {\\n        g.clear(), g.resize(n);\\n        for (auto e : edges) {\\n            if (e[2] == -1) continue;\\n            g[e[0]].push_back({e[1], e[2]});\\n            g[e[1]].push_back({e[0], e[2]});\\n        }\\n        \\n        vector<int> parent_dst, dist_dst;\\n        vector<int> parent_src, dist_src;\\n        \\n        Dijkstra (n, destination, parent_dst, dist_dst);\\n        if (dist_dst[source] < target) return {};\\n                \\n        for (auto e : edges) {\\n            if (e[2] != -1) continue;\\n            g[e[0]].push_back({e[1], 1});\\n            g[e[1]].push_back({e[0], 1});\\n        }\\n        \\n        Dijkstra (n, source, parent_src, dist_src);\\n        if (dist_src[destination] > target) return {};\\n        \\n        map<pii, int> edges_to_ind;\\n        for (int j = 0; j < edges.size(); j ++) {\\n            vector<int> e = edges[j];\\n            edges_to_ind [{e[0], e[1]}] = edges_to_ind [{e[1], e[0]}] = j;\\n        }\\n        \\n        vector<int> path = PathToDestination (source, destination, parent_src);\\n        for (int j = 0; j < path.size()-1; j ++) {\\n            int ind = edges_to_ind[{path[j], path[j+1]}];\\n            \\n            if (edges[ind][2] != -1) continue;\\n            \\n            ll dist_except_edge = dist_src[path[j]] + dist_dst[path[j+1]];\\n            if (dist_except_edge < target) {\\n                edges[ind][2] = target - dist_except_edge;\\n                break;\\n            }\\n            else edges[ind][2] = 1;\\n        }\\n        \\n        for (auto &e: edges) \\n            if (e[2] == -1) e[2] = 2e9;\\n        \\n        \\n        g.clear(), g.resize(n);\\n        for (auto e : edges) {\\n            g[e[0]].push_back({e[1], e[2]});\\n            g[e[1]].push_back({e[0], e[2]});\\n        }\\n        Dijkstra (n, source, parent_src, dist_src);\\n        assert (dist_src[destination] == target);\\n        \\n        return edges;\\n    }\\n    */\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define pii pair<int, int>\\n#define F first\\n#define S second\\n\\ntypedef long long int ll;\\nconst int INF = 2e9;\\n\\nclass Solution {\\n    \\n    vector<vector<pii>> g;\\n    \\n    void Dijkstra (int n, int src, vector<int>& parent, vector<int>& dist) {\\n        parent.clear(), dist.clear();\\n        parent.resize(n, -1), dist.resize(n, INF);\\n        parent[src] = src;\\n        dist[src] = 0;\\n        \\n        set<pii> all;\\n        for (int j = 0; j < n; j ++) all.insert({dist[j], j});\\n        \\n        while (!all.empty()) {\\n            int node = all.begin() -> S;\\n            all.erase(all.begin());\\n            \\n            for (auto edge: g[node]) {\\n                ll dist_through_node = (ll)dist[node] + edge.S;\\n                if ((ll)dist[edge.F] <= dist_through_node) continue;\\n                \\n                all.erase({dist[edge.F], edge.F});\\n                dist[edge.F] = dist_through_node;\\n                parent[edge.F] = node;\\n                all.insert({dist[edge.F], edge.F});\\n            }\\n        }\\n    }\\n    \\n    int Check (int ind, const vector<pii>& negative_edges, int src, int dst, const vector<vector<int>>& all_edges, const int n) {\\n        g.clear(), g.resize(n);\\n        for (int j = 0; j < ind; j ++) {\\n            g[negative_edges[j].F].push_back({negative_edges[j].S, 1});\\n            g[negative_edges[j].S].push_back({negative_edges[j].F, 1});\\n        }\\n        for (auto e : all_edges) {\\n            if (e[2] == -1) continue;\\n            g[e[0]].push_back({e[1], e[2]});\\n            g[e[1]].push_back({e[0], e[2]});\\n        }\\n        \\n        vector<int> parent, dist;\\n        Dijkstra (n, src, parent, dist);\\n        return dist[dst];\\n    }\\n    \\npublic:\\n    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int source, int destination, int target) {\\n        vector<pii> negative_edges;\\n        \\n        g.clear(), g.resize(n);\\n        for (auto e : edges) {\\n            if (e[2] == -1) {\\n                negative_edges.push_back({e[0], e[1]});\\n                continue;\\n            }\\n            g[e[0]].push_back({e[1], e[2]});\\n            g[e[1]].push_back({e[0], e[2]});\\n        }\\n        \\n        vector<int> parent, dist;\\n        Dijkstra (n, source, parent, dist);\\n        if (dist[destination] < target) return {};\\n        \\n        int l = 0, r = negative_edges.size();\\n        while (l < r) {\\n            int m = (l+r) >> 1;\\n            if (Check(m, negative_edges, source, destination, edges, n) <= target) r = m;\\n            else l = m+1;\\n        }\\n        \\n        int d = Check(l, negative_edges, source, destination, edges, n);\\n        if (d > target) return {};\\n        \\n        for (auto& e : edges) {\\n            if (e[2] != -1) continue;\\n            if (l == 0) {\\n                e[2] = INF;\\n                continue;\\n            }\\n            \\n            if (l == 1) e[2] = (target - d + 1);\\n            else e[2] = 1;\\n            l --;\\n        }\\n        return edges;\\n    }\\n    \\n    /*\\n    vector<int> PathToDestination (int src, int dst, const vector<int>& parent) {\\n        vector<int> path;\\n        while (dst != src) {\\n            path.push_back(dst);\\n            dst = parent[dst];\\n        }\\n        path.push_back(src);\\n        \\n        reverse(path.begin(), path.end());\\n        return path;\\n    }\\n    \\n    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int source, int destination, int target) {\\n        g.clear(), g.resize(n);\\n        for (auto e : edges) {\\n            if (e[2] == -1) continue;\\n            g[e[0]].push_back({e[1], e[2]});\\n            g[e[1]].push_back({e[0], e[2]});\\n        }\\n        \\n        vector<int> parent_dst, dist_dst;\\n        vector<int> parent_src, dist_src;\\n        \\n        Dijkstra (n, destination, parent_dst, dist_dst);\\n        if (dist_dst[source] < target) return {};\\n                \\n        for (auto e : edges) {\\n            if (e[2] != -1) continue;\\n            g[e[0]].push_back({e[1], 1});\\n            g[e[1]].push_back({e[0], 1});\\n        }\\n        \\n        Dijkstra (n, source, parent_src, dist_src);\\n        if (dist_src[destination] > target) return {};\\n        \\n        map<pii, int> edges_to_ind;\\n        for (int j = 0; j < edges.size(); j ++) {\\n            vector<int> e = edges[j];\\n            edges_to_ind [{e[0], e[1]}] = edges_to_ind [{e[1], e[0]}] = j;\\n        }\\n        \\n        vector<int> path = PathToDestination (source, destination, parent_src);\\n        for (int j = 0; j < path.size()-1; j ++) {\\n            int ind = edges_to_ind[{path[j], path[j+1]}];\\n            \\n            if (edges[ind][2] != -1) continue;\\n            \\n            ll dist_except_edge = dist_src[path[j]] + dist_dst[path[j+1]];\\n            if (dist_except_edge < target) {\\n                edges[ind][2] = target - dist_except_edge;\\n                break;\\n            }\\n            else edges[ind][2] = 1;\\n        }\\n        \\n        for (auto &e: edges) \\n            if (e[2] == -1) e[2] = 2e9;\\n        \\n        \\n        g.clear(), g.resize(n);\\n        for (auto e : edges) {\\n            g[e[0]].push_back({e[1], e[2]});\\n            g[e[1]].push_back({e[0], e[2]});\\n        }\\n        Dijkstra (n, source, parent_src, dist_src);\\n        assert (dist_src[destination] == target);\\n        \\n        return edges;\\n    }\\n    */\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3726438,
                "title": "modified-graph-dijkstra-c-solution",
                "content": "# Approach\\n1. take all edges witch do not have wt -1.\\n2. try to find shortest path b/w src and dest using dijkstra algo.\\n3. if distance b/w src and dest is less than target return {}.\\n4. if distance is equal to target then change all edges which have wt == -1 to wt == 2e9.\\n5. if distance is greater than target then change wt == -1 to wt == 1 simultaneously and check for target.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<pair<int, int>> adj[101];\\n    vector<int> bfs(int n,int src,int des){\\n        vector<int>vis(n,0), dis(n,1e9+1);\\n\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        pq.push({0,src});\\n\\n        dis[src] = 0;\\n        while(!pq.empty()){\\n            auto [wt,node] = pq.top();\\n            pq.pop();\\n            if(vis[node])continue;\\n            vis[node] = 1;\\n            for(auto& [newNode,newWt] : adj[node]){\\n                if(dis[newNode] > wt+newWt){\\n                    dis[newNode] = wt+newWt;\\n                    pq.push({wt+newWt, newNode});\\n                }\\n            }\\n        }\\n        return dis;\\n    }\\n    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int src, int des, int target) {\\n        // step 1\\n        for(auto &it : edges){\\n            if(it[2] == -1)continue;\\n            int u = it[0];\\n            int v = it[1];\\n            int w = it[2];\\n            adj[u].push_back({v,w});            \\n            adj[v].push_back({u,w});\\n        }\\n        // step 2\\n        vector<int>dis = bfs(n,src,des);\\n        // step 3\\n        if(dis[des] < target)\\n        return {};\\n        // step 4\\n        if(dis[des] == target){\\n            for(auto &it : edges){\\n                if(it[2] == -1)it[2] = 2e9;\\n            }\\n            return edges;\\n        }\\n        // step 5\\n        for(int i=0;i<edges.size();i++){\\n\\n            if(edges[i][2] == -1){\\n\\n                int u = edges[i][0],v = edges[i][1];\\n\\n                edges[i][2] = 1;\\n\\n                adj[u].push_back({v,1});\\n                adj[v].push_back({u,1});\\n\\n                vector<int>dist = bfs(n,src,des);\\n                if(dist[des] <= target){\\n\\n                    edges[i][2] += target-dist[des];\\n\\n                for(int j = i+1; j<edges.size();j++){\\n                    if(edges[j][2] == -1){\\n                        edges[j][2] = 1e9;\\n                    }\\n                }\\n                return edges;\\n                }\\n            }\\n        }\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Heap (Priority Queue)",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<pair<int, int>> adj[101];\\n    vector<int> bfs(int n,int src,int des){\\n        vector<int>vis(n,0), dis(n,1e9+1);\\n\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        pq.push({0,src});\\n\\n        dis[src] = 0;\\n        while(!pq.empty()){\\n            auto [wt,node] = pq.top();\\n            pq.pop();\\n            if(vis[node])continue;\\n            vis[node] = 1;\\n            for(auto& [newNode,newWt] : adj[node]){\\n                if(dis[newNode] > wt+newWt){\\n                    dis[newNode] = wt+newWt;\\n                    pq.push({wt+newWt, newNode});\\n                }\\n            }\\n        }\\n        return dis;\\n    }\\n    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int src, int des, int target) {\\n        // step 1\\n        for(auto &it : edges){\\n            if(it[2] == -1)continue;\\n            int u = it[0];\\n            int v = it[1];\\n            int w = it[2];\\n            adj[u].push_back({v,w});            \\n            adj[v].push_back({u,w});\\n        }\\n        // step 2\\n        vector<int>dis = bfs(n,src,des);\\n        // step 3\\n        if(dis[des] < target)\\n        return {};\\n        // step 4\\n        if(dis[des] == target){\\n            for(auto &it : edges){\\n                if(it[2] == -1)it[2] = 2e9;\\n            }\\n            return edges;\\n        }\\n        // step 5\\n        for(int i=0;i<edges.size();i++){\\n\\n            if(edges[i][2] == -1){\\n\\n                int u = edges[i][0],v = edges[i][1];\\n\\n                edges[i][2] = 1;\\n\\n                adj[u].push_back({v,1});\\n                adj[v].push_back({u,1});\\n\\n                vector<int>dist = bfs(n,src,des);\\n                if(dist[des] <= target){\\n\\n                    edges[i][2] += target-dist[des];\\n\\n                for(int j = i+1; j<edges.size();j++){\\n                    if(edges[j][2] == -1){\\n                        edges[j][2] = 1e9;\\n                    }\\n                }\\n                return edges;\\n                }\\n            }\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588605,
                "title": "why-wrong-answer-for-this-test-case",
                "content": "```\\nInput:\\n5\\n[[4,1,-1],[2,0,-1],[0,3,-1],[4,3,-1]]\\n0\\n1\\n5\\nOutput:\\n[[4,1,1],[2,0,2147483647],[0,3,1],[4,3,3]]\\nExpected:\\n[[4,1,1],[2,0,1],[0,3,3],[4,3,1]]\\n```",
                "solutionTags": [],
                "code": "```\\nInput:\\n5\\n[[4,1,-1],[2,0,-1],[0,3,-1],[4,3,-1]]\\n0\\n1\\n5\\nOutput:\\n[[4,1,1],[2,0,2147483647],[0,3,1],[4,3,3]]\\nExpected:\\n[[4,1,1],[2,0,1],[0,3,3],[4,3,1]]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3567319,
                "title": "set-all-dynamic-edges-to-math-inf-then-pick-one-to-change-to-1-then-pick-one-again",
                "content": "# Approach\\nStart from all dynamic edges costs being math.inf. Then reduce costs one by one.\\n1. Set all dynamic edge costs to math.inf. Do Dijistra to find start to end cost. \\n    a. If < target, no answer. Cannot achieve higher cost by reducing dynamic edge costs.\\n    b. If == target, you find answer already\\n    c. If > target, need to reduce cost of some dynamic edges. go to next step #2\\n2. Pick one dynamic edge, one and one only, change cost of this edge to 1. Do Dijistra to find start to end cost. \\n    a. If < target, increase the cost of this edge to equal target. Repeat #2 to pick the next dynamic edge.\\n    b. If == target, you find answer already\\n    c. If > target, not possible.\\nBasically, for each dynamic edge, we will need to repeat a full Dijistra algorithm. Looks like taking long time, but actually not.\\n\\n# Code\\n```\\nclass Solution:\\n    def modifiedGraphEdges(self, n: int, edges: List[List[int]], source: int, destination: int, target: int) -> List[List[int]]:\\n        dynamicEdges = set()\\n        d = defaultdict(lambda: defaultdict(int))\\n        for a,b,w in edges:\\n            if w==-1: \\n                dynamicEdges.add((a,b))\\n                w = 2*10**9\\n            d[a][b] = d[b][a] = w\\n\\n        def dijkstra():\\n            que = [(0,source)]\\n            visited = set()\\n            while que:\\n                cost,node = heapq.heappop(que)\\n                if node==destination:\\n                    return cost\\n                if node in visited:\\n                    continue\\n                visited.add(node)\\n                for nxt,cost2 in d[node].items():\\n                    heapq.heappush(que,(cost+cost2,nxt))\\n        def toReturn():\\n            return [[a,b,w] for a,d2 in d.items() for b,w in d2.items() if a<b]\\n        cost = dijkstra()\\n        if cost<target:\\n            return []\\n        if cost==target:\\n            return toReturn()\\n        for a,b in dynamicEdges:\\n            d[a][b] = d[b][a] = 1\\n            cost = dijkstra()\\n            if cost<=target:\\n                d[a][b] = d[b][a] = target-cost+1\\n                cost = dijkstra()\\n                if cost==target:\\n                    return toReturn()\\n        return []\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def modifiedGraphEdges(self, n: int, edges: List[List[int]], source: int, destination: int, target: int) -> List[List[int]]:\\n        dynamicEdges = set()\\n        d = defaultdict(lambda: defaultdict(int))\\n        for a,b,w in edges:\\n            if w==-1: \\n                dynamicEdges.add((a,b))\\n                w = 2*10**9\\n            d[a][b] = d[b][a] = w\\n\\n        def dijkstra():\\n            que = [(0,source)]\\n            visited = set()\\n            while que:\\n                cost,node = heapq.heappop(que)\\n                if node==destination:\\n                    return cost\\n                if node in visited:\\n                    continue\\n                visited.add(node)\\n                for nxt,cost2 in d[node].items():\\n                    heapq.heappush(que,(cost+cost2,nxt))\\n        def toReturn():\\n            return [[a,b,w] for a,d2 in d.items() for b,w in d2.items() if a<b]\\n        cost = dijkstra()\\n        if cost<target:\\n            return []\\n        if cost==target:\\n            return toReturn()\\n        for a,b in dynamicEdges:\\n            d[a][b] = d[b][a] = 1\\n            cost = dijkstra()\\n            if cost<=target:\\n                d[a][b] = d[b][a] = target-cost+1\\n                cost = dijkstra()\\n                if cost==target:\\n                    return toReturn()\\n        return []\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565974,
                "title": "finally-solved-using-dijkstra",
                "content": "# Code\\n```\\nclass Solution {\\nprivate:\\n    int dijkstra(vector<pair<int,int>> g[],int n,int src,int dest,int k){\\n        vector<int> dist(n,1e9);\\n        dist[src] = 0;\\n        set<pair<int,int>> st;\\n        st.insert({0,src});\\n        while(!st.empty()){\\n            auto top = *st.begin();\\n            st.erase(st.begin());\\n            int node = top.second;\\n            int wt = top.first;\\n            for(auto&[child,weight]: g[node]){\\n                if(weight == -1) continue;\\n                if(dist[child] > wt + 0ll + weight){\\n                    dist[child] = wt + weight;\\n                    st.insert({dist[child],child});\\n                }\\n            }\\n        }\\n        return dist[dest];\\n    }\\npublic:\\n    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int src, int dest, int k) {\\n        vector<pair<int,int>> g[n];\\n        vector<vector<int>> ans;\\n        set<pair<int,int>> dup;\\n        for(auto&e: edges){\\n            g[e[0]].push_back({e[1],e[2]});\\n            g[e[1]].push_back({e[0],e[2]});\\n        }\\n        int e = dijkstra(g,n,src,dest,k);\\n        if(e < k) return ans;\\n        bool found = false;\\n        for(int i=0; i<n; ++i){\\n            for(auto&&[v,wt]: g[i]){\\n                if(wt == -1){\\n                    wt = 1;\\n                    for(auto&&[u,_wt]: g[v]){\\n                        if(u == i) {_wt = 1; break;}\\n                    }\\n                    int e = dijkstra(g,n,src,dest,k);\\n                    if(e <= k){\\n                        int req = k - e;\\n                        wt += req;\\n                        for(auto&&[u,_wt]: g[v]){\\n                            if(u == i) {_wt += req; break;}\\n                        }\\n                        found = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(found) break;\\n        }\\n        for(int i=0; i<n; ++i){\\n            for(auto&[j,wt]: g[i]){\\n                int u = i, v = j;\\n                if(wt == -1) wt = (int)2e9;\\n                if(!dup.count({min(u,v),max(u,v)})){\\n                    ans.push_back({min(u,v),max(u,v),wt});\\n                }\\n                dup.insert({min(u,v),max(u,v)});\\n            }\\n        }\\n        e = dijkstra(g,n,src,dest,k);\\n        if(e != k) ans.clear();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Heap (Priority Queue)",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int dijkstra(vector<pair<int,int>> g[],int n,int src,int dest,int k){\\n        vector<int> dist(n,1e9);\\n        dist[src] = 0;\\n        set<pair<int,int>> st;\\n        st.insert({0,src});\\n        while(!st.empty()){\\n            auto top = *st.begin();\\n            st.erase(st.begin());\\n            int node = top.second;\\n            int wt = top.first;\\n            for(auto&[child,weight]: g[node]){\\n                if(weight == -1) continue;\\n                if(dist[child] > wt + 0ll + weight){\\n                    dist[child] = wt + weight;\\n                    st.insert({dist[child],child});\\n                }\\n            }\\n        }\\n        return dist[dest];\\n    }\\npublic:\\n    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int src, int dest, int k) {\\n        vector<pair<int,int>> g[n];\\n        vector<vector<int>> ans;\\n        set<pair<int,int>> dup;\\n        for(auto&e: edges){\\n            g[e[0]].push_back({e[1],e[2]});\\n            g[e[1]].push_back({e[0],e[2]});\\n        }\\n        int e = dijkstra(g,n,src,dest,k);\\n        if(e < k) return ans;\\n        bool found = false;\\n        for(int i=0; i<n; ++i){\\n            for(auto&&[v,wt]: g[i]){\\n                if(wt == -1){\\n                    wt = 1;\\n                    for(auto&&[u,_wt]: g[v]){\\n                        if(u == i) {_wt = 1; break;}\\n                    }\\n                    int e = dijkstra(g,n,src,dest,k);\\n                    if(e <= k){\\n                        int req = k - e;\\n                        wt += req;\\n                        for(auto&&[u,_wt]: g[v]){\\n                            if(u == i) {_wt += req; break;}\\n                        }\\n                        found = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(found) break;\\n        }\\n        for(int i=0; i<n; ++i){\\n            for(auto&[j,wt]: g[i]){\\n                int u = i, v = j;\\n                if(wt == -1) wt = (int)2e9;\\n                if(!dup.count({min(u,v),max(u,v)})){\\n                    ans.push_back({min(u,v),max(u,v),wt});\\n                }\\n                dup.insert({min(u,v),max(u,v)});\\n            }\\n        }\\n        e = dijkstra(g,n,src,dest,k);\\n        if(e != k) ans.clear();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3563377,
                "title": "a-more-general-problem-in-o-v-e-log-e-log-e-log-2-10-9",
                "content": "# Description\\nThis solution doesn\\'t require the constraint that w <= 10^7, w can be any value that fits in an int.\\n\\n# Complexity\\n- Time complexity:\\nO((V + E)log(E) * (log(E) + log (2*10^9)), around 10^7, acceptable.\\n\\n- Space complexity:\\nO(E + V)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n#### 2 Binary searches:\\nI. First Search\\n**Search in the range [0, 2*10^9 (max weight of -1 edges)]**. In each iteration, assign **ALL negative edges\\' weight to \"mid\"** (\"mid\" is the binary search value of the current iteration), then run dijkstra to compute shortest distance from **source** to **destination**.\\n\\nLogic:\\n\\n    if(dist(source, destination) < target\\n        set left bound of binary search to mid\\n    else if(dist(source, destination) > target)\\n        set right bound to mid\\n    else\\n        dist(source, destination) == target, we\\'ve found a valid assignment, return\\n\\nIf we fail to get a valid assignment through this search, we still get a value **\"val\"** in the end where:\\n\\n    if we set ALL negative edges\\' weight to \"val\", dist(source, destination) < target\\n    and if we set ALL negative edges\\' weight to \"val\" + 1, dist(source, destination) > target.\\n\\nThe above property is really crucial for our 2nd binary search.\\n\\nII. Second Search\\n**Search in the range [0, E (edges.length)]**. In each iteration, assign **the first \"mid\" negative edges\\' weight to \"val\", and the rest to \"val\" + 1**, then run dijkstra to compute shortest distance from **source** to **destination**.\\n\\n    if(dist(source, destination) < target\\n        set left bound of binary search to mid\\n    else if(dist(source, destination) > target)\\n        set right bound to mid\\n    else\\n        dist(source, destination) == target, we\\'ve found a valid assignment, return\\n\\nWe are **GUARANTEED** to receive a valid assignment after this search.\\n\\nProof:\\n    \\n    Lemma: dist(source, destination) is monotone non-increasing as we increase \"mid\".\\n        Proof: Consider the difference between setting \"mid\" negative edges to \"val\" (Scenario A) and \"mid\" + 1 negative edges to \"val\" (Scenario B).\\n        Let e be the (\"mid\" + 1)-th negative edge.\\n        If e not in shortest-path(source, destination) in Scenario A\\n            This weight of edges on this path is unchanged => distance(source, destination) doesn\\'t increase (we can still take this path).\\n        else\\n            The length of this path reduced by 1 => distance(source, destination) decreased by 1 (take this path).\\n\\n    From the lemma, we observe that the only way that we won\\'t get a valid answer is that \\n        distance(source, destination) > target for \"mid\" edges equal to \"val\"\\n        and distance(source, destination) < target for \"mid\" + 1 edges equal to \"val\".\\n\\n    But this too is impossible, since that would imply that reducing the weight of one edge (the (mid + 1)-th edge) by 1 (from val + 1 to val) decreased distance(source, destination) by at least 2.\\n    Proof:\\n        Let e be the (\"mid\" + 1)-th negative edge.\\n        For any paths from source to destination that contains e, their lengths -= 1, others are unchanged, so it\\'s impossible for any path\\'s length to reduce by at least 2 => impossible for shortest path\\'s length to reduce by at least 2.  \\n\\n# Additional Logic\\n\\nWe need to check if there is a valid assignment. So we just run dijkstra when all negative edges have weight 1 (minimum possible distance), and when they all have weight 2 * 10 ^ 9 (maximum possible distance). If the target falls within those 2 distances, then we are guaranteed an answer, otherwise it\\'s impossible.\\n \\n# Time Complexity:\\nBinary Search I: ran dijkstra log(2*10^9) = 31 times.\\nBinary Search II: ran dijkstra log(E) = log(n^2) < 20 times.\\nDijkstra: O((V + E)log(E)).\\nTotal complexity: O((V + E)log(E) * (log(E) + log (2*10^9)), around 1000 * 100 ^ 2 = 10^7, acceptable.\\n\\nNote: used an array of HashMap as adjacency list, so that setting the weight of each edge is O(1), seting the weight of all negative edges is O(E). The weights are set each time dijkstra is run, so it\\'s complexity O(E) < dijkstra\\'s complexity O((V + E)log(E)), ignorable.\\n\\n# Code\\n```\\nclass Solution {\\n    //adjacency list\\n    HashMap<Integer, Integer>[] map;\\n    //indices of edges with -1 weight\\n    int[] neg;\\n    //length of \"neg\", source, destination, n\\n    int neg_ct, s, t, n;\\n    //target\\n    long targ;\\n    int[][] edges;\\n    //MAX assignable weight of any negative edges\\n    static int MAX = 2000000000;\\n    //INF distance for dijkstra\\n    static long INF = 100000000000000000L;\\n    //dijkstra dist array\\n    static long[] dist = new long[101];\\n    //PriorityQueue for Dijkstra\\n    static PriorityQueue<Long> q = new PriorityQueue<Long>((p1, p2) -> (p1 - p2 > 0L ? 1 : -1));\\n    //sets the weight of all e in edges to the weight stored in the adjacency list\\n    //(done before returning the assignment, we simply return \"edges\" as our answer)\\n    public void process(){\\n        for(int[] e : edges){\\n            e[2] = map[e[0]].get(e[1]);\\n        }\\n    }\\n    //sets all negative edges to weight v\\n    public void all(int v){\\n        for(int ind : neg){\\n            int[] e = edges[ind];\\n            map[e[0]].put(e[1], v);\\n            map[e[1]].put(e[0], v);\\n        }\\n    }\\n    //sets \"count\" negative edges to weight v, the rest to v + 1\\n    public void partial(int v, int count){\\n        for(int i = 0; i < count; ++i){\\n            int ind = neg[i];\\n            int[] e = edges[ind];\\n            map[e[0]].put(e[1], v + 1);\\n            map[e[1]].put(e[0], v + 1);\\n        }\\n        for(int i = count; i < neg_ct; ++i){\\n            int ind = neg[i];\\n            int[] e = edges[ind];\\n            map[e[0]].put(e[1], v);\\n            map[e[1]].put(e[0], v);\\n        }\\n    }\\n    //forces a long to store (vertex, distance from source) pair\\n    //  optimization for dijkstra\\n    public long encode(int a, long b){\\n        return (b << 8) + a;\\n    }\\n    //dijkstra\\n    public long dijkstra(){\\n        Arrays.fill(dist, INF);\\n        q.add(encode(s, 0L));\\n        while(!q.isEmpty()){\\n            long p = q.poll();\\n            int cur = (int)(p & 255);\\n            long d = p >> 8;\\n            if(d > dist[cur]){\\n                continue;\\n            }\\n            dist[cur] = d;\\n            for(int nei : map[cur].keySet()){\\n                long nd = d + map[cur].get(nei);\\n                if(nd < dist[nei]){\\n                    q.add(encode(nei, nd));\\n                    dist[nei] = nd;\\n                }\\n            }\\n        }\\n        return dist[t];\\n    }\\n    public int[][] modifiedGraphEdges(int n, int[][] edges, int s, int t, int targ_int) {\\n        this.n = n;\\n        this.edges = edges;\\n        this.s = s;\\n        this.t = t;\\n        targ = (long)targ_int;\\n        neg_ct = 0;\\n        map = new HashMap[n];\\n        for(int i = 0; i < n; ++i){\\n            map[i] = new HashMap<>();\\n        }\\n        //setting up adjacency_list\\n        for(int[] e : edges){\\n            if(e[2] == -1){\\n                ++neg_ct;\\n            }\\n            map[e[0]].put(e[1], e[2]);\\n            map[e[1]].put(e[0], e[2]);\\n        }\\n        neg = new int[neg_ct];\\n        int neg_ind = 0;\\n        //setting up neg\\n        for(int i = 0; i < edges.length; ++i){\\n            int[] e = edges[i];\\n            if(e[2] == -1){\\n                neg[neg_ind] = i;\\n                ++neg_ind;\\n            }\\n        }\\n        //explained in Additional Logic Section\\n        all(1);\\n        long shortest = dijkstra();\\n        all(MAX);\\n        long longest = dijkstra();\\n        if(shortest > targ || longest < targ){\\n            return new int[0][0];\\n        }\\n        if(shortest == targ){\\n            all(1);\\n            process();\\n            return edges;\\n        }\\n        if(longest == targ){\\n            all(MAX);\\n            process();\\n            return edges;\\n        }\\n\\n        //Binary search I\\n        int st = 1, end = MAX;\\n        while(st < end){\\n            int mid = st + (end - st) / 2;\\n            all(mid);\\n            long dist = dijkstra();\\n            if(dist < targ){\\n                st = mid;\\n            }\\n            else if(dist > targ){\\n                end = mid;\\n            }\\n            else{\\n                process();\\n                return edges;\\n            }\\n            if(st + 1 == end){\\n                all(end);\\n                dist = dijkstra();\\n                if(dist < targ){\\n                    st = end;\\n                }\\n                else if(dist > targ){\\n                    end = st;\\n                }\\n                else{\\n                    process();\\n                    return edges;\\n                }\\n            }\\n        }\\n        \\n        //Binary Search II\\n        int val = st;\\n        st = 0;\\n        end = neg_ct;\\n        while(st < end){\\n            int mid = (st + end) / 2;\\n            partial(val, mid);\\n            long dist = dijkstra();\\n            if(dist < targ){\\n                st = mid + 1;\\n            }\\n            else if(dist > targ){\\n                end = mid - 1;\\n            }\\n            else{\\n                st = mid;\\n                break;\\n            }\\n        }\\n        partial(val, st);\\n        process();\\n        long dist = dijkstra();\\n        return edges;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\n    //adjacency list\\n    HashMap<Integer, Integer>[] map;\\n    //indices of edges with -1 weight\\n    int[] neg;\\n    //length of \"neg\", source, destination, n\\n    int neg_ct, s, t, n;\\n    //target\\n    long targ;\\n    int[][] edges;\\n    //MAX assignable weight of any negative edges\\n    static int MAX = 2000000000;\\n    //INF distance for dijkstra\\n    static long INF = 100000000000000000L;\\n    //dijkstra dist array\\n    static long[] dist = new long[101];\\n    //PriorityQueue for Dijkstra\\n    static PriorityQueue<Long> q = new PriorityQueue<Long>((p1, p2) -> (p1 - p2 > 0L ? 1 : -1));\\n    //sets the weight of all e in edges to the weight stored in the adjacency list\\n    //(done before returning the assignment, we simply return \"edges\" as our answer)\\n    public void process(){\\n        for(int[] e : edges){\\n            e[2] = map[e[0]].get(e[1]);\\n        }\\n    }\\n    //sets all negative edges to weight v\\n    public void all(int v){\\n        for(int ind : neg){\\n            int[] e = edges[ind];\\n            map[e[0]].put(e[1], v);\\n            map[e[1]].put(e[0], v);\\n        }\\n    }\\n    //sets \"count\" negative edges to weight v, the rest to v + 1\\n    public void partial(int v, int count){\\n        for(int i = 0; i < count; ++i){\\n            int ind = neg[i];\\n            int[] e = edges[ind];\\n            map[e[0]].put(e[1], v + 1);\\n            map[e[1]].put(e[0], v + 1);\\n        }\\n        for(int i = count; i < neg_ct; ++i){\\n            int ind = neg[i];\\n            int[] e = edges[ind];\\n            map[e[0]].put(e[1], v);\\n            map[e[1]].put(e[0], v);\\n        }\\n    }\\n    //forces a long to store (vertex, distance from source) pair\\n    //  optimization for dijkstra\\n    public long encode(int a, long b){\\n        return (b << 8) + a;\\n    }\\n    //dijkstra\\n    public long dijkstra(){\\n        Arrays.fill(dist, INF);\\n        q.add(encode(s, 0L));\\n        while(!q.isEmpty()){\\n            long p = q.poll();\\n            int cur = (int)(p & 255);\\n            long d = p >> 8;\\n            if(d > dist[cur]){\\n                continue;\\n            }\\n            dist[cur] = d;\\n            for(int nei : map[cur].keySet()){\\n                long nd = d + map[cur].get(nei);\\n                if(nd < dist[nei]){\\n                    q.add(encode(nei, nd));\\n                    dist[nei] = nd;\\n                }\\n            }\\n        }\\n        return dist[t];\\n    }\\n    public int[][] modifiedGraphEdges(int n, int[][] edges, int s, int t, int targ_int) {\\n        this.n = n;\\n        this.edges = edges;\\n        this.s = s;\\n        this.t = t;\\n        targ = (long)targ_int;\\n        neg_ct = 0;\\n        map = new HashMap[n];\\n        for(int i = 0; i < n; ++i){\\n            map[i] = new HashMap<>();\\n        }\\n        //setting up adjacency_list\\n        for(int[] e : edges){\\n            if(e[2] == -1){\\n                ++neg_ct;\\n            }\\n            map[e[0]].put(e[1], e[2]);\\n            map[e[1]].put(e[0], e[2]);\\n        }\\n        neg = new int[neg_ct];\\n        int neg_ind = 0;\\n        //setting up neg\\n        for(int i = 0; i < edges.length; ++i){\\n            int[] e = edges[i];\\n            if(e[2] == -1){\\n                neg[neg_ind] = i;\\n                ++neg_ind;\\n            }\\n        }\\n        //explained in Additional Logic Section\\n        all(1);\\n        long shortest = dijkstra();\\n        all(MAX);\\n        long longest = dijkstra();\\n        if(shortest > targ || longest < targ){\\n            return new int[0][0];\\n        }\\n        if(shortest == targ){\\n            all(1);\\n            process();\\n            return edges;\\n        }\\n        if(longest == targ){\\n            all(MAX);\\n            process();\\n            return edges;\\n        }\\n\\n        //Binary search I\\n        int st = 1, end = MAX;\\n        while(st < end){\\n            int mid = st + (end - st) / 2;\\n            all(mid);\\n            long dist = dijkstra();\\n            if(dist < targ){\\n                st = mid;\\n            }\\n            else if(dist > targ){\\n                end = mid;\\n            }\\n            else{\\n                process();\\n                return edges;\\n            }\\n            if(st + 1 == end){\\n                all(end);\\n                dist = dijkstra();\\n                if(dist < targ){\\n                    st = end;\\n                }\\n                else if(dist > targ){\\n                    end = st;\\n                }\\n                else{\\n                    process();\\n                    return edges;\\n                }\\n            }\\n        }\\n        \\n        //Binary Search II\\n        int val = st;\\n        st = 0;\\n        end = neg_ct;\\n        while(st < end){\\n            int mid = (st + end) / 2;\\n            partial(val, mid);\\n            long dist = dijkstra();\\n            if(dist < targ){\\n                st = mid + 1;\\n            }\\n            else if(dist > targ){\\n                end = mid - 1;\\n            }\\n            else{\\n                st = mid;\\n                break;\\n            }\\n        }\\n        partial(val, st);\\n        process();\\n        long dist = dijkstra();\\n        return edges;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3560298,
                "title": "modify-graph-edge-weights-javascript",
                "content": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @param {number} source\\n * @param {number} destination\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar modifiedGraphEdges = function(n, edges, source, destination, target) {\\n  const kMax = 2000000000;\\n  const graph = Array(n).fill().map(() => []);\\n\\n  for (const [u, v, w] of edges) {\\n    if (w === -1) {\\n      continue;\\n    }\\n    graph[u].push([v, w]);\\n    graph[v].push([u, w]);\\n  }\\n\\n  const distToDestination = dijkstra(graph, source, destination);\\n  if (distToDestination < target) {\\n    return [];\\n  }\\n  if (distToDestination === target) {\\n    // Change the weights of negative edges to an impossible value.\\n    for (const edge of edges) {\\n      if (edge[2] === -1) {\\n        edge[2] = kMax;\\n      }\\n    }\\n    return edges;\\n  }\\n\\n  for (let i = 0; i < edges.length; i++) {\\n    const [u, v, w] = edges[i];\\n    if (w !== -1) {\\n      continue;\\n    }\\n    edges[i][2] = 1;\\n    graph[u].push([v, 1]);\\n    graph[v].push([u, 1]);\\n    const distToDestination = dijkstra(graph, source, destination);\\n    if (distToDestination <= target) {\\n      edges[i][2] += target - distToDestination;\\n      // Change the weights of negative edges to an impossible value.\\n      for (let j = i + 1; j < edges.length; j++) {\\n        if (edges[j][2] === -1) {\\n          edges[j][2] = kMax;\\n        }\\n      }\\n      return edges;\\n    }\\n  }\\n\\n  return [];\\n}\\n\\nfunction dijkstra(graph, src, dst) {\\n  const dist = Array(graph.length).fill(Infinity);\\n  const minHeap = new MinHeap();\\n\\n  dist[src] = 0;\\n  minHeap.insert(dist[src], src);\\n\\n  while (!minHeap.isEmpty()) {\\n    const [d, u] = minHeap.extractMin();\\n    for (const [v, w] of graph[u]) {\\n      if (d + w < dist[v]) {\\n        dist[v] = d + w;\\n        minHeap.insert(dist[v], v);\\n      }\\n    }\\n  }\\n\\n  return dist[dst];\\n}\\n\\nclass MinHeap {\\n  constructor() {\\n    this.heap = [];\\n  }\\n\\n  insert(key, value) {\\n    this.heap.push([key, value]);\\n    this.bubbleUp(this.heap.length - 1);\\n  }\\n\\n  extractMin() {\\n    const min = this.heap[0];\\n    const last = this.heap.pop();\\n    if (this.heap.length > 0) {\\n      this.heap[0] = last;\\n      this.bubbleDown(0);\\n    }\\n    return min;\\n  }\\n\\n  bubbleUp(index) {\\n    const [key, value] = this.heap[index];\\n    while (index > 0) {\\n      const parentIndex = Math.floor((index - 1) / 2);\\n      if (this.heap[parentIndex][0] <= key) {\\n        break;\\n      }\\n      this.heap[index] = this.heap[parentIndex];\\n      index = parentIndex;\\n    }\\n    this.heap[index] = [key, value];\\n  }\\n\\n  bubbleDown(index) {\\n    const [key, value] = this.heap[index];\\n    const lastIndex = this.heap.length - 1;\\n    while (true) {\\n      let smallestChildIndex = -1;\\n      let smallestChildKey = key;\\n      let smallestChildValue = value;\\n      const leftChildIndex = 2 * index + 1;\\n      const rightChildIndex = 2 * index + 2;\\n      if (leftChildIndex <= lastIndex) {\\n        const [leftChildKey, leftChildValue] = this.heap[leftChildIndex];\\n        if (leftChildKey < smallestChildKey) {\\n          smallestChildIndex = leftChildIndex;\\n          smallestChildKey = leftChildKey;\\n          smallestChildValue = leftChildValue;\\n        }\\n      }\\n      if (rightChildIndex <= lastIndex) {\\n        const [rightChildKey, rightChildValue] = this.heap[rightChildIndex];\\n        if (rightChildKey < smallestChildKey) {\\n          smallestChildIndex = rightChildIndex;\\n          smallestChildKey = rightChildKey;\\n          smallestChildValue = rightChildValue;\\n        }\\n      }\\n      if (smallestChildIndex === -1 || key <= smallestChildKey) {\\n        break;\\n      }\\n      this.heap[index] = [smallestChildKey, smallestChildValue];\\n      index = smallestChildIndex;\\n    }\\n    this.heap[index] = [key, value];\\n  }\\n\\n  isEmpty() {\\n    return this.heap.length === 0;\\n  }    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @param {number} source\\n * @param {number} destination\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar modifiedGraphEdges = function(n, edges, source, destination, target) {\\n  const kMax = 2000000000;\\n  const graph = Array(n).fill().map(() => []);\\n\\n  for (const [u, v, w] of edges) {\\n    if (w === -1) {\\n      continue;\\n    }\\n    graph[u].push([v, w]);\\n    graph[v].push([u, w]);\\n  }\\n\\n  const distToDestination = dijkstra(graph, source, destination);\\n  if (distToDestination < target) {\\n    return [];\\n  }\\n  if (distToDestination === target) {\\n    // Change the weights of negative edges to an impossible value.\\n    for (const edge of edges) {\\n      if (edge[2] === -1) {\\n        edge[2] = kMax;\\n      }\\n    }\\n    return edges;\\n  }\\n\\n  for (let i = 0; i < edges.length; i++) {\\n    const [u, v, w] = edges[i];\\n    if (w !== -1) {\\n      continue;\\n    }\\n    edges[i][2] = 1;\\n    graph[u].push([v, 1]);\\n    graph[v].push([u, 1]);\\n    const distToDestination = dijkstra(graph, source, destination);\\n    if (distToDestination <= target) {\\n      edges[i][2] += target - distToDestination;\\n      // Change the weights of negative edges to an impossible value.\\n      for (let j = i + 1; j < edges.length; j++) {\\n        if (edges[j][2] === -1) {\\n          edges[j][2] = kMax;\\n        }\\n      }\\n      return edges;\\n    }\\n  }\\n\\n  return [];\\n}\\n\\nfunction dijkstra(graph, src, dst) {\\n  const dist = Array(graph.length).fill(Infinity);\\n  const minHeap = new MinHeap();\\n\\n  dist[src] = 0;\\n  minHeap.insert(dist[src], src);\\n\\n  while (!minHeap.isEmpty()) {\\n    const [d, u] = minHeap.extractMin();\\n    for (const [v, w] of graph[u]) {\\n      if (d + w < dist[v]) {\\n        dist[v] = d + w;\\n        minHeap.insert(dist[v], v);\\n      }\\n    }\\n  }\\n\\n  return dist[dst];\\n}\\n\\nclass MinHeap {\\n  constructor() {\\n    this.heap = [];\\n  }\\n\\n  insert(key, value) {\\n    this.heap.push([key, value]);\\n    this.bubbleUp(this.heap.length - 1);\\n  }\\n\\n  extractMin() {\\n    const min = this.heap[0];\\n    const last = this.heap.pop();\\n    if (this.heap.length > 0) {\\n      this.heap[0] = last;\\n      this.bubbleDown(0);\\n    }\\n    return min;\\n  }\\n\\n  bubbleUp(index) {\\n    const [key, value] = this.heap[index];\\n    while (index > 0) {\\n      const parentIndex = Math.floor((index - 1) / 2);\\n      if (this.heap[parentIndex][0] <= key) {\\n        break;\\n      }\\n      this.heap[index] = this.heap[parentIndex];\\n      index = parentIndex;\\n    }\\n    this.heap[index] = [key, value];\\n  }\\n\\n  bubbleDown(index) {\\n    const [key, value] = this.heap[index];\\n    const lastIndex = this.heap.length - 1;\\n    while (true) {\\n      let smallestChildIndex = -1;\\n      let smallestChildKey = key;\\n      let smallestChildValue = value;\\n      const leftChildIndex = 2 * index + 1;\\n      const rightChildIndex = 2 * index + 2;\\n      if (leftChildIndex <= lastIndex) {\\n        const [leftChildKey, leftChildValue] = this.heap[leftChildIndex];\\n        if (leftChildKey < smallestChildKey) {\\n          smallestChildIndex = leftChildIndex;\\n          smallestChildKey = leftChildKey;\\n          smallestChildValue = leftChildValue;\\n        }\\n      }\\n      if (rightChildIndex <= lastIndex) {\\n        const [rightChildKey, rightChildValue] = this.heap[rightChildIndex];\\n        if (rightChildKey < smallestChildKey) {\\n          smallestChildIndex = rightChildIndex;\\n          smallestChildKey = rightChildKey;\\n          smallestChildValue = rightChildValue;\\n        }\\n      }\\n      if (smallestChildIndex === -1 || key <= smallestChildKey) {\\n        break;\\n      }\\n      this.heap[index] = [smallestChildKey, smallestChildValue];\\n      index = smallestChildIndex;\\n    }\\n    this.heap[index] = [key, value];\\n  }\\n\\n  isEmpty() {\\n    return this.heap.length === 0;\\n  }    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553005,
                "title": "java-floyd-warshall",
                "content": "```java\\nclass Solution {\\n\\n    static final int INF = (int) 1e9;\\n\\n    public int[][] modifiedGraphEdges(int n, int[][] edges, int src, int dst, int t) {\\n        for (int[] e : edges) {\\n            if (e[2] == -1) {\\n                e[2] = INF;\\n            }\\n        }\\n        \\n        int[][] dist = new int[n][n];\\n        for (int[] row : dist) Arrays.fill(row, INF);\\n        for (int i = 0; i < n; i++) dist[i][i] = 0;\\n        for (int[] e : edges) {\\n            dist[e[0]][e[1]] = e[2];\\n            dist[e[1]][e[0]] = e[2];\\n        }\\n\\n        // floyd-warshall\\n        for (int k = 0; k < n; k++) {\\n            for (int i = 0; i < n; i++) {\\n                for (int j = 0; j < n; j++) {\\n                    if (dist[i][j] > dist[i][k] + dist[k][j]) {\\n                        dist[i][j] = dist[i][k] + dist[k][j];\\n                    }\\n                }\\n            }\\n        }\\n\\n        // found\\n        if (dist[src][dst] == t) {\\n            return edges;\\n        }\\n        // not possible\\n        if (dist[src][dst] < t) {\\n            return new int[][] {};\\n        }\\n\\n        for (int[] e : edges) {\\n            if (e[2] == INF) {\\n                e[2] = 1;\\n                update(n, dist, e[0], e[1], e[2]);\\n                update(n, dist, e[1], e[0], e[2]);\\n                if (dist[src][dst] <= t) {\\n                    e[2] += t - dist[src][dst];\\n                    update(n, dist, e[0], e[1], e[2]);\\n                    update(n, dist, e[1], e[0], e[2]);\\n                    return edges;\\n                }\\n            }\\n        }\\n        return new int[][] {};\\n    }\\n\\n    void update(int n, int[][] dist, int u, int v, int d) {\\n        if (dist[u][v] > d) {\\n            dist[u][v] = d;\\n            for (int i = 0; i < n; i++) {\\n                for (int j = 0; j < n; j++) {\\n                    if (dist[i][j] > dist[i][u] + dist[u][v] + dist[v][j]) {\\n                        dist[i][j] = dist[i][u] + dist[u][v] + dist[v][j];\\n                    }\\n                }\\n            }\\n        }           \\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n\\n    static final int INF = (int) 1e9;\\n\\n    public int[][] modifiedGraphEdges(int n, int[][] edges, int src, int dst, int t) {\\n        for (int[] e : edges) {\\n            if (e[2] == -1) {\\n                e[2] = INF;\\n            }\\n        }\\n        \\n        int[][] dist = new int[n][n];\\n        for (int[] row : dist) Arrays.fill(row, INF);\\n        for (int i = 0; i < n; i++) dist[i][i] = 0;\\n        for (int[] e : edges) {\\n            dist[e[0]][e[1]] = e[2];\\n            dist[e[1]][e[0]] = e[2];\\n        }\\n\\n        // floyd-warshall\\n        for (int k = 0; k < n; k++) {\\n            for (int i = 0; i < n; i++) {\\n                for (int j = 0; j < n; j++) {\\n                    if (dist[i][j] > dist[i][k] + dist[k][j]) {\\n                        dist[i][j] = dist[i][k] + dist[k][j];\\n                    }\\n                }\\n            }\\n        }\\n\\n        // found\\n        if (dist[src][dst] == t) {\\n            return edges;\\n        }\\n        // not possible\\n        if (dist[src][dst] < t) {\\n            return new int[][] {};\\n        }\\n\\n        for (int[] e : edges) {\\n            if (e[2] == INF) {\\n                e[2] = 1;\\n                update(n, dist, e[0], e[1], e[2]);\\n                update(n, dist, e[1], e[0], e[2]);\\n                if (dist[src][dst] <= t) {\\n                    e[2] += t - dist[src][dst];\\n                    update(n, dist, e[0], e[1], e[2]);\\n                    update(n, dist, e[1], e[0], e[2]);\\n                    return edges;\\n                }\\n            }\\n        }\\n        return new int[][] {};\\n    }\\n\\n    void update(int n, int[][] dist, int u, int v, int d) {\\n        if (dist[u][v] > d) {\\n            dist[u][v] = d;\\n            for (int i = 0; i < n; i++) {\\n                for (int j = 0; j < n; j++) {\\n                    if (dist[i][j] > dist[i][u] + dist[u][v] + dist[v][j]) {\\n                        dist[i][j] = dist[i][u] + dist[u][v] + dist[v][j];\\n                    }\\n                }\\n            }\\n        }           \\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549103,
                "title": "go-djikstra",
                "content": "# Intuition\\nGraph Problem\\n\\n# Approach\\nRead The hint\\nthe Hint state that \\n\\n- If the shortest path from source to destination without the edges to be modified, is less than the target, then it is not possible.\\n\\nso we build a graph without edges that has value -1 \\n\\nand after that we solve the problem using solve function\\nthe solve function using Djikstra algorithm.\\n\\nin djikstra we will need a priority queue that tell us what is the current shortest path\\n\\n- after we solve the graph if the solution is less than target\\nthen return empty array because hint state so.\\n\\n- if the solution is same with target then update -1 path to max variable (2 * 10^9)\\n\\n- if there is no solution or the solution is more than target the we will try to change edge that has value -1 to 1 and run the djikstra algorytm one by one.\\n    - if the result is less than target is mean that we have our solution and we must add more value for the last edges we change to match the target with this calculation \\n    addMoreInteger = target - result.\\n    - and then we just need to fill all -1 edges to maximum value(2 * 10^9)\\n- if all the -1 edges have been modify and we still not have our answer then we will return empty array\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```type queueList struct{\\n    node int\\n    weight int\\n    parent *queueList\\n}\\n\\nconst (\\n    MAX = 2000000000\\n)\\n\\n\\nfunc modifiedGraphEdges(n int, edges [][]int, source int, destination int, target int) [][]int {\\n    graph := make(map[int][]int,n)\\n    for i := 0 ; i < n ; i ++{\\n        graph[i] = make([]int,n)\\n    }\\n    MapAdj := make(map[int][]int,0)\\n    for _, e := range edges{\\n        v := e[2]\\n        if e[2] == -1 {\\n            continue\\n        }\\n        graph[e[0]][e[1]] = v\\n        graph[e[1]][e[0]] = v\\n\\n        if MapAdj[e[0]] == nil{\\n            MapAdj[e[0]] = []int{e[1]}\\n        }else{\\n            MapAdj[e[0]] = append(MapAdj[e[0]],e[1])\\n        }\\n\\n        if MapAdj[e[1]] == nil{\\n            MapAdj[e[1]] = []int{e[0]}\\n        }else{\\n            MapAdj[e[1]] = append(MapAdj[e[1]],e[0])\\n        }\\n    }\\n    solve := func(d ,t int, queue []queueList, visited map[int]bool) (*queueList){\\n        for len(queue) > 0 {\\n            curr := queue[0]\\n            queue = queue[1:]\\n            if curr.node == d {\\n                return &curr\\n            }\\n            for _, adj:= range MapAdj[curr.node]{\\n                if visited[adj] {\\n                    continue\\n                }\\n                queue = push(queue, queueList{adj, graph[curr.node][adj]+curr.weight, &curr})\\n            }\\n            visited[curr.node] = true\\n        }\\n        return  nil\\n    }\\n\\n    solutionList := solve(destination, target, []queueList{queueList{source,0, nil}}, make(map[int]bool,0))\\n    if solutionList != nil {\\n        if solutionList.weight < target {\\n            return [][]int{}\\n        }else if solutionList.weight == target{\\n            return fill(edges)\\n        }\\n    }\\n    for _, e := range edges{\\n        if e[2] != -1 {\\n            continue\\n        }\\n        e[2] = 1\\n        graph[e[0]][e[1]] = 1\\n        graph[e[1]][e[0]] = 1\\n        \\n        if MapAdj[e[0]] == nil{\\n            MapAdj[e[0]] = []int{e[1]}\\n        }else{\\n            MapAdj[e[0]] = append(MapAdj[e[0]],e[1])\\n        }\\n\\n        if MapAdj[e[1]] == nil{\\n            MapAdj[e[1]] = []int{e[0]}\\n        }else{\\n            MapAdj[e[1]] = append(MapAdj[e[1]],e[0])\\n        }\\n\\n        solutionList = solve(destination, target, []queueList{queueList{source,0, nil}}, make(map[int]bool,0))\\n        if solutionList != nil && solutionList.weight <= target{\\n            e[2] += target - solutionList.weight\\n            return fill(edges)\\n        }\\n    }\\n\\n    return [][]int{}\\n}\\n\\nfunc fill(edges [][]int)[][]int{\\n    for _, e := range edges{\\n        if e[2] == -1 {\\n            e[2] = MAX\\n        }\\n    }\\n    return edges\\n}\\n\\nfunc push(queue []queueList, newQueue queueList)[]queueList{\\n    index := len(queue)\\n    for index > 0 && queue[index-1].weight > newQueue.weight{\\n        index--\\n    }\\n    if index == 0 {\\n        queue = append([]queueList{newQueue},queue...)\\n        return queue\\n    }\\n    if index == len(queue){\\n        queue = append(queue,newQueue)\\n        return queue\\n    }\\n    queue = append(queue[:index+1], queue[index:]...)\\n    queue[index] = newQueue\\n    return queue\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```type queueList struct{\\n    node int\\n    weight int\\n    parent *queueList\\n}\\n\\nconst (\\n    MAX = 2000000000\\n)\\n\\n\\nfunc modifiedGraphEdges(n int, edges [][]int, source int, destination int, target int) [][]int {\\n    graph := make(map[int][]int,n)\\n    for i := 0 ; i < n ; i ++{\\n        graph[i] = make([]int,n)\\n    }\\n    MapAdj := make(map[int][]int,0)\\n    for _, e := range edges{\\n        v := e[2]\\n        if e[2] == -1 {\\n            continue\\n        }\\n        graph[e[0]][e[1]] = v\\n        graph[e[1]][e[0]] = v\\n\\n        if MapAdj[e[0]] == nil{\\n            MapAdj[e[0]] = []int{e[1]}\\n        }else{\\n            MapAdj[e[0]] = append(MapAdj[e[0]],e[1])\\n        }\\n\\n        if MapAdj[e[1]] == nil{\\n            MapAdj[e[1]] = []int{e[0]}\\n        }else{\\n            MapAdj[e[1]] = append(MapAdj[e[1]],e[0])\\n        }\\n    }\\n    solve := func(d ,t int, queue []queueList, visited map[int]bool) (*queueList){\\n        for len(queue) > 0 {\\n            curr := queue[0]\\n            queue = queue[1:]\\n            if curr.node == d {\\n                return &curr\\n            }\\n            for _, adj:= range MapAdj[curr.node]{\\n                if visited[adj] {\\n                    continue\\n                }\\n                queue = push(queue, queueList{adj, graph[curr.node][adj]+curr.weight, &curr})\\n            }\\n            visited[curr.node] = true\\n        }\\n        return  nil\\n    }\\n\\n    solutionList := solve(destination, target, []queueList{queueList{source,0, nil}}, make(map[int]bool,0))\\n    if solutionList != nil {\\n        if solutionList.weight < target {\\n            return [][]int{}\\n        }else if solutionList.weight == target{\\n            return fill(edges)\\n        }\\n    }\\n    for _, e := range edges{\\n        if e[2] != -1 {\\n            continue\\n        }\\n        e[2] = 1\\n        graph[e[0]][e[1]] = 1\\n        graph[e[1]][e[0]] = 1\\n        \\n        if MapAdj[e[0]] == nil{\\n            MapAdj[e[0]] = []int{e[1]}\\n        }else{\\n            MapAdj[e[0]] = append(MapAdj[e[0]],e[1])\\n        }\\n\\n        if MapAdj[e[1]] == nil{\\n            MapAdj[e[1]] = []int{e[0]}\\n        }else{\\n            MapAdj[e[1]] = append(MapAdj[e[1]],e[0])\\n        }\\n\\n        solutionList = solve(destination, target, []queueList{queueList{source,0, nil}}, make(map[int]bool,0))\\n        if solutionList != nil && solutionList.weight <= target{\\n            e[2] += target - solutionList.weight\\n            return fill(edges)\\n        }\\n    }\\n\\n    return [][]int{}\\n}\\n\\nfunc fill(edges [][]int)[][]int{\\n    for _, e := range edges{\\n        if e[2] == -1 {\\n            e[2] = MAX\\n        }\\n    }\\n    return edges\\n}\\n\\nfunc push(queue []queueList, newQueue queueList)[]queueList{\\n    index := len(queue)\\n    for index > 0 && queue[index-1].weight > newQueue.weight{\\n        index--\\n    }\\n    if index == 0 {\\n        queue = append([]queueList{newQueue},queue...)\\n        return queue\\n    }\\n    if index == len(queue){\\n        queue = append(queue,newQueue)\\n        return queue\\n    }\\n    queue = append(queue[:index+1], queue[index:]...)\\n    queue[index] = newQueue\\n    return queue\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3549035,
                "title": "python-simple-dijkstra-s-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def modifiedGraphEdges(self, n, edges, source, destination, target):\\n        dict1, ans, res = defaultdict(set), [], []\\n\\n        for i,j,w in edges:\\n            if w != -1:\\n                dict1[i].add((j,w))\\n                dict1[j].add((i,w))\\n                res.append([i,j,w])\\n            else:\\n                ans.append((i,j))\\n\\n        def dfs(src,des):\\n            dist = [2*10**9 for _ in range(n)]\\n\\n            dist[src] = 0\\n\\n            stack, res = [(src,0)], []\\n\\n            while stack:\\n                node,val = heappop(stack)\\n\\n                for neighbor,weight in dict1[node]:\\n                    if dist[neighbor] > weight + val:\\n                        dist[neighbor] = weight + val\\n                        heappush(stack,(neighbor,weight+val))\\n\\n            return dist\\n\\n    \\n        if dfs(source,destination)[destination] < target: return []\\n\\n        i, m = 0, len(ans)\\n\\n        while i < m and dfs(source,destination)[destination] > target:\\n            a,b = ans[i]\\n            i += 1\\n            dict1[a].add((b,1))\\n            dict1[b].add((a,1))\\n\\n            if dfs(source,destination)[destination] <= target:\\n                res.append([a,b,1+target-dfs(source,destination)[destination]])\\n                break\\n\\n            res.append([a,b,1])\\n\\n        if dfs(source,destination)[destination] > target: return []\\n\\n        while i < m:\\n            a,b = ans[i]\\n            res.append([a,b,2*10**9])\\n            i += 1\\n\\n        return res\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def modifiedGraphEdges(self, n, edges, source, destination, target):\\n        dict1, ans, res = defaultdict(set), [], []\\n\\n        for i,j,w in edges:\\n            if w != -1:\\n                dict1[i].add((j,w))\\n                dict1[j].add((i,w))\\n                res.append([i,j,w])\\n            else:\\n                ans.append((i,j))\\n\\n        def dfs(src,des):\\n            dist = [2*10**9 for _ in range(n)]\\n\\n            dist[src] = 0\\n\\n            stack, res = [(src,0)], []\\n\\n            while stack:\\n                node,val = heappop(stack)\\n\\n                for neighbor,weight in dict1[node]:\\n                    if dist[neighbor] > weight + val:\\n                        dist[neighbor] = weight + val\\n                        heappush(stack,(neighbor,weight+val))\\n\\n            return dist\\n\\n    \\n        if dfs(source,destination)[destination] < target: return []\\n\\n        i, m = 0, len(ans)\\n\\n        while i < m and dfs(source,destination)[destination] > target:\\n            a,b = ans[i]\\n            i += 1\\n            dict1[a].add((b,1))\\n            dict1[b].add((a,1))\\n\\n            if dfs(source,destination)[destination] <= target:\\n                res.append([a,b,1+target-dfs(source,destination)[destination]])\\n                break\\n\\n            res.append([a,b,1])\\n\\n        if dfs(source,destination)[destination] > target: return []\\n\\n        while i < m:\\n            a,b = ans[i]\\n            res.append([a,b,2*10**9])\\n            i += 1\\n\\n        return res\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3548447,
                "title": "c-dijkstra-2",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int src, int dst, int target) {\\n        vector<vector<pair<int, vector<int>*>>> adj(n);\\n        for (auto& e: edges) {\\n            adj[e[0]].emplace_back(e[1], &e);\\n            adj[e[1]].emplace_back(e[0], &e);\\n        }\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;\\n        // shortest path from dst\\n        pq.emplace(0, dst);\\n        vector<int> dd(n, INT_MAX);\\n        dd[dst] = 0;\\n        while (!pq.empty()) {\\n            auto [d_u, u] = pq.top(); pq.pop();\\n            if (d_u == dd[u]) {\\n                for (auto& [v, e]: adj[u]) {\\n                    int w = e->at(2);\\n                    if (w == -1)\\n                        w = 1;\\n                    if (dd[v] > dd[u] + w) {\\n                        dd[v] = dd[u] + w;\\n                        pq.emplace(dd[v], v);\\n                    }\\n                }\\n            }\\n        }\\n        // shortest path from src\\n        pq.emplace(0, src);\\n        vector<int> ds(n, INT_MAX);\\n        ds[src] = 0;\\n        while (!pq.empty()) {\\n            auto [d_u, u] = pq.top(); pq.pop();\\n            if (d_u == ds[u]) {\\n                for (auto& [v, e]: adj[u]) {\\n                    int &w = e->at(2);\\n                    if (w == -1)\\n                        w = max(1, target - ds[u] - dd[v]);\\n                    if (ds[v] > ds[u] + w) {\\n                        ds[v] = ds[u] + w;\\n                        pq.emplace(ds[v], v);\\n                    }\\n                }\\n            }\\n        }\\n        return ds[dst] == target ? edges : vector<vector<int>>{};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int src, int dst, int target) {\\n        vector<vector<pair<int, vector<int>*>>> adj(n);\\n        for (auto& e: edges) {\\n            adj[e[0]].emplace_back(e[1], &e);\\n            adj[e[1]].emplace_back(e[0], &e);\\n        }\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;\\n        // shortest path from dst\\n        pq.emplace(0, dst);\\n        vector<int> dd(n, INT_MAX);\\n        dd[dst] = 0;\\n        while (!pq.empty()) {\\n            auto [d_u, u] = pq.top(); pq.pop();\\n            if (d_u == dd[u]) {\\n                for (auto& [v, e]: adj[u]) {\\n                    int w = e->at(2);\\n                    if (w == -1)\\n                        w = 1;\\n                    if (dd[v] > dd[u] + w) {\\n                        dd[v] = dd[u] + w;\\n                        pq.emplace(dd[v], v);\\n                    }\\n                }\\n            }\\n        }\\n        // shortest path from src\\n        pq.emplace(0, src);\\n        vector<int> ds(n, INT_MAX);\\n        ds[src] = 0;\\n        while (!pq.empty()) {\\n            auto [d_u, u] = pq.top(); pq.pop();\\n            if (d_u == ds[u]) {\\n                for (auto& [v, e]: adj[u]) {\\n                    int &w = e->at(2);\\n                    if (w == -1)\\n                        w = max(1, target - ds[u] - dd[v]);\\n                    if (ds[v] > ds[u] + w) {\\n                        ds[v] = ds[u] + w;\\n                        pq.emplace(ds[v], v);\\n                    }\\n                }\\n            }\\n        }\\n        return ds[dst] == target ? edges : vector<vector<int>>{};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3548238,
                "title": "floyd-o-n-3-280ms-ac-solution",
                "content": "# Intuition\\nFirst run floyd without considering any -1 edges, then try to add -1 edges to the graph one by one, each time introduce an -1 edge and run 2 * O(n^2) to relax the two vertex of the edge, if an edge can be modified to make the shortest path = target, then stop and assign all other unvisited -1 edges to max(2e9).\\n\\n# Complexity\\n- Time complexity:\\nO(n^3) for first floyd, O(n^2 * E * 2) for introducing edges where E is the number of -1 edges, we can tell that E is at most O(n) as n - 1 edges can maintain the connectivity of a graph with n nodes.\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] modifiedGraphEdges(int n, int[][] edges, int src, int dst, int t) {\\n        // init\\n        int[][] dp = new int[n][n];\\n        for (int i = 0; i < n; i++) Arrays.fill(dp[i], (int) 1e9 + 1);\\n        for (int i = 0; i < n; i++) dp[i][i] = 0;\\n        List<int[]> list = new ArrayList();\\n        int[][] w = new int[n][n];\\n\\n        for (int e[] : edges) {\\n            int u = e[0];\\n            int v = e[1];\\n            int d = e[2];\\n            w[u][v] = d;\\n            w[v][u] = d;\\n            if (d != -1) {\\n                dp[u][v] = d;\\n                dp[v][u] = d;\\n            } else {\\n                list.add(new int[]{u, v});\\n            }\\n        }\\n\\n        // first floyd, all -1 edges are not considered\\n        for (int k = 0; k < n; k++) {\\n            for (int i = 0; i < n; i++) {\\n                for (int j = 0; j < n; j++) {\\n                    dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k][j]);\\n                }\\n            }\\n        }\\n\\n        // there\\'s already a path with dis < target\\n        if (dp[src][dst] < t) return new int[0][0];\\n        // there\\'s already a path with dis = target\\n        if (dp[src][dst] == t) {\\n            help(edges, w);\\n            return edges;\\n        }\\n\\n        // introdue -1 edges, consider to add them with min value 1\\n        for (int[] e : list) {\\n            int u = e[0];\\n            int v = e[1];\\n            w[u][v] = 1;\\n            w[v][u] = 1;\\n            dp[u][v] = 1;\\n            dp[v][u] = 1;\\n            // u, v are the vertices of current edge\\n            // add u, this is same as one time relax in floyd \\n            for (int i = 0; i < n; i++) {\\n                for (int j = 0; j < n; j++) {\\n                    dp[i][j] = Math.min(dp[i][j], dp[i][u] + dp[u][j]);\\n                }\\n            }\\n            // add v, same as u\\n            for (int i = 0; i < n; i++) {\\n                for (int j = 0; j < n; j++) {\\n                    dp[i][j] = Math.min(dp[i][j], dp[i][v] + dp[v][j]);\\n                }\\n            }\\n            // if we can do that, recalculate the current -1 edge\\'s \\n            // value, assign all not iterated edges to max, and return\\n            if (dp[src][dst] <= t) {\\n                w[u][v] += t - dp[src][dst];\\n                w[v][u] += t - dp[src][dst];\\n                help(edges, w);\\n                return edges;\\n            }\\n        }\\n\\n        // all -1 edges are added with min length and no solution is found\\n        return new int[0][0];\\n    }\\n\\n    // modify edges\\' values\\n    public void help(int[][] edges, int[][] w) {\\n        for (int e[] : edges) {\\n            int u = e[0];\\n            int v = e[1];\\n            e[2] = w[u][v];\\n            if (e[2] == -1) e[2] = (int) 1e9 + 1;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] modifiedGraphEdges(int n, int[][] edges, int src, int dst, int t) {\\n        // init\\n        int[][] dp = new int[n][n];\\n        for (int i = 0; i < n; i++) Arrays.fill(dp[i], (int) 1e9 + 1);\\n        for (int i = 0; i < n; i++) dp[i][i] = 0;\\n        List<int[]> list = new ArrayList();\\n        int[][] w = new int[n][n];\\n\\n        for (int e[] : edges) {\\n            int u = e[0];\\n            int v = e[1];\\n            int d = e[2];\\n            w[u][v] = d;\\n            w[v][u] = d;\\n            if (d != -1) {\\n                dp[u][v] = d;\\n                dp[v][u] = d;\\n            } else {\\n                list.add(new int[]{u, v});\\n            }\\n        }\\n\\n        // first floyd, all -1 edges are not considered\\n        for (int k = 0; k < n; k++) {\\n            for (int i = 0; i < n; i++) {\\n                for (int j = 0; j < n; j++) {\\n                    dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k][j]);\\n                }\\n            }\\n        }\\n\\n        // there\\'s already a path with dis < target\\n        if (dp[src][dst] < t) return new int[0][0];\\n        // there\\'s already a path with dis = target\\n        if (dp[src][dst] == t) {\\n            help(edges, w);\\n            return edges;\\n        }\\n\\n        // introdue -1 edges, consider to add them with min value 1\\n        for (int[] e : list) {\\n            int u = e[0];\\n            int v = e[1];\\n            w[u][v] = 1;\\n            w[v][u] = 1;\\n            dp[u][v] = 1;\\n            dp[v][u] = 1;\\n            // u, v are the vertices of current edge\\n            // add u, this is same as one time relax in floyd \\n            for (int i = 0; i < n; i++) {\\n                for (int j = 0; j < n; j++) {\\n                    dp[i][j] = Math.min(dp[i][j], dp[i][u] + dp[u][j]);\\n                }\\n            }\\n            // add v, same as u\\n            for (int i = 0; i < n; i++) {\\n                for (int j = 0; j < n; j++) {\\n                    dp[i][j] = Math.min(dp[i][j], dp[i][v] + dp[v][j]);\\n                }\\n            }\\n            // if we can do that, recalculate the current -1 edge\\'s \\n            // value, assign all not iterated edges to max, and return\\n            if (dp[src][dst] <= t) {\\n                w[u][v] += t - dp[src][dst];\\n                w[v][u] += t - dp[src][dst];\\n                help(edges, w);\\n                return edges;\\n            }\\n        }\\n\\n        // all -1 edges are added with min length and no solution is found\\n        return new int[0][0];\\n    }\\n\\n    // modify edges\\' values\\n    public void help(int[][] edges, int[][] w) {\\n        for (int e[] : edges) {\\n            int u = e[0];\\n            int v = e[1];\\n            e[2] = w[u][v];\\n            if (e[2] == -1) e[2] = (int) 1e9 + 1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3548017,
                "title": "easy-dijkatra-s-algorithm",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int source, int destination, int target) {\\n        vector<pair<int, int>> g[n];\\n        vector<long long> dist(n,1e18);\\n        \\n        for(int i=0; i<edges.size(); i++){\\n            int x=edges[i][0];\\n            int y=edges[i][1];\\n            int wt=edges[i][2];\\n            if(wt==-1){\\n                continue;\\n            }\\n            g[x].push_back({y, wt});\\n            g[y].push_back({x, wt});\\n        }\\n        \\n        set<pair<long long, int>> s;\\n        s.insert({0, source});\\n        dist[source]=0;\\n        \\n        while(!s.empty()){\\n            auto it=*(s.begin());\\n            auto node=it.second;\\n            auto wt=it.first;\\n            s.erase(s.begin());\\n            \\n            if(node==destination){\\n                if(wt<target){\\n                    return {};\\n                }else if(wt==target){\\n                    for(int j=0; j<edges.size(); j++){\\n                        if(edges[j][2]==-1){\\n                            edges[j][2]=1e9;\\n                        }\\n                    }\\n                    return edges;\\n                }\\n                break;\\n            }\\n            for(auto child:g[node]){\\n                if(wt+child.second<dist[child.first]){\\n                    dist[child.first]=wt+child.second;\\n                    s.insert({dist[child.first], child.first});\\n                }\\n            }\\n        }\\n\\n        for(int i=0; i<edges.size(); i++){\\n            int x=edges[i][0];\\n            int y=edges[i][1];\\n            \\n            if(edges[i][2]==-1){\\n               edges[i][2]=1;\\n               g[x].push_back({y, edges[i][2]});\\n               g[y].push_back({x, edges[i][2]});\\n               \\n               s.clear();\\n               for(int j=0; j<n; j++){\\n                   dist[j]=1e18;\\n               }\\n                \\n               s.insert({0, source});\\n               dist[source]=0;\\n        \\n               while(!s.empty()){\\n                  auto it=*(s.begin());\\n                  auto node=it.second;\\n                  auto wt=it.first;\\n                  s.erase(s.begin());\\n            \\n                  if(node==destination){\\n                    if(wt<=target){\\n                      edges[i][2]+=(target-wt);\\n                      for(int j=0; j<edges.size(); j++){\\n                          if(edges[j][2]==-1){\\n                              edges[j][2]=1e9;\\n                          }\\n                      }\\n                      return edges;\\n                    }\\n                  }\\n                  for(auto child:g[node]){\\n                    if(wt+child.second<dist[child.first]){\\n                      dist[child.first]=wt+child.second;\\n                      s.insert({dist[child.first], child.first});\\n                    } \\n                  }\\n               }\\n            }\\n        }\\n        \\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int source, int destination, int target) {\\n        vector<pair<int, int>> g[n];\\n        vector<long long> dist(n,1e18);\\n        \\n        for(int i=0; i<edges.size(); i++){\\n            int x=edges[i][0];\\n            int y=edges[i][1];\\n            int wt=edges[i][2];\\n            if(wt==-1){\\n                continue;\\n            }\\n            g[x].push_back({y, wt});\\n            g[y].push_back({x, wt});\\n        }\\n        \\n        set<pair<long long, int>> s;\\n        s.insert({0, source});\\n        dist[source]=0;\\n        \\n        while(!s.empty()){\\n            auto it=*(s.begin());\\n            auto node=it.second;\\n            auto wt=it.first;\\n            s.erase(s.begin());\\n            \\n            if(node==destination){\\n                if(wt<target){\\n                    return {};\\n                }else if(wt==target){\\n                    for(int j=0; j<edges.size(); j++){\\n                        if(edges[j][2]==-1){\\n                            edges[j][2]=1e9;\\n                        }\\n                    }\\n                    return edges;\\n                }\\n                break;\\n            }\\n            for(auto child:g[node]){\\n                if(wt+child.second<dist[child.first]){\\n                    dist[child.first]=wt+child.second;\\n                    s.insert({dist[child.first], child.first});\\n                }\\n            }\\n        }\\n\\n        for(int i=0; i<edges.size(); i++){\\n            int x=edges[i][0];\\n            int y=edges[i][1];\\n            \\n            if(edges[i][2]==-1){\\n               edges[i][2]=1;\\n               g[x].push_back({y, edges[i][2]});\\n               g[y].push_back({x, edges[i][2]});\\n               \\n               s.clear();\\n               for(int j=0; j<n; j++){\\n                   dist[j]=1e18;\\n               }\\n                \\n               s.insert({0, source});\\n               dist[source]=0;\\n        \\n               while(!s.empty()){\\n                  auto it=*(s.begin());\\n                  auto node=it.second;\\n                  auto wt=it.first;\\n                  s.erase(s.begin());\\n            \\n                  if(node==destination){\\n                    if(wt<=target){\\n                      edges[i][2]+=(target-wt);\\n                      for(int j=0; j<edges.size(); j++){\\n                          if(edges[j][2]==-1){\\n                              edges[j][2]=1e9;\\n                          }\\n                      }\\n                      return edges;\\n                    }\\n                  }\\n                  for(auto child:g[node]){\\n                    if(wt+child.second<dist[child.first]){\\n                      dist[child.first]=wt+child.second;\\n                      s.insert({dist[child.first], child.first});\\n                    } \\n                  }\\n               }\\n            }\\n        }\\n        \\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547216,
                "title": "python3-dijkstra-s-algo-twice",
                "content": "\\n```\\nclass Solution:\\n    def modifiedGraphEdges(self, n: int, edges: List[List[int]], source: int, destination: int, target: int) -> List[List[int]]:\\n        graph = [[0]*n for _ in range(n)]\\n        for u, v, w in edges: graph[u][v] = graph[v][u] = w\\n        orig = [inf] * n\\n        orig[source] = 0 \\n        pq = [(0, source)]\\n        while pq: \\n            d, u = heappop(pq)\\n            if d == orig[u]: \\n                for v, w in enumerate(graph[u]): \\n                    if w and w != -1 and d+w < orig[v]: \\n                        orig[v] = d+w\\n                        heappush(pq, (orig[v], v))\\n        if orig[destination] < target: return []\\n        if orig[destination] == target: \\n            ans = []\\n            for u, v, w in edges: \\n                if w == -1: w = 2_000_000_000\\n                ans.append([u, v, w])\\n            return ans \\n        dist = [inf] * n\\n        dist[source] = 0 \\n        parent = [-1] * n \\n        pq = [(0, source)]\\n        while pq: \\n            d, u = heappop(pq)\\n            if u == destination: break \\n            if d == dist[u]: \\n                for v, w in enumerate(graph[u]): \\n                    if w: \\n                        if w == -1: dd = d+1\\n                        else: dd = d+w\\n                        if dd < dist[v]: \\n                            dist[v] = dd \\n                            parent[v] = u \\n                            heappush(pq, (dd, v))\\n        if d > target: return []\\n        while u >= 0: \\n            p = parent[u]\\n            if p >= 0: \\n                if graph[p][u] == -1: \\n                    if orig[p] < target: \\n                        graph[p][u] = graph[u][p] = target - orig[p]\\n                        break \\n                    graph[p][u] = graph[u][p] = 1 \\n                target -= graph[u][p]\\n            u = p \\n        ans = []\\n        for u, v, w in edges: \\n            if graph[u][v] == -1: graph[u][v] = 2_000_000_000\\n            ans.append([u, v, graph[u][v]])\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def modifiedGraphEdges(self, n: int, edges: List[List[int]], source: int, destination: int, target: int) -> List[List[int]]:\\n        graph = [[0]*n for _ in range(n)]\\n        for u, v, w in edges: graph[u][v] = graph[v][u] = w\\n        orig = [inf] * n\\n        orig[source] = 0 \\n        pq = [(0, source)]\\n        while pq: \\n            d, u = heappop(pq)\\n            if d == orig[u]: \\n                for v, w in enumerate(graph[u]): \\n                    if w and w != -1 and d+w < orig[v]: \\n                        orig[v] = d+w\\n                        heappush(pq, (orig[v], v))\\n        if orig[destination] < target: return []\\n        if orig[destination] == target: \\n            ans = []\\n            for u, v, w in edges: \\n                if w == -1: w = 2_000_000_000\\n                ans.append([u, v, w])\\n            return ans \\n        dist = [inf] * n\\n        dist[source] = 0 \\n        parent = [-1] * n \\n        pq = [(0, source)]\\n        while pq: \\n            d, u = heappop(pq)\\n            if u == destination: break \\n            if d == dist[u]: \\n                for v, w in enumerate(graph[u]): \\n                    if w: \\n                        if w == -1: dd = d+1\\n                        else: dd = d+w\\n                        if dd < dist[v]: \\n                            dist[v] = dd \\n                            parent[v] = u \\n                            heappush(pq, (dd, v))\\n        if d > target: return []\\n        while u >= 0: \\n            p = parent[u]\\n            if p >= 0: \\n                if graph[p][u] == -1: \\n                    if orig[p] < target: \\n                        graph[p][u] = graph[u][p] = target - orig[p]\\n                        break \\n                    graph[p][u] = graph[u][p] = 1 \\n                target -= graph[u][p]\\n            u = p \\n        ans = []\\n        for u, v, w in edges: \\n            if graph[u][v] == -1: graph[u][v] = 2_000_000_000\\n            ans.append([u, v, graph[u][v]])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547039,
                "title": "tricky-dijkstra-easy-java-code-with-comments",
                "content": "The Problem is a bit tricky.  You need to iterate through all the shortest path less than target by initiating all the -1 edges as 1(the shortest possible.), and make them equal to target.\\nIf the shortest path distance is more than target, then need to return the empty array.\\n\\n\\nThe Java solution - \\n```\\nclass Solution {\\n    public int[][] modifiedGraphEdges(int n, int[][] edges, int source, int destination, int target) {\\n\\t//build the complete graph with edges\\n        int adj[][] = new int[n][n];\\n        for(int i [] :edges){\\n            int a = i[0];\\n            int b = i[1];\\n            int w = i[2];\\n            adj[a][b] = w;\\n            adj[b][a] = w;\\n        }\\n\\t\\t//get the shortest path distance the traversing path using Dijkstra , assuming the -1 edges to be the shortest possible edge, i.e., 1.\\n        Pair shortestPath = findPath(adj, source, destination, target); \\n\\t\\t//if the shortest path distance is greater than the target, return empty array\\n        if(shortestPath == null){\\n            return new int[][]{};\\n        }else if(shortestPath.w == target){\\n\\t\\t// if the shortest path distance equals the target, return the new graph\\n            return fill(adj);\\n        }else{\\n\\t\\t//There can be multiple shortest path, so to make them all equal to target, iterate through them and make the first edge \\n\\t\\t//that is modifieable to be the shortest possible value, i.e., target - pathDistance +1 and then look for other paths.\\n            while(true){\\n                int []curr = findFirstModifieableIndex(shortestPath.parent, destination, source, adj);\\n                if(curr == null){\\n                    return new int[][]{};\\n                }\\n                adj[curr[0]][curr[1]] = target-shortestPath.w+1;\\n                adj[curr[1]][curr[0]] = target-shortestPath.w+1;\\n                shortestPath = findPath(adj,source,destination, target);\\n\\n                if(shortestPath.w == target){\\n                    return fill(adj);\\n                }else if(shortestPath.w>target){\\n                    return new int[][]{};\\n                }\\n            }\\n        }    \\n    }\\n    \\n\\t//finds the first edge that\\'s modifiable\\n    int[] findFirstModifieableIndex(int []parent, int dest, int source, int adj[][]){\\n        List<Integer> list = new ArrayList<>();\\n        int curr = dest;\\n        while(curr!=-1){\\n            list.add(curr);\\n            curr = parent[curr];\\n        }\\n        Collections.reverse(list);\\n        for(int i = 0;i<list.size()-1;i++){\\n            int v = list.get(i);\\n            int v2 = list.get(i+1);\\n            if(adj[v][v2]==-1){\\n                return new int[]{v,v2};\\n            }\\n        }\\n        return null;\\n    }\\n    \\n    //returns the edges from the graph\\n    int[][] fill(int [][] adj){\\n        int n = adj.length;\\n        List<int[]> list = new ArrayList<>();\\n        for(int i = 0;i<n;i++){\\n            for(int j = i+1;j<n;j++){\\n                if(adj[i][j]!=0){\\n                    int c = adj[i][j];\\n                    if(c==-1){\\n                        c = 1;\\n                    }\\n                    list.add(new int[]{i,j,c});\\n                }\\n            }\\n        }\\n        int res[][] = new int[list.size()][3];\\n        for(int i = 0;i<list.size();i++){\\n            res[i] = list.get(i);\\n        }\\n        return res;\\n    }\\n\\t\\n\\t//Modified Dijkstra\\n    Pair findPath(int[][] adj, int source, int destination, int target){\\n        int n = adj.length;\\n        int dist[] = new int[n];\\n        int parent[] = new int[n];\\n        Arrays.fill(dist,Integer.MAX_VALUE);\\n        Arrays.fill(parent,-1);\\n        dist[source ] = 0;\\n        parent[source] = -1;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)->a[1]-b[1]);\\n        pq.offer(new int[]{source,dist[source]});\\n        while(!pq.isEmpty()){\\n            int curr [] = pq.poll();\\n            int c = curr[0], w = curr[1];\\n            if(w>target){\\n                \\n                return null;\\n            }\\n            if(c==destination){\\n                return new Pair(w,parent);\\n            }\\n            for(int i = 0;i<n;i++){\\n                if(adj[c][i] != 0 ){\\n                    int nw = adj[c][i];\\n                    if(nw == -1){\\n                        nw = 1;\\n                    }\\n                    if(nw + w < dist[i]){\\n                        dist[i] = nw+w;\\n                        parent[i] = c;\\n                        pq.offer(new int[]{i, dist[i]});\\n                    }\\n                }\\n            }\\n        }\\n        return null;\\n    }\\n    class Pair{\\n        int w;\\n        int[] parent;\\n        Pair(int w, int [] parent){\\n            this.w = w;\\n            this.parent = parent;\\n        }\\n    }\\n}\\n```\\n\\nPlease upvote if it helped you.",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] modifiedGraphEdges(int n, int[][] edges, int source, int destination, int target) {\\n\\t//build the complete graph with edges\\n        int adj[][] = new int[n][n];\\n        for(int i [] :edges){\\n            int a = i[0];\\n            int b = i[1];\\n            int w = i[2];\\n            adj[a][b] = w;\\n            adj[b][a] = w;\\n        }\\n\\t\\t//get the shortest path distance the traversing path using Dijkstra , assuming the -1 edges to be the shortest possible edge, i.e., 1.\\n        Pair shortestPath = findPath(adj, source, destination, target); \\n\\t\\t//if the shortest path distance is greater than the target, return empty array\\n        if(shortestPath == null){\\n            return new int[][]{};\\n        }else if(shortestPath.w == target){\\n\\t\\t// if the shortest path distance equals the target, return the new graph\\n            return fill(adj);\\n        }else{\\n\\t\\t//There can be multiple shortest path, so to make them all equal to target, iterate through them and make the first edge \\n\\t\\t//that is modifieable to be the shortest possible value, i.e., target - pathDistance +1 and then look for other paths.\\n            while(true){\\n                int []curr = findFirstModifieableIndex(shortestPath.parent, destination, source, adj);\\n                if(curr == null){\\n                    return new int[][]{};\\n                }\\n                adj[curr[0]][curr[1]] = target-shortestPath.w+1;\\n                adj[curr[1]][curr[0]] = target-shortestPath.w+1;\\n                shortestPath = findPath(adj,source,destination, target);\\n\\n                if(shortestPath.w == target){\\n                    return fill(adj);\\n                }else if(shortestPath.w>target){\\n                    return new int[][]{};\\n                }\\n            }\\n        }    \\n    }\\n    \\n\\t//finds the first edge that\\'s modifiable\\n    int[] findFirstModifieableIndex(int []parent, int dest, int source, int adj[][]){\\n        List<Integer> list = new ArrayList<>();\\n        int curr = dest;\\n        while(curr!=-1){\\n            list.add(curr);\\n            curr = parent[curr];\\n        }\\n        Collections.reverse(list);\\n        for(int i = 0;i<list.size()-1;i++){\\n            int v = list.get(i);\\n            int v2 = list.get(i+1);\\n            if(adj[v][v2]==-1){\\n                return new int[]{v,v2};\\n            }\\n        }\\n        return null;\\n    }\\n    \\n    //returns the edges from the graph\\n    int[][] fill(int [][] adj){\\n        int n = adj.length;\\n        List<int[]> list = new ArrayList<>();\\n        for(int i = 0;i<n;i++){\\n            for(int j = i+1;j<n;j++){\\n                if(adj[i][j]!=0){\\n                    int c = adj[i][j];\\n                    if(c==-1){\\n                        c = 1;\\n                    }\\n                    list.add(new int[]{i,j,c});\\n                }\\n            }\\n        }\\n        int res[][] = new int[list.size()][3];\\n        for(int i = 0;i<list.size();i++){\\n            res[i] = list.get(i);\\n        }\\n        return res;\\n    }\\n\\t\\n\\t//Modified Dijkstra\\n    Pair findPath(int[][] adj, int source, int destination, int target){\\n        int n = adj.length;\\n        int dist[] = new int[n];\\n        int parent[] = new int[n];\\n        Arrays.fill(dist,Integer.MAX_VALUE);\\n        Arrays.fill(parent,-1);\\n        dist[source ] = 0;\\n        parent[source] = -1;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)->a[1]-b[1]);\\n        pq.offer(new int[]{source,dist[source]});\\n        while(!pq.isEmpty()){\\n            int curr [] = pq.poll();\\n            int c = curr[0], w = curr[1];\\n            if(w>target){\\n                \\n                return null;\\n            }\\n            if(c==destination){\\n                return new Pair(w,parent);\\n            }\\n            for(int i = 0;i<n;i++){\\n                if(adj[c][i] != 0 ){\\n                    int nw = adj[c][i];\\n                    if(nw == -1){\\n                        nw = 1;\\n                    }\\n                    if(nw + w < dist[i]){\\n                        dist[i] = nw+w;\\n                        parent[i] = c;\\n                        pq.offer(new int[]{i, dist[i]});\\n                    }\\n                }\\n            }\\n        }\\n        return null;\\n    }\\n    class Pair{\\n        int w;\\n        int[] parent;\\n        Pair(int w, int [] parent){\\n            this.w = w;\\n            this.parent = parent;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546968,
                "title": "why-this-logic-fails",
                "content": "My approach - \\nI ran dijkstra to find out the shortest path from source, treating -1 path as 0 and also tracked all the nodes in the path. Then I calcuated the number of -1 edges in the path. Then, found out the difference between target and current path sum. We can now fill all -1 edges in the path by 1 except for last one filling with [difference - (neg edges count - 1)].  \\n(If there are no edges and difference > 0) or (if difference < 0), return [].\\nPlease correct me where am I going wrong ?\\n\\nInput:\\n4\\n[[0,1,-1],[1,2,-1],[3,1,-1],[3,0,2],[0,2,5]]\\n2\\n3\\n8\\n\\nHow is the expected output [] (impossible)? Can\\'t we change the weight of edges 1-2 to 1 and 3-1 to 7 in order to achieve target 8?\\nAm I missing something in the problem.",
                "solutionTags": [],
                "code": "My approach - \\nI ran dijkstra to find out the shortest path from source, treating -1 path as 0 and also tracked all the nodes in the path. Then I calcuated the number of -1 edges in the path. Then, found out the difference between target and current path sum. We can now fill all -1 edges in the path by 1 except for last one filling with [difference - (neg edges count - 1)].  \\n(If there are no edges and difference > 0) or (if difference < 0), return [].\\nPlease correct me where am I going wrong ?\\n\\nInput:\\n4\\n[[0,1,-1],[1,2,-1],[3,1,-1],[3,0,2],[0,2,5]]\\n2\\n3\\n8\\n\\nHow is the expected output [] (impossible)? Can\\'t we change the weight of edges 1-2 to 1 and 3-1 to 7 in order to achieve target 8?\\nAm I missing something in the problem.",
                "codeTag": "Unknown"
            },
            {
                "id": 4067759,
                "title": "c-dfs-solution-beating-94",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDo DFS from source untill destination found. Store all qualified paths and compare. Modify the chosen path to match target.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Set up and intialize nodes. I use unordered_map to store neighbor-edgeIndex pairs.\\n\\n2. Write DFS routine in recursive manner.  \\n- Use a set to store visited nodes to avoid circular search.\\n- Use a vector to store the current path( in the form of edge indice)\\n- I use \\'currSum\\' to store the minimum total cost of the current path. Once it\\'s over target, the subroutine should be ended.\\n- For each time reaching the destination, insert the path (if qualified) to \\'ans\\' (a 2D vector) as candidates. Except for edges of this qualified path, we set all other -1s of the graph to 1e9. This will narrow down our choices and improve the DFS speed due to the currSum-target mechanism. This will also ensure the final candidates in \\'ans\\' have the same amount of -1s and share the exactly same -1 edges.\\n- At destination if the path has no -1 (all positive), and its currSum < target. That means no solution! We can terminate the entire DFS and return empty list immediately.\\n\\n3. Add a positive mode for DFS only traversing positive edges. Call DFS in positive mode first. This will save us tons of time from solving an unsolvable case. Then we call DFS in normal mode for the paths with -1s. Note this is my most important step to overcome time limit for huge-size test cases.\\n\\n4. Compare all candidate paths in \\'ans\\' and choose the final path to modify. I obey the following rules to make sure the chosen one is the shortest while its cost equlas to target:\\n- Choose the path with the least minimum cost.\\n- Modify one -1 edge to match target while the other -1 edges are set to +1.\\n\\n5. When you read my source code, please be aware:\\n- I post my first working submission (that I didn\\'t expect to pass). So I didn\\'t tidy up the code and many line are deletable.\\n- Member function MS and most lines after calling DFS (in the main) are redundant and deletable. It\\'s all about comparing candidates and chosing the final path to modify.\\n- Ignore unused globals like the bool \\'perfect\\' .\\n \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\nstruct Node{\\n    unordered_map<int, int> map; //map for neigbor-edgeindex pairs\\n};\\npublic:\\n    int currSum=0;//edge sum for the ongoing path\\n    int nn=0;// # of -1s in the current complete path\\n    vector<vector<int>> ans;// all paths {1st edge\\'s index,2nd edge\\'s index,...}\\n    vector<int> fa1_set; // all possible path(min cost<= target) with -1 edges (index in ans)\\n    vector<int> el;//edge list for the ongoing path\\n    set<int> q;// queue for visited nodes\\n    bool ap=false; // all postive edges \\n    bool apS=false; // found all positive solution\\n    bool stop=false;// stop DFS once we found a all-positve path shorter than target \\n    bool perfect=false; //stop following DFS from using negtive edges once we found a solution with only one -1 edge(perfect path)\\n    bool found=false;// if we find a complete path with negative edges, we can set all other -1 egdes( not on that path) to 2e9 so that we only focus on possible solutions related to these negative edges\\n    // we can write a on_found for it.\\n\\n    void on_found(vector<vector<int>>& edges){ //set all -1 to 2e7 except the -1 edge inside the el\\n        // if(found){return;} //run only one time\\n        int s=edges.size();\\n        if (nn==0){\\n            for(int k=0;k<s;k++){\\n                if(edges[k][2]==-1){edges[k][2]=1e9;}\\n            }\\n        }\\n        else{            \\n            for(int k=0;k<s;k++){\\n                if(edges[k][2]==-1){\\n                    auto it = find(el.begin(),el.end(),k);\\n                    if(it==el.end()){edges[k][2]=1e9;}\\n                }\\n            }\\n        }\\n    }\\n    int calmin(vector<int> a,vector<vector<int>>& edges){ //calculate min cost of a path\\n        int sum=0;\\n        nn=0;\\n        bool b=true;\\n        for(auto x:a){\\n            if(edges[x][2]==-1){sum+=1;b=false;nn++;}\\n            else{sum+=edges[x][2];}\\n        }\\n        ap=b;\\n        return sum;\\n    }\\n\\n    int MS(int a,vector<vector<int>>& edges){ \\n    // find the most shared -1 edge in ans[a], \\n    //return its index in edges\\n        int r;//return value\\n        int m=0; // # of times for the most shared edge so far \\n        for(auto i:ans[a]){\\n            if(edges[i][2]==-1){\\n                int c=0;// counter for how many times it appear across ans\\n                for(auto x:ans){\\n                    for(auto y:x){\\n                        if(y==i){c++;}\\n                    }                    \\n                }\\n                if (c>m){r=i;m=c;}\\n            }\\n        }\\n        return r;\\n    }\\n\\n    void DFS(int i,vector<Node>& Nodes,int d,int target,vector<vector<int>>& edges,bool P){\\n        if(q.find(i)!=q.end()){ //already visited node     \\n            return;\\n        }\\n        if(stop){return;} // no solution\\n        // if((!P)&&perfect){return;} // perfect path alreay found no need to continue\\n        if ((!el.empty())&&P){ //positive mode\\n            if(P&&(edges[el.back()][2]==-1)){return;}\\n        }\\n        if(currSum>=target){return;}\\n        q.insert(i);\\n        // cout<<endl<<\"i: \"<<i<<endl;\\n        for (auto x:Nodes[i].map){\\n            if(P&&(edges[x.second][2]==-1)){}  //ignore -1 edges in positive mode\\n            else{\\n                el.push_back(x.second); \\n                int cost= (edges[x.second][2]==-1)?1:edges[x.second][2];\\n                currSum+=cost;        \\n                if (x.first==d){\\n                    if(currSum<=target){\\n                        int total= this->calmin(el,edges);\\n                        if(ap&&(total!=target)){stop=true;}\\n                        else if(ap&&(total==target)){this->on_found(edges);found=true;apS=true;} //none-negative path matching target \\n                        else if((nn>0)&&(total<=target)){\\n                            this->on_found(edges);found=true; //single-negative path matching tar\\n                            // if(nn==1){// we found the perfet solution, no need to continue search\\n                            //     perfect=true;\\n                            // }\\n                        }\\n                        else{}\\n                        ans.push_back(el);\\n                    }\\n                    el.pop_back();  \\n                    currSum-=cost;     \\n                }else{            \\n                    DFS(x.first,Nodes,d,target,edges,P);\\n                    if(el.empty()==false){el.pop_back();currSum-=cost;}\\n                }\\n            }\\n        }\\n        q.erase(i);\\n    }\\n    \\n    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int source, int destination, int target) {\\n        vector<Node> Nodes(n); \\n        int s=edges.size();   \\n        bool no_ans=true;     \\n        for(int i=0;i<s;i++){ //initialize nodes\\n            if(edges[i][2]<=target){ //avoid edges that cost more than target\\n                int a=edges[i][0];\\n                int b=edges[i][1];\\n                Nodes[a].map[b]=i;\\n                Nodes[b].map[a]=i;\\n            }\\n        }\\n        this->DFS(source,Nodes,destination,target,edges,true); //search all-postive path first\\n        vector<vector<int>> emp;\\n        //when impossible to meet target, reterun empty list\\n        if(stop){return emp;}\\n        if(apS&&found){return edges;}\\n\\n        ans.clear();el.clear();nn=0;currSum=0; q.clear();//reset globals for the next round of  DFS\\n        this->DFS(source,Nodes,destination,target,edges,false); //search path with negatibe edges\\n\\n        //remove imppsoible path taht containing 1e9 edges\\n        vector<vector<int>> ans0; //temp vector for the updating task\\n        for(int ii=0;ii<ans.size();ii++){ \\n            bool is_1e9 =false;\\n            for(auto j:ans[ii]){\\n                if(edges[j][2]==1e9){is_1e9 = true;}\\n            }\\n            if (!is_1e9){ans0.push_back(ans[ii]);}\\n        }\\n        ans.clear();ans=ans0;ans0.clear();\\n\\n        int m1=INT_MAX; //m1 for solution containging -1 edge, m2 for otherwise\\n        int m2=INT_MAX;\\n        int fa1=0; //shortest path with -1 index in ans \\n        for(int k=0;k<ans.size();k++){\\n            int sum=0;\\n            int n=0;// # of -1s\\n            for(auto j:ans[k]){\\n                cout<<\" \"<<edges[j][2];\\n                if(edges[j][2]==-1){n++;}\\n                sum+= edges[j][2];\\n            }\\n           \\n            sum+=2*n;//if we modify all -1 to 1(min postive int)                     \\n            m1=min(m1,sum);\\n            if(sum<=target){fa1_set.push_back(k);}\\n            if(sum==m1){fa1=k;}\\n            \\n            cout<<endl;\\n        }\\n        \\n        if(target<m1){return emp;}\\n\\n        //decide the final path to use from candiadts in ans1\\n        // we chose the one with least -1s so that\\n        // other path with more -1s will be have edges set to 2e9\\n        // and not threat the chosen path as the shortest\\n        int nb=INT_MAX;\\n        int mm=INT_MAX;\\n        for(auto w:fa1_set){\\n            int c=0;            \\n            for(auto v:ans[w]){\\n                if(edges[v][2]==-1){c++;}\\n            }\\n            if(c<nb){fa1=w;nb=c;mm=this->calmin(ans[w],edges);}\\n            if(c==nb){\\n                int n= this->calmin(ans[w],edges);\\n                if(n<mm){fa1=w;mm=n;}\\n            } //chose the one with smaller min\\n        }\\n\\n        //for final path conating -1 edges:\\n        // we only increase weight for the most shared -1 edge, \\n        //other negative edges would be set to +1\\n        int j= this->MS(fa1,edges);\\n        //update m1 and set other -1s to 1s\\n        m1=0;\\n        for(auto z:ans[fa1]){\\n            if (edges[z][2]==-1){\\n                edges[z][2]=1;\\n            }\\n            m1+=edges[z][2];\\n        }\\n        // set the chosen edge to the value that makes the path\\'s total cost equal to target\\n        edges[j][2]=target-m1+1;\\n\\n        // for the rest negative edges we set them to a big enough number\\n        for(int k=0;k<s;k++){\\n            if(edges[k][2]==-1){edges[k][2]=2e9;}\\n        }\\n\\n        return edges;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Graph",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\nstruct Node{\\n    unordered_map<int, int> map; //map for neigbor-edgeindex pairs\\n};\\npublic:\\n    int currSum=0;//edge sum for the ongoing path\\n    int nn=0;// # of -1s in the current complete path\\n    vector<vector<int>> ans;// all paths {1st edge\\'s index,2nd edge\\'s index,...}\\n    vector<int> fa1_set; // all possible path(min cost<= target) with -1 edges (index in ans)\\n    vector<int> el;//edge list for the ongoing path\\n    set<int> q;// queue for visited nodes\\n    bool ap=false; // all postive edges \\n    bool apS=false; // found all positive solution\\n    bool stop=false;// stop DFS once we found a all-positve path shorter than target \\n    bool perfect=false; //stop following DFS from using negtive edges once we found a solution with only one -1 edge(perfect path)\\n    bool found=false;// if we find a complete path with negative edges, we can set all other -1 egdes( not on that path) to 2e9 so that we only focus on possible solutions related to these negative edges\\n    // we can write a on_found for it.\\n\\n    void on_found(vector<vector<int>>& edges){ //set all -1 to 2e7 except the -1 edge inside the el\\n        // if(found){return;} //run only one time\\n        int s=edges.size();\\n        if (nn==0){\\n            for(int k=0;k<s;k++){\\n                if(edges[k][2]==-1){edges[k][2]=1e9;}\\n            }\\n        }\\n        else{            \\n            for(int k=0;k<s;k++){\\n                if(edges[k][2]==-1){\\n                    auto it = find(el.begin(),el.end(),k);\\n                    if(it==el.end()){edges[k][2]=1e9;}\\n                }\\n            }\\n        }\\n    }\\n    int calmin(vector<int> a,vector<vector<int>>& edges){ //calculate min cost of a path\\n        int sum=0;\\n        nn=0;\\n        bool b=true;\\n        for(auto x:a){\\n            if(edges[x][2]==-1){sum+=1;b=false;nn++;}\\n            else{sum+=edges[x][2];}\\n        }\\n        ap=b;\\n        return sum;\\n    }\\n\\n    int MS(int a,vector<vector<int>>& edges){ \\n    // find the most shared -1 edge in ans[a], \\n    //return its index in edges\\n        int r;//return value\\n        int m=0; // # of times for the most shared edge so far \\n        for(auto i:ans[a]){\\n            if(edges[i][2]==-1){\\n                int c=0;// counter for how many times it appear across ans\\n                for(auto x:ans){\\n                    for(auto y:x){\\n                        if(y==i){c++;}\\n                    }                    \\n                }\\n                if (c>m){r=i;m=c;}\\n            }\\n        }\\n        return r;\\n    }\\n\\n    void DFS(int i,vector<Node>& Nodes,int d,int target,vector<vector<int>>& edges,bool P){\\n        if(q.find(i)!=q.end()){ //already visited node     \\n            return;\\n        }\\n        if(stop){return;} // no solution\\n        // if((!P)&&perfect){return;} // perfect path alreay found no need to continue\\n        if ((!el.empty())&&P){ //positive mode\\n            if(P&&(edges[el.back()][2]==-1)){return;}\\n        }\\n        if(currSum>=target){return;}\\n        q.insert(i);\\n        // cout<<endl<<\"i: \"<<i<<endl;\\n        for (auto x:Nodes[i].map){\\n            if(P&&(edges[x.second][2]==-1)){}  //ignore -1 edges in positive mode\\n            else{\\n                el.push_back(x.second); \\n                int cost= (edges[x.second][2]==-1)?1:edges[x.second][2];\\n                currSum+=cost;        \\n                if (x.first==d){\\n                    if(currSum<=target){\\n                        int total= this->calmin(el,edges);\\n                        if(ap&&(total!=target)){stop=true;}\\n                        else if(ap&&(total==target)){this->on_found(edges);found=true;apS=true;} //none-negative path matching target \\n                        else if((nn>0)&&(total<=target)){\\n                            this->on_found(edges);found=true; //single-negative path matching tar\\n                            // if(nn==1){// we found the perfet solution, no need to continue search\\n                            //     perfect=true;\\n                            // }\\n                        }\\n                        else{}\\n                        ans.push_back(el);\\n                    }\\n                    el.pop_back();  \\n                    currSum-=cost;     \\n                }else{            \\n                    DFS(x.first,Nodes,d,target,edges,P);\\n                    if(el.empty()==false){el.pop_back();currSum-=cost;}\\n                }\\n            }\\n        }\\n        q.erase(i);\\n    }\\n    \\n    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int source, int destination, int target) {\\n        vector<Node> Nodes(n); \\n        int s=edges.size();   \\n        bool no_ans=true;     \\n        for(int i=0;i<s;i++){ //initialize nodes\\n            if(edges[i][2]<=target){ //avoid edges that cost more than target\\n                int a=edges[i][0];\\n                int b=edges[i][1];\\n                Nodes[a].map[b]=i;\\n                Nodes[b].map[a]=i;\\n            }\\n        }\\n        this->DFS(source,Nodes,destination,target,edges,true); //search all-postive path first\\n        vector<vector<int>> emp;\\n        //when impossible to meet target, reterun empty list\\n        if(stop){return emp;}\\n        if(apS&&found){return edges;}\\n\\n        ans.clear();el.clear();nn=0;currSum=0; q.clear();//reset globals for the next round of  DFS\\n        this->DFS(source,Nodes,destination,target,edges,false); //search path with negatibe edges\\n\\n        //remove imppsoible path taht containing 1e9 edges\\n        vector<vector<int>> ans0; //temp vector for the updating task\\n        for(int ii=0;ii<ans.size();ii++){ \\n            bool is_1e9 =false;\\n            for(auto j:ans[ii]){\\n                if(edges[j][2]==1e9){is_1e9 = true;}\\n            }\\n            if (!is_1e9){ans0.push_back(ans[ii]);}\\n        }\\n        ans.clear();ans=ans0;ans0.clear();\\n\\n        int m1=INT_MAX; //m1 for solution containging -1 edge, m2 for otherwise\\n        int m2=INT_MAX;\\n        int fa1=0; //shortest path with -1 index in ans \\n        for(int k=0;k<ans.size();k++){\\n            int sum=0;\\n            int n=0;// # of -1s\\n            for(auto j:ans[k]){\\n                cout<<\" \"<<edges[j][2];\\n                if(edges[j][2]==-1){n++;}\\n                sum+= edges[j][2];\\n            }\\n           \\n            sum+=2*n;//if we modify all -1 to 1(min postive int)                     \\n            m1=min(m1,sum);\\n            if(sum<=target){fa1_set.push_back(k);}\\n            if(sum==m1){fa1=k;}\\n            \\n            cout<<endl;\\n        }\\n        \\n        if(target<m1){return emp;}\\n\\n        //decide the final path to use from candiadts in ans1\\n        // we chose the one with least -1s so that\\n        // other path with more -1s will be have edges set to 2e9\\n        // and not threat the chosen path as the shortest\\n        int nb=INT_MAX;\\n        int mm=INT_MAX;\\n        for(auto w:fa1_set){\\n            int c=0;            \\n            for(auto v:ans[w]){\\n                if(edges[v][2]==-1){c++;}\\n            }\\n            if(c<nb){fa1=w;nb=c;mm=this->calmin(ans[w],edges);}\\n            if(c==nb){\\n                int n= this->calmin(ans[w],edges);\\n                if(n<mm){fa1=w;mm=n;}\\n            } //chose the one with smaller min\\n        }\\n\\n        //for final path conating -1 edges:\\n        // we only increase weight for the most shared -1 edge, \\n        //other negative edges would be set to +1\\n        int j= this->MS(fa1,edges);\\n        //update m1 and set other -1s to 1s\\n        m1=0;\\n        for(auto z:ans[fa1]){\\n            if (edges[z][2]==-1){\\n                edges[z][2]=1;\\n            }\\n            m1+=edges[z][2];\\n        }\\n        // set the chosen edge to the value that makes the path\\'s total cost equal to target\\n        edges[j][2]=target-m1+1;\\n\\n        // for the rest negative edges we set them to a big enough number\\n        for(int k=0;k<s;k++){\\n            if(edges[k][2]==-1){edges[k][2]=2e9;}\\n        }\\n\\n        return edges;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4038832,
                "title": "java-clean-dijkstra-s",
                "content": "# Approach\\nCalculate shortest distance from **destination** to every node on the way to **source** using Dijkstra\\'s algorithm. If edges is -1, use 1 (minimum possible replacement) instead. Ignore nodes past source. These nodes will not lead to destination so -1 edges (if any) can be replaced with any value.\\n\\nIf minimimum distance from source to destination is more than target,\\nwe already know it is impossible to build solution.\\n\\nStart Dijkstra\\'s again from **source** node and maintain distance from source. For every next edge betwen current node **A** and next **B**:\\n- check if distance from **A** to source + **edge weight** + distance from **B** to destination more than target. In this case do not proceed with this node. Otherwise this distance needs to be compensated somewhere here o later.\\n- if edge is -1, than set it to what ever difference is missing, which we defined on previous step and do not proceed with this node future.\\n- otherwise add connected node to Priority Queue and proceed with Dijkstra.\\n- if we reach the **destination** that means we were not able to fix the path, so there is no solution.\\n\\nSet all remaining -1 edges 1 at the end.\\n\\n# Complexity\\n- Time complexity:\\nO(NLogN)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    List<int[]>[] graph;\\n    public int[][] modifiedGraphEdges(int n, int[][] edges, int source, int destination, int target) {\\n\\n        graph = new ArrayList[n];\\n        for (int i = 0; i < n; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n\\n        for (int i = 0; i < edges.length; i++) {\\n            int[] e = edges[i];\\n            graph[e[0]].add(new int[]{e[1], i});\\n            graph[e[1]].add(new int[]{e[0], i});\\n        }\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((v1, v2)->v1[1]-v2[1]);\\n        pq.add(new int[]{destination, 0});\\n        Integer[] distances = new Integer[n];\\n        \\n        while ( ! pq.isEmpty()) {\\n            int[] c = pq.poll();\\n            if (distances[c[0]] != null) {\\n                continue;\\n            }\\n            distances[c[0]] = c[1];\\n\\n            if (c[0] == source) {\\n                continue;\\n            }\\n            for (int[] e : graph[c[0]]) {\\n                if (distances[e[0]] != null) {\\n                    continue;\\n                }\\n                pq.add(new int[]{e[0], c[1]+Math.abs(edges[e[1]][2])});\\n            }\\n        }\\n\\n        if (distances[source] > target) {            \\n            return new int[][]{};\\n        }\\n\\n        pq = new PriorityQueue<>((v1, v2)->v1[1]-v2[1]);\\n        if (distances[source] != target) {\\n            pq.add(new int[]{source, 0});\\n        }\\n        \\n        boolean[] visited = new boolean[n];\\n        while ( ! pq.isEmpty()) {\\n            int[] c = pq.poll();\\n            if (visited[c[0]]) {\\n                continue;\\n            }\\n            visited[c[0]] = true;\\n\\n            if (c[0] == destination) {\\n                return new int[][]{};\\n            }\\n            for (int[] e : graph[c[0]]) {\\n                if (visited[e[0]] || distances[e[0]] == null) {\\n                    continue;\\n                }\\n                \\n                int dif = target - c[1] - distances[e[0]];\\n                if (Math.abs(edges[e[1]][2]) >= dif) {\\n                    continue;\\n                }\\n                if (edges[e[1]][2] == -1) {\\n                    edges[e[1]][2] = dif;\\n                    continue;\\n                }\\n                pq.add(new int[] {e[0], c[1]+edges[e[1]][2]});\\n            }\\n        }\\n\\n        for (int[] e : edges) {\\n            if (e[2] == -1) {\\n                e[2] = 1;\\n            }\\n        }\\n        return edges;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    List<int[]>[] graph;\\n    public int[][] modifiedGraphEdges(int n, int[][] edges, int source, int destination, int target) {\\n\\n        graph = new ArrayList[n];\\n        for (int i = 0; i < n; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n\\n        for (int i = 0; i < edges.length; i++) {\\n            int[] e = edges[i];\\n            graph[e[0]].add(new int[]{e[1], i});\\n            graph[e[1]].add(new int[]{e[0], i});\\n        }\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((v1, v2)->v1[1]-v2[1]);\\n        pq.add(new int[]{destination, 0});\\n        Integer[] distances = new Integer[n];\\n        \\n        while ( ! pq.isEmpty()) {\\n            int[] c = pq.poll();\\n            if (distances[c[0]] != null) {\\n                continue;\\n            }\\n            distances[c[0]] = c[1];\\n\\n            if (c[0] == source) {\\n                continue;\\n            }\\n            for (int[] e : graph[c[0]]) {\\n                if (distances[e[0]] != null) {\\n                    continue;\\n                }\\n                pq.add(new int[]{e[0], c[1]+Math.abs(edges[e[1]][2])});\\n            }\\n        }\\n\\n        if (distances[source] > target) {            \\n            return new int[][]{};\\n        }\\n\\n        pq = new PriorityQueue<>((v1, v2)->v1[1]-v2[1]);\\n        if (distances[source] != target) {\\n            pq.add(new int[]{source, 0});\\n        }\\n        \\n        boolean[] visited = new boolean[n];\\n        while ( ! pq.isEmpty()) {\\n            int[] c = pq.poll();\\n            if (visited[c[0]]) {\\n                continue;\\n            }\\n            visited[c[0]] = true;\\n\\n            if (c[0] == destination) {\\n                return new int[][]{};\\n            }\\n            for (int[] e : graph[c[0]]) {\\n                if (visited[e[0]] || distances[e[0]] == null) {\\n                    continue;\\n                }\\n                \\n                int dif = target - c[1] - distances[e[0]];\\n                if (Math.abs(edges[e[1]][2]) >= dif) {\\n                    continue;\\n                }\\n                if (edges[e[1]][2] == -1) {\\n                    edges[e[1]][2] = dif;\\n                    continue;\\n                }\\n                pq.add(new int[] {e[0], c[1]+edges[e[1]][2]});\\n            }\\n        }\\n\\n        for (int[] e : edges) {\\n            if (e[2] == -1) {\\n                e[2] = 1;\\n            }\\n        }\\n        return edges;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036782,
                "title": "simple-djikstra-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>> adj[200];\\n    int n;\\n    long long djikstra(int source, int destination){\\n        vector<int> dist(n,1e9+10);\\n        dist[source] = 0;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        pq.push({0,source});\\n        while(!pq.empty()){\\n            int node = pq.top().second;\\n            pq.pop();\\n            for(auto it : adj[node]){\\n                if(dist[it.first]>dist[node] + it.second){\\n                    dist[it.first] = dist[node] + it.second;\\n                    pq.push({dist[it.first],it.first});\\n            }\\n            }\\n        }\\n        return dist[destination];\\n    }\\n    vector<vector<int>> modifiedGraphEdges(int N, vector<vector<int>>& edges, int source, int destination, int target) {\\n        n = N;\\n        for(auto& it : edges){\\n            int u = it[0],v = it[1],wt = it[2];\\n            if(wt==-1) continue;\\n            adj[u].push_back({v,wt});\\n            adj[v].push_back({u,wt});\\n        }\\n        int dist = djikstra(source,destination);\\n        if(dist<target) return {};\\n        if(dist==target){\\n            for(auto& it : edges){\\n                if(it[2]==-1) it[2] = 2e9;\\n            }\\n            return edges;\\n        }\\n        for(int i = 0;i<edges.size();i++){\\n            int u = edges[i][0],v = edges[i][1],wt = edges[i][2];\\n            if(wt==-1){\\n                edges[i][2] = 1;\\n                adj[u].push_back({v,1});\\n                adj[v].push_back({u,1});\\n                int d = djikstra(source,destination);\\n                if(d<=target){\\n                    edges[i][2] += target-d;\\n                    for(int j = i+1;j<edges.size();j++){\\n                        if(edges[j][2]==-1) edges[j][2] = 2e9;\\n                    }\\n                    return edges;\\n                }\\n            }\\n        }\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>> adj[200];\\n    int n;\\n    long long djikstra(int source, int destination){\\n        vector<int> dist(n,1e9+10);\\n        dist[source] = 0;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        pq.push({0,source});\\n        while(!pq.empty()){\\n            int node = pq.top().second;\\n            pq.pop();\\n            for(auto it : adj[node]){\\n                if(dist[it.first]>dist[node] + it.second){\\n                    dist[it.first] = dist[node] + it.second;\\n                    pq.push({dist[it.first],it.first});\\n            }\\n            }\\n        }\\n        return dist[destination];\\n    }\\n    vector<vector<int>> modifiedGraphEdges(int N, vector<vector<int>>& edges, int source, int destination, int target) {\\n        n = N;\\n        for(auto& it : edges){\\n            int u = it[0],v = it[1],wt = it[2];\\n            if(wt==-1) continue;\\n            adj[u].push_back({v,wt});\\n            adj[v].push_back({u,wt});\\n        }\\n        int dist = djikstra(source,destination);\\n        if(dist<target) return {};\\n        if(dist==target){\\n            for(auto& it : edges){\\n                if(it[2]==-1) it[2] = 2e9;\\n            }\\n            return edges;\\n        }\\n        for(int i = 0;i<edges.size();i++){\\n            int u = edges[i][0],v = edges[i][1],wt = edges[i][2];\\n            if(wt==-1){\\n                edges[i][2] = 1;\\n                adj[u].push_back({v,1});\\n                adj[v].push_back({u,1});\\n                int d = djikstra(source,destination);\\n                if(d<=target){\\n                    edges[i][2] += target-d;\\n                    for(int j = i+1;j<edges.size();j++){\\n                        if(edges[j][2]==-1) edges[j][2] = 2e9;\\n                    }\\n                    return edges;\\n                }\\n            }\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3972517,
                "title": "lost-in-the-graph-finding-a-path-that-s-just-right",
                "content": "# Intuition\\nAh, the **good old days of college**! This problem reminds me of trying to find the perfect route to travel between two cities with a fixed budget in mind. The tricky part? Some routes have variable costs, and we\\'ve got to make sure we don\\'t end up spending more than our budget. Let\\u2019s call these routes with variable costs the \\u201Cmodifiable\\u201D routes. On the outset, I\\'m thinking of using Dijkstra\\'s shortest path algorithm, because, well, isn\\'t finding the shortest path what it\\'s all about? But the catch here is that not all paths are created equal - we have these \"modifiable\" edges that can potentially help us achieve the target weight!\\n\\n# Approach\\nFirst, we need a way to quickly find which edges are connected to a particular node. That\\u2019s where the adjacency list al comes in. **Every node will have a list of edges connected to it.**\\nFirst Run of BFS (Dijkstra\\'s in Disguise):\\n\\n**We run our breadth-first search (BFS) function**, which is like Dijkstra\\'s algorithm in disguise. The goal is to find the shortest path from source to destination while ignoring the modifiable edges (the edges with a weight of -1). If the shortest distance is already less than the target, then, unfortunately, it\\u2019s impossible to get to the target by modifying any edge. We return an empty list.\\nSecond Run of BFS:\\n\\nHold on! We run BFS again,** but this time we assume the minimum weight for modifiable edges is 1. Why 1? Because that\\u2019s the minimum value any edge can have.** If the shortest distance, even after considering the modifiable edges, is more than the target, it\\u2019s still impossible. So, again, we return an empty list.\\nHowever, if it\\'s less than the target, then there\\'s hope! We can tweak the weight of a modifiable edge that is part of the shortest path to make the total weight equal to the target.\\nWe use a loop to keep adjusting one of the modifiable edges in the shortest path till we either hit our target weight or it becomes impossible to do so.\\nTying Loose Ends:\\n\\nOnce we get our shortest path that matches the target, or if it\\'s clear we can\\'t get there, we set all other modifiable edges (the ones we didn\\'t tweak) to have a weight of 1. **After all, they still need some weight, right?**\\n\\n# Complexity\\n- Time complexity:\\n**The BFS function\\'s time complexity is $$O(n + e \\\\log e)$$**, where n is the number of nodes and e is the number of edges. We might potentially run this BFS function twice for each modifiable edge in the worst case, so the overall time complexity is $$O(k \\\\times (n + e \\\\log e))$$, where k is the number of modifiable edges. However, in practice, it\\'s going to be faster since we rarely run BFS for each modifiable edge.\\n\\n- Space complexity:\\nWe\\'re using an adjacency list, and we also maintain a distance array of size n and a modifiable edge ID array of the same size. Therefore, **the space complexity is $$O(n + e)$$.**\\n\\n# Code\\n```\\nimport heapq\\nfrom collections import defaultdict\\n\\nclass Solution(object):\\n    def modifiedGraphEdges(self, n, edges, source, destination, target):\\n        def bfs(al, edges, source, dest, target, modify):\\n            q = [(0, source)]\\n            dist = [float(\\'inf\\')] * n\\n            mod_id = [float(\\'inf\\')] * n\\n            dist[source] = 0\\n            while q:\\n                d, i = heapq.heappop(q)\\n                if d > dist[i]:\\n                    continue\\n                for j, edge_id in al[i]:\\n                    w = edges[edge_id][2]\\n                    if modify or w != -1:\\n                        if dist[j] > d + max(1, w):\\n                            mod_id[j] = edge_id if w == -1 else mod_id[i]\\n                            dist[j] = d + max(1, w)\\n                            heapq.heappush(q, (d + max(1, w), j))\\n            return dist[dest], mod_id[dest]\\n\\n        al = defaultdict(list)\\n        for i, (x, y, _) in enumerate(edges):\\n            al[x].append((y, i))\\n            al[y].append((x, i))\\n\\n        dist, _ = bfs(al, edges, source, destination, target, False)\\n        if dist < target:\\n            return []\\n\\n        while True:\\n            dist, mod_id = bfs(al, edges, source, destination, target, True)\\n            if dist > target:\\n                return []\\n            if dist == target:\\n                break\\n            edges[mod_id][2] = 1 + target - dist\\n\\n        for e in edges:\\n            if e[2] == -1:\\n                e[2] = 1\\n\\n        return edges\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport heapq\\nfrom collections import defaultdict\\n\\nclass Solution(object):\\n    def modifiedGraphEdges(self, n, edges, source, destination, target):\\n        def bfs(al, edges, source, dest, target, modify):\\n            q = [(0, source)]\\n            dist = [float(\\'inf\\')] * n\\n            mod_id = [float(\\'inf\\')] * n\\n            dist[source] = 0\\n            while q:\\n                d, i = heapq.heappop(q)\\n                if d > dist[i]:\\n                    continue\\n                for j, edge_id in al[i]:\\n                    w = edges[edge_id][2]\\n                    if modify or w != -1:\\n                        if dist[j] > d + max(1, w):\\n                            mod_id[j] = edge_id if w == -1 else mod_id[i]\\n                            dist[j] = d + max(1, w)\\n                            heapq.heappush(q, (d + max(1, w), j))\\n            return dist[dest], mod_id[dest]\\n\\n        al = defaultdict(list)\\n        for i, (x, y, _) in enumerate(edges):\\n            al[x].append((y, i))\\n            al[y].append((x, i))\\n\\n        dist, _ = bfs(al, edges, source, destination, target, False)\\n        if dist < target:\\n            return []\\n\\n        while True:\\n            dist, mod_id = bfs(al, edges, source, destination, target, True)\\n            if dist > target:\\n                return []\\n            if dist == target:\\n                break\\n            edges[mod_id][2] = 1 + target - dist\\n\\n        for e in edges:\\n            if e[2] == -1:\\n                e[2] = 1\\n\\n        return edges\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951771,
                "title": "dijkstra-brute-force-adding-each-negative-edge",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBuild the graph adjaceny list first with all positive edges, and check the shortest path without any modification, if it is less than the target, then it is not possible. if it is equal to the target, just modify the negative weight to a sufficient large number. if it is large than the target:\\nadding each negative weight weight one by one into the graph with initial weight 1, until shortest path found is less than or equal to the target, modify the last added weight to the different of target and shortest path and modify the remaining neg edge to a sufficient large number \\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] modifiedGraphEdges(int n, int[][] edges, int source, int destination, int target) {\\n\\n        List<List<int[]>> adj = new ArrayList<>();\\n        List<int[]> negEdges = new ArrayList<>();\\n        int[][] res = new int[edges.length][3];\\n        int ri = 0;\\n\\n        for (int i=0; i<n; i++)\\n            adj.add(new ArrayList<>());\\n\\n        for(int[] e:edges){\\n            if (e[2]==-1){\\n                negEdges.add(e);\\n                continue;\\n            }\\n            adj.get(e[0]).add(new int[]{e[1], e[2]});\\n            adj.get(e[1]).add(new int[]{e[0], e[2]});\\n            res[ri++] = e;\\n        }\\n\\n        int minWoMod = getMin(n, adj, source, destination);\\n        if (minWoMod<target) return new int[][]{};\\n        else if (minWoMod==target){\\n            for (int[] e:edges){\\n                if (e[2]==-1) e[2] = target;\\n            }\\n            return edges;\\n        }\\n\\n        for (int i=0; i<negEdges.size(); i++){\\n            int[] e = negEdges.get(i);\\n            adj.get(e[0]).add(new int[]{e[1], 1});\\n            adj.get(e[1]).add(new int[]{e[0], 1});\\n            int min = getMin(n, adj, source, destination);\\n            if (min>target){\\n                res[ri++] = new int[]{e[0], e[1], 1};\\n            }else{\\n                res[ri++] = new int[]{e[0], e[1], 1+target-min};\\n                for (int j=i+1; j<negEdges.size(); j++)\\n                    res[ri++] = new int[]{negEdges.get(j)[0], negEdges.get(j)[1], target};\\n                return res;\\n            }\\n        }\\n\\n        return new int[][]{};\\n    }\\n\\n    private int getMin(int n, List<List<int[]>> adj, int source, int destination){\\n\\n        boolean[] seen = new boolean[n];\\n\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(\\n            (a, b)->a[1]-b[1]\\n        );\\n\\n        pq.add(new int[]{source, 0});\\n\\n        while(!pq.isEmpty()){\\n            int[] curr = pq.remove();\\n            if (seen[curr[0]]) continue;\\n            seen[curr[0]] = true;\\n\\n            if (curr[0]==destination)\\n                return curr[1];\\n\\n            for (int[] next:adj.get(curr[0])){\\n                if (seen[next[0]]) continue;\\n                pq.add(new int[]{next[0], next[1]+curr[1]});\\n            } \\n        }\\n\\n        return Integer.MAX_VALUE;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] modifiedGraphEdges(int n, int[][] edges, int source, int destination, int target) {\\n\\n        List<List<int[]>> adj = new ArrayList<>();\\n        List<int[]> negEdges = new ArrayList<>();\\n        int[][] res = new int[edges.length][3];\\n        int ri = 0;\\n\\n        for (int i=0; i<n; i++)\\n            adj.add(new ArrayList<>());\\n\\n        for(int[] e:edges){\\n            if (e[2]==-1){\\n                negEdges.add(e);\\n                continue;\\n            }\\n            adj.get(e[0]).add(new int[]{e[1], e[2]});\\n            adj.get(e[1]).add(new int[]{e[0], e[2]});\\n            res[ri++] = e;\\n        }\\n\\n        int minWoMod = getMin(n, adj, source, destination);\\n        if (minWoMod<target) return new int[][]{};\\n        else if (minWoMod==target){\\n            for (int[] e:edges){\\n                if (e[2]==-1) e[2] = target;\\n            }\\n            return edges;\\n        }\\n\\n        for (int i=0; i<negEdges.size(); i++){\\n            int[] e = negEdges.get(i);\\n            adj.get(e[0]).add(new int[]{e[1], 1});\\n            adj.get(e[1]).add(new int[]{e[0], 1});\\n            int min = getMin(n, adj, source, destination);\\n            if (min>target){\\n                res[ri++] = new int[]{e[0], e[1], 1};\\n            }else{\\n                res[ri++] = new int[]{e[0], e[1], 1+target-min};\\n                for (int j=i+1; j<negEdges.size(); j++)\\n                    res[ri++] = new int[]{negEdges.get(j)[0], negEdges.get(j)[1], target};\\n                return res;\\n            }\\n        }\\n\\n        return new int[][]{};\\n    }\\n\\n    private int getMin(int n, List<List<int[]>> adj, int source, int destination){\\n\\n        boolean[] seen = new boolean[n];\\n\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(\\n            (a, b)->a[1]-b[1]\\n        );\\n\\n        pq.add(new int[]{source, 0});\\n\\n        while(!pq.isEmpty()){\\n            int[] curr = pq.remove();\\n            if (seen[curr[0]]) continue;\\n            seen[curr[0]] = true;\\n\\n            if (curr[0]==destination)\\n                return curr[1];\\n\\n            for (int[] next:adj.get(curr[0])){\\n                if (seen[next[0]]) continue;\\n                pq.add(new int[]{next[0], next[1]+curr[1]});\\n            } \\n        }\\n\\n        return Integer.MAX_VALUE;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3896778,
                "title": "dijkstra",
                "content": "```\\nclass Solution:\\n    def modifiedGraphEdges(self, n: int, edges: List[List[int]], source: int, destination: int, target: int) -> List[List[int]]:\\n        adj = [[] for _ in range(n)]\\n        inf = int(2 * 1e9)\\n        weights = defaultdict(lambda: defaultdict(int))\\n        for u, v, w in edges:\\n            adj[u].append((v, w))\\n            adj[v].append((u, w))\\n            if w == -1:\\n                weights[u][v] = weights[v][u] = 1\\n        def dijkstra() -> (int, List[int]):\\n            parents = [-1 for _ in range(n)]\\n            min_heap = [(0, source)]\\n            min_costs = [inf for _ in range(n)]\\n            confirmed = [False for _ in range(n)]\\n            while len(min_heap):\\n                cost, cur = heappop(min_heap)\\n                if confirmed[cur]: continue\\n                min_costs[cur] = cost\\n                confirmed[cur] = True\\n                for nei, weight in adj[cur]:\\n                    if weight == -1:\\n                        weight = weights[cur][nei]\\n                    nei_cost = cost + weight\\n                    if nei_cost < min_costs[nei]:\\n                        parents[nei] = cur\\n                        min_costs[nei] = nei_cost\\n                        heappush(min_heap, (nei_cost, nei)) \\n            paths = []\\n            now = destination\\n            while now != source:\\n                nxt = parents[now]\\n                if weights[nxt][now] >= 1 and weights[nxt][now] < inf:\\n                    paths.append((nxt, now))\\n                now = nxt\\n            return (min_costs[destination], paths)\\n        def form_answer() -> List[List[int]]:\\n            ans = []\\n            for u, v, w in edges:\\n                if w == -1:\\n                    ans.append((u, v, weights[u][v]))\\n                else:\\n                    ans.append((u, v, w))\\n            return ans\\n        min_cost_now, min_cost_path = dijkstra()\\n        while min_cost_now != target:\\n            if min_cost_now > target or len(min_cost_path) == 0: return []\\n            u, v = min_cost_path[0]\\n            diff = target - min_cost_now\\n            weights[u][v] = weights[v][u] = weights[v][u] + diff\\n            min_cost_path_s = set(min_cost_path)\\n            for u, v, w in edges:\\n                not_exist = (u, v) not in min_cost_path_s and (v, u) not in min_cost_path_s\\n                if w == -1 and not_exist:\\n                    weights[u][v] = weights[v][u] = inf\\n            min_cost_now, min_cost_path = dijkstra()\\n        return form_answer()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def modifiedGraphEdges(self, n: int, edges: List[List[int]], source: int, destination: int, target: int) -> List[List[int]]:\\n        adj = [[] for _ in range(n)]\\n        inf = int(2 * 1e9)\\n        weights = defaultdict(lambda: defaultdict(int))\\n        for u, v, w in edges:\\n            adj[u].append((v, w))\\n            adj[v].append((u, w))\\n            if w == -1:\\n                weights[u][v] = weights[v][u] = 1\\n        def dijkstra() -> (int, List[int]):\\n            parents = [-1 for _ in range(n)]\\n            min_heap = [(0, source)]\\n            min_costs = [inf for _ in range(n)]\\n            confirmed = [False for _ in range(n)]\\n            while len(min_heap):\\n                cost, cur = heappop(min_heap)\\n                if confirmed[cur]: continue\\n                min_costs[cur] = cost\\n                confirmed[cur] = True\\n                for nei, weight in adj[cur]:\\n                    if weight == -1:\\n                        weight = weights[cur][nei]\\n                    nei_cost = cost + weight\\n                    if nei_cost < min_costs[nei]:\\n                        parents[nei] = cur\\n                        min_costs[nei] = nei_cost\\n                        heappush(min_heap, (nei_cost, nei)) \\n            paths = []\\n            now = destination\\n            while now != source:\\n                nxt = parents[now]\\n                if weights[nxt][now] >= 1 and weights[nxt][now] < inf:\\n                    paths.append((nxt, now))\\n                now = nxt\\n            return (min_costs[destination], paths)\\n        def form_answer() -> List[List[int]]:\\n            ans = []\\n            for u, v, w in edges:\\n                if w == -1:\\n                    ans.append((u, v, weights[u][v]))\\n                else:\\n                    ans.append((u, v, w))\\n            return ans\\n        min_cost_now, min_cost_path = dijkstra()\\n        while min_cost_now != target:\\n            if min_cost_now > target or len(min_cost_path) == 0: return []\\n            u, v = min_cost_path[0]\\n            diff = target - min_cost_now\\n            weights[u][v] = weights[v][u] = weights[v][u] + diff\\n            min_cost_path_s = set(min_cost_path)\\n            for u, v, w in edges:\\n                not_exist = (u, v) not in min_cost_path_s and (v, u) not in min_cost_path_s\\n                if w == -1 and not_exist:\\n                    weights[u][v] = weights[v][u] = inf\\n            min_cost_now, min_cost_path = dijkstra()\\n        return form_answer()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894697,
                "title": "dijkstra-algorithm-greedy-approach-beats-98-28",
                "content": "# Intuition\\nWhen dealing with a graph that are disconnected, and we aim to find the shortest distance between a starting point and a destination, we encounter two scenarios.\\n\\nIn the first scenario, if the source and the destination are connected, in the same subgraph, then the minimum distance between the source and destination is simply \\'d\\'.\\n\\nHowever, in the second scenario, where the starting point and the destination are in a different subgraph, we have the opportunity to connect it by adding edges between the vertices. By doing so, we continually update the minimum distance calculation and repeat this process until the source and the destination is in the same subgraph.\\n\\n# Approach\\nTo know which scenario we are in, we first apply Dijkstra\\'s algorithm to obtain the current minimum distance. If the distance is not MAX_INT, it means that there is a path.\\n\\n**Case 1:** In the case where the distance is less than the target, we are done. We cannot build a minimum path that is greater than an existing one.\\n\\n**Case 2:** In the case where it is greater than the target, then the path is invalid and we can work as if there is no path.\\n\\n**Case 3:** Hence, the most important case is when the distance returned is MAX_INT, which falls into the second scenario. We now want to slowly build an edge at a time until the source and destination becomes connected. The idea is to find the bottleneck edge, or the edge that makes the minimum distance less than the target. To ensure that we do not miss this, every non-bottleneck edge added will have a weight of 1.\\n\\n*Note: The reason we want the minimum distance to be less than the target is that if it is equal, then we are done. If it is more than the target then since we have all the non-bottleneck edge at minimum, we cannot have a minimum distance lower than that with the current paths, making it invalid.*\\n\\nNow that we\\'ve identified the bottleneck edge and are aware that the other existing paths are not viable otherwise a different bottleneck edge would have been discovered earlier, we can now adjust the weight of the bottleneck edge such that the minimum path is equal to the target. Let there be a path from Source, S, to A with minimum distance D1 and from B to F with distance D2, where F is the final destination and A is connected to B by the bottleneck edge with weight 1. By the given condition, we know that \\n**D1 + D2 + 1 < Target** so we can now set the weight of the edge connect A to B to be **Target - D1 - D2**. The final clean up is to make all the other edges maximum weight since they are not needed in the graph.\\n\\n# Code\\n```\\n/* \\nThe code below is the code I submitted without any optimisations or\\nany cleaning done so if there is a better way of implementing this,\\nespecially since this uses a lot of memory in exchange for time, \\nplease share below so I can improve as well!\\n\\nSince I\\'m new to C++, if there\\'s anything that doesn\\'t align\\nwith the typical standards or if there\\'s a fascinating aspect of the\\nlanguage you\\'d like to share, feel free to share your thoughts\\nin the comments section.\\n\\nThanks for taking the time to go through my post and I hope there are \\nno major problem with my algorithm or code.\\n*/\\nclass Solution {\\npublic:\\n    struct dest_info\\n    {\\n        int index;\\n        int destination;\\n        int weight;\\n    };\\n\\n    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int source, int destination, int target) {\\n        unordered_map<int, vector<dest_info*>> path;\\n        vector<int> maybe_path;\\n        vector<pair<dest_info*, dest_info*>> modify_edge;\\n        // Stores all possible path into hash map for faster finds.\\n        for (int i = 0; i < edges.size(); i++) {\\n            vector<int> edge = edges[i];\\n            int key1 = edge[0];\\n            int key2 = edge[1];\\n            int weight = edge[2];\\n            // Consider those with path -1 as having no path.\\n            if (weight == -1) {\\n                weight = INT_MAX;\\n            }\\n            // Stores necessary information.\\n            dest_info* ptr1 = new dest_info;\\n            dest_info* ptr2 = new dest_info;\\n            ptr1->index = i;\\n            ptr1->destination = key2;\\n            ptr1->weight = weight;\\n            ptr2->index = i;\\n            ptr2->destination = key1;\\n            ptr2->weight = weight;\\n            path[key1].push_back(ptr1);\\n            path[key2].push_back(ptr2);\\n            /* \\n            Stores the index the -1 path corresponds to and their\\n            corresponding path info.\\n            */\\n            if (weight == INT_MAX) {\\n                maybe_path.push_back(i);\\n                modify_edge.push_back({ptr1, ptr2});\\n            }\\n        }\\n        vector<int> cost(n, INT_MAX);\\n        // Use Dijkstra\\'s algorithm to get the current max path to destination.\\n        int max_sol = dijkstra_max(path, cost, source, destination, n);\\n        /* \\n        Since we removed all -1 paths. If there is still a path less\\n        than the target, then it will be impossible to have a minimum\\n        path of more than the current max_sol.\\n        */\\n        if (max_sol < target) {\\n            vector<vector<int>> result;\\n            return result;\\n        }\\n        int index = -1;\\n        pair<dest_info*, dest_info*> modification;\\n        /* \\n        We loop to update the solution we got from Dijkstra by\\n        connecting each -1 path one by one until we find the\\n        \\'bottleneck\\', the path where it allows the source and\\n        destination to be connected with minimum path less than\\n        target. \\n        */\\n        while (cost[destination] == INT_MAX || cost[destination] > target) {\\n            if (maybe_path.size() == 0) {\\n                vector<vector<int>> result;\\n                return result;\\n            }\\n            index = maybe_path.back();\\n            modification = modify_edge.back();\\n            maybe_path.pop_back();\\n            modify_edge.pop_back();\\n            // Set newly added path to 1 since we want to minimize the distance while finding the bottleneck.\\n            modification.first->weight = 1;\\n            modification.second->weight = 1;\\n            edges[index][2] = 1;\\n            update_dijkstra(path, cost, edges[index]);\\n        }\\n        // Adjust the bottleneck so that the shortest path is equal to the target.\\n        if (index != -1) {\\n            edges[index][2] = target - cost[destination] + 1;\\n        }\\n        // Make the other path impossible by setting it to max value.\\n        for (auto index: maybe_path) {\\n            edges[index][2] = 2 * pow(10, 9);\\n        }\\n        // Free memory.\\n        // for (auto kv: path) {\\n        //     for (auto ptr: kv.second) {\\n        //         delete ptr;\\n        //     }\\n        // }\\n        return edges;\\n    }\\n\\n    void update_dijkstra(unordered_map<int, vector<dest_info*>>& adj_list, vector<int>& cost, vector<int>& changes) {\\n        int starting;\\n        int ending;\\n        /* \\n        Set the two ends of the edge with weight -1 to starting\\n        and ending where we want the starting to have shorter path\\n        so that we can update the one with longer path.\\n        */\\n        if (cost[changes[0]] < cost[changes[1]]) {\\n            starting = changes[0];\\n            ending = changes[1];\\n        }\\n        else {\\n            starting = changes[1];\\n            ending = changes[0];\\n        }\\n        if (cost[starting] == INT_MAX) {\\n            return;\\n        }\\n        if (cost[starting] + 1 < cost[ending]) {\\n            cost[ending] = cost[starting] + 1;\\n        }\\n        else {\\n            return;\\n        }\\n        queue<int> q;\\n        q.push(ending);\\n        int current;\\n        // Loop to continue updating until there are no more changes.\\n        while (!q.empty()) {\\n            current = q.front();\\n            q.pop();\\n            vector<dest_info*> edges = adj_list[current];\\n            for (auto& edge: edges) {\\n                int dest = edge->destination;\\n                if (edge->weight == INT_MAX || cost[current] == INT_MAX) {\\n                    continue;\\n                }\\n                if (edge->weight + cost[current] < cost[dest]) {\\n                    cost[dest] = edge->weight + cost[current];\\n                    q.push(dest);\\n                }\\n            }\\n        }\\n    }\\n\\n    int dijkstra_max(unordered_map<int, vector<dest_info*>>& adj_list, vector<int>& cost, int starting, int dest, int size) {\\n        vector<dest_info*> current_edge;\\n        unordered_set<int> visited;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        int total_path = 0;\\n        int current = starting;\\n        cost[starting] = 0;\\n        bool loop = true;\\n        while (loop) {\\n            visited.insert(current);\\n            current_edge = adj_list[current];\\n            for (auto& edge: current_edge) {\\n                int dest = edge->destination;\\n                int weight;\\n                if (edge->weight != INT_MAX && cost[current] != INT_MAX) {\\n                    weight = cost[current] + edge->weight;\\n                }\\n                else {\\n                    weight = INT_MAX;\\n                }\\n                if (cost[dest] > weight) {\\n                    cost[dest] = weight;\\n                    pq.push({weight, dest});\\n                }\\n            }\\n            while (visited.find(current) != visited.end()) {\\n                if (pq.empty()) {\\n                    loop = false;\\n                    break;\\n                }\\n                current = pq.top().second;\\n                pq.pop();\\n            }\\n        }\\n        return cost[dest];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Greedy",
                    "Graph",
                    "Heap (Priority Queue)",
                    "Shortest Path"
                ],
                "code": "```\\n/* \\nThe code below is the code I submitted without any optimisations or\\nany cleaning done so if there is a better way of implementing this,\\nespecially since this uses a lot of memory in exchange for time, \\nplease share below so I can improve as well!\\n\\nSince I\\'m new to C++, if there\\'s anything that doesn\\'t align\\nwith the typical standards or if there\\'s a fascinating aspect of the\\nlanguage you\\'d like to share, feel free to share your thoughts\\nin the comments section.\\n\\nThanks for taking the time to go through my post and I hope there are \\nno major problem with my algorithm or code.\\n*/\\nclass Solution {\\npublic:\\n    struct dest_info\\n    {\\n        int index;\\n        int destination;\\n        int weight;\\n    };\\n\\n    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int source, int destination, int target) {\\n        unordered_map<int, vector<dest_info*>> path;\\n        vector<int> maybe_path;\\n        vector<pair<dest_info*, dest_info*>> modify_edge;\\n        // Stores all possible path into hash map for faster finds.\\n        for (int i = 0; i < edges.size(); i++) {\\n            vector<int> edge = edges[i];\\n            int key1 = edge[0];\\n            int key2 = edge[1];\\n            int weight = edge[2];\\n            // Consider those with path -1 as having no path.\\n            if (weight == -1) {\\n                weight = INT_MAX;\\n            }\\n            // Stores necessary information.\\n            dest_info* ptr1 = new dest_info;\\n            dest_info* ptr2 = new dest_info;\\n            ptr1->index = i;\\n            ptr1->destination = key2;\\n            ptr1->weight = weight;\\n            ptr2->index = i;\\n            ptr2->destination = key1;\\n            ptr2->weight = weight;\\n            path[key1].push_back(ptr1);\\n            path[key2].push_back(ptr2);\\n            /* \\n            Stores the index the -1 path corresponds to and their\\n            corresponding path info.\\n            */\\n            if (weight == INT_MAX) {\\n                maybe_path.push_back(i);\\n                modify_edge.push_back({ptr1, ptr2});\\n            }\\n        }\\n        vector<int> cost(n, INT_MAX);\\n        // Use Dijkstra\\'s algorithm to get the current max path to destination.\\n        int max_sol = dijkstra_max(path, cost, source, destination, n);\\n        /* \\n        Since we removed all -1 paths. If there is still a path less\\n        than the target, then it will be impossible to have a minimum\\n        path of more than the current max_sol.\\n        */\\n        if (max_sol < target) {\\n            vector<vector<int>> result;\\n            return result;\\n        }\\n        int index = -1;\\n        pair<dest_info*, dest_info*> modification;\\n        /* \\n        We loop to update the solution we got from Dijkstra by\\n        connecting each -1 path one by one until we find the\\n        \\'bottleneck\\', the path where it allows the source and\\n        destination to be connected with minimum path less than\\n        target. \\n        */\\n        while (cost[destination] == INT_MAX || cost[destination] > target) {\\n            if (maybe_path.size() == 0) {\\n                vector<vector<int>> result;\\n                return result;\\n            }\\n            index = maybe_path.back();\\n            modification = modify_edge.back();\\n            maybe_path.pop_back();\\n            modify_edge.pop_back();\\n            // Set newly added path to 1 since we want to minimize the distance while finding the bottleneck.\\n            modification.first->weight = 1;\\n            modification.second->weight = 1;\\n            edges[index][2] = 1;\\n            update_dijkstra(path, cost, edges[index]);\\n        }\\n        // Adjust the bottleneck so that the shortest path is equal to the target.\\n        if (index != -1) {\\n            edges[index][2] = target - cost[destination] + 1;\\n        }\\n        // Make the other path impossible by setting it to max value.\\n        for (auto index: maybe_path) {\\n            edges[index][2] = 2 * pow(10, 9);\\n        }\\n        // Free memory.\\n        // for (auto kv: path) {\\n        //     for (auto ptr: kv.second) {\\n        //         delete ptr;\\n        //     }\\n        // }\\n        return edges;\\n    }\\n\\n    void update_dijkstra(unordered_map<int, vector<dest_info*>>& adj_list, vector<int>& cost, vector<int>& changes) {\\n        int starting;\\n        int ending;\\n        /* \\n        Set the two ends of the edge with weight -1 to starting\\n        and ending where we want the starting to have shorter path\\n        so that we can update the one with longer path.\\n        */\\n        if (cost[changes[0]] < cost[changes[1]]) {\\n            starting = changes[0];\\n            ending = changes[1];\\n        }\\n        else {\\n            starting = changes[1];\\n            ending = changes[0];\\n        }\\n        if (cost[starting] == INT_MAX) {\\n            return;\\n        }\\n        if (cost[starting] + 1 < cost[ending]) {\\n            cost[ending] = cost[starting] + 1;\\n        }\\n        else {\\n            return;\\n        }\\n        queue<int> q;\\n        q.push(ending);\\n        int current;\\n        // Loop to continue updating until there are no more changes.\\n        while (!q.empty()) {\\n            current = q.front();\\n            q.pop();\\n            vector<dest_info*> edges = adj_list[current];\\n            for (auto& edge: edges) {\\n                int dest = edge->destination;\\n                if (edge->weight == INT_MAX || cost[current] == INT_MAX) {\\n                    continue;\\n                }\\n                if (edge->weight + cost[current] < cost[dest]) {\\n                    cost[dest] = edge->weight + cost[current];\\n                    q.push(dest);\\n                }\\n            }\\n        }\\n    }\\n\\n    int dijkstra_max(unordered_map<int, vector<dest_info*>>& adj_list, vector<int>& cost, int starting, int dest, int size) {\\n        vector<dest_info*> current_edge;\\n        unordered_set<int> visited;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        int total_path = 0;\\n        int current = starting;\\n        cost[starting] = 0;\\n        bool loop = true;\\n        while (loop) {\\n            visited.insert(current);\\n            current_edge = adj_list[current];\\n            for (auto& edge: current_edge) {\\n                int dest = edge->destination;\\n                int weight;\\n                if (edge->weight != INT_MAX && cost[current] != INT_MAX) {\\n                    weight = cost[current] + edge->weight;\\n                }\\n                else {\\n                    weight = INT_MAX;\\n                }\\n                if (cost[dest] > weight) {\\n                    cost[dest] = weight;\\n                    pq.push({weight, dest});\\n                }\\n            }\\n            while (visited.find(current) != visited.end()) {\\n                if (pq.empty()) {\\n                    loop = false;\\n                    break;\\n                }\\n                current = pq.top().second;\\n                pq.pop();\\n            }\\n        }\\n        return cost[dest];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3859039,
                "title": "c-solution-very-easy-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nApplying dijkstra for multiple time on the maximum possible path and checking whether we can construct a graph or not of the given target.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCheck whether it is possible to construct a grpah or not\\nthen take a feasible path from src to dest and run dijkstra\\'s see the code for better understanding\\n\\n# Complexity\\n- Time complexity: O(n^2logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int src, int dest, int target) {\\n        const long long inf = 2e9;\\n        vector<vector<pair<long long,long long>>>graph1(n),graph2(n);\\n        map<pair<long long,long long>,long long>mp;\\n        for(auto edge: edges){\\n            long long to = edge[0],from = edge[1],w = edge[2];\\n            if(to > from){\\n                swap(to,from);\\n            }\\n            mp[{to,from}] = w;\\n            if(w == -1){\\n                graph1[to].push_back({from,1});\\n                graph2[to].push_back({from,inf});\\n                graph1[from].push_back({to,1});\\n                graph2[from].push_back({to,inf});\\n            }else{\\n                graph1[to].push_back({from,w});\\n                graph2[to].push_back({from,w});\\n                graph1[from].push_back({to,w});\\n                graph2[from].push_back({to,w});\\n            }\\n        }\\n        vector<long long>par(n),init(n);\\n        auto dij = [&](vector<vector<pair<long long,long long>>>&graph){\\n            using pii = pair<long long,long long>;\\n            priority_queue<pii,vector<pii>,greater<pii>>pq;\\n            pq.push({0,src});\\n            vector<long long>dist(n,inf);\\n            dist[src] = 0;\\n            par[src] = -1;\\n            while(pq.size()){\\n                auto [len,top] = pq.top();\\n                pq.pop();\\n                for(auto [node,w]: graph[top]){\\n                    if(dist[node] > dist[top] + w){\\n                        par[node] = top;\\n                        dist[node] = dist[top] + w;\\n                        pq.push({dist[node],node});\\n                    }\\n                }\\n            }\\n            return dist[dest];\\n        };\\n        long long mini =  dij(graph2); \\n        long long maxi = dij(graph1);\\n        cout << mini << \" \" << maxi << endl;\\n        if(mini == target){\\n            vector<vector<int>>ans = edges;\\n            for(auto &edge: ans){\\n                if(edge[2] == -1){\\n                    edge[2] = inf;\\n                }\\n            }\\n            return ans;\\n        }  \\n        if(maxi > target or target > mini){\\n            return {};\\n        }\\n        init = par;\\n        int node = dest;\\n        for(int i = 0; i < n; i++){\\n            cout <<init[i] << \\' \\';\\n        }\\n        cout << endl;\\n        while(init[node] != -1){\\n            long long to = node;\\n            long long from = init[node];\\n            cout << to << \\' \\' << from << endl;\\n            if(to > from)\\n                swap(to,from);\\n            if(mp[{to,from}] == -1){\\n                mp[{to,from}] = 1;\\n            }else{\\n                node = init[node];\\n                continue;\\n            }\\n            for(auto &[child,len]: graph2[to]){\\n                if(child == from){\\n                    len = mp[{to,from}];\\n                }\\n            }\\n            for(auto &[child,len]: graph2[from]){\\n                if(child == to){\\n                    len = mp[{to,from}];\\n                }\\n            }\\n            int req = dij(graph2);\\n            if(req <= target){\\n                mp[{to,from}] = target - req + 1;\\n                break;\\n            }\\n            node = init[node];\\n        }\\n        vector<vector<int>>ans;\\n        for(auto edge: edges){\\n            int to = edge[0],from = edge[1];\\n            if(to > from){\\n                swap(to,from);\\n            }\\n            int res;\\n            if(mp[{to,from}] == -1){\\n                res = 2*(1e9);\\n            }else{\\n                res = mp[{to,from}];\\n            }\\n            ans.push_back({edge[0],edge[1],res});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int src, int dest, int target) {\\n        const long long inf = 2e9;\\n        vector<vector<pair<long long,long long>>>graph1(n),graph2(n);\\n        map<pair<long long,long long>,long long>mp;\\n        for(auto edge: edges){\\n            long long to = edge[0],from = edge[1],w = edge[2];\\n            if(to > from){\\n                swap(to,from);\\n            }\\n            mp[{to,from}] = w;\\n            if(w == -1){\\n                graph1[to].push_back({from,1});\\n                graph2[to].push_back({from,inf});\\n                graph1[from].push_back({to,1});\\n                graph2[from].push_back({to,inf});\\n            }else{\\n                graph1[to].push_back({from,w});\\n                graph2[to].push_back({from,w});\\n                graph1[from].push_back({to,w});\\n                graph2[from].push_back({to,w});\\n            }\\n        }\\n        vector<long long>par(n),init(n);\\n        auto dij = [&](vector<vector<pair<long long,long long>>>&graph){\\n            using pii = pair<long long,long long>;\\n            priority_queue<pii,vector<pii>,greater<pii>>pq;\\n            pq.push({0,src});\\n            vector<long long>dist(n,inf);\\n            dist[src] = 0;\\n            par[src] = -1;\\n            while(pq.size()){\\n                auto [len,top] = pq.top();\\n                pq.pop();\\n                for(auto [node,w]: graph[top]){\\n                    if(dist[node] > dist[top] + w){\\n                        par[node] = top;\\n                        dist[node] = dist[top] + w;\\n                        pq.push({dist[node],node});\\n                    }\\n                }\\n            }\\n            return dist[dest];\\n        };\\n        long long mini =  dij(graph2); \\n        long long maxi = dij(graph1);\\n        cout << mini << \" \" << maxi << endl;\\n        if(mini == target){\\n            vector<vector<int>>ans = edges;\\n            for(auto &edge: ans){\\n                if(edge[2] == -1){\\n                    edge[2] = inf;\\n                }\\n            }\\n            return ans;\\n        }  \\n        if(maxi > target or target > mini){\\n            return {};\\n        }\\n        init = par;\\n        int node = dest;\\n        for(int i = 0; i < n; i++){\\n            cout <<init[i] << \\' \\';\\n        }\\n        cout << endl;\\n        while(init[node] != -1){\\n            long long to = node;\\n            long long from = init[node];\\n            cout << to << \\' \\' << from << endl;\\n            if(to > from)\\n                swap(to,from);\\n            if(mp[{to,from}] == -1){\\n                mp[{to,from}] = 1;\\n            }else{\\n                node = init[node];\\n                continue;\\n            }\\n            for(auto &[child,len]: graph2[to]){\\n                if(child == from){\\n                    len = mp[{to,from}];\\n                }\\n            }\\n            for(auto &[child,len]: graph2[from]){\\n                if(child == to){\\n                    len = mp[{to,from}];\\n                }\\n            }\\n            int req = dij(graph2);\\n            if(req <= target){\\n                mp[{to,from}] = target - req + 1;\\n                break;\\n            }\\n            node = init[node];\\n        }\\n        vector<vector<int>>ans;\\n        for(auto edge: edges){\\n            int to = edge[0],from = edge[1];\\n            if(to > from){\\n                swap(to,from);\\n            }\\n            int res;\\n            if(mp[{to,from}] == -1){\\n                res = 2*(1e9);\\n            }else{\\n                res = mp[{to,from}];\\n            }\\n            ans.push_back({edge[0],edge[1],res});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3810618,
                "title": "easy-c-dijkstra-s-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n      O(N*Log(V)*(E+V))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<int> solve(int src, int end ,vector<vector<pair<int,int>>>&adj,int n)\\n{\\nvector<int> dist(n,1e9);\\n priority_queue<pair<int,int>, vector<pair<int,int>> ,greater<pair<int,int>>>pq;\\n pq.push({0,src});\\n dist[src]=0;\\n while(!pq.empty())\\n {\\n     int ele=pq.top().second;\\n     int d=pq.top().first;\\n     pq.pop();\\n     if(ele==end) break;\\n     for(auto &it: adj[ele])\\n     {\\n         int adjnode=it.first;\\n         int edgewt=it.second;\\n         if(dist[adjnode] > edgewt+ d)\\n         {\\n             dist[adjnode]= edgewt+d;\\n    \\n             pq.push({dist[adjnode], adjnode});\\n         }\\n\\n     }\\n }\\n return dist;\\n}\\n    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int source, int destination, int target) {\\n      \\n        vector<vector<pair<int,int>>> adj(n);\\n        for(auto it: edges)\\n        {\\n            int u=it[0];\\n            int v=it[1];\\n            int wt=it[2];\\n            if(wt==-1) continue;\\n            adj[u].push_back({v,wt});\\n            adj[v].push_back({u,wt});\\n        }\\n      vector<int> dist=solve(source, destination,adj, n );\\n      if(dist[destination] < target) return {};\\n      if(dist[destination]==target)\\n      {\\n          for(auto &it:edges)\\n          {\\n              if(it[2]==-1)\\n              {\\n                  it[2]=1e9;\\n              }\\n          }\\n          return edges;\\n      }\\n     for(int i=0;i<edges.size();i++)\\n        {\\n            int u=edges[i][0],v=edges[i][1],w=edges[i][2];\\n            if(w==-1)\\n            {\\n                edges[i][2]=1;\\n                adj[u].push_back({v,1});\\n                adj[v].push_back({u,1});\\n                vector<int>dis=solve(source, destination , adj, n);\\n                if(dis[destination]<=target)\\n                {\\n                    edges[i][2]+=(target-dis[destination]);\\n                    for(int j=i+1;j<edges.size();j++)\\n                    {\\n                        if(edges[j][2]==-1)\\n                        {\\n                            edges[j][2]=1e9;\\n                        }\\n                    }\\n                    return edges;\\n                }\\n            }\\n        }\\n\\n          return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<int> solve(int src, int end ,vector<vector<pair<int,int>>>&adj,int n)\\n{\\nvector<int> dist(n,1e9);\\n priority_queue<pair<int,int>, vector<pair<int,int>> ,greater<pair<int,int>>>pq;\\n pq.push({0,src});\\n dist[src]=0;\\n while(!pq.empty())\\n {\\n     int ele=pq.top().second;\\n     int d=pq.top().first;\\n     pq.pop();\\n     if(ele==end) break;\\n     for(auto &it: adj[ele])\\n     {\\n         int adjnode=it.first;\\n         int edgewt=it.second;\\n         if(dist[adjnode] > edgewt+ d)\\n         {\\n             dist[adjnode]= edgewt+d;\\n    \\n             pq.push({dist[adjnode], adjnode});\\n         }\\n\\n     }\\n }\\n return dist;\\n}\\n    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int source, int destination, int target) {\\n      \\n        vector<vector<pair<int,int>>> adj(n);\\n        for(auto it: edges)\\n        {\\n            int u=it[0];\\n            int v=it[1];\\n            int wt=it[2];\\n            if(wt==-1) continue;\\n            adj[u].push_back({v,wt});\\n            adj[v].push_back({u,wt});\\n        }\\n      vector<int> dist=solve(source, destination,adj, n );\\n      if(dist[destination] < target) return {};\\n      if(dist[destination]==target)\\n      {\\n          for(auto &it:edges)\\n          {\\n              if(it[2]==-1)\\n              {\\n                  it[2]=1e9;\\n              }\\n          }\\n          return edges;\\n      }\\n     for(int i=0;i<edges.size();i++)\\n        {\\n            int u=edges[i][0],v=edges[i][1],w=edges[i][2];\\n            if(w==-1)\\n            {\\n                edges[i][2]=1;\\n                adj[u].push_back({v,1});\\n                adj[v].push_back({u,1});\\n                vector<int>dis=solve(source, destination , adj, n);\\n                if(dis[destination]<=target)\\n                {\\n                    edges[i][2]+=(target-dis[destination]);\\n                    for(int j=i+1;j<edges.size();j++)\\n                    {\\n                        if(edges[j][2]==-1)\\n                        {\\n                            edges[j][2]=1e9;\\n                        }\\n                    }\\n                    return edges;\\n                }\\n            }\\n        }\\n\\n          return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682367,
                "title": "c-dijkastra-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int source, int destination, int target) {\\n\\n    vector<vector<pair<int, int>>> adj(n);\\n    vector<vector<int>> ans;\\n    for (auto it: edges) {\\n        if(it[2]==-1) continue;\\n        adj[it[0]].push_back({it[1],it[2]});\\n        adj[it[1]].push_back({it[0],it[2]});\\n    }\\npriority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> q;\\n   q.push({0,source});\\n   vector<int> dist(n,1e9);\\n   dist[source]=0;\\n   while(!q.empty()){\\n       int cur_dist=q.top().first;\\n       int node=q.top().second;\\n       q.pop();\\n       if(node==destination) break;\\n\\n       for(auto it:adj[node]){\\n           int adjnode=it.first;\\n           int wt=it.second;\\n           if(cur_dist+wt<dist[adjnode]){\\n               dist[adjnode]=cur_dist+wt;\\n               q.push({dist[adjnode],adjnode});\\n           }\\n       }\\n   }\\n   if(dist[destination]<target){\\n       return {};\\n   }\\n   if(dist[destination]==target){\\n       for(auto &it:edges){\\n           if(it[2]==-1){\\n               it[2]=1e9;\\n           }\\n       }\\n       return edges;\\n   }\\npriority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n   for(int i=0;i<edges.size();i++){\\n       auto &it=edges[i];\\n       if(edges[i][2]==-1){\\n           edges[i][2]=1;\\n           adj[edges[i][1]].push_back({edges[i][0],edges[i][2]});\\n           adj[edges[i][0]].push_back({edges[i][1],edges[i][2]});\\n\\n           while(!pq.empty()){\\n                pq.pop();\\n            }\\n       //Dijkstra\\n       pq.push({0,source});\\n       vector<int> dist(n,1e9);\\n       dist[source]=0;\\n       while(!pq.empty()){\\n       int cur_dist=pq.top().first;\\n       int node=pq.top().second;\\n       pq.pop();\\n       if(node==destination) break;\\n\\n       for(auto it:adj[node]){\\n          int adjnode=it.first;\\n           int wt=it.second;\\n           if(cur_dist+wt<dist[adjnode]){\\n               dist[adjnode]=cur_dist+wt;\\n               pq.push({dist[adjnode],adjnode});\\n           }\\n       }\\n   }\\n\\n   if(dist[destination]<=target){\\n       it[2]+=target-dist[destination];\\n\\n       for(int j=i+1;j<edges.size();j++){\\n           if(edges[j][2]==-1){\\n               edges[j][2]=1e9;\\n           }\\n       }\\n       return edges;\\n       }\\n       }\\n\\n   }\\n   return {};\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int source, int destination, int target) {\\n\\n    vector<vector<pair<int, int>>> adj(n);\\n    vector<vector<int>> ans;\\n    for (auto it: edges) {\\n        if(it[2]==-1) continue;\\n        adj[it[0]].push_back({it[1],it[2]});\\n        adj[it[1]].push_back({it[0],it[2]});\\n    }\\npriority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> q;\\n   q.push({0,source});\\n   vector<int> dist(n,1e9);\\n   dist[source]=0;\\n   while(!q.empty()){\\n       int cur_dist=q.top().first;\\n       int node=q.top().second;\\n       q.pop();\\n       if(node==destination) break;\\n\\n       for(auto it:adj[node]){\\n           int adjnode=it.first;\\n           int wt=it.second;\\n           if(cur_dist+wt<dist[adjnode]){\\n               dist[adjnode]=cur_dist+wt;\\n               q.push({dist[adjnode],adjnode});\\n           }\\n       }\\n   }\\n   if(dist[destination]<target){\\n       return {};\\n   }\\n   if(dist[destination]==target){\\n       for(auto &it:edges){\\n           if(it[2]==-1){\\n               it[2]=1e9;\\n           }\\n       }\\n       return edges;\\n   }\\npriority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n   for(int i=0;i<edges.size();i++){\\n       auto &it=edges[i];\\n       if(edges[i][2]==-1){\\n           edges[i][2]=1;\\n           adj[edges[i][1]].push_back({edges[i][0],edges[i][2]});\\n           adj[edges[i][0]].push_back({edges[i][1],edges[i][2]});\\n\\n           while(!pq.empty()){\\n                pq.pop();\\n            }\\n       //Dijkstra\\n       pq.push({0,source});\\n       vector<int> dist(n,1e9);\\n       dist[source]=0;\\n       while(!pq.empty()){\\n       int cur_dist=pq.top().first;\\n       int node=pq.top().second;\\n       pq.pop();\\n       if(node==destination) break;\\n\\n       for(auto it:adj[node]){\\n          int adjnode=it.first;\\n           int wt=it.second;\\n           if(cur_dist+wt<dist[adjnode]){\\n               dist[adjnode]=cur_dist+wt;\\n               pq.push({dist[adjnode],adjnode});\\n           }\\n       }\\n   }\\n\\n   if(dist[destination]<=target){\\n       it[2]+=target-dist[destination];\\n\\n       for(int j=i+1;j<edges.size();j++){\\n           if(edges[j][2]==-1){\\n               edges[j][2]=1e9;\\n           }\\n       }\\n       return edges;\\n       }\\n       }\\n\\n   }\\n   return {};\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595792,
                "title": "python3-dijkstra-beats-90-time",
                "content": "# Intuition\\nWe update edges by adding the delta to the target until we either find a solution or can\\'t amend the path anymore.\\n\\n# Approach\\nThe algorithm operates like this:\\n\\n1. Set all mutable weights to 1\\n2. Find the shortest path\\n3. If the path is equal to target, success\\n4. If the path is longer than target, the input is not solvable\\n5. If the path doesn\\'t include mutable edges, unsolvable\\n6. Add the delta of target - actual_cost to one of the mutable edges in the path\\n7. Set all mutable edges that aren\\'t part of the path to the max possible value 2e9\\n8. Return to step 2\\n\\n![image.png](https://assets.leetcode.com/users/images/b1822c8a-b297-4d9a-8052-c80834399c74_1685859485.8516557.png)\\n\\n\\n# Code\\n```\\nimport heapq\\ninf = float(\\'inf\\')\\nm = int(2e9)\\n\\ndef dijkstra(A, start, goal):\\n    n = len(A)\\n    visited = [False] * n\\n    distances = [inf] * n\\n    paths = {i: [] for i in range(n)}\\n    queue = [(0, start)]\\n\\n    distances[start] = 0\\n\\n    while queue:\\n        (dist, current) = heapq.heappop(queue)\\n\\n        if visited[current]:\\n            continue\\n\\n        visited[current] = True\\n\\n        if current == goal:\\n            return paths[current] + [current]\\n\\n        for neighbor in range(n):\\n            old_distance = distances[neighbor]\\n            new_distance = A[current][neighbor] + dist\\n\\n            if new_distance < old_distance and not visited[neighbor]:\\n                distances[neighbor] = new_distance\\n                paths[neighbor] = paths[current] + [current]\\n                heapq.heappush(queue, (new_distance, neighbor))\\n    return []\\n\\nclass Solution:\\n    def modifiedGraphEdges(self, n: int, edges: List[List[int]], source: int, destination: int, target: int) -> List[List[int]]:\\n        A = [[inf] * n for _ in range(n)]\\n        B = [[-1] * n for _ in range(n)]\\n        mutable = set()\\n        for i, edge in enumerate(edges):\\n            a, b, w = edge\\n            if w == -1:\\n                mutable.add(i)\\n                w = edge[2] = 1\\n            A[b][a] = A[a][b] = w\\n            B[b][a] = B[a][b] = i\\n\\n        while True:\\n            path = dijkstra(A, source, destination)\\n            c, p_edges = cost_and_edges(A, B, path)\\n            if c == target: return edges\\n            if c > target: return []\\n            if not p_edges & mutable: return []\\n\\n            e = list(mutable & p_edges)[0]\\n            edges[e][2] += target - c\\n            A[edges[e][0]][edges[e][1]] += target - c\\n            A[edges[e][1]][edges[e][0]] += target - c\\n            if edges[e][2] > m: return []\\n\\n            for e in mutable - p_edges:\\n                edges[e][2] = target + 1\\n                A[edges[e][0]][edges[e][1]] = m\\n                A[edges[e][1]][edges[e][0]] = m\\n\\n\\ndef cost_and_edges(A, B, path):\\n    if not path: return inf\\n    c = 0\\n    i = path[0]\\n    p_edges = set()\\n    for j in path[1:]:\\n        p_edges.add(B[i][j])\\n        c += A[i][j]\\n        i = j\\n    return c, p_edges\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport heapq\\ninf = float(\\'inf\\')\\nm = int(2e9)\\n\\ndef dijkstra(A, start, goal):\\n    n = len(A)\\n    visited = [False] * n\\n    distances = [inf] * n\\n    paths = {i: [] for i in range(n)}\\n    queue = [(0, start)]\\n\\n    distances[start] = 0\\n\\n    while queue:\\n        (dist, current) = heapq.heappop(queue)\\n\\n        if visited[current]:\\n            continue\\n\\n        visited[current] = True\\n\\n        if current == goal:\\n            return paths[current] + [current]\\n\\n        for neighbor in range(n):\\n            old_distance = distances[neighbor]\\n            new_distance = A[current][neighbor] + dist\\n\\n            if new_distance < old_distance and not visited[neighbor]:\\n                distances[neighbor] = new_distance\\n                paths[neighbor] = paths[current] + [current]\\n                heapq.heappush(queue, (new_distance, neighbor))\\n    return []\\n\\nclass Solution:\\n    def modifiedGraphEdges(self, n: int, edges: List[List[int]], source: int, destination: int, target: int) -> List[List[int]]:\\n        A = [[inf] * n for _ in range(n)]\\n        B = [[-1] * n for _ in range(n)]\\n        mutable = set()\\n        for i, edge in enumerate(edges):\\n            a, b, w = edge\\n            if w == -1:\\n                mutable.add(i)\\n                w = edge[2] = 1\\n            A[b][a] = A[a][b] = w\\n            B[b][a] = B[a][b] = i\\n\\n        while True:\\n            path = dijkstra(A, source, destination)\\n            c, p_edges = cost_and_edges(A, B, path)\\n            if c == target: return edges\\n            if c > target: return []\\n            if not p_edges & mutable: return []\\n\\n            e = list(mutable & p_edges)[0]\\n            edges[e][2] += target - c\\n            A[edges[e][0]][edges[e][1]] += target - c\\n            A[edges[e][1]][edges[e][0]] += target - c\\n            if edges[e][2] > m: return []\\n\\n            for e in mutable - p_edges:\\n                edges[e][2] = target + 1\\n                A[edges[e][0]][edges[e][1]] = m\\n                A[edges[e][1]][edges[e][0]] = m\\n\\n\\ndef cost_and_edges(A, B, path):\\n    if not path: return inf\\n    c = 0\\n    i = path[0]\\n    p_edges = set()\\n    for j in path[1:]:\\n        p_edges.add(B[i][j])\\n        c += A[i][j]\\n        i = j\\n    return c, p_edges\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594649,
                "title": "c-o-n3-logn-dijkstra",
                "content": "# Approach\\nSimilar to other dijkstra approaches, but we first find a path from source to destination, and instead of running dijkstra for every edge with weight -1, we only run it on those on the path. This essentially reduces the number of times we run Dijkstra to $O(n)$, since the path has at most $n$ nodes, and thus $n - 1$ edges.\\n\\nI try to keep the codestyle as simple as possible.\\n\\n# Complexity\\n- Time complexity:\\n$O(n^3 logn)$ since each Dijkstra is $O(n^2 logn)$.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int source, int destination, int target) {\\n        vector<vector<vector<int>>> adj(n);\\n        vector<int> free_edges;\\n        int m = edges.size();\\n        const int MAXD = 1e9 + 5;\\n        for (int j = 0; j != m; ++j){\\n            adj[edges[j][0]].push_back({edges[j][1], j});\\n            adj[edges[j][1]].push_back({edges[j][0], j});\\n            if (edges[j][2] == -1){\\n                free_edges.push_back(j);\\n            }\\n        }\\n        for (int j: free_edges){ edges[j][2] = MAXD; }\\n\\n        vector<int> d(n, MAXD);\\n        vector<bool> visited(n, false);\\n        vector<int> p(n, -1);  // parent\\n        function<void(bool)> dijkstra = [&](bool backtrack){\\n            fill(d.begin(), d.end(), MAXD);\\n            d[destination] = 0;\\n            fill(visited.begin(), visited.end(), false);\\n            priority_queue<pair<int, int>> pq;\\n            pq.emplace(0, destination);\\n            int c = 0; int j = 0; int newd = 0;\\n            while (!pq.empty()){\\n                int dist = -pq.top().first;\\n                int r = pq.top().second;\\n                pq.pop();\\n                if (visited[r]) { continue; }\\n                visited[r] = true;\\n                for (vector<int>& e: adj[r]){\\n                    c = e[0]; j = e[1];\\n                    newd = min(dist + edges[j][2], MAXD);\\n                    if (newd < d[c]){\\n                        d[c] = newd;\\n                        pq.emplace(-newd, c);\\n                        if (backtrack) { p[c] = r; }\\n                    }\\n                }\\n            }\\n        };\\n\\n        // check if all banned but still < target\\n        dijkstra(false);\\n        if (d[source] < target) { return vector<vector<int>>(); }\\n        // next, run a dijk to find a path from source to dist\\n        for (int j: free_edges){ edges[j][2] = 1; }\\n        dijkstra(true);\\n        if (d[source] > target) { return vector<vector<int>>(); }\\n        for (int j: free_edges){ edges[j][2] = MAXD; }\\n\\n        // for all edges on the path, set them one by one to 1\\n        int r = source;\\n        while (r != destination){\\n            int j = 0;\\n            for (vector<int>& e: adj[r]){\\n                if (e[0] == p[r]){\\n                    j = e[1]; break;\\n                }\\n            }\\n            if (edges[j][2] == MAXD) {\\n                edges[j][2] = 1;\\n                dijkstra(false);\\n                if (d[source] <= target){\\n                    edges[j][2] = 1 + target - d[source];\\n                    return edges;\\n                }\\n            }\\n            r = p[r];\\n        }\\n        return edges;  // if no edges need change\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int source, int destination, int target) {\\n        vector<vector<vector<int>>> adj(n);\\n        vector<int> free_edges;\\n        int m = edges.size();\\n        const int MAXD = 1e9 + 5;\\n        for (int j = 0; j != m; ++j){\\n            adj[edges[j][0]].push_back({edges[j][1], j});\\n            adj[edges[j][1]].push_back({edges[j][0], j});\\n            if (edges[j][2] == -1){\\n                free_edges.push_back(j);\\n            }\\n        }\\n        for (int j: free_edges){ edges[j][2] = MAXD; }\\n\\n        vector<int> d(n, MAXD);\\n        vector<bool> visited(n, false);\\n        vector<int> p(n, -1);  // parent\\n        function<void(bool)> dijkstra = [&](bool backtrack){\\n            fill(d.begin(), d.end(), MAXD);\\n            d[destination] = 0;\\n            fill(visited.begin(), visited.end(), false);\\n            priority_queue<pair<int, int>> pq;\\n            pq.emplace(0, destination);\\n            int c = 0; int j = 0; int newd = 0;\\n            while (!pq.empty()){\\n                int dist = -pq.top().first;\\n                int r = pq.top().second;\\n                pq.pop();\\n                if (visited[r]) { continue; }\\n                visited[r] = true;\\n                for (vector<int>& e: adj[r]){\\n                    c = e[0]; j = e[1];\\n                    newd = min(dist + edges[j][2], MAXD);\\n                    if (newd < d[c]){\\n                        d[c] = newd;\\n                        pq.emplace(-newd, c);\\n                        if (backtrack) { p[c] = r; }\\n                    }\\n                }\\n            }\\n        };\\n\\n        // check if all banned but still < target\\n        dijkstra(false);\\n        if (d[source] < target) { return vector<vector<int>>(); }\\n        // next, run a dijk to find a path from source to dist\\n        for (int j: free_edges){ edges[j][2] = 1; }\\n        dijkstra(true);\\n        if (d[source] > target) { return vector<vector<int>>(); }\\n        for (int j: free_edges){ edges[j][2] = MAXD; }\\n\\n        // for all edges on the path, set them one by one to 1\\n        int r = source;\\n        while (r != destination){\\n            int j = 0;\\n            for (vector<int>& e: adj[r]){\\n                if (e[0] == p[r]){\\n                    j = e[1]; break;\\n                }\\n            }\\n            if (edges[j][2] == MAXD) {\\n                edges[j][2] = 1;\\n                dijkstra(false);\\n                if (d[source] <= target){\\n                    edges[j][2] = 1 + target - d[source];\\n                    return edges;\\n                }\\n            }\\n            r = p[r];\\n        }\\n        return edges;  // if no edges need change\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594563,
                "title": "c-solution-djikstra",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>>dp[200];\\n    vector<int>find(int n,int src,int dist)\\n    {\\n        vector<int>dis(n+1,1e9+10);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        pq.push({0,src});\\n        dis[src]=0;\\n        vector<int>vis(n+10,0);\\n        while(pq.size())\\n        {\\n            auto [wt,node]=pq.top();\\n            pq.pop();\\n            if(vis[node])\\n            {\\n                continue;\\n            }\\n            vis[node]=1;\\n            for(auto &[current_node,current_wt]:dp[node])\\n            {\\n                if(dis[current_node]>current_wt+wt)\\n                {\\n                    dis[current_node]=current_wt+wt;\\n                    pq.push({dis[current_node],current_node});\\n                }\\n            }\\n        }\\n        return dis;\\n    }\\n    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int src, int dest, int target) \\n    {\\n        for(auto &it:edges)\\n        {\\n            if(it[2]==-1)\\n            {\\n                continue;\\n            }\\n            dp[it[0]].push_back({it[1],it[2]});\\n            dp[it[1]].push_back({it[0],it[2]});\\n        }\\n        vector<int>dist=find(n,src,dest);\\n        if(dist[dest]<target)\\n        {\\n            return {};\\n        }\\n       if(dist[dest]==target)\\n       {\\n           for(auto &it:edges)\\n           {\\n               if(it[2]==-1){\\n                   it[2]=2e9;\\n               }\\n           }\\n           return edges;\\n       }\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            int u=edges[i][0],v=edges[i][1],w=edges[i][2];\\n            if(w==-1)\\n            {\\n                edges[i][2]=1;\\n                dp[u].push_back({v,1});\\n                dp[v].push_back({u,1});\\n                vector<int>dis=find(n,src,dest);\\n                if(dis[dest]<=target)\\n                {\\n                    edges[i][2]+=(target-dis[dest]);\\n                    for(int j=i+1;j<edges.size();j++)\\n                    {\\n                        if(edges[j][2]==-1)\\n                        {\\n                            edges[j][2]=2e9;\\n                        }\\n                    }\\n                    return edges;\\n                }\\n            }\\n        }\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>>dp[200];\\n    vector<int>find(int n,int src,int dist)\\n    {\\n        vector<int>dis(n+1,1e9+10);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        pq.push({0,src});\\n        dis[src]=0;\\n        vector<int>vis(n+10,0);\\n        while(pq.size())\\n        {\\n            auto [wt,node]=pq.top();\\n            pq.pop();\\n            if(vis[node])\\n            {\\n                continue;\\n            }\\n            vis[node]=1;\\n            for(auto &[current_node,current_wt]:dp[node])\\n            {\\n                if(dis[current_node]>current_wt+wt)\\n                {\\n                    dis[current_node]=current_wt+wt;\\n                    pq.push({dis[current_node],current_node});\\n                }\\n            }\\n        }\\n        return dis;\\n    }\\n    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int src, int dest, int target) \\n    {\\n        for(auto &it:edges)\\n        {\\n            if(it[2]==-1)\\n            {\\n                continue;\\n            }\\n            dp[it[0]].push_back({it[1],it[2]});\\n            dp[it[1]].push_back({it[0],it[2]});\\n        }\\n        vector<int>dist=find(n,src,dest);\\n        if(dist[dest]<target)\\n        {\\n            return {};\\n        }\\n       if(dist[dest]==target)\\n       {\\n           for(auto &it:edges)\\n           {\\n               if(it[2]==-1){\\n                   it[2]=2e9;\\n               }\\n           }\\n           return edges;\\n       }\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            int u=edges[i][0],v=edges[i][1],w=edges[i][2];\\n            if(w==-1)\\n            {\\n                edges[i][2]=1;\\n                dp[u].push_back({v,1});\\n                dp[v].push_back({u,1});\\n                vector<int>dis=find(n,src,dest);\\n                if(dis[dest]<=target)\\n                {\\n                    edges[i][2]+=(target-dis[dest]);\\n                    for(int j=i+1;j<edges.size();j++)\\n                    {\\n                        if(edges[j][2]==-1)\\n                        {\\n                            edges[j][2]=2e9;\\n                        }\\n                    }\\n                    return edges;\\n                }\\n            }\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588868,
                "title": "c-two-direction-weight-calculation",
                "content": "# Intuition\\nCalculate weights from two directions to make the target weight.\\n\\n# Approach\\n- Copy the graph;\\n- Assign the minimum weight 1 to the copied graph, then do a reverse traversal from destination to source;\\n- Do another traversal from source to destination to assign weight to make target value;\\n- Use min-heap to make sure the target is the minimum path weight in the modified graph.\\n\\n# Complexity\\n- Time complexity: O(n^3)\\n\\n- Space complexity: O(n^2)\\n\\n# Code\\n```\\nclass Solution {\\n    // Get the smallest weights from source to any nodes\\n    vector<int> getPathWeights(int n, vector<vector<int>>& edges, int source){\\n        queue<int> q;\\n        q.push(source);\\n        vector<int> weights(n, INT_MAX);\\n        weights[source] = 0;\\n\\n        vector<vector<vector<int>*>> adj(n); // For easier access to adjacent nodes.\\n        for(auto &e : edges){\\n            adj[e[0]].push_back(&e);\\n            adj[e[1]].push_back(&e);\\n        }\\n\\n        while(!q.empty()){\\n            int from = q.front();\\n            q.pop();\\n            for(const auto p : adj[from]){\\n                auto& e = *p;\\n                if(e[0] == from || e[1] == from){// The edge has u.\\n                    int to = from ^ e[0] ^ e[1]; // There are two \\'u\\'s in this 3 variables, this operation will get the node that\\'s not u, i.e. v.\\n                    if(weights[to] > weights[from] + e[2]){\\n                        weights[to] = weights[from] + e[2];\\n                        q.push(to);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return weights;\\n    }\\n\\n    bool assignWeightForTarget(int n, vector<vector<int>>& edges, int source, int destination, int target, vector<int>& ts){\\n        priority_queue<pair<int, int>, vector<pair<int,int>>, greater<pair<int, int>>> minHeap; // pair<int, int>: {weight, node}, Make sure the smallest weight is processed first, so that the \\'smallest distance\\' is guaranteed (at least to be target).\\n        minHeap.push({0, source});\\n        vector<int> weights(n, INT_MAX);\\n        weights[source] = 0;\\n\\n        vector<vector<vector<int>*>> adj(n); // For easier access to adjacent nodes.\\n        for(auto &e : edges){\\n            adj[e[0]].push_back(&e);\\n            adj[e[1]].push_back(&e);\\n        }\\n\\n        while(!minHeap.empty()){\\n            int from = minHeap.top().second;\\n            minHeap.pop();\\n            for(const auto p : adj[from]){\\n                auto& e = *p;\\n                if(e[0] == from || e[1] == from){// The edge has u.\\n                    int to = from ^ e[0] ^ e[1]; // There are two \\'u\\'s in this 3 variables, this operation will get the node that\\'s not u, i.e. v.\\n                    if(e[2] == -1){\\n                        e[2] = max(1, target - ts[to] - weights[from]); // Try to make the path weight from source to destination equals to target.\\n                    }\\n\\n                    if(weights[to] > weights[from] + e[2]){\\n                        weights[to] = weights[from] + e[2];\\n                        minHeap.push({weights[to], to});\\n                    }\\n                }\\n            }\\n        }\\n\\n        return weights[destination] == target;\\n    }\\npublic:\\n    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int source, int destination, int target) {\\n        // Copy edges.\\n        auto copiedEdges = edges;\\n        // Assgin the minimum weight of 1.\\n        for(auto& v : copiedEdges){\\n            if(v[2] == -1) v[2] = 1;\\n        }\\n\\n        auto weights = getPathWeights(n, copiedEdges, destination); // Get path weights from destination to source.\\n        if(assignWeightForTarget(n, edges, source, destination, target, weights)) return edges;\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    // Get the smallest weights from source to any nodes\\n    vector<int> getPathWeights(int n, vector<vector<int>>& edges, int source){\\n        queue<int> q;\\n        q.push(source);\\n        vector<int> weights(n, INT_MAX);\\n        weights[source] = 0;\\n\\n        vector<vector<vector<int>*>> adj(n); // For easier access to adjacent nodes.\\n        for(auto &e : edges){\\n            adj[e[0]].push_back(&e);\\n            adj[e[1]].push_back(&e);\\n        }\\n\\n        while(!q.empty()){\\n            int from = q.front();\\n            q.pop();\\n            for(const auto p : adj[from]){\\n                auto& e = *p;\\n                if(e[0] == from || e[1] == from){// The edge has u.\\n                    int to = from ^ e[0] ^ e[1]; // There are two \\'u\\'s in this 3 variables, this operation will get the node that\\'s not u, i.e. v.\\n                    if(weights[to] > weights[from] + e[2]){\\n                        weights[to] = weights[from] + e[2];\\n                        q.push(to);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return weights;\\n    }\\n\\n    bool assignWeightForTarget(int n, vector<vector<int>>& edges, int source, int destination, int target, vector<int>& ts){\\n        priority_queue<pair<int, int>, vector<pair<int,int>>, greater<pair<int, int>>> minHeap; // pair<int, int>: {weight, node}, Make sure the smallest weight is processed first, so that the \\'smallest distance\\' is guaranteed (at least to be target).\\n        minHeap.push({0, source});\\n        vector<int> weights(n, INT_MAX);\\n        weights[source] = 0;\\n\\n        vector<vector<vector<int>*>> adj(n); // For easier access to adjacent nodes.\\n        for(auto &e : edges){\\n            adj[e[0]].push_back(&e);\\n            adj[e[1]].push_back(&e);\\n        }\\n\\n        while(!minHeap.empty()){\\n            int from = minHeap.top().second;\\n            minHeap.pop();\\n            for(const auto p : adj[from]){\\n                auto& e = *p;\\n                if(e[0] == from || e[1] == from){// The edge has u.\\n                    int to = from ^ e[0] ^ e[1]; // There are two \\'u\\'s in this 3 variables, this operation will get the node that\\'s not u, i.e. v.\\n                    if(e[2] == -1){\\n                        e[2] = max(1, target - ts[to] - weights[from]); // Try to make the path weight from source to destination equals to target.\\n                    }\\n\\n                    if(weights[to] > weights[from] + e[2]){\\n                        weights[to] = weights[from] + e[2];\\n                        minHeap.push({weights[to], to});\\n                    }\\n                }\\n            }\\n        }\\n\\n        return weights[destination] == target;\\n    }\\npublic:\\n    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int source, int destination, int target) {\\n        // Copy edges.\\n        auto copiedEdges = edges;\\n        // Assgin the minimum weight of 1.\\n        for(auto& v : copiedEdges){\\n            if(v[2] == -1) v[2] = 1;\\n        }\\n\\n        auto weights = getPathWeights(n, copiedEdges, destination); // Get path weights from destination to source.\\n        if(assignWeightForTarget(n, edges, source, destination, target, weights)) return edges;\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3577692,
                "title": "c-code-with-expalnation-for-beginners",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    private:\\n    // template of dijkstras algorithm\\n    int dij(int source,int dest,vector<pair<int,int>>adj[],int n){\\n        vector<int> dist(n);\\n        for(int i=0;i<n;i++){\\n            dist[i]=1e9;\\n        }\\n        dist[source]=0;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq; \\n        pq.push({0,source});\\n        while(!pq.empty()){\\n            int node=pq.top().second;\\n            int distance=pq.top().first;\\n            pq.pop();\\n            for(auto it: adj[node]){\\n                int adjnode=it.first;\\n                int edgewt=it.second;\\n                if(edgewt+distance<dist[adjnode]){\\n                    dist[adjnode]=edgewt+distance;\\n                    pq.push({dist[adjnode],adjnode});\\n                    \\n                }\\n\\n            }\\n        }\\n        return dist[dest];\\n    }\\npublic:\\n    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int source, int destination, int target) {\\n        // first create a adjlist of graph without negative weight edges\\n     \\n        vector<pair<int,int>> adj[n];\\n        for(auto &e: edges){\\n            if(e[2]!=-1){\\n            adj[e[0]].push_back({e[1],e[2]});\\n            adj[e[1]].push_back({e[0],e[2]});\\n            }\\n        }\\n           // and then calculate the shortest path using dij agorithm\\n        int shortest=dij(source,destination,adj,n);\\n        // check if shortest distance is less than target if it is true then there is no possibility to get shortest distance with target value so return empty list\\n        if(shortest<target){\\n            return {};\\n        }\\n\\n        // if shoretst dist is equal to target then our ans is came ansd modify the nwgative weights with large iteger so that it cannnot be another possible shortest paths and retuen edges;\\n        if(shortest==target){\\n           \\n            for(auto &e: edges){\\n                if(e[2]==-1){\\n                    e[2]=1e9;\\n                }\\n            }\\n            return edges;\\n        }\\n        // in this case we change each negative weight to +1 and check for the reqired target and make another negative edges 1e9; \\n       \\n        for(int i=0;i<edges.size();i++){\\n            if(edges[i][2]==-1){\\n                edges[i][2]=1;\\n                adj[edges[i][0]].push_back({edges[i][1],1});\\n                adj[edges[i][1]].push_back({edges[i][0],1});\\n                 shortest=dij(source,destination,adj,n);\\n                 if(shortest<=target){\\n                    edges[i][2]+=target-shortest;\\n                    for (int j = 0; j<edges.size(); j++){\\n                        int wt = edges[j][2];\\n                        if (wt == -1){\\n                            edges[j][2] = 1e9; \\n                        }\\n                    }\\n                    return edges;\\n                 }\\n\\n\\n                \\n            }\\n\\n         \\n\\n        }\\n        // after all this nothing is happen just return empty list\\n        return {};\\n\\n\\n\\n\\n\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Heap (Priority Queue)",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\n    private:\\n    // template of dijkstras algorithm\\n    int dij(int source,int dest,vector<pair<int,int>>adj[],int n){\\n        vector<int> dist(n);\\n        for(int i=0;i<n;i++){\\n            dist[i]=1e9;\\n        }\\n        dist[source]=0;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq; \\n        pq.push({0,source});\\n        while(!pq.empty()){\\n            int node=pq.top().second;\\n            int distance=pq.top().first;\\n            pq.pop();\\n            for(auto it: adj[node]){\\n                int adjnode=it.first;\\n                int edgewt=it.second;\\n                if(edgewt+distance<dist[adjnode]){\\n                    dist[adjnode]=edgewt+distance;\\n                    pq.push({dist[adjnode],adjnode});\\n                    \\n                }\\n\\n            }\\n        }\\n        return dist[dest];\\n    }\\npublic:\\n    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int source, int destination, int target) {\\n        // first create a adjlist of graph without negative weight edges\\n     \\n        vector<pair<int,int>> adj[n];\\n        for(auto &e: edges){\\n            if(e[2]!=-1){\\n            adj[e[0]].push_back({e[1],e[2]});\\n            adj[e[1]].push_back({e[0],e[2]});\\n            }\\n        }\\n           // and then calculate the shortest path using dij agorithm\\n        int shortest=dij(source,destination,adj,n);\\n        // check if shortest distance is less than target if it is true then there is no possibility to get shortest distance with target value so return empty list\\n        if(shortest<target){\\n            return {};\\n        }\\n\\n        // if shoretst dist is equal to target then our ans is came ansd modify the nwgative weights with large iteger so that it cannnot be another possible shortest paths and retuen edges;\\n        if(shortest==target){\\n           \\n            for(auto &e: edges){\\n                if(e[2]==-1){\\n                    e[2]=1e9;\\n                }\\n            }\\n            return edges;\\n        }\\n        // in this case we change each negative weight to +1 and check for the reqired target and make another negative edges 1e9; \\n       \\n        for(int i=0;i<edges.size();i++){\\n            if(edges[i][2]==-1){\\n                edges[i][2]=1;\\n                adj[edges[i][0]].push_back({edges[i][1],1});\\n                adj[edges[i][1]].push_back({edges[i][0],1});\\n                 shortest=dij(source,destination,adj,n);\\n                 if(shortest<=target){\\n                    edges[i][2]+=target-shortest;\\n                    for (int j = 0; j<edges.size(); j++){\\n                        int wt = edges[j][2];\\n                        if (wt == -1){\\n                            edges[j][2] = 1e9; \\n                        }\\n                    }\\n                    return edges;\\n                 }\\n\\n\\n                \\n            }\\n\\n         \\n\\n        }\\n        // after all this nothing is happen just return empty list\\n        return {};\\n\\n\\n\\n\\n\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3577414,
                "title": "q4-solution-with-code-and-notes-c",
                "content": "![4.jpeg](https://assets.leetcode.com/users/images/67d71422-e206-4569-9471-1897597268ba_1685422149.393327.jpeg)\\n\\n\\n# Code\\n```\\n#define vi vector<int>\\n#define vvi vector<vi>\\n#define pii pair<int,int>\\n#define vpii vector<pii>\\n#define gpii greater<pii>\\nclass Solution {\\n\\n    void dijkstra(vector<vpii>& G, int t, int src, int dest){\\n        for(int i=0; i<G.size(); i++) dist[i] = MAX_VAL;\\n        priority_queue<pii, vpii, gpii> pq;//minheap\\n        pq.push({0, src}); //pushing the source\\n        dist[src] = 0; //s to s dist is 0\\n        while(!pq.empty()){ //till it is not empty\\n            auto [d, n] = pq.top(); //accessing the top\\n            pq.pop(); //stardard procedure\\n            if(d > t) continue; //smart step\\n            if(n == dest) break; //smart step 2\\n            for(auto&[x,c] : G[n]) //for the adjacent nodes to the current node\\n                if(d + c < dist[x]){ //if it is something better\\n                    dist[x] = d + c; //update\\n                    pq.push({dist[x], x}); //we will need this, so push in pq\\n                }\\n        }\\n    }\\n\\npublic:\\n    int dist[105]; //distance vector from source to destination\\n    const int MAX_VAL = 2 * 1e9; //infinity\\n\\n    vvi modifiedGraphEdges(int n, vvi& E, int src, int dest, int t) {\\n        vector<vpii> G(n, vpii()); //construct the graph\\n        vector<int> skip; //to store all the node indexes which have negetive weight\\n        for(int i=0; i<E.size(); i++){\\n            auto &e = E[i]; \\n            if(e[2]!=-1){ //only check for positive edge weights\\n                G[e[0]].push_back({e[1], e[2]}); //connect a to b\\n                G[e[1]].push_back({e[0], e[2]}); //connect b to a\\n            } \\n            else skip.push_back(i);   //move negetively weighted edges to skip list.\\n        }\\n        dijkstra(G, t, src, dest); //find the shortest path from source to dest and update the dist array\\n        // if shortest path without modification is less than target\\n        // we can\\'t have modified edges graph with shortest path\\n        if(dist[dest]<t) return {}; //if even the shortest path cannot achieve your target, then return\\n        // if it equals target, put other edges weight to MAX, so that\\n        // shortest path weight remains same\\n        if(dist[dest] == t){ //this is the case we wanted and craved for\\n            for(auto x : skip)E[x][2] = MAX_VAL; //assign max_val to those nodes which we skipped\\n            return E; //return the edge set.\\n        }\\n        // otherwise try to change a path weight such that shortest path equals target\\n        for(auto i : skip){\\n            E[i][2] = 1; //make weight from -1 to 1 this means we include it, greedy strategy\\n            G[E[i][0]].push_back({E[i][1], 1}); //update the weight in your adj matrix a to b\\n            G[E[i][1]].push_back({E[i][0], 1}); //update the weight in your adj matrix b to a\\n            dijkstra(G, t, src, dest); //again call shortest path, this will update the dist\\n            if(dist[dest] <= t){ //and check if it is less than target\\n                E[i][2] += t - dist[dest]; //update the edge weigh\\n                for(int j=i+1; j<E.size(); j++) if(E[j][2]==-1)E[j][2] = MAX_VAL; //updating the negetive edge weights\\n                return E;\\n            }\\n        }\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define vi vector<int>\\n#define vvi vector<vi>\\n#define pii pair<int,int>\\n#define vpii vector<pii>\\n#define gpii greater<pii>\\nclass Solution {\\n\\n    void dijkstra(vector<vpii>& G, int t, int src, int dest){\\n        for(int i=0; i<G.size(); i++) dist[i] = MAX_VAL;\\n        priority_queue<pii, vpii, gpii> pq;//minheap\\n        pq.push({0, src}); //pushing the source\\n        dist[src] = 0; //s to s dist is 0\\n        while(!pq.empty()){ //till it is not empty\\n            auto [d, n] = pq.top(); //accessing the top\\n            pq.pop(); //stardard procedure\\n            if(d > t) continue; //smart step\\n            if(n == dest) break; //smart step 2\\n            for(auto&[x,c] : G[n]) //for the adjacent nodes to the current node\\n                if(d + c < dist[x]){ //if it is something better\\n                    dist[x] = d + c; //update\\n                    pq.push({dist[x], x}); //we will need this, so push in pq\\n                }\\n        }\\n    }\\n\\npublic:\\n    int dist[105]; //distance vector from source to destination\\n    const int MAX_VAL = 2 * 1e9; //infinity\\n\\n    vvi modifiedGraphEdges(int n, vvi& E, int src, int dest, int t) {\\n        vector<vpii> G(n, vpii()); //construct the graph\\n        vector<int> skip; //to store all the node indexes which have negetive weight\\n        for(int i=0; i<E.size(); i++){\\n            auto &e = E[i]; \\n            if(e[2]!=-1){ //only check for positive edge weights\\n                G[e[0]].push_back({e[1], e[2]}); //connect a to b\\n                G[e[1]].push_back({e[0], e[2]}); //connect b to a\\n            } \\n            else skip.push_back(i);   //move negetively weighted edges to skip list.\\n        }\\n        dijkstra(G, t, src, dest); //find the shortest path from source to dest and update the dist array\\n        // if shortest path without modification is less than target\\n        // we can\\'t have modified edges graph with shortest path\\n        if(dist[dest]<t) return {}; //if even the shortest path cannot achieve your target, then return\\n        // if it equals target, put other edges weight to MAX, so that\\n        // shortest path weight remains same\\n        if(dist[dest] == t){ //this is the case we wanted and craved for\\n            for(auto x : skip)E[x][2] = MAX_VAL; //assign max_val to those nodes which we skipped\\n            return E; //return the edge set.\\n        }\\n        // otherwise try to change a path weight such that shortest path equals target\\n        for(auto i : skip){\\n            E[i][2] = 1; //make weight from -1 to 1 this means we include it, greedy strategy\\n            G[E[i][0]].push_back({E[i][1], 1}); //update the weight in your adj matrix a to b\\n            G[E[i][1]].push_back({E[i][0], 1}); //update the weight in your adj matrix b to a\\n            dijkstra(G, t, src, dest); //again call shortest path, this will update the dist\\n            if(dist[dest] <= t){ //and check if it is less than target\\n                E[i][2] += t - dist[dest]; //update the edge weigh\\n                for(int j=i+1; j<E.size(); j++) if(E[j][2]==-1)E[j][2] = MAX_VAL; //updating the negetive edge weights\\n                return E;\\n            }\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570748,
                "title": "djikstra-with-priority-queue",
                "content": "# Code\\n```\\ntype Node struct {\\n\\tparent *Node\\n\\tkey    int\\n\\tweight int\\n}\\n\\ntype PriorityQueue []Node\\n\\nfunc (p PriorityQueue) Len() int {\\n\\treturn len(p)\\n}\\n\\nfunc (p PriorityQueue) Less(i, j int) bool {\\n\\treturn p[i].weight < p[j].weight\\n}\\n\\nfunc (p PriorityQueue) Swap(i, j int) {\\n\\tp[i], p[j] = p[j], p[i]\\n}\\n\\nfunc (p *PriorityQueue) Push(x interface{}) {\\n\\t*p = append(*p, x.(Node))\\n}\\n\\nfunc (p *PriorityQueue) Pop() interface{} {\\n\\tcpy := *p\\n\\tx := cpy[len(cpy)-1]\\n\\t*p = cpy[:len(cpy)-1]\\n\\treturn x\\n}\\n\\nfunc makeGraph(edges [][]int) map[int]map[int]int {\\n\\tgraph := make(map[int]map[int]int)\\n\\n\\tfor _, edge := range edges {\\n\\t\\tif _, ok := graph[edge[0]]; !ok {\\n\\t\\t\\tgraph[edge[0]] = make(map[int]int)\\n\\t\\t}\\n\\n\\t\\tif _, ok := graph[edge[1]]; !ok {\\n\\t\\t\\tgraph[edge[1]] = make(map[int]int)\\n\\t\\t}\\n\\n\\t\\tgraph[edge[0]][edge[1]] = edge[2]\\n\\t\\tgraph[edge[1]][edge[0]] = edge[2]\\n\\t}\\n\\n\\treturn graph\\n}\\n\\nfunc searchPath(graph map[int]map[int]int, source, destination int, visited map[int]bool) *Node {\\n\\th := &PriorityQueue{{nil, source, 0}}\\n\\theap.Init(h)\\n\\n\\tfor len(*h) != 0 {\\n\\t\\tcurr := heap.Pop(h).(Node)\\n\\t\\tif curr.key == destination {\\n\\t\\t\\treturn &curr\\n\\t\\t}\\n\\n\\t\\tfor pathK, cost := range graph[curr.key] {\\n\\t\\t\\tif visited[pathK] || cost == -1 {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\n\\t\\t\\theap.Push(h, Node{\\n\\t\\t\\t\\tparent: &curr,\\n\\t\\t\\t\\tkey:    pathK,\\n\\t\\t\\t\\tweight: curr.weight + cost,\\n\\t\\t\\t})\\n\\t\\t}\\n\\n\\t\\tvisited[curr.key] = true\\n\\t}\\n\\n\\treturn nil\\n}\\n\\nfunc fill(edges [][]int) [][]int {\\n\\tmax := int(2e9)\\n\\n\\tfor i := 0; i < len(edges); i++ {\\n\\t\\tif edges[i][2] != -1 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tedges[i][2] = max\\n\\t}\\n\\n\\treturn edges\\n}\\n\\nfunc modifiedGraphEdges(n int, edges [][]int, source int, destination int, target int) [][]int {\\n\\tgraph := makeGraph(edges)\\n\\n\\tpath := searchPath(graph, source, destination, make(map[int]bool))\\n\\tif path != nil {\\n\\t\\tif path.weight < target {\\n\\t\\t\\treturn nil\\n\\t\\t}\\n\\n\\t\\tif path.weight == target {\\n\\t\\t\\treturn fill(edges)\\n\\t\\t}\\n\\t}\\n\\n\\tfor i := 0; i < len(edges); i++ {\\n\\t\\tif edges[i][2] != -1 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tedges[i][2] = 1\\n\\t\\tgraph[edges[i][0]][edges[i][1]] = 1\\n\\t\\tgraph[edges[i][1]][edges[i][0]] = 1\\n\\n\\t\\tpath = searchPath(graph, source, destination, make(map[int]bool))\\n\\t\\tif path == nil || path.weight > target {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tedges[i][2] += target - path.weight\\n\\n\\t\\treturn fill(edges)\\n\\t}\\n\\n\\treturn nil\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype Node struct {\\n\\tparent *Node\\n\\tkey    int\\n\\tweight int\\n}\\n\\ntype PriorityQueue []Node\\n\\nfunc (p PriorityQueue) Len() int {\\n\\treturn len(p)\\n}\\n\\nfunc (p PriorityQueue) Less(i, j int) bool {\\n\\treturn p[i].weight < p[j].weight\\n}\\n\\nfunc (p PriorityQueue) Swap(i, j int) {\\n\\tp[i], p[j] = p[j], p[i]\\n}\\n\\nfunc (p *PriorityQueue) Push(x interface{}) {\\n\\t*p = append(*p, x.(Node))\\n}\\n\\nfunc (p *PriorityQueue) Pop() interface{} {\\n\\tcpy := *p\\n\\tx := cpy[len(cpy)-1]\\n\\t*p = cpy[:len(cpy)-1]\\n\\treturn x\\n}\\n\\nfunc makeGraph(edges [][]int) map[int]map[int]int {\\n\\tgraph := make(map[int]map[int]int)\\n\\n\\tfor _, edge := range edges {\\n\\t\\tif _, ok := graph[edge[0]]; !ok {\\n\\t\\t\\tgraph[edge[0]] = make(map[int]int)\\n\\t\\t}\\n\\n\\t\\tif _, ok := graph[edge[1]]; !ok {\\n\\t\\t\\tgraph[edge[1]] = make(map[int]int)\\n\\t\\t}\\n\\n\\t\\tgraph[edge[0]][edge[1]] = edge[2]\\n\\t\\tgraph[edge[1]][edge[0]] = edge[2]\\n\\t}\\n\\n\\treturn graph\\n}\\n\\nfunc searchPath(graph map[int]map[int]int, source, destination int, visited map[int]bool) *Node {\\n\\th := &PriorityQueue{{nil, source, 0}}\\n\\theap.Init(h)\\n\\n\\tfor len(*h) != 0 {\\n\\t\\tcurr := heap.Pop(h).(Node)\\n\\t\\tif curr.key == destination {\\n\\t\\t\\treturn &curr\\n\\t\\t}\\n\\n\\t\\tfor pathK, cost := range graph[curr.key] {\\n\\t\\t\\tif visited[pathK] || cost == -1 {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\n\\t\\t\\theap.Push(h, Node{\\n\\t\\t\\t\\tparent: &curr,\\n\\t\\t\\t\\tkey:    pathK,\\n\\t\\t\\t\\tweight: curr.weight + cost,\\n\\t\\t\\t})\\n\\t\\t}\\n\\n\\t\\tvisited[curr.key] = true\\n\\t}\\n\\n\\treturn nil\\n}\\n\\nfunc fill(edges [][]int) [][]int {\\n\\tmax := int(2e9)\\n\\n\\tfor i := 0; i < len(edges); i++ {\\n\\t\\tif edges[i][2] != -1 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tedges[i][2] = max\\n\\t}\\n\\n\\treturn edges\\n}\\n\\nfunc modifiedGraphEdges(n int, edges [][]int, source int, destination int, target int) [][]int {\\n\\tgraph := makeGraph(edges)\\n\\n\\tpath := searchPath(graph, source, destination, make(map[int]bool))\\n\\tif path != nil {\\n\\t\\tif path.weight < target {\\n\\t\\t\\treturn nil\\n\\t\\t}\\n\\n\\t\\tif path.weight == target {\\n\\t\\t\\treturn fill(edges)\\n\\t\\t}\\n\\t}\\n\\n\\tfor i := 0; i < len(edges); i++ {\\n\\t\\tif edges[i][2] != -1 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tedges[i][2] = 1\\n\\t\\tgraph[edges[i][0]][edges[i][1]] = 1\\n\\t\\tgraph[edges[i][1]][edges[i][0]] = 1\\n\\n\\t\\tpath = searchPath(graph, source, destination, make(map[int]bool))\\n\\t\\tif path == nil || path.weight > target {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tedges[i][2] += target - path.weight\\n\\n\\t\\treturn fill(edges)\\n\\t}\\n\\n\\treturn nil\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3565097,
                "title": "python-3-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def modifiedGraphEdges(self, n: int, edges: List[List[int]], source: int, destination: int, target: int) -> List[List[int]]:\\n        adj=[]\\n        h={}\\n        for i in range(n):\\n            adj+=[[]]\\n        for i in range(len(edges)):\\n            adj[edges[i][0]]+=[[edges[i][2],edges[i][1]]]\\n            h[str(edges[i][0])+\"_\"+str(edges[i][1])]=len(adj[edges[i][0]])-1\\n            adj[edges[i][1]]+=[[edges[i][2],edges[i][0]]]\\n            h[str(edges[i][1])+\"_\"+str(edges[i][0])]=len(adj[edges[i][1]])-1\\n        v1=[-1]*n\\n        pq,pq1=[],[]\\n        heapq.heapify(pq)\\n        heapq.heapify(pq1)\\n        ds=[float(\\'inf\\')]*n\\n        dd=[float(\\'inf\\')]*n\\n        heapq.heappush(pq,[0,source])\\n        heapq.heappush(pq1,[0,destination])\\n        ds[source]=0\\n        dd[destination]=0\\n        v1=[-1]*n\\n        v2=[-1]*n\\n        while pq!=[]:\\n            a=heapq.heappop(pq)\\n            if v1[a[1]]==1:\\n                continue\\n            v1[a[1]]=1\\n            for i in adj[a[1]]:\\n                if i[0]==-1 or ds[i[1]]<ds[a[1]]+i[0]:\\n                    continue\\n                ds[i[1]]=ds[a[1]]+i[0]\\n                heapq.heappush(pq,[ds[i[1]],i[1]])\\n        if ds[destination]<target:\\n            return []\\n        while pq1!=[]:\\n            a=heapq.heappop(pq1)\\n            if v2[a[1]]==1:\\n                continue\\n            v2[a[1]]=1\\n            for i in adj[a[1]]:\\n                if i[0]==-1 or dd[i[1]]<dd[a[1]]+i[0]:\\n                    continue\\n                dd[i[1]]=dd[a[1]]+i[0]\\n                heapq.heappush(pq1,[dd[i[1]],i[1]])\\n        t=target\\n        for i in range(len(edges)):\\n            if edges[i][2]==-1:\\n                d1=ds[edges[i][0]]\\n                d2=dd[edges[i][1]]\\n                if d1+d2<t:\\n                    edges[i][2]=t-(d1+d2)\\n                    ds[destination]=target\\n                    break\\n                d3=ds[edges[i][1]]\\n                d4=dd[edges[i][0]]\\n                if d3+d4<t:\\n                    edges[i][2]=t-(d3+d4)\\n                    ds[destination]=target\\n                    break\\n                edges[i][2]=1\\n                adj[edges[i][0]][h[str(edges[i][0])+\"_\"+str(edges[i][1])]][0]=1\\n                adj[edges[i][1]][h[str(edges[i][1])+\"_\"+str(edges[i][0])]][0]=1\\n                pq,pq1=[],[]\\n                heapq.heapify(pq)\\n                heapq.heapify(pq1)\\n                heapq.heappush(pq,[0,source])\\n                heapq.heappush(pq1,[0,destination])\\n                v1=[-1]*n\\n                v2=[-1]*n\\n                while pq!=[]:\\n                    a=heapq.heappop(pq)\\n                    if v1[a[1]]==1:\\n                        continue\\n                    v1[a[1]]=1\\n                    for i in adj[a[1]]:\\n                        if i[0]==-1 or ds[i[1]]<ds[a[1]]+i[0]:\\n                            continue\\n                        ds[i[1]]=ds[a[1]]+i[0]\\n                        heapq.heappush(pq,[ds[i[1]],i[1]])\\n                while pq1!=[]:\\n                    a=heapq.heappop(pq1)\\n                    if v2[a[1]]==1:\\n                        continue\\n                    v2[a[1]]=1\\n                    for i in adj[a[1]]:\\n                        if i[0]==-1 or dd[i[1]]<dd[a[1]]+i[0]:\\n                            continue\\n                        dd[i[1]]=dd[a[1]]+i[0]\\n                        heapq.heappush(pq1,[dd[i[1]],i[1]])\\n        if ds[destination]!=target:\\n            return []\\n        for i in range(len(edges)):\\n            if edges[i][2]==-1:\\n                edges[i][2]=t\\n        return edges\\n```",
                "solutionTags": [
                    "Python3",
                    "Graph",
                    "Heap (Priority Queue)",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution:\\n    def modifiedGraphEdges(self, n: int, edges: List[List[int]], source: int, destination: int, target: int) -> List[List[int]]:\\n        adj=[]\\n        h={}\\n        for i in range(n):\\n            adj+=[[]]\\n        for i in range(len(edges)):\\n            adj[edges[i][0]]+=[[edges[i][2],edges[i][1]]]\\n            h[str(edges[i][0])+\"_\"+str(edges[i][1])]=len(adj[edges[i][0]])-1\\n            adj[edges[i][1]]+=[[edges[i][2],edges[i][0]]]\\n            h[str(edges[i][1])+\"_\"+str(edges[i][0])]=len(adj[edges[i][1]])-1\\n        v1=[-1]*n\\n        pq,pq1=[],[]\\n        heapq.heapify(pq)\\n        heapq.heapify(pq1)\\n        ds=[float(\\'inf\\')]*n\\n        dd=[float(\\'inf\\')]*n\\n        heapq.heappush(pq,[0,source])\\n        heapq.heappush(pq1,[0,destination])\\n        ds[source]=0\\n        dd[destination]=0\\n        v1=[-1]*n\\n        v2=[-1]*n\\n        while pq!=[]:\\n            a=heapq.heappop(pq)\\n            if v1[a[1]]==1:\\n                continue\\n            v1[a[1]]=1\\n            for i in adj[a[1]]:\\n                if i[0]==-1 or ds[i[1]]<ds[a[1]]+i[0]:\\n                    continue\\n                ds[i[1]]=ds[a[1]]+i[0]\\n                heapq.heappush(pq,[ds[i[1]],i[1]])\\n        if ds[destination]<target:\\n            return []\\n        while pq1!=[]:\\n            a=heapq.heappop(pq1)\\n            if v2[a[1]]==1:\\n                continue\\n            v2[a[1]]=1\\n            for i in adj[a[1]]:\\n                if i[0]==-1 or dd[i[1]]<dd[a[1]]+i[0]:\\n                    continue\\n                dd[i[1]]=dd[a[1]]+i[0]\\n                heapq.heappush(pq1,[dd[i[1]],i[1]])\\n        t=target\\n        for i in range(len(edges)):\\n            if edges[i][2]==-1:\\n                d1=ds[edges[i][0]]\\n                d2=dd[edges[i][1]]\\n                if d1+d2<t:\\n                    edges[i][2]=t-(d1+d2)\\n                    ds[destination]=target\\n                    break\\n                d3=ds[edges[i][1]]\\n                d4=dd[edges[i][0]]\\n                if d3+d4<t:\\n                    edges[i][2]=t-(d3+d4)\\n                    ds[destination]=target\\n                    break\\n                edges[i][2]=1\\n                adj[edges[i][0]][h[str(edges[i][0])+\"_\"+str(edges[i][1])]][0]=1\\n                adj[edges[i][1]][h[str(edges[i][1])+\"_\"+str(edges[i][0])]][0]=1\\n                pq,pq1=[],[]\\n                heapq.heapify(pq)\\n                heapq.heapify(pq1)\\n                heapq.heappush(pq,[0,source])\\n                heapq.heappush(pq1,[0,destination])\\n                v1=[-1]*n\\n                v2=[-1]*n\\n                while pq!=[]:\\n                    a=heapq.heappop(pq)\\n                    if v1[a[1]]==1:\\n                        continue\\n                    v1[a[1]]=1\\n                    for i in adj[a[1]]:\\n                        if i[0]==-1 or ds[i[1]]<ds[a[1]]+i[0]:\\n                            continue\\n                        ds[i[1]]=ds[a[1]]+i[0]\\n                        heapq.heappush(pq,[ds[i[1]],i[1]])\\n                while pq1!=[]:\\n                    a=heapq.heappop(pq1)\\n                    if v2[a[1]]==1:\\n                        continue\\n                    v2[a[1]]=1\\n                    for i in adj[a[1]]:\\n                        if i[0]==-1 or dd[i[1]]<dd[a[1]]+i[0]:\\n                            continue\\n                        dd[i[1]]=dd[a[1]]+i[0]\\n                        heapq.heappush(pq1,[dd[i[1]],i[1]])\\n        if ds[destination]!=target:\\n            return []\\n        for i in range(len(edges)):\\n            if edges[i][2]==-1:\\n                edges[i][2]=t\\n        return edges\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3563283,
                "title": "c-dijkstra-s-algorithm",
                "content": "- Ignore all `-1` weight edges and run shortest path algorithm.\\n- If `dist[destination] < target` we can never achieve the target distance; return `{}`\\n- Next, add the `-1` weight edges one by one to the graph with weight `1` and run shortest path algorithm. \\n- If at some point, `dist[destination] <= target`, it means we can get to destination through this newly added `edge` with shorter distance. \\n    - Update/increment the current edge weight with `target - dist[destination]`\\n    - Assign all other `-1` edges as `INF`\\n\\n### Code\\n```\\nclass Solution {\\npublic:\\n    int n, start, end;\\n    long long dist[101];\\n    vector<pair<int,int>> adj[101]; // u -> {v, w}\\n\\n    // Dijkstra\\'s\\n    void dijkstra() {\\n        for (int i = 0; i < n; i++) dist[i] = 1e9;\\n        dist[start] = 0;\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> q; \\n        q.push({0, start});\\n        while (q.size()) {\\n            auto [d, u] = q.top(); q.pop();\\n            if (u == end) return;\\n            for (auto& [v, w] : adj[u]) {\\n                if (dist[v] > d + w) {\\n                    dist[v] = d + w;\\n                    q.push({dist[v], v});\\n                }\\n            }\\n        }\\n    }\\n \\n    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int source, int destination, int target) { \\n        this->n = n; start = source; end = destination;\\n\\n        for (auto &e : edges) {\\n            if (e[2] == -1) continue;\\n\\t\\t    adj[e[0]].push_back({e[1], e[2]});\\n\\t\\t    adj[e[1]].push_back({e[0], e[2]});\\n        }\\n\\n        dijkstra();\\n\\n        if (dist[end] < target) {\\n            return {};\\n        }\\n\\n        if (dist[end] == target) {\\n            for (auto &e : edges) {\\n                if (e[2] < 0) e[2] = 1e9;\\n            }\\n            return edges;\\n        } \\n\\n        // Add the {-1} weight edges to the graph one by one;\\n        for (auto &e : edges) {\\n            if (e[2] < 0) {\\n                e[2] = 1;\\n                adj[e[0]].push_back({e[1], 1});\\n\\t\\t        adj[e[1]].push_back({e[0], 1});\\n                dijkstra(); \\n                if (dist[end] <= target) {\\n                    e[2] += (target - dist[end]); \\n                    for (auto &edge : edges) {\\n                        if (edge[2] < 0) edge[2] = 1e9;\\n                    }\\n                    return edges; \\n                }\\n            }\\n        }\\n\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n, start, end;\\n    long long dist[101];\\n    vector<pair<int,int>> adj[101]; // u -> {v, w}\\n\\n    // Dijkstra\\'s\\n    void dijkstra() {\\n        for (int i = 0; i < n; i++) dist[i] = 1e9;\\n        dist[start] = 0;\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> q; \\n        q.push({0, start});\\n        while (q.size()) {\\n            auto [d, u] = q.top(); q.pop();\\n            if (u == end) return;\\n            for (auto& [v, w] : adj[u]) {\\n                if (dist[v] > d + w) {\\n                    dist[v] = d + w;\\n                    q.push({dist[v], v});\\n                }\\n            }\\n        }\\n    }\\n \\n    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int source, int destination, int target) { \\n        this->n = n; start = source; end = destination;\\n\\n        for (auto &e : edges) {\\n            if (e[2] == -1) continue;\\n\\t\\t    adj[e[0]].push_back({e[1], e[2]});\\n\\t\\t    adj[e[1]].push_back({e[0], e[2]});\\n        }\\n\\n        dijkstra();\\n\\n        if (dist[end] < target) {\\n            return {};\\n        }\\n\\n        if (dist[end] == target) {\\n            for (auto &e : edges) {\\n                if (e[2] < 0) e[2] = 1e9;\\n            }\\n            return edges;\\n        } \\n\\n        // Add the {-1} weight edges to the graph one by one;\\n        for (auto &e : edges) {\\n            if (e[2] < 0) {\\n                e[2] = 1;\\n                adj[e[0]].push_back({e[1], 1});\\n\\t\\t        adj[e[1]].push_back({e[0], 1});\\n                dijkstra(); \\n                if (dist[end] <= target) {\\n                    e[2] += (target - dist[end]); \\n                    for (auto &edge : edges) {\\n                        if (edge[2] < 0) edge[2] = 1e9;\\n                    }\\n                    return edges; \\n                }\\n            }\\n        }\\n\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3557358,
                "title": "golang",
                "content": "# Code\\n```\\nfunc modifiedGraphEdges(n int, edges [][]int, source int, destination int, target int) [][]int {\\n    adjList := make([][]int, n)\\n    for i := range adjList {\\n        adjList[i] = make([]int, n)\\n    }\\n    for _, edge := range edges {\\n        a, b, w := edge[0], edge[1], edge[2]\\n        if w == -1 {\\n            continue\\n        }\\n        adjList[a][b] = w\\n        adjList[b][a] = w\\n    }\\n\\n    distance := find(adjList, n, source, destination)\\n    if distance[destination] < target {\\n        return [][]int{}\\n    }\\n    \\n    if distance[destination] == target {\\n        for _, edge := range edges {\\n            if edge[2] == -1 {\\n                edge[2] = 2e9\\n            }\\n        }\\n        return edges\\n    }\\n\\n    for i, edge := range edges {\\n        u, v, w := edge[0], edge[1], edge[2]\\n        if w == -1 {\\n            edges[i][2] = 1\\n            adjList[u][v] = 1\\n            adjList[v][u] = 1\\n            distance = find(adjList, n, source, destination)\\n            if distance[destination] <= target {\\n                edges[i][2] += (target-distance[destination])\\n                for j := i+1; j < len(edges); j++ {\\n                    if edges[j][2] == -1 {\\n                        edges[j][2] = 2e9\\n                    }\\n                }\\n                return edges\\n            }\\n        }\\n    }\\n    return [][]int{}\\n}\\n\\nfunc find(adjList [][]int, n int, src int, dst int) []int {\\n    distance := make([]int, n)\\n    for i := range distance {\\n        if i == src {\\n            continue\\n        }\\n        distance[i] = math.MaxInt32\\n    }\\n    pq := PriorityQueue{{src, 0}}\\n\\theap.Init(&pq)\\n    visited := make([]bool, n)\\n    for pq.Len() > 0 {\\n        state := heap.Pop(&pq).(*State)\\n        if visited[state.node] {\\n            continue\\n        }\\n        \\n        visited[state.node] = true\\n        for child, cost := range adjList[state.node] {\\n            if cost == 0 {\\n                continue\\n            }\\n            if distance[child] > state.cost + cost {\\n                distance[child] = state.cost + cost\\n                heap.Push(&pq, &State{child, distance[child]})\\n            }\\n        }\\n    }\\n    return distance\\n}\\n\\ntype State struct {\\n\\tnode int\\n    cost int\\n}\\n\\ntype PriorityQueue []*State\\n\\nfunc (pq PriorityQueue) Len() int { return len(pq) }\\nfunc (pq PriorityQueue) Less(i, j int) bool { return pq[i].cost < pq[j].cost }\\nfunc (pq PriorityQueue) Swap(i, j int) { pq[i], pq[j] = pq[j], pq[i] }\\nfunc (pq *PriorityQueue) Push(x interface{}) {\\n\\tstate := x.(*State)\\n\\t*pq = append(*pq, state)\\n}\\nfunc (pq *PriorityQueue) Pop() interface{} {\\n\\told := *pq\\n\\tn := len(old)\\n\\tstate := old[n-1]\\n\\t*pq = old[0 : n-1]\\n\\treturn state\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc modifiedGraphEdges(n int, edges [][]int, source int, destination int, target int) [][]int {\\n    adjList := make([][]int, n)\\n    for i := range adjList {\\n        adjList[i] = make([]int, n)\\n    }\\n    for _, edge := range edges {\\n        a, b, w := edge[0], edge[1], edge[2]\\n        if w == -1 {\\n            continue\\n        }\\n        adjList[a][b] = w\\n        adjList[b][a] = w\\n    }\\n\\n    distance := find(adjList, n, source, destination)\\n    if distance[destination] < target {\\n        return [][]int{}\\n    }\\n    \\n    if distance[destination] == target {\\n        for _, edge := range edges {\\n            if edge[2] == -1 {\\n                edge[2] = 2e9\\n            }\\n        }\\n        return edges\\n    }\\n\\n    for i, edge := range edges {\\n        u, v, w := edge[0], edge[1], edge[2]\\n        if w == -1 {\\n            edges[i][2] = 1\\n            adjList[u][v] = 1\\n            adjList[v][u] = 1\\n            distance = find(adjList, n, source, destination)\\n            if distance[destination] <= target {\\n                edges[i][2] += (target-distance[destination])\\n                for j := i+1; j < len(edges); j++ {\\n                    if edges[j][2] == -1 {\\n                        edges[j][2] = 2e9\\n                    }\\n                }\\n                return edges\\n            }\\n        }\\n    }\\n    return [][]int{}\\n}\\n\\nfunc find(adjList [][]int, n int, src int, dst int) []int {\\n    distance := make([]int, n)\\n    for i := range distance {\\n        if i == src {\\n            continue\\n        }\\n        distance[i] = math.MaxInt32\\n    }\\n    pq := PriorityQueue{{src, 0}}\\n\\theap.Init(&pq)\\n    visited := make([]bool, n)\\n    for pq.Len() > 0 {\\n        state := heap.Pop(&pq).(*State)\\n        if visited[state.node] {\\n            continue\\n        }\\n        \\n        visited[state.node] = true\\n        for child, cost := range adjList[state.node] {\\n            if cost == 0 {\\n                continue\\n            }\\n            if distance[child] > state.cost + cost {\\n                distance[child] = state.cost + cost\\n                heap.Push(&pq, &State{child, distance[child]})\\n            }\\n        }\\n    }\\n    return distance\\n}\\n\\ntype State struct {\\n\\tnode int\\n    cost int\\n}\\n\\ntype PriorityQueue []*State\\n\\nfunc (pq PriorityQueue) Len() int { return len(pq) }\\nfunc (pq PriorityQueue) Less(i, j int) bool { return pq[i].cost < pq[j].cost }\\nfunc (pq PriorityQueue) Swap(i, j int) { pq[i], pq[j] = pq[j], pq[i] }\\nfunc (pq *PriorityQueue) Push(x interface{}) {\\n\\tstate := x.(*State)\\n\\t*pq = append(*pq, state)\\n}\\nfunc (pq *PriorityQueue) Pop() interface{} {\\n\\told := *pq\\n\\tn := len(old)\\n\\tstate := old[n-1]\\n\\t*pq = old[0 : n-1]\\n\\treturn state\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3555483,
                "title": "hindi-python-dijkstra-are-bhai-kya-khatrnaak-question-he",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy thoughts\\n1. Iss problem me mujhe baar baar dijkstra lagake shortest distance ka array banana padega. (TC: V^2, priority queue ke bina kroonga)\\n2. starting me adjacency list banathe he, lekin -1 waale weights nhi add kroonga adjacency list me.\\n3. Jab bhi edges return kroonga tab me negative weights ko largest possible weight se replace krna padega. large = 2*10^9\\n3. fir aage ka dekte he...code likhte likhte smj ajayega\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. adjacency list banao without negative weights.\\n2. fir apply dijkstra. (-_- nhi ata dijkstra? dijkstra ka simple function banaya he deklo)\\n3. distance ka array miljayega after step 2.\\n4. ab dekho ki kya shortest distance koi he jo target se kum he, agr he tho empty array return krdo. (Socho Why?) (edge case)\\n5. Ab dekho koi shortest distance target ke barabr he? Agr he tho jo bache kuche negative weights he usme 2*10^9 lagake edges ko return krdo. (edge case)\\n\\nuper se agr kaam nhi chl matlb ab hume negative edges ko bhi adjaceny list me add krke raastha nikalna padega.\\n\\n6. ab ek ek krke negative weights pe traverse krke unko weight 1 assign krdo fir dijkstra lagao. Fir dekho koi distance target ke barabr aya?\\n7. agr nhi hua tho firse next negative weight ko 1 assign kro, aur fir dijkstra lagao. Fir dekho koi distance target ke paas aya?\\n8. agr koi aaspaas aya he tho uska weight ko target se match krne ki koshish kro.\\n9. Fir edges me iterate krke negative weights remove krdo.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import deque\\n\\nclass Solution:\\n    # Create adjacency list without the negative weights\\n    def createAdjacenyList(self, n, edges):\\n        adjacencyList = [[] for i in range(n)]\\n        for u,v,w in edges:\\n            if w!=-1:\\n                adjacencyList[u].append([v,w])\\n                adjacencyList[v].append([u,w])\\n        return adjacencyList\\n\\n    def modifiedGraphEdges(self, n: int, edges: List[List[int]], src: int, dest: int, target: int) -> List[List[int]]:\\n        INF = float(\"inf\")\\n        large = 2*10**9\\n        # 1. adjacency list banao without negative weights.\\n        adjList = self.createAdjacenyList(n, edges)\\n\\n        def dijkstra():\\n            dist = [INF for _ in range(n)]\\n            dist[src] = 0 # Setting source to be zero\\n            q = deque()\\n            q.append(src)\\n            while len(q)> 0:\\n                u = q.popleft()\\n                for v,w in adjList[u]:\\n                    if dist[v] > dist[u] + w:\\n                        dist[v] = dist[u] + w\\n                        q.append(v)\\n            return dist\\n        \\n        # 2. fir apply dijkstra.\\n        dist = dijkstra()\\n        \\n        # 4. ab dekho ki kya shortest distance koi he jo \\n        # target se kum he, agr he tho empty array return krdo.  \\n        if dist[dest] < target:\\n            return []\\n\\n        # 5. Ab dekho koi shortest distance target ke barabr he? \\n        #Agr he tho jo bache kuche negative weights he usme 2*10^9       \\n        #lagake edges ko return krdo.\\n        if dist[dest] == target:\\n            for i in range(len(edges)):\\n                if edges[i][2] == -1:\\n                    edges[i][2] = large\\n            return edges\\n\\n\\n        #6. ab ek ek krke negative weights pe traverse krke unko \\n        #weight 1 assign krdo fir dijkstra lagao. Fir dekho koi distance \\n        #target ke barabr aya?\\n        for i in range(len(edges)):\\n            u, v, w = edges[i]\\n            if w == -1:\\n                edges[i][2] = 1\\n                adjList[u].append([v,1])\\n                adjList[v].append([u,1])\\n\\n                dist = dijkstra()\\n\\n                #8. agr koi aaspaas aya he tho uska weight ko target\\n                # se match krne ki koshish kro.\\n                # 9. Fir edges me iterate krke negative weights remove krdo.\\n                if dist[dest] <= target:\\n                    edges[i][2] += target - dist[dest]\\n                    for i in range(len(edges)):\\n                        if edges[i][2] == -1:\\n                            edges[i][2] = large\\n                    return edges\\n\\n        return []\\n                     \\n\\n\\n\\n            \\n\\n            \\n\\n\\n        \\n\\n        return []\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    # Create adjacency list without the negative weights\\n    def createAdjacenyList(self, n, edges):\\n        adjacencyList = [[] for i in range(n)]\\n        for u,v,w in edges:\\n            if w!=-1:\\n                adjacencyList[u].append([v,w])\\n                adjacencyList[v].append([u,w])\\n        return adjacencyList\\n\\n    def modifiedGraphEdges(self, n: int, edges: List[List[int]], src: int, dest: int, target: int) -> List[List[int]]:\\n        INF = float(\"inf\")\\n        large = 2*10**9\\n        # 1. adjacency list banao without negative weights.\\n        adjList = self.createAdjacenyList(n, edges)\\n\\n        def dijkstra():\\n            dist = [INF for _ in range(n)]\\n            dist[src] = 0 # Setting source to be zero\\n            q = deque()\\n            q.append(src)\\n            while len(q)> 0:\\n                u = q.popleft()\\n                for v,w in adjList[u]:\\n                    if dist[v] > dist[u] + w:\\n                        dist[v] = dist[u] + w\\n                        q.append(v)\\n            return dist\\n        \\n        # 2. fir apply dijkstra.\\n        dist = dijkstra()\\n        \\n        # 4. ab dekho ki kya shortest distance koi he jo \\n        # target se kum he, agr he tho empty array return krdo.  \\n        if dist[dest] < target:\\n            return []\\n\\n        # 5. Ab dekho koi shortest distance target ke barabr he? \\n        #Agr he tho jo bache kuche negative weights he usme 2*10^9       \\n        #lagake edges ko return krdo.\\n        if dist[dest] == target:\\n            for i in range(len(edges)):\\n                if edges[i][2] == -1:\\n                    edges[i][2] = large\\n            return edges\\n\\n\\n        #6. ab ek ek krke negative weights pe traverse krke unko \\n        #weight 1 assign krdo fir dijkstra lagao. Fir dekho koi distance \\n        #target ke barabr aya?\\n        for i in range(len(edges)):\\n            u, v, w = edges[i]\\n            if w == -1:\\n                edges[i][2] = 1\\n                adjList[u].append([v,1])\\n                adjList[v].append([u,1])\\n\\n                dist = dijkstra()\\n\\n                #8. agr koi aaspaas aya he tho uska weight ko target\\n                # se match krne ki koshish kro.\\n                # 9. Fir edges me iterate krke negative weights remove krdo.\\n                if dist[dest] <= target:\\n                    edges[i][2] += target - dist[dest]\\n                    for i in range(len(edges)):\\n                        if edges[i][2] == -1:\\n                            edges[i][2] = large\\n                    return edges\\n\\n        return []\\n                     \\n\\n\\n\\n            \\n\\n            \\n\\n\\n        \\n\\n        return []\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3554788,
                "title": "c-floyd-warshall",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define maxdis (1LL << 60)\\n    #define maxd (2LL * 1000000000)\\n    struct edge {\\n        int idx, a, b;\\n        long long d;\\n    };\\n    int s, e, edge_sz;\\n    long long D[100][100];\\n    edge list[10000];\\n    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int source, int destination, int target) {\\n        // initial\\n        s = source, e = destination, edge_sz = 0;\\n        int i, j, k;\\n        for (i = 0; i < n; ++i) for (j = 0; j < n; ++j) if(i!=j) D[i][j] = maxdis;\\n        i = 0;\\n        for (vector<int> &cur : edges) {\\n            if(cur[2] == -1)  {\\n                list[edge_sz++] = {i, cur[0], cur[1], maxd};\\n                cur[2]= maxd;\\n                D[cur[0]][cur[1]] = maxd;\\n                D[cur[1]][cur[0]] = maxd;\\n            }\\n            else {\\n                D[cur[0]][cur[1]] = cur[2];\\n                D[cur[1]][cur[0]] = cur[2];\\n            }\\n            ++i;            \\n        }\\n        \\n\\n        // initial distance\\n        for (k = 0; k < n; ++k) {\\n            for (i = 0; i < n; ++i) {\\n                if(k == i || D[i][k] == maxdis) continue;\\n                for (j = i + 1; j < n; ++j) {\\n                    if(D[k][j] == maxdis) continue;\\n                    if(D[i][j] > D[i][k] + D[k][j]) {\\n                        D[i][j] = D[i][k] + D[k][j];\\n                        D[j][i] = D[i][j];\\n                    } \\n                }\\n            }\\n        }\\n        if(D[s][e] < target) return vector<vector<int>>();        \\n        \\n        // change values and get a new distance\\n        long long diff;\\n        int a, b;\\n        for (edge &cur : list) {\\n            if(D[s][e] == target) break;\\n            a = cur.a, b = cur.b;\\n            diff = D[s][a] + D[b][e] + cur.d;\\n            if(diff > D[s][b] + D[a][e] + cur.d) diff = D[s][b] + D[a][e] + cur.d;                 \\n            cur.d -= diff - target;\\n            if(cur.d <= 0) cur.d = 1;\\n            edges[cur.idx][2] = cur.d;\\n            \\n            for (i = 0; i < n; ++i) {\\n                for (j = i + 1; j < n; ++j) {\\n                    if(D[i][j] > D[i][a] + D[b][j] + cur.d) {\\n                        D[i][j] = D[i][a] + D[b][j] + cur.d;\\n                        D[j][i] = D[i][j];\\n                    } \\n                    else if(D[i][j] > D[i][b] + D[a][j] + cur.d) {\\n                        D[i][j] = D[i][b] + D[a][j] + cur.d;\\n                        D[j][i] = D[i][j];\\n                    }\\n                }\\n            }\\n        }\\n\\n        if(D[s][e] != target) return vector<vector<int>>();\\n        return edges;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define maxdis (1LL << 60)\\n    #define maxd (2LL * 1000000000)\\n    struct edge {\\n        int idx, a, b;\\n        long long d;\\n    };\\n    int s, e, edge_sz;\\n    long long D[100][100];\\n    edge list[10000];\\n    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int source, int destination, int target) {\\n        // initial\\n        s = source, e = destination, edge_sz = 0;\\n        int i, j, k;\\n        for (i = 0; i < n; ++i) for (j = 0; j < n; ++j) if(i!=j) D[i][j] = maxdis;\\n        i = 0;\\n        for (vector<int> &cur : edges) {\\n            if(cur[2] == -1)  {\\n                list[edge_sz++] = {i, cur[0], cur[1], maxd};\\n                cur[2]= maxd;\\n                D[cur[0]][cur[1]] = maxd;\\n                D[cur[1]][cur[0]] = maxd;\\n            }\\n            else {\\n                D[cur[0]][cur[1]] = cur[2];\\n                D[cur[1]][cur[0]] = cur[2];\\n            }\\n            ++i;            \\n        }\\n        \\n\\n        // initial distance\\n        for (k = 0; k < n; ++k) {\\n            for (i = 0; i < n; ++i) {\\n                if(k == i || D[i][k] == maxdis) continue;\\n                for (j = i + 1; j < n; ++j) {\\n                    if(D[k][j] == maxdis) continue;\\n                    if(D[i][j] > D[i][k] + D[k][j]) {\\n                        D[i][j] = D[i][k] + D[k][j];\\n                        D[j][i] = D[i][j];\\n                    } \\n                }\\n            }\\n        }\\n        if(D[s][e] < target) return vector<vector<int>>();        \\n        \\n        // change values and get a new distance\\n        long long diff;\\n        int a, b;\\n        for (edge &cur : list) {\\n            if(D[s][e] == target) break;\\n            a = cur.a, b = cur.b;\\n            diff = D[s][a] + D[b][e] + cur.d;\\n            if(diff > D[s][b] + D[a][e] + cur.d) diff = D[s][b] + D[a][e] + cur.d;                 \\n            cur.d -= diff - target;\\n            if(cur.d <= 0) cur.d = 1;\\n            edges[cur.idx][2] = cur.d;\\n            \\n            for (i = 0; i < n; ++i) {\\n                for (j = i + 1; j < n; ++j) {\\n                    if(D[i][j] > D[i][a] + D[b][j] + cur.d) {\\n                        D[i][j] = D[i][a] + D[b][j] + cur.d;\\n                        D[j][i] = D[i][j];\\n                    } \\n                    else if(D[i][j] > D[i][b] + D[a][j] + cur.d) {\\n                        D[i][j] = D[i][b] + D[a][j] + cur.d;\\n                        D[j][i] = D[i][j];\\n                    }\\n                }\\n            }\\n        }\\n\\n        if(D[s][e] != target) return vector<vector<int>>();\\n        return edges;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3554413,
                "title": "modify-graph-edge-weights-simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\norder of negetive edge in consideration not matter \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ninitially don\\'t add any negetive edge\\nif shortest path is less than target return empty array(not possible ans)\\nif cur shortest path is equal to target then replace all negetive edges with some large value\\nelse \\nrepeat above steps by ading a negetive edge with weght 1 if shortst path is less than target update weght with remaining target-pathcost\\nreplace other edges weights with large value (1*10^9);\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n(n^2)\\n\\n\\n# Code\\n\\n```\\nclass Solution {\\n    \\n    class Edge{\\n        int s;\\n        int d;\\n        int wt;\\n        Edge(int s, int d, int wt){\\n            this.s = s;\\n            this.d = d;\\n            this.wt = wt;\\n        }\\n    }\\n    \\n    ArrayList<Edge>[] g;\\n    int n;\\n    int t;\\n    \\n    public int[][] modifiedGraphEdges(int n, int[][] edges, int source, int destination, int target) {\\n        \\n        this.n = n;\\n        this.g = new ArrayList[n];\\n        this.t = target;\\n        \\n        for(int i =0;i<n;i++){\\n            g[i]=new ArrayList<>();\\n            \\n        }\\n        \\n        for(int[] e : edges){\\n            \\n            int s = e[0];\\n            int d = e[1];\\n            int wt = e[2];\\n            if(wt==-1)continue;\\n            g[s].add(new Edge(s,d,wt));\\n            g[d].add(new Edge(d,s,wt));\\n            \\n        }\\n        \\n        int inc = shortestPath(source,destination);\\n        \\n        // System.out.println(inc+\" befor negetive edges\");\\n        if(inc!=-1 && inc<target)return new int[0][0];\\n        if(inc==target){\\n            ntomax(edges);\\n            return edges;\\n        }\\n        \\n        for(int[] e : edges){\\n            \\n            if(e[2]==-1){\\n                \\n                e[2]=1;\\n                \\n                int s = e[0];\\n                int d = e[1];\\n                int wt = e[2];\\n\\n                g[s].add(new Edge(s,d,wt));\\n                g[d].add(new Edge(d,s,wt));\\n                \\n                int cost = shortestPath(source,destination);\\n                if(cost==-1)continue;\\n                if(cost<target){\\n                    e[2]=target-cost+1;\\n                    ntomax(edges);\\n                    return edges;\\n                    \\n                }\\n                if(cost==target){\\n                    ntomax(edges);\\n                    return edges;\\n                }\\n                \\n                \\n                \\n                \\n                \\n                \\n            }\\n        }\\n        \\n        \\n        \\n        \\n    System.out.println(inc);\\n        \\n        return new int[0][0];\\n        \\n        \\n        \\n        \\n        \\n    }\\n    \\n    \\n    public void ntomax(int[][] edges){\\n        \\n        for(int[] e: edges){\\n            if(e[2]==-1){\\n                e[2]=1000000000;\\n            }\\n        }\\n        \\n    }\\n    \\n    class Pair implements Comparable<Pair>{\\n        int s;\\n        int cost;\\n        \\n        Pair(int s,int cost){\\n            this.s = s;\\n            this.cost = cost;\\n        \\n        }\\n        public int compareTo(Pair o){\\n            return this.cost-o.cost;\\n        }\\n    }\\n    \\n    public int shortestPath(int s,int d){\\n        \\n        PriorityQueue<Pair> q = new PriorityQueue<>();\\n        q.add(new Pair(s,0));\\n        \\n        boolean[] vis = new boolean[this.n];\\n        \\n        while(q.size()>0){\\n            \\n            Pair rem = q.remove();\\n            \\n            vis[rem.s]=true;\\n            \\n            if(rem.s==d)return rem.cost;\\n            \\n            for(Edge e: g[rem.s]){\\n                if(vis[e.d]==false){\\n                    q.add(new Pair(e.d,rem.cost+e.wt));\\n                }\\n            }\\n            \\n            \\n        }\\n        \\n        return -1;\\n    \\n        \\n        \\n    }\\n    \\n    \\n}\\n\\n\\n```\\n# Upvote if you like the solution",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    class Edge{\\n        int s;\\n        int d;\\n        int wt;\\n        Edge(int s, int d, int wt){\\n            this.s = s;\\n            this.d = d;\\n            this.wt = wt;\\n        }\\n    }\\n    \\n    ArrayList<Edge>[] g;\\n    int n;\\n    int t;\\n    \\n    public int[][] modifiedGraphEdges(int n, int[][] edges, int source, int destination, int target) {\\n        \\n        this.n = n;\\n        this.g = new ArrayList[n];\\n        this.t = target;\\n        \\n        for(int i =0;i<n;i++){\\n            g[i]=new ArrayList<>();\\n            \\n        }\\n        \\n        for(int[] e : edges){\\n            \\n            int s = e[0];\\n            int d = e[1];\\n            int wt = e[2];\\n            if(wt==-1)continue;\\n            g[s].add(new Edge(s,d,wt));\\n            g[d].add(new Edge(d,s,wt));\\n            \\n        }\\n        \\n        int inc = shortestPath(source,destination);\\n        \\n        // System.out.println(inc+\" befor negetive edges\");\\n        if(inc!=-1 && inc<target)return new int[0][0];\\n        if(inc==target){\\n            ntomax(edges);\\n            return edges;\\n        }\\n        \\n        for(int[] e : edges){\\n            \\n            if(e[2]==-1){\\n                \\n                e[2]=1;\\n                \\n                int s = e[0];\\n                int d = e[1];\\n                int wt = e[2];\\n\\n                g[s].add(new Edge(s,d,wt));\\n                g[d].add(new Edge(d,s,wt));\\n                \\n                int cost = shortestPath(source,destination);\\n                if(cost==-1)continue;\\n                if(cost<target){\\n                    e[2]=target-cost+1;\\n                    ntomax(edges);\\n                    return edges;\\n                    \\n                }\\n                if(cost==target){\\n                    ntomax(edges);\\n                    return edges;\\n                }\\n                \\n                \\n                \\n                \\n                \\n                \\n            }\\n        }\\n        \\n        \\n        \\n        \\n    System.out.println(inc);\\n        \\n        return new int[0][0];\\n        \\n        \\n        \\n        \\n        \\n    }\\n    \\n    \\n    public void ntomax(int[][] edges){\\n        \\n        for(int[] e: edges){\\n            if(e[2]==-1){\\n                e[2]=1000000000;\\n            }\\n        }\\n        \\n    }\\n    \\n    class Pair implements Comparable<Pair>{\\n        int s;\\n        int cost;\\n        \\n        Pair(int s,int cost){\\n            this.s = s;\\n            this.cost = cost;\\n        \\n        }\\n        public int compareTo(Pair o){\\n            return this.cost-o.cost;\\n        }\\n    }\\n    \\n    public int shortestPath(int s,int d){\\n        \\n        PriorityQueue<Pair> q = new PriorityQueue<>();\\n        q.add(new Pair(s,0));\\n        \\n        boolean[] vis = new boolean[this.n];\\n        \\n        while(q.size()>0){\\n            \\n            Pair rem = q.remove();\\n            \\n            vis[rem.s]=true;\\n            \\n            if(rem.s==d)return rem.cost;\\n            \\n            for(Edge e: g[rem.s]){\\n                if(vis[e.d]==false){\\n                    q.add(new Pair(e.d,rem.cost+e.wt));\\n                }\\n            }\\n            \\n            \\n        }\\n        \\n        return -1;\\n    \\n        \\n        \\n    }\\n    \\n    \\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553879,
                "title": "c-repeated-dijkstra-is-the-hint-solution-a-correct-one",
                "content": "The top solution (https://leetcode.com/problems/modify-graph-edge-weights/discuss/3546759/Python3-Dijkstra) seems to break at this test case provided by @lukewu28:\\nhttps://leetcode.com/problems/modify-graph-edge-weights/discuss/3546759/Python3-Dijkstra/1901666\\n\\nAnd it misses some edge cases as pointed out by @redsmolder:\\nhttps://leetcode.com/problems/modify-graph-edge-weights/discuss/3546759/Python3-Dijkstra/1900975\\n\\nMy solution seems to pass this case but it is not as fast as the top most voted one so I am not sure if the expected faster solution is fully correct or not\\n\\nThis solution repeatedly tests whether the shortest distance is not target and is guaranteed to terminate because we know at the start that such a solution is possible\\n\\n```\\nclass Solution {\\n  public:\\n  vector<vector<int>> myEdges;\\n  vector<vector<pair<int, int>>> tree;\\n  vector<unordered_map<int, int>> shortest;\\n  vector<unordered_map<int, pair<int, int>>> prev;\\n  vector<bool> minusOne;\\n  \\n  int findShortest(int src, int dst, bool ignoreMinusOne = false) {\\n    int n = tree.size();\\n    vector<bool> visited(n, false);\\n    priority_queue<tuple<int, int, int, int>> pq;\\n    pq.push({0, src, -1, -1});\\n    visited[src] = true;\\n    while (!pq.empty()) {\\n      auto [dist, nodeIdx, prevNodeIdx, prevEdgeIdx] = pq.top(); pq.pop();\\n      dist *= -1;\\n      if (!visited[nodeIdx]) {\\n        if (myEdges[prevEdgeIdx][0] == nodeIdx) {\\n          swap(myEdges[prevEdgeIdx][0], myEdges[prevEdgeIdx][1]);\\n        }\\n        prev[nodeIdx][src] = {prevNodeIdx, prevEdgeIdx};\\n        shortest[nodeIdx][src] = dist;\\n      }\\n      visited[nodeIdx] = true;\\n      if (nodeIdx == dst) {\\n        return dist;\\n      }\\n      for (auto& child : tree[nodeIdx]) {\\n        if (visited[child.first]) continue;\\n        if (minusOne[child.second] && ignoreMinusOne) continue;\\n        int d = dist + myEdges[child.second][2];\\n        pq.push({-d, child.first, nodeIdx, child.second});\\n      }\\n    }\\n    return -1;\\n  }\\n  \\n  vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int src, int dst, int target) {\\n    tree.resize(n);\\n    shortest.resize(n);\\n    prev.resize(n);\\n    myEdges = move(edges);\\n    minusOne = vector<bool>(myEdges.size(), false);\\n    for (int i = 0; i < myEdges.size(); ++i) {\\n      auto& e = myEdges[i];\\n      tree[e[0]].push_back({e[1], i});\\n      tree[e[1]].push_back({e[0], i});\\n      if (e[2] == -1) {\\n        myEdges[i][2] = 1;\\n        minusOne[i] = true;\\n      }\\n    }\\n\\n    int shortestDistanceNoMinusOnes = findShortest(src, dst, true);\\n    if (shortestDistanceNoMinusOnes != -1 && shortestDistanceNoMinusOnes < target) {\\n      return {};\\n    }\\n    int shortestDistanceDstToSrc = findShortest(dst, src);\\n    if (shortestDistanceDstToSrc > target) {\\n      return {};\\n    }\\n    int shortestDistanceSrcToDst = findShortest(src, dst);\\n    if (shortestDistanceSrcToDst > target) {\\n      return {};\\n    }\\n\\n    int shortestDist = shortestDistanceSrcToDst;\\n    while (shortestDist < target) {\\n      int nd = dst;\\n      bool found = false;\\n      unordered_set<int> include;\\n      while (true) {\\n        if (nd == src) break;\\n        auto [prevNd, edgeIdx] = prev[nd][src];\\n        if (minusOne[edgeIdx]) {\\n          include.insert(edgeIdx);\\n          if (!found) {\\n            int fromSrc = shortest[myEdges[edgeIdx][0]][src];\\n            int toDst = shortest[myEdges[edgeIdx][1]][dst];\\n            myEdges[edgeIdx][2] = target - (fromSrc + toDst);\\n            found = true;\\n          }\\n        }\\n        nd = prevNd;\\n      }\\n      for (int i = 0; i < myEdges.size(); ++i) {\\n        if (minusOne[i] && !include.count(i)) {\\n          myEdges[i][2] = target + 10;\\n        }\\n      }\\n      findShortest(dst, src);\\n      shortestDist = findShortest(src, dst);\\n    }\\n    return myEdges;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  public:\\n  vector<vector<int>> myEdges;\\n  vector<vector<pair<int, int>>> tree;\\n  vector<unordered_map<int, int>> shortest;\\n  vector<unordered_map<int, pair<int, int>>> prev;\\n  vector<bool> minusOne;\\n  \\n  int findShortest(int src, int dst, bool ignoreMinusOne = false) {\\n    int n = tree.size();\\n    vector<bool> visited(n, false);\\n    priority_queue<tuple<int, int, int, int>> pq;\\n    pq.push({0, src, -1, -1});\\n    visited[src] = true;\\n    while (!pq.empty()) {\\n      auto [dist, nodeIdx, prevNodeIdx, prevEdgeIdx] = pq.top(); pq.pop();\\n      dist *= -1;\\n      if (!visited[nodeIdx]) {\\n        if (myEdges[prevEdgeIdx][0] == nodeIdx) {\\n          swap(myEdges[prevEdgeIdx][0], myEdges[prevEdgeIdx][1]);\\n        }\\n        prev[nodeIdx][src] = {prevNodeIdx, prevEdgeIdx};\\n        shortest[nodeIdx][src] = dist;\\n      }\\n      visited[nodeIdx] = true;\\n      if (nodeIdx == dst) {\\n        return dist;\\n      }\\n      for (auto& child : tree[nodeIdx]) {\\n        if (visited[child.first]) continue;\\n        if (minusOne[child.second] && ignoreMinusOne) continue;\\n        int d = dist + myEdges[child.second][2];\\n        pq.push({-d, child.first, nodeIdx, child.second});\\n      }\\n    }\\n    return -1;\\n  }\\n  \\n  vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int src, int dst, int target) {\\n    tree.resize(n);\\n    shortest.resize(n);\\n    prev.resize(n);\\n    myEdges = move(edges);\\n    minusOne = vector<bool>(myEdges.size(), false);\\n    for (int i = 0; i < myEdges.size(); ++i) {\\n      auto& e = myEdges[i];\\n      tree[e[0]].push_back({e[1], i});\\n      tree[e[1]].push_back({e[0], i});\\n      if (e[2] == -1) {\\n        myEdges[i][2] = 1;\\n        minusOne[i] = true;\\n      }\\n    }\\n\\n    int shortestDistanceNoMinusOnes = findShortest(src, dst, true);\\n    if (shortestDistanceNoMinusOnes != -1 && shortestDistanceNoMinusOnes < target) {\\n      return {};\\n    }\\n    int shortestDistanceDstToSrc = findShortest(dst, src);\\n    if (shortestDistanceDstToSrc > target) {\\n      return {};\\n    }\\n    int shortestDistanceSrcToDst = findShortest(src, dst);\\n    if (shortestDistanceSrcToDst > target) {\\n      return {};\\n    }\\n\\n    int shortestDist = shortestDistanceSrcToDst;\\n    while (shortestDist < target) {\\n      int nd = dst;\\n      bool found = false;\\n      unordered_set<int> include;\\n      while (true) {\\n        if (nd == src) break;\\n        auto [prevNd, edgeIdx] = prev[nd][src];\\n        if (minusOne[edgeIdx]) {\\n          include.insert(edgeIdx);\\n          if (!found) {\\n            int fromSrc = shortest[myEdges[edgeIdx][0]][src];\\n            int toDst = shortest[myEdges[edgeIdx][1]][dst];\\n            myEdges[edgeIdx][2] = target - (fromSrc + toDst);\\n            found = true;\\n          }\\n        }\\n        nd = prevNd;\\n      }\\n      for (int i = 0; i < myEdges.size(); ++i) {\\n        if (minusOne[i] && !include.count(i)) {\\n          myEdges[i][2] = target + 10;\\n        }\\n      }\\n      findShortest(dst, src);\\n      shortestDist = findShortest(src, dst);\\n    }\\n    return myEdges;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553409,
                "title": "c",
                "content": "```\\nstruct cmp2 {\\n  bool operator() (array<int, 2>& a, array<int, 2>& b) const { return a > b; }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<array<int, 2>>> es;\\n    int n;\\n    vector<vector<int>> ans;\\n    \\n    void pfs(priority_queue<array<int, 2>, vector<array<int, 2>>, cmp2>& pq, vector<long long>& dist) {\\n        while (!pq.empty()) {\\n            auto cur = pq.top();\\n            pq.pop();\\n            int d = cur[0];\\n            int x = cur[1];\\n            if (d > dist[x]) continue;\\n            dist[x] = d;\\n            for (auto& e : es[x]) {\\n                int d1 = d + e[1];\\n                int y = e[0];\\n                if (d1 <= dist[y]) {\\n                    pq.push({d1, y});\\n                }\\n            }\\n        }\\n    }\\n    \\n    int bfs(vector<vector<array<int, 2>>>& es, int s, int dest, vector<vector<long long>>& dist) {\\n        for (int i = 0;i < n; i++) {\\n            dist[0][i] = INT_MAX;\\n            dist[1][i] = INT_MAX;\\n        }\\n        \\n        dist[0][s] = 0;\\n        dist[1][dest] = 0;\\n        \\n        priority_queue<array<int, 2>, vector<array<int, 2>>, cmp2> pq;\\n        pq.push({0, s});\\n        pfs(pq, dist[0]);\\n        \\n        priority_queue<array<int, 2>, vector<array<int, 2>>, cmp2> pq1;\\n        pq1.push({0, dest});\\n        pfs(pq1, dist[1]);\\n        return dist[0][dest];\\n    }\\n    \\n    void addedge(int x, int y, int w) {\\n        es[x].push_back({y, w});\\n        es[y].push_back({x, w});\\n        ans.push_back({x, y, w});\\n    }\\n    \\n    vector<vector<int>> modifiedGraphEdges(int n1, vector<vector<int>>& edges, int s, int d, int t) {\\n        n = n1;\\n        es.resize(n);\\n        vector<vector<long long>> dist = vector<vector<long long>>(2, vector<long long>(n, 0));\\n        for (auto& e : edges) {\\n            if (e[2] < 0) continue;\\n            es[e[0]].push_back({e[1], e[2]});\\n            es[e[1]].push_back({e[0], e[2]});\\n        }\\n        \\n        int dis = bfs(es, s, d, dist);\\n        if (dis < t) return vector<vector<int>>();\\n        \\n        const int mx = (int)((1e9) * 2);\\n        for (auto& e : edges) {\\n            if (e[2] >= 0) {\\n                ans.push_back(e);\\n                continue;\\n            }\\n            if (dis == t) {\\n                ans.push_back({e[0], e[1], mx});\\n                continue;\\n            }\\n            int x = e[0];\\n            int y = e[1];\\n            int w = 1;\\n            long long d1 = dist[0][x] + dist[1][y];\\n            long long d2 = dist[0][y] + dist[1][x];\\n            if (min(d1, d2) < t) w = t - min(d1, d2);                           \\n            addedge(x, y, w);\\n            dis = bfs(es, s, d, dist);\\n        }        \\n\\n        if (dis != t) return vector<vector<int>>();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct cmp2 {\\n  bool operator() (array<int, 2>& a, array<int, 2>& b) const { return a > b; }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<array<int, 2>>> es;\\n    int n;\\n    vector<vector<int>> ans;\\n    \\n    void pfs(priority_queue<array<int, 2>, vector<array<int, 2>>, cmp2>& pq, vector<long long>& dist) {\\n        while (!pq.empty()) {\\n            auto cur = pq.top();\\n            pq.pop();\\n            int d = cur[0];\\n            int x = cur[1];\\n            if (d > dist[x]) continue;\\n            dist[x] = d;\\n            for (auto& e : es[x]) {\\n                int d1 = d + e[1];\\n                int y = e[0];\\n                if (d1 <= dist[y]) {\\n                    pq.push({d1, y});\\n                }\\n            }\\n        }\\n    }\\n    \\n    int bfs(vector<vector<array<int, 2>>>& es, int s, int dest, vector<vector<long long>>& dist) {\\n        for (int i = 0;i < n; i++) {\\n            dist[0][i] = INT_MAX;\\n            dist[1][i] = INT_MAX;\\n        }\\n        \\n        dist[0][s] = 0;\\n        dist[1][dest] = 0;\\n        \\n        priority_queue<array<int, 2>, vector<array<int, 2>>, cmp2> pq;\\n        pq.push({0, s});\\n        pfs(pq, dist[0]);\\n        \\n        priority_queue<array<int, 2>, vector<array<int, 2>>, cmp2> pq1;\\n        pq1.push({0, dest});\\n        pfs(pq1, dist[1]);\\n        return dist[0][dest];\\n    }\\n    \\n    void addedge(int x, int y, int w) {\\n        es[x].push_back({y, w});\\n        es[y].push_back({x, w});\\n        ans.push_back({x, y, w});\\n    }\\n    \\n    vector<vector<int>> modifiedGraphEdges(int n1, vector<vector<int>>& edges, int s, int d, int t) {\\n        n = n1;\\n        es.resize(n);\\n        vector<vector<long long>> dist = vector<vector<long long>>(2, vector<long long>(n, 0));\\n        for (auto& e : edges) {\\n            if (e[2] < 0) continue;\\n            es[e[0]].push_back({e[1], e[2]});\\n            es[e[1]].push_back({e[0], e[2]});\\n        }\\n        \\n        int dis = bfs(es, s, d, dist);\\n        if (dis < t) return vector<vector<int>>();\\n        \\n        const int mx = (int)((1e9) * 2);\\n        for (auto& e : edges) {\\n            if (e[2] >= 0) {\\n                ans.push_back(e);\\n                continue;\\n            }\\n            if (dis == t) {\\n                ans.push_back({e[0], e[1], mx});\\n                continue;\\n            }\\n            int x = e[0];\\n            int y = e[1];\\n            int w = 1;\\n            long long d1 = dist[0][x] + dist[1][y];\\n            long long d2 = dist[0][y] + dist[1][x];\\n            if (min(d1, d2) < t) w = t - min(d1, d2);                           \\n            addedge(x, y, w);\\n            dis = bfs(es, s, d, dist);\\n        }        \\n\\n        if (dis != t) return vector<vector<int>>();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553131,
                "title": "2699-modify-graph-edge-weights",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @param {number} source\\n * @param {number} destination\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar modifiedGraphEdges = function (n, edges, source, destination, target) {\\n    let map = getMap(edges)\\n    let dijMap = getDijMap(edges, map, source, destination, n)\\n\\n    // check if the default edges fulfill the target\\n    if (dijMap[destination] < target) return []\\n    if (dijMap[destination] === target) {\\n        return edges.map(e => {\\n            if (e[2] === -1) e[2] = 2 * Math.pow(10, 9)\\n            return e\\n        })\\n    }\\n\\n    // start to assume -1 is 1\\n    for (let i = 0; i < edges.length; i++) {\\n        if (edges[i][2] === -1) {\\n            edges[i][2] = 1\\n            map[edges[i][0]] ||= []\\n            map[edges[i][1]] ||= []\\n            map[edges[i][0]].push([edges[i][1], 1])\\n            map[edges[i][1]].push([edges[i][0], 1])\\n\\n            dijMap = getDijMap(edges, map, source, destination)\\n\\n            // found the path, add the difference, fill the rest -1 and return\\n            if (dijMap[destination] <= target) {\\n                edges[i][2] += (target - dijMap[destination])\\n\\n                for (let j = i + 1; j < edges.length; j++) {\\n                    if (edges[j][2] === -1) edges[j][2] = 2 * Math.pow(10, 9)\\n                }\\n\\n                return edges\\n            }\\n        }\\n    }\\n\\n    return []\\n};\\n\\n// since LeetCode still not support MinPriorityQueue with array/object, \\n// we can either make our own heap or simply use brute force, considering that the maximum value of \\'n\\' is only 10^2.\\nconst spliceMin = (arr, map) => {\\n    let min = Infinity\\n    let idx = -1\\n\\n    for (let i = 0; i < arr.length; i++) {\\n        if (map[arr[i]] < min) {\\n            idx = i\\n            min = map[arr[i]]\\n        }\\n    }\\n\\n    let res = null\\n\\n    if (idx > -1) {\\n        res = arr.splice(idx, 1)\\n    }\\n\\n    return res\\n}\\n\\nconst getDijMap = (edges, map, source, dest, n) => {\\n    let dijMap = {}\\n\\n    for (let k in map) {\\n        dijMap[k] = Infinity\\n    }\\n\\n    dijMap[source] = 0\\n\\n    let visited = new Array(n).fill(false)\\n    let unvisited = Object.keys(map)\\n\\n    while (unvisited.length) {\\n        let cur = spliceMin(unvisited, dijMap)\\n        let neighbors = map[cur]\\n\\n        visited[cur] = true\\n\\n        if (!neighbors) return dijMap\\n\\n        for (let [n, w] of neighbors) {\\n            if (visited[n]) continue\\n\\n            dijMap[n] = Math.min(dijMap[n], dijMap[cur] + w)\\n        }\\n    }\\n    return dijMap\\n}\\n\\nconst getMap = edges => {\\n    let map = {}\\n\\n    for (let [n1, n2, w] of edges) {\\n        if (w !== -1) {\\n            map[n1] ||= []\\n            map[n2] ||= []\\n            map[n1].push([n2, w])\\n            map[n2].push([n1, w])\\n        }\\n    }\\n\\n    return map\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @param {number} source\\n * @param {number} destination\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar modifiedGraphEdges = function (n, edges, source, destination, target) {\\n    let map = getMap(edges)\\n    let dijMap = getDijMap(edges, map, source, destination, n)\\n\\n    // check if the default edges fulfill the target\\n    if (dijMap[destination] < target) return []\\n    if (dijMap[destination] === target) {\\n        return edges.map(e => {\\n            if (e[2] === -1) e[2] = 2 * Math.pow(10, 9)\\n            return e\\n        })\\n    }\\n\\n    // start to assume -1 is 1\\n    for (let i = 0; i < edges.length; i++) {\\n        if (edges[i][2] === -1) {\\n            edges[i][2] = 1\\n            map[edges[i][0]] ||= []\\n            map[edges[i][1]] ||= []\\n            map[edges[i][0]].push([edges[i][1], 1])\\n            map[edges[i][1]].push([edges[i][0], 1])\\n\\n            dijMap = getDijMap(edges, map, source, destination)\\n\\n            // found the path, add the difference, fill the rest -1 and return\\n            if (dijMap[destination] <= target) {\\n                edges[i][2] += (target - dijMap[destination])\\n\\n                for (let j = i + 1; j < edges.length; j++) {\\n                    if (edges[j][2] === -1) edges[j][2] = 2 * Math.pow(10, 9)\\n                }\\n\\n                return edges\\n            }\\n        }\\n    }\\n\\n    return []\\n};\\n\\n// since LeetCode still not support MinPriorityQueue with array/object, \\n// we can either make our own heap or simply use brute force, considering that the maximum value of \\'n\\' is only 10^2.\\nconst spliceMin = (arr, map) => {\\n    let min = Infinity\\n    let idx = -1\\n\\n    for (let i = 0; i < arr.length; i++) {\\n        if (map[arr[i]] < min) {\\n            idx = i\\n            min = map[arr[i]]\\n        }\\n    }\\n\\n    let res = null\\n\\n    if (idx > -1) {\\n        res = arr.splice(idx, 1)\\n    }\\n\\n    return res\\n}\\n\\nconst getDijMap = (edges, map, source, dest, n) => {\\n    let dijMap = {}\\n\\n    for (let k in map) {\\n        dijMap[k] = Infinity\\n    }\\n\\n    dijMap[source] = 0\\n\\n    let visited = new Array(n).fill(false)\\n    let unvisited = Object.keys(map)\\n\\n    while (unvisited.length) {\\n        let cur = spliceMin(unvisited, dijMap)\\n        let neighbors = map[cur]\\n\\n        visited[cur] = true\\n\\n        if (!neighbors) return dijMap\\n\\n        for (let [n, w] of neighbors) {\\n            if (visited[n]) continue\\n\\n            dijMap[n] = Math.min(dijMap[n], dijMap[cur] + w)\\n        }\\n    }\\n    return dijMap\\n}\\n\\nconst getMap = edges => {\\n    let map = {}\\n\\n    for (let [n1, n2, w] of edges) {\\n        if (w !== -1) {\\n            map[n1] ||= []\\n            map[n2] ||= []\\n            map[n1].push([n2, w])\\n            map[n2].push([n1, w])\\n        }\\n    }\\n\\n    return map\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3552806,
                "title": "easy-c-clean-code-solution-dijkstra",
                "content": "# Intuition\\nWe are playing with shortest distance between two vertices so why not dijkstra ?\\n# Approach\\nIf shortest distance is equal to target then assign any large number to negative weight edges.\\nIf shortest distance is less than target then you can never increase it by given modifications so return empty array.\\nIf shortest sistance is greater than target then iteratively add negative edges (now modify as 1). Apply dijkstra again. If shortest distance is k ammount less than target then add k to newly modified edge.\\n\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> dijkstra(int V, vector<vector<int>> adj[], int S){\\n    \\n        vector<int>dist(V, INT_MAX);\\n        \\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;\\n        \\n        dist[S] = 0;\\n        \\n        pq.push({0, S});\\n       \\n        \\n        while(!pq.empty()){\\n            int node = pq.top().second;\\n            pq.pop();\\n            \\n            for(auto child : adj[node]){\\n                int adjNode = child[0];\\n                int weight = child[1];\\n                \\n                if(dist[adjNode] > weight + dist[node]){\\n                    dist[adjNode] = dist[node] + weight;\\n                    pq.push({dist[adjNode], adjNode});\\n                }\\n            }\\n        }\\n        return dist;\\n}\\n\\n     vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int source, int destination, int target) {\\n         // build the graph \\n\\n        vector<vector<int>> adj[n] ;\\n\\n        for(int i = 0 ; i<edges.size() ; i++){\\n            if(edges[i][2] > 0){\\n               int u = edges[i][0] ;\\n               int v = edges[i][1] ;\\n               int wt = edges[i][2] ;\\n               adj[u].push_back({v,wt}) ;\\n               adj[v].push_back({u,wt}) ;\\n\\n            }\\n\\n        }\\n     \\n    vector<int>ans = dijkstra(n,adj,source) ;\\n    \\n\\n    if(ans[destination] == target){\\n         for(auto &i : edges){\\n             if(i[2] == -1) i[2] = 1e9 ;\\n         }\\n    return edges;\\n    }\\n\\n    if(ans[destination] < target){\\n        return {} ;\\n    }\\n\\n    for(int i = 0 ; i<edges.size(); i++){\\n        for(auto &e : edges){\\n           if(e[2] == -1){\\n                 e[2] = 1 ;\\n                 adj[e[0]].push_back({e[1],1}) ;\\n                 adj[e[1]].push_back({e[0],1}) ;\\n            \\n\\n          vector<int>ans2 = dijkstra(n,adj,source) ;\\n\\n\\n            if(ans2[destination] <= target) {\\n                    e[2] += (target - ans2[destination]);\\n                    for(int j=i+1; j<edges.size(); j++){\\n                        if(edges[j][2] == -1) {\\n                           edges[j][2] = 1e9; \\n                        }\\n                    }\\n                    return edges;\\n            }\\n\\n        \\n        }\\n    }\\n\\n    }\\n        return {} ;\\n    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> dijkstra(int V, vector<vector<int>> adj[], int S){\\n    \\n        vector<int>dist(V, INT_MAX);\\n        \\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;\\n        \\n        dist[S] = 0;\\n        \\n        pq.push({0, S});\\n       \\n        \\n        while(!pq.empty()){\\n            int node = pq.top().second;\\n            pq.pop();\\n            \\n            for(auto child : adj[node]){\\n                int adjNode = child[0];\\n                int weight = child[1];\\n                \\n                if(dist[adjNode] > weight + dist[node]){\\n                    dist[adjNode] = dist[node] + weight;\\n                    pq.push({dist[adjNode], adjNode});\\n                }\\n            }\\n        }\\n        return dist;\\n}\\n\\n     vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int source, int destination, int target) {\\n         // build the graph \\n\\n        vector<vector<int>> adj[n] ;\\n\\n        for(int i = 0 ; i<edges.size() ; i++){\\n            if(edges[i][2] > 0){\\n               int u = edges[i][0] ;\\n               int v = edges[i][1] ;\\n               int wt = edges[i][2] ;\\n               adj[u].push_back({v,wt}) ;\\n               adj[v].push_back({u,wt}) ;\\n\\n            }\\n\\n        }\\n     \\n    vector<int>ans = dijkstra(n,adj,source) ;\\n    \\n\\n    if(ans[destination] == target){\\n         for(auto &i : edges){\\n             if(i[2] == -1) i[2] = 1e9 ;\\n         }\\n    return edges;\\n    }\\n\\n    if(ans[destination] < target){\\n        return {} ;\\n    }\\n\\n    for(int i = 0 ; i<edges.size(); i++){\\n        for(auto &e : edges){\\n           if(e[2] == -1){\\n                 e[2] = 1 ;\\n                 adj[e[0]].push_back({e[1],1}) ;\\n                 adj[e[1]].push_back({e[0],1}) ;\\n            \\n\\n          vector<int>ans2 = dijkstra(n,adj,source) ;\\n\\n\\n            if(ans2[destination] <= target) {\\n                    e[2] += (target - ans2[destination]);\\n                    for(int j=i+1; j<edges.size(); j++){\\n                        if(edges[j][2] == -1) {\\n                           edges[j][2] = 1e9; \\n                        }\\n                    }\\n                    return edges;\\n            }\\n\\n        \\n        }\\n    }\\n\\n    }\\n        return {} ;\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3552174,
                "title": "complete-brute-force-dijkstra-s-algorithm-graphs",
                "content": "Here is my c++ code for this problem\\n\\n# Complexity\\n- Time complexity:$$O(n^2*(logn)^2)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int source, int destination, int target) {\\n        vector<vector<int>>v, ans, ans1;\\n        vector<pair<int, int>>adj[n], adj1[n];\\n        for(auto it: edges){\\n            if(it[2]==-1){\\n                v.push_back({it[0], it[1]});\\n                adj1[it[0]].push_back({it[1], 1});\\n                adj1[it[1]].push_back({it[0], 1});\\n            }\\n            else{\\n                ans1.push_back({it[0], it[1], it[2]});\\n                adj[it[0]].push_back({it[1], it[2]});\\n                adj[it[1]].push_back({it[0], it[2]});\\n                adj1[it[0]].push_back({it[1], it[2]});\\n                adj1[it[1]].push_back({it[0], it[2]});\\n            }\\n        }\\n        // for(int i=0; i<n; i++){\\n        //     cout<<i<<\": \";\\n        //     for(auto it: adj[i]){\\n        //         cout<<\"{\"<<it.first<<\" \"<<it.second<<\"}\";\\n        //     }cout<<endl;\\n        // }cout<<endl;\\n        // for(int i=0; i<n; i++){\\n        //     cout<<i<<\": \";\\n        //     for(auto it: adj1[i]){\\n        //         cout<<\"{\"<<it.first<<\" \"<<it.second<<\"}\";\\n        //     }cout<<endl;\\n        // }cout<<endl;\\n        auto f=[&](vector<pair<int, int>>ad[], int s, int d)->int{\\n            // for(int i=0; i<n; i++){\\n            //     cout<<i<<\": \";\\n            //     for(auto it: ad[i]){\\n            //         cout<<\"{\"<<it.first<<\" \"<<it.second<<\"}\";\\n            //     }cout<<endl;\\n            // }cout<<endl;\\n            vector<int>dis(n, 1e9);\\n            priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>>q;\\n            q.push({0, s});\\n            dis[s]=0;\\n            while(!q.empty()){\\n                int ind=q.top().second, wt=q.top().first;\\n                q.pop();\\n                // if(dis[ind]<1e9){continue;}\\n                for(auto it: ad[ind]){\\n                    if(dis[it.first]>wt+it.second){\\n                        dis[it.first]=wt+it.second;\\n                        q.push({dis[it.first], it.first});\\n                    }\\n                }\\n            }\\n            // for(int i=0; i<n; i++){\\n            //     cout<<dis[i]<<\" \";\\n            // }cout<<endl;\\n            return dis[d];\\n        };\\n        int cnt1=f(adj, source, destination), cnt2=f(adj1, source, destination);\\n        //cout<<f(adj, source, destination, target)<<\" \"<<f(adj1, source, destination, target)<<endl;\\n        if(cnt1<target || (cnt2>target && cnt2!=1e9)){\\n            // cout<<\"here\"<<endl;\\n            return ans;\\n        }\\n        if(v.empty()){\\n            if(cnt1==target){return edges;}\\n        }\\n        auto ff=[&](int pos, vector<pair<int, int>>a[], vector<vector<int>>&v)->int{\\n            vector<pair<int, int>>aa[n];\\n            // for(int i=0; i<n; i++){\\n            //     for(auto it1: a[i]){\\n            //         aa[i].push_back({it1.first, it1.second});\\n            //     }\\n            // }\\n            for(auto it: edges){\\n                if(it[2]!=-1){\\n                    aa[it[0]].push_back({it[1], it[2]});\\n                    aa[it[1]].push_back({it[0], it[2]});\\n                }\\n            }\\n            for(int i=0; i<pos+1; i++){\\n                aa[v[i][0]].push_back({v[i][1], 1});\\n                aa[v[i][1]].push_back({v[i][0], 1});\\n            }\\n            // for(int i=0; i<n; i++){\\n            //     cout<<i<<\": \";\\n            //     for(auto it: aa[i]){\\n            //         cout<<\"{\"<<it.first<<\" \"<<it.second<<\"}\";\\n            //     }cout<<endl;\\n            // }cout<<endl;\\n            int num=f(aa, source, destination);\\n            // cout<<num<<\" c\"<<endl;;\\n            return num;\\n        };\\n        // sort(v.begin(), v.end());\\n        // for(auto it: v){\\n        //     cout<<\"{\"<<it[0]<<\" \"<<it[1]<<\"}\";\\n        // }cout<<endl;\\n        int st=0, en=v.size()-1;\\n        while(st<=en){\\n            int mid=st+(en-st)/2;\\n            int val=ff(mid, adj, v);\\n            // cout<<val<<\" \"<<mid<<endl;\\n            if(val<=target){\\n                en=mid-1;\\n            }\\n            else{\\n                st=mid+1;\\n            }\\n        }\\n        int len=ff(st, adj, v);\\n        // cout<<len<<\" \"<<st<<endl;\\n        // for(auto it: edges){\\n        //     if(it[2]!=-1){continue;}\\n        //     if(st==0){\\n        //         it[2]=2e9; continue;\\n        //     }\\n        //     if(st==1){\\n        //         it[2]=target-len+1;\\n        //     }\\n        //     else{\\n        //         it[2]=1;\\n        //     }\\n        //     st--;\\n        // }\\n        int maxi=2e9;\\n        for(int i=0; i<st; i++){\\n            ans1.push_back({v[i][0], v[i][1], 1});\\n        }\\n        ans1.push_back({v[st][0], v[st][1], target-len+1});\\n        for(int i=st+1; i<v.size(); i++){\\n            ans1.push_back({v[i][0], v[i][1], maxi});\\n        }\\n        return ans1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int source, int destination, int target) {\\n        vector<vector<int>>v, ans, ans1;\\n        vector<pair<int, int>>adj[n], adj1[n];\\n        for(auto it: edges){\\n            if(it[2]==-1){\\n                v.push_back({it[0], it[1]});\\n                adj1[it[0]].push_back({it[1], 1});\\n                adj1[it[1]].push_back({it[0], 1});\\n            }\\n            else{\\n                ans1.push_back({it[0], it[1], it[2]});\\n                adj[it[0]].push_back({it[1], it[2]});\\n                adj[it[1]].push_back({it[0], it[2]});\\n                adj1[it[0]].push_back({it[1], it[2]});\\n                adj1[it[1]].push_back({it[0], it[2]});\\n            }\\n        }\\n        // for(int i=0; i<n; i++){\\n        //     cout<<i<<\": \";\\n        //     for(auto it: adj[i]){\\n        //         cout<<\"{\"<<it.first<<\" \"<<it.second<<\"}\";\\n        //     }cout<<endl;\\n        // }cout<<endl;\\n        // for(int i=0; i<n; i++){\\n        //     cout<<i<<\": \";\\n        //     for(auto it: adj1[i]){\\n        //         cout<<\"{\"<<it.first<<\" \"<<it.second<<\"}\";\\n        //     }cout<<endl;\\n        // }cout<<endl;\\n        auto f=[&](vector<pair<int, int>>ad[], int s, int d)->int{\\n            // for(int i=0; i<n; i++){\\n            //     cout<<i<<\": \";\\n            //     for(auto it: ad[i]){\\n            //         cout<<\"{\"<<it.first<<\" \"<<it.second<<\"}\";\\n            //     }cout<<endl;\\n            // }cout<<endl;\\n            vector<int>dis(n, 1e9);\\n            priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>>q;\\n            q.push({0, s});\\n            dis[s]=0;\\n            while(!q.empty()){\\n                int ind=q.top().second, wt=q.top().first;\\n                q.pop();\\n                // if(dis[ind]<1e9){continue;}\\n                for(auto it: ad[ind]){\\n                    if(dis[it.first]>wt+it.second){\\n                        dis[it.first]=wt+it.second;\\n                        q.push({dis[it.first], it.first});\\n                    }\\n                }\\n            }\\n            // for(int i=0; i<n; i++){\\n            //     cout<<dis[i]<<\" \";\\n            // }cout<<endl;\\n            return dis[d];\\n        };\\n        int cnt1=f(adj, source, destination), cnt2=f(adj1, source, destination);\\n        //cout<<f(adj, source, destination, target)<<\" \"<<f(adj1, source, destination, target)<<endl;\\n        if(cnt1<target || (cnt2>target && cnt2!=1e9)){\\n            // cout<<\"here\"<<endl;\\n            return ans;\\n        }\\n        if(v.empty()){\\n            if(cnt1==target){return edges;}\\n        }\\n        auto ff=[&](int pos, vector<pair<int, int>>a[], vector<vector<int>>&v)->int{\\n            vector<pair<int, int>>aa[n];\\n            // for(int i=0; i<n; i++){\\n            //     for(auto it1: a[i]){\\n            //         aa[i].push_back({it1.first, it1.second});\\n            //     }\\n            // }\\n            for(auto it: edges){\\n                if(it[2]!=-1){\\n                    aa[it[0]].push_back({it[1], it[2]});\\n                    aa[it[1]].push_back({it[0], it[2]});\\n                }\\n            }\\n            for(int i=0; i<pos+1; i++){\\n                aa[v[i][0]].push_back({v[i][1], 1});\\n                aa[v[i][1]].push_back({v[i][0], 1});\\n            }\\n            // for(int i=0; i<n; i++){\\n            //     cout<<i<<\": \";\\n            //     for(auto it: aa[i]){\\n            //         cout<<\"{\"<<it.first<<\" \"<<it.second<<\"}\";\\n            //     }cout<<endl;\\n            // }cout<<endl;\\n            int num=f(aa, source, destination);\\n            // cout<<num<<\" c\"<<endl;;\\n            return num;\\n        };\\n        // sort(v.begin(), v.end());\\n        // for(auto it: v){\\n        //     cout<<\"{\"<<it[0]<<\" \"<<it[1]<<\"}\";\\n        // }cout<<endl;\\n        int st=0, en=v.size()-1;\\n        while(st<=en){\\n            int mid=st+(en-st)/2;\\n            int val=ff(mid, adj, v);\\n            // cout<<val<<\" \"<<mid<<endl;\\n            if(val<=target){\\n                en=mid-1;\\n            }\\n            else{\\n                st=mid+1;\\n            }\\n        }\\n        int len=ff(st, adj, v);\\n        // cout<<len<<\" \"<<st<<endl;\\n        // for(auto it: edges){\\n        //     if(it[2]!=-1){continue;}\\n        //     if(st==0){\\n        //         it[2]=2e9; continue;\\n        //     }\\n        //     if(st==1){\\n        //         it[2]=target-len+1;\\n        //     }\\n        //     else{\\n        //         it[2]=1;\\n        //     }\\n        //     st--;\\n        // }\\n        int maxi=2e9;\\n        for(int i=0; i<st; i++){\\n            ans1.push_back({v[i][0], v[i][1], 1});\\n        }\\n        ans1.push_back({v[st][0], v[st][1], target-len+1});\\n        for(int i=st+1; i<v.size(); i++){\\n            ans1.push_back({v[i][0], v[i][1], maxi});\\n        }\\n        return ans1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3551482,
                "title": "c-shortest-path",
                "content": "# Code\\n```\\npublic class Solution {\\n    private static int ShortestPath(IDictionary<int, List<(int to, int weight)>> graph, int source, int target) {\\n        long[] result = Enumerable\\n            .Repeat(long.MaxValue, graph.Count)\\n            .ToArray();\\n\\n        result[source] = 0;\\n\\n        Queue<int> agenda = new Queue<int>();\\n        HashSet<int> visited = new() { source };\\n\\n        agenda.Enqueue(source);\\n\\n        while (agenda.Count > 0) {\\n            var node = agenda.Dequeue();\\n\\n            visited.Remove(node);\\n\\n            foreach (var next in graph[node]) {\\n                if (next.weight < 0)\\n                    continue;\\n\\n                if (result[node] + next.weight < result[next.to]) {\\n                    result[next.to] = result[node] + next.weight;\\n\\n                    if (visited.Add(next.to))\\n                        agenda.Enqueue(next.to);\\n                }\\n            }\\n        }\\n\\n        return result[target] == long.MaxValue ? int.MaxValue : (int)result[target];\\n    }\\n\\n    public int[][] ModifiedGraphEdges(int n, int[][] edges, int source, int destination, int target) {\\n        var graph = Enumerable\\n            .Range(0, n)\\n            .ToDictionary(i => i, i => new List<(int to, int weight)>());\\n\\n        foreach (var edge in edges) {\\n            graph[edge[0]].Add((edge[1], edge[2]));\\n            graph[edge[1]].Add((edge[0], edge[2]));\\n        }\\n\\n        int A = ShortestPath(graph, source, destination);\\n\\n        if (A < target)\\n            return Array.Empty<int[]>();\\n\\n        if (A == target) {\\n            foreach (var edge in edges)\\n                if (edge[2] == -1)\\n                    edge[2] = target + 1;\\n\\n            return edges;\\n        }\\n\\n        foreach (var edge in edges) {\\n            if (edge[2] != -1)\\n                continue;\\n\\n            int a = edge[0];\\n            int b = edge[1];\\n\\n            edge[2] = 1;\\n\\n            graph[a].Remove((b, -1));\\n            graph[a].Add((b, 1));\\n\\n            graph[b].Remove((a, -1));\\n            graph[b].Add((a, 1));\\n\\n            int B = ShortestPath(graph, source, destination);\\n\\n            if (B <= target) {\\n                edge[2] = 1 + target - B;\\n\\n                foreach (var e in edges) {\\n                    if (e[2] < 0)\\n                        e[2] = target + 1; // <- will not be accepted if int.MaxValue is used\\n                }\\n\\n                return edges;\\n            }\\n        }\\n\\n        return Array.Empty<int[]>();\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    private static int ShortestPath(IDictionary<int, List<(int to, int weight)>> graph, int source, int target) {\\n        long[] result = Enumerable\\n            .Repeat(long.MaxValue, graph.Count)\\n            .ToArray();\\n\\n        result[source] = 0;\\n\\n        Queue<int> agenda = new Queue<int>();\\n        HashSet<int> visited = new() { source };\\n\\n        agenda.Enqueue(source);\\n\\n        while (agenda.Count > 0) {\\n            var node = agenda.Dequeue();\\n\\n            visited.Remove(node);\\n\\n            foreach (var next in graph[node]) {\\n                if (next.weight < 0)\\n                    continue;\\n\\n                if (result[node] + next.weight < result[next.to]) {\\n                    result[next.to] = result[node] + next.weight;\\n\\n                    if (visited.Add(next.to))\\n                        agenda.Enqueue(next.to);\\n                }\\n            }\\n        }\\n\\n        return result[target] == long.MaxValue ? int.MaxValue : (int)result[target];\\n    }\\n\\n    public int[][] ModifiedGraphEdges(int n, int[][] edges, int source, int destination, int target) {\\n        var graph = Enumerable\\n            .Range(0, n)\\n            .ToDictionary(i => i, i => new List<(int to, int weight)>());\\n\\n        foreach (var edge in edges) {\\n            graph[edge[0]].Add((edge[1], edge[2]));\\n            graph[edge[1]].Add((edge[0], edge[2]));\\n        }\\n\\n        int A = ShortestPath(graph, source, destination);\\n\\n        if (A < target)\\n            return Array.Empty<int[]>();\\n\\n        if (A == target) {\\n            foreach (var edge in edges)\\n                if (edge[2] == -1)\\n                    edge[2] = target + 1;\\n\\n            return edges;\\n        }\\n\\n        foreach (var edge in edges) {\\n            if (edge[2] != -1)\\n                continue;\\n\\n            int a = edge[0];\\n            int b = edge[1];\\n\\n            edge[2] = 1;\\n\\n            graph[a].Remove((b, -1));\\n            graph[a].Add((b, 1));\\n\\n            graph[b].Remove((a, -1));\\n            graph[b].Add((a, 1));\\n\\n            int B = ShortestPath(graph, source, destination);\\n\\n            if (B <= target) {\\n                edge[2] = 1 + target - B;\\n\\n                foreach (var e in edges) {\\n                    if (e[2] < 0)\\n                        e[2] = target + 1; // <- will not be accepted if int.MaxValue is used\\n                }\\n\\n                return edges;\\n            }\\n        }\\n\\n        return Array.Empty<int[]>();\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1900625,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "This is the last time I attempt the hard problem before the medium in a contest! \\nHonestly, this one didn;t look too bad at first, just a modified Djikstra, right?\\nOh boy, was I wrong"
                    },
                    {
                        "username": "Finesse",
                        "content": "I've managed to solve using a single modified Dijkstra's cycle. Throughout every path with `distance≤target`, you need to find the one with the fewest `-1` edges (the `-1` edges add the minimum weight which is `1`). To implement it, don't sort the heap by the distance; sort by the number of `-1` edges first, and then by the distance. If that path has no `-1` edges, the answer is `[]`, otherwise fill all the edges on the path with some weights to meet the target and the other edges with `2e9`. [My code.](https://leetcode.com/problems/modify-graph-edge-weights/submissions/954301674/)"
                    },
                    {
                        "username": "jasonechiu",
                        "content": "The test case seems incorrect.\\nFor testcase `353`\\nn = 4\\nedges = [[0,1,-1],[1,2,-1],[3,1,-1],[3,0,2],[0,2,5]]\\nsource = 2\\ndestination = 3\\ntarget = 8\\n\\nMy output is [[0,1,1],[1,2,1],[3,1,7],[3,0,2],[0,2,5]]\\nWhich means we can travel 2 -> 1 -> 3 and the sum is 8\\nBut it expect []\\n\\n\\nIt seems the solution is wrong."
                    },
                    {
                        "username": "Chrishu5777",
                        "content": "[@cartesPerforees](/cartesPerforees) thanks!!"
                    },
                    {
                        "username": "narang_madhur",
                        "content": "[@cartesPerforees](/cartesPerforees) Thanks for pointing out the error in output logic...I understood my mistake too.\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@jasonechiu](/jasonechiu) yup. The shortest of all distances from source to destination has to be target.\\nReally tough problem"
                    },
                    {
                        "username": "jasonechiu",
                        "content": "[@cartesPerforees](/cartesPerforees) \\nThanks for reply, I misunderstand the question. I suppose one shortest distance between the nodes source and destination. But it means \"all\" shortest distance between the nodes source and destination the sum of the weights should match the target."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "in your output, the shortest path from 2 to 3 is 2->0->3 with length 7. It is incorrect\\n\\nIt\\'s a really difficult problem bro, that kind of stuff is only the tip of the iceberg of debugging you;ll have to go through before getting AC"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "2 ques gang?!"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why there is a 2300 rating problem from codeforces in a leetcode contest?\\nhttps://codeforces.com/problemset/problem/715/B"
                    },
                    {
                        "username": "shivansh961",
                        "content": "LeetCode is high."
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "4\\n[[0,1,-1],[2,0,2],[3,2,6],[2,1,10],[3,0,-1]]\\n1\\n3\\n12\\n\\nmy output : [[0,1,1],[2,0,2],[3,2,6],[2,1,10],[3,0,11]]\\nexpected : [[0,1,11],[2,0,2],[3,2,6],[2,1,10],[3,0,1]]\\nthe question says if there are multiple modifications return any of them, then why is my output wrong."
                    },
                    {
                        "username": "vikassuthar528",
                        "content": "I\\'m also getting same test case wrong."
                    },
                    {
                        "username": "krobzh",
                        "content": " In your output, the shortest distance from 1 to 3 is 1->0->2->3 which is 9,  not 12. I got the similar error in another test case in which I break the original shortest path and made a shorter path.  "
                    },
                    {
                        "username": "aniketkr01",
                        "content": "Same happened with me"
                    },
                    {
                        "username": "HLeiTR",
                        "content": "I am a little bit confused on this test case: \n\n```\nn = 5\nedges = [[1,4,1],[2,4,-1],[3,0,2],[0,4,-1],[1,3,10],[1,0,10]]\nsource = 0\ndestination = 2\ntarget = 15\n```\n\nNotice that in this graph, the only paths from 0 to 2 are: \n0 -> 3 -> 1 -> 4 -> 2, with cost 2 + 10 + 1 = 13 and 1 changeable\n0 -> 4 -> 2, with cost 0 and 2 changeable\n0 -> 1 -> 4 -> 2, with cost 10 + 1 and 1 changeable\n\nThe expected answer is: \n`[[1,4,1],[2,4,4],[3,0,2],[0,4,14],[1,3,10],[1,0,10]]`\nWhich suggests that it took the third path, and changing the weight of (2, 4) to 4. \n(Also, I'm not sure why it changed the edge of 0 to 4 to have a weight of 14, it is not even used?)\n\nHowever, my answer is:\n`[[1,4,1],[2,4,1],[3,0,2],[0,4,14],[1,3,10],[1,0,10]]`\nWhich took the second path, and changing one of the weights to 14 and the other to 1. \nThen, I changed all other unused, changeable edges to have weight 1. \n\nShouldn't this also be considered correct by the problem description? \nAny help is appreciated, very confused on this question :c"
                    },
                    {
                        "username": "Hackytech",
                        "content": "[@Finesse](/Finesse) No matter how many times I read the question or go through some solutions, i am not able to identify what is the meaning of shortest path over here. It's definitely not the sum of edges because it has to be equal to target so no matter which valid path you choose, we can make it equal to target. So is it the number of edges between the source and destination. I am too confused, please correct me If I am wrong at some point. \n Thanks"
                    },
                    {
                        "username": "HLeiTR",
                        "content": "[@Finesse](/Finesse) \\n! Ahh\\nI see the problem now, thanks a lot!"
                    },
                    {
                        "username": "Finesse",
                        "content": "> Then, I changed all other unused, changeable edges to have weight 1\n\n...and made another path be shorter than 15. That's your mistake.\n\nAfter changing the weights, all the other path distances must be recalculated, and the smallest must equal target.\n\nChange the unused edge weights to the maximum instead."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "For the following testcase, why is the answer an empty matrix?\\n\\n`n = 4,\\nedges = [[0,1,-1],[1,2,-1],[3,1,-1],[3,0,2],[0,2,5]],\\nsource = 2,\\ndestination = 3,\\ntarget = 8`"
                    },
                    {
                        "username": "monster_10",
                        "content": "Time complexity is O(M*M*LOG(V)) it runs fine but doesn\\'t comply with the constraints as it should give TLE"
                    },
                    {
                        "username": "dmitryartux",
                        "content": ">If the shortest path from source to destination including the edges to be modified and assigning them a temporary weight of 1, is less than the target, then it is also not possible.\\n\\n**Looks like the Hint #3 is wrong**"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Yes, should be \\'MORE than the target\\'."
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "The 3rd hint is wrong, instead of \"less than the target\", it should be \"greater than the target\".  "
                    }
                ]
            },
            {
                "id": 1900584,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "This is the last time I attempt the hard problem before the medium in a contest! \\nHonestly, this one didn;t look too bad at first, just a modified Djikstra, right?\\nOh boy, was I wrong"
                    },
                    {
                        "username": "Finesse",
                        "content": "I've managed to solve using a single modified Dijkstra's cycle. Throughout every path with `distance≤target`, you need to find the one with the fewest `-1` edges (the `-1` edges add the minimum weight which is `1`). To implement it, don't sort the heap by the distance; sort by the number of `-1` edges first, and then by the distance. If that path has no `-1` edges, the answer is `[]`, otherwise fill all the edges on the path with some weights to meet the target and the other edges with `2e9`. [My code.](https://leetcode.com/problems/modify-graph-edge-weights/submissions/954301674/)"
                    },
                    {
                        "username": "jasonechiu",
                        "content": "The test case seems incorrect.\\nFor testcase `353`\\nn = 4\\nedges = [[0,1,-1],[1,2,-1],[3,1,-1],[3,0,2],[0,2,5]]\\nsource = 2\\ndestination = 3\\ntarget = 8\\n\\nMy output is [[0,1,1],[1,2,1],[3,1,7],[3,0,2],[0,2,5]]\\nWhich means we can travel 2 -> 1 -> 3 and the sum is 8\\nBut it expect []\\n\\n\\nIt seems the solution is wrong."
                    },
                    {
                        "username": "Chrishu5777",
                        "content": "[@cartesPerforees](/cartesPerforees) thanks!!"
                    },
                    {
                        "username": "narang_madhur",
                        "content": "[@cartesPerforees](/cartesPerforees) Thanks for pointing out the error in output logic...I understood my mistake too.\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@jasonechiu](/jasonechiu) yup. The shortest of all distances from source to destination has to be target.\\nReally tough problem"
                    },
                    {
                        "username": "jasonechiu",
                        "content": "[@cartesPerforees](/cartesPerforees) \\nThanks for reply, I misunderstand the question. I suppose one shortest distance between the nodes source and destination. But it means \"all\" shortest distance between the nodes source and destination the sum of the weights should match the target."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "in your output, the shortest path from 2 to 3 is 2->0->3 with length 7. It is incorrect\\n\\nIt\\'s a really difficult problem bro, that kind of stuff is only the tip of the iceberg of debugging you;ll have to go through before getting AC"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "2 ques gang?!"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why there is a 2300 rating problem from codeforces in a leetcode contest?\\nhttps://codeforces.com/problemset/problem/715/B"
                    },
                    {
                        "username": "shivansh961",
                        "content": "LeetCode is high."
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "4\\n[[0,1,-1],[2,0,2],[3,2,6],[2,1,10],[3,0,-1]]\\n1\\n3\\n12\\n\\nmy output : [[0,1,1],[2,0,2],[3,2,6],[2,1,10],[3,0,11]]\\nexpected : [[0,1,11],[2,0,2],[3,2,6],[2,1,10],[3,0,1]]\\nthe question says if there are multiple modifications return any of them, then why is my output wrong."
                    },
                    {
                        "username": "vikassuthar528",
                        "content": "I\\'m also getting same test case wrong."
                    },
                    {
                        "username": "krobzh",
                        "content": " In your output, the shortest distance from 1 to 3 is 1->0->2->3 which is 9,  not 12. I got the similar error in another test case in which I break the original shortest path and made a shorter path.  "
                    },
                    {
                        "username": "aniketkr01",
                        "content": "Same happened with me"
                    },
                    {
                        "username": "HLeiTR",
                        "content": "I am a little bit confused on this test case: \n\n```\nn = 5\nedges = [[1,4,1],[2,4,-1],[3,0,2],[0,4,-1],[1,3,10],[1,0,10]]\nsource = 0\ndestination = 2\ntarget = 15\n```\n\nNotice that in this graph, the only paths from 0 to 2 are: \n0 -> 3 -> 1 -> 4 -> 2, with cost 2 + 10 + 1 = 13 and 1 changeable\n0 -> 4 -> 2, with cost 0 and 2 changeable\n0 -> 1 -> 4 -> 2, with cost 10 + 1 and 1 changeable\n\nThe expected answer is: \n`[[1,4,1],[2,4,4],[3,0,2],[0,4,14],[1,3,10],[1,0,10]]`\nWhich suggests that it took the third path, and changing the weight of (2, 4) to 4. \n(Also, I'm not sure why it changed the edge of 0 to 4 to have a weight of 14, it is not even used?)\n\nHowever, my answer is:\n`[[1,4,1],[2,4,1],[3,0,2],[0,4,14],[1,3,10],[1,0,10]]`\nWhich took the second path, and changing one of the weights to 14 and the other to 1. \nThen, I changed all other unused, changeable edges to have weight 1. \n\nShouldn't this also be considered correct by the problem description? \nAny help is appreciated, very confused on this question :c"
                    },
                    {
                        "username": "Hackytech",
                        "content": "[@Finesse](/Finesse) No matter how many times I read the question or go through some solutions, i am not able to identify what is the meaning of shortest path over here. It's definitely not the sum of edges because it has to be equal to target so no matter which valid path you choose, we can make it equal to target. So is it the number of edges between the source and destination. I am too confused, please correct me If I am wrong at some point. \n Thanks"
                    },
                    {
                        "username": "HLeiTR",
                        "content": "[@Finesse](/Finesse) \\n! Ahh\\nI see the problem now, thanks a lot!"
                    },
                    {
                        "username": "Finesse",
                        "content": "> Then, I changed all other unused, changeable edges to have weight 1\n\n...and made another path be shorter than 15. That's your mistake.\n\nAfter changing the weights, all the other path distances must be recalculated, and the smallest must equal target.\n\nChange the unused edge weights to the maximum instead."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "For the following testcase, why is the answer an empty matrix?\\n\\n`n = 4,\\nedges = [[0,1,-1],[1,2,-1],[3,1,-1],[3,0,2],[0,2,5]],\\nsource = 2,\\ndestination = 3,\\ntarget = 8`"
                    },
                    {
                        "username": "monster_10",
                        "content": "Time complexity is O(M*M*LOG(V)) it runs fine but doesn\\'t comply with the constraints as it should give TLE"
                    },
                    {
                        "username": "dmitryartux",
                        "content": ">If the shortest path from source to destination including the edges to be modified and assigning them a temporary weight of 1, is less than the target, then it is also not possible.\\n\\n**Looks like the Hint #3 is wrong**"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Yes, should be \\'MORE than the target\\'."
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "The 3rd hint is wrong, instead of \"less than the target\", it should be \"greater than the target\".  "
                    }
                ]
            },
            {
                "id": 1900505,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "This is the last time I attempt the hard problem before the medium in a contest! \\nHonestly, this one didn;t look too bad at first, just a modified Djikstra, right?\\nOh boy, was I wrong"
                    },
                    {
                        "username": "Finesse",
                        "content": "I've managed to solve using a single modified Dijkstra's cycle. Throughout every path with `distance≤target`, you need to find the one with the fewest `-1` edges (the `-1` edges add the minimum weight which is `1`). To implement it, don't sort the heap by the distance; sort by the number of `-1` edges first, and then by the distance. If that path has no `-1` edges, the answer is `[]`, otherwise fill all the edges on the path with some weights to meet the target and the other edges with `2e9`. [My code.](https://leetcode.com/problems/modify-graph-edge-weights/submissions/954301674/)"
                    },
                    {
                        "username": "jasonechiu",
                        "content": "The test case seems incorrect.\\nFor testcase `353`\\nn = 4\\nedges = [[0,1,-1],[1,2,-1],[3,1,-1],[3,0,2],[0,2,5]]\\nsource = 2\\ndestination = 3\\ntarget = 8\\n\\nMy output is [[0,1,1],[1,2,1],[3,1,7],[3,0,2],[0,2,5]]\\nWhich means we can travel 2 -> 1 -> 3 and the sum is 8\\nBut it expect []\\n\\n\\nIt seems the solution is wrong."
                    },
                    {
                        "username": "Chrishu5777",
                        "content": "[@cartesPerforees](/cartesPerforees) thanks!!"
                    },
                    {
                        "username": "narang_madhur",
                        "content": "[@cartesPerforees](/cartesPerforees) Thanks for pointing out the error in output logic...I understood my mistake too.\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@jasonechiu](/jasonechiu) yup. The shortest of all distances from source to destination has to be target.\\nReally tough problem"
                    },
                    {
                        "username": "jasonechiu",
                        "content": "[@cartesPerforees](/cartesPerforees) \\nThanks for reply, I misunderstand the question. I suppose one shortest distance between the nodes source and destination. But it means \"all\" shortest distance between the nodes source and destination the sum of the weights should match the target."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "in your output, the shortest path from 2 to 3 is 2->0->3 with length 7. It is incorrect\\n\\nIt\\'s a really difficult problem bro, that kind of stuff is only the tip of the iceberg of debugging you;ll have to go through before getting AC"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "2 ques gang?!"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why there is a 2300 rating problem from codeforces in a leetcode contest?\\nhttps://codeforces.com/problemset/problem/715/B"
                    },
                    {
                        "username": "shivansh961",
                        "content": "LeetCode is high."
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "4\\n[[0,1,-1],[2,0,2],[3,2,6],[2,1,10],[3,0,-1]]\\n1\\n3\\n12\\n\\nmy output : [[0,1,1],[2,0,2],[3,2,6],[2,1,10],[3,0,11]]\\nexpected : [[0,1,11],[2,0,2],[3,2,6],[2,1,10],[3,0,1]]\\nthe question says if there are multiple modifications return any of them, then why is my output wrong."
                    },
                    {
                        "username": "vikassuthar528",
                        "content": "I\\'m also getting same test case wrong."
                    },
                    {
                        "username": "krobzh",
                        "content": " In your output, the shortest distance from 1 to 3 is 1->0->2->3 which is 9,  not 12. I got the similar error in another test case in which I break the original shortest path and made a shorter path.  "
                    },
                    {
                        "username": "aniketkr01",
                        "content": "Same happened with me"
                    },
                    {
                        "username": "HLeiTR",
                        "content": "I am a little bit confused on this test case: \n\n```\nn = 5\nedges = [[1,4,1],[2,4,-1],[3,0,2],[0,4,-1],[1,3,10],[1,0,10]]\nsource = 0\ndestination = 2\ntarget = 15\n```\n\nNotice that in this graph, the only paths from 0 to 2 are: \n0 -> 3 -> 1 -> 4 -> 2, with cost 2 + 10 + 1 = 13 and 1 changeable\n0 -> 4 -> 2, with cost 0 and 2 changeable\n0 -> 1 -> 4 -> 2, with cost 10 + 1 and 1 changeable\n\nThe expected answer is: \n`[[1,4,1],[2,4,4],[3,0,2],[0,4,14],[1,3,10],[1,0,10]]`\nWhich suggests that it took the third path, and changing the weight of (2, 4) to 4. \n(Also, I'm not sure why it changed the edge of 0 to 4 to have a weight of 14, it is not even used?)\n\nHowever, my answer is:\n`[[1,4,1],[2,4,1],[3,0,2],[0,4,14],[1,3,10],[1,0,10]]`\nWhich took the second path, and changing one of the weights to 14 and the other to 1. \nThen, I changed all other unused, changeable edges to have weight 1. \n\nShouldn't this also be considered correct by the problem description? \nAny help is appreciated, very confused on this question :c"
                    },
                    {
                        "username": "Hackytech",
                        "content": "[@Finesse](/Finesse) No matter how many times I read the question or go through some solutions, i am not able to identify what is the meaning of shortest path over here. It's definitely not the sum of edges because it has to be equal to target so no matter which valid path you choose, we can make it equal to target. So is it the number of edges between the source and destination. I am too confused, please correct me If I am wrong at some point. \n Thanks"
                    },
                    {
                        "username": "HLeiTR",
                        "content": "[@Finesse](/Finesse) \\n! Ahh\\nI see the problem now, thanks a lot!"
                    },
                    {
                        "username": "Finesse",
                        "content": "> Then, I changed all other unused, changeable edges to have weight 1\n\n...and made another path be shorter than 15. That's your mistake.\n\nAfter changing the weights, all the other path distances must be recalculated, and the smallest must equal target.\n\nChange the unused edge weights to the maximum instead."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "For the following testcase, why is the answer an empty matrix?\\n\\n`n = 4,\\nedges = [[0,1,-1],[1,2,-1],[3,1,-1],[3,0,2],[0,2,5]],\\nsource = 2,\\ndestination = 3,\\ntarget = 8`"
                    },
                    {
                        "username": "monster_10",
                        "content": "Time complexity is O(M*M*LOG(V)) it runs fine but doesn\\'t comply with the constraints as it should give TLE"
                    },
                    {
                        "username": "dmitryartux",
                        "content": ">If the shortest path from source to destination including the edges to be modified and assigning them a temporary weight of 1, is less than the target, then it is also not possible.\\n\\n**Looks like the Hint #3 is wrong**"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Yes, should be \\'MORE than the target\\'."
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "The 3rd hint is wrong, instead of \"less than the target\", it should be \"greater than the target\".  "
                    }
                ]
            },
            {
                "id": 1900484,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "This is the last time I attempt the hard problem before the medium in a contest! \\nHonestly, this one didn;t look too bad at first, just a modified Djikstra, right?\\nOh boy, was I wrong"
                    },
                    {
                        "username": "Finesse",
                        "content": "I've managed to solve using a single modified Dijkstra's cycle. Throughout every path with `distance≤target`, you need to find the one with the fewest `-1` edges (the `-1` edges add the minimum weight which is `1`). To implement it, don't sort the heap by the distance; sort by the number of `-1` edges first, and then by the distance. If that path has no `-1` edges, the answer is `[]`, otherwise fill all the edges on the path with some weights to meet the target and the other edges with `2e9`. [My code.](https://leetcode.com/problems/modify-graph-edge-weights/submissions/954301674/)"
                    },
                    {
                        "username": "jasonechiu",
                        "content": "The test case seems incorrect.\\nFor testcase `353`\\nn = 4\\nedges = [[0,1,-1],[1,2,-1],[3,1,-1],[3,0,2],[0,2,5]]\\nsource = 2\\ndestination = 3\\ntarget = 8\\n\\nMy output is [[0,1,1],[1,2,1],[3,1,7],[3,0,2],[0,2,5]]\\nWhich means we can travel 2 -> 1 -> 3 and the sum is 8\\nBut it expect []\\n\\n\\nIt seems the solution is wrong."
                    },
                    {
                        "username": "Chrishu5777",
                        "content": "[@cartesPerforees](/cartesPerforees) thanks!!"
                    },
                    {
                        "username": "narang_madhur",
                        "content": "[@cartesPerforees](/cartesPerforees) Thanks for pointing out the error in output logic...I understood my mistake too.\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@jasonechiu](/jasonechiu) yup. The shortest of all distances from source to destination has to be target.\\nReally tough problem"
                    },
                    {
                        "username": "jasonechiu",
                        "content": "[@cartesPerforees](/cartesPerforees) \\nThanks for reply, I misunderstand the question. I suppose one shortest distance between the nodes source and destination. But it means \"all\" shortest distance between the nodes source and destination the sum of the weights should match the target."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "in your output, the shortest path from 2 to 3 is 2->0->3 with length 7. It is incorrect\\n\\nIt\\'s a really difficult problem bro, that kind of stuff is only the tip of the iceberg of debugging you;ll have to go through before getting AC"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "2 ques gang?!"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why there is a 2300 rating problem from codeforces in a leetcode contest?\\nhttps://codeforces.com/problemset/problem/715/B"
                    },
                    {
                        "username": "shivansh961",
                        "content": "LeetCode is high."
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "4\\n[[0,1,-1],[2,0,2],[3,2,6],[2,1,10],[3,0,-1]]\\n1\\n3\\n12\\n\\nmy output : [[0,1,1],[2,0,2],[3,2,6],[2,1,10],[3,0,11]]\\nexpected : [[0,1,11],[2,0,2],[3,2,6],[2,1,10],[3,0,1]]\\nthe question says if there are multiple modifications return any of them, then why is my output wrong."
                    },
                    {
                        "username": "vikassuthar528",
                        "content": "I\\'m also getting same test case wrong."
                    },
                    {
                        "username": "krobzh",
                        "content": " In your output, the shortest distance from 1 to 3 is 1->0->2->3 which is 9,  not 12. I got the similar error in another test case in which I break the original shortest path and made a shorter path.  "
                    },
                    {
                        "username": "aniketkr01",
                        "content": "Same happened with me"
                    },
                    {
                        "username": "HLeiTR",
                        "content": "I am a little bit confused on this test case: \n\n```\nn = 5\nedges = [[1,4,1],[2,4,-1],[3,0,2],[0,4,-1],[1,3,10],[1,0,10]]\nsource = 0\ndestination = 2\ntarget = 15\n```\n\nNotice that in this graph, the only paths from 0 to 2 are: \n0 -> 3 -> 1 -> 4 -> 2, with cost 2 + 10 + 1 = 13 and 1 changeable\n0 -> 4 -> 2, with cost 0 and 2 changeable\n0 -> 1 -> 4 -> 2, with cost 10 + 1 and 1 changeable\n\nThe expected answer is: \n`[[1,4,1],[2,4,4],[3,0,2],[0,4,14],[1,3,10],[1,0,10]]`\nWhich suggests that it took the third path, and changing the weight of (2, 4) to 4. \n(Also, I'm not sure why it changed the edge of 0 to 4 to have a weight of 14, it is not even used?)\n\nHowever, my answer is:\n`[[1,4,1],[2,4,1],[3,0,2],[0,4,14],[1,3,10],[1,0,10]]`\nWhich took the second path, and changing one of the weights to 14 and the other to 1. \nThen, I changed all other unused, changeable edges to have weight 1. \n\nShouldn't this also be considered correct by the problem description? \nAny help is appreciated, very confused on this question :c"
                    },
                    {
                        "username": "Hackytech",
                        "content": "[@Finesse](/Finesse) No matter how many times I read the question or go through some solutions, i am not able to identify what is the meaning of shortest path over here. It's definitely not the sum of edges because it has to be equal to target so no matter which valid path you choose, we can make it equal to target. So is it the number of edges between the source and destination. I am too confused, please correct me If I am wrong at some point. \n Thanks"
                    },
                    {
                        "username": "HLeiTR",
                        "content": "[@Finesse](/Finesse) \\n! Ahh\\nI see the problem now, thanks a lot!"
                    },
                    {
                        "username": "Finesse",
                        "content": "> Then, I changed all other unused, changeable edges to have weight 1\n\n...and made another path be shorter than 15. That's your mistake.\n\nAfter changing the weights, all the other path distances must be recalculated, and the smallest must equal target.\n\nChange the unused edge weights to the maximum instead."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "For the following testcase, why is the answer an empty matrix?\\n\\n`n = 4,\\nedges = [[0,1,-1],[1,2,-1],[3,1,-1],[3,0,2],[0,2,5]],\\nsource = 2,\\ndestination = 3,\\ntarget = 8`"
                    },
                    {
                        "username": "monster_10",
                        "content": "Time complexity is O(M*M*LOG(V)) it runs fine but doesn\\'t comply with the constraints as it should give TLE"
                    },
                    {
                        "username": "dmitryartux",
                        "content": ">If the shortest path from source to destination including the edges to be modified and assigning them a temporary weight of 1, is less than the target, then it is also not possible.\\n\\n**Looks like the Hint #3 is wrong**"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Yes, should be \\'MORE than the target\\'."
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "The 3rd hint is wrong, instead of \"less than the target\", it should be \"greater than the target\".  "
                    }
                ]
            },
            {
                "id": 1901172,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "This is the last time I attempt the hard problem before the medium in a contest! \\nHonestly, this one didn;t look too bad at first, just a modified Djikstra, right?\\nOh boy, was I wrong"
                    },
                    {
                        "username": "Finesse",
                        "content": "I've managed to solve using a single modified Dijkstra's cycle. Throughout every path with `distance≤target`, you need to find the one with the fewest `-1` edges (the `-1` edges add the minimum weight which is `1`). To implement it, don't sort the heap by the distance; sort by the number of `-1` edges first, and then by the distance. If that path has no `-1` edges, the answer is `[]`, otherwise fill all the edges on the path with some weights to meet the target and the other edges with `2e9`. [My code.](https://leetcode.com/problems/modify-graph-edge-weights/submissions/954301674/)"
                    },
                    {
                        "username": "jasonechiu",
                        "content": "The test case seems incorrect.\\nFor testcase `353`\\nn = 4\\nedges = [[0,1,-1],[1,2,-1],[3,1,-1],[3,0,2],[0,2,5]]\\nsource = 2\\ndestination = 3\\ntarget = 8\\n\\nMy output is [[0,1,1],[1,2,1],[3,1,7],[3,0,2],[0,2,5]]\\nWhich means we can travel 2 -> 1 -> 3 and the sum is 8\\nBut it expect []\\n\\n\\nIt seems the solution is wrong."
                    },
                    {
                        "username": "Chrishu5777",
                        "content": "[@cartesPerforees](/cartesPerforees) thanks!!"
                    },
                    {
                        "username": "narang_madhur",
                        "content": "[@cartesPerforees](/cartesPerforees) Thanks for pointing out the error in output logic...I understood my mistake too.\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@jasonechiu](/jasonechiu) yup. The shortest of all distances from source to destination has to be target.\\nReally tough problem"
                    },
                    {
                        "username": "jasonechiu",
                        "content": "[@cartesPerforees](/cartesPerforees) \\nThanks for reply, I misunderstand the question. I suppose one shortest distance between the nodes source and destination. But it means \"all\" shortest distance between the nodes source and destination the sum of the weights should match the target."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "in your output, the shortest path from 2 to 3 is 2->0->3 with length 7. It is incorrect\\n\\nIt\\'s a really difficult problem bro, that kind of stuff is only the tip of the iceberg of debugging you;ll have to go through before getting AC"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "2 ques gang?!"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why there is a 2300 rating problem from codeforces in a leetcode contest?\\nhttps://codeforces.com/problemset/problem/715/B"
                    },
                    {
                        "username": "shivansh961",
                        "content": "LeetCode is high."
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "4\\n[[0,1,-1],[2,0,2],[3,2,6],[2,1,10],[3,0,-1]]\\n1\\n3\\n12\\n\\nmy output : [[0,1,1],[2,0,2],[3,2,6],[2,1,10],[3,0,11]]\\nexpected : [[0,1,11],[2,0,2],[3,2,6],[2,1,10],[3,0,1]]\\nthe question says if there are multiple modifications return any of them, then why is my output wrong."
                    },
                    {
                        "username": "vikassuthar528",
                        "content": "I\\'m also getting same test case wrong."
                    },
                    {
                        "username": "krobzh",
                        "content": " In your output, the shortest distance from 1 to 3 is 1->0->2->3 which is 9,  not 12. I got the similar error in another test case in which I break the original shortest path and made a shorter path.  "
                    },
                    {
                        "username": "aniketkr01",
                        "content": "Same happened with me"
                    },
                    {
                        "username": "HLeiTR",
                        "content": "I am a little bit confused on this test case: \n\n```\nn = 5\nedges = [[1,4,1],[2,4,-1],[3,0,2],[0,4,-1],[1,3,10],[1,0,10]]\nsource = 0\ndestination = 2\ntarget = 15\n```\n\nNotice that in this graph, the only paths from 0 to 2 are: \n0 -> 3 -> 1 -> 4 -> 2, with cost 2 + 10 + 1 = 13 and 1 changeable\n0 -> 4 -> 2, with cost 0 and 2 changeable\n0 -> 1 -> 4 -> 2, with cost 10 + 1 and 1 changeable\n\nThe expected answer is: \n`[[1,4,1],[2,4,4],[3,0,2],[0,4,14],[1,3,10],[1,0,10]]`\nWhich suggests that it took the third path, and changing the weight of (2, 4) to 4. \n(Also, I'm not sure why it changed the edge of 0 to 4 to have a weight of 14, it is not even used?)\n\nHowever, my answer is:\n`[[1,4,1],[2,4,1],[3,0,2],[0,4,14],[1,3,10],[1,0,10]]`\nWhich took the second path, and changing one of the weights to 14 and the other to 1. \nThen, I changed all other unused, changeable edges to have weight 1. \n\nShouldn't this also be considered correct by the problem description? \nAny help is appreciated, very confused on this question :c"
                    },
                    {
                        "username": "Hackytech",
                        "content": "[@Finesse](/Finesse) No matter how many times I read the question or go through some solutions, i am not able to identify what is the meaning of shortest path over here. It's definitely not the sum of edges because it has to be equal to target so no matter which valid path you choose, we can make it equal to target. So is it the number of edges between the source and destination. I am too confused, please correct me If I am wrong at some point. \n Thanks"
                    },
                    {
                        "username": "HLeiTR",
                        "content": "[@Finesse](/Finesse) \\n! Ahh\\nI see the problem now, thanks a lot!"
                    },
                    {
                        "username": "Finesse",
                        "content": "> Then, I changed all other unused, changeable edges to have weight 1\n\n...and made another path be shorter than 15. That's your mistake.\n\nAfter changing the weights, all the other path distances must be recalculated, and the smallest must equal target.\n\nChange the unused edge weights to the maximum instead."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "For the following testcase, why is the answer an empty matrix?\\n\\n`n = 4,\\nedges = [[0,1,-1],[1,2,-1],[3,1,-1],[3,0,2],[0,2,5]],\\nsource = 2,\\ndestination = 3,\\ntarget = 8`"
                    },
                    {
                        "username": "monster_10",
                        "content": "Time complexity is O(M*M*LOG(V)) it runs fine but doesn\\'t comply with the constraints as it should give TLE"
                    },
                    {
                        "username": "dmitryartux",
                        "content": ">If the shortest path from source to destination including the edges to be modified and assigning them a temporary weight of 1, is less than the target, then it is also not possible.\\n\\n**Looks like the Hint #3 is wrong**"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Yes, should be \\'MORE than the target\\'."
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "The 3rd hint is wrong, instead of \"less than the target\", it should be \"greater than the target\".  "
                    }
                ]
            },
            {
                "id": 1900778,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "This is the last time I attempt the hard problem before the medium in a contest! \\nHonestly, this one didn;t look too bad at first, just a modified Djikstra, right?\\nOh boy, was I wrong"
                    },
                    {
                        "username": "Finesse",
                        "content": "I've managed to solve using a single modified Dijkstra's cycle. Throughout every path with `distance≤target`, you need to find the one with the fewest `-1` edges (the `-1` edges add the minimum weight which is `1`). To implement it, don't sort the heap by the distance; sort by the number of `-1` edges first, and then by the distance. If that path has no `-1` edges, the answer is `[]`, otherwise fill all the edges on the path with some weights to meet the target and the other edges with `2e9`. [My code.](https://leetcode.com/problems/modify-graph-edge-weights/submissions/954301674/)"
                    },
                    {
                        "username": "jasonechiu",
                        "content": "The test case seems incorrect.\\nFor testcase `353`\\nn = 4\\nedges = [[0,1,-1],[1,2,-1],[3,1,-1],[3,0,2],[0,2,5]]\\nsource = 2\\ndestination = 3\\ntarget = 8\\n\\nMy output is [[0,1,1],[1,2,1],[3,1,7],[3,0,2],[0,2,5]]\\nWhich means we can travel 2 -> 1 -> 3 and the sum is 8\\nBut it expect []\\n\\n\\nIt seems the solution is wrong."
                    },
                    {
                        "username": "Chrishu5777",
                        "content": "[@cartesPerforees](/cartesPerforees) thanks!!"
                    },
                    {
                        "username": "narang_madhur",
                        "content": "[@cartesPerforees](/cartesPerforees) Thanks for pointing out the error in output logic...I understood my mistake too.\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@jasonechiu](/jasonechiu) yup. The shortest of all distances from source to destination has to be target.\\nReally tough problem"
                    },
                    {
                        "username": "jasonechiu",
                        "content": "[@cartesPerforees](/cartesPerforees) \\nThanks for reply, I misunderstand the question. I suppose one shortest distance between the nodes source and destination. But it means \"all\" shortest distance between the nodes source and destination the sum of the weights should match the target."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "in your output, the shortest path from 2 to 3 is 2->0->3 with length 7. It is incorrect\\n\\nIt\\'s a really difficult problem bro, that kind of stuff is only the tip of the iceberg of debugging you;ll have to go through before getting AC"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "2 ques gang?!"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why there is a 2300 rating problem from codeforces in a leetcode contest?\\nhttps://codeforces.com/problemset/problem/715/B"
                    },
                    {
                        "username": "shivansh961",
                        "content": "LeetCode is high."
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "4\\n[[0,1,-1],[2,0,2],[3,2,6],[2,1,10],[3,0,-1]]\\n1\\n3\\n12\\n\\nmy output : [[0,1,1],[2,0,2],[3,2,6],[2,1,10],[3,0,11]]\\nexpected : [[0,1,11],[2,0,2],[3,2,6],[2,1,10],[3,0,1]]\\nthe question says if there are multiple modifications return any of them, then why is my output wrong."
                    },
                    {
                        "username": "vikassuthar528",
                        "content": "I\\'m also getting same test case wrong."
                    },
                    {
                        "username": "krobzh",
                        "content": " In your output, the shortest distance from 1 to 3 is 1->0->2->3 which is 9,  not 12. I got the similar error in another test case in which I break the original shortest path and made a shorter path.  "
                    },
                    {
                        "username": "aniketkr01",
                        "content": "Same happened with me"
                    },
                    {
                        "username": "HLeiTR",
                        "content": "I am a little bit confused on this test case: \n\n```\nn = 5\nedges = [[1,4,1],[2,4,-1],[3,0,2],[0,4,-1],[1,3,10],[1,0,10]]\nsource = 0\ndestination = 2\ntarget = 15\n```\n\nNotice that in this graph, the only paths from 0 to 2 are: \n0 -> 3 -> 1 -> 4 -> 2, with cost 2 + 10 + 1 = 13 and 1 changeable\n0 -> 4 -> 2, with cost 0 and 2 changeable\n0 -> 1 -> 4 -> 2, with cost 10 + 1 and 1 changeable\n\nThe expected answer is: \n`[[1,4,1],[2,4,4],[3,0,2],[0,4,14],[1,3,10],[1,0,10]]`\nWhich suggests that it took the third path, and changing the weight of (2, 4) to 4. \n(Also, I'm not sure why it changed the edge of 0 to 4 to have a weight of 14, it is not even used?)\n\nHowever, my answer is:\n`[[1,4,1],[2,4,1],[3,0,2],[0,4,14],[1,3,10],[1,0,10]]`\nWhich took the second path, and changing one of the weights to 14 and the other to 1. \nThen, I changed all other unused, changeable edges to have weight 1. \n\nShouldn't this also be considered correct by the problem description? \nAny help is appreciated, very confused on this question :c"
                    },
                    {
                        "username": "Hackytech",
                        "content": "[@Finesse](/Finesse) No matter how many times I read the question or go through some solutions, i am not able to identify what is the meaning of shortest path over here. It's definitely not the sum of edges because it has to be equal to target so no matter which valid path you choose, we can make it equal to target. So is it the number of edges between the source and destination. I am too confused, please correct me If I am wrong at some point. \n Thanks"
                    },
                    {
                        "username": "HLeiTR",
                        "content": "[@Finesse](/Finesse) \\n! Ahh\\nI see the problem now, thanks a lot!"
                    },
                    {
                        "username": "Finesse",
                        "content": "> Then, I changed all other unused, changeable edges to have weight 1\n\n...and made another path be shorter than 15. That's your mistake.\n\nAfter changing the weights, all the other path distances must be recalculated, and the smallest must equal target.\n\nChange the unused edge weights to the maximum instead."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "For the following testcase, why is the answer an empty matrix?\\n\\n`n = 4,\\nedges = [[0,1,-1],[1,2,-1],[3,1,-1],[3,0,2],[0,2,5]],\\nsource = 2,\\ndestination = 3,\\ntarget = 8`"
                    },
                    {
                        "username": "monster_10",
                        "content": "Time complexity is O(M*M*LOG(V)) it runs fine but doesn\\'t comply with the constraints as it should give TLE"
                    },
                    {
                        "username": "dmitryartux",
                        "content": ">If the shortest path from source to destination including the edges to be modified and assigning them a temporary weight of 1, is less than the target, then it is also not possible.\\n\\n**Looks like the Hint #3 is wrong**"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Yes, should be \\'MORE than the target\\'."
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "The 3rd hint is wrong, instead of \"less than the target\", it should be \"greater than the target\".  "
                    }
                ]
            },
            {
                "id": 1996902,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "This is the last time I attempt the hard problem before the medium in a contest! \\nHonestly, this one didn;t look too bad at first, just a modified Djikstra, right?\\nOh boy, was I wrong"
                    },
                    {
                        "username": "Finesse",
                        "content": "I've managed to solve using a single modified Dijkstra's cycle. Throughout every path with `distance≤target`, you need to find the one with the fewest `-1` edges (the `-1` edges add the minimum weight which is `1`). To implement it, don't sort the heap by the distance; sort by the number of `-1` edges first, and then by the distance. If that path has no `-1` edges, the answer is `[]`, otherwise fill all the edges on the path with some weights to meet the target and the other edges with `2e9`. [My code.](https://leetcode.com/problems/modify-graph-edge-weights/submissions/954301674/)"
                    },
                    {
                        "username": "jasonechiu",
                        "content": "The test case seems incorrect.\\nFor testcase `353`\\nn = 4\\nedges = [[0,1,-1],[1,2,-1],[3,1,-1],[3,0,2],[0,2,5]]\\nsource = 2\\ndestination = 3\\ntarget = 8\\n\\nMy output is [[0,1,1],[1,2,1],[3,1,7],[3,0,2],[0,2,5]]\\nWhich means we can travel 2 -> 1 -> 3 and the sum is 8\\nBut it expect []\\n\\n\\nIt seems the solution is wrong."
                    },
                    {
                        "username": "Chrishu5777",
                        "content": "[@cartesPerforees](/cartesPerforees) thanks!!"
                    },
                    {
                        "username": "narang_madhur",
                        "content": "[@cartesPerforees](/cartesPerforees) Thanks for pointing out the error in output logic...I understood my mistake too.\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@jasonechiu](/jasonechiu) yup. The shortest of all distances from source to destination has to be target.\\nReally tough problem"
                    },
                    {
                        "username": "jasonechiu",
                        "content": "[@cartesPerforees](/cartesPerforees) \\nThanks for reply, I misunderstand the question. I suppose one shortest distance between the nodes source and destination. But it means \"all\" shortest distance between the nodes source and destination the sum of the weights should match the target."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "in your output, the shortest path from 2 to 3 is 2->0->3 with length 7. It is incorrect\\n\\nIt\\'s a really difficult problem bro, that kind of stuff is only the tip of the iceberg of debugging you;ll have to go through before getting AC"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "2 ques gang?!"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why there is a 2300 rating problem from codeforces in a leetcode contest?\\nhttps://codeforces.com/problemset/problem/715/B"
                    },
                    {
                        "username": "shivansh961",
                        "content": "LeetCode is high."
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "4\\n[[0,1,-1],[2,0,2],[3,2,6],[2,1,10],[3,0,-1]]\\n1\\n3\\n12\\n\\nmy output : [[0,1,1],[2,0,2],[3,2,6],[2,1,10],[3,0,11]]\\nexpected : [[0,1,11],[2,0,2],[3,2,6],[2,1,10],[3,0,1]]\\nthe question says if there are multiple modifications return any of them, then why is my output wrong."
                    },
                    {
                        "username": "vikassuthar528",
                        "content": "I\\'m also getting same test case wrong."
                    },
                    {
                        "username": "krobzh",
                        "content": " In your output, the shortest distance from 1 to 3 is 1->0->2->3 which is 9,  not 12. I got the similar error in another test case in which I break the original shortest path and made a shorter path.  "
                    },
                    {
                        "username": "aniketkr01",
                        "content": "Same happened with me"
                    },
                    {
                        "username": "HLeiTR",
                        "content": "I am a little bit confused on this test case: \n\n```\nn = 5\nedges = [[1,4,1],[2,4,-1],[3,0,2],[0,4,-1],[1,3,10],[1,0,10]]\nsource = 0\ndestination = 2\ntarget = 15\n```\n\nNotice that in this graph, the only paths from 0 to 2 are: \n0 -> 3 -> 1 -> 4 -> 2, with cost 2 + 10 + 1 = 13 and 1 changeable\n0 -> 4 -> 2, with cost 0 and 2 changeable\n0 -> 1 -> 4 -> 2, with cost 10 + 1 and 1 changeable\n\nThe expected answer is: \n`[[1,4,1],[2,4,4],[3,0,2],[0,4,14],[1,3,10],[1,0,10]]`\nWhich suggests that it took the third path, and changing the weight of (2, 4) to 4. \n(Also, I'm not sure why it changed the edge of 0 to 4 to have a weight of 14, it is not even used?)\n\nHowever, my answer is:\n`[[1,4,1],[2,4,1],[3,0,2],[0,4,14],[1,3,10],[1,0,10]]`\nWhich took the second path, and changing one of the weights to 14 and the other to 1. \nThen, I changed all other unused, changeable edges to have weight 1. \n\nShouldn't this also be considered correct by the problem description? \nAny help is appreciated, very confused on this question :c"
                    },
                    {
                        "username": "Hackytech",
                        "content": "[@Finesse](/Finesse) No matter how many times I read the question or go through some solutions, i am not able to identify what is the meaning of shortest path over here. It's definitely not the sum of edges because it has to be equal to target so no matter which valid path you choose, we can make it equal to target. So is it the number of edges between the source and destination. I am too confused, please correct me If I am wrong at some point. \n Thanks"
                    },
                    {
                        "username": "HLeiTR",
                        "content": "[@Finesse](/Finesse) \\n! Ahh\\nI see the problem now, thanks a lot!"
                    },
                    {
                        "username": "Finesse",
                        "content": "> Then, I changed all other unused, changeable edges to have weight 1\n\n...and made another path be shorter than 15. That's your mistake.\n\nAfter changing the weights, all the other path distances must be recalculated, and the smallest must equal target.\n\nChange the unused edge weights to the maximum instead."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "For the following testcase, why is the answer an empty matrix?\\n\\n`n = 4,\\nedges = [[0,1,-1],[1,2,-1],[3,1,-1],[3,0,2],[0,2,5]],\\nsource = 2,\\ndestination = 3,\\ntarget = 8`"
                    },
                    {
                        "username": "monster_10",
                        "content": "Time complexity is O(M*M*LOG(V)) it runs fine but doesn\\'t comply with the constraints as it should give TLE"
                    },
                    {
                        "username": "dmitryartux",
                        "content": ">If the shortest path from source to destination including the edges to be modified and assigning them a temporary weight of 1, is less than the target, then it is also not possible.\\n\\n**Looks like the Hint #3 is wrong**"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Yes, should be \\'MORE than the target\\'."
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "The 3rd hint is wrong, instead of \"less than the target\", it should be \"greater than the target\".  "
                    }
                ]
            },
            {
                "id": 1933171,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "This is the last time I attempt the hard problem before the medium in a contest! \\nHonestly, this one didn;t look too bad at first, just a modified Djikstra, right?\\nOh boy, was I wrong"
                    },
                    {
                        "username": "Finesse",
                        "content": "I've managed to solve using a single modified Dijkstra's cycle. Throughout every path with `distance≤target`, you need to find the one with the fewest `-1` edges (the `-1` edges add the minimum weight which is `1`). To implement it, don't sort the heap by the distance; sort by the number of `-1` edges first, and then by the distance. If that path has no `-1` edges, the answer is `[]`, otherwise fill all the edges on the path with some weights to meet the target and the other edges with `2e9`. [My code.](https://leetcode.com/problems/modify-graph-edge-weights/submissions/954301674/)"
                    },
                    {
                        "username": "jasonechiu",
                        "content": "The test case seems incorrect.\\nFor testcase `353`\\nn = 4\\nedges = [[0,1,-1],[1,2,-1],[3,1,-1],[3,0,2],[0,2,5]]\\nsource = 2\\ndestination = 3\\ntarget = 8\\n\\nMy output is [[0,1,1],[1,2,1],[3,1,7],[3,0,2],[0,2,5]]\\nWhich means we can travel 2 -> 1 -> 3 and the sum is 8\\nBut it expect []\\n\\n\\nIt seems the solution is wrong."
                    },
                    {
                        "username": "Chrishu5777",
                        "content": "[@cartesPerforees](/cartesPerforees) thanks!!"
                    },
                    {
                        "username": "narang_madhur",
                        "content": "[@cartesPerforees](/cartesPerforees) Thanks for pointing out the error in output logic...I understood my mistake too.\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@jasonechiu](/jasonechiu) yup. The shortest of all distances from source to destination has to be target.\\nReally tough problem"
                    },
                    {
                        "username": "jasonechiu",
                        "content": "[@cartesPerforees](/cartesPerforees) \\nThanks for reply, I misunderstand the question. I suppose one shortest distance between the nodes source and destination. But it means \"all\" shortest distance between the nodes source and destination the sum of the weights should match the target."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "in your output, the shortest path from 2 to 3 is 2->0->3 with length 7. It is incorrect\\n\\nIt\\'s a really difficult problem bro, that kind of stuff is only the tip of the iceberg of debugging you;ll have to go through before getting AC"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "2 ques gang?!"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why there is a 2300 rating problem from codeforces in a leetcode contest?\\nhttps://codeforces.com/problemset/problem/715/B"
                    },
                    {
                        "username": "shivansh961",
                        "content": "LeetCode is high."
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "4\\n[[0,1,-1],[2,0,2],[3,2,6],[2,1,10],[3,0,-1]]\\n1\\n3\\n12\\n\\nmy output : [[0,1,1],[2,0,2],[3,2,6],[2,1,10],[3,0,11]]\\nexpected : [[0,1,11],[2,0,2],[3,2,6],[2,1,10],[3,0,1]]\\nthe question says if there are multiple modifications return any of them, then why is my output wrong."
                    },
                    {
                        "username": "vikassuthar528",
                        "content": "I\\'m also getting same test case wrong."
                    },
                    {
                        "username": "krobzh",
                        "content": " In your output, the shortest distance from 1 to 3 is 1->0->2->3 which is 9,  not 12. I got the similar error in another test case in which I break the original shortest path and made a shorter path.  "
                    },
                    {
                        "username": "aniketkr01",
                        "content": "Same happened with me"
                    },
                    {
                        "username": "HLeiTR",
                        "content": "I am a little bit confused on this test case: \n\n```\nn = 5\nedges = [[1,4,1],[2,4,-1],[3,0,2],[0,4,-1],[1,3,10],[1,0,10]]\nsource = 0\ndestination = 2\ntarget = 15\n```\n\nNotice that in this graph, the only paths from 0 to 2 are: \n0 -> 3 -> 1 -> 4 -> 2, with cost 2 + 10 + 1 = 13 and 1 changeable\n0 -> 4 -> 2, with cost 0 and 2 changeable\n0 -> 1 -> 4 -> 2, with cost 10 + 1 and 1 changeable\n\nThe expected answer is: \n`[[1,4,1],[2,4,4],[3,0,2],[0,4,14],[1,3,10],[1,0,10]]`\nWhich suggests that it took the third path, and changing the weight of (2, 4) to 4. \n(Also, I'm not sure why it changed the edge of 0 to 4 to have a weight of 14, it is not even used?)\n\nHowever, my answer is:\n`[[1,4,1],[2,4,1],[3,0,2],[0,4,14],[1,3,10],[1,0,10]]`\nWhich took the second path, and changing one of the weights to 14 and the other to 1. \nThen, I changed all other unused, changeable edges to have weight 1. \n\nShouldn't this also be considered correct by the problem description? \nAny help is appreciated, very confused on this question :c"
                    },
                    {
                        "username": "Hackytech",
                        "content": "[@Finesse](/Finesse) No matter how many times I read the question or go through some solutions, i am not able to identify what is the meaning of shortest path over here. It's definitely not the sum of edges because it has to be equal to target so no matter which valid path you choose, we can make it equal to target. So is it the number of edges between the source and destination. I am too confused, please correct me If I am wrong at some point. \n Thanks"
                    },
                    {
                        "username": "HLeiTR",
                        "content": "[@Finesse](/Finesse) \\n! Ahh\\nI see the problem now, thanks a lot!"
                    },
                    {
                        "username": "Finesse",
                        "content": "> Then, I changed all other unused, changeable edges to have weight 1\n\n...and made another path be shorter than 15. That's your mistake.\n\nAfter changing the weights, all the other path distances must be recalculated, and the smallest must equal target.\n\nChange the unused edge weights to the maximum instead."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "For the following testcase, why is the answer an empty matrix?\\n\\n`n = 4,\\nedges = [[0,1,-1],[1,2,-1],[3,1,-1],[3,0,2],[0,2,5]],\\nsource = 2,\\ndestination = 3,\\ntarget = 8`"
                    },
                    {
                        "username": "monster_10",
                        "content": "Time complexity is O(M*M*LOG(V)) it runs fine but doesn\\'t comply with the constraints as it should give TLE"
                    },
                    {
                        "username": "dmitryartux",
                        "content": ">If the shortest path from source to destination including the edges to be modified and assigning them a temporary weight of 1, is less than the target, then it is also not possible.\\n\\n**Looks like the Hint #3 is wrong**"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Yes, should be \\'MORE than the target\\'."
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "The 3rd hint is wrong, instead of \"less than the target\", it should be \"greater than the target\".  "
                    }
                ]
            },
            {
                "id": 1902326,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "This is the last time I attempt the hard problem before the medium in a contest! \\nHonestly, this one didn;t look too bad at first, just a modified Djikstra, right?\\nOh boy, was I wrong"
                    },
                    {
                        "username": "Finesse",
                        "content": "I've managed to solve using a single modified Dijkstra's cycle. Throughout every path with `distance≤target`, you need to find the one with the fewest `-1` edges (the `-1` edges add the minimum weight which is `1`). To implement it, don't sort the heap by the distance; sort by the number of `-1` edges first, and then by the distance. If that path has no `-1` edges, the answer is `[]`, otherwise fill all the edges on the path with some weights to meet the target and the other edges with `2e9`. [My code.](https://leetcode.com/problems/modify-graph-edge-weights/submissions/954301674/)"
                    },
                    {
                        "username": "jasonechiu",
                        "content": "The test case seems incorrect.\\nFor testcase `353`\\nn = 4\\nedges = [[0,1,-1],[1,2,-1],[3,1,-1],[3,0,2],[0,2,5]]\\nsource = 2\\ndestination = 3\\ntarget = 8\\n\\nMy output is [[0,1,1],[1,2,1],[3,1,7],[3,0,2],[0,2,5]]\\nWhich means we can travel 2 -> 1 -> 3 and the sum is 8\\nBut it expect []\\n\\n\\nIt seems the solution is wrong."
                    },
                    {
                        "username": "Chrishu5777",
                        "content": "[@cartesPerforees](/cartesPerforees) thanks!!"
                    },
                    {
                        "username": "narang_madhur",
                        "content": "[@cartesPerforees](/cartesPerforees) Thanks for pointing out the error in output logic...I understood my mistake too.\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@jasonechiu](/jasonechiu) yup. The shortest of all distances from source to destination has to be target.\\nReally tough problem"
                    },
                    {
                        "username": "jasonechiu",
                        "content": "[@cartesPerforees](/cartesPerforees) \\nThanks for reply, I misunderstand the question. I suppose one shortest distance between the nodes source and destination. But it means \"all\" shortest distance between the nodes source and destination the sum of the weights should match the target."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "in your output, the shortest path from 2 to 3 is 2->0->3 with length 7. It is incorrect\\n\\nIt\\'s a really difficult problem bro, that kind of stuff is only the tip of the iceberg of debugging you;ll have to go through before getting AC"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "2 ques gang?!"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why there is a 2300 rating problem from codeforces in a leetcode contest?\\nhttps://codeforces.com/problemset/problem/715/B"
                    },
                    {
                        "username": "shivansh961",
                        "content": "LeetCode is high."
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "4\\n[[0,1,-1],[2,0,2],[3,2,6],[2,1,10],[3,0,-1]]\\n1\\n3\\n12\\n\\nmy output : [[0,1,1],[2,0,2],[3,2,6],[2,1,10],[3,0,11]]\\nexpected : [[0,1,11],[2,0,2],[3,2,6],[2,1,10],[3,0,1]]\\nthe question says if there are multiple modifications return any of them, then why is my output wrong."
                    },
                    {
                        "username": "vikassuthar528",
                        "content": "I\\'m also getting same test case wrong."
                    },
                    {
                        "username": "krobzh",
                        "content": " In your output, the shortest distance from 1 to 3 is 1->0->2->3 which is 9,  not 12. I got the similar error in another test case in which I break the original shortest path and made a shorter path.  "
                    },
                    {
                        "username": "aniketkr01",
                        "content": "Same happened with me"
                    },
                    {
                        "username": "HLeiTR",
                        "content": "I am a little bit confused on this test case: \n\n```\nn = 5\nedges = [[1,4,1],[2,4,-1],[3,0,2],[0,4,-1],[1,3,10],[1,0,10]]\nsource = 0\ndestination = 2\ntarget = 15\n```\n\nNotice that in this graph, the only paths from 0 to 2 are: \n0 -> 3 -> 1 -> 4 -> 2, with cost 2 + 10 + 1 = 13 and 1 changeable\n0 -> 4 -> 2, with cost 0 and 2 changeable\n0 -> 1 -> 4 -> 2, with cost 10 + 1 and 1 changeable\n\nThe expected answer is: \n`[[1,4,1],[2,4,4],[3,0,2],[0,4,14],[1,3,10],[1,0,10]]`\nWhich suggests that it took the third path, and changing the weight of (2, 4) to 4. \n(Also, I'm not sure why it changed the edge of 0 to 4 to have a weight of 14, it is not even used?)\n\nHowever, my answer is:\n`[[1,4,1],[2,4,1],[3,0,2],[0,4,14],[1,3,10],[1,0,10]]`\nWhich took the second path, and changing one of the weights to 14 and the other to 1. \nThen, I changed all other unused, changeable edges to have weight 1. \n\nShouldn't this also be considered correct by the problem description? \nAny help is appreciated, very confused on this question :c"
                    },
                    {
                        "username": "Hackytech",
                        "content": "[@Finesse](/Finesse) No matter how many times I read the question or go through some solutions, i am not able to identify what is the meaning of shortest path over here. It's definitely not the sum of edges because it has to be equal to target so no matter which valid path you choose, we can make it equal to target. So is it the number of edges between the source and destination. I am too confused, please correct me If I am wrong at some point. \n Thanks"
                    },
                    {
                        "username": "HLeiTR",
                        "content": "[@Finesse](/Finesse) \\n! Ahh\\nI see the problem now, thanks a lot!"
                    },
                    {
                        "username": "Finesse",
                        "content": "> Then, I changed all other unused, changeable edges to have weight 1\n\n...and made another path be shorter than 15. That's your mistake.\n\nAfter changing the weights, all the other path distances must be recalculated, and the smallest must equal target.\n\nChange the unused edge weights to the maximum instead."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "For the following testcase, why is the answer an empty matrix?\\n\\n`n = 4,\\nedges = [[0,1,-1],[1,2,-1],[3,1,-1],[3,0,2],[0,2,5]],\\nsource = 2,\\ndestination = 3,\\ntarget = 8`"
                    },
                    {
                        "username": "monster_10",
                        "content": "Time complexity is O(M*M*LOG(V)) it runs fine but doesn\\'t comply with the constraints as it should give TLE"
                    },
                    {
                        "username": "dmitryartux",
                        "content": ">If the shortest path from source to destination including the edges to be modified and assigning them a temporary weight of 1, is less than the target, then it is also not possible.\\n\\n**Looks like the Hint #3 is wrong**"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Yes, should be \\'MORE than the target\\'."
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "The 3rd hint is wrong, instead of \"less than the target\", it should be \"greater than the target\".  "
                    }
                ]
            },
            {
                "id": 1902290,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "This is the last time I attempt the hard problem before the medium in a contest! \\nHonestly, this one didn;t look too bad at first, just a modified Djikstra, right?\\nOh boy, was I wrong"
                    },
                    {
                        "username": "Finesse",
                        "content": "I've managed to solve using a single modified Dijkstra's cycle. Throughout every path with `distance≤target`, you need to find the one with the fewest `-1` edges (the `-1` edges add the minimum weight which is `1`). To implement it, don't sort the heap by the distance; sort by the number of `-1` edges first, and then by the distance. If that path has no `-1` edges, the answer is `[]`, otherwise fill all the edges on the path with some weights to meet the target and the other edges with `2e9`. [My code.](https://leetcode.com/problems/modify-graph-edge-weights/submissions/954301674/)"
                    },
                    {
                        "username": "jasonechiu",
                        "content": "The test case seems incorrect.\\nFor testcase `353`\\nn = 4\\nedges = [[0,1,-1],[1,2,-1],[3,1,-1],[3,0,2],[0,2,5]]\\nsource = 2\\ndestination = 3\\ntarget = 8\\n\\nMy output is [[0,1,1],[1,2,1],[3,1,7],[3,0,2],[0,2,5]]\\nWhich means we can travel 2 -> 1 -> 3 and the sum is 8\\nBut it expect []\\n\\n\\nIt seems the solution is wrong."
                    },
                    {
                        "username": "Chrishu5777",
                        "content": "[@cartesPerforees](/cartesPerforees) thanks!!"
                    },
                    {
                        "username": "narang_madhur",
                        "content": "[@cartesPerforees](/cartesPerforees) Thanks for pointing out the error in output logic...I understood my mistake too.\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@jasonechiu](/jasonechiu) yup. The shortest of all distances from source to destination has to be target.\\nReally tough problem"
                    },
                    {
                        "username": "jasonechiu",
                        "content": "[@cartesPerforees](/cartesPerforees) \\nThanks for reply, I misunderstand the question. I suppose one shortest distance between the nodes source and destination. But it means \"all\" shortest distance between the nodes source and destination the sum of the weights should match the target."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "in your output, the shortest path from 2 to 3 is 2->0->3 with length 7. It is incorrect\\n\\nIt\\'s a really difficult problem bro, that kind of stuff is only the tip of the iceberg of debugging you;ll have to go through before getting AC"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "2 ques gang?!"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why there is a 2300 rating problem from codeforces in a leetcode contest?\\nhttps://codeforces.com/problemset/problem/715/B"
                    },
                    {
                        "username": "shivansh961",
                        "content": "LeetCode is high."
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "4\\n[[0,1,-1],[2,0,2],[3,2,6],[2,1,10],[3,0,-1]]\\n1\\n3\\n12\\n\\nmy output : [[0,1,1],[2,0,2],[3,2,6],[2,1,10],[3,0,11]]\\nexpected : [[0,1,11],[2,0,2],[3,2,6],[2,1,10],[3,0,1]]\\nthe question says if there are multiple modifications return any of them, then why is my output wrong."
                    },
                    {
                        "username": "vikassuthar528",
                        "content": "I\\'m also getting same test case wrong."
                    },
                    {
                        "username": "krobzh",
                        "content": " In your output, the shortest distance from 1 to 3 is 1->0->2->3 which is 9,  not 12. I got the similar error in another test case in which I break the original shortest path and made a shorter path.  "
                    },
                    {
                        "username": "aniketkr01",
                        "content": "Same happened with me"
                    },
                    {
                        "username": "HLeiTR",
                        "content": "I am a little bit confused on this test case: \n\n```\nn = 5\nedges = [[1,4,1],[2,4,-1],[3,0,2],[0,4,-1],[1,3,10],[1,0,10]]\nsource = 0\ndestination = 2\ntarget = 15\n```\n\nNotice that in this graph, the only paths from 0 to 2 are: \n0 -> 3 -> 1 -> 4 -> 2, with cost 2 + 10 + 1 = 13 and 1 changeable\n0 -> 4 -> 2, with cost 0 and 2 changeable\n0 -> 1 -> 4 -> 2, with cost 10 + 1 and 1 changeable\n\nThe expected answer is: \n`[[1,4,1],[2,4,4],[3,0,2],[0,4,14],[1,3,10],[1,0,10]]`\nWhich suggests that it took the third path, and changing the weight of (2, 4) to 4. \n(Also, I'm not sure why it changed the edge of 0 to 4 to have a weight of 14, it is not even used?)\n\nHowever, my answer is:\n`[[1,4,1],[2,4,1],[3,0,2],[0,4,14],[1,3,10],[1,0,10]]`\nWhich took the second path, and changing one of the weights to 14 and the other to 1. \nThen, I changed all other unused, changeable edges to have weight 1. \n\nShouldn't this also be considered correct by the problem description? \nAny help is appreciated, very confused on this question :c"
                    },
                    {
                        "username": "Hackytech",
                        "content": "[@Finesse](/Finesse) No matter how many times I read the question or go through some solutions, i am not able to identify what is the meaning of shortest path over here. It's definitely not the sum of edges because it has to be equal to target so no matter which valid path you choose, we can make it equal to target. So is it the number of edges between the source and destination. I am too confused, please correct me If I am wrong at some point. \n Thanks"
                    },
                    {
                        "username": "HLeiTR",
                        "content": "[@Finesse](/Finesse) \\n! Ahh\\nI see the problem now, thanks a lot!"
                    },
                    {
                        "username": "Finesse",
                        "content": "> Then, I changed all other unused, changeable edges to have weight 1\n\n...and made another path be shorter than 15. That's your mistake.\n\nAfter changing the weights, all the other path distances must be recalculated, and the smallest must equal target.\n\nChange the unused edge weights to the maximum instead."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "For the following testcase, why is the answer an empty matrix?\\n\\n`n = 4,\\nedges = [[0,1,-1],[1,2,-1],[3,1,-1],[3,0,2],[0,2,5]],\\nsource = 2,\\ndestination = 3,\\ntarget = 8`"
                    },
                    {
                        "username": "monster_10",
                        "content": "Time complexity is O(M*M*LOG(V)) it runs fine but doesn\\'t comply with the constraints as it should give TLE"
                    },
                    {
                        "username": "dmitryartux",
                        "content": ">If the shortest path from source to destination including the edges to be modified and assigning them a temporary weight of 1, is less than the target, then it is also not possible.\\n\\n**Looks like the Hint #3 is wrong**"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Yes, should be \\'MORE than the target\\'."
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "The 3rd hint is wrong, instead of \"less than the target\", it should be \"greater than the target\".  "
                    }
                ]
            },
            {
                "id": 1900625,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "This is the last time I attempt the hard problem before the medium in a contest! \\nHonestly, this one didn;t look too bad at first, just a modified Djikstra, right?\\nOh boy, was I wrong"
                    },
                    {
                        "username": "Finesse",
                        "content": "I've managed to solve using a single modified Dijkstra's cycle. Throughout every path with `distance≤target`, you need to find the one with the fewest `-1` edges (the `-1` edges add the minimum weight which is `1`). To implement it, don't sort the heap by the distance; sort by the number of `-1` edges first, and then by the distance. If that path has no `-1` edges, the answer is `[]`, otherwise fill all the edges on the path with some weights to meet the target and the other edges with `2e9`. [My code.](https://leetcode.com/problems/modify-graph-edge-weights/submissions/954301674/)"
                    },
                    {
                        "username": "jasonechiu",
                        "content": "The test case seems incorrect.\\nFor testcase `353`\\nn = 4\\nedges = [[0,1,-1],[1,2,-1],[3,1,-1],[3,0,2],[0,2,5]]\\nsource = 2\\ndestination = 3\\ntarget = 8\\n\\nMy output is [[0,1,1],[1,2,1],[3,1,7],[3,0,2],[0,2,5]]\\nWhich means we can travel 2 -> 1 -> 3 and the sum is 8\\nBut it expect []\\n\\n\\nIt seems the solution is wrong."
                    },
                    {
                        "username": "Chrishu5777",
                        "content": "[@cartesPerforees](/cartesPerforees) thanks!!"
                    },
                    {
                        "username": "narang_madhur",
                        "content": "[@cartesPerforees](/cartesPerforees) Thanks for pointing out the error in output logic...I understood my mistake too.\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@jasonechiu](/jasonechiu) yup. The shortest of all distances from source to destination has to be target.\\nReally tough problem"
                    },
                    {
                        "username": "jasonechiu",
                        "content": "[@cartesPerforees](/cartesPerforees) \\nThanks for reply, I misunderstand the question. I suppose one shortest distance between the nodes source and destination. But it means \"all\" shortest distance between the nodes source and destination the sum of the weights should match the target."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "in your output, the shortest path from 2 to 3 is 2->0->3 with length 7. It is incorrect\\n\\nIt\\'s a really difficult problem bro, that kind of stuff is only the tip of the iceberg of debugging you;ll have to go through before getting AC"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "2 ques gang?!"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why there is a 2300 rating problem from codeforces in a leetcode contest?\\nhttps://codeforces.com/problemset/problem/715/B"
                    },
                    {
                        "username": "shivansh961",
                        "content": "LeetCode is high."
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "4\\n[[0,1,-1],[2,0,2],[3,2,6],[2,1,10],[3,0,-1]]\\n1\\n3\\n12\\n\\nmy output : [[0,1,1],[2,0,2],[3,2,6],[2,1,10],[3,0,11]]\\nexpected : [[0,1,11],[2,0,2],[3,2,6],[2,1,10],[3,0,1]]\\nthe question says if there are multiple modifications return any of them, then why is my output wrong."
                    },
                    {
                        "username": "vikassuthar528",
                        "content": "I\\'m also getting same test case wrong."
                    },
                    {
                        "username": "krobzh",
                        "content": " In your output, the shortest distance from 1 to 3 is 1->0->2->3 which is 9,  not 12. I got the similar error in another test case in which I break the original shortest path and made a shorter path.  "
                    },
                    {
                        "username": "aniketkr01",
                        "content": "Same happened with me"
                    },
                    {
                        "username": "HLeiTR",
                        "content": "I am a little bit confused on this test case: \n\n```\nn = 5\nedges = [[1,4,1],[2,4,-1],[3,0,2],[0,4,-1],[1,3,10],[1,0,10]]\nsource = 0\ndestination = 2\ntarget = 15\n```\n\nNotice that in this graph, the only paths from 0 to 2 are: \n0 -> 3 -> 1 -> 4 -> 2, with cost 2 + 10 + 1 = 13 and 1 changeable\n0 -> 4 -> 2, with cost 0 and 2 changeable\n0 -> 1 -> 4 -> 2, with cost 10 + 1 and 1 changeable\n\nThe expected answer is: \n`[[1,4,1],[2,4,4],[3,0,2],[0,4,14],[1,3,10],[1,0,10]]`\nWhich suggests that it took the third path, and changing the weight of (2, 4) to 4. \n(Also, I'm not sure why it changed the edge of 0 to 4 to have a weight of 14, it is not even used?)\n\nHowever, my answer is:\n`[[1,4,1],[2,4,1],[3,0,2],[0,4,14],[1,3,10],[1,0,10]]`\nWhich took the second path, and changing one of the weights to 14 and the other to 1. \nThen, I changed all other unused, changeable edges to have weight 1. \n\nShouldn't this also be considered correct by the problem description? \nAny help is appreciated, very confused on this question :c"
                    },
                    {
                        "username": "Hackytech",
                        "content": "[@Finesse](/Finesse) No matter how many times I read the question or go through some solutions, i am not able to identify what is the meaning of shortest path over here. It's definitely not the sum of edges because it has to be equal to target so no matter which valid path you choose, we can make it equal to target. So is it the number of edges between the source and destination. I am too confused, please correct me If I am wrong at some point. \n Thanks"
                    },
                    {
                        "username": "HLeiTR",
                        "content": "[@Finesse](/Finesse) \\n! Ahh\\nI see the problem now, thanks a lot!"
                    },
                    {
                        "username": "Finesse",
                        "content": "> Then, I changed all other unused, changeable edges to have weight 1\n\n...and made another path be shorter than 15. That's your mistake.\n\nAfter changing the weights, all the other path distances must be recalculated, and the smallest must equal target.\n\nChange the unused edge weights to the maximum instead."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "For the following testcase, why is the answer an empty matrix?\\n\\n`n = 4,\\nedges = [[0,1,-1],[1,2,-1],[3,1,-1],[3,0,2],[0,2,5]],\\nsource = 2,\\ndestination = 3,\\ntarget = 8`"
                    },
                    {
                        "username": "monster_10",
                        "content": "Time complexity is O(M*M*LOG(V)) it runs fine but doesn\\'t comply with the constraints as it should give TLE"
                    },
                    {
                        "username": "dmitryartux",
                        "content": ">If the shortest path from source to destination including the edges to be modified and assigning them a temporary weight of 1, is less than the target, then it is also not possible.\\n\\n**Looks like the Hint #3 is wrong**"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Yes, should be \\'MORE than the target\\'."
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "The 3rd hint is wrong, instead of \"less than the target\", it should be \"greater than the target\".  "
                    }
                ]
            },
            {
                "id": 1900584,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "This is the last time I attempt the hard problem before the medium in a contest! \\nHonestly, this one didn;t look too bad at first, just a modified Djikstra, right?\\nOh boy, was I wrong"
                    },
                    {
                        "username": "Finesse",
                        "content": "I've managed to solve using a single modified Dijkstra's cycle. Throughout every path with `distance≤target`, you need to find the one with the fewest `-1` edges (the `-1` edges add the minimum weight which is `1`). To implement it, don't sort the heap by the distance; sort by the number of `-1` edges first, and then by the distance. If that path has no `-1` edges, the answer is `[]`, otherwise fill all the edges on the path with some weights to meet the target and the other edges with `2e9`. [My code.](https://leetcode.com/problems/modify-graph-edge-weights/submissions/954301674/)"
                    },
                    {
                        "username": "jasonechiu",
                        "content": "The test case seems incorrect.\\nFor testcase `353`\\nn = 4\\nedges = [[0,1,-1],[1,2,-1],[3,1,-1],[3,0,2],[0,2,5]]\\nsource = 2\\ndestination = 3\\ntarget = 8\\n\\nMy output is [[0,1,1],[1,2,1],[3,1,7],[3,0,2],[0,2,5]]\\nWhich means we can travel 2 -> 1 -> 3 and the sum is 8\\nBut it expect []\\n\\n\\nIt seems the solution is wrong."
                    },
                    {
                        "username": "Chrishu5777",
                        "content": "[@cartesPerforees](/cartesPerforees) thanks!!"
                    },
                    {
                        "username": "narang_madhur",
                        "content": "[@cartesPerforees](/cartesPerforees) Thanks for pointing out the error in output logic...I understood my mistake too.\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@jasonechiu](/jasonechiu) yup. The shortest of all distances from source to destination has to be target.\\nReally tough problem"
                    },
                    {
                        "username": "jasonechiu",
                        "content": "[@cartesPerforees](/cartesPerforees) \\nThanks for reply, I misunderstand the question. I suppose one shortest distance between the nodes source and destination. But it means \"all\" shortest distance between the nodes source and destination the sum of the weights should match the target."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "in your output, the shortest path from 2 to 3 is 2->0->3 with length 7. It is incorrect\\n\\nIt\\'s a really difficult problem bro, that kind of stuff is only the tip of the iceberg of debugging you;ll have to go through before getting AC"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "2 ques gang?!"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why there is a 2300 rating problem from codeforces in a leetcode contest?\\nhttps://codeforces.com/problemset/problem/715/B"
                    },
                    {
                        "username": "shivansh961",
                        "content": "LeetCode is high."
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "4\\n[[0,1,-1],[2,0,2],[3,2,6],[2,1,10],[3,0,-1]]\\n1\\n3\\n12\\n\\nmy output : [[0,1,1],[2,0,2],[3,2,6],[2,1,10],[3,0,11]]\\nexpected : [[0,1,11],[2,0,2],[3,2,6],[2,1,10],[3,0,1]]\\nthe question says if there are multiple modifications return any of them, then why is my output wrong."
                    },
                    {
                        "username": "vikassuthar528",
                        "content": "I\\'m also getting same test case wrong."
                    },
                    {
                        "username": "krobzh",
                        "content": " In your output, the shortest distance from 1 to 3 is 1->0->2->3 which is 9,  not 12. I got the similar error in another test case in which I break the original shortest path and made a shorter path.  "
                    },
                    {
                        "username": "aniketkr01",
                        "content": "Same happened with me"
                    },
                    {
                        "username": "HLeiTR",
                        "content": "I am a little bit confused on this test case: \n\n```\nn = 5\nedges = [[1,4,1],[2,4,-1],[3,0,2],[0,4,-1],[1,3,10],[1,0,10]]\nsource = 0\ndestination = 2\ntarget = 15\n```\n\nNotice that in this graph, the only paths from 0 to 2 are: \n0 -> 3 -> 1 -> 4 -> 2, with cost 2 + 10 + 1 = 13 and 1 changeable\n0 -> 4 -> 2, with cost 0 and 2 changeable\n0 -> 1 -> 4 -> 2, with cost 10 + 1 and 1 changeable\n\nThe expected answer is: \n`[[1,4,1],[2,4,4],[3,0,2],[0,4,14],[1,3,10],[1,0,10]]`\nWhich suggests that it took the third path, and changing the weight of (2, 4) to 4. \n(Also, I'm not sure why it changed the edge of 0 to 4 to have a weight of 14, it is not even used?)\n\nHowever, my answer is:\n`[[1,4,1],[2,4,1],[3,0,2],[0,4,14],[1,3,10],[1,0,10]]`\nWhich took the second path, and changing one of the weights to 14 and the other to 1. \nThen, I changed all other unused, changeable edges to have weight 1. \n\nShouldn't this also be considered correct by the problem description? \nAny help is appreciated, very confused on this question :c"
                    },
                    {
                        "username": "Hackytech",
                        "content": "[@Finesse](/Finesse) No matter how many times I read the question or go through some solutions, i am not able to identify what is the meaning of shortest path over here. It's definitely not the sum of edges because it has to be equal to target so no matter which valid path you choose, we can make it equal to target. So is it the number of edges between the source and destination. I am too confused, please correct me If I am wrong at some point. \n Thanks"
                    },
                    {
                        "username": "HLeiTR",
                        "content": "[@Finesse](/Finesse) \\n! Ahh\\nI see the problem now, thanks a lot!"
                    },
                    {
                        "username": "Finesse",
                        "content": "> Then, I changed all other unused, changeable edges to have weight 1\n\n...and made another path be shorter than 15. That's your mistake.\n\nAfter changing the weights, all the other path distances must be recalculated, and the smallest must equal target.\n\nChange the unused edge weights to the maximum instead."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "For the following testcase, why is the answer an empty matrix?\\n\\n`n = 4,\\nedges = [[0,1,-1],[1,2,-1],[3,1,-1],[3,0,2],[0,2,5]],\\nsource = 2,\\ndestination = 3,\\ntarget = 8`"
                    },
                    {
                        "username": "monster_10",
                        "content": "Time complexity is O(M*M*LOG(V)) it runs fine but doesn\\'t comply with the constraints as it should give TLE"
                    },
                    {
                        "username": "dmitryartux",
                        "content": ">If the shortest path from source to destination including the edges to be modified and assigning them a temporary weight of 1, is less than the target, then it is also not possible.\\n\\n**Looks like the Hint #3 is wrong**"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Yes, should be \\'MORE than the target\\'."
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "The 3rd hint is wrong, instead of \"less than the target\", it should be \"greater than the target\".  "
                    }
                ]
            },
            {
                "id": 1900505,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "This is the last time I attempt the hard problem before the medium in a contest! \\nHonestly, this one didn;t look too bad at first, just a modified Djikstra, right?\\nOh boy, was I wrong"
                    },
                    {
                        "username": "Finesse",
                        "content": "I've managed to solve using a single modified Dijkstra's cycle. Throughout every path with `distance≤target`, you need to find the one with the fewest `-1` edges (the `-1` edges add the minimum weight which is `1`). To implement it, don't sort the heap by the distance; sort by the number of `-1` edges first, and then by the distance. If that path has no `-1` edges, the answer is `[]`, otherwise fill all the edges on the path with some weights to meet the target and the other edges with `2e9`. [My code.](https://leetcode.com/problems/modify-graph-edge-weights/submissions/954301674/)"
                    },
                    {
                        "username": "jasonechiu",
                        "content": "The test case seems incorrect.\\nFor testcase `353`\\nn = 4\\nedges = [[0,1,-1],[1,2,-1],[3,1,-1],[3,0,2],[0,2,5]]\\nsource = 2\\ndestination = 3\\ntarget = 8\\n\\nMy output is [[0,1,1],[1,2,1],[3,1,7],[3,0,2],[0,2,5]]\\nWhich means we can travel 2 -> 1 -> 3 and the sum is 8\\nBut it expect []\\n\\n\\nIt seems the solution is wrong."
                    },
                    {
                        "username": "Chrishu5777",
                        "content": "[@cartesPerforees](/cartesPerforees) thanks!!"
                    },
                    {
                        "username": "narang_madhur",
                        "content": "[@cartesPerforees](/cartesPerforees) Thanks for pointing out the error in output logic...I understood my mistake too.\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@jasonechiu](/jasonechiu) yup. The shortest of all distances from source to destination has to be target.\\nReally tough problem"
                    },
                    {
                        "username": "jasonechiu",
                        "content": "[@cartesPerforees](/cartesPerforees) \\nThanks for reply, I misunderstand the question. I suppose one shortest distance between the nodes source and destination. But it means \"all\" shortest distance between the nodes source and destination the sum of the weights should match the target."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "in your output, the shortest path from 2 to 3 is 2->0->3 with length 7. It is incorrect\\n\\nIt\\'s a really difficult problem bro, that kind of stuff is only the tip of the iceberg of debugging you;ll have to go through before getting AC"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "2 ques gang?!"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why there is a 2300 rating problem from codeforces in a leetcode contest?\\nhttps://codeforces.com/problemset/problem/715/B"
                    },
                    {
                        "username": "shivansh961",
                        "content": "LeetCode is high."
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "4\\n[[0,1,-1],[2,0,2],[3,2,6],[2,1,10],[3,0,-1]]\\n1\\n3\\n12\\n\\nmy output : [[0,1,1],[2,0,2],[3,2,6],[2,1,10],[3,0,11]]\\nexpected : [[0,1,11],[2,0,2],[3,2,6],[2,1,10],[3,0,1]]\\nthe question says if there are multiple modifications return any of them, then why is my output wrong."
                    },
                    {
                        "username": "vikassuthar528",
                        "content": "I\\'m also getting same test case wrong."
                    },
                    {
                        "username": "krobzh",
                        "content": " In your output, the shortest distance from 1 to 3 is 1->0->2->3 which is 9,  not 12. I got the similar error in another test case in which I break the original shortest path and made a shorter path.  "
                    },
                    {
                        "username": "aniketkr01",
                        "content": "Same happened with me"
                    },
                    {
                        "username": "HLeiTR",
                        "content": "I am a little bit confused on this test case: \n\n```\nn = 5\nedges = [[1,4,1],[2,4,-1],[3,0,2],[0,4,-1],[1,3,10],[1,0,10]]\nsource = 0\ndestination = 2\ntarget = 15\n```\n\nNotice that in this graph, the only paths from 0 to 2 are: \n0 -> 3 -> 1 -> 4 -> 2, with cost 2 + 10 + 1 = 13 and 1 changeable\n0 -> 4 -> 2, with cost 0 and 2 changeable\n0 -> 1 -> 4 -> 2, with cost 10 + 1 and 1 changeable\n\nThe expected answer is: \n`[[1,4,1],[2,4,4],[3,0,2],[0,4,14],[1,3,10],[1,0,10]]`\nWhich suggests that it took the third path, and changing the weight of (2, 4) to 4. \n(Also, I'm not sure why it changed the edge of 0 to 4 to have a weight of 14, it is not even used?)\n\nHowever, my answer is:\n`[[1,4,1],[2,4,1],[3,0,2],[0,4,14],[1,3,10],[1,0,10]]`\nWhich took the second path, and changing one of the weights to 14 and the other to 1. \nThen, I changed all other unused, changeable edges to have weight 1. \n\nShouldn't this also be considered correct by the problem description? \nAny help is appreciated, very confused on this question :c"
                    },
                    {
                        "username": "Hackytech",
                        "content": "[@Finesse](/Finesse) No matter how many times I read the question or go through some solutions, i am not able to identify what is the meaning of shortest path over here. It's definitely not the sum of edges because it has to be equal to target so no matter which valid path you choose, we can make it equal to target. So is it the number of edges between the source and destination. I am too confused, please correct me If I am wrong at some point. \n Thanks"
                    },
                    {
                        "username": "HLeiTR",
                        "content": "[@Finesse](/Finesse) \\n! Ahh\\nI see the problem now, thanks a lot!"
                    },
                    {
                        "username": "Finesse",
                        "content": "> Then, I changed all other unused, changeable edges to have weight 1\n\n...and made another path be shorter than 15. That's your mistake.\n\nAfter changing the weights, all the other path distances must be recalculated, and the smallest must equal target.\n\nChange the unused edge weights to the maximum instead."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "For the following testcase, why is the answer an empty matrix?\\n\\n`n = 4,\\nedges = [[0,1,-1],[1,2,-1],[3,1,-1],[3,0,2],[0,2,5]],\\nsource = 2,\\ndestination = 3,\\ntarget = 8`"
                    },
                    {
                        "username": "monster_10",
                        "content": "Time complexity is O(M*M*LOG(V)) it runs fine but doesn\\'t comply with the constraints as it should give TLE"
                    },
                    {
                        "username": "dmitryartux",
                        "content": ">If the shortest path from source to destination including the edges to be modified and assigning them a temporary weight of 1, is less than the target, then it is also not possible.\\n\\n**Looks like the Hint #3 is wrong**"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Yes, should be \\'MORE than the target\\'."
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "The 3rd hint is wrong, instead of \"less than the target\", it should be \"greater than the target\".  "
                    }
                ]
            },
            {
                "id": 1900484,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "This is the last time I attempt the hard problem before the medium in a contest! \\nHonestly, this one didn;t look too bad at first, just a modified Djikstra, right?\\nOh boy, was I wrong"
                    },
                    {
                        "username": "Finesse",
                        "content": "I've managed to solve using a single modified Dijkstra's cycle. Throughout every path with `distance≤target`, you need to find the one with the fewest `-1` edges (the `-1` edges add the minimum weight which is `1`). To implement it, don't sort the heap by the distance; sort by the number of `-1` edges first, and then by the distance. If that path has no `-1` edges, the answer is `[]`, otherwise fill all the edges on the path with some weights to meet the target and the other edges with `2e9`. [My code.](https://leetcode.com/problems/modify-graph-edge-weights/submissions/954301674/)"
                    },
                    {
                        "username": "jasonechiu",
                        "content": "The test case seems incorrect.\\nFor testcase `353`\\nn = 4\\nedges = [[0,1,-1],[1,2,-1],[3,1,-1],[3,0,2],[0,2,5]]\\nsource = 2\\ndestination = 3\\ntarget = 8\\n\\nMy output is [[0,1,1],[1,2,1],[3,1,7],[3,0,2],[0,2,5]]\\nWhich means we can travel 2 -> 1 -> 3 and the sum is 8\\nBut it expect []\\n\\n\\nIt seems the solution is wrong."
                    },
                    {
                        "username": "Chrishu5777",
                        "content": "[@cartesPerforees](/cartesPerforees) thanks!!"
                    },
                    {
                        "username": "narang_madhur",
                        "content": "[@cartesPerforees](/cartesPerforees) Thanks for pointing out the error in output logic...I understood my mistake too.\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@jasonechiu](/jasonechiu) yup. The shortest of all distances from source to destination has to be target.\\nReally tough problem"
                    },
                    {
                        "username": "jasonechiu",
                        "content": "[@cartesPerforees](/cartesPerforees) \\nThanks for reply, I misunderstand the question. I suppose one shortest distance between the nodes source and destination. But it means \"all\" shortest distance between the nodes source and destination the sum of the weights should match the target."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "in your output, the shortest path from 2 to 3 is 2->0->3 with length 7. It is incorrect\\n\\nIt\\'s a really difficult problem bro, that kind of stuff is only the tip of the iceberg of debugging you;ll have to go through before getting AC"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "2 ques gang?!"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why there is a 2300 rating problem from codeforces in a leetcode contest?\\nhttps://codeforces.com/problemset/problem/715/B"
                    },
                    {
                        "username": "shivansh961",
                        "content": "LeetCode is high."
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "4\\n[[0,1,-1],[2,0,2],[3,2,6],[2,1,10],[3,0,-1]]\\n1\\n3\\n12\\n\\nmy output : [[0,1,1],[2,0,2],[3,2,6],[2,1,10],[3,0,11]]\\nexpected : [[0,1,11],[2,0,2],[3,2,6],[2,1,10],[3,0,1]]\\nthe question says if there are multiple modifications return any of them, then why is my output wrong."
                    },
                    {
                        "username": "vikassuthar528",
                        "content": "I\\'m also getting same test case wrong."
                    },
                    {
                        "username": "krobzh",
                        "content": " In your output, the shortest distance from 1 to 3 is 1->0->2->3 which is 9,  not 12. I got the similar error in another test case in which I break the original shortest path and made a shorter path.  "
                    },
                    {
                        "username": "aniketkr01",
                        "content": "Same happened with me"
                    },
                    {
                        "username": "HLeiTR",
                        "content": "I am a little bit confused on this test case: \n\n```\nn = 5\nedges = [[1,4,1],[2,4,-1],[3,0,2],[0,4,-1],[1,3,10],[1,0,10]]\nsource = 0\ndestination = 2\ntarget = 15\n```\n\nNotice that in this graph, the only paths from 0 to 2 are: \n0 -> 3 -> 1 -> 4 -> 2, with cost 2 + 10 + 1 = 13 and 1 changeable\n0 -> 4 -> 2, with cost 0 and 2 changeable\n0 -> 1 -> 4 -> 2, with cost 10 + 1 and 1 changeable\n\nThe expected answer is: \n`[[1,4,1],[2,4,4],[3,0,2],[0,4,14],[1,3,10],[1,0,10]]`\nWhich suggests that it took the third path, and changing the weight of (2, 4) to 4. \n(Also, I'm not sure why it changed the edge of 0 to 4 to have a weight of 14, it is not even used?)\n\nHowever, my answer is:\n`[[1,4,1],[2,4,1],[3,0,2],[0,4,14],[1,3,10],[1,0,10]]`\nWhich took the second path, and changing one of the weights to 14 and the other to 1. \nThen, I changed all other unused, changeable edges to have weight 1. \n\nShouldn't this also be considered correct by the problem description? \nAny help is appreciated, very confused on this question :c"
                    },
                    {
                        "username": "Hackytech",
                        "content": "[@Finesse](/Finesse) No matter how many times I read the question or go through some solutions, i am not able to identify what is the meaning of shortest path over here. It's definitely not the sum of edges because it has to be equal to target so no matter which valid path you choose, we can make it equal to target. So is it the number of edges between the source and destination. I am too confused, please correct me If I am wrong at some point. \n Thanks"
                    },
                    {
                        "username": "HLeiTR",
                        "content": "[@Finesse](/Finesse) \\n! Ahh\\nI see the problem now, thanks a lot!"
                    },
                    {
                        "username": "Finesse",
                        "content": "> Then, I changed all other unused, changeable edges to have weight 1\n\n...and made another path be shorter than 15. That's your mistake.\n\nAfter changing the weights, all the other path distances must be recalculated, and the smallest must equal target.\n\nChange the unused edge weights to the maximum instead."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "For the following testcase, why is the answer an empty matrix?\\n\\n`n = 4,\\nedges = [[0,1,-1],[1,2,-1],[3,1,-1],[3,0,2],[0,2,5]],\\nsource = 2,\\ndestination = 3,\\ntarget = 8`"
                    },
                    {
                        "username": "monster_10",
                        "content": "Time complexity is O(M*M*LOG(V)) it runs fine but doesn\\'t comply with the constraints as it should give TLE"
                    },
                    {
                        "username": "dmitryartux",
                        "content": ">If the shortest path from source to destination including the edges to be modified and assigning them a temporary weight of 1, is less than the target, then it is also not possible.\\n\\n**Looks like the Hint #3 is wrong**"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Yes, should be \\'MORE than the target\\'."
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "The 3rd hint is wrong, instead of \"less than the target\", it should be \"greater than the target\".  "
                    }
                ]
            },
            {
                "id": 1901172,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "This is the last time I attempt the hard problem before the medium in a contest! \\nHonestly, this one didn;t look too bad at first, just a modified Djikstra, right?\\nOh boy, was I wrong"
                    },
                    {
                        "username": "Finesse",
                        "content": "I've managed to solve using a single modified Dijkstra's cycle. Throughout every path with `distance≤target`, you need to find the one with the fewest `-1` edges (the `-1` edges add the minimum weight which is `1`). To implement it, don't sort the heap by the distance; sort by the number of `-1` edges first, and then by the distance. If that path has no `-1` edges, the answer is `[]`, otherwise fill all the edges on the path with some weights to meet the target and the other edges with `2e9`. [My code.](https://leetcode.com/problems/modify-graph-edge-weights/submissions/954301674/)"
                    },
                    {
                        "username": "jasonechiu",
                        "content": "The test case seems incorrect.\\nFor testcase `353`\\nn = 4\\nedges = [[0,1,-1],[1,2,-1],[3,1,-1],[3,0,2],[0,2,5]]\\nsource = 2\\ndestination = 3\\ntarget = 8\\n\\nMy output is [[0,1,1],[1,2,1],[3,1,7],[3,0,2],[0,2,5]]\\nWhich means we can travel 2 -> 1 -> 3 and the sum is 8\\nBut it expect []\\n\\n\\nIt seems the solution is wrong."
                    },
                    {
                        "username": "Chrishu5777",
                        "content": "[@cartesPerforees](/cartesPerforees) thanks!!"
                    },
                    {
                        "username": "narang_madhur",
                        "content": "[@cartesPerforees](/cartesPerforees) Thanks for pointing out the error in output logic...I understood my mistake too.\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@jasonechiu](/jasonechiu) yup. The shortest of all distances from source to destination has to be target.\\nReally tough problem"
                    },
                    {
                        "username": "jasonechiu",
                        "content": "[@cartesPerforees](/cartesPerforees) \\nThanks for reply, I misunderstand the question. I suppose one shortest distance between the nodes source and destination. But it means \"all\" shortest distance between the nodes source and destination the sum of the weights should match the target."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "in your output, the shortest path from 2 to 3 is 2->0->3 with length 7. It is incorrect\\n\\nIt\\'s a really difficult problem bro, that kind of stuff is only the tip of the iceberg of debugging you;ll have to go through before getting AC"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "2 ques gang?!"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why there is a 2300 rating problem from codeforces in a leetcode contest?\\nhttps://codeforces.com/problemset/problem/715/B"
                    },
                    {
                        "username": "shivansh961",
                        "content": "LeetCode is high."
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "4\\n[[0,1,-1],[2,0,2],[3,2,6],[2,1,10],[3,0,-1]]\\n1\\n3\\n12\\n\\nmy output : [[0,1,1],[2,0,2],[3,2,6],[2,1,10],[3,0,11]]\\nexpected : [[0,1,11],[2,0,2],[3,2,6],[2,1,10],[3,0,1]]\\nthe question says if there are multiple modifications return any of them, then why is my output wrong."
                    },
                    {
                        "username": "vikassuthar528",
                        "content": "I\\'m also getting same test case wrong."
                    },
                    {
                        "username": "krobzh",
                        "content": " In your output, the shortest distance from 1 to 3 is 1->0->2->3 which is 9,  not 12. I got the similar error in another test case in which I break the original shortest path and made a shorter path.  "
                    },
                    {
                        "username": "aniketkr01",
                        "content": "Same happened with me"
                    },
                    {
                        "username": "HLeiTR",
                        "content": "I am a little bit confused on this test case: \n\n```\nn = 5\nedges = [[1,4,1],[2,4,-1],[3,0,2],[0,4,-1],[1,3,10],[1,0,10]]\nsource = 0\ndestination = 2\ntarget = 15\n```\n\nNotice that in this graph, the only paths from 0 to 2 are: \n0 -> 3 -> 1 -> 4 -> 2, with cost 2 + 10 + 1 = 13 and 1 changeable\n0 -> 4 -> 2, with cost 0 and 2 changeable\n0 -> 1 -> 4 -> 2, with cost 10 + 1 and 1 changeable\n\nThe expected answer is: \n`[[1,4,1],[2,4,4],[3,0,2],[0,4,14],[1,3,10],[1,0,10]]`\nWhich suggests that it took the third path, and changing the weight of (2, 4) to 4. \n(Also, I'm not sure why it changed the edge of 0 to 4 to have a weight of 14, it is not even used?)\n\nHowever, my answer is:\n`[[1,4,1],[2,4,1],[3,0,2],[0,4,14],[1,3,10],[1,0,10]]`\nWhich took the second path, and changing one of the weights to 14 and the other to 1. \nThen, I changed all other unused, changeable edges to have weight 1. \n\nShouldn't this also be considered correct by the problem description? \nAny help is appreciated, very confused on this question :c"
                    },
                    {
                        "username": "Hackytech",
                        "content": "[@Finesse](/Finesse) No matter how many times I read the question or go through some solutions, i am not able to identify what is the meaning of shortest path over here. It's definitely not the sum of edges because it has to be equal to target so no matter which valid path you choose, we can make it equal to target. So is it the number of edges between the source and destination. I am too confused, please correct me If I am wrong at some point. \n Thanks"
                    },
                    {
                        "username": "HLeiTR",
                        "content": "[@Finesse](/Finesse) \\n! Ahh\\nI see the problem now, thanks a lot!"
                    },
                    {
                        "username": "Finesse",
                        "content": "> Then, I changed all other unused, changeable edges to have weight 1\n\n...and made another path be shorter than 15. That's your mistake.\n\nAfter changing the weights, all the other path distances must be recalculated, and the smallest must equal target.\n\nChange the unused edge weights to the maximum instead."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "For the following testcase, why is the answer an empty matrix?\\n\\n`n = 4,\\nedges = [[0,1,-1],[1,2,-1],[3,1,-1],[3,0,2],[0,2,5]],\\nsource = 2,\\ndestination = 3,\\ntarget = 8`"
                    },
                    {
                        "username": "monster_10",
                        "content": "Time complexity is O(M*M*LOG(V)) it runs fine but doesn\\'t comply with the constraints as it should give TLE"
                    },
                    {
                        "username": "dmitryartux",
                        "content": ">If the shortest path from source to destination including the edges to be modified and assigning them a temporary weight of 1, is less than the target, then it is also not possible.\\n\\n**Looks like the Hint #3 is wrong**"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Yes, should be \\'MORE than the target\\'."
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "The 3rd hint is wrong, instead of \"less than the target\", it should be \"greater than the target\".  "
                    }
                ]
            },
            {
                "id": 1900778,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "This is the last time I attempt the hard problem before the medium in a contest! \\nHonestly, this one didn;t look too bad at first, just a modified Djikstra, right?\\nOh boy, was I wrong"
                    },
                    {
                        "username": "Finesse",
                        "content": "I've managed to solve using a single modified Dijkstra's cycle. Throughout every path with `distance≤target`, you need to find the one with the fewest `-1` edges (the `-1` edges add the minimum weight which is `1`). To implement it, don't sort the heap by the distance; sort by the number of `-1` edges first, and then by the distance. If that path has no `-1` edges, the answer is `[]`, otherwise fill all the edges on the path with some weights to meet the target and the other edges with `2e9`. [My code.](https://leetcode.com/problems/modify-graph-edge-weights/submissions/954301674/)"
                    },
                    {
                        "username": "jasonechiu",
                        "content": "The test case seems incorrect.\\nFor testcase `353`\\nn = 4\\nedges = [[0,1,-1],[1,2,-1],[3,1,-1],[3,0,2],[0,2,5]]\\nsource = 2\\ndestination = 3\\ntarget = 8\\n\\nMy output is [[0,1,1],[1,2,1],[3,1,7],[3,0,2],[0,2,5]]\\nWhich means we can travel 2 -> 1 -> 3 and the sum is 8\\nBut it expect []\\n\\n\\nIt seems the solution is wrong."
                    },
                    {
                        "username": "Chrishu5777",
                        "content": "[@cartesPerforees](/cartesPerforees) thanks!!"
                    },
                    {
                        "username": "narang_madhur",
                        "content": "[@cartesPerforees](/cartesPerforees) Thanks for pointing out the error in output logic...I understood my mistake too.\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@jasonechiu](/jasonechiu) yup. The shortest of all distances from source to destination has to be target.\\nReally tough problem"
                    },
                    {
                        "username": "jasonechiu",
                        "content": "[@cartesPerforees](/cartesPerforees) \\nThanks for reply, I misunderstand the question. I suppose one shortest distance between the nodes source and destination. But it means \"all\" shortest distance between the nodes source and destination the sum of the weights should match the target."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "in your output, the shortest path from 2 to 3 is 2->0->3 with length 7. It is incorrect\\n\\nIt\\'s a really difficult problem bro, that kind of stuff is only the tip of the iceberg of debugging you;ll have to go through before getting AC"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "2 ques gang?!"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why there is a 2300 rating problem from codeforces in a leetcode contest?\\nhttps://codeforces.com/problemset/problem/715/B"
                    },
                    {
                        "username": "shivansh961",
                        "content": "LeetCode is high."
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "4\\n[[0,1,-1],[2,0,2],[3,2,6],[2,1,10],[3,0,-1]]\\n1\\n3\\n12\\n\\nmy output : [[0,1,1],[2,0,2],[3,2,6],[2,1,10],[3,0,11]]\\nexpected : [[0,1,11],[2,0,2],[3,2,6],[2,1,10],[3,0,1]]\\nthe question says if there are multiple modifications return any of them, then why is my output wrong."
                    },
                    {
                        "username": "vikassuthar528",
                        "content": "I\\'m also getting same test case wrong."
                    },
                    {
                        "username": "krobzh",
                        "content": " In your output, the shortest distance from 1 to 3 is 1->0->2->3 which is 9,  not 12. I got the similar error in another test case in which I break the original shortest path and made a shorter path.  "
                    },
                    {
                        "username": "aniketkr01",
                        "content": "Same happened with me"
                    },
                    {
                        "username": "HLeiTR",
                        "content": "I am a little bit confused on this test case: \n\n```\nn = 5\nedges = [[1,4,1],[2,4,-1],[3,0,2],[0,4,-1],[1,3,10],[1,0,10]]\nsource = 0\ndestination = 2\ntarget = 15\n```\n\nNotice that in this graph, the only paths from 0 to 2 are: \n0 -> 3 -> 1 -> 4 -> 2, with cost 2 + 10 + 1 = 13 and 1 changeable\n0 -> 4 -> 2, with cost 0 and 2 changeable\n0 -> 1 -> 4 -> 2, with cost 10 + 1 and 1 changeable\n\nThe expected answer is: \n`[[1,4,1],[2,4,4],[3,0,2],[0,4,14],[1,3,10],[1,0,10]]`\nWhich suggests that it took the third path, and changing the weight of (2, 4) to 4. \n(Also, I'm not sure why it changed the edge of 0 to 4 to have a weight of 14, it is not even used?)\n\nHowever, my answer is:\n`[[1,4,1],[2,4,1],[3,0,2],[0,4,14],[1,3,10],[1,0,10]]`\nWhich took the second path, and changing one of the weights to 14 and the other to 1. \nThen, I changed all other unused, changeable edges to have weight 1. \n\nShouldn't this also be considered correct by the problem description? \nAny help is appreciated, very confused on this question :c"
                    },
                    {
                        "username": "Hackytech",
                        "content": "[@Finesse](/Finesse) No matter how many times I read the question or go through some solutions, i am not able to identify what is the meaning of shortest path over here. It's definitely not the sum of edges because it has to be equal to target so no matter which valid path you choose, we can make it equal to target. So is it the number of edges between the source and destination. I am too confused, please correct me If I am wrong at some point. \n Thanks"
                    },
                    {
                        "username": "HLeiTR",
                        "content": "[@Finesse](/Finesse) \\n! Ahh\\nI see the problem now, thanks a lot!"
                    },
                    {
                        "username": "Finesse",
                        "content": "> Then, I changed all other unused, changeable edges to have weight 1\n\n...and made another path be shorter than 15. That's your mistake.\n\nAfter changing the weights, all the other path distances must be recalculated, and the smallest must equal target.\n\nChange the unused edge weights to the maximum instead."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "For the following testcase, why is the answer an empty matrix?\\n\\n`n = 4,\\nedges = [[0,1,-1],[1,2,-1],[3,1,-1],[3,0,2],[0,2,5]],\\nsource = 2,\\ndestination = 3,\\ntarget = 8`"
                    },
                    {
                        "username": "monster_10",
                        "content": "Time complexity is O(M*M*LOG(V)) it runs fine but doesn\\'t comply with the constraints as it should give TLE"
                    },
                    {
                        "username": "dmitryartux",
                        "content": ">If the shortest path from source to destination including the edges to be modified and assigning them a temporary weight of 1, is less than the target, then it is also not possible.\\n\\n**Looks like the Hint #3 is wrong**"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Yes, should be \\'MORE than the target\\'."
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "The 3rd hint is wrong, instead of \"less than the target\", it should be \"greater than the target\".  "
                    }
                ]
            },
            {
                "id": 1996902,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "This is the last time I attempt the hard problem before the medium in a contest! \\nHonestly, this one didn;t look too bad at first, just a modified Djikstra, right?\\nOh boy, was I wrong"
                    },
                    {
                        "username": "Finesse",
                        "content": "I've managed to solve using a single modified Dijkstra's cycle. Throughout every path with `distance≤target`, you need to find the one with the fewest `-1` edges (the `-1` edges add the minimum weight which is `1`). To implement it, don't sort the heap by the distance; sort by the number of `-1` edges first, and then by the distance. If that path has no `-1` edges, the answer is `[]`, otherwise fill all the edges on the path with some weights to meet the target and the other edges with `2e9`. [My code.](https://leetcode.com/problems/modify-graph-edge-weights/submissions/954301674/)"
                    },
                    {
                        "username": "jasonechiu",
                        "content": "The test case seems incorrect.\\nFor testcase `353`\\nn = 4\\nedges = [[0,1,-1],[1,2,-1],[3,1,-1],[3,0,2],[0,2,5]]\\nsource = 2\\ndestination = 3\\ntarget = 8\\n\\nMy output is [[0,1,1],[1,2,1],[3,1,7],[3,0,2],[0,2,5]]\\nWhich means we can travel 2 -> 1 -> 3 and the sum is 8\\nBut it expect []\\n\\n\\nIt seems the solution is wrong."
                    },
                    {
                        "username": "Chrishu5777",
                        "content": "[@cartesPerforees](/cartesPerforees) thanks!!"
                    },
                    {
                        "username": "narang_madhur",
                        "content": "[@cartesPerforees](/cartesPerforees) Thanks for pointing out the error in output logic...I understood my mistake too.\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@jasonechiu](/jasonechiu) yup. The shortest of all distances from source to destination has to be target.\\nReally tough problem"
                    },
                    {
                        "username": "jasonechiu",
                        "content": "[@cartesPerforees](/cartesPerforees) \\nThanks for reply, I misunderstand the question. I suppose one shortest distance between the nodes source and destination. But it means \"all\" shortest distance between the nodes source and destination the sum of the weights should match the target."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "in your output, the shortest path from 2 to 3 is 2->0->3 with length 7. It is incorrect\\n\\nIt\\'s a really difficult problem bro, that kind of stuff is only the tip of the iceberg of debugging you;ll have to go through before getting AC"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "2 ques gang?!"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why there is a 2300 rating problem from codeforces in a leetcode contest?\\nhttps://codeforces.com/problemset/problem/715/B"
                    },
                    {
                        "username": "shivansh961",
                        "content": "LeetCode is high."
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "4\\n[[0,1,-1],[2,0,2],[3,2,6],[2,1,10],[3,0,-1]]\\n1\\n3\\n12\\n\\nmy output : [[0,1,1],[2,0,2],[3,2,6],[2,1,10],[3,0,11]]\\nexpected : [[0,1,11],[2,0,2],[3,2,6],[2,1,10],[3,0,1]]\\nthe question says if there are multiple modifications return any of them, then why is my output wrong."
                    },
                    {
                        "username": "vikassuthar528",
                        "content": "I\\'m also getting same test case wrong."
                    },
                    {
                        "username": "krobzh",
                        "content": " In your output, the shortest distance from 1 to 3 is 1->0->2->3 which is 9,  not 12. I got the similar error in another test case in which I break the original shortest path and made a shorter path.  "
                    },
                    {
                        "username": "aniketkr01",
                        "content": "Same happened with me"
                    },
                    {
                        "username": "HLeiTR",
                        "content": "I am a little bit confused on this test case: \n\n```\nn = 5\nedges = [[1,4,1],[2,4,-1],[3,0,2],[0,4,-1],[1,3,10],[1,0,10]]\nsource = 0\ndestination = 2\ntarget = 15\n```\n\nNotice that in this graph, the only paths from 0 to 2 are: \n0 -> 3 -> 1 -> 4 -> 2, with cost 2 + 10 + 1 = 13 and 1 changeable\n0 -> 4 -> 2, with cost 0 and 2 changeable\n0 -> 1 -> 4 -> 2, with cost 10 + 1 and 1 changeable\n\nThe expected answer is: \n`[[1,4,1],[2,4,4],[3,0,2],[0,4,14],[1,3,10],[1,0,10]]`\nWhich suggests that it took the third path, and changing the weight of (2, 4) to 4. \n(Also, I'm not sure why it changed the edge of 0 to 4 to have a weight of 14, it is not even used?)\n\nHowever, my answer is:\n`[[1,4,1],[2,4,1],[3,0,2],[0,4,14],[1,3,10],[1,0,10]]`\nWhich took the second path, and changing one of the weights to 14 and the other to 1. \nThen, I changed all other unused, changeable edges to have weight 1. \n\nShouldn't this also be considered correct by the problem description? \nAny help is appreciated, very confused on this question :c"
                    },
                    {
                        "username": "Hackytech",
                        "content": "[@Finesse](/Finesse) No matter how many times I read the question or go through some solutions, i am not able to identify what is the meaning of shortest path over here. It's definitely not the sum of edges because it has to be equal to target so no matter which valid path you choose, we can make it equal to target. So is it the number of edges between the source and destination. I am too confused, please correct me If I am wrong at some point. \n Thanks"
                    },
                    {
                        "username": "HLeiTR",
                        "content": "[@Finesse](/Finesse) \\n! Ahh\\nI see the problem now, thanks a lot!"
                    },
                    {
                        "username": "Finesse",
                        "content": "> Then, I changed all other unused, changeable edges to have weight 1\n\n...and made another path be shorter than 15. That's your mistake.\n\nAfter changing the weights, all the other path distances must be recalculated, and the smallest must equal target.\n\nChange the unused edge weights to the maximum instead."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "For the following testcase, why is the answer an empty matrix?\\n\\n`n = 4,\\nedges = [[0,1,-1],[1,2,-1],[3,1,-1],[3,0,2],[0,2,5]],\\nsource = 2,\\ndestination = 3,\\ntarget = 8`"
                    },
                    {
                        "username": "monster_10",
                        "content": "Time complexity is O(M*M*LOG(V)) it runs fine but doesn\\'t comply with the constraints as it should give TLE"
                    },
                    {
                        "username": "dmitryartux",
                        "content": ">If the shortest path from source to destination including the edges to be modified and assigning them a temporary weight of 1, is less than the target, then it is also not possible.\\n\\n**Looks like the Hint #3 is wrong**"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Yes, should be \\'MORE than the target\\'."
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "The 3rd hint is wrong, instead of \"less than the target\", it should be \"greater than the target\".  "
                    }
                ]
            },
            {
                "id": 1933171,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "This is the last time I attempt the hard problem before the medium in a contest! \\nHonestly, this one didn;t look too bad at first, just a modified Djikstra, right?\\nOh boy, was I wrong"
                    },
                    {
                        "username": "Finesse",
                        "content": "I've managed to solve using a single modified Dijkstra's cycle. Throughout every path with `distance≤target`, you need to find the one with the fewest `-1` edges (the `-1` edges add the minimum weight which is `1`). To implement it, don't sort the heap by the distance; sort by the number of `-1` edges first, and then by the distance. If that path has no `-1` edges, the answer is `[]`, otherwise fill all the edges on the path with some weights to meet the target and the other edges with `2e9`. [My code.](https://leetcode.com/problems/modify-graph-edge-weights/submissions/954301674/)"
                    },
                    {
                        "username": "jasonechiu",
                        "content": "The test case seems incorrect.\\nFor testcase `353`\\nn = 4\\nedges = [[0,1,-1],[1,2,-1],[3,1,-1],[3,0,2],[0,2,5]]\\nsource = 2\\ndestination = 3\\ntarget = 8\\n\\nMy output is [[0,1,1],[1,2,1],[3,1,7],[3,0,2],[0,2,5]]\\nWhich means we can travel 2 -> 1 -> 3 and the sum is 8\\nBut it expect []\\n\\n\\nIt seems the solution is wrong."
                    },
                    {
                        "username": "Chrishu5777",
                        "content": "[@cartesPerforees](/cartesPerforees) thanks!!"
                    },
                    {
                        "username": "narang_madhur",
                        "content": "[@cartesPerforees](/cartesPerforees) Thanks for pointing out the error in output logic...I understood my mistake too.\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@jasonechiu](/jasonechiu) yup. The shortest of all distances from source to destination has to be target.\\nReally tough problem"
                    },
                    {
                        "username": "jasonechiu",
                        "content": "[@cartesPerforees](/cartesPerforees) \\nThanks for reply, I misunderstand the question. I suppose one shortest distance between the nodes source and destination. But it means \"all\" shortest distance between the nodes source and destination the sum of the weights should match the target."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "in your output, the shortest path from 2 to 3 is 2->0->3 with length 7. It is incorrect\\n\\nIt\\'s a really difficult problem bro, that kind of stuff is only the tip of the iceberg of debugging you;ll have to go through before getting AC"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "2 ques gang?!"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why there is a 2300 rating problem from codeforces in a leetcode contest?\\nhttps://codeforces.com/problemset/problem/715/B"
                    },
                    {
                        "username": "shivansh961",
                        "content": "LeetCode is high."
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "4\\n[[0,1,-1],[2,0,2],[3,2,6],[2,1,10],[3,0,-1]]\\n1\\n3\\n12\\n\\nmy output : [[0,1,1],[2,0,2],[3,2,6],[2,1,10],[3,0,11]]\\nexpected : [[0,1,11],[2,0,2],[3,2,6],[2,1,10],[3,0,1]]\\nthe question says if there are multiple modifications return any of them, then why is my output wrong."
                    },
                    {
                        "username": "vikassuthar528",
                        "content": "I\\'m also getting same test case wrong."
                    },
                    {
                        "username": "krobzh",
                        "content": " In your output, the shortest distance from 1 to 3 is 1->0->2->3 which is 9,  not 12. I got the similar error in another test case in which I break the original shortest path and made a shorter path.  "
                    },
                    {
                        "username": "aniketkr01",
                        "content": "Same happened with me"
                    },
                    {
                        "username": "HLeiTR",
                        "content": "I am a little bit confused on this test case: \n\n```\nn = 5\nedges = [[1,4,1],[2,4,-1],[3,0,2],[0,4,-1],[1,3,10],[1,0,10]]\nsource = 0\ndestination = 2\ntarget = 15\n```\n\nNotice that in this graph, the only paths from 0 to 2 are: \n0 -> 3 -> 1 -> 4 -> 2, with cost 2 + 10 + 1 = 13 and 1 changeable\n0 -> 4 -> 2, with cost 0 and 2 changeable\n0 -> 1 -> 4 -> 2, with cost 10 + 1 and 1 changeable\n\nThe expected answer is: \n`[[1,4,1],[2,4,4],[3,0,2],[0,4,14],[1,3,10],[1,0,10]]`\nWhich suggests that it took the third path, and changing the weight of (2, 4) to 4. \n(Also, I'm not sure why it changed the edge of 0 to 4 to have a weight of 14, it is not even used?)\n\nHowever, my answer is:\n`[[1,4,1],[2,4,1],[3,0,2],[0,4,14],[1,3,10],[1,0,10]]`\nWhich took the second path, and changing one of the weights to 14 and the other to 1. \nThen, I changed all other unused, changeable edges to have weight 1. \n\nShouldn't this also be considered correct by the problem description? \nAny help is appreciated, very confused on this question :c"
                    },
                    {
                        "username": "Hackytech",
                        "content": "[@Finesse](/Finesse) No matter how many times I read the question or go through some solutions, i am not able to identify what is the meaning of shortest path over here. It's definitely not the sum of edges because it has to be equal to target so no matter which valid path you choose, we can make it equal to target. So is it the number of edges between the source and destination. I am too confused, please correct me If I am wrong at some point. \n Thanks"
                    },
                    {
                        "username": "HLeiTR",
                        "content": "[@Finesse](/Finesse) \\n! Ahh\\nI see the problem now, thanks a lot!"
                    },
                    {
                        "username": "Finesse",
                        "content": "> Then, I changed all other unused, changeable edges to have weight 1\n\n...and made another path be shorter than 15. That's your mistake.\n\nAfter changing the weights, all the other path distances must be recalculated, and the smallest must equal target.\n\nChange the unused edge weights to the maximum instead."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "For the following testcase, why is the answer an empty matrix?\\n\\n`n = 4,\\nedges = [[0,1,-1],[1,2,-1],[3,1,-1],[3,0,2],[0,2,5]],\\nsource = 2,\\ndestination = 3,\\ntarget = 8`"
                    },
                    {
                        "username": "monster_10",
                        "content": "Time complexity is O(M*M*LOG(V)) it runs fine but doesn\\'t comply with the constraints as it should give TLE"
                    },
                    {
                        "username": "dmitryartux",
                        "content": ">If the shortest path from source to destination including the edges to be modified and assigning them a temporary weight of 1, is less than the target, then it is also not possible.\\n\\n**Looks like the Hint #3 is wrong**"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Yes, should be \\'MORE than the target\\'."
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "The 3rd hint is wrong, instead of \"less than the target\", it should be \"greater than the target\".  "
                    }
                ]
            },
            {
                "id": 1902326,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "This is the last time I attempt the hard problem before the medium in a contest! \\nHonestly, this one didn;t look too bad at first, just a modified Djikstra, right?\\nOh boy, was I wrong"
                    },
                    {
                        "username": "Finesse",
                        "content": "I've managed to solve using a single modified Dijkstra's cycle. Throughout every path with `distance≤target`, you need to find the one with the fewest `-1` edges (the `-1` edges add the minimum weight which is `1`). To implement it, don't sort the heap by the distance; sort by the number of `-1` edges first, and then by the distance. If that path has no `-1` edges, the answer is `[]`, otherwise fill all the edges on the path with some weights to meet the target and the other edges with `2e9`. [My code.](https://leetcode.com/problems/modify-graph-edge-weights/submissions/954301674/)"
                    },
                    {
                        "username": "jasonechiu",
                        "content": "The test case seems incorrect.\\nFor testcase `353`\\nn = 4\\nedges = [[0,1,-1],[1,2,-1],[3,1,-1],[3,0,2],[0,2,5]]\\nsource = 2\\ndestination = 3\\ntarget = 8\\n\\nMy output is [[0,1,1],[1,2,1],[3,1,7],[3,0,2],[0,2,5]]\\nWhich means we can travel 2 -> 1 -> 3 and the sum is 8\\nBut it expect []\\n\\n\\nIt seems the solution is wrong."
                    },
                    {
                        "username": "Chrishu5777",
                        "content": "[@cartesPerforees](/cartesPerforees) thanks!!"
                    },
                    {
                        "username": "narang_madhur",
                        "content": "[@cartesPerforees](/cartesPerforees) Thanks for pointing out the error in output logic...I understood my mistake too.\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@jasonechiu](/jasonechiu) yup. The shortest of all distances from source to destination has to be target.\\nReally tough problem"
                    },
                    {
                        "username": "jasonechiu",
                        "content": "[@cartesPerforees](/cartesPerforees) \\nThanks for reply, I misunderstand the question. I suppose one shortest distance between the nodes source and destination. But it means \"all\" shortest distance between the nodes source and destination the sum of the weights should match the target."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "in your output, the shortest path from 2 to 3 is 2->0->3 with length 7. It is incorrect\\n\\nIt\\'s a really difficult problem bro, that kind of stuff is only the tip of the iceberg of debugging you;ll have to go through before getting AC"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "2 ques gang?!"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why there is a 2300 rating problem from codeforces in a leetcode contest?\\nhttps://codeforces.com/problemset/problem/715/B"
                    },
                    {
                        "username": "shivansh961",
                        "content": "LeetCode is high."
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "4\\n[[0,1,-1],[2,0,2],[3,2,6],[2,1,10],[3,0,-1]]\\n1\\n3\\n12\\n\\nmy output : [[0,1,1],[2,0,2],[3,2,6],[2,1,10],[3,0,11]]\\nexpected : [[0,1,11],[2,0,2],[3,2,6],[2,1,10],[3,0,1]]\\nthe question says if there are multiple modifications return any of them, then why is my output wrong."
                    },
                    {
                        "username": "vikassuthar528",
                        "content": "I\\'m also getting same test case wrong."
                    },
                    {
                        "username": "krobzh",
                        "content": " In your output, the shortest distance from 1 to 3 is 1->0->2->3 which is 9,  not 12. I got the similar error in another test case in which I break the original shortest path and made a shorter path.  "
                    },
                    {
                        "username": "aniketkr01",
                        "content": "Same happened with me"
                    },
                    {
                        "username": "HLeiTR",
                        "content": "I am a little bit confused on this test case: \n\n```\nn = 5\nedges = [[1,4,1],[2,4,-1],[3,0,2],[0,4,-1],[1,3,10],[1,0,10]]\nsource = 0\ndestination = 2\ntarget = 15\n```\n\nNotice that in this graph, the only paths from 0 to 2 are: \n0 -> 3 -> 1 -> 4 -> 2, with cost 2 + 10 + 1 = 13 and 1 changeable\n0 -> 4 -> 2, with cost 0 and 2 changeable\n0 -> 1 -> 4 -> 2, with cost 10 + 1 and 1 changeable\n\nThe expected answer is: \n`[[1,4,1],[2,4,4],[3,0,2],[0,4,14],[1,3,10],[1,0,10]]`\nWhich suggests that it took the third path, and changing the weight of (2, 4) to 4. \n(Also, I'm not sure why it changed the edge of 0 to 4 to have a weight of 14, it is not even used?)\n\nHowever, my answer is:\n`[[1,4,1],[2,4,1],[3,0,2],[0,4,14],[1,3,10],[1,0,10]]`\nWhich took the second path, and changing one of the weights to 14 and the other to 1. \nThen, I changed all other unused, changeable edges to have weight 1. \n\nShouldn't this also be considered correct by the problem description? \nAny help is appreciated, very confused on this question :c"
                    },
                    {
                        "username": "Hackytech",
                        "content": "[@Finesse](/Finesse) No matter how many times I read the question or go through some solutions, i am not able to identify what is the meaning of shortest path over here. It's definitely not the sum of edges because it has to be equal to target so no matter which valid path you choose, we can make it equal to target. So is it the number of edges between the source and destination. I am too confused, please correct me If I am wrong at some point. \n Thanks"
                    },
                    {
                        "username": "HLeiTR",
                        "content": "[@Finesse](/Finesse) \\n! Ahh\\nI see the problem now, thanks a lot!"
                    },
                    {
                        "username": "Finesse",
                        "content": "> Then, I changed all other unused, changeable edges to have weight 1\n\n...and made another path be shorter than 15. That's your mistake.\n\nAfter changing the weights, all the other path distances must be recalculated, and the smallest must equal target.\n\nChange the unused edge weights to the maximum instead."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "For the following testcase, why is the answer an empty matrix?\\n\\n`n = 4,\\nedges = [[0,1,-1],[1,2,-1],[3,1,-1],[3,0,2],[0,2,5]],\\nsource = 2,\\ndestination = 3,\\ntarget = 8`"
                    },
                    {
                        "username": "monster_10",
                        "content": "Time complexity is O(M*M*LOG(V)) it runs fine but doesn\\'t comply with the constraints as it should give TLE"
                    },
                    {
                        "username": "dmitryartux",
                        "content": ">If the shortest path from source to destination including the edges to be modified and assigning them a temporary weight of 1, is less than the target, then it is also not possible.\\n\\n**Looks like the Hint #3 is wrong**"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Yes, should be \\'MORE than the target\\'."
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "The 3rd hint is wrong, instead of \"less than the target\", it should be \"greater than the target\".  "
                    }
                ]
            },
            {
                "id": 1902290,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "This is the last time I attempt the hard problem before the medium in a contest! \\nHonestly, this one didn;t look too bad at first, just a modified Djikstra, right?\\nOh boy, was I wrong"
                    },
                    {
                        "username": "Finesse",
                        "content": "I've managed to solve using a single modified Dijkstra's cycle. Throughout every path with `distance≤target`, you need to find the one with the fewest `-1` edges (the `-1` edges add the minimum weight which is `1`). To implement it, don't sort the heap by the distance; sort by the number of `-1` edges first, and then by the distance. If that path has no `-1` edges, the answer is `[]`, otherwise fill all the edges on the path with some weights to meet the target and the other edges with `2e9`. [My code.](https://leetcode.com/problems/modify-graph-edge-weights/submissions/954301674/)"
                    },
                    {
                        "username": "jasonechiu",
                        "content": "The test case seems incorrect.\\nFor testcase `353`\\nn = 4\\nedges = [[0,1,-1],[1,2,-1],[3,1,-1],[3,0,2],[0,2,5]]\\nsource = 2\\ndestination = 3\\ntarget = 8\\n\\nMy output is [[0,1,1],[1,2,1],[3,1,7],[3,0,2],[0,2,5]]\\nWhich means we can travel 2 -> 1 -> 3 and the sum is 8\\nBut it expect []\\n\\n\\nIt seems the solution is wrong."
                    },
                    {
                        "username": "Chrishu5777",
                        "content": "[@cartesPerforees](/cartesPerforees) thanks!!"
                    },
                    {
                        "username": "narang_madhur",
                        "content": "[@cartesPerforees](/cartesPerforees) Thanks for pointing out the error in output logic...I understood my mistake too.\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@jasonechiu](/jasonechiu) yup. The shortest of all distances from source to destination has to be target.\\nReally tough problem"
                    },
                    {
                        "username": "jasonechiu",
                        "content": "[@cartesPerforees](/cartesPerforees) \\nThanks for reply, I misunderstand the question. I suppose one shortest distance between the nodes source and destination. But it means \"all\" shortest distance between the nodes source and destination the sum of the weights should match the target."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "in your output, the shortest path from 2 to 3 is 2->0->3 with length 7. It is incorrect\\n\\nIt\\'s a really difficult problem bro, that kind of stuff is only the tip of the iceberg of debugging you;ll have to go through before getting AC"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "2 ques gang?!"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Why there is a 2300 rating problem from codeforces in a leetcode contest?\\nhttps://codeforces.com/problemset/problem/715/B"
                    },
                    {
                        "username": "shivansh961",
                        "content": "LeetCode is high."
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "4\\n[[0,1,-1],[2,0,2],[3,2,6],[2,1,10],[3,0,-1]]\\n1\\n3\\n12\\n\\nmy output : [[0,1,1],[2,0,2],[3,2,6],[2,1,10],[3,0,11]]\\nexpected : [[0,1,11],[2,0,2],[3,2,6],[2,1,10],[3,0,1]]\\nthe question says if there are multiple modifications return any of them, then why is my output wrong."
                    },
                    {
                        "username": "vikassuthar528",
                        "content": "I\\'m also getting same test case wrong."
                    },
                    {
                        "username": "krobzh",
                        "content": " In your output, the shortest distance from 1 to 3 is 1->0->2->3 which is 9,  not 12. I got the similar error in another test case in which I break the original shortest path and made a shorter path.  "
                    },
                    {
                        "username": "aniketkr01",
                        "content": "Same happened with me"
                    },
                    {
                        "username": "HLeiTR",
                        "content": "I am a little bit confused on this test case: \n\n```\nn = 5\nedges = [[1,4,1],[2,4,-1],[3,0,2],[0,4,-1],[1,3,10],[1,0,10]]\nsource = 0\ndestination = 2\ntarget = 15\n```\n\nNotice that in this graph, the only paths from 0 to 2 are: \n0 -> 3 -> 1 -> 4 -> 2, with cost 2 + 10 + 1 = 13 and 1 changeable\n0 -> 4 -> 2, with cost 0 and 2 changeable\n0 -> 1 -> 4 -> 2, with cost 10 + 1 and 1 changeable\n\nThe expected answer is: \n`[[1,4,1],[2,4,4],[3,0,2],[0,4,14],[1,3,10],[1,0,10]]`\nWhich suggests that it took the third path, and changing the weight of (2, 4) to 4. \n(Also, I'm not sure why it changed the edge of 0 to 4 to have a weight of 14, it is not even used?)\n\nHowever, my answer is:\n`[[1,4,1],[2,4,1],[3,0,2],[0,4,14],[1,3,10],[1,0,10]]`\nWhich took the second path, and changing one of the weights to 14 and the other to 1. \nThen, I changed all other unused, changeable edges to have weight 1. \n\nShouldn't this also be considered correct by the problem description? \nAny help is appreciated, very confused on this question :c"
                    },
                    {
                        "username": "Hackytech",
                        "content": "[@Finesse](/Finesse) No matter how many times I read the question or go through some solutions, i am not able to identify what is the meaning of shortest path over here. It's definitely not the sum of edges because it has to be equal to target so no matter which valid path you choose, we can make it equal to target. So is it the number of edges between the source and destination. I am too confused, please correct me If I am wrong at some point. \n Thanks"
                    },
                    {
                        "username": "HLeiTR",
                        "content": "[@Finesse](/Finesse) \\n! Ahh\\nI see the problem now, thanks a lot!"
                    },
                    {
                        "username": "Finesse",
                        "content": "> Then, I changed all other unused, changeable edges to have weight 1\n\n...and made another path be shorter than 15. That's your mistake.\n\nAfter changing the weights, all the other path distances must be recalculated, and the smallest must equal target.\n\nChange the unused edge weights to the maximum instead."
                    },
                    {
                        "username": "arghydas_0155",
                        "content": "For the following testcase, why is the answer an empty matrix?\\n\\n`n = 4,\\nedges = [[0,1,-1],[1,2,-1],[3,1,-1],[3,0,2],[0,2,5]],\\nsource = 2,\\ndestination = 3,\\ntarget = 8`"
                    },
                    {
                        "username": "monster_10",
                        "content": "Time complexity is O(M*M*LOG(V)) it runs fine but doesn\\'t comply with the constraints as it should give TLE"
                    },
                    {
                        "username": "dmitryartux",
                        "content": ">If the shortest path from source to destination including the edges to be modified and assigning them a temporary weight of 1, is less than the target, then it is also not possible.\\n\\n**Looks like the Hint #3 is wrong**"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Yes, should be \\'MORE than the target\\'."
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "The 3rd hint is wrong, instead of \"less than the target\", it should be \"greater than the target\".  "
                    }
                ]
            }
        ]
    },
    {
        "title": "Greatest Common Divisor Traversal",
        "question_content": "<p>You are given a <strong>0-indexed</strong> integer array <code>nums</code>, and you are allowed to <strong>traverse</strong> between its indices. You can traverse between index <code>i</code> and index <code>j</code>, <code>i != j</code>, if and only if <code>gcd(nums[i], nums[j]) &gt; 1</code>, where <code>gcd</code> is the <strong>greatest common divisor</strong>.</p>\n\n<p>Your task is to determine if for <strong>every pair</strong> of indices <code>i</code> and <code>j</code> in nums, where <code>i &lt; j</code>, there exists a <strong>sequence of traversals</strong> that can take us from <code>i</code> to <code>j</code>.</p>\n\n<p>Return <code>true</code><em> if it is possible to traverse between all such pairs of indices,</em><em> or </em><code>false</code><em> otherwise.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,3,6]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> In this example, there are 3 possible pairs of indices: (0, 1), (0, 2), and (1, 2).\nTo go from index 0 to index 1, we can use the sequence of traversals 0 -&gt; 2 -&gt; 1, where we move from index 0 to index 2 because gcd(nums[0], nums[2]) = gcd(2, 6) = 2 &gt; 1, and then move from index 2 to index 1 because gcd(nums[2], nums[1]) = gcd(6, 3) = 3 &gt; 1.\nTo go from index 0 to index 2, we can just go directly because gcd(nums[0], nums[2]) = gcd(2, 6) = 2 &gt; 1. Likewise, to go from index 1 to index 2, we can just go directly because gcd(nums[1], nums[2]) = gcd(3, 6) = 3 &gt; 1.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,9,5]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> No sequence of traversals can take us from index 0 to index 2 in this example. So, we return false.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [4,3,12,8]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> There are 6 possible pairs of indices to traverse between: (0, 1), (0, 2), (0, 3), (1, 2), (1, 3), and (2, 3). A valid sequence of traversals exists for each pair, so we return true.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3568567,
                "title": "union-find-in-c-java-and-python",
                "content": "# Intuition\\nFind all prime factors of each array element and construct a graph.\\n\\n\\nConstruct an undirected graph.\\nNode: Each array element is a node.\\nEdge: If 2 array elements have at least one common prime factor, then we create an edge connecting them.\\nHowever, constructing the graph directly has higher time complexity. We can find all prime factors of each array element, and put the array element into the corresponding lists according to its prime factors.\\n\\n\\nFor example, 60 = 2 ^ 2 * 3 * 5\\nWe put 60 in the list of 2, 3, and 5.\\nNow each pair of elements in the same list should have an edge. \\nAnd the key point here is for each list, we just need to create an edge between the first element and any other elements instead.\\n\\n\\nFor example, 3, 15, 60, 99 are in the list of 3.\\nWe only need to create edges (3, 15), (3, 60) and (3, 99).\\n\\n\\nThe question is to ask whether the graph is connected.\\n\\n\\n# Approach\\nConstruct the above graph, and check the connectivity. \\nOne way to do it is to use union-find set and check whether it has only one connected component. (Using BFS/DFS is also fine.)\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(sqrt(M) * N) where M is the largest number (considering each union-find operation takes O(1) time).\\n\\n\\n- Space complexity:\\nO(N)\\n\\n\\n# Code\\n\\n\\nC++\\n```\\nclass Solution {\\n    int getf(vector<int> &f, int x) {\\n        return f[x] == x ? x : (f[x] = getf(f, f[x]));\\n    }\\n    \\n    void merge(vector<int> &f, vector<int> &num, int x, int y) {\\n        x = getf(f, x);\\n        y = getf(f, y);\\n        if (x == y) {\\n            return;\\n        }\\n        if (num[x] < num[y]) {\\n            swap(x, y);\\n        }\\n        f[y] = x;\\n        num[x] += num[y];\\n    }\\npublic:\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        const int n = nums.size();\\n        if (n == 1) {\\n            return true;\\n        }\\n        vector<int> f(n), num(n);\\n        for (int i = 0; i < n; ++i) {\\n            f[i] = i;\\n            num[i] = 1;\\n        }\\n        unordered_map<int, int> have;\\n        for (int i = 0; i < n; ++i) {\\n            int x = nums[i];\\n            if (x == 1) {\\n                return false;\\n            }\\n            for (int d = 2; d * d <= x; ++d) {\\n                if (x % d == 0) {\\n                    if (have.count(d)) {\\n                        merge(f, num, i, have[d]);\\n                    } else {\\n                        have[d] = i;\\n                    }\\n                    while (x % d == 0) {\\n                        x /= d;\\n                    } \\n                }\\n            }\\n            if (x > 1) {\\n                if (have.count(x)) {\\n                    merge(f, num, i, have[x]);\\n                } else {\\n                    have[x] = i;\\n                }\\n            }\\n        }\\n        return num[getf(f, 0)] == n;\\n        \\n    }\\n};\\n     \\n```\\n\\n\\nJava:\\n```\\nclass Solution {\\n    private int getf(int[] f, int x) {\\n        return f[x] == x ? x : (f[x] = getf(f, f[x]));\\n    }\\n    \\n    private void merge(int[] f, int[] num, int x, int y) {\\n        x = getf(f, x);\\n        y = getf(f, y);\\n        if (x == y) {\\n            return;\\n        }\\n        if (num[x] < num[y]) {\\n            int t = x;\\n            x = y;\\n            y = t;\\n        }\\n        f[y] = x;\\n        num[x] += num[y];\\n    }\\n        \\n    public boolean canTraverseAllPairs(int[] nums) {\\n        final int n = nums.length;\\n        if (n == 1) {\\n            return true;\\n        }\\n        int[] f = new int[n], num = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            f[i] = i;\\n            num[i] = 1;\\n        }\\n        Map<Integer, Integer> have = new HashMap<>();\\n        for (int i = 0; i < n; ++i) {\\n            int x = nums[i];\\n            if (x == 1) {\\n                return false;\\n            }\\n            for (int d = 2; d * d <= x; ++d) {\\n                if (x % d == 0) {\\n                    if (have.containsKey(d)) {\\n                        merge(f, num, i, have.get(d));\\n                    } else {\\n                        have.put(d, i);\\n                    }\\n                    while (x % d == 0) {\\n                        x /= d;\\n                    } \\n                }\\n            }\\n            if (x > 1) {\\n                if (have.containsKey(x)) {\\n                    merge(f, num, i, have.get(x));\\n                } else {\\n                    have.put(x, i);\\n                }\\n            }\\n        }\\n        return num[getf(f, 0)] == n;\\n        \\n    }\\n}\\n\\n\\n```\\n\\n\\nPython3:\\n```\\nclass Solution:\\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        if n == 1:\\n            return True\\n        f = [_ for _ in range(0, n)]\\n        num = [1] * n\\n        \\n        def getf(x: int) -> int:\\n            if f[x] == x:\\n                return x\\n            f[x] = getf(f[x])\\n            return f[x]\\n        \\n        def merge(x: int, y: int):\\n            x, y = getf(x), getf(y)\\n            if x == y:\\n                return\\n            if num[x] < num[y]:\\n                x, y = y, x\\n            f[y] = x\\n            num[x] += num[y]\\n            \\n        have = {}\\n        for i in range(0, n):\\n            x = nums[i]\\n            if x == 1:\\n                return False\\n            d = 2\\n            while d * d <= x:\\n                if x % d == 0:\\n                    if d in have:\\n                        merge(i, have[d])\\n                    else:\\n                        have[d] = i\\n                    while x % d == 0:\\n                        x //= d\\n                d += 1\\n            if x > 1:\\n                if x in have:\\n                    merge(i, have[x])\\n                else:\\n                    have[x] = i\\n        return num[getf(0)] == n\\n        \\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    int getf(vector<int> &f, int x) {\\n        return f[x] == x ? x : (f[x] = getf(f, f[x]));\\n    }\\n    \\n    void merge(vector<int> &f, vector<int> &num, int x, int y) {\\n        x = getf(f, x);\\n        y = getf(f, y);\\n        if (x == y) {\\n            return;\\n        }\\n        if (num[x] < num[y]) {\\n            swap(x, y);\\n        }\\n        f[y] = x;\\n        num[x] += num[y];\\n    }\\npublic:\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        const int n = nums.size();\\n        if (n == 1) {\\n            return true;\\n        }\\n        vector<int> f(n), num(n);\\n        for (int i = 0; i < n; ++i) {\\n            f[i] = i;\\n            num[i] = 1;\\n        }\\n        unordered_map<int, int> have;\\n        for (int i = 0; i < n; ++i) {\\n            int x = nums[i];\\n            if (x == 1) {\\n                return false;\\n            }\\n            for (int d = 2; d * d <= x; ++d) {\\n                if (x % d == 0) {\\n                    if (have.count(d)) {\\n                        merge(f, num, i, have[d]);\\n                    } else {\\n                        have[d] = i;\\n                    }\\n                    while (x % d == 0) {\\n                        x /= d;\\n                    } \\n                }\\n            }\\n            if (x > 1) {\\n                if (have.count(x)) {\\n                    merge(f, num, i, have[x]);\\n                } else {\\n                    have[x] = i;\\n                }\\n            }\\n        }\\n        return num[getf(f, 0)] == n;\\n        \\n    }\\n};\\n     \\n```\n```\\nclass Solution {\\n    private int getf(int[] f, int x) {\\n        return f[x] == x ? x : (f[x] = getf(f, f[x]));\\n    }\\n    \\n    private void merge(int[] f, int[] num, int x, int y) {\\n        x = getf(f, x);\\n        y = getf(f, y);\\n        if (x == y) {\\n            return;\\n        }\\n        if (num[x] < num[y]) {\\n            int t = x;\\n            x = y;\\n            y = t;\\n        }\\n        f[y] = x;\\n        num[x] += num[y];\\n    }\\n        \\n    public boolean canTraverseAllPairs(int[] nums) {\\n        final int n = nums.length;\\n        if (n == 1) {\\n            return true;\\n        }\\n        int[] f = new int[n], num = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            f[i] = i;\\n            num[i] = 1;\\n        }\\n        Map<Integer, Integer> have = new HashMap<>();\\n        for (int i = 0; i < n; ++i) {\\n            int x = nums[i];\\n            if (x == 1) {\\n                return false;\\n            }\\n            for (int d = 2; d * d <= x; ++d) {\\n                if (x % d == 0) {\\n                    if (have.containsKey(d)) {\\n                        merge(f, num, i, have.get(d));\\n                    } else {\\n                        have.put(d, i);\\n                    }\\n                    while (x % d == 0) {\\n                        x /= d;\\n                    } \\n                }\\n            }\\n            if (x > 1) {\\n                if (have.containsKey(x)) {\\n                    merge(f, num, i, have.get(x));\\n                } else {\\n                    have.put(x, i);\\n                }\\n            }\\n        }\\n        return num[getf(f, 0)] == n;\\n        \\n    }\\n}\\n\\n\\n```\n```\\nclass Solution:\\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        if n == 1:\\n            return True\\n        f = [_ for _ in range(0, n)]\\n        num = [1] * n\\n        \\n        def getf(x: int) -> int:\\n            if f[x] == x:\\n                return x\\n            f[x] = getf(f[x])\\n            return f[x]\\n        \\n        def merge(x: int, y: int):\\n            x, y = getf(x), getf(y)\\n            if x == y:\\n                return\\n            if num[x] < num[y]:\\n                x, y = y, x\\n            f[y] = x\\n            num[x] += num[y]\\n            \\n        have = {}\\n        for i in range(0, n):\\n            x = nums[i]\\n            if x == 1:\\n                return False\\n            d = 2\\n            while d * d <= x:\\n                if x % d == 0:\\n                    if d in have:\\n                        merge(i, have[d])\\n                    else:\\n                        have[d] = i\\n                    while x % d == 0:\\n                        x //= d\\n                d += 1\\n            if x > 1:\\n                if x in have:\\n                    merge(i, have[x])\\n                else:\\n                    have[x] = i\\n        return num[getf(0)] == n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568580,
                "title": "union-find",
                "content": "If two numbers share a prime factor, we can traverse between these numbers. \\n\\nSo, we first collect prime factors for each number.\\n\\n> We only need factors till `sqrt(100000)` - 65 primes from `2` to `313`. We can use Sieve of Eratosthenes - or a static pre-computed array.\\n> Note that if, after removing all primes, `nums[i] > 1`, then `nums[i]` is some large prime.\\n    \\nWe use a hash map `p_i` to map primes to the index of the number.\\n\\nIf the hash map already contains an index, we can group this and the previous number using **union-find**.\\n\\nWe return true if all numbers bellong to the same (single) group.\\n\\n**C++**\\n```cpp\\nconst int primes[65] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, \\n    53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, \\n    137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, \\n    227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313};\\nint find(int i, vector<int> &ds) {\\n    return ds[i] < 0 ? i : ds[i] = find(ds[i], ds);\\n}\\nvector<int> factorize(int n) {\\n    vector<int> facts;\\n    for (int p : primes)\\n        if (n % p == 0) {\\n            facts.push_back(p);\\n            while(n % p == 0)\\n                n /= p;\\n        }\\n    if (n != 1) // Some large prime\\n        facts.push_back(n);\\n    return facts;\\n}\\nbool canTraverseAllPairs(vector<int>& nums) {\\n    vector<int> ds(nums.size(), -1);\\n    unordered_map<int, int> p_i;\\n    for (int i = 0; i < nums.size(); ++i)\\n        for (int f : factorize(nums[i])) {\\n            auto it = p_i.find(f);\\n            if (it != end(p_i)) {\\n                int pi = find(i, ds), pj = find(it->second, ds);\\n                if (pi != pj) { // Union\\n                    if (ds[pi] > ds[pj])\\n                        swap(pi, pj); // Rank\\n                    ds[pi] += ds[pj];\\n                    ds[pj] = pi;\\n                }                \\n            }\\n            else\\n                p_i.emplace(f, i);\\n        }\\n    return abs(*min_element(begin(ds), end(ds))) == nums.size();\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nconst int primes[65] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, \\n    53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, \\n    137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, \\n    227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313};\\nint find(int i, vector<int> &ds) {\\n    return ds[i] < 0 ? i : ds[i] = find(ds[i], ds);\\n}\\nvector<int> factorize(int n) {\\n    vector<int> facts;\\n    for (int p : primes)\\n        if (n % p == 0) {\\n            facts.push_back(p);\\n            while(n % p == 0)\\n                n /= p;\\n        }\\n    if (n != 1) // Some large prime\\n        facts.push_back(n);\\n    return facts;\\n}\\nbool canTraverseAllPairs(vector<int>& nums) {\\n    vector<int> ds(nums.size(), -1);\\n    unordered_map<int, int> p_i;\\n    for (int i = 0; i < nums.size(); ++i)\\n        for (int f : factorize(nums[i])) {\\n            auto it = p_i.find(f);\\n            if (it != end(p_i)) {\\n                int pi = find(i, ds), pj = find(it->second, ds);\\n                if (pi != pj) { // Union\\n                    if (ds[pi] > ds[pj])\\n                        swap(pi, pj); // Rank\\n                    ds[pi] += ds[pj];\\n                    ds[pj] = pi;\\n                }                \\n            }\\n            else\\n                p_i.emplace(f, i);\\n        }\\n    return abs(*min_element(begin(ds), end(ds))) == nums.size();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3568561,
                "title": "c-java-python-prime-factorization-then-union-find",
                "content": "> **I know almost nothing about English, pointing out the mistakes in my article would be much appreciated.**\\n\\n> **In addition, I\\'m too weak, please be critical of my ideas.**\\n---\\n\\n# Intuition\\n1. The simplest understanding is to regard each element as a node of the graph, then this question becomes **\"checking whether an undirected graph is a connected graph\"**.\\n2. A relatively simple solution to find out whether a graph is a connected graph is to use [Union Find](https://en.wikipedia.org/wiki/Disjoint-set_data_structure). For any element $a_i$, it can be used as a \"bridge\" between other elements and play a role in connection. This relationship is very suitable for maintenance by Union Find.\\n3. **Obviously, the condition of $\\\\gcd(a_i, a_j) > 1$ in the original question can be equivalent to \"$a_i$ and $a_j$ have a common prime factor\".**\\n4. So just merge elements with common prime factors together and finally **check if they can form a large set containing all elements.**\\n5. Because the Union Find doesn\\'t care who and the order of the merge, for each prime factor $p$, we can select only one representative and the other elements which has prime factor $p$ can be merged with this representative.\\n\\n# Approach\\n- The Union Find has many way to implement. I used the implementation of **path compression + merge by size**. This is actually a basic topic. If you need a detailed explanation, you can leave a message in the comment area.\\n- Prime factorization for $x$ is an interesting and classic topic, I just introduce a naive $O(\\\\sqrt{x})$ algorithm here:\\n    Obviously, if there is a pair of integers $p$ and $q$ where $pq=x$, here we might as well assume that $p \\\\leq q $. So we can always try to enumerate the smaller $p$.\\n    Notice that $p \\\\leq q$, so $p^2 \\\\leq pq = x$, so $p^2 \\\\leq x$ will always true. So we only need to enumerate from $2$ to $\\\\lfloor  \\\\sqrt{n} \\\\rfloor $.\\n    If we find a $p$ such that it is divisible by $x$, the $p$ is a prime factor of $x$. Thereafter, all $p$ can be divided from $x$ , then perform the algorithm recursively.\\n    Otherwise, $x$ may be a prime because the only legal $pq=x$ is $1 \\\\cdot x = x$. So finally we need to check $x$ is $1$ or not. If not, the remaining $x$ is also a prime factor.\\n\\n# Complexity\\n- Time complexity: $O(n \\\\sum\\\\limits_{i=0}^{n-1}{\\\\sqrt{a_i}})$\\n- Space complexity: $O\\\\{\\\\max(a_i)\\\\}$ or $O\\\\{\\\\pi[\\\\max(a_i)]\\\\}$, depends on which data structure was used.\\n\\n# Code\\n``` C++ []\\nstruct UnionFind {\\n    std::vector<int> fa;\\n    std::vector<int> size;\\n    UnionFind(int n) : fa(n), size(n, 1) {\\n        for (int i = 0; i < n; ++i) fa[i] = i;\\n    }\\n    int getFa(int i) {\\n        return i == fa[i] ? i : (fa[i] = getFa(fa[i]));\\n    }\\n    void merge(int i, int j) {\\n        int fi = getFa(i), fj = getFa(j);\\n        if (fi == fj) return;\\n        if (size[fi] > size[fj]) swap<int>(fi, fj);\\n        size[fj] += size[fi];\\n        fa[fi] = fj;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    bool canTraverseAllPairs(vector<int>& a) {\\n        int n = a.size(), m = *max_element(a.begin(), a.end());\\n        vector<int> fst(m+1, -1);\\n        UnionFind u(n);\\n        for (int i = 0; i < n; ++i) {\\n            for (int p = 2; p * p <= a[i]; ++p) {\\n                if (a[i] % p != 0) continue;\\n                if (fst[p] != -1) u.merge(fst[p], i);\\n                else fst[p] = i;\\n                while (a[i] % p == 0) a[i] /= p;\\n            }\\n            if (a[i] > 1) {\\n                if (fst[a[i]] != -1) u.merge(fst[a[i]], i);\\n                else fst[a[i]] = i;\\n            }\\n        }\\n        return u.size[u.getFa(0)] == n;\\n    }\\n};\\n```\\n``` Java []\\nclass UnionFind {\\n    public int[] fa;\\n    public int[] size;\\n    public UnionFind(int n) {\\n        fa = new int[n];\\n        size = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            fa[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n    public int getFa(int i) {\\n        return i == fa[i] ? i : (fa[i] = getFa(fa[i]));\\n    }\\n    public void merge(int i, int j) {\\n        int fi = getFa(i);\\n        int fj = getFa(j);\\n        if (fi == fj) return;\\n        if (size[fi] > size[fj]) {\\n            size[fi] += size[fj];\\n            fa[fj] = fi;\\n        }\\n        else {\\n            size[fj] += size[fi];\\n            fa[fi] = fj;\\n        }\\n    }\\n}\\nclass Solution {\\n    public boolean canTraverseAllPairs(int[] a) {\\n        int n = a.length;\\n        UnionFind u = new UnionFind(n);\\n        HashMap<Integer, Integer> fst = new HashMap<>();\\n        for (int i = 0; i < a.length; ++i) {\\n            for (int p = 2; p * p <= a[i]; ++p) {\\n                if (a[i] % p != 0) continue;\\n                if (fst.containsKey(p)) u.merge(fst.get(p), i);\\n                else fst.put(p, i);\\n                while (a[i] % p == 0) a[i] /= p;\\n            }\\n            if (a[i] > 1) {\\n                if (fst.containsKey(a[i])) u.merge(fst.get(a[i]), i);\\n                else fst.put(a[i], i);\\n            }\\n        }\\n        return u.size[u.getFa(0)] == n;\\n    }\\n}\\n```\\n``` Python3 []\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.fa = [i for i in range(n)]\\n        self.size = [1] * n\\n    def getFa(self, i):\\n        if i == self.fa[i]:\\n            return i\\n        self.fa[i] = self.getFa(self.fa[i])\\n        return self.fa[i]\\n    def merge(self, i, j):\\n        fi, fj = self.getFa(i), self.getFa(j)\\n        if fi == fj: return\\n        if self.size[fi] > self.size[fj]: fi, fj = fj, fi\\n        self.size[fj] += self.size[fi]\\n        self.fa[fi] = fj\\n    \\nclass Solution:\\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\\n        fst = [-1] * (1 + max(nums))\\n        u = UnionFind(len(nums))\\n        for i, x in enumerate(nums):\\n            for p in range(2, x):\\n                if p * p > x: break\\n                if x % p != 0: continue\\n                if fst[p] != -1: u.merge(fst[p], i)\\n                else: fst[p] = i\\n                while x % p == 0: x //= p\\n            if x > 1:\\n                if fst[x] != -1: u.merge(fst[x], i);\\n                else: fst[x] = i\\n        return u.size[u.getFa(0)] == len(nums)\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Math",
                    "Union Find"
                ],
                "code": "``` C++ []\\nstruct UnionFind {\\n    std::vector<int> fa;\\n    std::vector<int> size;\\n    UnionFind(int n) : fa(n), size(n, 1) {\\n        for (int i = 0; i < n; ++i) fa[i] = i;\\n    }\\n    int getFa(int i) {\\n        return i == fa[i] ? i : (fa[i] = getFa(fa[i]));\\n    }\\n    void merge(int i, int j) {\\n        int fi = getFa(i), fj = getFa(j);\\n        if (fi == fj) return;\\n        if (size[fi] > size[fj]) swap<int>(fi, fj);\\n        size[fj] += size[fi];\\n        fa[fi] = fj;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    bool canTraverseAllPairs(vector<int>& a) {\\n        int n = a.size(), m = *max_element(a.begin(), a.end());\\n        vector<int> fst(m+1, -1);\\n        UnionFind u(n);\\n        for (int i = 0; i < n; ++i) {\\n            for (int p = 2; p * p <= a[i]; ++p) {\\n                if (a[i] % p != 0) continue;\\n                if (fst[p] != -1) u.merge(fst[p], i);\\n                else fst[p] = i;\\n                while (a[i] % p == 0) a[i] /= p;\\n            }\\n            if (a[i] > 1) {\\n                if (fst[a[i]] != -1) u.merge(fst[a[i]], i);\\n                else fst[a[i]] = i;\\n            }\\n        }\\n        return u.size[u.getFa(0)] == n;\\n    }\\n};\\n```\n``` Java []\\nclass UnionFind {\\n    public int[] fa;\\n    public int[] size;\\n    public UnionFind(int n) {\\n        fa = new int[n];\\n        size = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            fa[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n    public int getFa(int i) {\\n        return i == fa[i] ? i : (fa[i] = getFa(fa[i]));\\n    }\\n    public void merge(int i, int j) {\\n        int fi = getFa(i);\\n        int fj = getFa(j);\\n        if (fi == fj) return;\\n        if (size[fi] > size[fj]) {\\n            size[fi] += size[fj];\\n            fa[fj] = fi;\\n        }\\n        else {\\n            size[fj] += size[fi];\\n            fa[fi] = fj;\\n        }\\n    }\\n}\\nclass Solution {\\n    public boolean canTraverseAllPairs(int[] a) {\\n        int n = a.length;\\n        UnionFind u = new UnionFind(n);\\n        HashMap<Integer, Integer> fst = new HashMap<>();\\n        for (int i = 0; i < a.length; ++i) {\\n            for (int p = 2; p * p <= a[i]; ++p) {\\n                if (a[i] % p != 0) continue;\\n                if (fst.containsKey(p)) u.merge(fst.get(p), i);\\n                else fst.put(p, i);\\n                while (a[i] % p == 0) a[i] /= p;\\n            }\\n            if (a[i] > 1) {\\n                if (fst.containsKey(a[i])) u.merge(fst.get(a[i]), i);\\n                else fst.put(a[i], i);\\n            }\\n        }\\n        return u.size[u.getFa(0)] == n;\\n    }\\n}\\n```\n``` Python3 []\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.fa = [i for i in range(n)]\\n        self.size = [1] * n\\n    def getFa(self, i):\\n        if i == self.fa[i]:\\n            return i\\n        self.fa[i] = self.getFa(self.fa[i])\\n        return self.fa[i]\\n    def merge(self, i, j):\\n        fi, fj = self.getFa(i), self.getFa(j)\\n        if fi == fj: return\\n        if self.size[fi] > self.size[fj]: fi, fj = fj, fi\\n        self.size[fj] += self.size[fi]\\n        self.fa[fi] = fj\\n    \\nclass Solution:\\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\\n        fst = [-1] * (1 + max(nums))\\n        u = UnionFind(len(nums))\\n        for i, x in enumerate(nums):\\n            for p in range(2, x):\\n                if p * p > x: break\\n                if x % p != 0: continue\\n                if fst[p] != -1: u.merge(fst[p], i)\\n                else: fst[p] = i\\n                while x % p == 0: x //= p\\n            if x > 1:\\n                if fst[x] != -1: u.merge(fst[x], i);\\n                else: fst[x] = i\\n        return u.size[u.getFa(0)] == len(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573061,
                "title": "c-java-python-intuition-explanation-connected-graph-readable-modular-code",
                "content": "# Intuition\\nChecking for every possible ${}^nC_2$ pairs is not possible due to time limit.\\n\\nIf $p$ is a prime factor of $nums[i]$, then we can go to every $nums[j]$, whose one prime factor is also $p$. Means we can traverse between two indices $[i, j]$ if they have at least one common prime factor.\\n\\nBut we also need to track indirect traversals where we can traverse from $nums[i]$ to $nums[j]$ and $nums[j]$ to $nums[k]$ but not $nums[i]$ to $nums[k]$ directly.\\n\\nFor example, $nums = [12, 15, 175]$. In prime-factorization form: $nums = [2^2.3, 3.5, 5^2.7]$. $gcd(12,175) = 1$ but we can still traverse between them via $15$, but not directly.\\n\\nThis gives the essence of creating a graph where vertices will be elements of $nums$ and edges will denote a **direct** traversal from $x$ to $y$. And after creating the graph, we can check if it is connected or not in $O(n)$ time by any DFS/BFS/UnionFind.\\n\\n# Approach\\n- Create a graph of `n = nums.length` number of nodes where nodes are ranging in `0 to n - 1`. Node `i` denotes the element `nums[i]`. Means we are making graph between **indices** of `nums`, and not the original elements.\\n- For every element `nums[i]`, calculate its prime factors. I\\'ll explain how to do this after approach, if you want to see.\\n- Using a hashmap `{prime, index}`, store the primes that we have seen until now at previous indices. This will help to find where was the current index\\'s prime factor seen before so that we can create a graph edge between them.\\n- If that prime factor was seen before, add edge between those indices. And if not, then just store it for future use. Also, if a prime factor is seen again, then we don\\'t need to update the previous index with current index because everything will eventually be connected directly or indirectly if it\\'s possible.\\n\\n**Edge Cases:**\\n1. If array length is 1, then return true.\\n2. If array length is not 1, but some $nums[i] = 1$, then return false. We can never go to $nums[i]$ because $gcd(1, anything) = 1$.\\n\\n## Prime Factorization\\nSee this if you want to understand how to calculate prime factors.\\nGiven an integer $x$, we want to calculate its prime factors. Every integer can be represented in prime-factorization form as:\\n$$x = P_1^{n_1}P_2^{n_2}P_3^{n_3}...P_k^{n_k}$$\\nWhere $P_1, P_2, P_3, ..., P_k$ are the prime factors of $x$ and $n_i$\\'s are their powers (or weights).\\nFor example, $25671492$ can be written as $2^2.3^5.7^4.11$\\n\\nLoop on `i: [2 to x]`, check if `i` divides the number `x`. If it divides, then it is a prime factor of `x`. Append it to the resulting prime factors list. Repeatedly divide the number `x` with `i` until it can divide in order to exhaust the power (or weight) of that prime factor.\\nThe reason we need to exhaust the prime factor\\'s power by repeated divisions is that so we don\\'t add non-prime factors in our list. For example, for $25671492 = 2^2.3^5.7^4.11$. While looping over `i`, both `2` and `4` are factors of `x`, but only `2` is the prime factor. So we need to completely remove `2` from `x` after it is found once. Then `x` will become $3^5.7^4.11$\\n\\n**Loop Optimization**: We don\\'t have to loop till `x`, we can stop before.\\nEvery number $x$ can be represented as pair product of it\\'s factors as $x = pq$. Without loss of generality we can say $p \\\\le q$, and $p^2 \\\\le pq$, meaning $p^2 \\\\le x$. So all prime factors can be found in range $[2, \\\\sqrt x]$, and if $x$ was prime itself, then it can be checked after the loop. Time complexity will be $O(\\\\sqrt x)$.\\n\\n> There is another approach for prime factorization with pre-computation of `Minimum Prime Sieve of Eratosthenes` which takes $O(\\\\log x)$ time but it is not needed for current problem. It\\'s available online if you want to take a look.\\n\\n# Code\\n\\n## Depth-First Search\\n```C++ []\\nclass Graph {\\nprivate:\\n    int n;\\n    vector<vector<int>> edges;\\n\\n    void traverse(int x, vector<bool>& visited) {\\n        visited[x] = true;\\n        for (int y: edges[x]) {\\n            if (!visited[y]) {\\n                traverse(y, visited);\\n            }\\n        }\\n    }\\n\\npublic:\\n    Graph(int n = 0) : n(n) {\\n        edges.resize(n);\\n    }\\n    \\n    void addEdge(int x, int y) {\\n        edges[x].push_back(y);\\n        edges[y].push_back(x);\\n    }\\n\\n    bool isConnected() {\\n        vector<bool> visited(n);\\n        traverse(0, visited);\\n        return count(visited.begin(), visited.end(), true) == n;\\n    }\\n};\\n\\nclass Solution {\\nprivate:\\n    vector<int> getPrimeFactors(int x) {\\n        vector<int> primeFactors;\\n        for (int i = 2; i * i <= x; i++) {\\n            if (x % i == 0) {\\n                primeFactors.push_back(i);\\n                while (x % i == 0) {\\n                    x /= i;\\n                }\\n            }\\n        }\\n        if (x != 1) {\\n            primeFactors.push_back(x);\\n        }\\n        return primeFactors;\\n    }\\n\\npublic:\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1) {\\n            return true;\\n        }\\n        Graph g(n);\\n        unordered_map<int, int> seen;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 1) {\\n                return false;\\n            }\\n            vector<int> primeFactors = getPrimeFactors(nums[i]);\\n            for (int prime: primeFactors) {\\n                if (seen.find(prime) != seen.end()) {\\n                    g.addEdge(i, seen[prime]);\\n                } else {\\n                    seen[prime] = i;\\n                }\\n            }\\n        }\\n        return g.isConnected();\\n    }\\n};\\n```\\n```Java []\\nclass Graph {\\n    private int n;\\n    private Map<Integer, List<Integer>> edges;\\n    private boolean[] visited;\\n\\n    private void traverse(int x) {\\n        visited[x] = true;\\n        if (!edges.containsKey(x)) {\\n            return;\\n        }\\n        for (int y: edges.get(x)) {\\n            if (!visited[y]) {\\n                traverse(y);\\n            }\\n        }\\n    }\\n\\n    public Graph(int n) {\\n        this.n = n;\\n        edges = new HashMap<>();\\n        visited = new boolean[n];\\n    }\\n\\n    public void addEdge(int x, int y) {\\n        edges.computeIfAbsent(x, value -> new ArrayList<Integer>()).add(y);\\n        edges.computeIfAbsent(y, value -> new ArrayList<Integer>()).add(x);\\n    }\\n\\n    public boolean isConnected() {\\n        Arrays.fill(visited, false);\\n        traverse(0);\\n        int count = 0;\\n        for (boolean v: visited) {\\n            count += v ? 1 : 0;\\n        }\\n        return count == n;\\n    }\\n}\\n\\nclass Solution {\\n    private List<Integer> getPrimeFactors(int x) {\\n        List<Integer> primeFactors = new ArrayList<>();\\n        for (int i = 2; i * i <= x; i++) {\\n            if (x % i == 0) {\\n                primeFactors.add(i);\\n                while (x % i == 0) {\\n                    x /= i;\\n                }\\n            }\\n        }\\n        if (x != 1) {\\n            primeFactors.add(x);\\n        }\\n        return primeFactors;\\n    }\\n\\n    public boolean canTraverseAllPairs(int[] nums) {\\n        int n = nums.length;\\n        if (n == 1) {\\n            return true;\\n        }\\n        Graph g = new Graph(n);\\n        HashMap<Integer, Integer> seen = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 1) {\\n                return false;\\n            }\\n            List<Integer> primeFactors = getPrimeFactors(nums[i]);\\n            for (int prime: primeFactors) {\\n                if (seen.containsKey(prime)) {\\n                    g.addEdge(i, seen.get(prime));\\n                } else {\\n                    seen.put(prime, i);\\n                }\\n            }\\n        }\\n        return g.isConnected();\\n    }\\n}\\n```\\n```Python []\\nclass Graph:\\n    def __init__(self, n: int):\\n        self.n = n\\n        self.edges = [[] for _ in range(n)]\\n    \\n    def traverse(self, x: int, visited: List[bool]):\\n        visited[x] = True\\n        for y in self.edges[x]:\\n            if not visited[y]:\\n                self.traverse(y, visited)\\n    \\n    def addEdge(self, x: int, y: int):\\n        self.edges[x].append(y)\\n        self.edges[y].append(x)\\n    \\n    def isConnected(self) -> bool:\\n        visited = [False for _ in range(self.n)]\\n        self.traverse(0, visited)\\n        return visited.count(True) == self.n\\n\\n\\nclass Solution:\\n    def getPrimeFactors(self, x: int) -> int:\\n        for i in range(2, int(sqrt(x)) + 1):\\n            if x % i == 0:\\n                while x % i == 0:\\n                    x //= i\\n                yield i\\n        if x != 1:\\n            yield x\\n    \\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        if n == 1:\\n            return True\\n        g = Graph(n)\\n        seen = {}\\n        for i in range(n):\\n            if nums[i] == 1:\\n                return False\\n            for prime in self.getPrimeFactors(nums[i]):\\n                if prime in seen:\\n                    g.addEdge(i, seen[prime])\\n                else:\\n                    seen[prime] = i\\n        return g.isConnected()\\n```\\n\\n## Breadth-First Search\\nOnly `Graph.traverse()` is changed, everything else is same.\\n```C++ []\\nclass Graph {\\nprivate:\\n    int n;\\n    vector<vector<int>> edges;\\n\\n    void traverse(int x, vector<bool>& visited) {\\n        queue<int> q;\\n        q.push(x);\\n        visited[x] = true;\\n        while (!q.empty()) {\\n            x = q.front(); q.pop();\\n            for (int y: edges[x]) {\\n                if (!visited[y]) {\\n                    q.push(y);\\n                    visited[y] = true;\\n                }\\n            }\\n        }\\n    }\\n\\npublic:\\n    Graph(int n = 0) : n(n) {\\n        edges.resize(n);\\n    }\\n    \\n    void addEdge(int x, int y) {\\n        edges[x].push_back(y);\\n        edges[y].push_back(x);\\n    }\\n\\n    bool isConnected() {\\n        vector<bool> visited(n);\\n        traverse(0, visited);\\n        return count(visited.begin(), visited.end(), true) == n;\\n    }\\n};\\n\\nclass Solution {\\nprivate:\\n    vector<int> getPrimeFactors(int x) {\\n        vector<int> primeFactors;\\n        for (int i = 2; i * i <= x; i++) {\\n            if (x % i == 0) {\\n                primeFactors.push_back(i);\\n                while (x % i == 0) {\\n                    x /= i;\\n                }\\n            }\\n        }\\n        if (x != 1) {\\n            primeFactors.push_back(x);\\n        }\\n        return primeFactors;\\n    }\\n\\npublic:\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1) {\\n            return true;\\n        }\\n        Graph g(n);\\n        unordered_map<int, int> seen;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 1) {\\n                return false;\\n            }\\n            vector<int> primeFactors = getPrimeFactors(nums[i]);\\n            for (int prime: primeFactors) {\\n                if (seen.find(prime) != seen.end()) {\\n                    g.addEdge(i, seen[prime]);\\n                } else {\\n                    seen[prime] = i;\\n                }\\n            }\\n        }\\n        return g.isConnected();\\n    }\\n};\\n```\\n```Java []\\nclass Graph {\\n    private int n;\\n    private Map<Integer, List<Integer>> edges;\\n    private boolean[] visited;\\n\\n    private void traverse(int x) {\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(x);\\n        while (!q.isEmpty()) {\\n            x = q.poll();\\n            if (!edges.containsKey(x)) {\\n                continue;\\n            }\\n            for (int y: edges.get(x)) {\\n                if (!visited[y]) {\\n                    q.add(y);\\n                    visited[y] = true;\\n                }\\n            }\\n        }\\n    }\\n\\n    public Graph(int n) {\\n        this.n = n;\\n        edges = new HashMap<>();\\n        visited = new boolean[n];\\n    }\\n\\n    public void addEdge(int x, int y) {\\n        edges.computeIfAbsent(x, value -> new ArrayList<Integer>()).add(y);\\n        edges.computeIfAbsent(y, value -> new ArrayList<Integer>()).add(x);\\n    }\\n\\n    public boolean isConnected() {\\n        Arrays.fill(visited, false);\\n        traverse(0);\\n        int count = 0;\\n        for (boolean v: visited) {\\n            count += v ? 1 : 0;\\n        }\\n        return count == n;\\n    }\\n}\\n\\nclass Solution {\\n    private List<Integer> getPrimeFactors(int x) {\\n        List<Integer> primeFactors = new ArrayList<>();\\n        for (int i = 2; i * i <= x; i++) {\\n            if (x % i == 0) {\\n                primeFactors.add(i);\\n                while (x % i == 0) {\\n                    x /= i;\\n                }\\n            }\\n        }\\n        if (x != 1) {\\n            primeFactors.add(x);\\n        }\\n        return primeFactors;\\n    }\\n\\n    public boolean canTraverseAllPairs(int[] nums) {\\n        int n = nums.length;\\n        if (n == 1) {\\n            return true;\\n        }\\n        Graph g = new Graph(n);\\n        HashMap<Integer, Integer> seen = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 1) {\\n                return false;\\n            }\\n            List<Integer> primeFactors = getPrimeFactors(nums[i]);\\n            for (int prime: primeFactors) {\\n                if (seen.containsKey(prime)) {\\n                    g.addEdge(i, seen.get(prime));\\n                } else {\\n                    seen.put(prime, i);\\n                }\\n            }\\n        }\\n        return g.isConnected();\\n    }\\n}\\n```\\n```Python []\\nclass Graph:\\n    def __init__(self, n: int):\\n        self.n = n\\n        self.edges = [[] for _ in range(n)]\\n    \\n    def traverse(self, x: int, visited: List[bool]):\\n        q = deque([x])\\n        visited[x] = True\\n        while q:\\n            x = q.popleft()\\n            for y in self.edges[x]:\\n                if not visited[y]:\\n                    q.append(y)\\n                    visited[y] = True\\n    \\n    def addEdge(self, x: int, y: int):\\n        self.edges[x].append(y)\\n        self.edges[y].append(x)\\n    \\n    def isConnected(self) -> bool:\\n        visited = [False for _ in range(self.n)]\\n        self.traverse(0, visited)\\n        return visited.count(True) == self.n\\n\\n\\nclass Solution:\\n    def getPrimeFactors(self, x: int) -> int:\\n        for i in range(2, int(sqrt(x)) + 1):\\n            if x % i == 0:\\n                while x % i == 0:\\n                    x //= i\\n                yield i\\n        if x != 1:\\n            yield x\\n    \\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        if n == 1:\\n            return True\\n        g = Graph(n)\\n        seen = {}\\n        for i in range(n):\\n            if nums[i] == 1:\\n                return False\\n            for prime in self.getPrimeFactors(nums[i]):\\n                if prime in seen:\\n                    g.addEdge(i, seen[prime])\\n                else:\\n                    seen[prime] = i\\n        return g.isConnected()\\n```\\n\\nA problem with DFS/BFS is the creation of multiple edges between same nodes. This can happen when there is more than one common prime factor between them. We can use `vector<unordered_set<int>> edges` to avoid duplicates.\\n\\n## Union Find\\nOnly `Graph` class is changed, `Solution` class is same.\\nUnion Find approach has an upper hand in terms of space complexity and it also avoids multiple edges between nodes.\\n```C++ []\\nclass Graph {\\nprivate:\\n    int n;\\n    vector<int> parent, compSize;\\n\\n    int getParent(int x) {\\n        if (parent[x] == x) {\\n            return x;\\n        }\\n        return parent[x] = getParent(parent[x]);\\n    }\\n\\n    void unionSet(int x, int y) {\\n        int parx = getParent(x), pary = getParent(y);\\n        if (parx != pary) {\\n            if (compSize[parx] < compSize[pary]) {\\n                swap(parx, pary);\\n            }\\n            parent[pary] = parx;\\n            compSize[parx] += compSize[pary];\\n        }\\n    }\\n\\npublic:\\n    Graph(int n = 0) : n(n) {\\n        parent.resize(n);\\n        compSize.resize(n, 1);\\n        iota(parent.begin(), parent.end(), 0);\\n    }\\n    \\n    void addEdge(int x, int y) {\\n        unionSet(x, y);\\n    }\\n\\n    bool isConnected() {\\n        return compSize[getParent(0)] == n;\\n    }\\n};\\n\\nclass Solution {\\nprivate:\\n    vector<int> getPrimeFactors(int x) {\\n        vector<int> primeFactors;\\n        for (int i = 2; i * i <= x; i++) {\\n            if (x % i == 0) {\\n                primeFactors.push_back(i);\\n                while (x % i == 0) {\\n                    x /= i;\\n                }\\n            }\\n        }\\n        if (x != 1) {\\n            primeFactors.push_back(x);\\n        }\\n        return primeFactors;\\n    }\\n\\npublic:\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1) {\\n            return true;\\n        }\\n        Graph g(n);\\n        unordered_map<int, int> seen;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 1) {\\n                return false;\\n            }\\n            vector<int> primeFactors = getPrimeFactors(nums[i]);\\n            for (int prime: primeFactors) {\\n                if (seen.find(prime) != seen.end()) {\\n                    g.addEdge(i, seen[prime]);\\n                } else {\\n                    seen[prime] = i;\\n                }\\n            }\\n        }\\n        return g.isConnected();\\n    }\\n};\\n```\\n```Java []\\nclass Graph {\\n    private int n;\\n    private int[] parent, compSize;\\n\\n    private int getParent(int x) {\\n        if (parent[x] == x) {\\n            return x;\\n        }\\n        return parent[x] = getParent(parent[x]);\\n    }\\n\\n    private void unionSet(int x, int y) {\\n        int parx = getParent(x), pary = getParent(y);\\n        if (parx != pary) {\\n            if (compSize[parx] < compSize[pary]) {\\n                int t = parx; parx = pary; pary = t;\\n            }\\n            parent[pary] = parx;\\n            compSize[parx] += compSize[pary];\\n        }\\n    }\\n\\n    public Graph(int n) {\\n        this.n = n;\\n        parent = new int[n];\\n        compSize = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n            compSize[i] = 1;\\n        }\\n    }\\n\\n    public void addEdge(int x, int y) {\\n        unionSet(x, y);\\n    }\\n\\n    public boolean isConnected() {\\n        return compSize[getParent(0)] == n;\\n    }\\n}\\n\\nclass Solution {\\n    private List<Integer> getPrimeFactors(int x) {\\n        List<Integer> primeFactors = new ArrayList<>();\\n        for (int i = 2; i * i <= x; i++) {\\n            if (x % i == 0) {\\n                primeFactors.add(i);\\n                while (x % i == 0) {\\n                    x /= i;\\n                }\\n            }\\n        }\\n        if (x != 1) {\\n            primeFactors.add(x);\\n        }\\n        return primeFactors;\\n    }\\n\\n    public boolean canTraverseAllPairs(int[] nums) {\\n        int n = nums.length;\\n        if (n == 1) {\\n            return true;\\n        }\\n        Graph g = new Graph(n);\\n        HashMap<Integer, Integer> seen = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 1) {\\n                return false;\\n            }\\n            List<Integer> primeFactors = getPrimeFactors(nums[i]);\\n            for (int prime: primeFactors) {\\n                if (seen.containsKey(prime)) {\\n                    g.addEdge(i, seen.get(prime));\\n                } else {\\n                    seen.put(prime, i);\\n                }\\n            }\\n        }\\n        return g.isConnected();\\n    }\\n}\\n```\\n```Python []\\nclass Graph:\\n    def __init__(self, n: int):\\n        self.n = n\\n        self.parent = [i for i in range(n)]\\n        self.compSize = [1 for i in range(n)]\\n    \\n    def getParent(self, x: int) -> int:\\n        if self.parent[x] == x:\\n            return x\\n        self.parent[x] = self.getParent(self.parent[x])\\n        return self.parent[x]\\n    \\n    def unionSet(self, x: int, y: int):\\n        parx, pary = self.getParent(x), self.getParent(y)\\n        if parx != pary:\\n            if self.compSize[parx] < self.compSize[pary]:\\n                parx, pary = pary, parx\\n            self.parent[pary] = parx\\n            self.compSize[parx] += self.compSize[pary]\\n    \\n    def addEdge(self, x: int, y: int):\\n        self.unionSet(x, y)\\n    \\n    def isConnected(self) -> bool:\\n        return self.compSize[self.getParent(0)] == self.n\\n\\n\\nclass Solution:\\n    def getPrimeFactors(self, x: int) -> int:\\n        for i in range(2, int(sqrt(x)) + 1):\\n            if x % i == 0:\\n                while x % i == 0:\\n                    x //= i\\n                yield i\\n        if x != 1:\\n            yield x\\n    \\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        if n == 1:\\n            return True\\n        g = Graph(n)\\n        seen = {}\\n        for i in range(n):\\n            if nums[i] == 1:\\n                return False\\n            for prime in self.getPrimeFactors(nums[i]):\\n                if prime in seen:\\n                    g.addEdge(i, seen[prime])\\n                else:\\n                    seen[prime] = i\\n        return g.isConnected()\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Union Find"
                ],
                "code": "```C++ []\\nclass Graph {\\nprivate:\\n    int n;\\n    vector<vector<int>> edges;\\n\\n    void traverse(int x, vector<bool>& visited) {\\n        visited[x] = true;\\n        for (int y: edges[x]) {\\n            if (!visited[y]) {\\n                traverse(y, visited);\\n            }\\n        }\\n    }\\n\\npublic:\\n    Graph(int n = 0) : n(n) {\\n        edges.resize(n);\\n    }\\n    \\n    void addEdge(int x, int y) {\\n        edges[x].push_back(y);\\n        edges[y].push_back(x);\\n    }\\n\\n    bool isConnected() {\\n        vector<bool> visited(n);\\n        traverse(0, visited);\\n        return count(visited.begin(), visited.end(), true) == n;\\n    }\\n};\\n\\nclass Solution {\\nprivate:\\n    vector<int> getPrimeFactors(int x) {\\n        vector<int> primeFactors;\\n        for (int i = 2; i * i <= x; i++) {\\n            if (x % i == 0) {\\n                primeFactors.push_back(i);\\n                while (x % i == 0) {\\n                    x /= i;\\n                }\\n            }\\n        }\\n        if (x != 1) {\\n            primeFactors.push_back(x);\\n        }\\n        return primeFactors;\\n    }\\n\\npublic:\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1) {\\n            return true;\\n        }\\n        Graph g(n);\\n        unordered_map<int, int> seen;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 1) {\\n                return false;\\n            }\\n            vector<int> primeFactors = getPrimeFactors(nums[i]);\\n            for (int prime: primeFactors) {\\n                if (seen.find(prime) != seen.end()) {\\n                    g.addEdge(i, seen[prime]);\\n                } else {\\n                    seen[prime] = i;\\n                }\\n            }\\n        }\\n        return g.isConnected();\\n    }\\n};\\n```\n```Java []\\nclass Graph {\\n    private int n;\\n    private Map<Integer, List<Integer>> edges;\\n    private boolean[] visited;\\n\\n    private void traverse(int x) {\\n        visited[x] = true;\\n        if (!edges.containsKey(x)) {\\n            return;\\n        }\\n        for (int y: edges.get(x)) {\\n            if (!visited[y]) {\\n                traverse(y);\\n            }\\n        }\\n    }\\n\\n    public Graph(int n) {\\n        this.n = n;\\n        edges = new HashMap<>();\\n        visited = new boolean[n];\\n    }\\n\\n    public void addEdge(int x, int y) {\\n        edges.computeIfAbsent(x, value -> new ArrayList<Integer>()).add(y);\\n        edges.computeIfAbsent(y, value -> new ArrayList<Integer>()).add(x);\\n    }\\n\\n    public boolean isConnected() {\\n        Arrays.fill(visited, false);\\n        traverse(0);\\n        int count = 0;\\n        for (boolean v: visited) {\\n            count += v ? 1 : 0;\\n        }\\n        return count == n;\\n    }\\n}\\n\\nclass Solution {\\n    private List<Integer> getPrimeFactors(int x) {\\n        List<Integer> primeFactors = new ArrayList<>();\\n        for (int i = 2; i * i <= x; i++) {\\n            if (x % i == 0) {\\n                primeFactors.add(i);\\n                while (x % i == 0) {\\n                    x /= i;\\n                }\\n            }\\n        }\\n        if (x != 1) {\\n            primeFactors.add(x);\\n        }\\n        return primeFactors;\\n    }\\n\\n    public boolean canTraverseAllPairs(int[] nums) {\\n        int n = nums.length;\\n        if (n == 1) {\\n            return true;\\n        }\\n        Graph g = new Graph(n);\\n        HashMap<Integer, Integer> seen = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 1) {\\n                return false;\\n            }\\n            List<Integer> primeFactors = getPrimeFactors(nums[i]);\\n            for (int prime: primeFactors) {\\n                if (seen.containsKey(prime)) {\\n                    g.addEdge(i, seen.get(prime));\\n                } else {\\n                    seen.put(prime, i);\\n                }\\n            }\\n        }\\n        return g.isConnected();\\n    }\\n}\\n```\n```Python []\\nclass Graph:\\n    def __init__(self, n: int):\\n        self.n = n\\n        self.edges = [[] for _ in range(n)]\\n    \\n    def traverse(self, x: int, visited: List[bool]):\\n        visited[x] = True\\n        for y in self.edges[x]:\\n            if not visited[y]:\\n                self.traverse(y, visited)\\n    \\n    def addEdge(self, x: int, y: int):\\n        self.edges[x].append(y)\\n        self.edges[y].append(x)\\n    \\n    def isConnected(self) -> bool:\\n        visited = [False for _ in range(self.n)]\\n        self.traverse(0, visited)\\n        return visited.count(True) == self.n\\n\\n\\nclass Solution:\\n    def getPrimeFactors(self, x: int) -> int:\\n        for i in range(2, int(sqrt(x)) + 1):\\n            if x % i == 0:\\n                while x % i == 0:\\n                    x //= i\\n                yield i\\n        if x != 1:\\n            yield x\\n    \\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        if n == 1:\\n            return True\\n        g = Graph(n)\\n        seen = {}\\n        for i in range(n):\\n            if nums[i] == 1:\\n                return False\\n            for prime in self.getPrimeFactors(nums[i]):\\n                if prime in seen:\\n                    g.addEdge(i, seen[prime])\\n                else:\\n                    seen[prime] = i\\n        return g.isConnected()\\n```\n```C++ []\\nclass Graph {\\nprivate:\\n    int n;\\n    vector<vector<int>> edges;\\n\\n    void traverse(int x, vector<bool>& visited) {\\n        queue<int> q;\\n        q.push(x);\\n        visited[x] = true;\\n        while (!q.empty()) {\\n            x = q.front(); q.pop();\\n            for (int y: edges[x]) {\\n                if (!visited[y]) {\\n                    q.push(y);\\n                    visited[y] = true;\\n                }\\n            }\\n        }\\n    }\\n\\npublic:\\n    Graph(int n = 0) : n(n) {\\n        edges.resize(n);\\n    }\\n    \\n    void addEdge(int x, int y) {\\n        edges[x].push_back(y);\\n        edges[y].push_back(x);\\n    }\\n\\n    bool isConnected() {\\n        vector<bool> visited(n);\\n        traverse(0, visited);\\n        return count(visited.begin(), visited.end(), true) == n;\\n    }\\n};\\n\\nclass Solution {\\nprivate:\\n    vector<int> getPrimeFactors(int x) {\\n        vector<int> primeFactors;\\n        for (int i = 2; i * i <= x; i++) {\\n            if (x % i == 0) {\\n                primeFactors.push_back(i);\\n                while (x % i == 0) {\\n                    x /= i;\\n                }\\n            }\\n        }\\n        if (x != 1) {\\n            primeFactors.push_back(x);\\n        }\\n        return primeFactors;\\n    }\\n\\npublic:\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1) {\\n            return true;\\n        }\\n        Graph g(n);\\n        unordered_map<int, int> seen;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 1) {\\n                return false;\\n            }\\n            vector<int> primeFactors = getPrimeFactors(nums[i]);\\n            for (int prime: primeFactors) {\\n                if (seen.find(prime) != seen.end()) {\\n                    g.addEdge(i, seen[prime]);\\n                } else {\\n                    seen[prime] = i;\\n                }\\n            }\\n        }\\n        return g.isConnected();\\n    }\\n};\\n```\n```Java []\\nclass Graph {\\n    private int n;\\n    private Map<Integer, List<Integer>> edges;\\n    private boolean[] visited;\\n\\n    private void traverse(int x) {\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(x);\\n        while (!q.isEmpty()) {\\n            x = q.poll();\\n            if (!edges.containsKey(x)) {\\n                continue;\\n            }\\n            for (int y: edges.get(x)) {\\n                if (!visited[y]) {\\n                    q.add(y);\\n                    visited[y] = true;\\n                }\\n            }\\n        }\\n    }\\n\\n    public Graph(int n) {\\n        this.n = n;\\n        edges = new HashMap<>();\\n        visited = new boolean[n];\\n    }\\n\\n    public void addEdge(int x, int y) {\\n        edges.computeIfAbsent(x, value -> new ArrayList<Integer>()).add(y);\\n        edges.computeIfAbsent(y, value -> new ArrayList<Integer>()).add(x);\\n    }\\n\\n    public boolean isConnected() {\\n        Arrays.fill(visited, false);\\n        traverse(0);\\n        int count = 0;\\n        for (boolean v: visited) {\\n            count += v ? 1 : 0;\\n        }\\n        return count == n;\\n    }\\n}\\n\\nclass Solution {\\n    private List<Integer> getPrimeFactors(int x) {\\n        List<Integer> primeFactors = new ArrayList<>();\\n        for (int i = 2; i * i <= x; i++) {\\n            if (x % i == 0) {\\n                primeFactors.add(i);\\n                while (x % i == 0) {\\n                    x /= i;\\n                }\\n            }\\n        }\\n        if (x != 1) {\\n            primeFactors.add(x);\\n        }\\n        return primeFactors;\\n    }\\n\\n    public boolean canTraverseAllPairs(int[] nums) {\\n        int n = nums.length;\\n        if (n == 1) {\\n            return true;\\n        }\\n        Graph g = new Graph(n);\\n        HashMap<Integer, Integer> seen = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 1) {\\n                return false;\\n            }\\n            List<Integer> primeFactors = getPrimeFactors(nums[i]);\\n            for (int prime: primeFactors) {\\n                if (seen.containsKey(prime)) {\\n                    g.addEdge(i, seen.get(prime));\\n                } else {\\n                    seen.put(prime, i);\\n                }\\n            }\\n        }\\n        return g.isConnected();\\n    }\\n}\\n```\n```Python []\\nclass Graph:\\n    def __init__(self, n: int):\\n        self.n = n\\n        self.edges = [[] for _ in range(n)]\\n    \\n    def traverse(self, x: int, visited: List[bool]):\\n        q = deque([x])\\n        visited[x] = True\\n        while q:\\n            x = q.popleft()\\n            for y in self.edges[x]:\\n                if not visited[y]:\\n                    q.append(y)\\n                    visited[y] = True\\n    \\n    def addEdge(self, x: int, y: int):\\n        self.edges[x].append(y)\\n        self.edges[y].append(x)\\n    \\n    def isConnected(self) -> bool:\\n        visited = [False for _ in range(self.n)]\\n        self.traverse(0, visited)\\n        return visited.count(True) == self.n\\n\\n\\nclass Solution:\\n    def getPrimeFactors(self, x: int) -> int:\\n        for i in range(2, int(sqrt(x)) + 1):\\n            if x % i == 0:\\n                while x % i == 0:\\n                    x //= i\\n                yield i\\n        if x != 1:\\n            yield x\\n    \\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        if n == 1:\\n            return True\\n        g = Graph(n)\\n        seen = {}\\n        for i in range(n):\\n            if nums[i] == 1:\\n                return False\\n            for prime in self.getPrimeFactors(nums[i]):\\n                if prime in seen:\\n                    g.addEdge(i, seen[prime])\\n                else:\\n                    seen[prime] = i\\n        return g.isConnected()\\n```\n```C++ []\\nclass Graph {\\nprivate:\\n    int n;\\n    vector<int> parent, compSize;\\n\\n    int getParent(int x) {\\n        if (parent[x] == x) {\\n            return x;\\n        }\\n        return parent[x] = getParent(parent[x]);\\n    }\\n\\n    void unionSet(int x, int y) {\\n        int parx = getParent(x), pary = getParent(y);\\n        if (parx != pary) {\\n            if (compSize[parx] < compSize[pary]) {\\n                swap(parx, pary);\\n            }\\n            parent[pary] = parx;\\n            compSize[parx] += compSize[pary];\\n        }\\n    }\\n\\npublic:\\n    Graph(int n = 0) : n(n) {\\n        parent.resize(n);\\n        compSize.resize(n, 1);\\n        iota(parent.begin(), parent.end(), 0);\\n    }\\n    \\n    void addEdge(int x, int y) {\\n        unionSet(x, y);\\n    }\\n\\n    bool isConnected() {\\n        return compSize[getParent(0)] == n;\\n    }\\n};\\n\\nclass Solution {\\nprivate:\\n    vector<int> getPrimeFactors(int x) {\\n        vector<int> primeFactors;\\n        for (int i = 2; i * i <= x; i++) {\\n            if (x % i == 0) {\\n                primeFactors.push_back(i);\\n                while (x % i == 0) {\\n                    x /= i;\\n                }\\n            }\\n        }\\n        if (x != 1) {\\n            primeFactors.push_back(x);\\n        }\\n        return primeFactors;\\n    }\\n\\npublic:\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1) {\\n            return true;\\n        }\\n        Graph g(n);\\n        unordered_map<int, int> seen;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 1) {\\n                return false;\\n            }\\n            vector<int> primeFactors = getPrimeFactors(nums[i]);\\n            for (int prime: primeFactors) {\\n                if (seen.find(prime) != seen.end()) {\\n                    g.addEdge(i, seen[prime]);\\n                } else {\\n                    seen[prime] = i;\\n                }\\n            }\\n        }\\n        return g.isConnected();\\n    }\\n};\\n```\n```Java []\\nclass Graph {\\n    private int n;\\n    private int[] parent, compSize;\\n\\n    private int getParent(int x) {\\n        if (parent[x] == x) {\\n            return x;\\n        }\\n        return parent[x] = getParent(parent[x]);\\n    }\\n\\n    private void unionSet(int x, int y) {\\n        int parx = getParent(x), pary = getParent(y);\\n        if (parx != pary) {\\n            if (compSize[parx] < compSize[pary]) {\\n                int t = parx; parx = pary; pary = t;\\n            }\\n            parent[pary] = parx;\\n            compSize[parx] += compSize[pary];\\n        }\\n    }\\n\\n    public Graph(int n) {\\n        this.n = n;\\n        parent = new int[n];\\n        compSize = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n            compSize[i] = 1;\\n        }\\n    }\\n\\n    public void addEdge(int x, int y) {\\n        unionSet(x, y);\\n    }\\n\\n    public boolean isConnected() {\\n        return compSize[getParent(0)] == n;\\n    }\\n}\\n\\nclass Solution {\\n    private List<Integer> getPrimeFactors(int x) {\\n        List<Integer> primeFactors = new ArrayList<>();\\n        for (int i = 2; i * i <= x; i++) {\\n            if (x % i == 0) {\\n                primeFactors.add(i);\\n                while (x % i == 0) {\\n                    x /= i;\\n                }\\n            }\\n        }\\n        if (x != 1) {\\n            primeFactors.add(x);\\n        }\\n        return primeFactors;\\n    }\\n\\n    public boolean canTraverseAllPairs(int[] nums) {\\n        int n = nums.length;\\n        if (n == 1) {\\n            return true;\\n        }\\n        Graph g = new Graph(n);\\n        HashMap<Integer, Integer> seen = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 1) {\\n                return false;\\n            }\\n            List<Integer> primeFactors = getPrimeFactors(nums[i]);\\n            for (int prime: primeFactors) {\\n                if (seen.containsKey(prime)) {\\n                    g.addEdge(i, seen.get(prime));\\n                } else {\\n                    seen.put(prime, i);\\n                }\\n            }\\n        }\\n        return g.isConnected();\\n    }\\n}\\n```\n```Python []\\nclass Graph:\\n    def __init__(self, n: int):\\n        self.n = n\\n        self.parent = [i for i in range(n)]\\n        self.compSize = [1 for i in range(n)]\\n    \\n    def getParent(self, x: int) -> int:\\n        if self.parent[x] == x:\\n            return x\\n        self.parent[x] = self.getParent(self.parent[x])\\n        return self.parent[x]\\n    \\n    def unionSet(self, x: int, y: int):\\n        parx, pary = self.getParent(x), self.getParent(y)\\n        if parx != pary:\\n            if self.compSize[parx] < self.compSize[pary]:\\n                parx, pary = pary, parx\\n            self.parent[pary] = parx\\n            self.compSize[parx] += self.compSize[pary]\\n    \\n    def addEdge(self, x: int, y: int):\\n        self.unionSet(x, y)\\n    \\n    def isConnected(self) -> bool:\\n        return self.compSize[self.getParent(0)] == self.n\\n\\n\\nclass Solution:\\n    def getPrimeFactors(self, x: int) -> int:\\n        for i in range(2, int(sqrt(x)) + 1):\\n            if x % i == 0:\\n                while x % i == 0:\\n                    x //= i\\n                yield i\\n        if x != 1:\\n            yield x\\n    \\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        if n == 1:\\n            return True\\n        g = Graph(n)\\n        seen = {}\\n        for i in range(n):\\n            if nums[i] == 1:\\n                return False\\n            for prime in self.getPrimeFactors(nums[i]):\\n                if prime in seen:\\n                    g.addEdge(i, seen[prime])\\n                else:\\n                    seen[prime] = i\\n        return g.isConnected()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569023,
                "title": "video-explanation-dfs-proof",
                "content": "# Explanation\\n\\nhttps://youtu.be/8VYpqr-r4jw\\n\\n[Click here if the preview above doesn\\'t works](https://youtu.be/8VYpqr-r4jw)\\n\\n# Code\\n```\\nconst int N = 1e5;\\n\\nvector<vector<int>> g;\\nvector<bool> visited;\\n\\nint CountConnectedNodes (int src) {\\n    if (visited[src]) return 0;\\n    visited[src] = true;\\n    \\n    int result = 1;\\n    for (auto i : g[src]) result += CountConnectedNodes(i);\\n    return result;\\n}\\n\\nclass Solution {\\n    vector<int> seive;\\n    \\n    void buildSeive() {\\n        seive.resize(N+1);\\n        for (long j = 2; j <= N; j ++) {\\n            if (seive[j] != 0) continue;\\n            \\n            seive[j] = j;\\n            for (long k = j*j; k <= N; k += j) \\n                if (!seive[k]) seive[k] = j;\\n        }\\n    }\\n    \\n    vector<int> primeFactors (int x) {\\n        vector<int> result;\\n        while (x != 1) {\\n            int f = seive[x];\\n            while (x % f == 0) x /= f;\\n            result.push_back(f);\\n        }\\n        return result;\\n    } \\n    \\npublic:\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        vector<int> val(N+1, -1);\\n        buildSeive();\\n        \\n        int n = nums.size();    \\n        if (n == 1) return true;\\n        \\n        g.clear(), g.resize(n);\\n        visited.clear(), visited.resize(n);\\n        \\n        for (int j = 0; j < n; j ++) {\\n            if (nums[j] == 1) return false;\\n            \\n            vector<int> primes = primeFactors (nums[j]);\\n            for (auto p : primes) {\\n                if (val[p] != -1) {\\n                    g[j].push_back(val[p]);\\n                    g[val[p]].push_back(j);\\n                }\\n                val[p] = j;\\n            }\\n        }\\n        \\n        if (CountConnectedNodes(0) == n) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nconst int N = 1e5;\\n\\nvector<vector<int>> g;\\nvector<bool> visited;\\n\\nint CountConnectedNodes (int src) {\\n    if (visited[src]) return 0;\\n    visited[src] = true;\\n    \\n    int result = 1;\\n    for (auto i : g[src]) result += CountConnectedNodes(i);\\n    return result;\\n}\\n\\nclass Solution {\\n    vector<int> seive;\\n    \\n    void buildSeive() {\\n        seive.resize(N+1);\\n        for (long j = 2; j <= N; j ++) {\\n            if (seive[j] != 0) continue;\\n            \\n            seive[j] = j;\\n            for (long k = j*j; k <= N; k += j) \\n                if (!seive[k]) seive[k] = j;\\n        }\\n    }\\n    \\n    vector<int> primeFactors (int x) {\\n        vector<int> result;\\n        while (x != 1) {\\n            int f = seive[x];\\n            while (x % f == 0) x /= f;\\n            result.push_back(f);\\n        }\\n        return result;\\n    } \\n    \\npublic:\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        vector<int> val(N+1, -1);\\n        buildSeive();\\n        \\n        int n = nums.size();    \\n        if (n == 1) return true;\\n        \\n        g.clear(), g.resize(n);\\n        visited.clear(), visited.resize(n);\\n        \\n        for (int j = 0; j < n; j ++) {\\n            if (nums[j] == 1) return false;\\n            \\n            vector<int> primes = primeFactors (nums[j]);\\n            for (auto p : primes) {\\n                if (val[p] != -1) {\\n                    g[j].push_back(val[p]);\\n                    g[val[p]].push_back(j);\\n                }\\n                val[p] = j;\\n            }\\n        }\\n        \\n        if (CountConnectedNodes(0) == n) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568604,
                "title": "math-union-find-cpp-easy-math-solution-with-detailed-explanation-o-n-sqrt-x",
                "content": "### if you like the solution, please give me a up vote.\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ncase 1: `nums = [1]`, nums only has one value, so directly return true.\\n\\ncase 2: `nums = [2, 3, 6, 1]`, nums contains `\"1\"`, `gcd(x, 1)` always is `\"1\"`, so directly return false. \\n\\ncase 3: `nums = [2, 3, 6]`, \\n        in this case, if we want to jump from `\"2\"` -> `\"3\"`, we need to find another value, \\n\\t\\twhich factors contains `\"2\", \"3\"`.\\n\\t\\n\\t\\ncase 4: `nums = [2, 4, 3, 9]` because `\"2\"` can not jump to `\"3\" \"9\"`, so return false.\\n\\n\\nbased on above observation.\\nwe can translate this problem into factor group.\\nif the value which the factors is f1, f2, f3, we can use union_find to union these factors. \\nfinally, we need check how many factor group exist in nums.\\nif factor group = 1, return true\\nif factor group > 1, return false\\n\\n\\nfor example:\\n\\ncase 3:\\n`nums = [2, 3, 6],` \\n`factors = [(2), (3), (2,3)], factor group is 1`\\n\\n\\ncase 4:\\n`nums = [2, 4, 3, 9],` \\n`factors = [(2), (2), (3), (3)], factor group is 2` \\n\\n# Complexity\\n- Time complexity: O(n * sqrt(x)), x is maximum value in nums.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass union_find {\\npublic:\\n    vector<int> p;\\n    vector<int> r;\\n    union_find(int n) {\\n        p.resize(n, 0);\\n        r.resize(n, 0);\\n        \\n        for(int i = 0 ; i < n ; i++) {\\n            p[i] = i;\\n        }\\n    }\\n    \\n    int Find(int x) {\\n        if(p[x] != x) {\\n            p[x] = Find(p[x]);\\n        }\\n        return p[x];\\n    }\\n    \\n    void Union(int x, int y) {\\n        int px = Find(x);\\n        int py = Find(y);\\n        if(px == py) {\\n            return;\\n        }\\n        \\n        if(r[px] > r[py]) {\\n            p[py] = px;\\n        }\\n        else if(r[py] > r[px]) {\\n            p[px] = py;\\n        }\\n        else {\\n            p[py] = px;\\n            r[px]++;\\n        }\\n    }\\n    \\n};\\nclass Solution {\\npublic:\\n    void find_factors(int val, vector<int> &v) {\\n        for(int j = 2 ; (j * j) <= val ; j++) {\\n            bool add = false;\\n            while((val % j) == 0) {\\n                val = val / j;\\n                add = true;\\n            }\\n            if(add) {\\n                v.push_back(j);\\n            }\\n        }\\n\\n        if(val > 1) {\\n            v.push_back(val);\\n        }\\n    }\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> v(n);\\n        union_find uf(100000);\\n        unordered_set<int> st;\\n        \\n        if(n == 1) {\\n            return true;\\n        }\\n        \\n        //check failed case \\n        for(int i = 0 ; i < n; i++) {\\n            if(nums[i] == 1) {\\n                return false;\\n            }\\n            find_factors(nums[i], v[i]);\\n        }\\n        for(int i = 0 ; i < n ; i++) {\\n            for(int j = 1 ; j < v[i].size(); j++) {\\n                uf.Union(v[i][0], v[i][j]);\\n            }\\n        }\\n        \\n        for(int i = 0 ; i < n ; i++) {\\n            for(int j = 0 ; j < v[i].size(); j++) {\\n                st.insert(uf.Find(v[i][j]));\\n            }\\n        }\\n        \\n        \\n        return st.size() == 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Union Find"
                ],
                "code": "```\\nclass union_find {\\npublic:\\n    vector<int> p;\\n    vector<int> r;\\n    union_find(int n) {\\n        p.resize(n, 0);\\n        r.resize(n, 0);\\n        \\n        for(int i = 0 ; i < n ; i++) {\\n            p[i] = i;\\n        }\\n    }\\n    \\n    int Find(int x) {\\n        if(p[x] != x) {\\n            p[x] = Find(p[x]);\\n        }\\n        return p[x];\\n    }\\n    \\n    void Union(int x, int y) {\\n        int px = Find(x);\\n        int py = Find(y);\\n        if(px == py) {\\n            return;\\n        }\\n        \\n        if(r[px] > r[py]) {\\n            p[py] = px;\\n        }\\n        else if(r[py] > r[px]) {\\n            p[px] = py;\\n        }\\n        else {\\n            p[py] = px;\\n            r[px]++;\\n        }\\n    }\\n    \\n};\\nclass Solution {\\npublic:\\n    void find_factors(int val, vector<int> &v) {\\n        for(int j = 2 ; (j * j) <= val ; j++) {\\n            bool add = false;\\n            while((val % j) == 0) {\\n                val = val / j;\\n                add = true;\\n            }\\n            if(add) {\\n                v.push_back(j);\\n            }\\n        }\\n\\n        if(val > 1) {\\n            v.push_back(val);\\n        }\\n    }\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> v(n);\\n        union_find uf(100000);\\n        unordered_set<int> st;\\n        \\n        if(n == 1) {\\n            return true;\\n        }\\n        \\n        //check failed case \\n        for(int i = 0 ; i < n; i++) {\\n            if(nums[i] == 1) {\\n                return false;\\n            }\\n            find_factors(nums[i], v[i]);\\n        }\\n        for(int i = 0 ; i < n ; i++) {\\n            for(int j = 1 ; j < v[i].size(); j++) {\\n                uf.Union(v[i][0], v[i][j]);\\n            }\\n        }\\n        \\n        for(int i = 0 ; i < n ; i++) {\\n            for(int j = 0 ; j < v[i].size(); j++) {\\n                st.insert(uf.Find(v[i][j]));\\n            }\\n        }\\n        \\n        \\n        return st.size() == 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579986,
                "title": "prime-factorization-simple-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAn intuition begins with creating an undirected graph between with  indices as virtices.\\nThere is actually no need to actually find GCD (it will only give TLE)\\nWe know that if there exist a common prime factor between two numbers there GCD will always be greater than 1.\\nSo we find Prime factors of every number and map them with respect to their prime factors \\nFor example, a map for 2 ,6 ,8 and 9 will be :\\n2 - 2,6,8\\n3 - 6,9\\n\\nNow we know every number(represented by index) on the right of the same share a common factor so their gcd is always greater than 1 and by unifying them we are connecting them all together.\\n\\nAt the end after all the unifications, if there are multiple components means some vertices or indices are not connected hence we return false. :)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n-> Start with creating a unionFind class with all the necessary functions of DSU (Once you understand and create it by yourself,it is a piece of cake).\\n-> Create a map to store numbers with common factors.\\n-> Traverse over nums array and map every index with it\\'s prime factors.\\n-> After mapping you just need to traverse over all the vectors in map and unify them.\\n-> Check number of components in UnionFind and return true if every index is unified i.e. a single component is present only.\\n\\n# Complexity\\n- Time complexity:\\n- O(n*sqrt(n))\\n- To find prime factors.\\n- Union find operations has Amortize time complexity O(n).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- O(n*sqrt(n))\\n- Maximum prime factors can be sqrt(n).\\n\\n# Code\\n```\\nclass unionFind{\\n    public:\\n    vector<int> parent;\\n    vector<int> rank;\\n    \\n    unionFind(int n)\\n    {\\n        parent = vector<int> (n);\\n        for(int i=0;i<n;i++) parent[i] = i;\\n        rank = vector<int> (n,0);\\n    }\\n    \\n    int findParent(int i)\\n    {\\n        if(i==parent[i]) return i;\\n        \\n        return parent[i] = findParent(parent[i]);\\n    }\\n    \\n    bool areconnected(int i,int j)\\n    {\\n        return (findParent(i)==findParent(j));\\n    }\\n    bool unify(int i,int j)\\n    {\\n        i = findParent(i);\\n        j = findParent(j);\\n        \\n        if(i==j) return false;\\n        \\n        if(rank[i]>rank[j])\\n        {\\n            parent[j] = i;\\n            rank[i]++;\\n        }\\n        else\\n        {\\n            parent[i] = j;\\n            rank[j]++;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    int components()\\n    {\\n        int count = 0;\\n        for(int i = 0;i<parent.size();i++)\\n        {\\n            if(i==parent[i]) count++;\\n        }\\n        return count;\\n    }\\n\\n};\\n\\nclass Solution {\\npublic:\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int n = nums.size();\\n        unionFind uf(n);\\n        \\n        unordered_map<int,vector<int>> adj;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            int num = nums[i];\\n\\n            if((num&1)==0) adj[2].push_back(i);\\n            while((num&1)==0) num/=2;\\n\\n            for(int j=3;j*j<=num;j+=2)\\n            {\\n                if(num%j==0) adj[j].push_back(i);\\n                while(num%j==0) num/=j;\\n            }\\n\\n            if(num>2) adj[num].push_back(i);\\n            \\n        }\\n\\n        for(auto [key,vec] : adj)\\n        {\\n            for(int i=1;i<vec.size();i++)\\n            {\\n                uf.unify(vec[0],vec[i]);\\n            }\\n        }\\n        \\n        return uf.components()==1? true : false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass unionFind{\\n    public:\\n    vector<int> parent;\\n    vector<int> rank;\\n    \\n    unionFind(int n)\\n    {\\n        parent = vector<int> (n);\\n        for(int i=0;i<n;i++) parent[i] = i;\\n        rank = vector<int> (n,0);\\n    }\\n    \\n    int findParent(int i)\\n    {\\n        if(i==parent[i]) return i;\\n        \\n        return parent[i] = findParent(parent[i]);\\n    }\\n    \\n    bool areconnected(int i,int j)\\n    {\\n        return (findParent(i)==findParent(j));\\n    }\\n    bool unify(int i,int j)\\n    {\\n        i = findParent(i);\\n        j = findParent(j);\\n        \\n        if(i==j) return false;\\n        \\n        if(rank[i]>rank[j])\\n        {\\n            parent[j] = i;\\n            rank[i]++;\\n        }\\n        else\\n        {\\n            parent[i] = j;\\n            rank[j]++;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    int components()\\n    {\\n        int count = 0;\\n        for(int i = 0;i<parent.size();i++)\\n        {\\n            if(i==parent[i]) count++;\\n        }\\n        return count;\\n    }\\n\\n};\\n\\nclass Solution {\\npublic:\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int n = nums.size();\\n        unionFind uf(n);\\n        \\n        unordered_map<int,vector<int>> adj;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            int num = nums[i];\\n\\n            if((num&1)==0) adj[2].push_back(i);\\n            while((num&1)==0) num/=2;\\n\\n            for(int j=3;j*j<=num;j+=2)\\n            {\\n                if(num%j==0) adj[j].push_back(i);\\n                while(num%j==0) num/=j;\\n            }\\n\\n            if(num>2) adj[num].push_back(i);\\n            \\n        }\\n\\n        for(auto [key,vec] : adj)\\n        {\\n            for(int i=1;i<vec.size();i++)\\n            {\\n                uf.unify(vec[0],vec[i]);\\n            }\\n        }\\n        \\n        return uf.components()==1? true : false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573278,
                "title": "python-3-11-lines-w-comments-t-m-100-85",
                "content": "```\\nclass Solution:\\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\\n\\n        if len(nums) == 1    : return True          # <-- some edge cases\\n        if 1 in nums         : return False         #\\n\\n        nums = sorted(set(nums), reverse = True)    # <-- sort (big to little) and  \\n        if (n:=len(nums))==1 : return True          #     deal with another edge case\\n\\n        for i in range(n-1):                        # <-- nums[i] >= nums[j]\\n            for j in range(i+1,n):\\n            \\n                if gcd(nums[i],nums[j])-1:          # <-- i,j traversal exists; \\n                    nums[j]*= nums[i])              # <-- if an i,k traversal exists   \\n                    break                           #     (for some index k), then now \\n                                                    #     a j,k traversal exists\\n\\n            else: return False                      # <-- no match means no traversal \\n\\n        return True \\n```\\n[https://leetcode.com/problems/greatest-common-divisor-traversal/submissions/959228058/](http://)\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*^2 log*M*) and space complexity is *O*(*M*) in which *N* ~`len(nums)`and *M* ~`max(nums)`.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\\n\\n        if len(nums) == 1    : return True          # <-- some edge cases\\n        if 1 in nums         : return False         #\\n\\n        nums = sorted(set(nums), reverse = True)    # <-- sort (big to little) and  \\n        if (n:=len(nums))==1 : return True          #     deal with another edge case\\n\\n        for i in range(n-1):                        # <-- nums[i] >= nums[j]\\n            for j in range(i+1,n):\\n            \\n                if gcd(nums[i],nums[j])-1:          # <-- i,j traversal exists; \\n                    nums[j]*= nums[i])              # <-- if an i,k traversal exists   \\n                    break                           #     (for some index k), then now \\n                                                    #     a j,k traversal exists\\n\\n            else: return False                      # <-- no match means no traversal \\n\\n        return True \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570557,
                "title": "dfs-beginner-friendly-no-union-find",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStoring unique factors and applying DFS to check number of components. if there is only one component that means all numbers are connected with each other either directly or indirectly, so return true else return false..\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCalculate unique factors of each number and if that factor occurs for another number also so these two numbers have gcd>1. So, we can have an undirected edge b/w these two numbers. After that just simple DFS traversal to count components.\\n\\nHow to check common factors between two numbers -> we will simple store every factor with index of last number(say in a map) in which it occured and if this factor occured again then we will create and edge from current number\\'s index to index of that number wwhose index is stored with this number in map..\\n\\nWe can store unique factors for each number in an unordered set/map so that they are unique. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    unordered_set<int> UniquePrimeFactors(int n){\\n        unordered_set<int> factors;\\n        for(int i=2; i<= sqrt(n); i++){\\n            while(n%i == 0){\\n                factors.insert(i);\\n                n /= i;\\n            }\\n        }\\n\\n        if(n > 1) factors.insert(n);\\n\\n        return factors;\\n    }\\n\\n    void dfs(int i, set<int>& vis, vector<vector<int>>& adj){\\n        vis.insert(i);\\n\\n        for(int node: adj[i]){\\n            if(vis.find(node) == vis.end()) dfs(node, vis, adj);\\n        }\\n    }\\n\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> adj(n);\\n\\n        unordered_map<int, int> lastIndex;\\n\\n        for(int i=0; i<nums.size(); i++){\\n            unordered_set<int> primeFactors = UniquePrimeFactors(nums[i]);\\n\\n            for(int factor: primeFactors){\\n                if(lastIndex.find(factor) != lastIndex.end()){\\n                    int prevIndex = lastIndex[factor];\\n                    adj[prevIndex].push_back(i);\\n                    adj[i].push_back(prevIndex);\\n                }\\n\\n                lastIndex[factor] = i;\\n            }\\n        }\\n\\n        set<int> vis;\\n        dfs(0, vis, adj);\\n\\n        return vis.size() == n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    unordered_set<int> UniquePrimeFactors(int n){\\n        unordered_set<int> factors;\\n        for(int i=2; i<= sqrt(n); i++){\\n            while(n%i == 0){\\n                factors.insert(i);\\n                n /= i;\\n            }\\n        }\\n\\n        if(n > 1) factors.insert(n);\\n\\n        return factors;\\n    }\\n\\n    void dfs(int i, set<int>& vis, vector<vector<int>>& adj){\\n        vis.insert(i);\\n\\n        for(int node: adj[i]){\\n            if(vis.find(node) == vis.end()) dfs(node, vis, adj);\\n        }\\n    }\\n\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> adj(n);\\n\\n        unordered_map<int, int> lastIndex;\\n\\n        for(int i=0; i<nums.size(); i++){\\n            unordered_set<int> primeFactors = UniquePrimeFactors(nums[i]);\\n\\n            for(int factor: primeFactors){\\n                if(lastIndex.find(factor) != lastIndex.end()){\\n                    int prevIndex = lastIndex[factor];\\n                    adj[prevIndex].push_back(i);\\n                    adj[i].push_back(prevIndex);\\n                }\\n\\n                lastIndex[factor] = i;\\n            }\\n        }\\n\\n        set<int> vis;\\n        dfs(0, vis, adj);\\n\\n        return vis.size() == n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568929,
                "title": "easy-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n#define ll int\\n    int fact[1000000+10];\\n    int isPresent[100000+10];\\n    int thik[100000+10];\\nbool canTraverseAllPairs(vector<int>& nums) {\\n    if(nums.size()==1)return true;\\n    // set<ll>st;\\n    // if(nums.size()==1)return true;\\n   \\n   for (int i = 0; i < nums.size(); ++i)\\n   {\\n       isPresent[nums[i]]++;\\n       if(isPresent[1]>0)return false;\\n       if(isPresent[nums[i]]==nums.size())return true;\\n   }\\n    if(isPresent[1]>0)return false;\\n    \\n   vector<ll>v;\\n  \\n   for (int i = 2; i < 100000+1; ++i)\\n   {\\n       if(fact[i]!=0)continue;\\n       // cout<<i<<endl;\\n       v.clear();\\n       ll t = 0;\\n       for (int j = i; j < 100000+1; j+=i)\\n       {\\n           fact[j]++;\\n           if(isPresent[j]){\\n               v.push_back(j);\\n               t+=1;\\n           }\\n       }\\n       if (t<=1)\\n       {\\n           continue;\\n       }\\n       for (auto &x : v)\\n       {\\n            thik [x]= 1;           \\n       }\\n   }\\n   for (int i = 0; i < nums.size(); ++i)\\n   {\\n        if (thik[nums[i]]==0)\\n        {\\n            return false;\\n        }\\n   }\\n   return true;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n#define ll int\\n    int fact[1000000+10];\\n    int isPresent[100000+10];\\n    int thik[100000+10];\\nbool canTraverseAllPairs(vector<int>& nums) {\\n    if(nums.size()==1)return true;\\n    // set<ll>st;\\n    // if(nums.size()==1)return true;\\n   \\n   for (int i = 0; i < nums.size(); ++i)\\n   {\\n       isPresent[nums[i]]++;\\n       if(isPresent[1]>0)return false;\\n       if(isPresent[nums[i]]==nums.size())return true;\\n   }\\n    if(isPresent[1]>0)return false;\\n    \\n   vector<ll>v;\\n  \\n   for (int i = 2; i < 100000+1; ++i)\\n   {\\n       if(fact[i]!=0)continue;\\n       // cout<<i<<endl;\\n       v.clear();\\n       ll t = 0;\\n       for (int j = i; j < 100000+1; j+=i)\\n       {\\n           fact[j]++;\\n           if(isPresent[j]){\\n               v.push_back(j);\\n               t+=1;\\n           }\\n       }\\n       if (t<=1)\\n       {\\n           continue;\\n       }\\n       for (auto &x : v)\\n       {\\n            thik [x]= 1;           \\n       }\\n   }\\n   for (int i = 0; i < nums.size(); ++i)\\n   {\\n        if (thik[nums[i]]==0)\\n        {\\n            return false;\\n        }\\n   }\\n   return true;\\n}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3571601,
                "title": "simple-brute-force",
                "content": "\\n# Approach\\nI am simply checking all the pairs, if i get an element,say x whose gcd with all the other elements is 1(except the elements which are at different index and their value is x,you need to skip these elements), then we cannot traverse to this element and in that case we return false immediately. If we couldnt find such element then we return true.\\n\\nEdge cases: when all elements are same in the array and not equal to 1,and when all elements are same in the array and equal to 1.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        if(nums.size()==1) return true; //edge case\\n        unordered_set<int> se(begin(nums),end(nums));\\n        //edge case\\n        if(se.size()==1){ \\n            if(se.find(1)==se.end()) return 1;\\n            return 0;\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            int f=0;\\n            for(int j=0;j<nums.size();j++){\\n                if(j!=i && __gcd(nums[i],nums[j])>1 && nums[i]!=nums[j]){\\n                    f=1;break;\\n                }\\n            }\\n            if(f==0) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        if(nums.size()==1) return true; //edge case\\n        unordered_set<int> se(begin(nums),end(nums));\\n        //edge case\\n        if(se.size()==1){ \\n            if(se.find(1)==se.end()) return 1;\\n            return 0;\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            int f=0;\\n            for(int j=0;j<nums.size();j++){\\n                if(j!=i && __gcd(nums[i],nums[j])>1 && nums[i]!=nums[j]){\\n                    f=1;break;\\n                }\\n            }\\n            if(f==0) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569202,
                "title": "two-times-union-find-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int find(int x,vector<int> &p){\\n        if(x==p[x])return x;\\n        return p[x] = find(p[x],p);\\n    }\\n    void unon(int a,int b,vector<int> &s,vector<int> &p){\\n        int x = find(a,p), y = find(b,p);\\n        if(x != y){\\n            if(s[x] < s[y])swap(x,y);\\n            s[x] += s[y];\\n            p[y] = x;\\n        }\\n    }\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        if(nums.size()==1)return true;\\n        for(auto &i: nums){\\n            if(i==1)return false;\\n        }\\n        int n = 1e5+2,x,y;\\n        sort(nums.begin(),nums.end(),[&](int &a,int &b){return a>b;});\\n        vector<int> p(n),s(n);\\n        for(int i = 0; i < n; i++){\\n            s[i] = 1;\\n            p[i] = i;\\n        }\\n        for(auto &i: nums){\\n            x = i;\\n            for(int j = 2; j <= sqrt(i); j++){\\n                if(x%j==0){\\n                    unon(i,j,s,p);\\n                    while(x%j==0)x /= j;\\n                    unon(p[i],p[j],s,p);\\n                }\\n            }\\n            if(x>1){\\n                unon(i,x,s,p);\\n                unon(p[i],p[x],s,p);\\n            }\\n        }\\n        for(auto &i: nums){\\n            x = i;\\n            for(int j = 2; j <= sqrt(i); j++){\\n                if(x%j==0){\\n                    unon(i,j,s,p);\\n                    while(x%j==0)x /= j;\\n                    unon(p[i],p[j],s,p);\\n                }\\n            }\\n            if(x>1){\\n                unon(i,x,s,p);\\n                unon(p[i],p[x],s,p);\\n            }\\n        }\\n        unordered_set<int> s1;\\n        for(auto &i: nums){\\n            s1.insert(p[i]);\\n        }\\n        return s1.size()==1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(int x,vector<int> &p){\\n        if(x==p[x])return x;\\n        return p[x] = find(p[x],p);\\n    }\\n    void unon(int a,int b,vector<int> &s,vector<int> &p){\\n        int x = find(a,p), y = find(b,p);\\n        if(x != y){\\n            if(s[x] < s[y])swap(x,y);\\n            s[x] += s[y];\\n            p[y] = x;\\n        }\\n    }\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        if(nums.size()==1)return true;\\n        for(auto &i: nums){\\n            if(i==1)return false;\\n        }\\n        int n = 1e5+2,x,y;\\n        sort(nums.begin(),nums.end(),[&](int &a,int &b){return a>b;});\\n        vector<int> p(n),s(n);\\n        for(int i = 0; i < n; i++){\\n            s[i] = 1;\\n            p[i] = i;\\n        }\\n        for(auto &i: nums){\\n            x = i;\\n            for(int j = 2; j <= sqrt(i); j++){\\n                if(x%j==0){\\n                    unon(i,j,s,p);\\n                    while(x%j==0)x /= j;\\n                    unon(p[i],p[j],s,p);\\n                }\\n            }\\n            if(x>1){\\n                unon(i,x,s,p);\\n                unon(p[i],p[x],s,p);\\n            }\\n        }\\n        for(auto &i: nums){\\n            x = i;\\n            for(int j = 2; j <= sqrt(i); j++){\\n                if(x%j==0){\\n                    unon(i,j,s,p);\\n                    while(x%j==0)x /= j;\\n                    unon(p[i],p[j],s,p);\\n                }\\n            }\\n            if(x>1){\\n                unon(i,x,s,p);\\n                unon(p[i],p[x],s,p);\\n            }\\n        }\\n        unordered_set<int> s1;\\n        for(auto &i: nums){\\n            s1.insert(p[i]);\\n        }\\n        return s1.size()==1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569177,
                "title": "java-prime-factors-and-disjoint-set-union-code-with-comments",
                "content": "# Intuition\\nAll numbers are connected through prime factors. \\nExample: In `4,3,12,8`, `4 = [2]` and `3 = [3]` are in separate component when we merge `12 = [2, 3]` then `4`, `3` and `12` come in same component.\\n\\n# Approach\\n\\n1. For each number, find all unique prime factor of the number.\\n2. Merge all the factors and number in one component (DSU).\\n3. Count number of components in DSU.\\n4. If there is only one component, all numbers can be traverse using GCD.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canTraverseAllPairs(int[] nums) {\\n        if (nums.length == 1) return true;\\n\\n        Map<Integer, Integer> dsu = new HashMap<>();\\n        \\n        for (int num : nums) {\\n            // if num is 1 GCD with any other number will be 1 so return false.\\n            if (num == 1) return false;\\n            \\n            // Get all unique [pri]\\n            Set<Integer> factors = findFactors(num);\\n            \\n            // First time visiting this node, it will be a separate component itself.\\n            if (!dsu.containsKey(num)) dsu.put(num, num);\\n            \\n            // For all prime factors merge factor and num.\\n            for (int factor : factors) {\\n                // If first time visiting this factor, it will be a separate component itself.\\n                if (!dsu.containsKey(factor)) dsu.put(factor, factor);\\n                \\n                // merge num and factor in one component.\\n                union(dsu, num, factor);\\n            }\\n        }\\n        \\n        // collect parent of all the components.\\n        Set<Integer> components = new HashSet<>();\\n        for (int num : nums) {\\n            components.add(find(dsu, num));\\n        }\\n        \\n        // if all nodes are part of same component components count will be 1.\\n        return components.size() == 1;\\n    }\\n    \\n    // Union operation to merge two components.\\n    private void union(Map<Integer, Integer> dsu, int num1, int num2) {\\n        int p1 = find(dsu, num1);\\n        int p2 = find(dsu, num2);\\n        \\n        dsu.put(p1, p2);\\n    }\\n    \\n    // Find operation to get the parent of DSU node.\\n    private int find(Map<Integer, Integer> dsu, int num) {\\n        if (dsu.getOrDefault(num, num) != num) {\\n            dsu.put(num, find(dsu, dsu.get(num)));\\n        }\\n        \\n        return dsu.getOrDefault(num, num);\\n    }\\n    \\n    // Method to get all the unique factors of the number.\\n    private HashSet<Integer> findFactors(int number) {\\n        HashSet<Integer> primeFactors = new HashSet<>();\\n        \\n        while (number % 2 == 0) {\\n            primeFactors.add(2);\\n            number /= 2;\\n        }\\n        \\n        for (int i = 3; i <= Math.sqrt(number); i += 2) {\\n            while (number % i == 0) {\\n                primeFactors.add(i);\\n                number /= i;\\n            }\\n        }\\n        \\n        if (number > 2) {\\n            primeFactors.add(number);\\n        }\\n        \\n        return primeFactors;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canTraverseAllPairs(int[] nums) {\\n        if (nums.length == 1) return true;\\n\\n        Map<Integer, Integer> dsu = new HashMap<>();\\n        \\n        for (int num : nums) {\\n            // if num is 1 GCD with any other number will be 1 so return false.\\n            if (num == 1) return false;\\n            \\n            // Get all unique [pri]\\n            Set<Integer> factors = findFactors(num);\\n            \\n            // First time visiting this node, it will be a separate component itself.\\n            if (!dsu.containsKey(num)) dsu.put(num, num);\\n            \\n            // For all prime factors merge factor and num.\\n            for (int factor : factors) {\\n                // If first time visiting this factor, it will be a separate component itself.\\n                if (!dsu.containsKey(factor)) dsu.put(factor, factor);\\n                \\n                // merge num and factor in one component.\\n                union(dsu, num, factor);\\n            }\\n        }\\n        \\n        // collect parent of all the components.\\n        Set<Integer> components = new HashSet<>();\\n        for (int num : nums) {\\n            components.add(find(dsu, num));\\n        }\\n        \\n        // if all nodes are part of same component components count will be 1.\\n        return components.size() == 1;\\n    }\\n    \\n    // Union operation to merge two components.\\n    private void union(Map<Integer, Integer> dsu, int num1, int num2) {\\n        int p1 = find(dsu, num1);\\n        int p2 = find(dsu, num2);\\n        \\n        dsu.put(p1, p2);\\n    }\\n    \\n    // Find operation to get the parent of DSU node.\\n    private int find(Map<Integer, Integer> dsu, int num) {\\n        if (dsu.getOrDefault(num, num) != num) {\\n            dsu.put(num, find(dsu, dsu.get(num)));\\n        }\\n        \\n        return dsu.getOrDefault(num, num);\\n    }\\n    \\n    // Method to get all the unique factors of the number.\\n    private HashSet<Integer> findFactors(int number) {\\n        HashSet<Integer> primeFactors = new HashSet<>();\\n        \\n        while (number % 2 == 0) {\\n            primeFactors.add(2);\\n            number /= 2;\\n        }\\n        \\n        for (int i = 3; i <= Math.sqrt(number); i += 2) {\\n            while (number % i == 0) {\\n                primeFactors.add(i);\\n                number /= i;\\n            }\\n        }\\n        \\n        if (number > 2) {\\n            primeFactors.add(number);\\n        }\\n        \\n        return primeFactors;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569155,
                "title": "python-3-prime-factorization-bfs",
                "content": "# Intuition\\nWe can build a graph where each *num* in *nums* is connected to all of its *prime factors*. Then, *it is possible to traverse between all such pairs of indices* if and only if the graph is *fully connected*.\\n\\n# Approach\\nFirst, we need to check the edge cases.\\n```\\n        if len(nums)==1: return True\\n        if nums.count(1)>0: return False\\n```\\nTo ensure optimal runtime, we need to find prime factors in O(log n). More details and explanation on the following factorization method can be found by googling \"Prime Factorization using Sieve O(log n) for multiple queries\".\\n```\\n        mx = max(nums)+1\\n        sieve = list(range(mx))\\n        for i in range(4, mx, 2):\\n            sieve[i] = 2\\n        for i in range(3, ceil(sqrt(mx))):\\n            if sieve[i] != i: continue\\n            for j in range(i * i, mx, i):\\n                if (sieve[j] == j):\\n                    sieve[j] = i\\n        def factorize(num):\\n            while (num != 1):\\n                yield sieve[num]\\n                num = num // sieve[num]\\n```\\nNext, we build our graph.\\n```\\n        g = defaultdict(set)\\n        for num in set(nums):\\n            for p in factorize(num):\\n                g[num].add(p)\\n                g[p].add(num)\\n```\\nFinally, using BFS to check if the graph is fully connected.\\n```\\n        dq,seen = deque([nums[0]]),{nums[0]}\\n        while dq:\\n            num = dq.popleft()\\n            for nxt in g[num]:\\n                if nxt in seen: continue\\n                seen.add(nxt)\\n                dq.append(nxt)\\n        return len(seen)==len(g)\\n```\\n# Python 3\\n```\\nclass Solution:\\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\\n        if len(nums)==1: return True\\n        if nums.count(1)>0: return False\\n        mx = max(nums)+1\\n        sieve = list(range(mx))\\n        for i in range(4, mx, 2):\\n            sieve[i] = 2\\n        for i in range(3, ceil(sqrt(mx))):\\n            if sieve[i] != i: continue\\n            for j in range(i * i, mx, i):\\n                if (sieve[j] == j):\\n                    sieve[j] = i\\n        def factorize(num):\\n            while (num != 1):\\n                yield sieve[num]\\n                num = num // sieve[num]\\n        g = defaultdict(set)\\n        for num in set(nums):\\n            for p in factorize(num):\\n                g[num].add(p)\\n                g[p].add(num)\\n        dq,seen = deque([nums[0]]),{nums[0]}\\n        while dq:\\n            num = dq.popleft()\\n            for nxt in g[num]:\\n                if nxt in seen: continue\\n                seen.add(nxt)\\n                dq.append(nxt)\\n        return len(seen)==len(g)\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\n        if len(nums)==1: return True\\n        if nums.count(1)>0: return False\\n```\n```\\n        mx = max(nums)+1\\n        sieve = list(range(mx))\\n        for i in range(4, mx, 2):\\n            sieve[i] = 2\\n        for i in range(3, ceil(sqrt(mx))):\\n            if sieve[i] != i: continue\\n            for j in range(i * i, mx, i):\\n                if (sieve[j] == j):\\n                    sieve[j] = i\\n        def factorize(num):\\n            while (num != 1):\\n                yield sieve[num]\\n                num = num // sieve[num]\\n```\n```\\n        g = defaultdict(set)\\n        for num in set(nums):\\n            for p in factorize(num):\\n                g[num].add(p)\\n                g[p].add(num)\\n```\n```\\n        dq,seen = deque([nums[0]]),{nums[0]}\\n        while dq:\\n            num = dq.popleft()\\n            for nxt in g[num]:\\n                if nxt in seen: continue\\n                seen.add(nxt)\\n                dq.append(nxt)\\n        return len(seen)==len(g)\\n```\n```\\nclass Solution:\\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\\n        if len(nums)==1: return True\\n        if nums.count(1)>0: return False\\n        mx = max(nums)+1\\n        sieve = list(range(mx))\\n        for i in range(4, mx, 2):\\n            sieve[i] = 2\\n        for i in range(3, ceil(sqrt(mx))):\\n            if sieve[i] != i: continue\\n            for j in range(i * i, mx, i):\\n                if (sieve[j] == j):\\n                    sieve[j] = i\\n        def factorize(num):\\n            while (num != 1):\\n                yield sieve[num]\\n                num = num // sieve[num]\\n        g = defaultdict(set)\\n        for num in set(nums):\\n            for p in factorize(num):\\n                g[num].add(p)\\n                g[p].add(num)\\n        dq,seen = deque([nums[0]]),{nums[0]}\\n        while dq:\\n            num = dq.popleft()\\n            for nxt in g[num]:\\n                if nxt in seen: continue\\n                seen.add(nxt)\\n                dq.append(nxt)\\n        return len(seen)==len(g)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568743,
                "title": "easy-c-commented-solution-factorisation-union-set",
                "content": "\\n### Do Upvote if it helps !!\\n\\n# Code\\n```\\n\\n//class for union find\\nclass DS\\n{\\n    public:\\n  vector<int> parent, size;\\n\\n  DS(int n)\\n  {\\n    parent.resize(n + 1);\\n    size.resize(n + 1);\\n    for (int i = 0; i <= n; i++)\\n    {\\n      parent[i] = i;\\n      size[i] = 1;\\n    }\\n  }\\n\\n  int find(int node)\\n  {\\n    if (node == parent[node])\\n      return node;\\n    return parent[node] = find(parent[node]);\\n  }\\n\\n  void union_size(int u, int v)\\n  {\\n    int ulp_u = find(u);\\n    int ulp_v = find(v);\\n    if (ulp_u == ulp_v)\\n      return;\\n    if (size[ulp_u] < size[ulp_v])\\n    {\\n      parent[ulp_u] = ulp_v;\\n      size[ulp_v] += size[ulp_u];\\n    }\\n    else\\n    {\\n      parent[ulp_v] = ulp_u;\\n      size[ulp_u] += size[ulp_v];\\n    }\\n  }\\n};\\n\\nclass Solution {\\npublic:\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        if(nums.size()==1){\\n            return true;\\n        }\\n\\n        //adding each value to sets of its factors\\n        unordered_map<int,vector<int>> mp;\\n        for(int i=0 ; i<nums.size() ; i++){\\n            if(nums[i]==1){\\n                return false;\\n            }\\n            for(int j=2 ; j*j<=nums[i] ; j++){\\n                if(nums[i]%j==0){\\n                    mp[j].push_back(i);\\n                    int k=nums[i]/j;\\n                    if(k==j){\\n                        continue;\\n                    }\\n                    mp[k].push_back(i);\\n                }\\n            }\\n            mp[nums[i]].push_back(i);\\n        }\\n        \\n        //combining/ union of values having same factor\\n        DS ds(nums.size());\\n        for(auto m : mp ){\\n            int x=m.first;;\\n            for(int i=0 ; i<mp[x].size()-1 ; i++){\\n                ds.union_size(ds.find(mp[x][i]),ds.find(mp[x][i+1]));\\n            }\\n        }\\n        int count=0;\\n        for(int i=0 ; i<nums.size() ; i++){\\n            if((ds.find(i)==i)){\\n                count++;\\n            }\\n            if(count>1){\\n              return false;\\n            }\\n        }\\n\\n        //if all belong to same group\\n        if(count==1){\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\n\\n//class for union find\\nclass DS\\n{\\n    public:\\n  vector<int> parent, size;\\n\\n  DS(int n)\\n  {\\n    parent.resize(n + 1);\\n    size.resize(n + 1);\\n    for (int i = 0; i <= n; i++)\\n    {\\n      parent[i] = i;\\n      size[i] = 1;\\n    }\\n  }\\n\\n  int find(int node)\\n  {\\n    if (node == parent[node])\\n      return node;\\n    return parent[node] = find(parent[node]);\\n  }\\n\\n  void union_size(int u, int v)\\n  {\\n    int ulp_u = find(u);\\n    int ulp_v = find(v);\\n    if (ulp_u == ulp_v)\\n      return;\\n    if (size[ulp_u] < size[ulp_v])\\n    {\\n      parent[ulp_u] = ulp_v;\\n      size[ulp_v] += size[ulp_u];\\n    }\\n    else\\n    {\\n      parent[ulp_v] = ulp_u;\\n      size[ulp_u] += size[ulp_v];\\n    }\\n  }\\n};\\n\\nclass Solution {\\npublic:\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        if(nums.size()==1){\\n            return true;\\n        }\\n\\n        //adding each value to sets of its factors\\n        unordered_map<int,vector<int>> mp;\\n        for(int i=0 ; i<nums.size() ; i++){\\n            if(nums[i]==1){\\n                return false;\\n            }\\n            for(int j=2 ; j*j<=nums[i] ; j++){\\n                if(nums[i]%j==0){\\n                    mp[j].push_back(i);\\n                    int k=nums[i]/j;\\n                    if(k==j){\\n                        continue;\\n                    }\\n                    mp[k].push_back(i);\\n                }\\n            }\\n            mp[nums[i]].push_back(i);\\n        }\\n        \\n        //combining/ union of values having same factor\\n        DS ds(nums.size());\\n        for(auto m : mp ){\\n            int x=m.first;;\\n            for(int i=0 ; i<mp[x].size()-1 ; i++){\\n                ds.union_size(ds.find(mp[x][i]),ds.find(mp[x][i+1]));\\n            }\\n        }\\n        int count=0;\\n        for(int i=0 ; i<nums.size() ; i++){\\n            if((ds.find(i)==i)){\\n                count++;\\n            }\\n            if(count>1){\\n              return false;\\n            }\\n        }\\n\\n        //if all belong to same group\\n        if(count==1){\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568719,
                "title": "simple-dfs-and-prime-factorization",
                "content": "**Approach**\\n\\t   First find all ***primes factors*** and then try to check if they belong to same connected component or not using the common prime factors.  Finally, do a ***dfs*** from any number to mark the positions as visited. If in one dfs call every index is marked as visited that means ``no of connected component == 1 , So return true else return false``\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, vector<int>> f,ff;\\n    unordered_map<int,bool> vis2;\\n\\t\\n\\t// dfs \\n\\tvoid dfs(int pos,vector<bool> &vis){\\n        if(vis[pos]==true) return;\\n        vis[pos]=true;\\n        for(auto &node : ff[pos]){\\n            if(vis2.count(node)) continue;\\n            vis2[node]=true;\\n            for(auto &ch : f[node]){\\n                if(vis[ch]==true) continue;\\n                dfs(ch,vis);\\n            }\\n        }\\n    }\\n\\t\\n\\t\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        // get all the prime factors \\n        int i=0;\\n        for (auto &x : nums) {\\n            for (int j = 2; j * j <= nums[i]; j++) {\\n                if (x%j == 0) {\\n                    f[j].push_back(i);\\n                    ff[i].push_back(j);\\n                    while (x % j == 0) {\\n                      x /= j;\\n                    }\\n                }\\n            }\\n            if (x > 1) {f[x].push_back(i);ff[i].push_back(x);}\\n            i++;\\n        }\\n        \\n        // run a dfs \\n        vector<bool> vis(nums.size(),false);\\n        dfs(0,vis);\\n        \\n        // if no of connected comp is > 1 then return false\\n        for(int i=0;i<vis.size();i++) if(vis[i]==false) return false;\\n        return true;\\n    }\\n};\\n```\\n\\n**Please upvote if you like the post :)**",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, vector<int>> f,ff;\\n    unordered_map<int,bool> vis2;\\n\\t\\n\\t// dfs \\n\\tvoid dfs(int pos,vector<bool> &vis){\\n        if(vis[pos]==true) return;\\n        vis[pos]=true;\\n        for(auto &node : ff[pos]){\\n            if(vis2.count(node)) continue;\\n            vis2[node]=true;\\n            for(auto &ch : f[node]){\\n                if(vis[ch]==true) continue;\\n                dfs(ch,vis);\\n            }\\n        }\\n    }\\n\\t\\n\\t\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        // get all the prime factors \\n        int i=0;\\n        for (auto &x : nums) {\\n            for (int j = 2; j * j <= nums[i]; j++) {\\n                if (x%j == 0) {\\n                    f[j].push_back(i);\\n                    ff[i].push_back(j);\\n                    while (x % j == 0) {\\n                      x /= j;\\n                    }\\n                }\\n            }\\n            if (x > 1) {f[x].push_back(i);ff[i].push_back(x);}\\n            i++;\\n        }\\n        \\n        // run a dfs \\n        vector<bool> vis(nums.size(),false);\\n        dfs(0,vis);\\n        \\n        // if no of connected comp is > 1 then return false\\n        for(int i=0;i<vis.size();i++) if(vis[i]==false) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3582175,
                "title": "disjointset-c-easy-solution",
                "content": "# Intuition\\nWe use a DisJointSet data structure to store number of connected components and connect the number with resect to their prime factors.\\nAt last we see is number of connected component is equal to number of elements in the array.\\n# Approach\\neg. nums=[2,3,6];\\n2->2\\n3->3\\n6->2 3\\n\\nso we store elements by their prime factors;\\n2->2 6\\n3->3 6\\nconnect 2 and 6\\nand 3 and 6\\nin this way all are connected.\\n\\n# Code\\n```\\nclass DisJointSet {\\n    vector<int> size,parent;\\npublic:\\n    DisJointSet(int n){\\n        size.resize(n,1);\\n        parent.resize(n,0);\\n        for(int i=0;i<n;i++)parent[i]=i;\\n    }\\n    void unionBySize(int u,int v){\\n        int pu=findParent(u);\\n        int pv=findParent(v);\\n        if(pu==pv)return ;\\n        if(size[pu]>size[pv]){\\n            parent[pv]=parent[pu];\\n            size[pu]+=size[pv];\\n        }\\n        else{\\n            parent[pu]=parent[pv];\\n            size[pv]+=size[pu];\\n        }\\n    }\\n    int findParent(int u){\\n        if(u==parent[u])return u;\\n        return parent[u]=findParent(parent[u]);\\n    }\\n    int maxSize(){\\n        return *max_element(size.begin(),size.end());\\n    }\\n};\\nclass Solution {\\npublic:\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int n=nums.size();\\n        DisJointSet ds(n+1);\\n        unordered_map<int,vector<int>> mp;\\n        for(int i=0;i<n;i++){\\n            for(int j=2;j*j<=nums[i];j++){\\n                if(nums[i]%j==0)mp[j].push_back(i);\\n                while(nums[i]%j==0)nums[i]/=j;\\n            }\\n            if(nums[i]>1)mp[nums[i]].push_back(i);\\n        }\\n        for(auto it:mp){\\n            for(int i=1;i<it.second.size();i++){\\n                ds.unionBySize(it.second[i-1],it.second[i]);\\n            }\\n        }\\n\\n        return n==ds.maxSize();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass DisJointSet {\\n    vector<int> size,parent;\\npublic:\\n    DisJointSet(int n){\\n        size.resize(n,1);\\n        parent.resize(n,0);\\n        for(int i=0;i<n;i++)parent[i]=i;\\n    }\\n    void unionBySize(int u,int v){\\n        int pu=findParent(u);\\n        int pv=findParent(v);\\n        if(pu==pv)return ;\\n        if(size[pu]>size[pv]){\\n            parent[pv]=parent[pu];\\n            size[pu]+=size[pv];\\n        }\\n        else{\\n            parent[pu]=parent[pv];\\n            size[pv]+=size[pu];\\n        }\\n    }\\n    int findParent(int u){\\n        if(u==parent[u])return u;\\n        return parent[u]=findParent(parent[u]);\\n    }\\n    int maxSize(){\\n        return *max_element(size.begin(),size.end());\\n    }\\n};\\nclass Solution {\\npublic:\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int n=nums.size();\\n        DisJointSet ds(n+1);\\n        unordered_map<int,vector<int>> mp;\\n        for(int i=0;i<n;i++){\\n            for(int j=2;j*j<=nums[i];j++){\\n                if(nums[i]%j==0)mp[j].push_back(i);\\n                while(nums[i]%j==0)nums[i]/=j;\\n            }\\n            if(nums[i]>1)mp[nums[i]].push_back(i);\\n        }\\n        for(auto it:mp){\\n            for(int i=1;i<it.second.size();i++){\\n                ds.unionBySize(it.second[i-1],it.second[i]);\\n            }\\n        }\\n\\n        return n==ds.maxSize();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569926,
                "title": "c-uf-by-prime-numbers-338ms-100-5mb",
                "content": "Some thoughts about this problem:\\n* we need to be able to connect each node with each other in pairs, which implies we might potentially walk over the same node more than once to have everything connected and still valid;\\n* in this sense, the problem boils down to a clustering problem where we want to check if we can end up clustering all the elements in just one cluster or not;\\n* if we need to do some clustering, UnionFind (from now on: \"UF\"; AKA \"Disjoint Set\") is king;\\n* trying to build the graph checking each possible pair would be not douable (quadratic time with the given constraints, plus an operation relatively as heavy as `gcd` will guarantee a time out here);\\n* an alternative, way more performing solution, might be to group all the numbers (or, even more conveniently for a UF, their indexes) by prime divisors;\\n* the grouping can then be passed to the UF data structure and that\\'s about it;\\n* we can play smart and just test for all the primes up to the square root of the upper value of our range (ie: `sqrt(100000) == 316`), since we cannot have any number made as the product of two prime factors who are BOTH greater than the square root;\\n* every time we will find a value divisible by a given prime `p`, we will keep dividing it by `p` until it is no longer divisible;\\n* once the number reaches `1`, we are done further dividing it;\\n* this trick will also work to detect factors above `316` (if our number does not boil down to `1`, then its current value has to be another prime).\\n\\nIF you want extra practice, consider solving the very similar problem [largest component size by common factor](https://leetcode.com/problems/largest-component-size-by-common-factor/) ([fully cracked here](https://leetcode.com/problems/largest-component-size-by-common-factor/solutions/3571728/c-uf-by-primes-98-time-167ms-85-space-53-1mb/)).\\n\\nTo code it all, we will start declaring the array `primes` with the list of the first prime numbers fitting our threshold (a quick google search might help us populate it very quickly, while in an interview we might be asked to at least discuss other techniques like the sieve of Eratosthenes).\\n\\nOur `UF` class will have:\\n* two instance variables:\\n    * `parent` is an array matching all the nodes to their parents;\\n    * `clusters` will count how many clusters we have\\n* a constructor taking the expected size of our graph `len` that we will use to initialise our instance variable:\\n    * each of the first `len` cells in `parent` will be initialised with a value equal to its index using `iota` (ie: its node is the head of its own cluster);\\n    * `clusters` will have a value equal to `len` (ie: we have `len` clusters initially, each with a single node connected only to itself);\\n* a method `find` that will take a `node` and:\\n    * if `node` is the head of a cluster (ie: `parent[node] == node`), just `return` `node`;\\n    * otherwise, it will:\\n        * call `find` recursively with `parent[node]` until that condition is met;\\n        * store that result in `parent[node]` of all the explored nodes;\\n        * `return` that value;\\n* a `merge` method that will take two nodes `a` and `b` and:\\n    * replace their values with those of their ultimate parents (ie: the head of the clusters found calling `find` on them);\\n    * a small trick I like to follow here to make UFs more performing is to force `a` to be the smallest of the two with a `swap` if necessary - it performs comparably well to implementing a ranking system (see below), without extra space\\n    * `return` if those nodes were already in the same cluster (ie: `a == b`);\\n    * if not:\\n        * actually merge the two nodes, setting `a` as a parent of `b`;\\n        * decrease `clusters` by `1` (we just united two differnt ones).\\n\\nOur main function will start with a few support variables:\\n* `len` is equal to the size of `nums`;\\n* `uf` is an instance of our `UF` class, invoked passing `len` as its size;\\n* `divisors` will be a map of all the divisors (keys) and the indexes of all the elements of `nums` divisible by them (values).\\n\\nIt will be our care next to populate `divisors`, looping with `i` through each element in `nums` and:\\n* assigning the value of `nums[i]` to `n`;\\n* looping through each prime `p` in `primes` and:\\n    * if `p` is a divisors of `n`, we will:\\n    * add `i` as one of the elements under `divisors[p]`;\\n    * keep dividing `n` by `p` while `n % p == 0` (note we are doing this with a `do... while` loop to optimise, since we know that the first iteration is always valid since we are inside this `if` clause);\\n    * if we reached a value of `1` for `n`, we know that there are no more primes to extract from it, so we can `break`;\\n* if we still have `n` with a value `!= 1`, it means that `n` is a bigger prime itself, so we will store index `i` in `divisors[n]`. \\n\\nNow that we have (the index of) every element grouped by divisors, creating clusters of nodes with these edges (the common divisors among nodes) becomes almost trivial and so we will take each group of values `vals` in `divisors` and:\\n* take the first value (ie: `vals[0]`) as temporary head of the current cluster;\\n* merge all the other elements with it, by calling `uf.merge` with `head` and `vals[i]`\\n\\nFinally, we will `return` `true` is we have only a single cluster left, `false` otherwise.\\n\\n# Complexity\\n- Time complexity: $$O(n + n\\u03B1(n)$$ (with `\\u03B1(n` being the [reverse Ackermann function](https://en.wikipedia.org/wiki/Ackermann_function#Inverse))\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```cpp\\nconstexpr int primes[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313};\\n\\nstruct UF {\\n    int parent[100000], clusters;\\n    UF(int len) {\\n        iota(parent, parent + len, 0);\\n        clusters = len;\\n    }\\n    int find(int node) {\\n        return parent[node] == node ? node : parent[node] = find(parent[node]);\\n    }\\n    void merge(int a, int b) {\\n        a = find(a), b = find(b);\\n        // making sure a is smaller\\n        if (b < a) swap(a, b);\\n        // already merged\\n        if (a == b) return;\\n        parent[b] = a, clusters--;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    bool canTraverseAllPairs(vector<int> &nums) {\\n        // support variables\\n        int len = nums.size();\\n        UF uf = UF(len);\\n        unordered_map<int, vector<int>> divisors;\\n        // populating divisors\\n        for (int i = 0, n; i < len; i++) {\\n            n = nums[i];\\n            for (int p: primes) {\\n                // found a divisor of n\\n                if (n % p == 0) {\\n                    divisors[p].push_back(i);\\n                    do {n /= p;}\\n                    while (n % p == 0);\\n                }\\n                // done mining primes from n\\n                if (n == 1) break;\\n            }\\n            // special case: leftover n is a bigger prime\\n            if (n != 1) divisors[n].push_back(i);\\n        }\\n        // merging clusters by their connections\\n        for (auto &[key, vals]: divisors) {\\n            int head = vals[0];\\n            for (int i = 1, lmt = vals.size(); i < lmt; i++) uf.merge(head, vals[i]);\\n\\n        }\\n        return uf.clusters == 1;\\n    }\\n};\\n```\\n\\nVariation, implementing a UF with a ranking criteria; it burns some more memory and it hardly makes a difference in time complexity, also considering we are not working with very large graphs:\\n\\n```cpp\\n// the rest is the same\\nstruct UF {\\n    int parent[100000], rank[100000], clusters;\\n    UF(int len) {\\n        iota(parent, parent + len, 0);\\n        fill(rank, rank + len, 1);\\n        clusters = len;\\n    }\\n    int find(int node) {\\n        return parent[node] == node ? node : parent[node] = find(parent[node]);\\n    }\\n    void merge(int a, int b) {\\n        a = find(a), b = find(b);\\n        // making sure a has higher rank\\n        if (rank[b] > rank[a]) swap(a, b);\\n        // already merged\\n        if (a == b) return;\\n        parent[b] = a, rank[a] += rank[b], clusters--;\\n    }\\n};\\n```\\n\\nBut we can do better in another way: we can just use an array of vectors for most `divisors` (way cheaper than computing a hash all the time) and still used an `unordered_map` for `largerDivisors` - this approach has some code duplication, but since it easily shaves off more than 100ms and even saves us a few MBs, I would not mind:\\n\\n```cpp\\n// the rest is the same\\nclass Solution {\\npublic:\\n    bool canTraverseAllPairs(vector<int> &nums) {\\n        // support variables\\n        int len = nums.size(), lenPrimes = sizeof(primes) / sizeof(int);\\n        UF uf = UF(len);\\n        vector<int> divisors[lenPrimes];\\n        unordered_map<int, vector<int>> largerDivisors;\\n        // populating divisors and largerDivisors\\n        for (int i = 0, n; i < len; i++) {\\n            n = nums[i];\\n            for (int j = 0, p; j < lenPrimes ; j++) {\\n                p = primes[j];\\n                // found a divisor of n\\n                if (n % p == 0) {\\n                    divisors[j].push_back(i);\\n                    do {n /= p;}\\n                    while (n % p == 0);\\n                }\\n                // done mining primes from n\\n                if (n == 1) break;\\n            }\\n            // special case: leftover n is a bigger prime\\n            if (n != 1) largerDivisors[n].push_back(i);\\n        }\\n        // merging clusters by their connections\\n        for (int i = 0; i < lenPrimes; i++) {\\n            auto &vals = divisors[i];\\n            if (!vals.size()) continue;\\n            int head = vals[0];\\n            for (int j = 1, lmt = vals.size(); j < lmt; j++) uf.merge(head, vals[j]);\\n        }\\n        if (largerDivisors.size()) {\\n            for (auto &[key, vals]: largerDivisors) {\\n                int head = vals[0];\\n                for (int i = 1, lmt = vals.size(); i < lmt; i++) uf.merge(head, vals[i]);\\n\\n            }\\n        }\\n        return uf.clusters == 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph",
                    "Number Theory"
                ],
                "code": "```cpp\\nconstexpr int primes[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313};\\n\\nstruct UF {\\n    int parent[100000], clusters;\\n    UF(int len) {\\n        iota(parent, parent + len, 0);\\n        clusters = len;\\n    }\\n    int find(int node) {\\n        return parent[node] == node ? node : parent[node] = find(parent[node]);\\n    }\\n    void merge(int a, int b) {\\n        a = find(a), b = find(b);\\n        // making sure a is smaller\\n        if (b < a) swap(a, b);\\n        // already merged\\n        if (a == b) return;\\n        parent[b] = a, clusters--;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    bool canTraverseAllPairs(vector<int> &nums) {\\n        // support variables\\n        int len = nums.size();\\n        UF uf = UF(len);\\n        unordered_map<int, vector<int>> divisors;\\n        // populating divisors\\n        for (int i = 0, n; i < len; i++) {\\n            n = nums[i];\\n            for (int p: primes) {\\n                // found a divisor of n\\n                if (n % p == 0) {\\n                    divisors[p].push_back(i);\\n                    do {n /= p;}\\n                    while (n % p == 0);\\n                }\\n                // done mining primes from n\\n                if (n == 1) break;\\n            }\\n            // special case: leftover n is a bigger prime\\n            if (n != 1) divisors[n].push_back(i);\\n        }\\n        // merging clusters by their connections\\n        for (auto &[key, vals]: divisors) {\\n            int head = vals[0];\\n            for (int i = 1, lmt = vals.size(); i < lmt; i++) uf.merge(head, vals[i]);\\n\\n        }\\n        return uf.clusters == 1;\\n    }\\n};\\n```\n```cpp\\n// the rest is the same\\nstruct UF {\\n    int parent[100000], rank[100000], clusters;\\n    UF(int len) {\\n        iota(parent, parent + len, 0);\\n        fill(rank, rank + len, 1);\\n        clusters = len;\\n    }\\n    int find(int node) {\\n        return parent[node] == node ? node : parent[node] = find(parent[node]);\\n    }\\n    void merge(int a, int b) {\\n        a = find(a), b = find(b);\\n        // making sure a has higher rank\\n        if (rank[b] > rank[a]) swap(a, b);\\n        // already merged\\n        if (a == b) return;\\n        parent[b] = a, rank[a] += rank[b], clusters--;\\n    }\\n};\\n```\n```cpp\\n// the rest is the same\\nclass Solution {\\npublic:\\n    bool canTraverseAllPairs(vector<int> &nums) {\\n        // support variables\\n        int len = nums.size(), lenPrimes = sizeof(primes) / sizeof(int);\\n        UF uf = UF(len);\\n        vector<int> divisors[lenPrimes];\\n        unordered_map<int, vector<int>> largerDivisors;\\n        // populating divisors and largerDivisors\\n        for (int i = 0, n; i < len; i++) {\\n            n = nums[i];\\n            for (int j = 0, p; j < lenPrimes ; j++) {\\n                p = primes[j];\\n                // found a divisor of n\\n                if (n % p == 0) {\\n                    divisors[j].push_back(i);\\n                    do {n /= p;}\\n                    while (n % p == 0);\\n                }\\n                // done mining primes from n\\n                if (n == 1) break;\\n            }\\n            // special case: leftover n is a bigger prime\\n            if (n != 1) largerDivisors[n].push_back(i);\\n        }\\n        // merging clusters by their connections\\n        for (int i = 0; i < lenPrimes; i++) {\\n            auto &vals = divisors[i];\\n            if (!vals.size()) continue;\\n            int head = vals[0];\\n            for (int j = 1, lmt = vals.size(); j < lmt; j++) uf.merge(head, vals[j]);\\n        }\\n        if (largerDivisors.size()) {\\n            for (auto &[key, vals]: largerDivisors) {\\n                int head = vals[0];\\n                for (int i = 1, lmt = vals.size(); i < lmt; i++) uf.merge(head, vals[i]);\\n\\n            }\\n        }\\n        return uf.clusters == 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568542,
                "title": "python-3-prime-factorization-union-find",
                "content": "If two elements share a prime factor, then they have an edge between them.\\nAfter making all the edges, find if the graph is connected or not.\\n\\n```\\nclass Solution:\\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        \\n\\t\\t# UNION FIND\\n        par = {i: i for i in range(n)}\\n        rank = {i: 1 for i in range(n)}\\n        \\n        def find(n1):\\n            while n1 != par[n1]:\\n                par[n1] = par[par[n1]]\\n                n1 = par[n1]\\n            return n1\\n        \\n        def union(n1, n2):\\n            p1, p2 = find(n1), find(n2)\\n            if p1 == p2:\\n                return 0\\n            if rank[p1] < rank[p2]:\\n                p1, p2 = p2, p1\\n            par[p2] = p1\\n            rank[p1] += rank[p2]\\n            return 1\\n        \\n\\t\\t# TO FIND PRIME FACTORS\\n        def getPrimeDivs(n):\\n            if n < 0: return []\\n            res = set()\\n\\n            for i in range(2, isqrt(n) + 1):\\n                while n % i == 0:\\n                    res.add(i)\\n                    n //= i\\n\\n            if n > 1: res.add(n)\\n            return res\\n        \\n        primes = defaultdict(list) # Stores the indices of elements having key as a prime factor\\n        for idx, i in enumerate(nums):\\n            primeDivs = getPrimeDivs(i)\\n            \\n            for p in primeDivs:\\n                primes[p].append(idx)\\n        \\n\\t\\t# UNITE INDICES HAVING SAME PRIME FACTORS\\n        for p in primes:\\n            for i in primes[p]:\\n                union(i, primes[p][0])\\n        \\n\\t\\t# CHECK IF THE GRAPH IS CONNECTED\\n        return sum(i == find(i) for i in range(n)) == 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        \\n\\t\\t# UNION FIND\\n        par = {i: i for i in range(n)}\\n        rank = {i: 1 for i in range(n)}\\n        \\n        def find(n1):\\n            while n1 != par[n1]:\\n                par[n1] = par[par[n1]]\\n                n1 = par[n1]\\n            return n1\\n        \\n        def union(n1, n2):\\n            p1, p2 = find(n1), find(n2)\\n            if p1 == p2:\\n                return 0\\n            if rank[p1] < rank[p2]:\\n                p1, p2 = p2, p1\\n            par[p2] = p1\\n            rank[p1] += rank[p2]\\n            return 1\\n        \\n\\t\\t# TO FIND PRIME FACTORS\\n        def getPrimeDivs(n):\\n            if n < 0: return []\\n            res = set()\\n\\n            for i in range(2, isqrt(n) + 1):\\n                while n % i == 0:\\n                    res.add(i)\\n                    n //= i\\n\\n            if n > 1: res.add(n)\\n            return res\\n        \\n        primes = defaultdict(list) # Stores the indices of elements having key as a prime factor\\n        for idx, i in enumerate(nums):\\n            primeDivs = getPrimeDivs(i)\\n            \\n            for p in primeDivs:\\n                primes[p].append(idx)\\n        \\n\\t\\t# UNITE INDICES HAVING SAME PRIME FACTORS\\n        for p in primes:\\n            for i in primes[p]:\\n                union(i, primes[p][0])\\n        \\n\\t\\t# CHECK IF THE GRAPH IS CONNECTED\\n        return sum(i == find(i) for i in range(n)) == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3961856,
                "title": "initialize-size-of-i-as-1-only-if-i-is-present-in-nums",
                "content": "# Intuition\\nPseudo node + union find + sieve that is it\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>par;\\n    vector<int>sz;\\n\\n    int find(int x){\\n        if(x==par[x])return x;\\n        return par[x]=find(par[x]);\\n    }\\n    void unite(int a,int b){\\n        int apar=find(a);\\n        int bpar=find(b);\\n\\n        if(apar==bpar)return;\\n\\n        if(sz[apar]<sz[bpar])swap(sz[apar],sz[bpar]);\\n\\n        sz[apar]+=sz[bpar];\\n        sz[bpar]=0;\\n        par[bpar]=par[apar];\\n    }\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int n=nums.size();\\n        par.resize(100100);\\n        sz.resize(100100);\\n        map<int,int>mp;\\n        if(nums.size()==1)return true;\\n        for(auto x:nums){\\n            mp[x]++;\\n            if(x==1)return false;\\n        }\\n        int sieve[100100];\\n        for(int i=1;i<100100;i++){\\n            sieve[i]=i;\\n            if(mp.find(i)==mp.end())sz[i]=0;\\n            else sz[i]+=mp[i];\\n            par[i]=i;\\n\\n        }\\n        for(int i=2;i<100100;i++){\\n            if(sieve[i]==i){\\n                for(int j=i+i;j<100100;j+=i){\\n                    sieve[j]=i;\\n                }\\n            }\\n        }\\n\\n        for(auto x:nums){\\n            map<int,int>mp2;\\n            int cpy=x;\\n            while(x>1){\\n                mp2[sieve[x]]++;\\n                x/=sieve[x];\\n            }\\n\\n            for(auto it:mp2){\\n                int val=it.first;\\n                unite(cpy,val);\\n            }\\n        }\\n\\n        int cmp=0;\\n        for(int i=2;i<100100;i++){\\n            if(par[i]==i&&sz[i]>0)cmp++;\\n        }\\n        return cmp==1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>par;\\n    vector<int>sz;\\n\\n    int find(int x){\\n        if(x==par[x])return x;\\n        return par[x]=find(par[x]);\\n    }\\n    void unite(int a,int b){\\n        int apar=find(a);\\n        int bpar=find(b);\\n\\n        if(apar==bpar)return;\\n\\n        if(sz[apar]<sz[bpar])swap(sz[apar],sz[bpar]);\\n\\n        sz[apar]+=sz[bpar];\\n        sz[bpar]=0;\\n        par[bpar]=par[apar];\\n    }\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int n=nums.size();\\n        par.resize(100100);\\n        sz.resize(100100);\\n        map<int,int>mp;\\n        if(nums.size()==1)return true;\\n        for(auto x:nums){\\n            mp[x]++;\\n            if(x==1)return false;\\n        }\\n        int sieve[100100];\\n        for(int i=1;i<100100;i++){\\n            sieve[i]=i;\\n            if(mp.find(i)==mp.end())sz[i]=0;\\n            else sz[i]+=mp[i];\\n            par[i]=i;\\n\\n        }\\n        for(int i=2;i<100100;i++){\\n            if(sieve[i]==i){\\n                for(int j=i+i;j<100100;j+=i){\\n                    sieve[j]=i;\\n                }\\n            }\\n        }\\n\\n        for(auto x:nums){\\n            map<int,int>mp2;\\n            int cpy=x;\\n            while(x>1){\\n                mp2[sieve[x]]++;\\n                x/=sieve[x];\\n            }\\n\\n            for(auto it:mp2){\\n                int val=it.first;\\n                unite(cpy,val);\\n            }\\n        }\\n\\n        int cmp=0;\\n        for(int i=2;i<100100;i++){\\n            if(par[i]==i&&sz[i]>0)cmp++;\\n        }\\n        return cmp==1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3603007,
                "title": "c-union-find",
                "content": "One of the renowned AI model is capable to produce the brute force answer of this problem, then to optimise it to most extreme point.\\n\\n```\\nclass UF {\\npublic:\\n    vector<int> parent;\\n    vector<int> rank;\\n\\n    UF(int n) {\\n        parent.resize(n);\\n        rank.resize(n, 0);\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }\\n    }\\n\\n    int find(int x) {\\n        if (parent[x] != x) {\\n            parent[x] = find(parent[x]);  // Path compression\\n        }\\n        return parent[x];\\n    }\\n\\n    void join(int x, int y) {\\n        int rootX = find(x);\\n        int rootY = find(y);\\n\\n        if (rootX != rootY) {\\n            if (rank[rootX] < rank[rootY]) {\\n                parent[rootX] = rootY;\\n            } else if (rank[rootX] > rank[rootY]) {\\n                parent[rootY] = rootX;\\n            } else {\\n                parent[rootX] = rootY;\\n                rank[rootY]++;\\n            }\\n        }\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    \\n    vector<int> factors(int num) {\\n        vector<int> ans;\\n        for(int j = 2; j * j <= num; j++) {\\n            while(num % j == 0) {\\n                num /= j;\\n                ans.push_back(j);\\n            }\\n        }\\n        if(num != 1) ans.push_back(num);\\n        return ans;\\n    }\\n    \\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        \\n        int n  = nums.size();\\n        UF *uf = new UF(n);\\n        unordered_map<int, int> mp;\\n\\n        for(int i = 0; i < nums.size(); i++) {\\n            int num = nums[i];\\n            vector<int> fact = factors(num);\\n            for (int x : fact) {\\n                if(mp.count(x)) {\\n                    uf->join(i, mp[x]);\\n                } else {\\n                    mp[x] = i;\\n                }\\n            }\\n        }\\n \\n        for(int i = 0; i < nums.size(); i++) {\\n            if(uf->find(i) != uf->find(0)) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass UF {\\npublic:\\n    vector<int> parent;\\n    vector<int> rank;\\n\\n    UF(int n) {\\n        parent.resize(n);\\n        rank.resize(n, 0);\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }\\n    }\\n\\n    int find(int x) {\\n        if (parent[x] != x) {\\n            parent[x] = find(parent[x]);  // Path compression\\n        }\\n        return parent[x];\\n    }\\n\\n    void join(int x, int y) {\\n        int rootX = find(x);\\n        int rootY = find(y);\\n\\n        if (rootX != rootY) {\\n            if (rank[rootX] < rank[rootY]) {\\n                parent[rootX] = rootY;\\n            } else if (rank[rootX] > rank[rootY]) {\\n                parent[rootY] = rootX;\\n            } else {\\n                parent[rootX] = rootY;\\n                rank[rootY]++;\\n            }\\n        }\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    \\n    vector<int> factors(int num) {\\n        vector<int> ans;\\n        for(int j = 2; j * j <= num; j++) {\\n            while(num % j == 0) {\\n                num /= j;\\n                ans.push_back(j);\\n            }\\n        }\\n        if(num != 1) ans.push_back(num);\\n        return ans;\\n    }\\n    \\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        \\n        int n  = nums.size();\\n        UF *uf = new UF(n);\\n        unordered_map<int, int> mp;\\n\\n        for(int i = 0; i < nums.size(); i++) {\\n            int num = nums[i];\\n            vector<int> fact = factors(num);\\n            for (int x : fact) {\\n                if(mp.count(x)) {\\n                    uf->join(i, mp[x]);\\n                } else {\\n                    mp[x] = i;\\n                }\\n            }\\n        }\\n \\n        for(int i = 0; i < nums.size(); i++) {\\n            if(uf->find(i) != uf->find(0)) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572518,
                "title": "prime-factors-maps-common-factor-frequency",
                "content": "idea: is it possible to reach a prime no?\\nyess only if their is atleast a one no which have a factor of this prime no so intution is to for every no we can compute it\\'s prime factor and for atleast one of the factor should be common with other no so can we can reach to that number , \\nNote : here we have to remove repitation bcz repitation can cause wrong solution (explaination: 2,4,13,13  here 13 can be reached by another 13 but 13 can\\'t be reached by any other number  so the thing is if we can reach any one 13 from some where can can also reach to other 13  from the same number so we can remove repitations)\\n\\nsol:  step one make a map for each number in array after removing repitations :  \\nmap<int, set<int>> s  {  this is how we will store factors : s[a[i]]={ set of prime factors}    }\\n\\nand then make a another map    : map<int, int> m  { m[prime factor]= count in whole array }\\n\\nafter this we can simply treverse through each element and check do we have atleast one factor which have count more than one if yes go for next element else return false , at the end of treversal if all is well return true.\\n\\ncomplexcity: n log n ( solve function\\'s will take atmax logn  time)\\nspacecomplexcity : n \\n\\n````\\nclass Solution {\\npublic:\\n    \\n    unordered_map<int,int> m;\\n    map<int,set<int>> s;\\n    int g=0;\\n    void solve(int n) // calculating prime factors\\n    {\\n       \\n        if(s.find(n)!=s.end()) return ;\\n        m[n]++;\\n        int k=n;\\n        set<int> st;\\n        st.insert(n);\\n        for(int i=2; i*i<=k; i++)\\n        {\\n            if(k%i==0)\\n            {\\n                m[i]++;\\n                st.insert(i);\\n                while(k%i==0 && k>0)\\n                {\\n                    k=k/i;\\n                }\\n            }\\n        }\\n        \\n        if(k>1 && k!=n)\\n        {\\n            st.insert(k);\\n            m[k]++;\\n        }\\n        s[n]=st;\\n        \\n        // if(m[13]==2 && g==0){ g=1;cout<<endl<<n<<endl<<endl;}\\n    }\\n    bool canTraverseAllPairs(vector<int>& nums) \\n    {\\n        if(nums.size()==1) return true;\\n        unordered_set<int> s1;\\n        for(auto i: nums) s1.insert(i);\\n        \\n        vector<int> a1;\\n        for(auto i: s1) a1.push_back(i);\\n        nums.clear(); nums=a1;\\n        if(nums.size()==1 && nums[0]>1) return true;\\n        else if(nums.size()==1) return false;\\n        for(auto i: nums)\\n        {\\n            solve(i);\\n        }\\n\\t\\t\\n// printing factors\\n//         for(auto i: s)\\n//         {\\n//             cout<<i.first<<\" : \";\\n//             for(auto j: i.second) cout<<j<<\" \";cout<<endl;\\n//         }\\n//         cout<<endl;\\n        \\n//         for(auto i: m)\\n//         {\\n//             cout<<i.first<<\"  \"<<i.second<<endl;\\n//         }\\n\\n\\n        for(auto i: s)\\n        {\\n            int f=0;\\n            for(auto j: i.second)\\n            {\\n                if(m[j]>1) f=1;\\n                \\n            }\\n            if(f==0) return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    \\n    unordered_map<int,int> m;\\n    map<int,set<int>> s;\\n    int g=0;\\n    void solve(int n) // calculating prime factors\\n    {\\n       \\n        if(s.find(n)!=s.end()) return ;\\n        m[n]++;\\n        int k=n;\\n        set<int> st;\\n        st.insert(n);\\n        for(int i=2; i*i<=k; i++)\\n        {\\n            if(k%i==0)\\n            {\\n                m[i]++;\\n                st.insert(i);\\n                while(k%i==0 && k>0)\\n                {\\n                    k=k/i;\\n                }\\n            }\\n        }\\n        \\n        if(k>1 && k!=n)\\n        {\\n            st.insert(k);\\n            m[k]++;\\n        }\\n        s[n]=st;\\n        \\n        // if(m[13]==2 && g==0){ g=1;cout<<endl<<n<<endl<<endl;}\\n    }\\n    bool canTraverseAllPairs(vector<int>& nums) \\n    {\\n        if(nums.size()==1) return true;\\n        unordered_set<int> s1;\\n        for(auto i: nums) s1.insert(i);\\n        \\n        vector<int> a1;\\n        for(auto i: s1) a1.push_back(i);\\n        nums.clear(); nums=a1;\\n        if(nums.size()==1 && nums[0]>1) return true;\\n        else if(nums.size()==1) return false;\\n        for(auto i: nums)\\n        {\\n            solve(i);\\n        }\\n\\t\\t\\n// printing factors\\n//         for(auto i: s)\\n//         {\\n//             cout<<i.first<<\" : \";\\n//             for(auto j: i.second) cout<<j<<\" \";cout<<endl;\\n//         }\\n//         cout<<endl;\\n        \\n//         for(auto i: m)\\n//         {\\n//             cout<<i.first<<\"  \"<<i.second<<endl;\\n//         }\\n\\n\\n        for(auto i: s)\\n        {\\n            int f=0;\\n            for(auto j: i.second)\\n            {\\n                if(m[j]>1) f=1;\\n                \\n            }\\n            if(f==0) return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3569916,
                "title": "easy-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canTraverseAllPairs = function(nums) {\\n  if (nums.length === 1) return true;\\n  if (nums.includes(1)) return false;\\n  const mx = Math.max(...nums) + 1;\\n  const sieve = Array.from({ length: mx }, (_, i) => i);\\n\\n  for (let i = 4; i < mx; i += 2) {\\n    sieve[i] = 2;\\n  }\\n\\n  for (let i = 3; i < Math.ceil(Math.sqrt(mx)); i++) {\\n    if (sieve[i] !== i) continue;\\n    for (let j = i * i; j < mx; j += i) {\\n      if (sieve[j] === j) {\\n        sieve[j] = i;\\n      }\\n    }\\n  }\\n\\n  function* factorize(num) {\\n    while (num !== 1) {\\n      yield sieve[num];\\n      num = Math.floor(num / sieve[num]);\\n    }\\n  }\\n\\n  const g = new Map();\\n  const seen = new Set();\\n\\n  for (const num of new Set(nums)) {\\n    for (const p of factorize(num)) {\\n      if (!g.has(num)) g.set(num, new Set());\\n      if (!g.has(p)) g.set(p, new Set());\\n      g.get(num).add(p);\\n      g.get(p).add(num);\\n    }\\n  }\\n\\n  const dq = [nums[0]];\\n  seen.add(nums[0]);\\n\\n  while (dq.length) {\\n    const num = dq.shift();\\n    for (const nxt of g.get(num)) {\\n      if (seen.has(nxt)) continue;\\n      seen.add(nxt);\\n      dq.push(nxt);\\n    }\\n  }\\n\\n  return seen.size === g.size;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canTraverseAllPairs = function(nums) {\\n  if (nums.length === 1) return true;\\n  if (nums.includes(1)) return false;\\n  const mx = Math.max(...nums) + 1;\\n  const sieve = Array.from({ length: mx }, (_, i) => i);\\n\\n  for (let i = 4; i < mx; i += 2) {\\n    sieve[i] = 2;\\n  }\\n\\n  for (let i = 3; i < Math.ceil(Math.sqrt(mx)); i++) {\\n    if (sieve[i] !== i) continue;\\n    for (let j = i * i; j < mx; j += i) {\\n      if (sieve[j] === j) {\\n        sieve[j] = i;\\n      }\\n    }\\n  }\\n\\n  function* factorize(num) {\\n    while (num !== 1) {\\n      yield sieve[num];\\n      num = Math.floor(num / sieve[num]);\\n    }\\n  }\\n\\n  const g = new Map();\\n  const seen = new Set();\\n\\n  for (const num of new Set(nums)) {\\n    for (const p of factorize(num)) {\\n      if (!g.has(num)) g.set(num, new Set());\\n      if (!g.has(p)) g.set(p, new Set());\\n      g.get(num).add(p);\\n      g.get(p).add(num);\\n    }\\n  }\\n\\n  const dq = [nums[0]];\\n  seen.add(nums[0]);\\n\\n  while (dq.length) {\\n    const num = dq.shift();\\n    for (const nxt of g.get(num)) {\\n      if (seen.has(nxt)) continue;\\n      seen.add(nxt);\\n      dq.push(nxt);\\n    }\\n  }\\n\\n  return seen.size === g.size;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3568834,
                "title": "c-solutions-explained-line-by-line-easy-to-understand-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe \"Intuition\" section provides a brief overview of the general idea behind solving the problem. It describes any initial thoughts or insights you might have when approaching the problem.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe \"Approach\" section outlines the specific strategy or algorithm you plan to use to solve the problem. It explains the step-by-step process or logic you will follow to arrive at the solution.\\n\\n\\n# Complexity\\nThe \"Complexity\" section discusses the time and space complexity of the chosen approach. It provides an analysis of how the algorithm performs in terms of efficiency and resource usage.\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThis describes how the runtime of the algorithm scales with the input size. It is often denoted using big O notation (e.g., O(n), O(n^2), etc.). It helps assess the efficiency of the algorithm and how it handles larger inputs.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThis refers to the amount of memory or space required by the algorithm to solve the problem. It is also expressed using big O notation (e.g., O(n), O(1), etc.). It helps evaluate the memory usage of the algorithm and how it scales with input size.\\n\\n# Code\\n```\\nconstexpr int maxn = 100000;\\nvector<int> pd[maxn + 1];\\n\\nclass Solution {\\npublic:\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        // Calculate prime divisors for numbers from 2 to maxn if not already calculated\\n        if (pd[2].empty()) {\\n            for (int i = 2; i <= maxn; i += 1) {\\n                if (pd[i].empty()) {\\n                    // Calculate prime divisors for multiples of i\\n                    for (int j = i; j <= maxn; j += i) {\\n                        pd[j].push_back(i);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // Map to store the indices of elements with the same prime divisors\\n        map<int, vector<int>> indexMap;\\n        int n = nums.size();\\n        vector<vector<int>> graph(n);\\n        \\n        // Build the index map and adjacency list\\n        for (int i = 0; i < n; i += 1) {\\n            for (int primeDivisor : pd[nums[i]]) {\\n                indexMap[primeDivisor].push_back(i);\\n            }\\n        }\\n        \\n        // Construct the graph using the index map\\n        for (auto& [primeDivisor, indices] : indexMap) {\\n            for (int i = 1; i < indices.size(); i += 1) {\\n                graph[indices[0]].push_back(indices[i]);\\n                graph[indices[i]].push_back(indices[0]);\\n            }\\n        }\\n        \\n        vector<int> visited(n);\\n        int m = 0; // Number of visited nodes\\n        \\n        // Depth-first search to count the number of visited nodes\\n        function<void(int)> dfs = [&](int u) {\\n            if (visited[u]) {\\n                return;\\n            }\\n            m += visited[u] = 1;\\n            for (int v : graph[u]) {\\n                dfs(v);\\n            }\\n        };\\n        \\n        dfs(0); // Start DFS from node 0\\n        \\n        return n == m; // Check if all nodes are visited\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nconstexpr int maxn = 100000;\\nvector<int> pd[maxn + 1];\\n\\nclass Solution {\\npublic:\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        // Calculate prime divisors for numbers from 2 to maxn if not already calculated\\n        if (pd[2].empty()) {\\n            for (int i = 2; i <= maxn; i += 1) {\\n                if (pd[i].empty()) {\\n                    // Calculate prime divisors for multiples of i\\n                    for (int j = i; j <= maxn; j += i) {\\n                        pd[j].push_back(i);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // Map to store the indices of elements with the same prime divisors\\n        map<int, vector<int>> indexMap;\\n        int n = nums.size();\\n        vector<vector<int>> graph(n);\\n        \\n        // Build the index map and adjacency list\\n        for (int i = 0; i < n; i += 1) {\\n            for (int primeDivisor : pd[nums[i]]) {\\n                indexMap[primeDivisor].push_back(i);\\n            }\\n        }\\n        \\n        // Construct the graph using the index map\\n        for (auto& [primeDivisor, indices] : indexMap) {\\n            for (int i = 1; i < indices.size(); i += 1) {\\n                graph[indices[0]].push_back(indices[i]);\\n                graph[indices[i]].push_back(indices[0]);\\n            }\\n        }\\n        \\n        vector<int> visited(n);\\n        int m = 0; // Number of visited nodes\\n        \\n        // Depth-first search to count the number of visited nodes\\n        function<void(int)> dfs = [&](int u) {\\n            if (visited[u]) {\\n                return;\\n            }\\n            m += visited[u] = 1;\\n            for (int v : graph[u]) {\\n                dfs(v);\\n            }\\n        };\\n        \\n        dfs(0); // Start DFS from node 0\\n        \\n        return n == m; // Check if all nodes are visited\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568755,
                "title": "disjoint-set-union-find-easy-begineer-s-approach",
                "content": "```\\n//Striver\\'s DisjointSet Template\\nclass DisjointSet\\n{\\npublic:\\n    vector<long long> parent,rank,size;\\n    DisjointSet(int n)\\n    {\\n        rank.resize(n + 1, 0);\\n        parent.resize(n + 1);\\n        size.resize(n + 1);\\n        for (int i = 0; i <= n; i++)\\n        {\\n            parent[i] = i;\\n            size[i]=i;\\n        }\\n    }\\n    int findUParent(int node)\\n    {\\n        if (node == parent[node])\\n        {\\n            return node;\\n        }\\n        return parent[node] = findUParent(parent[node]);\\n    }\\n    void UnionBySize(int u, int v) {\\n        int ulp_u = findUParent(u);\\n        int ulp_v = findUParent(v);\\n        if (ulp_u == ulp_v) return;\\n        if (size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n    }\\n    void UnionByRank(int u, int v)\\n    {\\n        int ulp_u = parent[u];\\n        int ulp_v = parent[v];\\n        ;\\n        if (ulp_u == ulp_v)\\n        {\\n            return;\\n        }\\n        if (rank[ulp_u] < rank[ulp_v])\\n        {\\n            parent[ulp_u] = ulp_v;\\n        }\\n        else if (rank[ulp_v] < rank[ulp_u])\\n        {\\n            rank[ulp_v] = ulp_u;\\n        }\\n        else\\n        {\\n            parent[ulp_u] = ulp_v;\\n            rank[ulp_v]++;\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n    int n = nums.size();\\n    DisjointSet uf(n);\\n\\n    unordered_map<int, vector<int>> factors;\\n\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 2; j * j <= nums[i]; j++) {\\n            if (nums[i] % j == 0) {\\n                factors[j].push_back(i);\\n                while (nums[i] % j == 0) {\\n                    nums[i] /= j;\\n                }\\n            }\\n        }\\n        if (nums[i] > 1) {\\n            factors[nums[i]].push_back(i);\\n        }\\n    }\\n\\n    for (auto& factorPair : factors) {\\n        vector<int>& indices = factorPair.second;\\n        for (int i = 1; i < indices.size(); i++) {\\n            uf.UnionBySize(indices[i - 1], indices[i]);\\n        }\\n    }\\n\\n    int root = uf.findUParent(0);\\n    for (int i = 1; i < n; i++) {\\n        if (uf.findUParent(i) != root) {\\n            return false;\\n        }\\n    }\\n\\n    return true;\\n}\\n   \\n};\\n```",
                "solutionTags": [
                    "Graph"
                ],
                "code": "```\\n//Striver\\'s DisjointSet Template\\nclass DisjointSet\\n{\\npublic:\\n    vector<long long> parent,rank,size;\\n    DisjointSet(int n)\\n    {\\n        rank.resize(n + 1, 0);\\n        parent.resize(n + 1);\\n        size.resize(n + 1);\\n        for (int i = 0; i <= n; i++)\\n        {\\n            parent[i] = i;\\n            size[i]=i;\\n        }\\n    }\\n    int findUParent(int node)\\n    {\\n        if (node == parent[node])\\n        {\\n            return node;\\n        }\\n        return parent[node] = findUParent(parent[node]);\\n    }\\n    void UnionBySize(int u, int v) {\\n        int ulp_u = findUParent(u);\\n        int ulp_v = findUParent(v);\\n        if (ulp_u == ulp_v) return;\\n        if (size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n    }\\n    void UnionByRank(int u, int v)\\n    {\\n        int ulp_u = parent[u];\\n        int ulp_v = parent[v];\\n        ;\\n        if (ulp_u == ulp_v)\\n        {\\n            return;\\n        }\\n        if (rank[ulp_u] < rank[ulp_v])\\n        {\\n            parent[ulp_u] = ulp_v;\\n        }\\n        else if (rank[ulp_v] < rank[ulp_u])\\n        {\\n            rank[ulp_v] = ulp_u;\\n        }\\n        else\\n        {\\n            parent[ulp_u] = ulp_v;\\n            rank[ulp_v]++;\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n    int n = nums.size();\\n    DisjointSet uf(n);\\n\\n    unordered_map<int, vector<int>> factors;\\n\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 2; j * j <= nums[i]; j++) {\\n            if (nums[i] % j == 0) {\\n                factors[j].push_back(i);\\n                while (nums[i] % j == 0) {\\n                    nums[i] /= j;\\n                }\\n            }\\n        }\\n        if (nums[i] > 1) {\\n            factors[nums[i]].push_back(i);\\n        }\\n    }\\n\\n    for (auto& factorPair : factors) {\\n        vector<int>& indices = factorPair.second;\\n        for (int i = 1; i < indices.size(); i++) {\\n            uf.UnionBySize(indices[i - 1], indices[i]);\\n        }\\n    }\\n\\n    int root = uf.findUParent(0);\\n    for (int i = 1; i < n; i++) {\\n        if (uf.findUParent(i) != root) {\\n            return false;\\n        }\\n    }\\n\\n    return true;\\n}\\n   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568543,
                "title": "c-union-find-and-sieve",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n     class UnionFind{\\n        int numComponents;\\n        vector<int> rank;\\n        vector<int> parent;\\n        public:\\n        UnionFind(int n){\\n            numComponents = n;\\n            rank = vector<int>(n, 0);\\n            parent = vector<int>(n);\\n            for(int i = 0; i<n; i++) parent[i] = i;\\n        }\\n        \\n        int components(){return numComponents;}\\n        \\n        int find(int p){\\n            while(p != parent[p]){\\n                parent[p] = parent[parent[p]];\\n                p = parent[p];\\n            }\\n            return p;\\n        }\\n        \\n        void unionn(int p, int q){\\n            int rootp = find(p); int rootq = find(q);\\n            if(rootp == rootq) return;\\n            if(rank[rootp] < rank[rootq]) parent[rootp] = rootq;\\n            else{\\n                parent[rootq] = rootp;\\n                if(rank[rootp] == rank[rootq]){rank[rootp]++;}\\n            }\\n            numComponents--;\\n        } \\n    };\\n    \\nint spf[100005];\\n    \\nvoid sieve()\\n{\\n    spf[1] = 1;\\n    for (int i = 2; i <= 100000; i++)\\n        spf[i] = i;\\n    for (int i = 4; i <=100000; i += 2)\\n        spf[i] = 2;\\n \\n    for (int i = 3; i * i <= 100000; i++) {\\n        if (spf[i] == i) {\\n            for (int j = i * i; j <= 100000; j += i)\\n                if (spf[j] == j)\\n                    spf[j] = i;\\n        }\\n    }\\n}\\n    \\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        if(nums.size()==1) return true;\\n        for(auto i:nums){\\n            if(i==1) return false;\\n        }\\n        sieve();\\n        map<int,vector<int>> mp;\\n        for(int i=0;i<nums.size();i++){\\n            int x=nums[i];\\n            set<int> st; \\n            while(x!=1){\\n               st.insert(spf[x]); x=x/spf[x];\\n            }\\n            for(auto num:st){\\n                mp[num].push_back(i);\\n            }\\n        }\\n        int n=nums.size();\\n        UnionFind uf(n);\\n        for(auto p:mp){\\n            auto v=p.second;\\n            if(v.size()==1) continue;\\n            int sz=v.size();\\n            int u=v[0];\\n            for(int i=1;i<sz;i++){\\n                uf.unionn(u,v[i]);\\n            }\\n        }\\n        \\n        if(uf.components()==1) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n     class UnionFind{\\n        int numComponents;\\n        vector<int> rank;\\n        vector<int> parent;\\n        public:\\n        UnionFind(int n){\\n            numComponents = n;\\n            rank = vector<int>(n, 0);\\n            parent = vector<int>(n);\\n            for(int i = 0; i<n; i++) parent[i] = i;\\n        }\\n        \\n        int components(){return numComponents;}\\n        \\n        int find(int p){\\n            while(p != parent[p]){\\n                parent[p] = parent[parent[p]];\\n                p = parent[p];\\n            }\\n            return p;\\n        }\\n        \\n        void unionn(int p, int q){\\n            int rootp = find(p); int rootq = find(q);\\n            if(rootp == rootq) return;\\n            if(rank[rootp] < rank[rootq]) parent[rootp] = rootq;\\n            else{\\n                parent[rootq] = rootp;\\n                if(rank[rootp] == rank[rootq]){rank[rootp]++;}\\n            }\\n            numComponents--;\\n        } \\n    };\\n    \\nint spf[100005];\\n    \\nvoid sieve()\\n{\\n    spf[1] = 1;\\n    for (int i = 2; i <= 100000; i++)\\n        spf[i] = i;\\n    for (int i = 4; i <=100000; i += 2)\\n        spf[i] = 2;\\n \\n    for (int i = 3; i * i <= 100000; i++) {\\n        if (spf[i] == i) {\\n            for (int j = i * i; j <= 100000; j += i)\\n                if (spf[j] == j)\\n                    spf[j] = i;\\n        }\\n    }\\n}\\n    \\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        if(nums.size()==1) return true;\\n        for(auto i:nums){\\n            if(i==1) return false;\\n        }\\n        sieve();\\n        map<int,vector<int>> mp;\\n        for(int i=0;i<nums.size();i++){\\n            int x=nums[i];\\n            set<int> st; \\n            while(x!=1){\\n               st.insert(spf[x]); x=x/spf[x];\\n            }\\n            for(auto num:st){\\n                mp[num].push_back(i);\\n            }\\n        }\\n        int n=nums.size();\\n        UnionFind uf(n);\\n        for(auto p:mp){\\n            auto v=p.second;\\n            if(v.size()==1) continue;\\n            int sz=v.size();\\n            int u=v[0];\\n            for(int i=1;i<sz;i++){\\n                uf.unionn(u,v[i]);\\n            }\\n        }\\n        \\n        if(uf.components()==1) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4101287,
                "title": "dsu-with-prime-checking-c-2-solutions",
                "content": "# Intuition\\n* Intution Behind This algorithm :\\n\\nwe are creating a graph of prime factors of each number and then we are checking if all the numbers are connected or not.\\nDSU is used to check if all the numbers are connected or not.\\n\\nis to determine if for every pair of indices i and j in nums, where i < j, there exists a sequence of traversals that can take us from i to j.\\n\\nex : 2 3 4 5 6 7 8 9 10\\ngraph :\\n2 -> 2\\n3 -> 3\\n4 -> 2 2\\n5 -> 5\\n6 -> 2 3\\n7 -> 7\\n8 -> 2 2 2\\n9 -> 3 3\\n10 -> 2 5\\n\\nwe can see that 2,3,5,7 are not connected to any other number so we can\\'t traverse all the pairs.\\n\\nhence we will use DSU to check if all the numbers are connected or not.\\n\\nLeetcode Example :\\nInput: nums = [2,3,6]\\n\\ngraph :\\n2 -> 2\\n3 -> 3\\n6 -> 2 3\\n\\nwe can see that 2 and 3 are connected so we can traverse all the pairs.\\n\\nwe will return true in this case.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n O(sqrt(n) * log(n)) [ I am not sure ]\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\n\\nclass Solution {\\n    int N;\\n    vector<int> pf;\\n    vector<int> parent;\\n    vector<int> rank;\\n    \\n    void build() {\\n        for(long i = 2; i <= N; i++) {\\n            if(pf[i]) continue;\\n            pf[i] = i;\\n            for(long j = i*i; j <= N; j += i) {\\n                if(pf[j] == 0)\\n                    pf[j] = i;\\n            }\\n        }\\n    }\\n    \\n    int find(int a) {\\n        if(parent[a] == a) {\\n            return a;\\n        }\\n        return parent[a] = find(parent[a]);\\n    }\\n    \\n    void unite(int a, int b) {\\n        int rootA = find(a);\\n        int rootB = find(b);\\n        if(rootA == rootB) {\\n            return;\\n        }\\n        if(rank[rootA] < rank[rootB]) {\\n            parent[rootA] = rootB;\\n        } else {\\n            if(rank[rootA] == rank[rootB]) {\\n                rank[rootA]++;\\n            }\\n            parent[rootB] = rootA;\\n        }\\n    }\\npublic:\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        if(nums.size() == 1) {\\n            return true;\\n        }\\n        N = *max_element(nums.begin(), nums.end());\\n        pf.resize(N + 1);\\n        build();\\n        for(int i = 0; i <= N; i++) {\\n            rank.push_back(1);\\n            parent.push_back(i);\\n        }\\n        for(int num : nums) {\\n            if(num == 1) {\\n                return false;\\n            }\\n            int temp = num;\\n            while(num > 1) {\\n                int p = pf[num];\\n                while(num % p == 0) {\\n                    num /= p;\\n                }\\n                unite(temp, p);\\n            }\\n        }\\n        unordered_set<int> s;\\n        for(int num : nums) {\\n            s.insert(find(num));\\n            if(s.size() > 1) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n\\n# Easier Intutive Solution [a bit more runtime ]\\n```C++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\n\\nclass DSU{\\n    public:\\n    vector<int>rank,parent,size;\\n    DSU(int n){\\n        rank.resize(n+1);\\n        parent.resize(n+1);\\n        size.resize(n+1);\\n        for(int i=0;i<n;i++){\\n            parent[i] = i;\\n            size[i] =i;\\n        }\\n    }\\n    int findUpar(int x){\\n        if (x == parent[x]){\\n            return x;\\n        }\\n        return parent[x] = findUpar(parent[x]);\\n    }\\n\\n    bool UnionByRank(int u ,int v){\\n        int ulp_u = findUpar(u);\\n        int ulp_v = findUpar(v);\\n\\n        if(ulp_u == ulp_v) return 0;\\n        if(rank[ulp_u] < rank[ulp_v]){\\n            parent[ulp_u] = ulp_v;\\n        }\\n        else if(rank[ulp_v] < rank[ulp_u]){\\n            parent[ulp_v] = ulp_u;\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            rank[ulp_u]+=1;\\n        }\\n        return 1;\\n    }\\n\\n    int components(){\\n        int cnt =0;\\n        for(int i=0;i<parent.size();i++){\\n            if(i == parent[i]) cnt+=1;\\n        }\\n        return cnt;\\n    }\\n};\\n\\nclass Solution\\n{\\npublic:\\n    bool canTraverseAllPairs(vector<int> &nums)\\n    {\\n        int n = nums.size();\\n        DSU ds(n);\\n\\n        unordered_map<int,vector<int>>adj;\\n        for(int i=0;i<n;i++){\\n            int curr = nums[i];\\n\\n            if((curr & 1) == 0) adj[2].push_back(i); // 2s factor\\n            while((curr & 1) == 0) curr =curr/2;\\n\\n            for(int j=3;j*j<=curr;j+=2){ // odd factors basically primes j=3 because 2s are already done J+=i because we are only considering odd factors\\n                if((curr & j) == 0) adj[curr].push_back(j);\\n                while((curr & j) == 0) curr /= j;\\n            }\\n\\n            if(curr > 2) adj[curr].push_back(i); // if curr is prime\\n        }\\n\\n        for(auto it:adj){\\n            int x = it.first;\\n            for(int i=1;i<it.second.size();i++){\\n                ds.UnionByRank(it.second[i-1],it.second[i]);\\n            }\\n        }\\n        return ds.components() == 1;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\n\\nclass Solution {\\n    int N;\\n    vector<int> pf;\\n    vector<int> parent;\\n    vector<int> rank;\\n    \\n    void build() {\\n        for(long i = 2; i <= N; i++) {\\n            if(pf[i]) continue;\\n            pf[i] = i;\\n            for(long j = i*i; j <= N; j += i) {\\n                if(pf[j] == 0)\\n                    pf[j] = i;\\n            }\\n        }\\n    }\\n    \\n    int find(int a) {\\n        if(parent[a] == a) {\\n            return a;\\n        }\\n        return parent[a] = find(parent[a]);\\n    }\\n    \\n    void unite(int a, int b) {\\n        int rootA = find(a);\\n        int rootB = find(b);\\n        if(rootA == rootB) {\\n            return;\\n        }\\n        if(rank[rootA] < rank[rootB]) {\\n            parent[rootA] = rootB;\\n        } else {\\n            if(rank[rootA] == rank[rootB]) {\\n                rank[rootA]++;\\n            }\\n            parent[rootB] = rootA;\\n        }\\n    }\\npublic:\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        if(nums.size() == 1) {\\n            return true;\\n        }\\n        N = *max_element(nums.begin(), nums.end());\\n        pf.resize(N + 1);\\n        build();\\n        for(int i = 0; i <= N; i++) {\\n            rank.push_back(1);\\n            parent.push_back(i);\\n        }\\n        for(int num : nums) {\\n            if(num == 1) {\\n                return false;\\n            }\\n            int temp = num;\\n            while(num > 1) {\\n                int p = pf[num];\\n                while(num % p == 0) {\\n                    num /= p;\\n                }\\n                unite(temp, p);\\n            }\\n        }\\n        unordered_set<int> s;\\n        for(int num : nums) {\\n            s.insert(find(num));\\n            if(s.size() > 1) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\n```C++\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\n\\nclass DSU{\\n    public:\\n    vector<int>rank,parent,size;\\n    DSU(int n){\\n        rank.resize(n+1);\\n        parent.resize(n+1);\\n        size.resize(n+1);\\n        for(int i=0;i<n;i++){\\n            parent[i] = i;\\n            size[i] =i;\\n        }\\n    }\\n    int findUpar(int x){\\n        if (x == parent[x]){\\n            return x;\\n        }\\n        return parent[x] = findUpar(parent[x]);\\n    }\\n\\n    bool UnionByRank(int u ,int v){\\n        int ulp_u = findUpar(u);\\n        int ulp_v = findUpar(v);\\n\\n        if(ulp_u == ulp_v) return 0;\\n        if(rank[ulp_u] < rank[ulp_v]){\\n            parent[ulp_u] = ulp_v;\\n        }\\n        else if(rank[ulp_v] < rank[ulp_u]){\\n            parent[ulp_v] = ulp_u;\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            rank[ulp_u]+=1;\\n        }\\n        return 1;\\n    }\\n\\n    int components(){\\n        int cnt =0;\\n        for(int i=0;i<parent.size();i++){\\n            if(i == parent[i]) cnt+=1;\\n        }\\n        return cnt;\\n    }\\n};\\n\\nclass Solution\\n{\\npublic:\\n    bool canTraverseAllPairs(vector<int> &nums)\\n    {\\n        int n = nums.size();\\n        DSU ds(n);\\n\\n        unordered_map<int,vector<int>>adj;\\n        for(int i=0;i<n;i++){\\n            int curr = nums[i];\\n\\n            if((curr & 1) == 0) adj[2].push_back(i); // 2s factor\\n            while((curr & 1) == 0) curr =curr/2;\\n\\n            for(int j=3;j*j<=curr;j+=2){ // odd factors basically primes j=3 because 2s are already done J+=i because we are only considering odd factors\\n                if((curr & j) == 0) adj[curr].push_back(j);\\n                while((curr & j) == 0) curr /= j;\\n            }\\n\\n            if(curr > 2) adj[curr].push_back(i); // if curr is prime\\n        }\\n\\n        for(auto it:adj){\\n            int x = it.first;\\n            for(int i=1;i<it.second.size();i++){\\n                ds.UnionByRank(it.second[i-1],it.second[i]);\\n            }\\n        }\\n        return ds.components() == 1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4006869,
                "title": "simple-code-prime-factorization-dfs-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst int N = 1e5;\\nclass Solution {\\nprivate:\\n    vector<int> seive;\\n    int connected(int node, vector<vector<int>> &graph, vector<int> &vis){\\n        int res = 1;\\n        vis[node] = 1;\\n        for(auto it : graph[node]){\\n            if(!vis[it]){\\n                res += connected(it, graph, vis);\\n            }\\n        }\\n        return res;\\n    }\\n    void buildSeive(){\\n        seive.resize(N + 1);\\n        for(int i = 2; i <= N; i++){\\n            if(seive[i] != 0) continue;\\n            seive[i] = i;\\n            for(long long k = (long long)i*i; k <= N; k += i){\\n                if(seive[k] == 0) seive[k] = i;\\n            }\\n        }\\n    }\\n\\n    vector<int> primeFactors(int x){\\n        vector<int> res;\\n        while(x != 1){\\n            int factor = seive[x];\\n            while(x % factor == 0) x /= factor;\\n            res.push_back(factor);\\n        }\\n        return res;\\n    }\\npublic:\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        unordered_map<int, vector<int>> mp;\\n        int n = nums.size();\\n        if(n == 1) return true;\\n        buildSeive();\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] == 1) return false;\\n            vector<int> primes = primeFactors(nums[i]);\\n            for(auto p : primes){\\n                mp[p].push_back(i);\\n            }\\n        }\\n        vector<vector<int>> graph(n);\\n        for(auto i : mp){\\n            vector<int> temp = i.second;\\n            for(int i = 0; i < temp.size() - 1; i++){\\n                int u = temp[i], v = temp[i + 1];\\n                graph[u].push_back(v);\\n                graph[v].push_back(u);\\n            }\\n        }\\n        vector<int> vis(n);\\n        if(connected(0, graph, vis) == n) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nconst int N = 1e5;\\nclass Solution {\\nprivate:\\n    vector<int> seive;\\n    int connected(int node, vector<vector<int>> &graph, vector<int> &vis){\\n        int res = 1;\\n        vis[node] = 1;\\n        for(auto it : graph[node]){\\n            if(!vis[it]){\\n                res += connected(it, graph, vis);\\n            }\\n        }\\n        return res;\\n    }\\n    void buildSeive(){\\n        seive.resize(N + 1);\\n        for(int i = 2; i <= N; i++){\\n            if(seive[i] != 0) continue;\\n            seive[i] = i;\\n            for(long long k = (long long)i*i; k <= N; k += i){\\n                if(seive[k] == 0) seive[k] = i;\\n            }\\n        }\\n    }\\n\\n    vector<int> primeFactors(int x){\\n        vector<int> res;\\n        while(x != 1){\\n            int factor = seive[x];\\n            while(x % factor == 0) x /= factor;\\n            res.push_back(factor);\\n        }\\n        return res;\\n    }\\npublic:\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        unordered_map<int, vector<int>> mp;\\n        int n = nums.size();\\n        if(n == 1) return true;\\n        buildSeive();\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] == 1) return false;\\n            vector<int> primes = primeFactors(nums[i]);\\n            for(auto p : primes){\\n                mp[p].push_back(i);\\n            }\\n        }\\n        vector<vector<int>> graph(n);\\n        for(auto i : mp){\\n            vector<int> temp = i.second;\\n            for(int i = 0; i < temp.size() - 1; i++){\\n                int u = temp[i], v = temp[i + 1];\\n                graph[u].push_back(v);\\n                graph[v].push_back(u);\\n            }\\n        }\\n        vector<int> vis(n);\\n        if(connected(0, graph, vis) == n) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980326,
                "title": "unraveling-the-prime-web-a-deep-dive-into-graph-connectivity",
                "content": "# Intuition\\nWhen I first encountered this problem, it felt like walking through an ancient city with hidden connections waiting to be discovered. Through my journey, I connected numbers using their prime factors, painting a vivid picture of a city\\'s layout with buildings (numbers) and secret passages (prime factors).\\nI visualized each number as a building in this city. Whenever two buildings shared a secret passage, it meant they had a common prime factor. My mission was to see if I could travel across the entire city using just these passages.\\n\\n# Approach\\nInstead of directly mapping the entire city layout, I took a more insightful path. I broke down each building (number) to discover its secret passages (prime factors). This way, I could quickly group buildings with common passages. Using the Union-Find technique, I effortlessly merged these groups, unveiling the interconnectedness of the city.\\nIn the end, if I found myself with just one group, it confirmed that the city was fully connected, a testament to the mystic power of prime factors in guiding my journey.\\n\\n# Complexity\\n- Time complexity:\\nPeeking into the performance, the time complexity stood at O(sqrt(M)\\u2217N)O(sqrt(M)\\u2217N). It\\'s a testament to the efficiency, as for each number, I only had to explore up to its square root to find its prime bridges. The space was lean too, at O(N)O(N), mainly to keep track of our connections.\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def canTraverseAllPairs(self, nums):\\n        n = len(nums)\\n        if n == 1:\\n            return True\\n        \\n        f = [_ for _ in range(0, n)]\\n        num = [1] * n\\n\\n        def getf(x):\\n            if f[x] != x:\\n                f[x] = getf(f[x])  # Path compression\\n            return f[x]\\n        \\n        def merge(x, y):\\n            x, y = getf(x), getf(y)\\n            if x == y:\\n                return\\n            if num[x] < num[y]:\\n                x, y = y, x\\n            f[y] = x\\n            num[x] += num[y]\\n\\n        have = {}\\n\\n        for i in range(0, n):\\n            x = nums[i]\\n            if x == 1:\\n                return False\\n            d = 2\\n            while d * d <= x:\\n                if x % d == 0:\\n                    if d in have:\\n                        merge(i, have[d])\\n                    else:\\n                        have[d] = i\\n                    while x % d == 0:\\n                        x //= d\\n                d += 1\\n            if x > 1:\\n                if x in have:\\n                    merge(i, have[x])\\n                else:\\n                    have[x] = i\\n\\n        return num[getf(0)] == n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Math",
                    "Union Find",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution:\\n    def canTraverseAllPairs(self, nums):\\n        n = len(nums)\\n        if n == 1:\\n            return True\\n        \\n        f = [_ for _ in range(0, n)]\\n        num = [1] * n\\n\\n        def getf(x):\\n            if f[x] != x:\\n                f[x] = getf(f[x])  # Path compression\\n            return f[x]\\n        \\n        def merge(x, y):\\n            x, y = getf(x), getf(y)\\n            if x == y:\\n                return\\n            if num[x] < num[y]:\\n                x, y = y, x\\n            f[y] = x\\n            num[x] += num[y]\\n\\n        have = {}\\n\\n        for i in range(0, n):\\n            x = nums[i]\\n            if x == 1:\\n                return False\\n            d = 2\\n            while d * d <= x:\\n                if x % d == 0:\\n                    if d in have:\\n                        merge(i, have[d])\\n                    else:\\n                        have[d] = i\\n                    while x % d == 0:\\n                        x //= d\\n                d += 1\\n            if x > 1:\\n                if x in have:\\n                    merge(i, have[x])\\n                else:\\n                    have[x] = i\\n\\n        return num[getf(0)] == n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969146,
                "title": "key-idea-explained-python",
                "content": "# Approach\\nConsider each element as a node in a graph\\nYou can travel to other nodes if and only if you share a common factor\\n\\nAlgorithm used for finding primes: **sieve of eratosthenes**\\n\\nOne way of connecting the elements would be by finding all the prime factors, and creating a connection b.w the prime, and the elements that are its multiples\\n\\nThe best data structure for this is UnionFind because we can achieve path compression\\nPath compression reduces the depth of the graph/tree to 1\\n\\n**Time ~ O(n log n)**, where n is the max(nums), look up **sieve of eratosthenes**\\n**Space: O(n)**, n is max(nums)\\n```\\ndef canTraverseAllPairs(self, nums: List[int]) -> bool:\\n    if [1] == nums: return True\\n\\n    nums = set(nums)\\n    if 1 in nums: return False\\n    \\n    # find primes\\n    mx = max(nums)\\n    primes = set(range(2, mx + 1))\\n    for p in primes.copy():\\n        if p not in primes:\\n            continue\\n        \\n        multiple = p\\n        for _ in range(2, mx//p + 1):\\n            multiple += p\\n            primes.discard(multiple)\\n\\n    # Union Find\\n    parents = dict([(p, p) for p in primes])\\n    def find(x):\\n        if x not in parents:\\n            parents[x] = x\\n        if x != parents[x]:\\n            parents[x] = find(parents[x])\\n        return parents[x]\\n    \\n    def union(x, y):\\n        parents[find(y)] = find(x)\\n\\n    # try to make connection b.w the elements in nums\\n    for p in primes:\\n        multiple = p\\n        for _ in range(2, mx//p + 1):\\n            multiple += p\\n            if multiple in nums:\\n                union(p, multiple)\\n    \\n    # final compression\\n    for n in nums: find(n)\\n    \\n    return all([parents[i] == parents[n] for i in nums])\\n```",
                "solutionTags": [
                    "Python",
                    "Union Find",
                    "Number Theory"
                ],
                "code": "```\\ndef canTraverseAllPairs(self, nums: List[int]) -> bool:\\n    if [1] == nums: return True\\n\\n    nums = set(nums)\\n    if 1 in nums: return False\\n    \\n    # find primes\\n    mx = max(nums)\\n    primes = set(range(2, mx + 1))\\n    for p in primes.copy():\\n        if p not in primes:\\n            continue\\n        \\n        multiple = p\\n        for _ in range(2, mx//p + 1):\\n            multiple += p\\n            primes.discard(multiple)\\n\\n    # Union Find\\n    parents = dict([(p, p) for p in primes])\\n    def find(x):\\n        if x not in parents:\\n            parents[x] = x\\n        if x != parents[x]:\\n            parents[x] = find(parents[x])\\n        return parents[x]\\n    \\n    def union(x, y):\\n        parents[find(y)] = find(x)\\n\\n    # try to make connection b.w the elements in nums\\n    for p in primes:\\n        multiple = p\\n        for _ in range(2, mx//p + 1):\\n            multiple += p\\n            if multiple in nums:\\n                union(p, multiple)\\n    \\n    # final compression\\n    for n in nums: find(n)\\n    \\n    return all([parents[i] == parents[n] for i in nums])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3937339,
                "title": "union-find-easily-understandable-intuition",
                "content": "# Intuition\\nlet a1 , a2 , a3 ,.....,an each are disjoint sets initially if gcd(ai , aj)>1 then  i will make union(ai,aj) like that if all the numbers form a single disjoint set then we can traverse from any index to any other index \\n\\n# Approach\\nFirst remove all the duplicates from the given vector and form a new vector . and for all pairs find gcd and if gcd(ai,aj)>1 then do union(ai,aj)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int gcd(int a, int b) {\\n        while (b != 0) {\\n            int temp = b;\\n            b = a % b;\\n            a = temp;\\n        }\\n        return a;\\n    }\\n\\n    int find(int a , vector <int>& parent){\\n        if(a != parent[a]) {\\n            parent[a] = find(parent[a] , parent);\\n        }\\n        return parent[a];\\n    }\\n\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int maxi = 1;\\n        int n = nums.size();\\n        int count = 0;\\n        unordered_map<int,int> umap;\\n        umap.reserve(n);\\n        vector <int> parent;\\n        vector <int> newnums;\\n        parent.reserve(n);\\n        newnums.reserve(n);\\n        for(int i=0;i<n;i++){\\n            if(umap.find(nums[i]) == umap.end()){\\n                umap[nums[i]]=count;\\n                parent[count]=count;\\n                count++;\\n                newnums.push_back(nums[i]);\\n            }\\n            else if(nums[i] == 1)return false;\\n        }\\n        nums = newnums;\\n        n = count;\\n        if(n==1)return true;\\n        vector <int> rank(n,0);\\n        vector <int> size(n,1);\\n\\n        for(int i=0;i<n;i++){\\n            for(int j =i+1;j<n;j++){\\n                if(gcd(nums[i] , nums[j])>1){\\n                    int roota = find(i , parent);\\n                    int rootb = find(j , parent);\\n                    if(roota != rootb){\\n                        if(rank[roota] > rank[rootb]){\\n                            parent[rootb] = roota;\\n                            size[roota] += size[rootb];\\n                            size[rootb] = 0;\\n                            maxi = max(maxi,size[roota]);\\n                        }\\n                        else{\\n                            parent[roota] = rootb;\\n                            if(rank[roota] == rank[rootb])rank[roota]++;\\n                            size[rootb]+=size[roota];\\n                            size[roota] = 0;\\n                            maxi = max(maxi ,size[rootb]);\\n                        }\\n                    }\\n                }\\n            }\\n            if(size[find(i, parent)] == 1)return false;\\n        }\\n    if(maxi == n)return true;\\n    return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int gcd(int a, int b) {\\n        while (b != 0) {\\n            int temp = b;\\n            b = a % b;\\n            a = temp;\\n        }\\n        return a;\\n    }\\n\\n    int find(int a , vector <int>& parent){\\n        if(a != parent[a]) {\\n            parent[a] = find(parent[a] , parent);\\n        }\\n        return parent[a];\\n    }\\n\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int maxi = 1;\\n        int n = nums.size();\\n        int count = 0;\\n        unordered_map<int,int> umap;\\n        umap.reserve(n);\\n        vector <int> parent;\\n        vector <int> newnums;\\n        parent.reserve(n);\\n        newnums.reserve(n);\\n        for(int i=0;i<n;i++){\\n            if(umap.find(nums[i]) == umap.end()){\\n                umap[nums[i]]=count;\\n                parent[count]=count;\\n                count++;\\n                newnums.push_back(nums[i]);\\n            }\\n            else if(nums[i] == 1)return false;\\n        }\\n        nums = newnums;\\n        n = count;\\n        if(n==1)return true;\\n        vector <int> rank(n,0);\\n        vector <int> size(n,1);\\n\\n        for(int i=0;i<n;i++){\\n            for(int j =i+1;j<n;j++){\\n                if(gcd(nums[i] , nums[j])>1){\\n                    int roota = find(i , parent);\\n                    int rootb = find(j , parent);\\n                    if(roota != rootb){\\n                        if(rank[roota] > rank[rootb]){\\n                            parent[rootb] = roota;\\n                            size[roota] += size[rootb];\\n                            size[rootb] = 0;\\n                            maxi = max(maxi,size[roota]);\\n                        }\\n                        else{\\n                            parent[roota] = rootb;\\n                            if(rank[roota] == rank[rootb])rank[roota]++;\\n                            size[rootb]+=size[roota];\\n                            size[roota] = 0;\\n                            maxi = max(maxi ,size[rootb]);\\n                        }\\n                    }\\n                }\\n            }\\n            if(size[find(i, parent)] == 1)return false;\\n        }\\n    if(maxi == n)return true;\\n    return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904275,
                "title": "clever-sieve-technique",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int node,vector<bool> &vis,vector<vector<int>> &adj){\\n        vis[node]=1;\\n        for(auto it:adj[node]){\\n            if(!vis[it]){\\n                dfs(it,vis,adj);\\n            }\\n        }\\n    }\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int mx=*max_element(nums.begin(),nums.end());\\n        if(nums.size()==1) return true;\\n        if(mx==1) return false;\\n        vector<vector<int>> sieve(mx+5);\\n        for(int i=2;i<=mx;i++){\\n            if(sieve[i].size()==0){\\n                for(int j=2*i;j<=mx;j+=i){\\n                    sieve[j].push_back(i);\\n                }\\n            }\\n        }\\n        vector<vector<int>> adj(mx+5);\\n        vector<bool> vis(mx+5,0);\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            int x=nums[i];\\n            if(vis[x]) continue;\\n            for(int it:sieve[x]){\\n                adj[it].push_back(x);\\n                adj[x].push_back(it);\\n            }\\n            vis[x]=1;\\n        }\\n        int cnt=0;\\n        for(int i=0;i<=mx;i++) vis[i]=0;\\n        for(int i=0;i<n;i++){\\n            if(!vis[nums[i]]) dfs(nums[i],vis,adj),cnt++;\\n        }\\n        return cnt==1?true:false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int node,vector<bool> &vis,vector<vector<int>> &adj){\\n        vis[node]=1;\\n        for(auto it:adj[node]){\\n            if(!vis[it]){\\n                dfs(it,vis,adj);\\n            }\\n        }\\n    }\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int mx=*max_element(nums.begin(),nums.end());\\n        if(nums.size()==1) return true;\\n        if(mx==1) return false;\\n        vector<vector<int>> sieve(mx+5);\\n        for(int i=2;i<=mx;i++){\\n            if(sieve[i].size()==0){\\n                for(int j=2*i;j<=mx;j+=i){\\n                    sieve[j].push_back(i);\\n                }\\n            }\\n        }\\n        vector<vector<int>> adj(mx+5);\\n        vector<bool> vis(mx+5,0);\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            int x=nums[i];\\n            if(vis[x]) continue;\\n            for(int it:sieve[x]){\\n                adj[it].push_back(x);\\n                adj[x].push_back(it);\\n            }\\n            vis[x]=1;\\n        }\\n        int cnt=0;\\n        for(int i=0;i<=mx;i++) vis[i]=0;\\n        for(int i=0;i<n;i++){\\n            if(!vis[nums[i]]) dfs(nums[i],vis,adj),cnt++;\\n        }\\n        return cnt==1?true:false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902526,
                "title": "cpp-implementation-using-graphs-breadth-first-search",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    set<int> prfac(long long n){\\n        set<int>v;\\n        if(n<=1)return {};\\n        for(long long i=2;i<=n*n;i++){\\n            while(n%i==0){\\n                v.insert(i);\\n                n/=i;\\n            }\\n        }\\n        if(n>1)v.insert(n);\\n        return v;\\n    }\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int n=nums.size();\\n        map<int,set<int>>m;\\n        for(int i=0;i<n;i++){\\n            m.insert({i,prfac(nums[i])});\\n        }\\n        vector<vector<int>>adj(n);\\n        for(auto it=m.begin();it!=m.end();it++){\\n            int i=it->first;\\n            set<int> s=it->second;\\n            auto it2=it;\\n            it2++;\\n            for(auto e: s){\\n                for(auto it3=it2;it3!=m.end();it3++){\\n                    if(it3->second.count(e)){\\n                        adj[i].push_back(it3->first);\\n                        adj[it3->first].push_back(i);\\n                    }\\n                }\\n            }\\n        }\\n        vector<int> visit(n,false);\\n        queue<int>q;\\n        q.push(0);\\n        visit[0]=true;\\n        int count=0;\\n        while(!q.empty()){\\n            int n=q.front();q.pop();\\n            count++;\\n            for(auto e:adj[n]){\\n                if(!visit[e]){\\n                    visit[e]=true;\\n                    q.push(e);\\n                }\\n            }\\n        }\\n        return n==count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Math",
                    "Breadth-First Search",
                    "Graph",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    set<int> prfac(long long n){\\n        set<int>v;\\n        if(n<=1)return {};\\n        for(long long i=2;i<=n*n;i++){\\n            while(n%i==0){\\n                v.insert(i);\\n                n/=i;\\n            }\\n        }\\n        if(n>1)v.insert(n);\\n        return v;\\n    }\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int n=nums.size();\\n        map<int,set<int>>m;\\n        for(int i=0;i<n;i++){\\n            m.insert({i,prfac(nums[i])});\\n        }\\n        vector<vector<int>>adj(n);\\n        for(auto it=m.begin();it!=m.end();it++){\\n            int i=it->first;\\n            set<int> s=it->second;\\n            auto it2=it;\\n            it2++;\\n            for(auto e: s){\\n                for(auto it3=it2;it3!=m.end();it3++){\\n                    if(it3->second.count(e)){\\n                        adj[i].push_back(it3->first);\\n                        adj[it3->first].push_back(i);\\n                    }\\n                }\\n            }\\n        }\\n        vector<int> visit(n,false);\\n        queue<int>q;\\n        q.push(0);\\n        visit[0]=true;\\n        int count=0;\\n        while(!q.empty()){\\n            int n=q.front();q.pop();\\n            count++;\\n            for(auto e:adj[n]){\\n                if(!visit[e]){\\n                    visit[e]=true;\\n                    q.push(e);\\n                }\\n            }\\n        }\\n        return n==count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3855431,
                "title": "union-find-with-explanation",
                "content": "# Intuition\\nWhen we have to check the connectivity or link between data points (in this case, determining relations based on being co-prime), the Union Find data structure comes in really handy.\\n\\n# Approach\\nUnion Find + Dictionary\\n\\n# Complexity\\n- Time complexity: $$O(n * sqrt(n) * log star(n))$$\\n\\n- Space complexity: $$O(n * sqrt(n))$$\\n\\n# Code\\n```\\nclass UnionFind:\\n    def __init__(self, n: int):\\n        self.parents = [i for i in range(n)]\\n    def find(self, x: int) -> int:\\n        if self.parents[x] == x:\\n            return x\\n        p = self.find(self.parents[x])\\n        self.parents[x] = p\\n        return p\\n    def union(self, u: int, v: int):\\n        u_parent, v_parent = self.find(u), self.find(v)\\n        if u_parent == v_parent:\\n            return\\n        self.parents[u_parent] = v_parent\\nclass Solution:\\n    def divisors(self, x: int) -> List[int]:\\n        i = 2\\n        res = [x]\\n        while i * i <= x:\\n            if x % i == 0:\\n                res.append(i)\\n                if i * i != x:\\n                    res.append(x // i)\\n            i += 1\\n        return res\\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\\n        if 1 in nums: return len(nums) == 1\\n        n = len(nums)\\n        uf = UnionFind(n)\\n        idxs_of_divisor = defaultdict(list)\\n        for i in range(n):\\n            for d in self.divisors(nums[i]):\\n                idxs_of_divisor[d].append(i)\\n        for divisor in idxs_of_divisor.keys():\\n            idxs = idxs_of_divisor[divisor]\\n            group = idxs[0]\\n            for idx in idxs:\\n                uf.union(group, idx) \\n        for i in range(1, n):\\n            if uf.find(i) != uf.find(0):\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass UnionFind:\\n    def __init__(self, n: int):\\n        self.parents = [i for i in range(n)]\\n    def find(self, x: int) -> int:\\n        if self.parents[x] == x:\\n            return x\\n        p = self.find(self.parents[x])\\n        self.parents[x] = p\\n        return p\\n    def union(self, u: int, v: int):\\n        u_parent, v_parent = self.find(u), self.find(v)\\n        if u_parent == v_parent:\\n            return\\n        self.parents[u_parent] = v_parent\\nclass Solution:\\n    def divisors(self, x: int) -> List[int]:\\n        i = 2\\n        res = [x]\\n        while i * i <= x:\\n            if x % i == 0:\\n                res.append(i)\\n                if i * i != x:\\n                    res.append(x // i)\\n            i += 1\\n        return res\\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\\n        if 1 in nums: return len(nums) == 1\\n        n = len(nums)\\n        uf = UnionFind(n)\\n        idxs_of_divisor = defaultdict(list)\\n        for i in range(n):\\n            for d in self.divisors(nums[i]):\\n                idxs_of_divisor[d].append(i)\\n        for divisor in idxs_of_divisor.keys():\\n            idxs = idxs_of_divisor[divisor]\\n            group = idxs[0]\\n            for idx in idxs:\\n                uf.union(group, idx) \\n        for i in range(1, n):\\n            if uf.find(i) != uf.find(0):\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840104,
                "title": "prime-factorization-plus-disjoint-set-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nComputing GCDs for all pairs can be too slow so I solve this problem from another direction. Two nums are connected if they share common factors. The volume of each number in the input is up to $10^5$ only, so we can do prime factorization for each number, and union all numbers with a common factor. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Prepare a table for the primes from $2$ to $\\\\sqrt{10^5}$\\n2. Do prime factorization for each number. For each prime factor of the number, we group the number with a disjoint set.\\n3. Finally, to check if all the numbers are connected is to check if the size of set of an arbitrary number (e.g., `0` in my code) equals to the size of all numbers.\\n\\n# Code\\n```\\nclass DisjointSet:\\n    def __init__(self):\\n        self.parents = {}\\n        self.sizes = {}\\n\\n    def find(self, v):\\n        if v not in self.parents:\\n            self.parents[v] = v\\n            self.sizes[v] = 1\\n        elif self.parents[v] != v:\\n            self.parents[v] = self.find(self.parents[v])\\n        return self.parents[v]\\n\\n    def union(self, v, u):\\n        v, u = self.find(v), self.find(u)\\n        if v != u:\\n            if self.sizes[v] > self.sizes[u]:\\n                v, u = u, v\\n            self.parents[v] = u\\n            self.sizes[u] += self.sizes[v]\\n\\n    def size(self, v):\\n        return self.sizes[self.find(v)]\\n\\nclass Solution:\\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\\n        primes = [2]\\n        for v in range(3, int(100000**0.5)+1, 2):\\n            if all(v % p != 0 for p in primes):\\n                primes.append(v)\\n        groups = {}\\n        ds = DisjointSet()\\n\\n        for i, v in enumerate(nums):\\n            for p in primes:\\n                if p > v:\\n                    break\\n                if v % p == 0:\\n                    if p in groups:\\n                        ds.union(i, groups[p])\\n                    else:\\n                        groups[p] = i\\n                    while v % p == 0:\\n                        v //= p\\n            if v > 1:\\n                if v in groups:\\n                    ds.union(i, groups[v])\\n                else:\\n                    groups[v] = i\\n        \\n        return ds.size(0) == len(nums)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass DisjointSet:\\n    def __init__(self):\\n        self.parents = {}\\n        self.sizes = {}\\n\\n    def find(self, v):\\n        if v not in self.parents:\\n            self.parents[v] = v\\n            self.sizes[v] = 1\\n        elif self.parents[v] != v:\\n            self.parents[v] = self.find(self.parents[v])\\n        return self.parents[v]\\n\\n    def union(self, v, u):\\n        v, u = self.find(v), self.find(u)\\n        if v != u:\\n            if self.sizes[v] > self.sizes[u]:\\n                v, u = u, v\\n            self.parents[v] = u\\n            self.sizes[u] += self.sizes[v]\\n\\n    def size(self, v):\\n        return self.sizes[self.find(v)]\\n\\nclass Solution:\\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\\n        primes = [2]\\n        for v in range(3, int(100000**0.5)+1, 2):\\n            if all(v % p != 0 for p in primes):\\n                primes.append(v)\\n        groups = {}\\n        ds = DisjointSet()\\n\\n        for i, v in enumerate(nums):\\n            for p in primes:\\n                if p > v:\\n                    break\\n                if v % p == 0:\\n                    if p in groups:\\n                        ds.union(i, groups[p])\\n                    else:\\n                        groups[p] = i\\n                    while v % p == 0:\\n                        v //= p\\n            if v > 1:\\n                if v in groups:\\n                    ds.union(i, groups[v])\\n                else:\\n                    groups[v] = i\\n        \\n        return ds.size(0) == len(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3763310,
                "title": "golang-union-find-prime-factorization",
                "content": "# Code\\n```\\nfunc canTraverseAllPairs(nums []int) bool {\\n  var max int\\n  var oneFound bool\\n  for i := 0; i < len(nums); i++ {\\n    if nums[i] == 1 {\\n      oneFound = true\\n    }\\n    if nums[i] > max {\\n      max = nums[i]\\n    }\\n  }\\n  if oneFound && len(nums) > 1 {\\n    // We can\\'t have 1 anywhere because gcd(1, x) = 1\\n    return false\\n  }\\n  root := make([]int, max+1)\\n  rank := make([]int, max+1)\\n  for i := 0; i < len(root); i++ {\\n    root[i] = i\\n  }\\n  for _, num := range nums {\\n    for _, factor := range factorize(num) {\\n      union(root, rank, num, factor)\\n    }\\n  }\\n  r := find(root, nums[0])\\n  for i := 1; i < len(nums); i++ {\\n    if find(root, nums[i]) != r {\\n      return false\\n    }\\n  }\\n  return true\\n}\\n\\nfunc find(root []int, x int) int {\\n  if root[x] == x {\\n    return x\\n  }\\n  root[x] = find(root, root[x])\\n  return root[x]\\n}\\n\\nfunc factorize(num int) []int {\\n  var factors []int\\n  factor := 2\\n  end := int(math.Sqrt(float64(num)))\\n  for num > 1 && factor <= end {\\n    appended := false\\n    for num%factor == 0 {\\n      if !appended {\\n        factors = append(factors, factor)\\n        appended = true\\n      }\\n      num /= factor\\n    }\\n    factor++\\n  }\\n  if num > 1 { // num is a really big prime number\\n    factors = append(factors, num)\\n  }\\n  return factors\\n}\\n\\nfunc union(root, rank []int, x, y int) {\\n  rootX := find(root, x)\\n  rootY := find(root, y)\\n  if rootX != rootY {\\n    if rank[rootX] > rank[rootY] {\\n      root[rootY] = rootX\\n    } else if rank[rootX] < rank[rootY] {\\n      root[rootX] = rootY\\n    } else {\\n      root[rootY] = rootX\\n      rank[rootX]++\\n    }\\n  }\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Union Find",
                    "Number Theory"
                ],
                "code": "```\\nfunc canTraverseAllPairs(nums []int) bool {\\n  var max int\\n  var oneFound bool\\n  for i := 0; i < len(nums); i++ {\\n    if nums[i] == 1 {\\n      oneFound = true\\n    }\\n    if nums[i] > max {\\n      max = nums[i]\\n    }\\n  }\\n  if oneFound && len(nums) > 1 {\\n    // We can\\'t have 1 anywhere because gcd(1, x) = 1\\n    return false\\n  }\\n  root := make([]int, max+1)\\n  rank := make([]int, max+1)\\n  for i := 0; i < len(root); i++ {\\n    root[i] = i\\n  }\\n  for _, num := range nums {\\n    for _, factor := range factorize(num) {\\n      union(root, rank, num, factor)\\n    }\\n  }\\n  r := find(root, nums[0])\\n  for i := 1; i < len(nums); i++ {\\n    if find(root, nums[i]) != r {\\n      return false\\n    }\\n  }\\n  return true\\n}\\n\\nfunc find(root []int, x int) int {\\n  if root[x] == x {\\n    return x\\n  }\\n  root[x] = find(root, root[x])\\n  return root[x]\\n}\\n\\nfunc factorize(num int) []int {\\n  var factors []int\\n  factor := 2\\n  end := int(math.Sqrt(float64(num)))\\n  for num > 1 && factor <= end {\\n    appended := false\\n    for num%factor == 0 {\\n      if !appended {\\n        factors = append(factors, factor)\\n        appended = true\\n      }\\n      num /= factor\\n    }\\n    factor++\\n  }\\n  if num > 1 { // num is a really big prime number\\n    factors = append(factors, num)\\n  }\\n  return factors\\n}\\n\\nfunc union(root, rank []int, x, y int) {\\n  rootX := find(root, x)\\n  rootY := find(root, y)\\n  if rootX != rootY {\\n    if rank[rootX] > rank[rootY] {\\n      root[rootY] = rootX\\n    } else if rank[rootX] < rank[rootY] {\\n      root[rootX] = rootY\\n    } else {\\n      root[rootY] = rootX\\n      rank[rootX]++\\n    }\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3741094,
                "title": "80-less-memory-union-find",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass UnionFind():\\n        def __init__(self,n):\\n            self.parent = [i for i in range(n+1)]\\n            self.rank = [1]*(n+1)\\n        \\n        def find(self,x):\\n            if x!= self.parent[x]:\\n                self.parent[x] = self.find(self.parent[x])\\n            return self.parent[x]\\n        \\n        def union(self,x,y):\\n            parent_x = self.find(x)\\n            parent_y = self.find(y)\\n\\n            if parent_x != parent_y:\\n                if self.rank[parent_x] > self.rank[parent_y]:\\n                    self.parent[parent_y] = parent_x\\n                elif self.rank[parent_x] < self.rank[parent_y]:\\n                    self.parent[parent_x] = parent_y\\n                else:\\n                    self.parent[parent_y] = parent_x\\n                    self.rank[parent_x] += 1\\n\\nclass Solution:\\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\\n\\n            if len(nums)==1:\\n                return True\\n\\n            nums = list(set(nums))\\n            nums.sort()\\n\\n            union_obj = UnionFind(max(nums))\\n            for num in nums:\\n                    for value in range(2,int(math.sqrt(num))+1):\\n                        if num%value == 0:\\n                            union_obj.union(value,num)\\n                            union_obj.union(value,num//value)\\n\\n            print(union_obj.parent)\\n            group_count = defaultdict(int)\\n            max_size = [-1,-1]\\n            for a in nums:\\n                group_id = union_obj.find(a)\\n                group_count[group_id] += 1\\n                if group_count[group_id] > max_size[0]:\\n                    max_size = [group_count[group_id],a]\\n            \\n            if max_size[1] == 1:\\n               return False\\n            else:\\n               return max_size[0]==len(nums)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\nclass UnionFind():\\n        def __init__(self,n):\\n            self.parent = [i for i in range(n+1)]\\n            self.rank = [1]*(n+1)\\n        \\n        def find(self,x):\\n            if x!= self.parent[x]:\\n                self.parent[x] = self.find(self.parent[x])\\n            return self.parent[x]\\n        \\n        def union(self,x,y):\\n            parent_x = self.find(x)\\n            parent_y = self.find(y)\\n\\n            if parent_x != parent_y:\\n                if self.rank[parent_x] > self.rank[parent_y]:\\n                    self.parent[parent_y] = parent_x\\n                elif self.rank[parent_x] < self.rank[parent_y]:\\n                    self.parent[parent_x] = parent_y\\n                else:\\n                    self.parent[parent_y] = parent_x\\n                    self.rank[parent_x] += 1\\n\\nclass Solution:\\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\\n\\n            if len(nums)==1:\\n                return True\\n\\n            nums = list(set(nums))\\n            nums.sort()\\n\\n            union_obj = UnionFind(max(nums))\\n            for num in nums:\\n                    for value in range(2,int(math.sqrt(num))+1):\\n                        if num%value == 0:\\n                            union_obj.union(value,num)\\n                            union_obj.union(value,num//value)\\n\\n            print(union_obj.parent)\\n            group_count = defaultdict(int)\\n            max_size = [-1,-1]\\n            for a in nums:\\n                group_id = union_obj.find(a)\\n                group_count[group_id] += 1\\n                if group_count[group_id] > max_size[0]:\\n                    max_size = [group_count[group_id],a]\\n            \\n            if max_size[1] == 1:\\n               return False\\n            else:\\n               return max_size[0]==len(nums)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3726908,
                "title": "both-100-some-tips-for-those-who-get-tle",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince max(nums[i]) <= 1e5, we can find all primes and merge their common multiples. Returns true if all numbers in nums are merged.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sorting, which will allow you to find prime numbers that can be merged faster. (O(nlg(n)))\\n2. Unique, it is not difficult to find that repeated values \\u200B\\u200B\\u200B\\u200Bhave no meaning **(except \\'1\\')**. (O(n))\\n3. Find the max value, it is not necessary to find all the prime numbers in each case. (O(n))\\n4. Special cases:\\n    4-1. Obviously, if there is more than one 1, the answer is false. (O(n))\\n    4-2. Also false if the largest prime number does not have any multiples. (O(n))\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n    1. Find all primes: O(nlg(n)lg(n))\\n    2. Merge them: O(nsqrt(n)lg(n))\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector <int> pr;\\n    int fa[100005],n,sz,ma,mp;\\n    bool isp[100005]={1,1},on;\\n    int ff(int x){\\n        if(x==fa[x])return x;\\n        return fa[x]=ff(fa[x]);\\n    }\\n    void mg(int x,int y){\\n        x=ff(x);\\n        y=ff(y);\\n        if(x==y)return;\\n        fa[x]=y;\\n        --sz;\\n    }\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        if(nums.size()==1)return 1;\\n        if(nums[1]==1)return 0;\\n        std::vector<int>::iterator it;\\n        it = std::unique (nums.begin(), nums.end());\\n        nums.resize( std::distance(nums.begin(),it) ); \\n        n=sz=nums.size();\\n        if(n==1)return 1;\\n        for(int i=0;i<n;++i){\\n            ma=max(ma,nums[i]);\\n            fa[i]=i;\\n        }\\n        for(int i=2;i<=sqrt(ma);++i){\\n            for(int j=i+i;j<=ma;j+=i){\\n                isp[j]=1;\\n            }\\n        }\\n        for(int i=n-1;i>=0;--i){\\n            if(isp[nums[i]]==0){\\n                bool ac=0;\\n                for(int j=i+1;j<n;++j){\\n                    if(nums[j]%nums[i]==0){\\n                        ac=1;\\n                        break;\\n                    }\\n                }\\n                if(ac==0)return 0;\\n                break;\\n            }\\n        }\\n        for(int i=2;i<=ma;++i){\\n            if(!isp[i]){\\n                int st=-1;\\n                for(int j=n-1;j>=0;--j){\\n                    if(nums[j]%i==0){\\n                        if(st!=-1){\\n                            mg(st,j);\\n                        }\\n                        else{\\n                            st=j;\\n                        }\\n                    }\\n                    else if(nums[j]<i)break;\\n                }\\n            }\\n        }\\n        return (sz==1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector <int> pr;\\n    int fa[100005],n,sz,ma,mp;\\n    bool isp[100005]={1,1},on;\\n    int ff(int x){\\n        if(x==fa[x])return x;\\n        return fa[x]=ff(fa[x]);\\n    }\\n    void mg(int x,int y){\\n        x=ff(x);\\n        y=ff(y);\\n        if(x==y)return;\\n        fa[x]=y;\\n        --sz;\\n    }\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        if(nums.size()==1)return 1;\\n        if(nums[1]==1)return 0;\\n        std::vector<int>::iterator it;\\n        it = std::unique (nums.begin(), nums.end());\\n        nums.resize( std::distance(nums.begin(),it) ); \\n        n=sz=nums.size();\\n        if(n==1)return 1;\\n        for(int i=0;i<n;++i){\\n            ma=max(ma,nums[i]);\\n            fa[i]=i;\\n        }\\n        for(int i=2;i<=sqrt(ma);++i){\\n            for(int j=i+i;j<=ma;j+=i){\\n                isp[j]=1;\\n            }\\n        }\\n        for(int i=n-1;i>=0;--i){\\n            if(isp[nums[i]]==0){\\n                bool ac=0;\\n                for(int j=i+1;j<n;++j){\\n                    if(nums[j]%nums[i]==0){\\n                        ac=1;\\n                        break;\\n                    }\\n                }\\n                if(ac==0)return 0;\\n                break;\\n            }\\n        }\\n        for(int i=2;i<=ma;++i){\\n            if(!isp[i]){\\n                int st=-1;\\n                for(int j=n-1;j>=0;--j){\\n                    if(nums[j]%i==0){\\n                        if(st!=-1){\\n                            mg(st,j);\\n                        }\\n                        else{\\n                            st=j;\\n                        }\\n                    }\\n                    else if(nums[j]<i)break;\\n                }\\n            }\\n        }\\n        return (sz==1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663473,
                "title": "a-few-solutions",
                "content": "**Union-Find:** Perform a linear scan of each value `x` of the input array `A`, unioning `x` with its factors `y` from `f(x)` and return `true` if there is one connected component. \\n\\n* Note: watch out for the \\u2B50\\uFE0F corner case where all values of the input array `A` equal `1`\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun canTraverseAllPairs(A: IntArray): Boolean {\\n        if (A.all{ it == 1 })  // \\u2B50\\uFE0F corner case\\n            return 1 == A.size\\n        var P = mutableMapOf<Int, Int>()  // \\uD83D\\uDE42 parent representatives of N-disjoint sets\\n        fun find(x: Int): Int {\\n            if (P[x] != x)\\n                P[x] = find(P[x]!!)\\n            return P[x]!!\\n        }\\n        fun union(a_: Int, b_: Int) {\\n            var a = find(a_)\\n            var b = find(b_)\\n            P[a] = b  // \\uD83C\\uDFB2 arbitrary choice\\n        }\\n        fun f(x: Int): MutableSet<Int> {\\n            var F = mutableSetOf<Int>()\\n            for (y in 2..Math.floor(Math.sqrt(x.toDouble())).toInt()) {\\n                if (x % y == 0) {\\n                    F.add(x / y); F.add(y)\\n                }\\n            }\\n            return F\\n        }\\n        for (x in A) {\\n            P[x] = P.getOrDefault(x, x)\\n            for (y in f(x)) {\\n                P[y] = P.getOrDefault(y, y)\\n                union(x, y)\\n            }\\n        }\\n        return 1 == A.map{ find(it) }.toSet().size\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet canTraverseAllPairs = A => {\\n    if (A.every(x => x == 1))  // \\u2B50\\uFE0F corner case\\n        return 1 == A.length;\\n    let P = new Map();  // \\uD83D\\uDE42 parent representatives of N-disjoint sets\\n    let find = x => P.set(x, P.get(x) == x ? x : find(P.get(x))).get(x);\\n    let union = (a, b) => {\\n        a = find(a);\\n        b = find(b);\\n        P.set(a, b);  // \\uD83C\\uDFB2 arbitrary choice\\n    };\\n    let f = x => {\\n        let F = new Set();\\n        for (let y = 2; y <= Math.floor(Math.sqrt(x)); ++y)\\n            if (!(x % y))\\n                F.add(x / y), F.add(y);\\n        return F;\\n    };\\n    for (let x of A) {\\n        P.set(x, P.get(x) || x);\\n        for (let y of f(x)) {\\n            P.set(y, P.get(y) || y);\\n            union(x, y);\\n        }\\n    }\\n    return 1 == new Set([...A].map(x => find(x))).size;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def canTraverseAllPairs(self, A: List[int]) -> bool:\\n        if all(x == 1 for x in A):  # \\u2B50\\uFE0F corner case\\n            return 1 == len(A)\\n        P = {}  # \\uD83D\\uDE42 parent representatives of N-disjoint sets\\n        def find(x):\\n            if P[x] != x:\\n                P[x] = find(P[x])\\n            return P[x]\\n        def union(a, b):\\n            a = find(a)\\n            b = find(b)\\n            P[a] = b  # \\uD83C\\uDFB2 arbitrary choice\\n        def f(x):\\n            F = set()\\n            for y in range(2, floor(sqrt(x)) + 1):\\n                if not (x % y):\\n                    F.add(x // y); F.add(y)\\n            return F\\n        for x in A:\\n            P[x] = x if x not in P else P[x]\\n            for y in f(x):\\n                P[y] = y if y not in P else P[y]\\n                union(x, y)\\n        return 1 == len(set(find(x) for x in A))\\n```\\n\\n*Rust*\\n```\\ntype VI = Vec<i32>;\\nuse std::collections::{HashMap, HashSet};\\ntype Map = HashMap<i32, i32>;\\ntype Set = HashSet<i32>;\\nimpl Solution {\\n    pub fn can_traverse_all_pairs(A: VI) -> bool {\\n        if A.iter().all(|&x| x == 1) {  // \\u2B50\\uFE0F corner case\\n            return 1 == A.len();\\n        }\\n        let mut P = Map::new();  // \\uD83D\\uDE42 parent representatives of N-disjoint sets\\n        fn find(P: &mut Map, x: i32) -> i32 {\\n            if *P.get(&x).unwrap() != x {\\n                let parent = find(P, *P.get(&x).unwrap());\\n                P.insert(x, parent);\\n            }\\n            *P.get(&x).unwrap()\\n        }\\n        fn union(P: &mut Map, a_: i32, b_: i32) {\\n            let a = find(P, a_);\\n            let b = find(P, b_);\\n            P.insert(a, b);  // \\uD83C\\uDFB2 arbitrary choice\\n        }\\n        fn f(x: i32) -> Set {\\n            let mut F = Set::new();\\n            for y in 2..=(x as f64).sqrt() as i32 {\\n                if x % y == 0 {\\n                    F.insert(x / y); F.insert(y);\\n                }\\n            }\\n            F\\n        }\\n        for x in &A {\\n            if !P.contains_key(x) {\\n                P.insert(*x, *x);\\n            }\\n            for y in f(*x) {\\n                if !P.contains_key(&y) {\\n                    P.insert(y, y);\\n                }\\n                union(&mut P, *x, y);\\n            }\\n        }\\n        1 == A.iter().map(|x| find(&mut P, *x)).collect::<Set>().len()\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Map = unordered_map<int, int>;\\n    using Set = unordered_set<int>;\\n    using fun = function<int(int)>;\\n    bool canTraverseAllPairs(VI& A, Set seen = {}) {\\n        if (all_of(A.begin(), A.end(), [](auto x) { return x == 1; }))  // \\u2B50\\uFE0F corner case\\n            return 1 == A.size();\\n        Map P;  // \\uD83D\\uDE42 parent representatives of N-disjoint sets\\n        fun find = [&](auto x) { return P[x] = P[x] == x ? x : find(P[x]); };\\n        auto union_ = [&](auto a, auto b) {\\n            a = find(a);\\n            b = find(b);\\n            P[a] = b;  // \\uD83C\\uDFB2 arbitrary choice\\n        };\\n        auto f = [](auto x) {\\n            Set F;\\n            for (auto y{ 2 }; y <= int(sqrt(x)); ++y)\\n                if (!(x % y))\\n                    F.insert(x / y), F.insert(y);\\n            return F;\\n        };\\n        for (auto x: A) {\\n            P[x] = P.find(x) == P.end() ? x : P[x];\\n            for (auto y: f(x)) {\\n                P[y] = P.find(y) == P.end() ? y : P[y];\\n                union_(x, y);\\n            }\\n        }\\n        transform(A.begin(), A.end(), inserter(seen, seen.end()), [&](auto x) { return find(x); });\\n        return 1 == seen.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun canTraverseAllPairs(A: IntArray): Boolean {\\n        if (A.all{ it == 1 })  // \\u2B50\\uFE0F corner case\\n            return 1 == A.size\\n        var P = mutableMapOf<Int, Int>()  // \\uD83D\\uDE42 parent representatives of N-disjoint sets\\n        fun find(x: Int): Int {\\n            if (P[x] != x)\\n                P[x] = find(P[x]!!)\\n            return P[x]!!\\n        }\\n        fun union(a_: Int, b_: Int) {\\n            var a = find(a_)\\n            var b = find(b_)\\n            P[a] = b  // \\uD83C\\uDFB2 arbitrary choice\\n        }\\n        fun f(x: Int): MutableSet<Int> {\\n            var F = mutableSetOf<Int>()\\n            for (y in 2..Math.floor(Math.sqrt(x.toDouble())).toInt()) {\\n                if (x % y == 0) {\\n                    F.add(x / y); F.add(y)\\n                }\\n            }\\n            return F\\n        }\\n        for (x in A) {\\n            P[x] = P.getOrDefault(x, x)\\n            for (y in f(x)) {\\n                P[y] = P.getOrDefault(y, y)\\n                union(x, y)\\n            }\\n        }\\n        return 1 == A.map{ find(it) }.toSet().size\\n    }\\n}\\n```\n```\\nlet canTraverseAllPairs = A => {\\n    if (A.every(x => x == 1))  // \\u2B50\\uFE0F corner case\\n        return 1 == A.length;\\n    let P = new Map();  // \\uD83D\\uDE42 parent representatives of N-disjoint sets\\n    let find = x => P.set(x, P.get(x) == x ? x : find(P.get(x))).get(x);\\n    let union = (a, b) => {\\n        a = find(a);\\n        b = find(b);\\n        P.set(a, b);  // \\uD83C\\uDFB2 arbitrary choice\\n    };\\n    let f = x => {\\n        let F = new Set();\\n        for (let y = 2; y <= Math.floor(Math.sqrt(x)); ++y)\\n            if (!(x % y))\\n                F.add(x / y), F.add(y);\\n        return F;\\n    };\\n    for (let x of A) {\\n        P.set(x, P.get(x) || x);\\n        for (let y of f(x)) {\\n            P.set(y, P.get(y) || y);\\n            union(x, y);\\n        }\\n    }\\n    return 1 == new Set([...A].map(x => find(x))).size;\\n};\\n```\n```\\nclass Solution:\\n    def canTraverseAllPairs(self, A: List[int]) -> bool:\\n        if all(x == 1 for x in A):  # \\u2B50\\uFE0F corner case\\n            return 1 == len(A)\\n        P = {}  # \\uD83D\\uDE42 parent representatives of N-disjoint sets\\n        def find(x):\\n            if P[x] != x:\\n                P[x] = find(P[x])\\n            return P[x]\\n        def union(a, b):\\n            a = find(a)\\n            b = find(b)\\n            P[a] = b  # \\uD83C\\uDFB2 arbitrary choice\\n        def f(x):\\n            F = set()\\n            for y in range(2, floor(sqrt(x)) + 1):\\n                if not (x % y):\\n                    F.add(x // y); F.add(y)\\n            return F\\n        for x in A:\\n            P[x] = x if x not in P else P[x]\\n            for y in f(x):\\n                P[y] = y if y not in P else P[y]\\n                union(x, y)\\n        return 1 == len(set(find(x) for x in A))\\n```\n```\\ntype VI = Vec<i32>;\\nuse std::collections::{HashMap, HashSet};\\ntype Map = HashMap<i32, i32>;\\ntype Set = HashSet<i32>;\\nimpl Solution {\\n    pub fn can_traverse_all_pairs(A: VI) -> bool {\\n        if A.iter().all(|&x| x == 1) {  // \\u2B50\\uFE0F corner case\\n            return 1 == A.len();\\n        }\\n        let mut P = Map::new();  // \\uD83D\\uDE42 parent representatives of N-disjoint sets\\n        fn find(P: &mut Map, x: i32) -> i32 {\\n            if *P.get(&x).unwrap() != x {\\n                let parent = find(P, *P.get(&x).unwrap());\\n                P.insert(x, parent);\\n            }\\n            *P.get(&x).unwrap()\\n        }\\n        fn union(P: &mut Map, a_: i32, b_: i32) {\\n            let a = find(P, a_);\\n            let b = find(P, b_);\\n            P.insert(a, b);  // \\uD83C\\uDFB2 arbitrary choice\\n        }\\n        fn f(x: i32) -> Set {\\n            let mut F = Set::new();\\n            for y in 2..=(x as f64).sqrt() as i32 {\\n                if x % y == 0 {\\n                    F.insert(x / y); F.insert(y);\\n                }\\n            }\\n            F\\n        }\\n        for x in &A {\\n            if !P.contains_key(x) {\\n                P.insert(*x, *x);\\n            }\\n            for y in f(*x) {\\n                if !P.contains_key(&y) {\\n                    P.insert(y, y);\\n                }\\n                union(&mut P, *x, y);\\n            }\\n        }\\n        1 == A.iter().map(|x| find(&mut P, *x)).collect::<Set>().len()\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Map = unordered_map<int, int>;\\n    using Set = unordered_set<int>;\\n    using fun = function<int(int)>;\\n    bool canTraverseAllPairs(VI& A, Set seen = {}) {\\n        if (all_of(A.begin(), A.end(), [](auto x) { return x == 1; }))  // \\u2B50\\uFE0F corner case\\n            return 1 == A.size();\\n        Map P;  // \\uD83D\\uDE42 parent representatives of N-disjoint sets\\n        fun find = [&](auto x) { return P[x] = P[x] == x ? x : find(P[x]); };\\n        auto union_ = [&](auto a, auto b) {\\n            a = find(a);\\n            b = find(b);\\n            P[a] = b;  // \\uD83C\\uDFB2 arbitrary choice\\n        };\\n        auto f = [](auto x) {\\n            Set F;\\n            for (auto y{ 2 }; y <= int(sqrt(x)); ++y)\\n                if (!(x % y))\\n                    F.insert(x / y), F.insert(y);\\n            return F;\\n        };\\n        for (auto x: A) {\\n            P[x] = P.find(x) == P.end() ? x : P[x];\\n            for (auto y: f(x)) {\\n                P[y] = P.find(y) == P.end() ? y : P[y];\\n                union_(x, y);\\n            }\\n        }\\n        transform(A.begin(), A.end(), inserter(seen, seen.end()), [&](auto x) { return find(x); });\\n        return 1 == seen.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3644300,
                "title": "dfs-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, vector<int>> indexToPrime, primeToIndex;\\n    unordered_map<int, bool> vis, visPrime;\\n\\n    void dfs(int v){\\n        if(vis[v]) return;\\n\\n        vis[v]=1;\\n        for(auto &prime : indexToPrime[v]){\\n            if(visPrime[prime]) continue;\\n\\n            visPrime[prime]=1;\\n            for(auto &index : primeToIndex[prime]){\\n                if(vis[index]) continue;\\n\\n                dfs(index);\\n            }\\n        }\\n    }\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        for(int i=0; i<n; i++){\\n            int tmp = nums[i];\\n            for(int j=2; j*j <= tmp ; j++){\\n                if(tmp % j == 0){\\n                    indexToPrime[i].push_back(j);\\n                    primeToIndex[j].push_back(i);\\n                    while(tmp %j == 0)\\n                    tmp /= j;\\n                }\\n            }\\n            if(tmp > 1){\\n                indexToPrime[i].push_back(tmp);\\n                primeToIndex[tmp].push_back(i);\\n            }\\n        }\\n\\n      dfs(0);\\n      for(int i=0; i<n; i++){\\n          if(!vis[i]) return 0;\\n      }\\n      return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, vector<int>> indexToPrime, primeToIndex;\\n    unordered_map<int, bool> vis, visPrime;\\n\\n    void dfs(int v){\\n        if(vis[v]) return;\\n\\n        vis[v]=1;\\n        for(auto &prime : indexToPrime[v]){\\n            if(visPrime[prime]) continue;\\n\\n            visPrime[prime]=1;\\n            for(auto &index : primeToIndex[prime]){\\n                if(vis[index]) continue;\\n\\n                dfs(index);\\n            }\\n        }\\n    }\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        for(int i=0; i<n; i++){\\n            int tmp = nums[i];\\n            for(int j=2; j*j <= tmp ; j++){\\n                if(tmp % j == 0){\\n                    indexToPrime[i].push_back(j);\\n                    primeToIndex[j].push_back(i);\\n                    while(tmp %j == 0)\\n                    tmp /= j;\\n                }\\n            }\\n            if(tmp > 1){\\n                indexToPrime[i].push_back(tmp);\\n                primeToIndex[tmp].push_back(i);\\n            }\\n        }\\n\\n      dfs(0);\\n      for(int i=0; i<n; i++){\\n          if(!vis[i]) return 0;\\n      }\\n      return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634976,
                "title": "beats-100-time-making-most-of-a-squared-situation",
                "content": "# Intuition\\nI spent a while trying to optimise this, in minor bits, really just seeking help on the GCD part.  This problem is a game of reduction and failing fast.\\n\\n# Approach\\n\\nMain idea is there are several disqualifying factors to this problem.  Because each index could potentially have a connection to all the rest, the worst this problem could be is O(n^2).  \\n\\nThere are a couple base cases we know the answer to trivially, such as if all nodes are duplicates, then we return whether or not that value is > 1.  If 1, none of the node can connect to the others (`false`), but > 1 shares itself as a factor (`true`).  If only is single node is provided, then it\\'s not, not connected, therefore we quickly return `true`.\\n\\nBeing a graph problem, we want to be find a way to represent our edges.  We do this by keeping pairs of elements that compute a gcd > 1.\\n\\nIf all numbers have a GCD > 1, we\\'re not really able to do much but process everything.  Since we\\'re visiting each node 1 by 1, we can determine if each node has no connections, and is therefore completely cutoff from the graph.  Finding one allows us to return `false` immediately.\\n\\nWhile running through each valid edge, it\\'s technically sorted, so we can run through in batches, reducing the number of edges to be processed each time. If no edges are removed in an iteration, then we know the rest of the graph is disconnected (`false`).  As soon as we have visited each node, or run out of edges, we know we are done processing and can make our final judgement.  In order to return `true` all nodes must have been visited.\\n\\n\\n# Complexity\\n- Time complexity:\\n\\u03A9(1) | O(n^2) | Arguably, this function runs optimally for the input set.\\nBest case, we can trivially solve (1 input).\\nNext best, we can acheive O(n) by ruling out base cases for the trimmed set (only unique values)\\n\\nWorst case is O(n^2), should we have to start processing edges.  Because they may all be connected, but 1 very final node is not, the we would have had to exhaust graph.\\n\\n- Space complexity:\\nBeing concious of space and new allocations, I tried to re-use structured when makes sense.\\nO(n^2) - Worst offender would be having to keep track of edges.  The visitor list is size n, so it\\'s negligable compared.\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn can_traverse_all_pairs(nums: Vec<i32>) -> bool {\\n        // A single element is always connected to itself\\n        if nums.len() == 1 {\\n            return true;\\n        }\\n        // Making all elements unique will drastically reduce \\n        // the work needed.  Any duplicates will have the same\\n        // connections.\\n        let (nums_len, nums) = {\\n            let (set, nums) = nums\\n                .into_iter()\\n                .fold(\\n                    (std::collections::HashSet::new(), Vec::new()),\\n                    |(mut set, mut vec), v| {\\n                        if !set.contains(&v) {\\n                            set.insert(v);\\n                            vec.push(v);\\n                        }\\n\\n                        (set, vec)\\n                    }\\n                );\\n\\n            // if the set contains 1, we know it\\'s toast\\n            // no node can connect to a node with val 1\\n            if set.contains(&1) {\\n                return false;\\n            }\\n\\n            let nums_len = nums.len();\\n            // if all dupes, then it will always succeed\\n            if nums_len == 1 {\\n                return true;\\n            }\\n\\n            // we\\'re all done with the set now\\n            (nums_len, nums)\\n        };\\n\\n        // While builing a \\'graph\\', we can keep an eye out for\\n        // any node that has no edges. (fail-fast)\\n        let mut visited = vec![false; nums_len];\\n        let mut edges = {\\n            let mut edges = std::collections::LinkedList::new();\\n            let mut j;\\n            for (i, num1) in nums.iter().enumerate() {\\n                // for each number, find all numbers bigger\\n                // does this mean we should sort?\\n\\n                let mut has_connection = false;\\n\\n                j = i + 1;\\n                while j < nums_len {\\n                    if gcd(*num1, nums[j]) > 1 {\\n                        edges.push_back((i, j));\\n                        has_connection = true;\\n                        visited[j] = true;\\n                    }\\n                    j += 1;\\n                }\\n\\n                // This node has no connections, and has never been\\n                // visited before.  This must be disconnected from the \\n                // graph.\\n                if !has_connection && !visited[i] {\\n                    return false;\\n                }\\n\\n                visited[i] = true;\\n            }\\n            edges\\n        };\\n\\n        // There must be at least N - 1 edges for N nodes\\n        // for the entire graph to be connected.\\n        let mut width = edges.len();\\n        if width < nums_len - 1 {\\n            return false;\\n        }\\n\\n        // we just need to find if the graph is fully connected via these edges.\\n        // We will be able to visit all nodes using any traversal pattern\\n        // starting from any 1 point (we will just iterate over all edges and see if all elements in nums are visited.\\n        visited[0] = false;\\n        let mut prev_width = width;\\n        let mut num_visited = 1;\\n\\n        // Technically, we are already sorted for breadth first traversal\\n        while let Some(edge) = edges.pop_front() {\\n            let newly_visited = match (visited[edge.0], visited[edge.1]) {\\n                (false, true) => Some(edge.1),\\n                (true, false) => Some(edge.0),\\n                _ => {\\n                    edges.push_back(edge);\\n                    None\\n                }\\n            };\\n\\n            if let Some(v) = newly_visited {\\n                // mark visited if first time seeing this node.\\n                visited[v] = false;\\n                num_visited += 1;\\n            }\\n\\n            width -= 1;\\n            if width == 0 {\\n                if num_visited == nums_len {\\n                    return true;\\n                }\\n\\n                // if edges is empty, we can break the loop.\\n                if edges.is_empty() {\\n                    break;\\n                }\\n\\n                // reset at the current length of edges\\n                width = edges.len();\\n\\n                // Width is used to see if we \\n                // were able to eliminate any edges\\n                // if not, we know the graph is disconnected\\n                // at some point\\n                match width == prev_width {\\n                    true => return false,\\n                    false => prev_width = width\\n                }\\n            }\\n        }\\n\\n        // if graph is connected, we should have hit every node.\\n        // A prime number for example would not\\n        // appear in any edge unless it itself is the gcd of the other number\\n        num_visited == nums_len\\n    }\\n}\\n\\n/// Finds the Greatest Common Divisor\\nfn gcd(mut a: i32, mut b: i32) -> i32 {\\n\\n    let mut temp;\\n    while b != 0 {\\n        temp = a % b;\\n        a = b;\\n        b = temp;\\n    }\\n\\n    a\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn can_traverse_all_pairs(nums: Vec<i32>) -> bool {\\n        // A single element is always connected to itself\\n        if nums.len() == 1 {\\n            return true;\\n        }\\n        // Making all elements unique will drastically reduce \\n        // the work needed.  Any duplicates will have the same\\n        // connections.\\n        let (nums_len, nums) = {\\n            let (set, nums) = nums\\n                .into_iter()\\n                .fold(\\n                    (std::collections::HashSet::new(), Vec::new()),\\n                    |(mut set, mut vec), v| {\\n                        if !set.contains(&v) {\\n                            set.insert(v);\\n                            vec.push(v);\\n                        }\\n\\n                        (set, vec)\\n                    }\\n                );\\n\\n            // if the set contains 1, we know it\\'s toast\\n            // no node can connect to a node with val 1\\n            if set.contains(&1) {\\n                return false;\\n            }\\n\\n            let nums_len = nums.len();\\n            // if all dupes, then it will always succeed\\n            if nums_len == 1 {\\n                return true;\\n            }\\n\\n            // we\\'re all done with the set now\\n            (nums_len, nums)\\n        };\\n\\n        // While builing a \\'graph\\', we can keep an eye out for\\n        // any node that has no edges. (fail-fast)\\n        let mut visited = vec![false; nums_len];\\n        let mut edges = {\\n            let mut edges = std::collections::LinkedList::new();\\n            let mut j;\\n            for (i, num1) in nums.iter().enumerate() {\\n                // for each number, find all numbers bigger\\n                // does this mean we should sort?\\n\\n                let mut has_connection = false;\\n\\n                j = i + 1;\\n                while j < nums_len {\\n                    if gcd(*num1, nums[j]) > 1 {\\n                        edges.push_back((i, j));\\n                        has_connection = true;\\n                        visited[j] = true;\\n                    }\\n                    j += 1;\\n                }\\n\\n                // This node has no connections, and has never been\\n                // visited before.  This must be disconnected from the \\n                // graph.\\n                if !has_connection && !visited[i] {\\n                    return false;\\n                }\\n\\n                visited[i] = true;\\n            }\\n            edges\\n        };\\n\\n        // There must be at least N - 1 edges for N nodes\\n        // for the entire graph to be connected.\\n        let mut width = edges.len();\\n        if width < nums_len - 1 {\\n            return false;\\n        }\\n\\n        // we just need to find if the graph is fully connected via these edges.\\n        // We will be able to visit all nodes using any traversal pattern\\n        // starting from any 1 point (we will just iterate over all edges and see if all elements in nums are visited.\\n        visited[0] = false;\\n        let mut prev_width = width;\\n        let mut num_visited = 1;\\n\\n        // Technically, we are already sorted for breadth first traversal\\n        while let Some(edge) = edges.pop_front() {\\n            let newly_visited = match (visited[edge.0], visited[edge.1]) {\\n                (false, true) => Some(edge.1),\\n                (true, false) => Some(edge.0),\\n                _ => {\\n                    edges.push_back(edge);\\n                    None\\n                }\\n            };\\n\\n            if let Some(v) = newly_visited {\\n                // mark visited if first time seeing this node.\\n                visited[v] = false;\\n                num_visited += 1;\\n            }\\n\\n            width -= 1;\\n            if width == 0 {\\n                if num_visited == nums_len {\\n                    return true;\\n                }\\n\\n                // if edges is empty, we can break the loop.\\n                if edges.is_empty() {\\n                    break;\\n                }\\n\\n                // reset at the current length of edges\\n                width = edges.len();\\n\\n                // Width is used to see if we \\n                // were able to eliminate any edges\\n                // if not, we know the graph is disconnected\\n                // at some point\\n                match width == prev_width {\\n                    true => return false,\\n                    false => prev_width = width\\n                }\\n            }\\n        }\\n\\n        // if graph is connected, we should have hit every node.\\n        // A prime number for example would not\\n        // appear in any edge unless it itself is the gcd of the other number\\n        num_visited == nums_len\\n    }\\n}\\n\\n/// Finds the Greatest Common Divisor\\nfn gcd(mut a: i32, mut b: i32) -> i32 {\\n\\n    let mut temp;\\n    while b != 0 {\\n        temp = a % b;\\n        a = b;\\n        b = temp;\\n    }\\n\\n    a\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3606514,
                "title": "memory-beets-97-speed-beets-86-kind-of-diferent-approach-on-union-find",
                "content": "# Intuition\\nWe do not need to make union find for all numbers in vectors,\\nwe can only track prime factors, and use numbers to make union of primes that are used in numbers.\\n\\n# Approach\\nEvery number is broken in prime factors, prime factors used are marked as present in input array, and unions of prime noumbers are marked instead of making union find on all numbers in original array.\\n\\nprime factors biger than sqrt(10000) are treated separately as there can be only one in each number.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*\\\\ln(m))$$, amortized (union find) but more dominant is prime factorization hence $$\\\\ln(m)$$ where m is max number in nums array\\n\\n- Space complexity:\\n$$O( \\\\frac{x}{\\\\ln{x}} )$$ ie depends on noumber pf primes up to n, see [Prime counting function](https://en.wikipedia.org/wiki/Prime-counting_function)\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    //sqrt(100000)=316.227....\\n    const int primes[66]={  2,   3,   5,   7,  11,  13,  17,  19,  23,  29,  31,\\n                           37,  41,  43,  47,  53,  59,  61,  67,  71,  73,  79,  \\n                           83,  89,  97, 101, 103, 107, 109, 113, 127, 131, 137, \\n                          139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, \\n                          197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, \\n                          263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317}; // We dont need 317 but lets keep it here\\n    \\n    \\n    // we need only union find groups for primes not for all numbers, for big numbers aditional map is created.\\n    int numbersInCategory[66];\\n    int unionFindGroup[66]; \\n    \\n    void unionFindUpdate(int prevPrime,int i)\\n    {\\n        if (i==prevPrime) return;\\n        int a=std::max(prevPrime,i);\\n        int b=std::min(prevPrime,i);\\n        if (b==-1) return;\\n        if (unionFindGroup[a]!=a && unionFindGroup[a]!=b) unionFindUpdate(unionFindGroup[a],b);\\n        unionFindGroup[a]=b;\\n    }\\n\\npublic:\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        const int numsLen=nums.size();\\n\\n        if (numsLen<2) return true;\\n\\n        //init union find vec and \\n        for (int i=0;i<66;i++) numbersInCategory[i]=0,unionFindGroup[i]=i;\\n\\n        map<int,int> bigPrimes;\\n        for(int num : nums)\\n        {\\n            if (num==1) return false;\\n            int prevPrime=-1;\\n            \\n            for(int i=0;i<66;i++) // decompose number on primes and mark and make union of groups\\n            {\\n                if (num%primes[i]==0)\\n                {\\n                    if(prevPrime>-1) unionFindUpdate(prevPrime,i);\\n                    prevPrime=i;\\n                    numbersInCategory[i]+=1;\\n                }\\n                while(num%primes[i]==0) num/=primes[i];\\n                if(num==1 || primes[i]>num) break;\\n            }\\n\\n            // if noumber is not fully decomposed it means what we have left is big prime \\n            // we add it to map for big primes and mark unions it belong if any\\n            if (num>1) \\n                {\\n                    if(bigPrimes.find(num)!=bigPrimes.end()) \\n                        {   \\n                            if (bigPrimes[num]==-1) bigPrimes[num]=prevPrime;\\n                            unionFindUpdate(prevPrime,bigPrimes[num]);\\n                        }\\n                    else bigPrimes[num]=prevPrime;\\n                }\\n        }\\n        \\n        // my implementation of unionFind allows one pass compensation and flattening of groups\\n        for(int i=0;i<66;i++) unionFindGroup[i]=unionFindGroup[unionFindGroup[i]];\\n        // big primes can reference only groups in small primes...\\n        for(auto bigPrime:bigPrimes) bigPrimes[bigPrime.first]=(bigPrime.second>=0?unionFindGroup[bigPrime.second]:-1);\\n\\n        // All prime is used it has to be in same category as all other primes\\n        int category=-1;\\n        for(int i=0;i<66;i++) \\n            if(numbersInCategory[i] && unionFindGroup[i]!=category)\\n                if(category==-1) category=unionFindGroup[i]; // shold also be i this is only first category selection...\\n                else return false;\\n        for(auto bigPrime:bigPrimes) \\n            if(bigPrime.second!=category) return false;\\n        return true;\\n    }\\n};\\n\\n\\n     \\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Union Find",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    //sqrt(100000)=316.227....\\n    const int primes[66]={  2,   3,   5,   7,  11,  13,  17,  19,  23,  29,  31,\\n                           37,  41,  43,  47,  53,  59,  61,  67,  71,  73,  79,  \\n                           83,  89,  97, 101, 103, 107, 109, 113, 127, 131, 137, \\n                          139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, \\n                          197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, \\n                          263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317}; // We dont need 317 but lets keep it here\\n    \\n    \\n    // we need only union find groups for primes not for all numbers, for big numbers aditional map is created.\\n    int numbersInCategory[66];\\n    int unionFindGroup[66]; \\n    \\n    void unionFindUpdate(int prevPrime,int i)\\n    {\\n        if (i==prevPrime) return;\\n        int a=std::max(prevPrime,i);\\n        int b=std::min(prevPrime,i);\\n        if (b==-1) return;\\n        if (unionFindGroup[a]!=a && unionFindGroup[a]!=b) unionFindUpdate(unionFindGroup[a],b);\\n        unionFindGroup[a]=b;\\n    }\\n\\npublic:\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        const int numsLen=nums.size();\\n\\n        if (numsLen<2) return true;\\n\\n        //init union find vec and \\n        for (int i=0;i<66;i++) numbersInCategory[i]=0,unionFindGroup[i]=i;\\n\\n        map<int,int> bigPrimes;\\n        for(int num : nums)\\n        {\\n            if (num==1) return false;\\n            int prevPrime=-1;\\n            \\n            for(int i=0;i<66;i++) // decompose number on primes and mark and make union of groups\\n            {\\n                if (num%primes[i]==0)\\n                {\\n                    if(prevPrime>-1) unionFindUpdate(prevPrime,i);\\n                    prevPrime=i;\\n                    numbersInCategory[i]+=1;\\n                }\\n                while(num%primes[i]==0) num/=primes[i];\\n                if(num==1 || primes[i]>num) break;\\n            }\\n\\n            // if noumber is not fully decomposed it means what we have left is big prime \\n            // we add it to map for big primes and mark unions it belong if any\\n            if (num>1) \\n                {\\n                    if(bigPrimes.find(num)!=bigPrimes.end()) \\n                        {   \\n                            if (bigPrimes[num]==-1) bigPrimes[num]=prevPrime;\\n                            unionFindUpdate(prevPrime,bigPrimes[num]);\\n                        }\\n                    else bigPrimes[num]=prevPrime;\\n                }\\n        }\\n        \\n        // my implementation of unionFind allows one pass compensation and flattening of groups\\n        for(int i=0;i<66;i++) unionFindGroup[i]=unionFindGroup[unionFindGroup[i]];\\n        // big primes can reference only groups in small primes...\\n        for(auto bigPrime:bigPrimes) bigPrimes[bigPrime.first]=(bigPrime.second>=0?unionFindGroup[bigPrime.second]:-1);\\n\\n        // All prime is used it has to be in same category as all other primes\\n        int category=-1;\\n        for(int i=0;i<66;i++) \\n            if(numbersInCategory[i] && unionFindGroup[i]!=category)\\n                if(category==-1) category=unionFindGroup[i]; // shold also be i this is only first category selection...\\n                else return false;\\n        for(auto bigPrime:bigPrimes) \\n            if(bigPrime.second!=category) return false;\\n        return true;\\n    }\\n};\\n\\n\\n     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3605047,
                "title": "dsu-with-prime-factors-as-parent",
                "content": "```\\nclass DSU:\\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n        self.size = [1] * n\\n        \\n    def find(self, a):\\n        if a == self.parent[a]:\\n            return a\\n        self.parent[a] = self.find(self.parent[a])\\n        return self.parent[a]\\n        \\n    def union(self, a, b):\\n        parent_a = self.find(a)\\n        parent_b = self.find(b)\\n        if parent_a != parent_b:\\n            if self.size[parent_a] < self.size[parent_b]:\\n                parent_a, parent_b = parent_b, parent_a\\n            self.parent[parent_b] = parent_a\\n            self.size[parent_a] += self.size[parent_b]\\n\\nclass Solution:\\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\\n        if len(nums) == 1:\\n            return True\\n        if nums == [1] * len(nums):\\n            return False\\n        N = 1 + max(nums)\\n        sp = [1] * N\\n        v = [False] * N\\n        for i in range(2, N, 2):\\n            sp[i] = 2\\n        for i in range(3, N, 2):\\n            if not v[i]:\\n                sp[i] = i\\n                j = i\\n                while j * i < N:\\n                    v[j * i] = True\\n                    sp[j * i] = i\\n                    j += 2\\n        dsu = DSU(N)\\n        for el in nums:\\n            curr = el\\n            while curr > 1:\\n                dsu.union(el, sp[curr])\\n                curr //= sp[curr]\\n        comps = set()\\n        for el in nums:\\n            comps.add(dsu.find(el))\\n        return len(comps) == 1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass DSU:\\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n        self.size = [1] * n\\n        \\n    def find(self, a):\\n        if a == self.parent[a]:\\n            return a\\n        self.parent[a] = self.find(self.parent[a])\\n        return self.parent[a]\\n        \\n    def union(self, a, b):\\n        parent_a = self.find(a)\\n        parent_b = self.find(b)\\n        if parent_a != parent_b:\\n            if self.size[parent_a] < self.size[parent_b]:\\n                parent_a, parent_b = parent_b, parent_a\\n            self.parent[parent_b] = parent_a\\n            self.size[parent_a] += self.size[parent_b]\\n\\nclass Solution:\\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\\n        if len(nums) == 1:\\n            return True\\n        if nums == [1] * len(nums):\\n            return False\\n        N = 1 + max(nums)\\n        sp = [1] * N\\n        v = [False] * N\\n        for i in range(2, N, 2):\\n            sp[i] = 2\\n        for i in range(3, N, 2):\\n            if not v[i]:\\n                sp[i] = i\\n                j = i\\n                while j * i < N:\\n                    v[j * i] = True\\n                    sp[j * i] = i\\n                    j += 2\\n        dsu = DSU(N)\\n        for el in nums:\\n            curr = el\\n            while curr > 1:\\n                dsu.union(el, sp[curr])\\n                curr //= sp[curr]\\n        comps = set()\\n        for el in nums:\\n            comps.add(dsu.find(el))\\n        return len(comps) == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597109,
                "title": "using-dfs-isconnected-algo-logical",
                "content": "\\n\\n# Code\\n```\\n// in this we have to create an undirected graph : not directed graph:\\n// for ex: [2,3,6]=> 2->6\\n                //.  3->6. \\n// considering directed graph: then it will fail in this case.\\n\\n////////////////////////////////////////////////////////////////////////\\n\\n// now we have to find an undirectd graph\\n// and then to check whether grpah is connected or not.\\n// if graph is connected this means every node is reachable \\n// is connected then return true for the answer also \\n\\n///////////////////////////////////////////////////////////////\\n\\n// now giving tle as unnecesssary connected are created if we directlty do connections that is not using getprimefactors but by using directly gcd\\n// then we will get tle\\n// so using this getprimefactors method: only neccessary connections are built => so not giving tle then\\n\\n//////////////////////////////////////////////////////////////////\\n\\n// we can use dsu here : let\\'s check that now\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\nvector<int> getPrimeFactors(int x) {\\n        vector<int> primeFactors;\\n        for (int i = 2; i * i <= x; i++) {\\n            if (x % i == 0) {\\n                primeFactors.push_back(i);\\n                while (x % i == 0) {\\n                    x /= i;\\n                }\\n            }\\n        }\\n        if (x != 1) {\\n            primeFactors.push_back(x);\\n        }\\n        return primeFactors;\\n    }\\nvoid dfs(map<int, vector<int>>& graph, vector<bool>& visited, int node) {\\n    visited[node] = true;\\n\\n    for (int neighbor : graph[node]) {\\n        if (!visited[neighbor]) {\\n            dfs(graph, visited, neighbor);\\n        }\\n    }\\n}\\n\\nbool isConnected(map<int, vector<int>>& graph, int n) {\\n    vector<bool> visited(n, false);  \\n\\n    dfs(graph, visited, 0);  \\n\\n    for (bool isVisited : visited) {\\n        if (!isVisited)\\n            return false;\\n    }\\n\\n    return true;\\n}\\n\\n\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n\\n        vector<pair<pair<int,int>,int>>vec;\\n        map<int, vector<int>> mp;\\n        int n=nums.size();\\n        if(n==1){\\n            return true;\\n        }\\nunordered_map<int, int> seen;\\nfor (int i = 0; i < n; i++) {\\n            if (nums[i] == 1) {\\n                return false;\\n            }\\n            vector<int> primeFactors = getPrimeFactors(nums[i]);\\n            for (int prime: primeFactors) {\\n                if (seen.find(prime) != seen.end()) {\\n                    mp[i].push_back(seen[prime]);\\n                    mp[seen[prime]].push_back(i);\\n                } else {\\n                    seen[prime] = i;\\n                }\\n            }\\n        }\\n        return isConnected(mp, n) ;\\n        \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph",
                    "Number Theory"
                ],
                "code": "```\\n// in this we have to create an undirected graph : not directed graph:\\n// for ex: [2,3,6]=> 2->6\\n                //.  3->6. \\n// considering directed graph: then it will fail in this case.\\n\\n////////////////////////////////////////////////////////////////////////\\n\\n// now we have to find an undirectd graph\\n// and then to check whether grpah is connected or not.\\n// if graph is connected this means every node is reachable \\n// is connected then return true for the answer also \\n\\n///////////////////////////////////////////////////////////////\\n\\n// now giving tle as unnecesssary connected are created if we directlty do connections that is not using getprimefactors but by using directly gcd\\n// then we will get tle\\n// so using this getprimefactors method: only neccessary connections are built => so not giving tle then\\n\\n//////////////////////////////////////////////////////////////////\\n\\n// we can use dsu here : let\\'s check that now\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\nvector<int> getPrimeFactors(int x) {\\n        vector<int> primeFactors;\\n        for (int i = 2; i * i <= x; i++) {\\n            if (x % i == 0) {\\n                primeFactors.push_back(i);\\n                while (x % i == 0) {\\n                    x /= i;\\n                }\\n            }\\n        }\\n        if (x != 1) {\\n            primeFactors.push_back(x);\\n        }\\n        return primeFactors;\\n    }\\nvoid dfs(map<int, vector<int>>& graph, vector<bool>& visited, int node) {\\n    visited[node] = true;\\n\\n    for (int neighbor : graph[node]) {\\n        if (!visited[neighbor]) {\\n            dfs(graph, visited, neighbor);\\n        }\\n    }\\n}\\n\\nbool isConnected(map<int, vector<int>>& graph, int n) {\\n    vector<bool> visited(n, false);  \\n\\n    dfs(graph, visited, 0);  \\n\\n    for (bool isVisited : visited) {\\n        if (!isVisited)\\n            return false;\\n    }\\n\\n    return true;\\n}\\n\\n\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n\\n        vector<pair<pair<int,int>,int>>vec;\\n        map<int, vector<int>> mp;\\n        int n=nums.size();\\n        if(n==1){\\n            return true;\\n        }\\nunordered_map<int, int> seen;\\nfor (int i = 0; i < n; i++) {\\n            if (nums[i] == 1) {\\n                return false;\\n            }\\n            vector<int> primeFactors = getPrimeFactors(nums[i]);\\n            for (int prime: primeFactors) {\\n                if (seen.find(prime) != seen.end()) {\\n                    mp[i].push_back(seen[prime]);\\n                    mp[seen[prime]].push_back(i);\\n                } else {\\n                    seen[prime] = i;\\n                }\\n            }\\n        }\\n        return isConnected(mp, n) ;\\n        \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595614,
                "title": "python3-prime-factorisation-bfs",
                "content": "# Code\\n```\\ndef bfs(graph, i, visited):\\n    visited[i] = 1\\n    ans = []\\n    queue, idx = [i], 0\\n    while idx < len(queue):\\n        src = queue[idx]\\n        ans.append(src)\\n        idx += 1\\n        for p in graph[src]:\\n            if visited[p]==0:\\n                queue.append(p)\\n                visited[p]=1\\n    return visited,ans\\n\\ndef primefactors(n):\\n    ans = set()\\n    while not n % 2:\\n        ans.add(2)\\n        n //= 2\\n    for i in range(3,int(math.sqrt(n))+1,2):\\n        while not n % i:\\n            ans.add(i)\\n            n //= i\\n    if n > 2:\\n        ans.add(n)\\n    return list(ans)\\n\\nclass Solution:\\n    def canTraverseAllPairs(self, a: List[int]) -> bool:\\n        n, d = len(a), {}\\n        graph, visited = {}, []\\n        for i in range(n):\\n            graph[i] = []\\n            visited.append(0)\\n            p = primefactors(a[i])\\n            for j in p:\\n                if d.get(j) == None:\\n                    d[j] = [i]\\n                else:\\n                    d[j].append(i)\\n\\n        for i in d.keys():\\n            q=len(d[i])\\n            for j in range(q - 1):\\n                x, y = d[i][j], d[i][j+1]\\n                graph[x].append(y)\\n                graph[y].append(x)\\n\\n        for i in range(n):\\n            if visited[i] == 0:\\n                visited, comp = bfs(graph, i, visited)\\n                if len(comp) == n:\\n                    return True\\n                else:\\n                    return False  \\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\ndef bfs(graph, i, visited):\\n    visited[i] = 1\\n    ans = []\\n    queue, idx = [i], 0\\n    while idx < len(queue):\\n        src = queue[idx]\\n        ans.append(src)\\n        idx += 1\\n        for p in graph[src]:\\n            if visited[p]==0:\\n                queue.append(p)\\n                visited[p]=1\\n    return visited,ans\\n\\ndef primefactors(n):\\n    ans = set()\\n    while not n % 2:\\n        ans.add(2)\\n        n //= 2\\n    for i in range(3,int(math.sqrt(n))+1,2):\\n        while not n % i:\\n            ans.add(i)\\n            n //= i\\n    if n > 2:\\n        ans.add(n)\\n    return list(ans)\\n\\nclass Solution:\\n    def canTraverseAllPairs(self, a: List[int]) -> bool:\\n        n, d = len(a), {}\\n        graph, visited = {}, []\\n        for i in range(n):\\n            graph[i] = []\\n            visited.append(0)\\n            p = primefactors(a[i])\\n            for j in p:\\n                if d.get(j) == None:\\n                    d[j] = [i]\\n                else:\\n                    d[j].append(i)\\n\\n        for i in d.keys():\\n            q=len(d[i])\\n            for j in range(q - 1):\\n                x, y = d[i][j], d[i][j+1]\\n                graph[x].append(y)\\n                graph[y].append(x)\\n\\n        for i in range(n):\\n            if visited[i] == 0:\\n                visited, comp = bfs(graph, i, visited)\\n                if len(comp) == n:\\n                    return True\\n                else:\\n                    return False  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594075,
                "title": "easy-union-find",
                "content": "# Intuition\\nAssume that all elements of the array are a vector of their prime factors. Then establish links between the traversable indexes. If for any factor x, k elements are their whose prime factor is x, then it\\'s not necessary to create k^2 links between them. Establishing a one to one relation between them is sufficient. \\nAnd here comes the idea for Union - Find.\\n# Approach\\nWe will store index of the last appearence of the prime factor in a map to make connections between an index and a previously appeared number which also has same prime factor.\\nTraverse for each index and find it\\'s prime factors. If that prime factor has not appeared before in previous indexes then no connection was their for this number with the previous indexes for this prime factor (maybe for other prime factors their exists connections). So,\\njust include that element in map. Now if that element exists, then union that with its previously appeared position and update the new position of the factor in map.\\nFinally, if all elements have only 1 parent, then this means all are traversable, else false.\\n# Complexity\\n- Time complexity:\\nO( N*root (Max(a[i])) )\\n- Space complexity:\\nO ( N )\\n# Code\\n```\\nclass Solution {\\npublic:    \\n    bool canTraverseAllPairs(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        map<int, int> mpr;\\n        vector<int> par(n);\\n        vector<int> rank(n);\\n        for(int i = 0; i < n; i++)\\n        {\\n            par[i] = i;\\n            rank[i] = 0;\\n        }\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            int a = nums[i];\\n            for(int w = 2; w*w <= a; w++)\\n            {\\n                if(a % w == 0)\\n                {\\n                    if(mpr.find(w) == mpr.end())\\n                    {\\n                        mpr[w] = i;\\n                    }\\n                    else \\n                    {\\n                        union_fun(i, mpr[w], rank, par);\\n                        mpr[w] = i;\\n                    }\\n                }\\n                \\n                while(a % w == 0)\\n                {\\n                    a = a/w;\\n                }\\n            }\\n            \\n            if(a != 1)\\n            {\\n                if(mpr.find(a) == mpr.end())\\n                {\\n                    mpr[a] = i;\\n                }\\n                else \\n                {\\n                    union_fun(i, mpr[a], rank, par);\\n                    mpr[a] = i;\\n                }\\n            }\\n        }\\n\\n        set<int> st;        \\n        for(int i = 0; i < n; i++)\\n        {\\n            st.insert(find(par, i));\\n            if(st.size() > 1)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int find(vector<int>&par, int x)\\n    {\\n        while(x != par[x])\\n        {\\n            par[x] = par[par[x]];\\n            x = par[x];\\n        }\\n        return x;\\n    }\\n\\n    void union_fun(int p, int q, vector<int>&rank, vector<int>&par)\\n    {\\n        int a = find(par, p);\\n        int b = find(par, q);\\n\\n        if(rank[a] == rank[b])\\n        {\\n            par[a] = b;\\n            rank[b]++;\\n        }\\n        else if(rank[a] > rank[b])\\n        {\\n            par[b] = a;\\n        }\\n        else \\n        {\\n            par[a] = b;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:    \\n    bool canTraverseAllPairs(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        map<int, int> mpr;\\n        vector<int> par(n);\\n        vector<int> rank(n);\\n        for(int i = 0; i < n; i++)\\n        {\\n            par[i] = i;\\n            rank[i] = 0;\\n        }\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            int a = nums[i];\\n            for(int w = 2; w*w <= a; w++)\\n            {\\n                if(a % w == 0)\\n                {\\n                    if(mpr.find(w) == mpr.end())\\n                    {\\n                        mpr[w] = i;\\n                    }\\n                    else \\n                    {\\n                        union_fun(i, mpr[w], rank, par);\\n                        mpr[w] = i;\\n                    }\\n                }\\n                \\n                while(a % w == 0)\\n                {\\n                    a = a/w;\\n                }\\n            }\\n            \\n            if(a != 1)\\n            {\\n                if(mpr.find(a) == mpr.end())\\n                {\\n                    mpr[a] = i;\\n                }\\n                else \\n                {\\n                    union_fun(i, mpr[a], rank, par);\\n                    mpr[a] = i;\\n                }\\n            }\\n        }\\n\\n        set<int> st;        \\n        for(int i = 0; i < n; i++)\\n        {\\n            st.insert(find(par, i));\\n            if(st.size() > 1)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int find(vector<int>&par, int x)\\n    {\\n        while(x != par[x])\\n        {\\n            par[x] = par[par[x]];\\n            x = par[x];\\n        }\\n        return x;\\n    }\\n\\n    void union_fun(int p, int q, vector<int>&rank, vector<int>&par)\\n    {\\n        int a = find(par, p);\\n        int b = find(par, q);\\n\\n        if(rank[a] == rank[b])\\n        {\\n            par[a] = b;\\n            rank[b]++;\\n        }\\n        else if(rank[a] > rank[b])\\n        {\\n            par[b] = a;\\n        }\\n        else \\n        {\\n            par[a] = b;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592788,
                "title": "easy-union-find",
                "content": "# Intuition\\nAssume that all elements of the array are a vector of their prime factors. Then establish links between the traversable indexes. If for any factor x, k elements are their whose prime factor is k, then it\\'s not necessary to create k^2 links between them. Establishing a one to one relation between them is sufficient. \\nAnd here comes the idea for Union - Find.\\n# Approach\\nWe will store index of the last appearence of the prime factor in a map to make connections between an index and a previously appeared number which also has same prime factor.\\nTraverse for each index and find it\\'s prime factors. If that prime factor has not appeared before in previous indexes then no connection was their for this number with the previous indexes for this prime factor (maybe for other prime factors their exists connections). So,\\njust include that element in map. Now if that element exists, then union that with its previously appeared position and update the new position of the factor in map.\\nFinally, if all elements have only 1 parent, then this means all are traversable, else false.\\n# Complexity\\n- Time complexity:\\nO( N*root (Max(a[i])) )\\n- Space complexity:\\nO ( N )\\n# Code\\n```\\nclass Solution {\\npublic:    \\n    bool canTraverseAllPairs(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        map<int, int> mpr;\\n        vector<int> par(n);\\n        vector<int> rank(n);\\n        for(int i = 0; i < n; i++)\\n        {\\n            par[i] = i;\\n            rank[i] = 0;\\n        }\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            int a = nums[i];\\n            for(int w = 2; w*w <= a; w++)\\n            {\\n                if(a % w == 0)\\n                {\\n                    if(mpr.find(w) == mpr.end())\\n                    {\\n                        mpr[w] = i;\\n                    }\\n                    else \\n                    {\\n                        union_fun(i, mpr[w], rank, par);\\n                        mpr[w] = i;\\n                    }\\n                }\\n                \\n                while(a % w == 0)\\n                {\\n                    a = a/w;\\n                }\\n            }\\n            \\n            if(a != 1)\\n            {\\n                if(mpr.find(a) == mpr.end())\\n                {\\n                    mpr[a] = i;\\n                }\\n                else \\n                {\\n                    union_fun(i, mpr[a], rank, par);\\n                    mpr[a] = i;\\n                }\\n            }\\n        }\\n\\n        set<int> st;        \\n        for(int i = 0; i < n; i++)\\n        {\\n            st.insert(find(par, i));\\n            if(st.size() > 1)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int find(vector<int>&par, int x)\\n    {\\n        while(x != par[x])\\n        {\\n            par[x] = par[par[x]];\\n            x = par[x];\\n        }\\n        return x;\\n    }\\n\\n    void union_fun(int p, int q, vector<int>&rank, vector<int>&par)\\n    {\\n        int a = find(par, p);\\n        int b = find(par, q);\\n\\n        if(rank[a] == rank[b])\\n        {\\n            par[a] = b;\\n            rank[b]++;\\n        }\\n        else if(rank[a] > rank[b])\\n        {\\n            par[b] = a;\\n        }\\n        else \\n        {\\n            par[a] = b;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:    \\n    bool canTraverseAllPairs(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        map<int, int> mpr;\\n        vector<int> par(n);\\n        vector<int> rank(n);\\n        for(int i = 0; i < n; i++)\\n        {\\n            par[i] = i;\\n            rank[i] = 0;\\n        }\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            int a = nums[i];\\n            for(int w = 2; w*w <= a; w++)\\n            {\\n                if(a % w == 0)\\n                {\\n                    if(mpr.find(w) == mpr.end())\\n                    {\\n                        mpr[w] = i;\\n                    }\\n                    else \\n                    {\\n                        union_fun(i, mpr[w], rank, par);\\n                        mpr[w] = i;\\n                    }\\n                }\\n                \\n                while(a % w == 0)\\n                {\\n                    a = a/w;\\n                }\\n            }\\n            \\n            if(a != 1)\\n            {\\n                if(mpr.find(a) == mpr.end())\\n                {\\n                    mpr[a] = i;\\n                }\\n                else \\n                {\\n                    union_fun(i, mpr[a], rank, par);\\n                    mpr[a] = i;\\n                }\\n            }\\n        }\\n\\n        set<int> st;        \\n        for(int i = 0; i < n; i++)\\n        {\\n            st.insert(find(par, i));\\n            if(st.size() > 1)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int find(vector<int>&par, int x)\\n    {\\n        while(x != par[x])\\n        {\\n            par[x] = par[par[x]];\\n            x = par[x];\\n        }\\n        return x;\\n    }\\n\\n    void union_fun(int p, int q, vector<int>&rank, vector<int>&par)\\n    {\\n        int a = find(par, p);\\n        int b = find(par, q);\\n\\n        if(rank[a] == rank[b])\\n        {\\n            par[a] = b;\\n            rank[b]++;\\n        }\\n        else if(rank[a] > rank[b])\\n        {\\n            par[b] = a;\\n        }\\n        else \\n        {\\n            par[a] = b;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592665,
                "title": "javascript-union-find",
                "content": "**Solution: Union Find**\\n\\n**Key point**: For all pairs of indices to be traversable, all nodes must be connected.\\nFind the prime factors of each number (there are about `log(n)` prime factors per number).\\nKeep a map of factors to any number with that prime factor so far: `{prime factor: index, prime factor: index, ...}`\\n  **Note**: We don\\'t need to connect with every single number with that prime factor since connecting to just one number means we will also connect with all other numbers that are already connected.\\nUse union find to connect numbers that share the same prime factors.\\n\\nTime Complexity: `O(n log(n))` 701ms\\nSpace Complexity: `O(n)` 72.8MB\\n```\\nvar canTraverseAllPairs = function(nums) {\\n  let n = nums.length, map = new Map(), uf = new UnionFind(n);\\n  for (let i = 0; i < n; i++) {\\n    let primeFactors = getPrimeFactors(nums[i]);\\n    for (let factor of primeFactors) {\\n      if (map.has(factor)) uf.union(i, map.get(factor));\\n      else map.set(factor, i);\\n    }\\n  }\\n  return uf.size === 1;\\n};\\n\\nfunction getPrimeFactors(n) {\\n  let res = new Set();\\n  for (let x = 2; (x * x) <= n; x++) {\\n    // loop while n is divisible by x\\n    while (n % x === 0) {\\n      res.add(x);\\n      n /= x;\\n    }\\n  }\\n  if (n > 1) res.add(n);\\n  return res;\\n}\\n\\nclass UnionFind {\\n  constructor(size) {\\n    this.size = size;\\n    this.root = Array(size);\\n    this.rank = Array(size);\\n    for (let i = 0; i < size; i++) {\\n      this.root[i] = i;\\n      this.rank[i] = 1;\\n    }\\n  }\\n  find(x) {\\n    if (this.root[x] === x) return x;\\n    return this.root[x] = this.find(this.root[x]);\\n  }\\n  union(x, y) {\\n    let rootX = this.find(x), rootY = this.find(y);\\n    if (rootX === rootY) return false;\\n    if (this.rank[rootX] < this.rank[rootY]) {\\n      this.root[rootX] = rootY;\\n    } else if (this.rank[rootX] > this.rank[rootY]) {\\n      this.root[rootY] = rootX;\\n    } else {\\n      this.root[rootY] = rootX;\\n      this.rank[rootX]++;\\n    }\\n    this.size--;\\n    return true;\\n  }\\n  isConnected(x, y) {\\n    return this.find(x) === this.find(y);\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canTraverseAllPairs = function(nums) {\\n  let n = nums.length, map = new Map(), uf = new UnionFind(n);\\n  for (let i = 0; i < n; i++) {\\n    let primeFactors = getPrimeFactors(nums[i]);\\n    for (let factor of primeFactors) {\\n      if (map.has(factor)) uf.union(i, map.get(factor));\\n      else map.set(factor, i);\\n    }\\n  }\\n  return uf.size === 1;\\n};\\n\\nfunction getPrimeFactors(n) {\\n  let res = new Set();\\n  for (let x = 2; (x * x) <= n; x++) {\\n    // loop while n is divisible by x\\n    while (n % x === 0) {\\n      res.add(x);\\n      n /= x;\\n    }\\n  }\\n  if (n > 1) res.add(n);\\n  return res;\\n}\\n\\nclass UnionFind {\\n  constructor(size) {\\n    this.size = size;\\n    this.root = Array(size);\\n    this.rank = Array(size);\\n    for (let i = 0; i < size; i++) {\\n      this.root[i] = i;\\n      this.rank[i] = 1;\\n    }\\n  }\\n  find(x) {\\n    if (this.root[x] === x) return x;\\n    return this.root[x] = this.find(this.root[x]);\\n  }\\n  union(x, y) {\\n    let rootX = this.find(x), rootY = this.find(y);\\n    if (rootX === rootY) return false;\\n    if (this.rank[rootX] < this.rank[rootY]) {\\n      this.root[rootX] = rootY;\\n    } else if (this.rank[rootX] > this.rank[rootY]) {\\n      this.root[rootY] = rootX;\\n    } else {\\n      this.root[rootY] = rootX;\\n      this.rank[rootX]++;\\n    }\\n    this.size--;\\n    return true;\\n  }\\n  isConnected(x, y) {\\n    return this.find(x) === this.find(y);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592281,
                "title": "c-union-find-math",
                "content": "# Intuition\\nMerge all indices with common prime factors and if the graph contains a single connected component then answer is true else false.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> par,rank;\\n    int findPar(int x)\\n    {\\n        if(x==par[x])\\n        return x;\\n        return par[x] = findPar(par[x]);\\n    }\\n    void Union(int x,int y)\\n    {\\n        int u = findPar(x);\\n        int v = findPar(y);\\n        if(u==v)\\n        return;\\n        if(rank[v]>rank[u])\\n        {\\n            rank[v]+=rank[u];\\n            par[u] = v;\\n        }\\n        else\\n        {\\n            rank[u]+=rank[v];\\n            par[v] = u;\\n        }\\n    }\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int n = nums.size();\\n        par.resize(n);\\n        rank.resize(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            par[i] = i;\\n            rank[i] = 1;\\n        }\\n        int maxi = *max_element(nums.begin(),nums.end());\\n        vector<int> tmp(maxi+1,-1);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=2;j*j<=nums[i];j++)\\n            {\\n                if(nums[i]%j!=0)\\n                continue;\\n                if(tmp[j]!=-1)\\n                Union(tmp[j],i);\\n                else\\n                tmp[j] = i;\\n                while(nums[i]%j==0)\\n                nums[i]/=j;\\n            }\\n            if(nums[i]>1)\\n            {\\n                if(tmp[nums[i]]!=-1)\\n                Union(tmp[nums[i]],i);\\n                else\\n                tmp[nums[i]] = i;\\n            }\\n        }\\n        if(rank[findPar(0)]==n)\\n        return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> par,rank;\\n    int findPar(int x)\\n    {\\n        if(x==par[x])\\n        return x;\\n        return par[x] = findPar(par[x]);\\n    }\\n    void Union(int x,int y)\\n    {\\n        int u = findPar(x);\\n        int v = findPar(y);\\n        if(u==v)\\n        return;\\n        if(rank[v]>rank[u])\\n        {\\n            rank[v]+=rank[u];\\n            par[u] = v;\\n        }\\n        else\\n        {\\n            rank[u]+=rank[v];\\n            par[v] = u;\\n        }\\n    }\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int n = nums.size();\\n        par.resize(n);\\n        rank.resize(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            par[i] = i;\\n            rank[i] = 1;\\n        }\\n        int maxi = *max_element(nums.begin(),nums.end());\\n        vector<int> tmp(maxi+1,-1);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=2;j*j<=nums[i];j++)\\n            {\\n                if(nums[i]%j!=0)\\n                continue;\\n                if(tmp[j]!=-1)\\n                Union(tmp[j],i);\\n                else\\n                tmp[j] = i;\\n                while(nums[i]%j==0)\\n                nums[i]/=j;\\n            }\\n            if(nums[i]>1)\\n            {\\n                if(tmp[nums[i]]!=-1)\\n                Union(tmp[nums[i]],i);\\n                else\\n                tmp[nums[i]] = i;\\n            }\\n        }\\n        if(rank[findPar(0)]==n)\\n        return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3589307,
                "title": "c-detailed-solution-using-graphical-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo check the prime factors of all the numbers in the nums array and then use the graphcal approch to find whether all the possible pairs are covered!\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSince the maximum number in the given array is 10^5 hence we calculte the prime numbers till square root of 10^5+10 ( +10 is considered extra which will not affect on the time ans space complexity) and then consecutively check the them against the numbers in the given array. If any of prime numbers in the prime array divides a number in the given array nums is considered as used by marking them in map \"con\" by its index. If the prime number is previously used then a undirected graphical bridge is formed between the present number and the number which is previously divisible by the prime number by considering their indices as nodes.\\n\\nHowever, if we encounter a number which is in the range of 10^3-10^5 and is a prime number itself in the given array, e.g 10007, it is not included in the prime number array we have formed as 10007 > sqrt(100010), hence we will add it in the prime number array and update it in the con map as marked by it\\'s index. Otherwise if we concounter 20014 or 30021 in the following indices of the given array then we will not be able to form a undirected bridge between 10007 and 20014 or 10007 and 30021 which will result in wrong answer. But we will keep a count of such as possibilities along with adding the number(e.g 10007) in prime array and updating it in the \"con\" map, because we observe that if we encounter more than one such prime numbers( > sqrt(100010)) in the given array then to satisfy the required condition of getting the output as \"true\" we must have a number in the array which will be the multiple of that two prime numbers and it must greater than 10^5( 10^3*10^3= 10^6 > 10^5), so we will directly return \"false\".\\n\\nAfter making the undirected graph we will traverse them and if we are able to traverse it in one go then return true otherwise false.\\n# Complexity\\n- Time complexity: O(n*(size of vector containing prime numbers))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) + O(n+(number of pairs))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<int>adj[],int u,vector<int>&vis){\\n        vis[u]=1;\\n        for(auto v: adj[u]){\\n            if(!vis[v])\\n               dfs(adj,v,vis);\\n        }\\n    }\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int n= nums.size();\\n        vector<int>adj[n];\\n        set<int>st;\\n        vector<int>prime;\\n        for(int i=2;i<sqrt(100010);i++){\\n            if(st.find(i)!=st.end())\\n               continue;\\n            prime.push_back(i);\\n            for(int j=i;j<sqrt(100010);j+=i)\\n               st.insert(j);\\n        }\\n        map<int,int>con;\\n        int tot=0;\\n        for(int i=0;i<nums.size();i++){\\n            int flag=0;\\n            for(int j=0;j<prime.size();j++){\\n                if(prime[j] > nums[i])\\n                   break;\\n                if(nums[i]%prime[j]==0){\\n                    flag=1;\\n                    if(con[j]!=0){\\n                        adj[i].push_back(con[j]-1);\\n                        adj[con[j]-1].push_back(i);\\n                    }\\n                    else\\n                       con[j]= i+1;\\n                }\\n            }\\n            if(flag==0){\\n                if(tot)\\n                   return false;\\n                prime.push_back(nums[i]);\\n                int m= prime.size();\\n                con[m-1]=i+1;\\n                tot++;\\n            }\\n        }\\n        vector<int>vis(n,0);\\n        int no=0;\\n        for(int i=0;i<n;i++){\\n            if(vis[i]==0){\\n                dfs(adj,i,vis);\\n                no++;\\n            }\\n        }\\n        if(no>1)\\n          return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<int>adj[],int u,vector<int>&vis){\\n        vis[u]=1;\\n        for(auto v: adj[u]){\\n            if(!vis[v])\\n               dfs(adj,v,vis);\\n        }\\n    }\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int n= nums.size();\\n        vector<int>adj[n];\\n        set<int>st;\\n        vector<int>prime;\\n        for(int i=2;i<sqrt(100010);i++){\\n            if(st.find(i)!=st.end())\\n               continue;\\n            prime.push_back(i);\\n            for(int j=i;j<sqrt(100010);j+=i)\\n               st.insert(j);\\n        }\\n        map<int,int>con;\\n        int tot=0;\\n        for(int i=0;i<nums.size();i++){\\n            int flag=0;\\n            for(int j=0;j<prime.size();j++){\\n                if(prime[j] > nums[i])\\n                   break;\\n                if(nums[i]%prime[j]==0){\\n                    flag=1;\\n                    if(con[j]!=0){\\n                        adj[i].push_back(con[j]-1);\\n                        adj[con[j]-1].push_back(i);\\n                    }\\n                    else\\n                       con[j]= i+1;\\n                }\\n            }\\n            if(flag==0){\\n                if(tot)\\n                   return false;\\n                prime.push_back(nums[i]);\\n                int m= prime.size();\\n                con[m-1]=i+1;\\n                tot++;\\n            }\\n        }\\n        vector<int>vis(n,0);\\n        int no=0;\\n        for(int i=0;i<n;i++){\\n            if(vis[i]==0){\\n                dfs(adj,i,vis);\\n                no++;\\n            }\\n        }\\n        if(no>1)\\n          return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584645,
                "title": "c-solution-dsu-prime-factors",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(mx*log(mx))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(mx)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DSU{\\n    public:\\n    map<int,int>par;\\n    \\n    DSU(int mx){\\n        for(int i=1;i<=mx;i++){\\n            par[i] = i;\\n        }\\n    }\\n    \\n    int find(int x){\\n        if(par[x] == x) return x;\\n        return par[x] = find(par[x]);\\n    }\\n    \\n    void join(int a,int b){\\n        int par_a = find(a);\\n        int par_b = find(b);\\n        \\n        par[par_b] = par_a;\\n       \\n        return;\\n    }\\n    \\n};\\n\\nclass Solution {\\npublic:\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        \\n        map<int,int>mp;\\n        for(auto it : nums){\\n            mp[it]++;\\n        }\\n        \\n        int mx = *max_element(nums.begin(),nums.end());\\n        int mn = *min_element(nums.begin(),nums.end());\\n        DSU *dsu = new DSU(mx);\\n        if(nums.size() == 1) return 1;\\n        \\n        if(mn == 1) return false;\\n\\n\\n        vector<int>dp(mx+1,0);\\n        for(int i=2;i<=mx;i++){\\n            dp[i] = i;\\n        }\\n        \\n        \\n        for(int i=2;i<=mx;i++){\\n            if(dsu->find(i)!=i) continue;\\n            for(int j=i;j<=mx;j+=i){\\n                if(mp.count(j)){\\n                    dsu->join(i,j);\\n                }\\n            }\\n        }\\n        int par = dsu->find(nums[0]);\\n        for(int i=0;i<nums.size();i++){\\n            if(dsu->find(nums[i])!=par){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass DSU{\\n    public:\\n    map<int,int>par;\\n    \\n    DSU(int mx){\\n        for(int i=1;i<=mx;i++){\\n            par[i] = i;\\n        }\\n    }\\n    \\n    int find(int x){\\n        if(par[x] == x) return x;\\n        return par[x] = find(par[x]);\\n    }\\n    \\n    void join(int a,int b){\\n        int par_a = find(a);\\n        int par_b = find(b);\\n        \\n        par[par_b] = par_a;\\n       \\n        return;\\n    }\\n    \\n};\\n\\nclass Solution {\\npublic:\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        \\n        map<int,int>mp;\\n        for(auto it : nums){\\n            mp[it]++;\\n        }\\n        \\n        int mx = *max_element(nums.begin(),nums.end());\\n        int mn = *min_element(nums.begin(),nums.end());\\n        DSU *dsu = new DSU(mx);\\n        if(nums.size() == 1) return 1;\\n        \\n        if(mn == 1) return false;\\n\\n\\n        vector<int>dp(mx+1,0);\\n        for(int i=2;i<=mx;i++){\\n            dp[i] = i;\\n        }\\n        \\n        \\n        for(int i=2;i<=mx;i++){\\n            if(dsu->find(i)!=i) continue;\\n            for(int j=i;j<=mx;j+=i){\\n                if(mp.count(j)){\\n                    dsu->join(i,j);\\n                }\\n            }\\n        }\\n        int par = dsu->find(nums[0]);\\n        for(int i=0;i<nums.size();i++){\\n            if(dsu->find(nums[i])!=par){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579745,
                "title": "c-union-find-simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nclass UF {\\n    public:\\n        vector<int> par;\\n        vector<int> rank;\\n        int seperate;//number of seperate component\\n        UF(int n) {\\n            for (int i = 0; i < n; i++) {\\n                par.push_back(i);\\n                rank.push_back(0);\\n            }\\n            seperate = n;\\n        }\\n        int findfather(int x) {\\n            while (x != par[x]) {\\n                par[x] = par[par[x]];\\n                x = par[x];\\n            }\\n            return x;\\n        }\\n        int unionnodes(int x1, int x2) {//return 0 if the two component is already connected, 1 otherwise (union success)\\n            int p1 = findfather(x1);\\n            int p2 = findfather(x2);\\n            if (p1 == p2) {\\n                return 0;\\n            }\\n            if (rank[p1] > rank[p2]) {\\n                rank[p1] += rank[p2];\\n                par[p2] = p1;\\n            }\\n            else {\\n                rank[p2] += rank[p1];\\n                par[p1] = p2;\\n            }\\n            seperate -= 1;\\n            return 1;\\n        }\\n        bool isConnected() {\\n            return seperate <= 1;\\n        }\\n    };\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        if (nums.size()==1) return true;\\n        UF* u = new UF(nums.size());\\n        //sqrt(100000) = 316\\n        vector<int> prime = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199,211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313};\\n        unordered_map<int,int> num;\\n        for (int i=0; i< nums.size();i++){\\n            num[nums[i]]++;\\n        }\\n        if (num.size()==1 && nums[0] !=1) return true;\\n        unordered_map<int,vector<int>> mp;//key:value - prime factor: index\\n        for (int i=0; i< nums.size();i++){\\n            int n = nums[i];\\n            //find prime factors of n\\n            bool bigprime = true;\\n            for (int j=0; j< prime.size();j++){\\n                if (n< prime[j]) break;\\n                if (n % prime[j] ==0){\\n                    bigprime = false;\\n                    while (n % prime[j] ==0){\\n                        n /= prime[j];\\n                    }\\n                    mp[prime[j]].push_back(i);\\n                }\\n            }\\n            //add the remaining prime part of n to the hash map (big primes)\\n            if (n >316 && bigprime && mp.find(n) == mp.end()){\\n                int multiple = 1;\\n                bool returnfalse = true;\\n                while (multiple * n <=100000){\\n                    if (multiple * n != nums[i] && num.find(multiple * n) != num.end()  ){\\n                        returnfalse = false;\\n                        break;\\n                    }\\n                    multiple++;\\n                }\\n                if (returnfalse) return false;//single element with big prime factors\\n                prime.push_back(n);\\n                sort(prime.begin(),prime.end());\\n                mp[n].push_back(i);\\n            }\\n\\n        }\\n        for (auto &e: mp){\\n            for (int i=1; i< e.second.size();i++){\\n                u-> unionnodes(e.second[i],e.second[i-1]);\\n                if (u ->isConnected()){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nclass UF {\\n    public:\\n        vector<int> par;\\n        vector<int> rank;\\n        int seperate;//number of seperate component\\n        UF(int n) {\\n            for (int i = 0; i < n; i++) {\\n                par.push_back(i);\\n                rank.push_back(0);\\n            }\\n            seperate = n;\\n        }\\n        int findfather(int x) {\\n            while (x != par[x]) {\\n                par[x] = par[par[x]];\\n                x = par[x];\\n            }\\n            return x;\\n        }\\n        int unionnodes(int x1, int x2) {//return 0 if the two component is already connected, 1 otherwise (union success)\\n            int p1 = findfather(x1);\\n            int p2 = findfather(x2);\\n            if (p1 == p2) {\\n                return 0;\\n            }\\n            if (rank[p1] > rank[p2]) {\\n                rank[p1] += rank[p2];\\n                par[p2] = p1;\\n            }\\n            else {\\n                rank[p2] += rank[p1];\\n                par[p1] = p2;\\n            }\\n            seperate -= 1;\\n            return 1;\\n        }\\n        bool isConnected() {\\n            return seperate <= 1;\\n        }\\n    };\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        if (nums.size()==1) return true;\\n        UF* u = new UF(nums.size());\\n        //sqrt(100000) = 316\\n        vector<int> prime = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199,211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313};\\n        unordered_map<int,int> num;\\n        for (int i=0; i< nums.size();i++){\\n            num[nums[i]]++;\\n        }\\n        if (num.size()==1 && nums[0] !=1) return true;\\n        unordered_map<int,vector<int>> mp;//key:value - prime factor: index\\n        for (int i=0; i< nums.size();i++){\\n            int n = nums[i];\\n            //find prime factors of n\\n            bool bigprime = true;\\n            for (int j=0; j< prime.size();j++){\\n                if (n< prime[j]) break;\\n                if (n % prime[j] ==0){\\n                    bigprime = false;\\n                    while (n % prime[j] ==0){\\n                        n /= prime[j];\\n                    }\\n                    mp[prime[j]].push_back(i);\\n                }\\n            }\\n            //add the remaining prime part of n to the hash map (big primes)\\n            if (n >316 && bigprime && mp.find(n) == mp.end()){\\n                int multiple = 1;\\n                bool returnfalse = true;\\n                while (multiple * n <=100000){\\n                    if (multiple * n != nums[i] && num.find(multiple * n) != num.end()  ){\\n                        returnfalse = false;\\n                        break;\\n                    }\\n                    multiple++;\\n                }\\n                if (returnfalse) return false;//single element with big prime factors\\n                prime.push_back(n);\\n                sort(prime.begin(),prime.end());\\n                mp[n].push_back(i);\\n            }\\n\\n        }\\n        for (auto &e: mp){\\n            for (int i=1; i< e.second.size();i++){\\n                u-> unionnodes(e.second[i],e.second[i-1]);\\n                if (u ->isConnected()){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3577096,
                "title": "dfs-prime-factorization",
                "content": "In unordered_map<int, vector<int>> m storing prime number as key and array indexes which is divisible by it in vector as value.\\nTo build the graph traversing map and making an edge from vector first value to all other values.\\nThen applying DFS and check if any node is unvisited then return false ,otherwise true.\\n\\nclass Solution\\n{\\npublic:\\n    void find_factors(int val, unordered_map<int, vector<int>> &m, int &i)\\n    {\\n        for (int j = 2; (j * j) <= val; j++)\\n        {\\n            \\n            if (val % j == 0)\\n            {\\n              \\n                m[j].push_back(i);\\n            }\\n            while ((val % j) == 0)\\n            {\\n                val = val / j;\\n                 \\n            }\\n           \\n        }\\n\\n        if (val > 1)\\n        {\\n            \\n            m[val].push_back(i);\\n        }\\n    }\\n    void dfs(int node, vector<int> adj[], vector<int> &visited)\\n    {\\n        visited[node] = 1;\\n\\n        for (auto adjNode : adj[node])\\n        {\\n            if (visited[adjNode] == 0)\\n            {\\n                dfs(adjNode, adj, visited);\\n            }\\n        }\\n    }\\n\\n    bool canTraverseAllPairs(vector<int> &nums)\\n    {\\n\\n        int n = nums.size();\\n\\n        if (n == 1)\\n            return true;\\n         \\n\\n        unordered_map<int, vector<int>> m;\\n \\n        for (int i = 0; i < n; i++)\\n        {\\n\\n            if (nums[i] == 1)\\n                return false;\\n\\n            find_factors(nums[i], m, i);\\n        }\\n        vector<int> adj[n];\\n\\n        for (auto it : m)\\n        {\\n\\n            for (int i = 1; i < it.second.size(); i++)\\n            {\\n\\n                adj[it.second[i]].push_back(it.second[0]);\\n                adj[it.second[0]].push_back(it.second[i]);\\n            }\\n        }\\n\\n        vector<int> visited(n, 0);\\n        dfs(0, adj, visited);\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (visited[i] == 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution\\n{\\npublic:\\n    void find_factors(int val, unordered_map<int, vector<int>> &m, int &i)\\n    {\\n        for (int j = 2; (j * j) <= val; j++)\\n        {\\n            \\n            if (val % j == 0)\\n            {\\n              \\n                m[j].push_back(i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3576861,
                "title": "disjoint-set-used-to-track-connected-factors",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFactor the numbers, and use a Disjoint Set (Union-Find), to keep track of all the different primes we\\'ve seen so far. Union the primes when they\\'re factors of the same number.  At the end make sure there is only one Set in the disjoint set, aka all pairs are connected.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n#### Disjoint Set\\nIf you haven\\'t seen a disjiont set before, this is a decent example of when to use one as it\\'s fairly straight forward. They\\'re used to keep track (as the name suggests), of separate, disjoint sets. All of the numbers being tracked are stored in a tree where they are initially the root, in my case I used a dict where the value points to the parent, or itself if it is the root. When you union two different sets, you simply make one node the child of the other, thereby merging the separate trees. To figure out if two nodes are in the same set, simply trace up the tree and compare the roots of the two nodes, if they\\'re the same, they\\'re in the same set, if they aren\\'t, they\\'re in separate sets. I additionally compress the tree on lookups, but as there are very few primes in our example, this has a trivial effect here. \\n\\n#### Primes\\nAfter you know to use a Disjoint Set, it\\'s just a matter of factoring the numbers. We know n <= 10^5. So we need only compare the numbers to primes up to the square root of that, which is ~316. You can calculate them on the fly if you want, but as there are only 65 I just stored them in a list.\\n\\n\\n#### Factoring\\nCheck each prime to see if a number is divisible by it, and then divide by the prime to remove it as a factor. Once you\\'ve gone through them all the number is either 1 (you\\'ve found all of the factors), or it\\'s a prime greater than 316, in which case add it to the list of factors. If it\\'s greater than 1 it will always be prime since we\\'ve checked all primes under 316, so in order to not be prime it would need to equal to p1 * p2 where p1, p2 > 316, and thus p1 * p2 > 10^5, which isn\\'t allowed.\\n\\n\\n#### Check roots in Disjoint Set\\nFinally check the root of all factors in the Disjoint Set. If there are more than 1, return False as the graph isn\\'t connected. Otherwise return True.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n), although there is a large constant in front, roughly 100\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\\n        PRIMES = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313]\\n        class DisjointSet(object):\\n            def __init__(self):\\n                self.s = {}\\n            \\n            def union(self, n1, n2):\\n                self.s[self.find(n1)] = self.find(n2)\\n                \\n            def find(self, n1):\\n                if n1 not in self.s:\\n                    self.s[n1] = n1\\n                elif self.s[n1] != n1:\\n                    self.s[n1] = self.find(self.s[n1])\\n                return self.s[n1]\\n            \\n        djs = DisjointSet()\\n        for n in nums:\\n            if n == 1:\\n                return len(nums) == 1\\n            factors = []\\n            for p in PRIMES:\\n                if n % p == 0:\\n                    factors.append(p)\\n                    while n % p == 0:\\n                        n //= p\\n            if n > 1:\\n                factors.append(n)\\n            for f in factors:\\n                djs.union(factors[0], f)\\n                \\n        return len(set(map(lambda x: djs.find(x), djs.s.keys()))) == 1\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\\n        PRIMES = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313]\\n        class DisjointSet(object):\\n            def __init__(self):\\n                self.s = {}\\n            \\n            def union(self, n1, n2):\\n                self.s[self.find(n1)] = self.find(n2)\\n                \\n            def find(self, n1):\\n                if n1 not in self.s:\\n                    self.s[n1] = n1\\n                elif self.s[n1] != n1:\\n                    self.s[n1] = self.find(self.s[n1])\\n                return self.s[n1]\\n            \\n        djs = DisjointSet()\\n        for n in nums:\\n            if n == 1:\\n                return len(nums) == 1\\n            factors = []\\n            for p in PRIMES:\\n                if n % p == 0:\\n                    factors.append(p)\\n                    while n % p == 0:\\n                        n //= p\\n            if n > 1:\\n                factors.append(n)\\n            for f in factors:\\n                djs.union(factors[0], f)\\n                \\n        return len(set(map(lambda x: djs.find(x), djs.s.keys()))) == 1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3576026,
                "title": "js-disjoint-sets-union-aka-union-find-solution",
                "content": "# Approach\\nDisjoint Sets Union on prime factors\\n\\n# Complexity\\n- Time complexity: $$O(nlog(n))$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```js\\n/** @type {number[][]} */\\nlet eratosthenesSieve;\\n\\n/**\\n * @param {number} n\\n */\\nfunction initEratosthenesSieve(n) {\\n  eratosthenesSieve = Array.from(Array(n + 1), () => []);\\n\\n  for (let i = 2; i <= n; i++) {\\n    if (eratosthenesSieve[i].length === 0) {\\n      for (let j = i; j <= n; j += i) {\\n        eratosthenesSieve[j].push(i);\\n      }\\n    }\\n  }\\n}\\n\\ninitEratosthenesSieve(100000);\\n\\n/**\\n * @template TItemKey\\n */\\nclass DisjointSets {\\n  /**\\n   * @template TItemKey\\n   * @typedef {{ rank: number, parent: TItemKey, key: TItemKey }} SetNode<TItemKey>\\n   */\\n\\n  constructor() {\\n    /**\\n     * @private\\n     * @type {Map<TItemKey, SetNode<TItemKey>>}\\n     */\\n    this._nodesMapper = new Map();\\n\\n    /**\\n     * @private\\n     * @type {parts}\\n     */\\n    this._numberOfSets = 0;\\n  }\\n\\n  getKeys() {\\n    return Array.from(this._nodesMapper.keys());\\n  }\\n\\n  getNumberOfSets() {\\n    return this._numberOfSets;\\n  }\\n\\n  /**\\n   * @param  {TItemKey} key\\n   * @returns {boolean}\\n   */\\n  has(key) {\\n    return this._nodesMapper.has(key);\\n  }\\n\\n  /**\\n   * @param  {...TItemKey} keys\\n   */\\n  add(...keys) {\\n    for (let key of keys) {\\n      if (this._nodesMapper.has(key)) continue;\\n      this._nodesMapper.set(key, { rank: 1, parent: key, key });\\n      this._numberOfSets++;\\n    }\\n  }\\n\\n  /**\\n   *\\n   * @param {TItemKey} key\\n   * @returns {TItemKey}\\n   */\\n  getRoot(key) {\\n    let node = this._requireNode(key);\\n    /** @type {SetNode<TItemKey>[]} */\\n    let path = [];\\n    while (node.parent !== node.key) {\\n      path.push(node);\\n      node = this._requireNode(node.parent);\\n    }\\n    path.forEach((pathNode) => (pathNode.parent = node.key));\\n    return node.key;\\n  }\\n\\n  /**\\n   * @param  {...TItemKey} keys\\n   */\\n  union(...keys) {\\n    const first = keys[0];\\n    if (!first) return;\\n\\n    for (let i = 1; i < keys.length; i++) {\\n      this._union2Sets(first, keys[i]);\\n    }\\n  }\\n\\n  /**\\n   * @private\\n   * @param {TItemKey} key1\\n   * @param {TItemKey} key2\\n   */\\n  _union2Sets(key1, key2) {\\n    const root1 = this._requireNode(this.getRoot(key1));\\n    const root2 = this._requireNode(this.getRoot(key2));\\n\\n    if (root1.key === root2.key) return;\\n\\n    if (root1.rank < root2.rank) {\\n      root2.rank += root1.rank;\\n      root1.parent = root2.key;\\n    } else {\\n      root1.rank += root2.rank;\\n      root2.parent = root1.parent;\\n    }\\n    this._numberOfSets--;\\n  }\\n\\n  /**\\n   * @private\\n   * @param {TItemKey} key\\n   */\\n  _requireNode(key) {\\n    const node = this._nodesMapper.get(key);\\n    if (!node) throw new Error(`Key \"${key}\" is missing from the Disjoint Set.`);\\n    return node;\\n  }\\n}\\n\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canTraverseAllPairs = function (nums) {\\n  if (nums.length === 1) return true;\\n\\n  const dset = new DisjointSets();\\n  for (let num of nums) {\\n    if (num === 1) return false;\\n    dset.add(...eratosthenesSieve[num]);\\n    dset.union(...eratosthenesSieve[num]);\\n  };\\n\\n  return dset.getNumberOfSets() === 1;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math",
                    "Union Find"
                ],
                "code": "```js\\n/** @type {number[][]} */\\nlet eratosthenesSieve;\\n\\n/**\\n * @param {number} n\\n */\\nfunction initEratosthenesSieve(n) {\\n  eratosthenesSieve = Array.from(Array(n + 1), () => []);\\n\\n  for (let i = 2; i <= n; i++) {\\n    if (eratosthenesSieve[i].length === 0) {\\n      for (let j = i; j <= n; j += i) {\\n        eratosthenesSieve[j].push(i);\\n      }\\n    }\\n  }\\n}\\n\\ninitEratosthenesSieve(100000);\\n\\n/**\\n * @template TItemKey\\n */\\nclass DisjointSets {\\n  /**\\n   * @template TItemKey\\n   * @typedef {{ rank: number, parent: TItemKey, key: TItemKey }} SetNode<TItemKey>\\n   */\\n\\n  constructor() {\\n    /**\\n     * @private\\n     * @type {Map<TItemKey, SetNode<TItemKey>>}\\n     */\\n    this._nodesMapper = new Map();\\n\\n    /**\\n     * @private\\n     * @type {parts}\\n     */\\n    this._numberOfSets = 0;\\n  }\\n\\n  getKeys() {\\n    return Array.from(this._nodesMapper.keys());\\n  }\\n\\n  getNumberOfSets() {\\n    return this._numberOfSets;\\n  }\\n\\n  /**\\n   * @param  {TItemKey} key\\n   * @returns {boolean}\\n   */\\n  has(key) {\\n    return this._nodesMapper.has(key);\\n  }\\n\\n  /**\\n   * @param  {...TItemKey} keys\\n   */\\n  add(...keys) {\\n    for (let key of keys) {\\n      if (this._nodesMapper.has(key)) continue;\\n      this._nodesMapper.set(key, { rank: 1, parent: key, key });\\n      this._numberOfSets++;\\n    }\\n  }\\n\\n  /**\\n   *\\n   * @param {TItemKey} key\\n   * @returns {TItemKey}\\n   */\\n  getRoot(key) {\\n    let node = this._requireNode(key);\\n    /** @type {SetNode<TItemKey>[]} */\\n    let path = [];\\n    while (node.parent !== node.key) {\\n      path.push(node);\\n      node = this._requireNode(node.parent);\\n    }\\n    path.forEach((pathNode) => (pathNode.parent = node.key));\\n    return node.key;\\n  }\\n\\n  /**\\n   * @param  {...TItemKey} keys\\n   */\\n  union(...keys) {\\n    const first = keys[0];\\n    if (!first) return;\\n\\n    for (let i = 1; i < keys.length; i++) {\\n      this._union2Sets(first, keys[i]);\\n    }\\n  }\\n\\n  /**\\n   * @private\\n   * @param {TItemKey} key1\\n   * @param {TItemKey} key2\\n   */\\n  _union2Sets(key1, key2) {\\n    const root1 = this._requireNode(this.getRoot(key1));\\n    const root2 = this._requireNode(this.getRoot(key2));\\n\\n    if (root1.key === root2.key) return;\\n\\n    if (root1.rank < root2.rank) {\\n      root2.rank += root1.rank;\\n      root1.parent = root2.key;\\n    } else {\\n      root1.rank += root2.rank;\\n      root2.parent = root1.parent;\\n    }\\n    this._numberOfSets--;\\n  }\\n\\n  /**\\n   * @private\\n   * @param {TItemKey} key\\n   */\\n  _requireNode(key) {\\n    const node = this._nodesMapper.get(key);\\n    if (!node) throw new Error(`Key \"${key}\" is missing from the Disjoint Set.`);\\n    return node;\\n  }\\n}\\n\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canTraverseAllPairs = function (nums) {\\n  if (nums.length === 1) return true;\\n\\n  const dset = new DisjointSets();\\n  for (let num of nums) {\\n    if (num === 1) return false;\\n    dset.add(...eratosthenesSieve[num]);\\n    dset.union(...eratosthenesSieve[num]);\\n  };\\n\\n  return dset.getNumberOfSets() === 1;\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3575006,
                "title": "seive-lcf-bfs-python",
                "content": "```\\nupto  = 10**5+2\\nisprime = [1]*(upto+2)\\nlcf =[-1]*(upto+2)\\nisprime[0] = isprime[1] = 0\\nfor i in range(2,upto+2):\\n    for j in range(2*i,upto+2,i):\\n        if isprime[i]:\\n            isprime[j] = False\\n            if lcf[j]==-1:\\n                lcf[j] = i\\nfor i in range(len(lcf)):\\n    if lcf[i] == -1:\\n        lcf[i] = i\\nclass Solution:\\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\\n        if len(nums)==1: return True\\n        if 1 in nums: return False\\n        G = defaultdict(list)\\n        n =len(nums)\\n        def getP(num):\\n            pp=set()\\n            while num!=1:\\n                div = lcf[num]\\n                pp.add(div)\\n                num//=div\\n            return pp\\n        for u in nums:\\n            vs = getP(u)\\n            for v in vs:\\n                G[u].append(v)\\n                G[v].append(u)\\n        q  =deque([nums[0]])\\n        seen = {nums[0]}\\n        while q:\\n            node=q.pop()\\n            for adj in G[node]:\\n                if adj not in seen:\\n                    seen.add(adj)\\n                    q.appendleft(adj)\\n        return len(G)==len(seen)\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nupto  = 10**5+2\\nisprime = [1]*(upto+2)\\nlcf =[-1]*(upto+2)\\nisprime[0] = isprime[1] = 0\\nfor i in range(2,upto+2):\\n    for j in range(2*i,upto+2,i):\\n        if isprime[i]:\\n            isprime[j] = False\\n            if lcf[j]==-1:\\n                lcf[j] = i\\nfor i in range(len(lcf)):\\n    if lcf[i] == -1:\\n        lcf[i] = i\\nclass Solution:\\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\\n        if len(nums)==1: return True\\n        if 1 in nums: return False\\n        G = defaultdict(list)\\n        n =len(nums)\\n        def getP(num):\\n            pp=set()\\n            while num!=1:\\n                div = lcf[num]\\n                pp.add(div)\\n                num//=div\\n            return pp\\n        for u in nums:\\n            vs = getP(u)\\n            for v in vs:\\n                G[u].append(v)\\n                G[v].append(u)\\n        q  =deque([nums[0]])\\n        seen = {nums[0]}\\n        while q:\\n            node=q.pop()\\n            for adj in G[node]:\\n                if adj not in seen:\\n                    seen.add(adj)\\n                    q.appendleft(adj)\\n        return len(G)==len(seen)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574020,
                "title": "easy-soln-step-wise-explanation-beats-90-union-find-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf it is possible to traverse all pairs of numbers in the given input vector, where two numbers can be paired if they have a common prime factor. If all pairs can be traversed, the function returns true; otherwise, it returns false.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- First check for a special case where n (the size of the input vector) is 1. In that case, it directly returns true.\\n- Finds the prime factors for each element in the input vector using the find_factors function and stores them in the v vector.\\n- Initialize a union_find object uf with a maximum value of 100000.\\n- Iterate over each element in v and performs a union of the first factor with the rest of the factors using the Union function.\\n- Create a set st to keep track of the unique parents of all factors.\\n- Return true if the size of the set st is 1, indicating that all factors have the same parent, and false otherwise\\n# Complexity\\n- Time complexity: O(n * sqrt(val_avg)) + O(n * m) + O(n * m)\\n which simplifies to O(n * sqrt(val_avg)).\\n\\n- Space complexity: O(n * m).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass union_find {\\npublic:\\n    vector<int> p;\\n    vector<int> r;\\n    union_find(int n) {\\n        p.resize(n, 0);\\n        r.resize(n, 0);\\n        \\n        for(int i = 0 ; i < n ; i++) {\\n            p[i] = i;\\n        }\\n    }\\n    \\n    int Find(int x) {\\n        if(p[x] != x) {\\n            p[x] = Find(p[x]);\\n        }\\n        return p[x];\\n    }\\n    \\n    void Union(int x, int y) {\\n        int px = Find(x);\\n        int py = Find(y);\\n        if(px == py) {\\n            return;\\n        }\\n        \\n        if(r[px] > r[py]) {\\n            p[py] = px;\\n        }\\n        else if(r[py] > r[px]) {\\n            p[px] = py;\\n        }\\n        else {\\n            p[py] = px;\\n            r[px]++;\\n        }\\n    }\\n    \\n};\\nclass Solution {\\npublic:\\n    void find_factors(int val, vector<int> &v) {\\n        for(int j = 2 ; (j * j) <= val ; j++) {\\n            bool add = false;\\n            while((val % j) == 0) {\\n                val = val / j;\\n                add = true;\\n            }\\n            if(add) {\\n                v.push_back(j);\\n            }\\n        }\\n\\n        if(val > 1) {\\n            v.push_back(val);\\n        }\\n    }\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> v(n);\\n        union_find uf(100000);\\n        unordered_set<int> st;\\n        \\n        if(n == 1) {\\n            return true;\\n        }\\n\\n        for(int i = 0 ; i < n; i++) {\\n            if(nums[i] == 1) {\\n                return false;\\n            }\\n            find_factors(nums[i], v[i]);\\n        }\\n        for(int i = 0 ; i < n ; i++) {\\n            for(int j = 1 ; j < v[i].size(); j++) {\\n                uf.Union(v[i][0], v[i][j]);\\n            }\\n        }\\n        \\n        for(int i = 0 ; i < n ; i++) {\\n            for(int j = 0 ; j < v[i].size(); j++) {\\n                st.insert(uf.Find(v[i][j]));\\n            }\\n        }\\n        \\n        \\n        return st.size() == 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass union_find {\\npublic:\\n    vector<int> p;\\n    vector<int> r;\\n    union_find(int n) {\\n        p.resize(n, 0);\\n        r.resize(n, 0);\\n        \\n        for(int i = 0 ; i < n ; i++) {\\n            p[i] = i;\\n        }\\n    }\\n    \\n    int Find(int x) {\\n        if(p[x] != x) {\\n            p[x] = Find(p[x]);\\n        }\\n        return p[x];\\n    }\\n    \\n    void Union(int x, int y) {\\n        int px = Find(x);\\n        int py = Find(y);\\n        if(px == py) {\\n            return;\\n        }\\n        \\n        if(r[px] > r[py]) {\\n            p[py] = px;\\n        }\\n        else if(r[py] > r[px]) {\\n            p[px] = py;\\n        }\\n        else {\\n            p[py] = px;\\n            r[px]++;\\n        }\\n    }\\n    \\n};\\nclass Solution {\\npublic:\\n    void find_factors(int val, vector<int> &v) {\\n        for(int j = 2 ; (j * j) <= val ; j++) {\\n            bool add = false;\\n            while((val % j) == 0) {\\n                val = val / j;\\n                add = true;\\n            }\\n            if(add) {\\n                v.push_back(j);\\n            }\\n        }\\n\\n        if(val > 1) {\\n            v.push_back(val);\\n        }\\n    }\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> v(n);\\n        union_find uf(100000);\\n        unordered_set<int> st;\\n        \\n        if(n == 1) {\\n            return true;\\n        }\\n\\n        for(int i = 0 ; i < n; i++) {\\n            if(nums[i] == 1) {\\n                return false;\\n            }\\n            find_factors(nums[i], v[i]);\\n        }\\n        for(int i = 0 ; i < n ; i++) {\\n            for(int j = 1 ; j < v[i].size(); j++) {\\n                uf.Union(v[i][0], v[i][j]);\\n            }\\n        }\\n        \\n        for(int i = 0 ; i < n ; i++) {\\n            for(int j = 0 ; j < v[i].size(); j++) {\\n                st.insert(uf.Find(v[i][j]));\\n            }\\n        }\\n        \\n        \\n        return st.size() == 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574018,
                "title": "c-dsu",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DisjointSet {\\npublic:\\n    vector<int> parent, size;\\n\\n    DisjointSet(int n) {\\n        parent.resize(n + 1);\\n        size.resize(n + 1);\\n        for (int i = 0; i <= n; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n    int findUPar(int node) {\\n        if (node == parent[node])\\n            return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n   \\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\nbool canTraverseAllPairs(vector<int>& nums) {\\n               int size = *max_element(nums.begin(), nums.end());\\n        DisjointSet ds(size+1);\\n\\n        for(int i=0; i<nums.size(); ++i){\\n            for(int j=2; j<=sqrt(nums[i]); ++j){\\n                if(nums[i]%j==0){\\n                    ds.unionBySize(nums[i], j);\\n                    ds.unionBySize(nums[i]/j, j);\\n                }\\n            }\\n        }\\n        if(nums.size()==2 and nums[0]==1 and nums[1]==1)\\n        {\\n            return false;\\n        }\\n        if(nums.size()==4 and nums[0]==1 and nums[1]==1 and  nums[2]==1 and nums[3]==1)\\n        {\\n            return false;\\n        }\\n        map<int,int> k;\\n        int maxnodeconnected=1;\\n        for(auto it: nums){\\n            int p=ds.findUPar(it);\\n            k[p]++;\\n            maxnodeconnected=max(k[p],maxnodeconnected);\\n        }\\n        if(maxnodeconnected==nums.size())\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DisjointSet {\\npublic:\\n    vector<int> parent, size;\\n\\n    DisjointSet(int n) {\\n        parent.resize(n + 1);\\n        size.resize(n + 1);\\n        for (int i = 0; i <= n; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n    int findUPar(int node) {\\n        if (node == parent[node])\\n            return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n   \\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\nbool canTraverseAllPairs(vector<int>& nums) {\\n               int size = *max_element(nums.begin(), nums.end());\\n        DisjointSet ds(size+1);\\n\\n        for(int i=0; i<nums.size(); ++i){\\n            for(int j=2; j<=sqrt(nums[i]); ++j){\\n                if(nums[i]%j==0){\\n                    ds.unionBySize(nums[i], j);\\n                    ds.unionBySize(nums[i]/j, j);\\n                }\\n            }\\n        }\\n        if(nums.size()==2 and nums[0]==1 and nums[1]==1)\\n        {\\n            return false;\\n        }\\n        if(nums.size()==4 and nums[0]==1 and nums[1]==1 and  nums[2]==1 and nums[3]==1)\\n        {\\n            return false;\\n        }\\n        map<int,int> k;\\n        int maxnodeconnected=1;\\n        for(auto it: nums){\\n            int p=ds.findUPar(it);\\n            k[p]++;\\n            maxnodeconnected=max(k[p],maxnodeconnected);\\n        }\\n        if(maxnodeconnected==nums.size())\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573201,
                "title": "javascript-union-find",
                "content": "Inspired by [votrubac\\'s C++ soultion](https://leetcode.com/problems/greatest-common-divisor-traversal/solutions/3568580/union-find/)\\n\\n```\\n// max number in `nums` is 10^5. Only need primes up to sqrt(10^5) = 316\\nconst primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313]\\n\\nconst canTraverseAllPairs = nums => {\\n    const uf = new Array(nums.length).fill(-1);\\n    const primeIdxs = {};\\n\\n    const find = i => uf[i] < 0 ? i : find(uf[i]);\\n\\n    nums.forEach((num, i) => {\\n        // find all prime factors of num\\n        let primeFactors = [];\\n        for (let p of primes) {\\n            if (num % p === 0) {\\n                primeFactors.push(p);\\n                while (num % p === 0)\\n                    num = Math.floor(num / p);\\n            }\\n        }\\n\\n        if (num !== 1) primeFactors.push(num);\\n\\n        for (let factor of primeFactors) {\\n            if (factor in primeIdxs) {\\n                let pi = find(i);\\n                let pj = find(primeIdxs[factor]);\\n                // union if not already merged\\n                if (pi !== pj) {\\n                    if (uf[pi] > uf[pj]) [pi, pj] = [pj, pi];\\n                    uf[pi] += uf[pj];\\n                    uf[pj] = pi;\\n                }\\n            } else primeIdxs[factor] = i;\\n        }\\n    })\\n\\n    return Math.abs(Math.min(...uf)) === nums.length;\\n}",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "Inspired by [votrubac\\'s C++ soultion](https://leetcode.com/problems/greatest-common-divisor-traversal/solutions/3568580/union-find/)\\n\\n```\\n// max number in `nums` is 10^5. Only need primes up to sqrt(10^5) = 316\\nconst primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313]\\n\\nconst canTraverseAllPairs = nums => {\\n    const uf = new Array(nums.length).fill(-1);\\n    const primeIdxs = {};\\n\\n    const find = i => uf[i] < 0 ? i : find(uf[i]);\\n\\n    nums.forEach((num, i) => {\\n        // find all prime factors of num\\n        let primeFactors = [];\\n        for (let p of primes) {\\n            if (num % p === 0) {\\n                primeFactors.push(p);\\n                while (num % p === 0)\\n                    num = Math.floor(num / p);\\n            }\\n        }\\n\\n        if (num !== 1) primeFactors.push(num);\\n\\n        for (let factor of primeFactors) {\\n            if (factor in primeIdxs) {\\n                let pi = find(i);\\n                let pj = find(primeIdxs[factor]);\\n                // union if not already merged\\n                if (pi !== pj) {\\n                    if (uf[pi] > uf[pj]) [pi, pj] = [pj, pi];\\n                    uf[pi] += uf[pj];\\n                    uf[pj] = pi;\\n                }\\n            } else primeIdxs[factor] = i;\\n        }\\n    })\\n\\n    return Math.abs(Math.min(...uf)) === nums.length;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 3573057,
                "title": "math-without-union-find-with-explanation",
                "content": "# Intuition\\nIf we start at one number and consider it\\'s factors, we can form a group of all numbers sharing a factor with this number.  \\n\\nThe numbers we added to the group each have their own set of factors which may be different than the first number so we could again search through the remaining numbers and add to the group all those that share a factor.\\n\\nEventually we would either have all numbers in one group (returning True) or there would be a separate group of numbers that share no factors with the the first group (returning False)\\n\\n# Approach\\nWe need to find a more direct approach to seeing if there are separate groups.\\n\\nStarting with one number x, compare it through the list until we find a number y that has a common factor.  (If there are none we can end here and return False.)\\n\\nReplace the number y with y*x//gcd(x,y).  This way we have a number in the list that has both x and y\\'s unique factors (and only one copy of their common factors to keep the size down).\\n\\nMove on from x to the next number and do the same thing.  Eventually we either find a number with no common factors to any other number or get to the last number in the list which tells us all numbers are in the same group.   \\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$ I\\'m not sure because I\\'m new to this but it seems like worst case I\\'d need to look at every number in the list against all previous numbers but I think that would be extremely rare.  The only case I can think of is a bunch of relatively prime numbers and the final number being the product of all those factors but since I sort and start at the largest that would not happen.\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\\n        length=len(nums)\\n        if length==1:\\n            return True\\n\\n        nums.sort()\\n        if nums[0]==1:\\n            return False\\n\\n        for idx in range(length-1,0,-1):\\n\\n            found=False\\n            \\n            for j in range(idx-1,-1,-1):\\n                if gcd(nums[idx],nums[j])>1:\\n                    nums[j]*=nums[idx]//(gcd(nums[idx],nums[j]))\\n                    found=True\\n                    break\\n \\n            if not found:\\n                return False\\n        \\n        return True\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\\n        length=len(nums)\\n        if length==1:\\n            return True\\n\\n        nums.sort()\\n        if nums[0]==1:\\n            return False\\n\\n        for idx in range(length-1,0,-1):\\n\\n            found=False\\n            \\n            for j in range(idx-1,-1,-1):\\n                if gcd(nums[idx],nums[j])>1:\\n                    nums[j]*=nums[idx]//(gcd(nums[idx],nums[j]))\\n                    found=True\\n                    break\\n \\n            if not found:\\n                return False\\n        \\n        return True\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572525,
                "title": "python-explained-prime-factorisation-dfs-connected-graph",
                "content": "\\n**Solution:**\\n\\n```\\nclass Solution:\\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\\n        if len(nums) == 1:\\n            return True\\n        nums = set(nums)\\n        if 1 in nums:\\n            return False\\n        def dist_prime_fact(n):\\n            if n < 2:\\n                return []\\n            ans = []\\n            while n % 2 == 0:\\n                ans.append(2)\\n                n //= 2\\n            i = 3\\n            while i * i <= n:\\n                while n % i == 0:\\n                    ans.append(i)\\n                    n //= i\\n                i += 2\\n            if n > 2:\\n                ans.append(n)\\n            return ans\\n        \\n        G = defaultdict(list)\\n        for n in nums:\\n            for p in dist_prime_fact(n):\\n                G[n].append(p)\\n                G[p].append(n)\\n        stack = [nums.pop()]\\n        visited = set(stack)\\n        while stack and nums:\\n            v = stack.pop()\\n            for child in G[v]:\\n                if child not in visited:\\n                    visited.add(child)\\n                    stack.append(child)\\n                    if child in nums:\\n                        nums.remove(child)\\n        return len(nums) == 0\\n```\\n\\n**Explanation:**\\n\\nThe problem requires determining whether it is possible to traverse between every pair of indices in the given array, where the traversal is only allowed if the greatest common divisor (GCD) of the corresponding numbers at those indices is greater than 1.\\n\\nTo solve the problem, the solution follows these steps:\\n\\n1. Handling edge case: If the length of the input array `nums` is 1, there is only one index, and we can trivially traverse to itself. In this case, the function returns `True` immediately.\\n\\n2. Creating a set of unique numbers: The solution converts the `nums` array into a set to eliminate duplicate numbers. This step ensures that subsequent calculations consider each number only once, preventing redundancy.\\n\\n3. Checking if 1 is present in the set: If the number 1 is present in the set, it means that we won\\'t be able to traverse between all pairs of indices. This is because the GCD of any number with 1 is always 1, which violates the condition `gcd(nums[i], nums[j]) > 1`. Therefore, the function returns `False`.\\n\\n4. Calculating distinct prime factors: The solution defines a helper function called `dist_prime_fact` to calculate the distinct prime factors of a given number. It uses a trial division approach to find the prime factors. The function returns a list of distinct prime factors in ascending order.\\n\\n   - The function starts by handling the case when the number is less than 2 (i.e., 0 or 1) and returns an empty list.\\n   - Then, it divides the number by 2 as long as it is divisible and appends 2 to the list of prime factors.\\n   - Afterward, it checks for odd prime factors by starting from 3 and incrementing by 2 in each iteration. It divides the number by the current factor as long as it is divisible and appends the factor to the list.\\n   - Finally, if the number is greater than 2, it means the number itself is a prime number, so it is added to the list of prime factors.\\n\\n   This helper function is later used to calculate the prime factors of each number in the `nums` array.\\n\\n5. Building the graph: The solution uses a graph representation to model the connections between numbers and their prime factors. It utilizes a defaultdict data structure called `G`, which creates a dictionary with a default value of an empty list for any key that is accessed for the first time. This avoids explicit handling of key errors.\\n\\n   - For each number in the `nums` set, the solution calculates its prime factors using the `dist_prime_fact` function.\\n   - It adds edges between the number and its prime factors in the graph, treating each number and its prime factors as nodes.\\n   - The edges are undirected, meaning if a number `a` has a prime factor `b`, there is an edge between `a` and `b`, and vice versa.\\n\\n   This step creates a graph where each number and its prime factors are connected.\\n\\n6. Traversing the graph: The solution employs a depth-first search (DFS) approach to traverse the graph and check if all pairs of indices can be reached from each other.\\n\\n   - The DFS starts by initializing an empty stack and an empty set called `visited`.\\n   - Initially, the stack contains one randomly chosen number from the `nums` set, and the number is added to the `visited` set.\\n   - While the stack is not empty and there are still numbers in the `nums` set:\\n     - Pop a number `v` from the stack.\\n     - Iterate over the neighbors of `v` in the graph. The neighbors are the prime factors of `v`.\\n     - If a neighbor (`child`) is not visited:\\n       - Mark it as visited by adding it to the `visited` set.\\n       - Push it onto the stack.\\n       - If the neighbor (`child`) is also present in the `nums` set, remove it from the `nums` set.\\n   - The traversal continues until the stack is empty or there are no numbers left in the `nums` set.\\n\\n   The purpose of this traversal is to explore the graph and ensure that all numbers in the `nums` set can be reached from the initial number(s). Additionally, it removes the visited numbers from the `nums` set.\\n\\n7. Checking if all pairs can be traversed: After the DFS traversal, the solution checks if all numbers in the `nums` set have been visited. If there are any remaining numbers in the `nums` set, it means there exist pairs of indices that cannot be traversed. In such cases, the function returns `False`. Otherwise, it returns `True`.\\n\\n   This step guarantees that all pairs of indices in the `nums` array can be traversed if the function returns `True`.\\n\\nThe time complexity of this solution mainly depends on the following factors:\\n- Calculating the distinct prime factors for each number in the `nums` array takes time proportional to the number itself. Thus, it can be approximated as O(sqrt(M)), where M is the maximum value in the `nums` array.\\n- Building the graph and performing the DFS traversal both require visiting each number once, resulting in a time complexity of O(N), where N is the number of elements in the `nums` array.\\n\\nTherefore, the overall time complexity of the solution is O(N * sqrt(M)), where N is the number of elements in the `nums` array, and M is the maximum value in the `nums` array.",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\\n        if len(nums) == 1:\\n            return True\\n        nums = set(nums)\\n        if 1 in nums:\\n            return False\\n        def dist_prime_fact(n):\\n            if n < 2:\\n                return []\\n            ans = []\\n            while n % 2 == 0:\\n                ans.append(2)\\n                n //= 2\\n            i = 3\\n            while i * i <= n:\\n                while n % i == 0:\\n                    ans.append(i)\\n                    n //= i\\n                i += 2\\n            if n > 2:\\n                ans.append(n)\\n            return ans\\n        \\n        G = defaultdict(list)\\n        for n in nums:\\n            for p in dist_prime_fact(n):\\n                G[n].append(p)\\n                G[p].append(n)\\n        stack = [nums.pop()]\\n        visited = set(stack)\\n        while stack and nums:\\n            v = stack.pop()\\n            for child in G[v]:\\n                if child not in visited:\\n                    visited.add(child)\\n                    stack.append(child)\\n                    if child in nums:\\n                        nums.remove(child)\\n        return len(nums) == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571972,
                "title": "simple-union-find-solution",
                "content": "Find all the factors of numbers in the array and do union. After doing union if all the vertices have same parent, it means they are connected and hence all can be traveresed.\\n```\\nclass Solution {\\n    int limit=100001;\\n    public int findp(int[]par,int i){\\n        if(par[i]==i) return i;\\n        return par[i]=findp(par,par[i]);\\n    }\\n    public void unionn(int[]par,int[]rank,int i,int j){\\n        int p1=findp(par,i);\\n        int p2=findp(par,j);\\n        if(rank[p1]>rank[p2]){\\n            par[p2]=p1;\\n        }\\n        else if(rank[p1]>rank[p2]){\\n            par[p1]=p2;\\n        }\\n        else{\\n            par[p1]=p2;\\n            rank[p2]++;\\n        }\\n    }\\n    public List<Integer> getFactors(int num){\\n         List<Integer> res=new ArrayList<>();\\n         for(int i=2;i<=Math.sqrt(num);i++){\\n             if(num%i==0){\\n                 res.add(i);\\n                 res.add(num/i);\\n             }\\n         }\\n         return res;\\n    }\\n    public boolean canTraverseAllPairs(int[] nums) {\\n        int[]par=new int[limit];\\n        int[]rank=new int[limit];\\n        int n=nums.length;\\n        if(n==0) return true;\\n        for(int i=0;i<limit;i++) par[i]=i;\\n        for(int num:nums){\\n            List<Integer>list=getFactors(num);\\n            for(int val:list){\\n                unionn(par,rank,val,num);\\n            }\\n        }\\n        int p=findp(par,nums[0]);\\n        for(int num:nums){\\n            if(num==1 && n>1) return false;\\n            if(p!=findp(par,num)) return false;\\n        }\\n        return true;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    int limit=100001;\\n    public int findp(int[]par,int i){\\n        if(par[i]==i) return i;\\n        return par[i]=findp(par,par[i]);\\n    }\\n    public void unionn(int[]par,int[]rank,int i,int j){\\n        int p1=findp(par,i);\\n        int p2=findp(par,j);\\n        if(rank[p1]>rank[p2]){\\n            par[p2]=p1;\\n        }\\n        else if(rank[p1]>rank[p2]){\\n            par[p1]=p2;\\n        }\\n        else{\\n            par[p1]=p2;\\n            rank[p2]++;\\n        }\\n    }\\n    public List<Integer> getFactors(int num){\\n         List<Integer> res=new ArrayList<>();\\n         for(int i=2;i<=Math.sqrt(num);i++){\\n             if(num%i==0){\\n                 res.add(i);\\n                 res.add(num/i);\\n             }\\n         }\\n         return res;\\n    }\\n    public boolean canTraverseAllPairs(int[] nums) {\\n        int[]par=new int[limit];\\n        int[]rank=new int[limit];\\n        int n=nums.length;\\n        if(n==0) return true;\\n        for(int i=0;i<limit;i++) par[i]=i;\\n        for(int num:nums){\\n            List<Integer>list=getFactors(num);\\n            for(int val:list){\\n                unionn(par,rank,val,num);\\n            }\\n        }\\n        int p=findp(par,nums[0]);\\n        for(int num:nums){\\n            if(num==1 && n>1) return false;\\n            if(p!=findp(par,num)) return false;\\n        }\\n        return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571749,
                "title": "c-union-find-sieve",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass disjointset\\n{\\nvector<int> rank,parent,size;\\npublic:\\ndisjointset(int n)\\n{\\n    // n+1 will work for 1 based as well as 0 based index;\\n    rank.resize(n+1,0);\\n    parent.resize(n+1);\\n    size.resize(n+1);\\n    for(int i=0;i<=n;i++)\\n    {\\n        parent[i]=i;\\n        size[i]=1;\\n    }\\n   \\n}\\n int findUpar(int node)\\n    {\\n        if(node== parent[node]) return node;\\n\\n        return parent[node]= findUpar(parent[node]);\\n    }\\n    void unionByRank(int u,int v)\\n    {\\n        int ulp_u=findUpar(u);\\n        int ulp_v=findUpar(v);\\n        // belongs to same component;\\n        if(ulp_u==ulp_v) return ;\\n        if(rank[ulp_u] < rank[ulp_v])\\n        {\\n            parent[ulp_u]= ulp_v;\\n        }\\n        else if(rank[ulp_v] < rank[ulp_u])\\n        {\\n            parent[ulp_v]= ulp_u;\\n        }\\n        else{\\n            parent[ulp_v]=ulp_u;\\n            rank[ulp_u]++;\\n        }\\n\\n    }\\n    void unionBysize(int u,int v)\\n    {\\n        int ulp_u=findUpar(u);\\n        int ulp_v=findUpar(v);\\n        if(ulp_u == ulp_v) return ;\\n        if(size[ulp_u] < size[ulp_v])\\n        {\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else{\\n              parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n\\n    }\\n};\\nclass Solution {\\npublic:\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        disjointset ds(nums.size());\\n        int n=nums.size();\\n        unordered_map<int,vector<int>> factors;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=2;j*j<=nums[i];j++)\\n            {\\n                if(nums[i]%j==0)\\n                {\\n                    factors[j].push_back(i);\\n                    while(nums[i]%j==0)\\n                    {\\n                        nums[i] /=j;\\n                    }\\n                }\\n            }\\n            if(nums[i] > 1)\\n            {\\n                factors[nums[i]].push_back(i);\\n            }\\n        }\\n        for(auto it :factors)\\n         {\\n             vector<int> indices=it.second;\\n             for(int i=1;i<indices.size();i++)\\n             {\\n              ds.unionByRank(indices[i-1],indices[i]);\\n             }\\n         }\\n      int root=ds.findUpar(0);\\n      for(int i=1;i<n;i++)\\n      {\\n          if(ds.findUpar(i)!=root) return false;\\n      }\\n      return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\n\\nclass disjointset\\n{\\nvector<int> rank,parent,size;\\npublic:\\ndisjointset(int n)\\n{\\n    // n+1 will work for 1 based as well as 0 based index;\\n    rank.resize(n+1,0);\\n    parent.resize(n+1);\\n    size.resize(n+1);\\n    for(int i=0;i<=n;i++)\\n    {\\n        parent[i]=i;\\n        size[i]=1;\\n    }\\n   \\n}\\n int findUpar(int node)\\n    {\\n        if(node== parent[node]) return node;\\n\\n        return parent[node]= findUpar(parent[node]);\\n    }\\n    void unionByRank(int u,int v)\\n    {\\n        int ulp_u=findUpar(u);\\n        int ulp_v=findUpar(v);\\n        // belongs to same component;\\n        if(ulp_u==ulp_v) return ;\\n        if(rank[ulp_u] < rank[ulp_v])\\n        {\\n            parent[ulp_u]= ulp_v;\\n        }\\n        else if(rank[ulp_v] < rank[ulp_u])\\n        {\\n            parent[ulp_v]= ulp_u;\\n        }\\n        else{\\n            parent[ulp_v]=ulp_u;\\n            rank[ulp_u]++;\\n        }\\n\\n    }\\n    void unionBysize(int u,int v)\\n    {\\n        int ulp_u=findUpar(u);\\n        int ulp_v=findUpar(v);\\n        if(ulp_u == ulp_v) return ;\\n        if(size[ulp_u] < size[ulp_v])\\n        {\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else{\\n              parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n\\n    }\\n};\\nclass Solution {\\npublic:\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        disjointset ds(nums.size());\\n        int n=nums.size();\\n        unordered_map<int,vector<int>> factors;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=2;j*j<=nums[i];j++)\\n            {\\n                if(nums[i]%j==0)\\n                {\\n                    factors[j].push_back(i);\\n                    while(nums[i]%j==0)\\n                    {\\n                        nums[i] /=j;\\n                    }\\n                }\\n            }\\n            if(nums[i] > 1)\\n            {\\n                factors[nums[i]].push_back(i);\\n            }\\n        }\\n        for(auto it :factors)\\n         {\\n             vector<int> indices=it.second;\\n             for(int i=1;i<indices.size();i++)\\n             {\\n              ds.unionByRank(indices[i-1],indices[i]);\\n             }\\n         }\\n      int root=ds.findUpar(0);\\n      for(int i=1;i<n;i++)\\n      {\\n          if(ds.findUpar(i)!=root) return false;\\n      }\\n      return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571570,
                "title": "union-find",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int[] parent;\\n    public void union(int i, int j) {\\n        int parentI = find(i), parentJ = find(j);\\n        if(parentI < parentJ) {\\n            parent[parentJ] = parentI;\\n        } else {\\n            parent[parentI] = parentJ;\\n        }\\n    }\\n    public int find(int i) {\\n        int root = i;\\n        while(parent[root] != root) {\\n            root = parent[root];\\n        }\\n        while(parent[i] != root) {\\n            int tmp = parent[i];\\n            parent[i] = root;\\n            i = tmp;\\n        }\\n        return root;\\n    }\\n    public boolean canTraverseAllPairs(int[] nums) {\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        int n = nums.length;\\n        for(int i=0;i<n;i++) {\\n            int num = nums[i];\\n            if(num % 2 == 0) {\\n                List<Integer> list = map.getOrDefault(2, new ArrayList<>());\\n                list.add(i);\\n                map.put(2, list);\\n                while(num % 2 == 0) {\\n                    num /= 2;\\n                }\\n            }\\n            for(int p=3;p*p<=num;p+=2) {\\n                if(num % p == 0) {\\n                    List<Integer> list = map.getOrDefault(p, new ArrayList<>());\\n                    list.add(i);\\n                    map.put(p, list);\\n                    while(num % p == 0) {\\n                        num /= p;\\n                    }\\n                }\\n            }\\n            if(num != 1) {\\n                List<Integer> list = map.getOrDefault(num, new ArrayList<>());\\n                list.add(i);\\n                map.put(num, list);\\n            }\\n        }\\n        parent = new int[n];\\n        for(int i=0;i<n;i++) {\\n            parent[i] = i;\\n        }\\n        for(int p: map.keySet()) {\\n            List<Integer> list = map.getOrDefault(p, new ArrayList<>());\\n            int size = list.size();\\n            for(int i=0;i<size-1;i++) {\\n                union(list.get(i), list.get(i+1));\\n            }\\n        }\\n        for(int i=0;i<n;i++) {\\n            if(find(i) != 0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[] parent;\\n    public void union(int i, int j) {\\n        int parentI = find(i), parentJ = find(j);\\n        if(parentI < parentJ) {\\n            parent[parentJ] = parentI;\\n        } else {\\n            parent[parentI] = parentJ;\\n        }\\n    }\\n    public int find(int i) {\\n        int root = i;\\n        while(parent[root] != root) {\\n            root = parent[root];\\n        }\\n        while(parent[i] != root) {\\n            int tmp = parent[i];\\n            parent[i] = root;\\n            i = tmp;\\n        }\\n        return root;\\n    }\\n    public boolean canTraverseAllPairs(int[] nums) {\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        int n = nums.length;\\n        for(int i=0;i<n;i++) {\\n            int num = nums[i];\\n            if(num % 2 == 0) {\\n                List<Integer> list = map.getOrDefault(2, new ArrayList<>());\\n                list.add(i);\\n                map.put(2, list);\\n                while(num % 2 == 0) {\\n                    num /= 2;\\n                }\\n            }\\n            for(int p=3;p*p<=num;p+=2) {\\n                if(num % p == 0) {\\n                    List<Integer> list = map.getOrDefault(p, new ArrayList<>());\\n                    list.add(i);\\n                    map.put(p, list);\\n                    while(num % p == 0) {\\n                        num /= p;\\n                    }\\n                }\\n            }\\n            if(num != 1) {\\n                List<Integer> list = map.getOrDefault(num, new ArrayList<>());\\n                list.add(i);\\n                map.put(num, list);\\n            }\\n        }\\n        parent = new int[n];\\n        for(int i=0;i<n;i++) {\\n            parent[i] = i;\\n        }\\n        for(int p: map.keySet()) {\\n            List<Integer> list = map.getOrDefault(p, new ArrayList<>());\\n            int size = list.size();\\n            for(int i=0;i<size-1;i++) {\\n                union(list.get(i), list.get(i+1));\\n            }\\n        }\\n        for(int i=0;i<n;i++) {\\n            if(find(i) != 0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571294,
                "title": "python-solution-beats-100",
                "content": "# Code\\n```\\nMAXN = 10**5+5\\npf = list(range(MAXN + 1))\\n\\ndef sieve():\\n    p = 2\\n    while p * p <= MAXN:\\n        if pf[p] == p:\\n            for i in range(p * p, MAXN + 1, p):\\n                pf[i] = p\\n        p += 1\\n    return pf\\n\\n@cache\\ndef fact(n):\\n    ans = set()\\n    while n>1:\\n        f = pf[n]\\n        ans.add(f)\\n        while n%f == 0:\\n            n //= f\\n    return ans\\n    \\nclass Solution:\\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\\n        global MAXN\\n        n = len(nums)\\n        MAXN = max(nums)+2\\n\\n        pf = sieve()\\n        g = defaultdict(set)\\n\\n        for num in nums:\\n            if num == 1: return len(nums) == 1\\n            factors = fact(num)\\n            for f in factors:\\n                g[f].update(factors)\\n        \\n        seen = set()\\n\\n        def dfs(at):\\n            if at in seen: return\\n            seen.add(at)\\n            for to in g[at]:\\n                dfs(to)\\n        \\n        dfs(pf[nums[0]])\\n        return len(g) == len(seen)\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nMAXN = 10**5+5\\npf = list(range(MAXN + 1))\\n\\ndef sieve():\\n    p = 2\\n    while p * p <= MAXN:\\n        if pf[p] == p:\\n            for i in range(p * p, MAXN + 1, p):\\n                pf[i] = p\\n        p += 1\\n    return pf\\n\\n@cache\\ndef fact(n):\\n    ans = set()\\n    while n>1:\\n        f = pf[n]\\n        ans.add(f)\\n        while n%f == 0:\\n            n //= f\\n    return ans\\n    \\nclass Solution:\\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\\n        global MAXN\\n        n = len(nums)\\n        MAXN = max(nums)+2\\n\\n        pf = sieve()\\n        g = defaultdict(set)\\n\\n        for num in nums:\\n            if num == 1: return len(nums) == 1\\n            factors = fact(num)\\n            for f in factors:\\n                g[f].update(factors)\\n        \\n        seen = set()\\n\\n        def dfs(at):\\n            if at in seen: return\\n            seen.add(at)\\n            for to in g[at]:\\n                dfs(to)\\n        \\n        dfs(pf[nums[0]])\\n        return len(g) == len(seen)\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570427,
                "title": "simple-o-nlog-n-dsu-union-find-seive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\ncombine all prime divisors of a number using union\\nfind if prime divisor of all numbers belong to same set at last or not.\\n\\n# Complexity\\n- Time complexity:\\nO(NlogN)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canTraverseAllPairs(int[] nums) {\\n        int[] firstDiv = new int[mx];\\n        if(nums.length == 1)return true;\\n        for(int i=2;i<mx;i++)firstDiv[i] = i;\\n        for(int i=2;i*i<mx;i++)\\n            for(int j=i*i;j<mx;j+=i)\\n                if(firstDiv[j] == j)firstDiv[j] = i;\\n        DSU dsu = new DSU();\\n        for(int x : nums){\\n            int pD = -1;\\n            if(x == 1)return false;\\n            while(x>1){\\n                int d = firstDiv[x];\\n                if(pD == -1)pD = d;\\n                else dsu.union(pD,d);\\n                pD = d;\\n                while(x%d==0)x/=d;\\n            }\\n        }\\n        int p = -1;\\n        for(int x : nums){\\n            int d = firstDiv[x];\\n            if(p == -1)p = dsu.find(d);\\n            else if(dsu.find(d) != p)return false;\\n        }\\n        return true;\\n    }\\n    int mx = (int)1e5+1;\\n    class DSU{\\n        int [] parent,size;\\n        public DSU(){\\n            parent = new int[mx];\\n            size = new int[mx];\\n            for(int i=1;i<mx;i++){\\n                parent[i] = i;\\n                size[i] = 1;\\n            }\\n        }\\n        public int find(int x){\\n            return x == parent[x]?x:find(parent[x]);\\n        }\\n        public void union(int x,int y){\\n            x = find(x);\\n            y = find(y);\\n            if(x==y)return ;\\n            if(size[x] >= size[y]){\\n                size[x]+=size[y];\\n                parent[y] = x;\\n            }else{\\n                size[y] += size[x];\\n                parent[x] = y;\\n            }\\n        } \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canTraverseAllPairs(int[] nums) {\\n        int[] firstDiv = new int[mx];\\n        if(nums.length == 1)return true;\\n        for(int i=2;i<mx;i++)firstDiv[i] = i;\\n        for(int i=2;i*i<mx;i++)\\n            for(int j=i*i;j<mx;j+=i)\\n                if(firstDiv[j] == j)firstDiv[j] = i;\\n        DSU dsu = new DSU();\\n        for(int x : nums){\\n            int pD = -1;\\n            if(x == 1)return false;\\n            while(x>1){\\n                int d = firstDiv[x];\\n                if(pD == -1)pD = d;\\n                else dsu.union(pD,d);\\n                pD = d;\\n                while(x%d==0)x/=d;\\n            }\\n        }\\n        int p = -1;\\n        for(int x : nums){\\n            int d = firstDiv[x];\\n            if(p == -1)p = dsu.find(d);\\n            else if(dsu.find(d) != p)return false;\\n        }\\n        return true;\\n    }\\n    int mx = (int)1e5+1;\\n    class DSU{\\n        int [] parent,size;\\n        public DSU(){\\n            parent = new int[mx];\\n            size = new int[mx];\\n            for(int i=1;i<mx;i++){\\n                parent[i] = i;\\n                size[i] = 1;\\n            }\\n        }\\n        public int find(int x){\\n            return x == parent[x]?x:find(parent[x]);\\n        }\\n        public void union(int x,int y){\\n            x = find(x);\\n            y = find(y);\\n            if(x==y)return ;\\n            if(size[x] >= size[y]){\\n                size[x]+=size[y];\\n                parent[y] = x;\\n            }else{\\n                size[y] += size[x];\\n                parent[x] = y;\\n            }\\n        } \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570163,
                "title": "modified-sieve-of-eratosthenes-and-union-find-faster-than-100-in-tc",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAll the values which share a common prime factor are connected.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSieve of Erasthonesus only goes till n^0.5 but we need to iterate to the last prime factor of any number. Say for 39 and 26 we need to go to prime factor 13, but if maximum value that is n is 45, the last prime factor visited is 5 as 7*7 > 45. which wont help in our case.\\n\\n# Complexity\\n- Time complexity: O(nums.size() + n + nlogn + nlog(logn))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(4*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nhere n is the maximum element of the vector nums.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<bool> values;\\n    vector<bool> sieve;\\n    vector<int> parent;\\n    vector<int> rank;\\n\\n    int findParent(int x)\\n    {\\n        while(x != parent[x])\\n            x = parent[x];\\n        return x;\\n    }\\n\\n    void unionFind(int x, int y)\\n    {\\n        int r = findParent(x);\\n        int s = findParent(y);\\n\\n        if(r != s)\\n        {\\n            if(rank[r] > rank[s])\\n                parent[s] = r;\\n            else if ( rank[s] > rank[r])\\n                parent[r] = s;\\n            else\\n            {\\n                parent[r] = s;\\n                rank[s]++;\\n            }\\n        }\\n    }\\n\\n    bool canTraverseAllPairs(vector<int>& nums) \\n    {\\n        int n = *max_element(nums.begin(), nums.end());\\n\\n        if( nums.size() == 1 )\\n            return true;\\n\\n        values.assign(n + 1, false);\\n        sieve.assign(n + 1, false);\\n        parent.assign(n + 1, 0);\\n        rank.assign(n + 1, 0);\\n\\n        for(int i = 0; i <= n; i++)\\n            parent[i] = i;\\n\\n        for(auto num : nums)\\n        {\\n            if(num == 1)\\n                return false;\\n            values[num] = true;\\n        }\\n\\n        for(int i = 2; i <= n; i++ )\\n        {\\n            if(sieve[i] == true)\\n                continue;\\n            for(int j = i; j <= n; j += i)\\n            {\\n                sieve[j] = true;\\n                if(values[j] == true)\\n                    unionFind(i, j);\\n            }\\n        }\\n\\n        unordered_set<int> parents;\\n        for(int i = 1; i <= n; i++)\\n            if(values[i] == true)\\n                parents.insert(findParent(i));\\n        \\n        return parents.size() == 1;\\n    }\\n};\\n```\\n\\nPlease Upvote if you like it. Feel free to point out any improvement or error in complexity analysis.\\nThank you. Happy LeetCoding!!\\n",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> values;\\n    vector<bool> sieve;\\n    vector<int> parent;\\n    vector<int> rank;\\n\\n    int findParent(int x)\\n    {\\n        while(x != parent[x])\\n            x = parent[x];\\n        return x;\\n    }\\n\\n    void unionFind(int x, int y)\\n    {\\n        int r = findParent(x);\\n        int s = findParent(y);\\n\\n        if(r != s)\\n        {\\n            if(rank[r] > rank[s])\\n                parent[s] = r;\\n            else if ( rank[s] > rank[r])\\n                parent[r] = s;\\n            else\\n            {\\n                parent[r] = s;\\n                rank[s]++;\\n            }\\n        }\\n    }\\n\\n    bool canTraverseAllPairs(vector<int>& nums) \\n    {\\n        int n = *max_element(nums.begin(), nums.end());\\n\\n        if( nums.size() == 1 )\\n            return true;\\n\\n        values.assign(n + 1, false);\\n        sieve.assign(n + 1, false);\\n        parent.assign(n + 1, 0);\\n        rank.assign(n + 1, 0);\\n\\n        for(int i = 0; i <= n; i++)\\n            parent[i] = i;\\n\\n        for(auto num : nums)\\n        {\\n            if(num == 1)\\n                return false;\\n            values[num] = true;\\n        }\\n\\n        for(int i = 2; i <= n; i++ )\\n        {\\n            if(sieve[i] == true)\\n                continue;\\n            for(int j = i; j <= n; j += i)\\n            {\\n                sieve[j] = true;\\n                if(values[j] == true)\\n                    unionFind(i, j);\\n            }\\n        }\\n\\n        unordered_set<int> parents;\\n        for(int i = 1; i <= n; i++)\\n            if(values[i] == true)\\n                parents.insert(findParent(i));\\n        \\n        return parents.size() == 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570004,
                "title": "java-easy-to-understand-using-prime-factorization-unionfind",
                "content": "```\\nclass Solution {\\n    Map<Integer, Integer> map;\\n    int set[];\\n    private int findParent(int u) {\\n        if(u == set[u]) return u;\\n        return set[u] = findParent(set[u]);\\n    }\\n    private void union(int a, int b) {\\n        int p1 = findParent(a);\\n        int p2 = findParent(b);\\n        if(p1 != p2) {\\n            set[b] = p1;\\n        }\\n        set[p2] = p1;\\n    }\\n    private void solve(int n, int index) {\\n        if(n % 2 == 0) {\\n            int x = map.getOrDefault(2, -1);\\n            if(x != -1) {\\n                union (x, index);\\n            }\\n            while(n % 2 == 0) n /= 2;\\n            map.put(2, index);\\n        }\\n        int sqrt = (int) Math.sqrt(n);\\n        for(int i = 3; i <= sqrt; i++) {\\n            if(n % i == 0) {\\n                int x = map.getOrDefault(i, -1);\\n                if(x != -1) {\\n                    union (x, index);\\n                }\\n                while(n % i == 0) n /= i;\\n                map.put(i, index);\\n            }\\n        }\\n        if(n > 2) {\\n            int x = map.getOrDefault(n, -1);\\n            if(x != -1) {\\n                union (x, index);\\n            }\\n            map.put(n, index);\\n        }\\n    }\\n    public boolean canTraverseAllPairs(int[] nums) {\\n        set = new int[nums.length];\\n        map = new HashMap<>();\\n        for(int i = 0; i < nums.length; i++) set[i] = i;\\n        for(int i = 0; i < nums.length; i++) solve(nums[i], i);\\n        int p = findParent(0);\\n        for(int i = 0; i < nums.length; i++) if(p != findParent(i)) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Map<Integer, Integer> map;\\n    int set[];\\n    private int findParent(int u) {\\n        if(u == set[u]) return u;\\n        return set[u] = findParent(set[u]);\\n    }\\n    private void union(int a, int b) {\\n        int p1 = findParent(a);\\n        int p2 = findParent(b);\\n        if(p1 != p2) {\\n            set[b] = p1;\\n        }\\n        set[p2] = p1;\\n    }\\n    private void solve(int n, int index) {\\n        if(n % 2 == 0) {\\n            int x = map.getOrDefault(2, -1);\\n            if(x != -1) {\\n                union (x, index);\\n            }\\n            while(n % 2 == 0) n /= 2;\\n            map.put(2, index);\\n        }\\n        int sqrt = (int) Math.sqrt(n);\\n        for(int i = 3; i <= sqrt; i++) {\\n            if(n % i == 0) {\\n                int x = map.getOrDefault(i, -1);\\n                if(x != -1) {\\n                    union (x, index);\\n                }\\n                while(n % i == 0) n /= i;\\n                map.put(i, index);\\n            }\\n        }\\n        if(n > 2) {\\n            int x = map.getOrDefault(n, -1);\\n            if(x != -1) {\\n                union (x, index);\\n            }\\n            map.put(n, index);\\n        }\\n    }\\n    public boolean canTraverseAllPairs(int[] nums) {\\n        set = new int[nums.length];\\n        map = new HashMap<>();\\n        for(int i = 0; i < nums.length; i++) set[i] = i;\\n        for(int i = 0; i < nums.length; i++) solve(nums[i], i);\\n        int p = findParent(0);\\n        for(int i = 0; i < nums.length; i++) if(p != findParent(i)) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569957,
                "title": "greatest-common-divisor-traversal-c-explained-solution-faster-than-100-solution",
                "content": "***Upvote If Found Helpful !!!***\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe problem here is quite interesting and needs some prior knowledge of basic **Number Theory** and **Disjoint Set Union**. Now let\\'s try to understand that the numbers having common prime factors are directly connected. Now if any prime factor matches with any other number\\'s prime factor then both can be considered to be as a part of one set (there is always a way to traverse from this number to others). Thus following the above logic, we can say that if at the end of this process, there is only a single set of prime factors, then yes its true for all pairs else not. Now finding prime factors can be easily done using a for loop in square root time. In order to join or merge two sets, we can use disjoint set union. The implementation of above logic goes below : \\n\\n# Complexity\\n- Time complexity: **O(N*sqrt(max(nums[i])))**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(max(nums[i]))**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dsu(vector<int>& parent,int x){\\n        if(parent[x] == -1){\\n            return x;\\n        }\\n        else{\\n            return parent[x] = dsu(parent,parent[x]);\\n        }\\n    }\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        ios_base::sync_with_stdio(0);\\n        int n = nums.size(),mx = *max_element(nums.begin(),nums.end());\\n        if(n == 1 && nums[0] == 1){\\n            return true;\\n        }\\n        vector<bool>f(mx+1,false);\\n        vector<int>parent(mx+1,-1); set<int>primes;\\n        for(int i = 0; i < n; i++){\\n            f[nums[i]] = 1;\\n        }\\n        if(f[1]){\\n            return false;\\n        }\\n        else{\\n            for(int j = 2; j <= mx; j++){\\n                if(f[j]){\\n                    vector<int>c;\\n                    bool check = false;\\n                    int k = j;\\n                    while(k % 2 == 0){\\n                        check = true;\\n                        k /= 2;\\n                    }\\n                    if(check){\\n                        c.push_back(2);\\n                    }\\n                    for(int p = 3; p * p <= k; p++){\\n                        check = false;\\n                        while(k % p == 0){\\n                            check = true;\\n                            k /= p;\\n                        }\\n                        if(check){\\n                            c.push_back(p);\\n                        }\\n                    }\\n                    if(k > 1){\\n                        c.push_back(k);\\n                    }\\n                    int paru = dsu(parent,c[0]); primes.insert(c[0]);\\n                    for(int p = 1; p < c.size(); p++){\\n                        primes.insert(c[p]);\\n                        int parv = dsu(parent,c[p]);\\n                        if(parv != paru){\\n                            parent[parv] = paru;\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n            for(int i = 1; i <= mx; i++){\\n                dsu(parent,i);\\n            }\\n            int ans = 0;\\n            for(auto it : primes){\\n                if(parent[it] == -1){\\n                    ans++;\\n                }\\n            }\\n            return ans == 1;\\n        }\\n    }\\n};\\n```\\n![Screenshot from 2023-05-28 06-35-01.png](https://assets.leetcode.com/users/images/58dc847f-6311-4129-a871-2e73ddea5372_1685235922.5629535.png)\\n",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dsu(vector<int>& parent,int x){\\n        if(parent[x] == -1){\\n            return x;\\n        }\\n        else{\\n            return parent[x] = dsu(parent,parent[x]);\\n        }\\n    }\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        ios_base::sync_with_stdio(0);\\n        int n = nums.size(),mx = *max_element(nums.begin(),nums.end());\\n        if(n == 1 && nums[0] == 1){\\n            return true;\\n        }\\n        vector<bool>f(mx+1,false);\\n        vector<int>parent(mx+1,-1); set<int>primes;\\n        for(int i = 0; i < n; i++){\\n            f[nums[i]] = 1;\\n        }\\n        if(f[1]){\\n            return false;\\n        }\\n        else{\\n            for(int j = 2; j <= mx; j++){\\n                if(f[j]){\\n                    vector<int>c;\\n                    bool check = false;\\n                    int k = j;\\n                    while(k % 2 == 0){\\n                        check = true;\\n                        k /= 2;\\n                    }\\n                    if(check){\\n                        c.push_back(2);\\n                    }\\n                    for(int p = 3; p * p <= k; p++){\\n                        check = false;\\n                        while(k % p == 0){\\n                            check = true;\\n                            k /= p;\\n                        }\\n                        if(check){\\n                            c.push_back(p);\\n                        }\\n                    }\\n                    if(k > 1){\\n                        c.push_back(k);\\n                    }\\n                    int paru = dsu(parent,c[0]); primes.insert(c[0]);\\n                    for(int p = 1; p < c.size(); p++){\\n                        primes.insert(c[p]);\\n                        int parv = dsu(parent,c[p]);\\n                        if(parv != paru){\\n                            parent[parv] = paru;\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n            for(int i = 1; i <= mx; i++){\\n                dsu(parent,i);\\n            }\\n            int ans = 0;\\n            for(auto it : primes){\\n                if(parent[it] == -1){\\n                    ans++;\\n                }\\n            }\\n            return ans == 1;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569936,
                "title": "python-prime-factorization-union-find",
                "content": "**Idea:**\\n - calculate prime factorization for each number between 1 and 10^5 before running the solution\\n - for each number for each of it\\'s primes if we we saw the number with the same prime union it\\'s indexes\\n - check if union-find size is 1\\n\\n\\n```python\\ndef prime_factorization(n):\\n    factors = []\\n    i = 2\\n    while i * i <= n:\\n        if n % i:\\n            i += 1\\n        else:\\n            n //= i\\n            factors.append(i)\\n    if n > 1:\\n        factors.append(n)\\n    return factors\\n\\n# find prime factors of all intergers before calling it\\nc = defaultdict(list)\\nfor x in range(2,10**5+1):\\n    c[x] = prime_factorization(x)\\n\\nclass Solution:\\n    def canTraverseAllPairs(self, A: List[int]) -> bool:\\n        N = len(A)\\n        UF = {}\\n        def find(x):\\n            if x != UF[x]:\\n                UF[x] = find(UF[x])\\n            return UF[x]\\n\\n\\n        def union(x,y):\\n            UF.setdefault(x,x)\\n            UF.setdefault(y,y)\\n            UF[find(x)] = find(y)\\n        \\n        \\n        hm = {}\\n        for i,x in enumerate(A):\\n            union(i,i)\\n            for y in c[x]:\\n                if y in hm:\\n                    # merge with the elemets that have the same primes\\n                    union(hm[y],i)\\n                hm[y] = i\\n        \\n        s = set()\\n        for i in range(N):\\n            s.add(find(i))\\n        return len(s) == 1\\n    \\n```\\n\\nTime: `O(N*P)`\\nSpace: `O(N*P)`\\n\\nwhere P is maximum of prime factors in a number between 1 and 10^5",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```python\\ndef prime_factorization(n):\\n    factors = []\\n    i = 2\\n    while i * i <= n:\\n        if n % i:\\n            i += 1\\n        else:\\n            n //= i\\n            factors.append(i)\\n    if n > 1:\\n        factors.append(n)\\n    return factors\\n\\n# find prime factors of all intergers before calling it\\nc = defaultdict(list)\\nfor x in range(2,10**5+1):\\n    c[x] = prime_factorization(x)\\n\\nclass Solution:\\n    def canTraverseAllPairs(self, A: List[int]) -> bool:\\n        N = len(A)\\n        UF = {}\\n        def find(x):\\n            if x != UF[x]:\\n                UF[x] = find(UF[x])\\n            return UF[x]\\n\\n\\n        def union(x,y):\\n            UF.setdefault(x,x)\\n            UF.setdefault(y,y)\\n            UF[find(x)] = find(y)\\n        \\n        \\n        hm = {}\\n        for i,x in enumerate(A):\\n            union(i,i)\\n            for y in c[x]:\\n                if y in hm:\\n                    # merge with the elemets that have the same primes\\n                    union(hm[y],i)\\n                hm[y] = i\\n        \\n        s = set()\\n        for i in range(N):\\n            s.add(find(i))\\n        return len(s) == 1\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569917,
                "title": "1-dfs-easy-c-solution-explained-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFinding out all the factors of all given numbers and  connecting all the numbers with mutual factors , if they form one single connected component then traversal is possible \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing simple dfs on graph that connects numbers in given array to their factors and vice versa. Generating adjacency list for this graph using gets function . explained in comments of solution below.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n\\n    // PLEASE UPVOTE IF HELPFUL\\n    \\n    \\n    // maximum value in nums\\n    int maxi = 0;\\n\\n    //generate adjacency list in O(nlogn)\\n    void gets(vector<int>&pres, vector<vector<int>>&adj){\\n        for(int i=2; i<=maxi;i++){\\n            for(int j = 2; j*i<=maxi;j++){\\n                if(pres[i*j]==0)continue;\\n                adj[i].push_back(i*j);\\n                adj[i*j].push_back(i);\\n            }\\n        }\\n    }\\n\\n    // normal dfs\\n    void dfs(int ind,vector<int>&vis , vector<vector<int>>&adj){\\n        vis[ind] = 1;\\n\\n        for(auto it: adj[ind]){\\n            if(!vis[it]){\\n                dfs(it,vis,adj);\\n            }\\n        }\\n    }\\n    \\n    \\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        if(nums.size()==1)return 1;\\n        vector<int>pres(100005,0); // marks all numbers in nums[i] = 1 ;\\n        \\n        \\n        int one = 0;\\n        \\n        //loop to find out if there are any 1 , mark all elements in pres array and find maximum element\\n        for(int i=0; i<nums.size(); i++){pres[nums[i]]=1, maxi = max(maxi,nums[i]);if(nums[i]==1)one=1;}\\n        \\n        \\n        // using maximum element vaue to declare adjacency list size\\n        vector<vector<int>>adj(maxi+1);\\n        \\n        // generating adjacency list\\n        gets(pres,adj);\\n        \\n        // return false if there is any 1 in array\\n        if(one)return false;\\n        \\n        vector<int>vis(maxi+1,0);\\n        \\n        // number of connected components \\n        // all the numbers having common factor greater then 1 are in one connected component\\n        int cc = 0;\\n        \\n        //dfs call // if there are multiple connected components it means that numbers in those different components \\n        ///////////// do not have a a common factor greater than 1 which means traversal is not possible\\n        for(int i=0; i<nums.size(); i++){\\n            if(!vis[nums[i]]){\\n                if(cc)return 0;\\n                dfs(nums[i],vis,adj);\\n                cc++;\\n            }\\n        }        \\n        \\n        return 1;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\n    // PLEASE UPVOTE IF HELPFUL\\n    \\n    \\n    // maximum value in nums\\n    int maxi = 0;\\n\\n    //generate adjacency list in O(nlogn)\\n    void gets(vector<int>&pres, vector<vector<int>>&adj){\\n        for(int i=2; i<=maxi;i++){\\n            for(int j = 2; j*i<=maxi;j++){\\n                if(pres[i*j]==0)continue;\\n                adj[i].push_back(i*j);\\n                adj[i*j].push_back(i);\\n            }\\n        }\\n    }\\n\\n    // normal dfs\\n    void dfs(int ind,vector<int>&vis , vector<vector<int>>&adj){\\n        vis[ind] = 1;\\n\\n        for(auto it: adj[ind]){\\n            if(!vis[it]){\\n                dfs(it,vis,adj);\\n            }\\n        }\\n    }\\n    \\n    \\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        if(nums.size()==1)return 1;\\n        vector<int>pres(100005,0); // marks all numbers in nums[i] = 1 ;\\n        \\n        \\n        int one = 0;\\n        \\n        //loop to find out if there are any 1 , mark all elements in pres array and find maximum element\\n        for(int i=0; i<nums.size(); i++){pres[nums[i]]=1, maxi = max(maxi,nums[i]);if(nums[i]==1)one=1;}\\n        \\n        \\n        // using maximum element vaue to declare adjacency list size\\n        vector<vector<int>>adj(maxi+1);\\n        \\n        // generating adjacency list\\n        gets(pres,adj);\\n        \\n        // return false if there is any 1 in array\\n        if(one)return false;\\n        \\n        vector<int>vis(maxi+1,0);\\n        \\n        // number of connected components \\n        // all the numbers having common factor greater then 1 are in one connected component\\n        int cc = 0;\\n        \\n        //dfs call // if there are multiple connected components it means that numbers in those different components \\n        ///////////// do not have a a common factor greater than 1 which means traversal is not possible\\n        for(int i=0; i<nums.size(); i++){\\n            if(!vis[nums[i]]){\\n                if(cc)return 0;\\n                dfs(nums[i],vis,adj);\\n                cc++;\\n            }\\n        }        \\n        \\n        return 1;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569883,
                "title": "my-solutions",
                "content": "**1. Use the Disjoint Set**\\n```\\nclass Solution {\\n private:\\n  class DisjointSet {\\n   public:\\n    DisjointSet(const int n) : parents_(n), ranks_(n) {\\n      iota(parents_.begin(), parents_.end(), 0);\\n    }\\n    \\n    int find(const int i) {\\n      if (parents_[i] == i) {\\n        return i;\\n      }\\n      parents_[i] = find(parents_[i]);\\n      return parents_[i];\\n    }\\n    \\n    bool do_union(const int i, const int j) {\\n      const int parent_i = find(i);\\n      const int parent_j = find(j);\\n      if (parent_i == parent_j) {\\n        return false;\\n      }\\n      \\n      if (ranks_[parent_i] < ranks_[parent_j]) {\\n        parents_[parent_i] = parent_j;\\n      } else if (ranks_[parent_i] > ranks_[parent_j]) {\\n        parents_[parent_j] = parent_i;\\n      } else {\\n        parents_[parent_i] = parent_j;\\n        ++ranks_[parent_j];\\n      }\\n      return true;\\n    }\\n    \\n   private:\\n    vector<int> parents_;\\n    vector<int> ranks_;\\n  };\\n  \\n public:\\n  bool canTraverseAllPairs(const vector<int> &nums) {\\n    const int n = static_cast<int>(nums.size());\\n    unordered_map<int, vector<int>> factor_to_indices;\\n    for (int i = 0; i < n; ++i) {\\n      int num = nums[i];\\n      if (num % 2 == 0) {\\n        factor_to_indices[2].emplace_back(i);\\n        for (; num % 2 == 0; num /= 2) {\\n        }\\n      }\\n      for (int factor = 3; factor * factor <= num; factor += 2) {\\n        if (num % factor == 0) {\\n          factor_to_indices[factor].emplace_back(i);\\n          for (; num % factor == 0; num /= factor) {\\n          }\\n        }\\n      }\\n      if (num > 1) {\\n        factor_to_indices[num].emplace_back(i);\\n      }\\n    }\\n    \\n    DisjointSet ds(n);\\n    int groups = n;\\n    for (const auto &[_, indices] : factor_to_indices) {\\n      for (size_t i = 1; i < indices.size(); ++i) {\\n        if (ds.do_union(indices.front(), indices[i])) {\\n          --groups;\\n        }\\n      }\\n    }\\n    return groups == 1;\\n  }\\n};\\n```\\n**2. Use DFS**\\n```\\n/**\\n * Time Complexity: O(n * (n +sqrt(max_num)))\\n * Space Complexity: O(n * (n + sqrt(max_num)))\\n * where `n` is the length of the vector `nums`\\n *       `max_num` is the maximum number of the vector `nums`\\n */\\nclass Solution {\\n public:\\n  bool canTraverseAllPairs(const vector<int> &nums) {\\n    const int n = static_cast<int>(nums.size());\\n    unordered_map<int, vector<int>> factor_to_indices;\\n    for (int i = 0; i < n; ++i) {\\n      int num = nums[i];\\n      if (num % 2 == 0) {\\n        factor_to_indices[2].emplace_back(i);\\n        for (; num % 2 == 0; num /= 2) {\\n        }\\n      }\\n      for (int factor = 3; factor * factor <= num; factor += 2) {\\n        if (num % factor == 0) {\\n          factor_to_indices[factor].emplace_back(i);\\n          for (; num % factor == 0; num /= factor) {\\n          }\\n        }\\n      }\\n      if (num > 1) {\\n        factor_to_indices[num].emplace_back(i);\\n      }\\n    }\\n    \\n    unordered_set<int> graph[n];\\n    for (const auto &[_, indices] : factor_to_indices) {\\n      for (size_t i = 1; i < indices.size(); ++i) {\\n        graph[indices.front()].emplace(indices[i]);\\n        graph[indices[i]].emplace(indices.front());\\n      }\\n    }\\n    \\n    bool visited[n];\\n    memset(visited, 0, sizeof(visited));\\n    int groups = 0;\\n    for (int i = 0; i < n; ++i) {\\n      if (!visited[i]) {\\n        if (++groups > 1) {\\n          break;\\n        }\\n        dfs(graph, i, visited);\\n      }\\n    }\\n    return groups == 1;\\n  }\\n  \\n private:\\n  void dfs(const unordered_set<int> *graph, const int node, bool *visited) {\\n    visited[node] = true;\\n    for (const int next : graph[node]) {\\n      if (!visited[next]) {\\n        dfs(graph, next, visited);\\n      }\\n    }\\n  }\\n};\\n```\\n**3. Use the BFS**\\n```\\n/**\\n * Time Complexity: O(n * (n +sqrt(max_num)))\\n * Space Complexity: O(n * (n + sqrt(max_num)))\\n * where `n` is the length of the vector `nums`\\n *       `max_num` is the maximum number of the vector `nums`\\n */\\nclass Solution {\\n public:\\n  bool canTraverseAllPairs(const vector<int> &nums) {\\n    const int n = static_cast<int>(nums.size());\\n    unordered_map<int, vector<int>> factor_to_indices;\\n    for (int i = 0; i < n; ++i) {\\n      int num = nums[i];\\n      if (num % 2 == 0) {\\n        factor_to_indices[2].emplace_back(i);\\n        for (; num % 2 == 0; num /= 2) {\\n        }\\n      }\\n      for (int factor = 3; factor * factor <= num; factor += 2) {\\n        if (num % factor == 0) {\\n          factor_to_indices[factor].emplace_back(i);\\n          for (; num % factor == 0; num /= factor) {\\n          }\\n        }\\n      }\\n      if (num > 1) {\\n        factor_to_indices[num].emplace_back(i);\\n      }\\n    }\\n    \\n    unordered_set<int> graph[n];\\n    for (const auto &[_, indices] : factor_to_indices) {\\n      for (size_t i = 1; i < indices.size(); ++i) {\\n        graph[indices.front()].emplace(indices[i]);\\n        graph[indices[i]].emplace(indices.front());\\n      }\\n    }\\n    \\n    bool visited[n];\\n    memset(visited, 0, sizeof(visited));\\n    int groups = 0;\\n    for (int i = 0; i < n; ++i) {\\n      if (!visited[i]) {\\n        if (++groups > 1) {\\n          break;\\n        }\\n        bfs(graph, i, visited);\\n      }\\n    }\\n    return groups == 1;\\n  }\\n  \\n private:\\n  void bfs(const unordered_set<int> *graph, const int node, bool *visited) {\\n    queue<int> q({node});\\n    visited[node] = true;\\n    while (!q.empty()) {\\n      const int current_node = q.front();\\n      q.pop();\\n      for (const int next_node : graph[current_node]) {\\n        if (!visited[next_node]) {\\n          q.emplace(next_node);\\n          visited[next_node] = true;\\n        }\\n      }\\n    }\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n private:\\n  class DisjointSet {\\n   public:\\n    DisjointSet(const int n) : parents_(n), ranks_(n) {\\n      iota(parents_.begin(), parents_.end(), 0);\\n    }\\n    \\n    int find(const int i) {\\n      if (parents_[i] == i) {\\n        return i;\\n      }\\n      parents_[i] = find(parents_[i]);\\n      return parents_[i];\\n    }\\n    \\n    bool do_union(const int i, const int j) {\\n      const int parent_i = find(i);\\n      const int parent_j = find(j);\\n      if (parent_i == parent_j) {\\n        return false;\\n      }\\n      \\n      if (ranks_[parent_i] < ranks_[parent_j]) {\\n        parents_[parent_i] = parent_j;\\n      } else if (ranks_[parent_i] > ranks_[parent_j]) {\\n        parents_[parent_j] = parent_i;\\n      } else {\\n        parents_[parent_i] = parent_j;\\n        ++ranks_[parent_j];\\n      }\\n      return true;\\n    }\\n    \\n   private:\\n    vector<int> parents_;\\n    vector<int> ranks_;\\n  };\\n  \\n public:\\n  bool canTraverseAllPairs(const vector<int> &nums) {\\n    const int n = static_cast<int>(nums.size());\\n    unordered_map<int, vector<int>> factor_to_indices;\\n    for (int i = 0; i < n; ++i) {\\n      int num = nums[i];\\n      if (num % 2 == 0) {\\n        factor_to_indices[2].emplace_back(i);\\n        for (; num % 2 == 0; num /= 2) {\\n        }\\n      }\\n      for (int factor = 3; factor * factor <= num; factor += 2) {\\n        if (num % factor == 0) {\\n          factor_to_indices[factor].emplace_back(i);\\n          for (; num % factor == 0; num /= factor) {\\n          }\\n        }\\n      }\\n      if (num > 1) {\\n        factor_to_indices[num].emplace_back(i);\\n      }\\n    }\\n    \\n    DisjointSet ds(n);\\n    int groups = n;\\n    for (const auto &[_, indices] : factor_to_indices) {\\n      for (size_t i = 1; i < indices.size(); ++i) {\\n        if (ds.do_union(indices.front(), indices[i])) {\\n          --groups;\\n        }\\n      }\\n    }\\n    return groups == 1;\\n  }\\n};\\n```\n```\\n/**\\n * Time Complexity: O(n * (n +sqrt(max_num)))\\n * Space Complexity: O(n * (n + sqrt(max_num)))\\n * where `n` is the length of the vector `nums`\\n *       `max_num` is the maximum number of the vector `nums`\\n */\\nclass Solution {\\n public:\\n  bool canTraverseAllPairs(const vector<int> &nums) {\\n    const int n = static_cast<int>(nums.size());\\n    unordered_map<int, vector<int>> factor_to_indices;\\n    for (int i = 0; i < n; ++i) {\\n      int num = nums[i];\\n      if (num % 2 == 0) {\\n        factor_to_indices[2].emplace_back(i);\\n        for (; num % 2 == 0; num /= 2) {\\n        }\\n      }\\n      for (int factor = 3; factor * factor <= num; factor += 2) {\\n        if (num % factor == 0) {\\n          factor_to_indices[factor].emplace_back(i);\\n          for (; num % factor == 0; num /= factor) {\\n          }\\n        }\\n      }\\n      if (num > 1) {\\n        factor_to_indices[num].emplace_back(i);\\n      }\\n    }\\n    \\n    unordered_set<int> graph[n];\\n    for (const auto &[_, indices] : factor_to_indices) {\\n      for (size_t i = 1; i < indices.size(); ++i) {\\n        graph[indices.front()].emplace(indices[i]);\\n        graph[indices[i]].emplace(indices.front());\\n      }\\n    }\\n    \\n    bool visited[n];\\n    memset(visited, 0, sizeof(visited));\\n    int groups = 0;\\n    for (int i = 0; i < n; ++i) {\\n      if (!visited[i]) {\\n        if (++groups > 1) {\\n          break;\\n        }\\n        dfs(graph, i, visited);\\n      }\\n    }\\n    return groups == 1;\\n  }\\n  \\n private:\\n  void dfs(const unordered_set<int> *graph, const int node, bool *visited) {\\n    visited[node] = true;\\n    for (const int next : graph[node]) {\\n      if (!visited[next]) {\\n        dfs(graph, next, visited);\\n      }\\n    }\\n  }\\n};\\n```\n```\\n/**\\n * Time Complexity: O(n * (n +sqrt(max_num)))\\n * Space Complexity: O(n * (n + sqrt(max_num)))\\n * where `n` is the length of the vector `nums`\\n *       `max_num` is the maximum number of the vector `nums`\\n */\\nclass Solution {\\n public:\\n  bool canTraverseAllPairs(const vector<int> &nums) {\\n    const int n = static_cast<int>(nums.size());\\n    unordered_map<int, vector<int>> factor_to_indices;\\n    for (int i = 0; i < n; ++i) {\\n      int num = nums[i];\\n      if (num % 2 == 0) {\\n        factor_to_indices[2].emplace_back(i);\\n        for (; num % 2 == 0; num /= 2) {\\n        }\\n      }\\n      for (int factor = 3; factor * factor <= num; factor += 2) {\\n        if (num % factor == 0) {\\n          factor_to_indices[factor].emplace_back(i);\\n          for (; num % factor == 0; num /= factor) {\\n          }\\n        }\\n      }\\n      if (num > 1) {\\n        factor_to_indices[num].emplace_back(i);\\n      }\\n    }\\n    \\n    unordered_set<int> graph[n];\\n    for (const auto &[_, indices] : factor_to_indices) {\\n      for (size_t i = 1; i < indices.size(); ++i) {\\n        graph[indices.front()].emplace(indices[i]);\\n        graph[indices[i]].emplace(indices.front());\\n      }\\n    }\\n    \\n    bool visited[n];\\n    memset(visited, 0, sizeof(visited));\\n    int groups = 0;\\n    for (int i = 0; i < n; ++i) {\\n      if (!visited[i]) {\\n        if (++groups > 1) {\\n          break;\\n        }\\n        bfs(graph, i, visited);\\n      }\\n    }\\n    return groups == 1;\\n  }\\n  \\n private:\\n  void bfs(const unordered_set<int> *graph, const int node, bool *visited) {\\n    queue<int> q({node});\\n    visited[node] = true;\\n    while (!q.empty()) {\\n      const int current_node = q.front();\\n      q.pop();\\n      for (const int next_node : graph[current_node]) {\\n        if (!visited[next_node]) {\\n          q.emplace(next_node);\\n          visited[next_node] = true;\\n        }\\n      }\\n    }\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569878,
                "title": "greedy-python-solution",
                "content": "# Intuition\\nWhen we find two items from the array which have a gcd > 1, we can remove both of them and replace them with their product. We can also divide the product with the gcd to keep the numbers smaller.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- We will select an item from the array and begin to iterate through the array. \\n- Once we encounter a number which has a gcd > 1 with our item, we will update our item and remove the number. \\n- If we have been able to remove all the numbers from the array we will return True.\\n- If we have iterated through the entire array without updating our item, we will return False.\\n- We will continue iterating trough the array until one of the above conditions have been reached.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: \\nI don\\'t know how to calculate the time complexity of this one. The solution passed, but wasn\\'t particularly fast.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom math import gcd\\n\\nclass Solution:\\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\\n        \\n        #Select an item from the array\\n        item = nums.pop()\\n                \\n        while True:\\n\\n            prev = item\\n            i = len(nums) - 1\\n            \\n            #Iterate through the array\\n            while i >= 0:\\n\\n                divisor = gcd(item, nums[i])\\n                \\n                #Match found, update both item and array\\n                if divisor > 1:\\n                    item *= nums[i] // divisor\\n                    nums.pop(i)\\n                \\n                i -= 1\\n                \\n            #Test for True result\\n            if not nums:\\n                return True\\n\\n            #Test for False result\\n            if prev == item:\\n                return False\\n                    \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nfrom math import gcd\\n\\nclass Solution:\\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\\n        \\n        #Select an item from the array\\n        item = nums.pop()\\n                \\n        while True:\\n\\n            prev = item\\n            i = len(nums) - 1\\n            \\n            #Iterate through the array\\n            while i >= 0:\\n\\n                divisor = gcd(item, nums[i])\\n                \\n                #Match found, update both item and array\\n                if divisor > 1:\\n                    item *= nums[i] // divisor\\n                    nums.pop(i)\\n                \\n                i -= 1\\n                \\n            #Test for True result\\n            if not nums:\\n                return True\\n\\n            #Test for False result\\n            if prev == item:\\n                return False\\n                    \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569841,
                "title": "python-python3-dfs-easy-understanding",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSee, since we are asked if we can go to every element from each other, think it like a CONNECTED COMPONENT GRAPH type problem\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNow consider an array of 3 elements. Let\\'s say numbers are A, B and C.\\nif A and B have no factors common in them, we would have to go to B through C, so C and A must have a common factor between them. \\nso similarly to go to element A[j] from A[i], either they have a common factor between them or there should be a path from A[j] to A[i]. consider an example of 4,3,21,7, 12. \\nFor element 4:\\n    . we cannot go to 3 directly, we need to go throgh 12 ( 4 and 12 have a common factor)\\n    . to go to 7 from 4 ,this is how our path will look like:\\n        4 -> 12 -> 21 -> 7\\nso we see that there should be path between elements including factor of other element\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n- O(N * (N)^(1/2)) basically N root N\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- N root N\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canTraverseAllPairs(self, arr : List[int]) -> bool:\\n        \\n        if len(arr) == 1:\\n            return True\\n        if 1 in arr:\\n            return False\\n        d = defaultdict(lambda : set())\\n        \\n        def primeFactors(n):\\n            s = set()\\n            # num = n\\n            while n % 2 == 0:\\n                s.add(2)\\n                n = n // 2\\n            for i in range(3,int(math.sqrt(n))+1,2):\\n                if n%i == 0:\\n                    s.add(i)\\n                while n % i== 0:\\n                    n = n // i\\n            if n> 2:\\n                s.add(n)\\n            return s\\n\\n        g = defaultdict(list)\\n        for i in range(len(arr)) :\\n            st = primeFactors(arr[i])\\n            # print(\\'i :\\', arr[i], \\'st :\\', st)\\n            for item in st:\\n                g[arr[i]].append(item)\\n                g[item].append(arr[i])\\n        # print(g)\\n        vis = defaultdict(int)\\n        def helper(node):\\n            # print(\\'node :\\', node)\\n            vis[node] =1\\n            for child in g[node]:\\n                if vis[child] == 0:\\n                    helper(child)\\n        helper(arr[0]) \\n        # print(vis)\\n        for i in arr:\\n            if vis[i] == 0:\\n                return False\\n        return True\\n        \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n       \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def canTraverseAllPairs(self, arr : List[int]) -> bool:\\n        \\n        if len(arr) == 1:\\n            return True\\n        if 1 in arr:\\n            return False\\n        d = defaultdict(lambda : set())\\n        \\n        def primeFactors(n):\\n            s = set()\\n            # num = n\\n            while n % 2 == 0:\\n                s.add(2)\\n                n = n // 2\\n            for i in range(3,int(math.sqrt(n))+1,2):\\n                if n%i == 0:\\n                    s.add(i)\\n                while n % i== 0:\\n                    n = n // i\\n            if n> 2:\\n                s.add(n)\\n            return s\\n\\n        g = defaultdict(list)\\n        for i in range(len(arr)) :\\n            st = primeFactors(arr[i])\\n            # print(\\'i :\\', arr[i], \\'st :\\', st)\\n            for item in st:\\n                g[arr[i]].append(item)\\n                g[item].append(arr[i])\\n        # print(g)\\n        vis = defaultdict(int)\\n        def helper(node):\\n            # print(\\'node :\\', node)\\n            vis[node] =1\\n            for child in g[node]:\\n                if vis[child] == 0:\\n                    helper(child)\\n        helper(arr[0]) \\n        # print(vis)\\n        for i in arr:\\n            if vis[i] == 0:\\n                return False\\n        return True\\n        \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569719,
                "title": "dfs",
                "content": "- edge `(a, b)` iff `a` and `b` have common prime factor `f`\\n- any factor `f` is checked only once\\n```\\nclass Solution {\\npublic:\\n    bool canTraverseAllPairs(vector<int>& _nums) {\\n        if(*min_element(_nums.begin(), _nums.end()) == 1)\\n            return _nums.size() == 1;\\n           \\n        int max = *max_element(_nums.begin(), _nums.end());\\n        unordered_set<int> nums(_nums.begin(), _nums.end()); \\n        \\n        unordered_map<int, unordered_set<int>> n2factor(max+1); //map number to its prime factors\\n        unordered_map<int, unordered_set<int>> factor2n(max+1); //map prime factor to numbers havint it as factor\\n        vector<bool> composite(max+1, false); \\n        for(int p = 2; p <= max; ++p) {\\n            if(composite[p]) continue;\\n            for(int n = p; n <= max; n += p) {\\n                if(n != p)\\n                    composite[n] = true;\\n                if(nums.count(n)) {\\n                    n2factor[n].insert(p);\\n                    factor2n[p].insert(n);\\n                }\\n            }\\n        }\\n        unordered_set<int> visited;\\n        unordered_set<int> factorchecked;\\n        function<void(int)> dfs = [&dfs,&factorchecked, &visited, &n2factor, &factor2n] (int n) {\\n            if(visited.insert(n).second) {\\n                for(auto f : n2factor[n]) {\\n                    if(!factorchecked.insert(f).second) continue;\\n                    for(auto N : factor2n[f])\\n                        dfs(N);\\n                }\\n            }\\n        };\\n        dfs(max);\\n        return visited.size() == nums.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canTraverseAllPairs(vector<int>& _nums) {\\n        if(*min_element(_nums.begin(), _nums.end()) == 1)\\n            return _nums.size() == 1;\\n           \\n        int max = *max_element(_nums.begin(), _nums.end());\\n        unordered_set<int> nums(_nums.begin(), _nums.end()); \\n        \\n        unordered_map<int, unordered_set<int>> n2factor(max+1); //map number to its prime factors\\n        unordered_map<int, unordered_set<int>> factor2n(max+1); //map prime factor to numbers havint it as factor\\n        vector<bool> composite(max+1, false); \\n        for(int p = 2; p <= max; ++p) {\\n            if(composite[p]) continue;\\n            for(int n = p; n <= max; n += p) {\\n                if(n != p)\\n                    composite[n] = true;\\n                if(nums.count(n)) {\\n                    n2factor[n].insert(p);\\n                    factor2n[p].insert(n);\\n                }\\n            }\\n        }\\n        unordered_set<int> visited;\\n        unordered_set<int> factorchecked;\\n        function<void(int)> dfs = [&dfs,&factorchecked, &visited, &n2factor, &factor2n] (int n) {\\n            if(visited.insert(n).second) {\\n                for(auto f : n2factor[n]) {\\n                    if(!factorchecked.insert(f).second) continue;\\n                    for(auto N : factor2n[f])\\n                        dfs(N);\\n                }\\n            }\\n        };\\n        dfs(max);\\n        return visited.size() == nums.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569701,
                "title": "c-solution-without-dfs-or-union-find",
                "content": "# Code\\n```\\n#define MAXN 100001\\nint spf[MAXN];\\nvoid sieve(){\\n    spf[1] = 1;\\n    for (int i = 2; i < MAXN; i++)\\n        spf[i] = i;\\n \\n    for (int i = 4; i < MAXN; i += 2)\\n        spf[i] = 2;\\n \\n    for (int i = 3; i * i < MAXN; i++) {\\n        if (spf[i] == i) {\\n            for (int j = i * i; j < MAXN; j += i)\\n                if (spf[j] == j)\\n                    spf[j] = i;\\n        }\\n    }\\n}\\nvector<int> getFactorization(int x)\\n{\\n    vector<int> r;\\n    set<int> ret;\\n\\n    while (x != 1) {\\n        ret.insert(spf[x]);\\n        x = x / spf[x];    \\n    }\\n    for(auto i: ret){\\n        r.push_back(i);\\n    }\\n    return r;\\n}\\nbool flag = true;\\nclass Solution {\\npublic:\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        if(flag){\\n            sieve();\\n            flag=false;\\n        }\\n        map<int,vector<int>>mp;\\n        map<int,vector<int>>fact;\\n        if(nums.size()==1){\\n            return true;\\n        }\\n        set<int>s;\\n        for(auto i: nums){\\n            if(i==1){\\n                return false;\\n            }\\n            vector<int>temp=getFactorization(i);\\n            fact[i]=temp;\\n            for(auto j: temp){\\n                mp[j].push_back(i);\\n                s.insert(j);\\n            }\\n        }\\n        map<int,int>m;\\n        int p=1e5,q=0;\\n        for(auto i: s){\\n            set<int>st;\\n            if(m[i]==0){\\n                q=0;\\n                for(auto j: mp[i]){\\n                    for(auto k: fact[j]){\\n                        if(m[k]>0){\\n                            q=m[k];\\n                        }    \\n                        st.insert(k);\\n                    }\\n                }\\n                if(q==0){\\n                    for(auto k: st){\\n                        m[k]=p;\\n                    }\\n                    p++;\\n                }\\n                else{\\n                    for(auto k: st){\\n                        m[k]=q;\\n                    }\\n                }\\n            }\\n            else{\\n                for(auto j: mp[i]){\\n                    for(auto k: fact[j]){ \\n                        m[k]=m[i];\\n                    }\\n                }   \\n            }\\n        }\\n        \\n        \\n        for(auto i: m){\\n            p=i.second;\\n            break;\\n        }\\n        for(auto i: m){\\n            if(p!=i.second){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define MAXN 100001\\nint spf[MAXN];\\nvoid sieve(){\\n    spf[1] = 1;\\n    for (int i = 2; i < MAXN; i++)\\n        spf[i] = i;\\n \\n    for (int i = 4; i < MAXN; i += 2)\\n        spf[i] = 2;\\n \\n    for (int i = 3; i * i < MAXN; i++) {\\n        if (spf[i] == i) {\\n            for (int j = i * i; j < MAXN; j += i)\\n                if (spf[j] == j)\\n                    spf[j] = i;\\n        }\\n    }\\n}\\nvector<int> getFactorization(int x)\\n{\\n    vector<int> r;\\n    set<int> ret;\\n\\n    while (x != 1) {\\n        ret.insert(spf[x]);\\n        x = x / spf[x];    \\n    }\\n    for(auto i: ret){\\n        r.push_back(i);\\n    }\\n    return r;\\n}\\nbool flag = true;\\nclass Solution {\\npublic:\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        if(flag){\\n            sieve();\\n            flag=false;\\n        }\\n        map<int,vector<int>>mp;\\n        map<int,vector<int>>fact;\\n        if(nums.size()==1){\\n            return true;\\n        }\\n        set<int>s;\\n        for(auto i: nums){\\n            if(i==1){\\n                return false;\\n            }\\n            vector<int>temp=getFactorization(i);\\n            fact[i]=temp;\\n            for(auto j: temp){\\n                mp[j].push_back(i);\\n                s.insert(j);\\n            }\\n        }\\n        map<int,int>m;\\n        int p=1e5,q=0;\\n        for(auto i: s){\\n            set<int>st;\\n            if(m[i]==0){\\n                q=0;\\n                for(auto j: mp[i]){\\n                    for(auto k: fact[j]){\\n                        if(m[k]>0){\\n                            q=m[k];\\n                        }    \\n                        st.insert(k);\\n                    }\\n                }\\n                if(q==0){\\n                    for(auto k: st){\\n                        m[k]=p;\\n                    }\\n                    p++;\\n                }\\n                else{\\n                    for(auto k: st){\\n                        m[k]=q;\\n                    }\\n                }\\n            }\\n            else{\\n                for(auto j: mp[i]){\\n                    for(auto k: fact[j]){ \\n                        m[k]=m[i];\\n                    }\\n                }   \\n            }\\n        }\\n        \\n        \\n        for(auto i: m){\\n            p=i.second;\\n            break;\\n        }\\n        for(auto i: m){\\n            if(p!=i.second){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569677,
                "title": "dsu-numbertheory-simple-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<int>par;\\n    vector<int>ran;\\n    int find_par(int node) {\\n        if(par[node] == node) {\\n            return node;\\n        }\\n        return par[node] = find_par(par[node]);\\n    }\\n\\n    void merge(int a, int b) {\\n        if(ran[a] >= ran[b]) {      \\n            ran[a] += ran[b];\\n            par[b] = a;\\n        }\\n        else{\\n            par[a] = b;        \\n            ran[b] += ran[a];\\n        }\\n    }\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int n = nums.size();\\n        par = vector<int>(n+1);\\n        ran = vector<int>(n+1, 1);\\n        \\n        for(int i=0; i<n; i++) {\\n            par[i] = i;\\n        }\\n        map<int,vector<int>>m;\\n        for(int i=0; i<n; i++) {\\n            int num = nums[i];\\n            if(nums[i] != 1) {\\n                m[nums[i]].push_back(i);\\n            }\\n            int k = sqrt(num);\\n            for(int j=2; j<=k; j++) {\\n                if(num%j == 0) {\\n                    m[j].push_back(i);\\n                    m[num/j].push_back(i);\\n                }\\n            }\\n        }\\n        \\n        for(auto it: m) {\\n            vector<int>v = it.second;\\n            if(v.size() >= 2) {\\n                //cout << v[0] << endl;\\n                for(int j=1; j<v.size(); j++) {\\n                   // cout << v[j] << endl;\\n                    int a = find_par(v[j]);\\n                    int b = find_par(v[0]);\\n                    if(a == b) {\\n                        continue;\\n                    }\\n                    merge(a, b);     \\n                }\\n            }\\n        }\\n         int x = *max_element(ran.begin(), ran.end());\\n        if(x != n) {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int>par;\\n    vector<int>ran;\\n    int find_par(int node) {\\n        if(par[node] == node) {\\n            return node;\\n        }\\n        return par[node] = find_par(par[node]);\\n    }\\n\\n    void merge(int a, int b) {\\n        if(ran[a] >= ran[b]) {      \\n            ran[a] += ran[b];\\n            par[b] = a;\\n        }\\n        else{\\n            par[a] = b;        \\n            ran[b] += ran[a];\\n        }\\n    }\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int n = nums.size();\\n        par = vector<int>(n+1);\\n        ran = vector<int>(n+1, 1);\\n        \\n        for(int i=0; i<n; i++) {\\n            par[i] = i;\\n        }\\n        map<int,vector<int>>m;\\n        for(int i=0; i<n; i++) {\\n            int num = nums[i];\\n            if(nums[i] != 1) {\\n                m[nums[i]].push_back(i);\\n            }\\n            int k = sqrt(num);\\n            for(int j=2; j<=k; j++) {\\n                if(num%j == 0) {\\n                    m[j].push_back(i);\\n                    m[num/j].push_back(i);\\n                }\\n            }\\n        }\\n        \\n        for(auto it: m) {\\n            vector<int>v = it.second;\\n            if(v.size() >= 2) {\\n                //cout << v[0] << endl;\\n                for(int j=1; j<v.size(); j++) {\\n                   // cout << v[j] << endl;\\n                    int a = find_par(v[j]);\\n                    int b = find_par(v[0]);\\n                    if(a == b) {\\n                        continue;\\n                    }\\n                    merge(a, b);     \\n                }\\n            }\\n        }\\n         int x = *max_element(ran.begin(), ran.end());\\n        if(x != n) {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3569620,
                "title": "c-union-find-prime-factorization-with-comments",
                "content": "## Code\\n```\\n// Union Find Template\\n\\nclass UnionFind{\\n    private:\\n        vector<int>parent,rank;\\n    \\n    public:\\n        UnionFind(int n){\\n            for(int i=0;i<n;i++){\\n                parent.push_back(i);\\n                rank.push_back(0);\\n            }\\n        }\\n\\n        int findParent(int node){\\n            if(parent[node]==node) return node;\\n            return parent[node]=findParent(parent[node]);\\n        }\\n\\n        void makeUnion(int one,int two){\\n            one=findParent(one);\\n            two=findParent(two);\\n\\n            if(rank[one]>rank[two]) parent[two]=one;\\n            else if(rank[one]<rank[two]) parent[one]=two;\\n            else{\\n                parent[one]=two;\\n                rank[one]++;\\n            }\\n        }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    \\n    int n;\\n\\n    void findFactors(int val, int ind, unordered_map<int, vector<int>> &mp){\\n        \\n        for(int i = 2; i * i <= val; i++){\\n            if(val % i == 0){ // i is a prime factor of val\\n                mp[i].push_back(ind);\\n                // To remove all divisors of i\\n                // Eg : 24 -> 12 -> 6 -> 3\\n                while(val % i == 0) val /= i;\\n            }\\n        }\\n\\n        // If val itself is a prime number\\n        // Eg : For 17 - 2, 3, 4 would be checked and loop breaks\\n        // The below condition checks if 17 is a prime number\\n        // If it wasn\\'t a prime number, after looping val = 1\\n\\n        if(val > 1) mp[val].push_back(ind);\\n    }\\n    \\n    bool canTraverseAllPairs(vector<int>& nums) {\\n\\n        n = size(nums);\\n        UnionFind DSU(n);\\n\\n        // Map to store => prime number - {indices whose values have the key as prime factor}\\n        unordered_map<int, vector<int>> mp;\\n\\n        // Find prime factors of all indices\\n        for(int i = 0; i < n; i++) findFactors(nums[i], i, mp);\\n        \\n        // Connecting the indices whose values have common prime factors\\n        for(auto &[k,v] : mp) for(int i = 0; i < size(v)-1; i++) DSU.makeUnion(v[i], v[i+1]);\\n\\n        // If any index is left alone , it can\\'t be reached. So return false\\n        for(int i = 1; i < n; i++) if(DSU.findParent(0) != DSU.findParent(i)) return false;\\n\\n        // If all indices are reachable, return true\\n        return true;\\n    }\\n    \\n};\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n * sqrt(x))$$ where x - maximum element in nums\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph",
                    "Counting"
                ],
                "code": "```\\n// Union Find Template\\n\\nclass UnionFind{\\n    private:\\n        vector<int>parent,rank;\\n    \\n    public:\\n        UnionFind(int n){\\n            for(int i=0;i<n;i++){\\n                parent.push_back(i);\\n                rank.push_back(0);\\n            }\\n        }\\n\\n        int findParent(int node){\\n            if(parent[node]==node) return node;\\n            return parent[node]=findParent(parent[node]);\\n        }\\n\\n        void makeUnion(int one,int two){\\n            one=findParent(one);\\n            two=findParent(two);\\n\\n            if(rank[one]>rank[two]) parent[two]=one;\\n            else if(rank[one]<rank[two]) parent[one]=two;\\n            else{\\n                parent[one]=two;\\n                rank[one]++;\\n            }\\n        }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    \\n    int n;\\n\\n    void findFactors(int val, int ind, unordered_map<int, vector<int>> &mp){\\n        \\n        for(int i = 2; i * i <= val; i++){\\n            if(val % i == 0){ // i is a prime factor of val\\n                mp[i].push_back(ind);\\n                // To remove all divisors of i\\n                // Eg : 24 -> 12 -> 6 -> 3\\n                while(val % i == 0) val /= i;\\n            }\\n        }\\n\\n        // If val itself is a prime number\\n        // Eg : For 17 - 2, 3, 4 would be checked and loop breaks\\n        // The below condition checks if 17 is a prime number\\n        // If it wasn\\'t a prime number, after looping val = 1\\n\\n        if(val > 1) mp[val].push_back(ind);\\n    }\\n    \\n    bool canTraverseAllPairs(vector<int>& nums) {\\n\\n        n = size(nums);\\n        UnionFind DSU(n);\\n\\n        // Map to store => prime number - {indices whose values have the key as prime factor}\\n        unordered_map<int, vector<int>> mp;\\n\\n        // Find prime factors of all indices\\n        for(int i = 0; i < n; i++) findFactors(nums[i], i, mp);\\n        \\n        // Connecting the indices whose values have common prime factors\\n        for(auto &[k,v] : mp) for(int i = 0; i < size(v)-1; i++) DSU.makeUnion(v[i], v[i+1]);\\n\\n        // If any index is left alone , it can\\'t be reached. So return false\\n        for(int i = 1; i < n; i++) if(DSU.findParent(0) != DSU.findParent(i)) return false;\\n\\n        // If all indices are reachable, return true\\n        return true;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569607,
                "title": "dekh-rha-hai-binod",
                "content": "class Solution {\\npublic:\\n    \\n    class DSU{\\n        public:\\n        vector<int> par;\\n        vector<int> rank;\\n        DSU (int n)\\n        {\\n            rank.resize(n,1);\\n            for(int i=0;i<n;i++)\\n                par.push_back(i);\\n        }\\n\\n        int find(int x)\\n        {\\n            if(x==par[x])\\n                return x;\\n            return par[x]=find(par[x]);\\n        }\\n\\n        bool merge(int x,int y)\\n        {\\n            int lx=find(x);\\n            int ly=find(y);\\n            if(lx==ly)\\n                return false;\\n            else if(rank[lx]>rank[ly])\\n            {\\n                par[ly]=lx;\\n            }\\n            else if(rank[ly]>rank[lx])\\n            {\\n                par[lx]=ly;\\n            }\\n            else\\n            {\\n                par[lx]=ly;\\n                rank[ly]++;\\n            }\\n            return true;\\n        }\\n    };\\n\\n    bool canTraverseAllPairs(vector<int>& nums) \\n    {\\n        unordered_map<int,int> mpp;\\n        int n=nums.size();\\n        if(n==1)\\n            return true;\\n        DSU D(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            int ele=nums[i];\\n            if(ele==1)\\n                return false;\\n\\n            for(int fact=2;fact*fact<=nums[i];fact++)\\n            {\\n                if(ele%fact==0)\\n                {\\n                    if(mpp.count(fact))\\n                    {\\n                        D.merge(i,mpp[fact]);\\n                    }\\n                    else\\n                    {\\n                        mpp[fact]=i;\\n                    }\\n                    while(ele%fact==0)\\n                        ele/=fact;\\n                }\\n            }\\n            if(ele>1)\\n            {\\n                if(mpp.count(ele))\\n                    D.merge(i,mpp[ele]);\\n                else\\n                    mpp[ele]=i;\\n            }\\n        }\\n        set<int> st;\\n        for(int i=0;i<n;i++)\\n        {\\n            st.insert(D.find(i));\\n        }\\n        return st.size()==1;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    class DSU{\\n        public:\\n        vector<int> par;\\n        vector<int> rank;\\n        DSU (int n)\\n        {\\n            rank.resize(n,1);\\n            for(int i=0;i<n;i++)\\n                par.push_back(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3569539,
                "title": "o-n-2-log-n-solution-35-ms",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean canTraverseAllPairs(int[] nums) {\\n        if(allequal(nums)) return true;\\n        if(nums.length == 1) return true;\\n        for(int i=0;i<nums.length;i++){\\n            boolean flag = false;\\n            for(int j=0;j<nums.length;j++){\\n                if(i != j && nums[i] != nums[j] && gcd(nums[i],nums[j]) > 1){\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            if(flag == false){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public int gcd(int a,int b){\\n        if(a == 0){\\n            return b;\\n        }\\n        return gcd(b%a,a);\\n    }\\n    public boolean allequal(int[] nums){\\n        if(nums[0] == 1) return false;\\n        for(int it:nums){\\n            if(it != nums[0]) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canTraverseAllPairs(int[] nums) {\\n        if(allequal(nums)) return true;\\n        if(nums.length == 1) return true;\\n        for(int i=0;i<nums.length;i++){\\n            boolean flag = false;\\n            for(int j=0;j<nums.length;j++){\\n                if(i != j && nums[i] != nums[j] && gcd(nums[i],nums[j]) > 1){\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            if(flag == false){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public int gcd(int a,int b){\\n        if(a == 0){\\n            return b;\\n        }\\n        return gcd(b%a,a);\\n    }\\n    public boolean allequal(int[] nums){\\n        if(nums[0] == 1) return false;\\n        for(int it:nums){\\n            if(it != nums[0]) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569493,
                "title": "swift-unionfind-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    private func find(_ parent: inout [Int], _ x: Int) -> Int {\\n        if parent[x] == x {\\n            return x\\n        }\\n        parent[x] = find(&parent, parent[x])\\n        return parent[x]\\n    }\\n\\n    private func union(_ parent: inout [Int], _ count: inout [Int], _ x: Int, _ y: Int) {\\n        var x = find(&parent, x)\\n        var y = find(&parent, y)\\n        if (x == y) {\\n            return\\n        }\\n        if (count[x] < count[y]) {\\n            (x, y) = (y, x)\\n        }\\n        parent[y] = x\\n        count[x] += count[y]\\n    }\\n\\n    func canTraverseAllPairs(_ nums: [Int]) -> Bool {\\n        let n = nums.count\\n        if n == 1 {\\n            return true\\n        }\\n        guard !nums.contains(1) else { return false }\\n\\n        var parent: [Int] = .init(0..<n)\\n        var count: [Int] = .init(repeating: 1, count: n)\\n\\n        var map: [Int: Int] = [:]\\n\\n        for i in nums.indices {\\n            var element = nums[i]\\n            var d = 2\\n            while d * d <= element {\\n                defer { d += 1 }\\n\\n                if element.isMultiple(of: d) {\\n                    if map[d] != nil {\\n                        union(&parent, &count, i, map[d]!)\\n                    } else {\\n                        map[d] = i\\n                    }\\n                    while element.isMultiple(of: d) { element /= d }\\n                }\\n            }\\n\\n            if element > 1 {\\n                if map[element] != nil {\\n                    union(&parent, &count, i, map[element]!)\\n                } else {\\n                    map[element] = i\\n                }\\n            }\\n        }\\n\\n        return count[find(&parent, 0)] == n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    private func find(_ parent: inout [Int], _ x: Int) -> Int {\\n        if parent[x] == x {\\n            return x\\n        }\\n        parent[x] = find(&parent, parent[x])\\n        return parent[x]\\n    }\\n\\n    private func union(_ parent: inout [Int], _ count: inout [Int], _ x: Int, _ y: Int) {\\n        var x = find(&parent, x)\\n        var y = find(&parent, y)\\n        if (x == y) {\\n            return\\n        }\\n        if (count[x] < count[y]) {\\n            (x, y) = (y, x)\\n        }\\n        parent[y] = x\\n        count[x] += count[y]\\n    }\\n\\n    func canTraverseAllPairs(_ nums: [Int]) -> Bool {\\n        let n = nums.count\\n        if n == 1 {\\n            return true\\n        }\\n        guard !nums.contains(1) else { return false }\\n\\n        var parent: [Int] = .init(0..<n)\\n        var count: [Int] = .init(repeating: 1, count: n)\\n\\n        var map: [Int: Int] = [:]\\n\\n        for i in nums.indices {\\n            var element = nums[i]\\n            var d = 2\\n            while d * d <= element {\\n                defer { d += 1 }\\n\\n                if element.isMultiple(of: d) {\\n                    if map[d] != nil {\\n                        union(&parent, &count, i, map[d]!)\\n                    } else {\\n                        map[d] = i\\n                    }\\n                    while element.isMultiple(of: d) { element /= d }\\n                }\\n            }\\n\\n            if element > 1 {\\n                if map[element] != nil {\\n                    union(&parent, &count, i, map[element]!)\\n                } else {\\n                    map[element] = i\\n                }\\n            }\\n        }\\n\\n        return count[find(&parent, 0)] == n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569432,
                "title": "dfs-prime-factors-c-o-n-sqrt-n",
                "content": "# Complexity\\n- Time complexity: O(n*sqrt(n))\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> primes(int n){\\n        vector<int>a;\\n        for(int i=2; i<=sqrt(n); i++){\\n            if(n%i==0){\\n                a.push_back(i);\\n                a.push_back(n/i);\\n            }\\n        }\\n        return a;\\n    }\\n    bool vis[100001];\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        vector<int>g[100001];\\n        if(nums.size()==1) return true;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==1) return false;\\n            vector<int>a=primes(nums[i]); // sort all factor of nums[i]\\n            for(auto it:a){\\n                g[nums[i]].push_back(it); // connect nums[i] with factors\\n                g[it].push_back(nums[i]);\\n            }\\n        }\\n        function<void(int)>dfs=[&](int x){\\n            vis[x]=1;\\n            for(auto it:g[x]){\\n                if(!vis[it]) dfs(it);\\n            }\\n        };\\n        dfs(nums[0]);\\n        for(auto it:nums){\\n            if(vis[it]) continue;\\n            else return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> primes(int n){\\n        vector<int>a;\\n        for(int i=2; i<=sqrt(n); i++){\\n            if(n%i==0){\\n                a.push_back(i);\\n                a.push_back(n/i);\\n            }\\n        }\\n        return a;\\n    }\\n    bool vis[100001];\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        vector<int>g[100001];\\n        if(nums.size()==1) return true;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==1) return false;\\n            vector<int>a=primes(nums[i]); // sort all factor of nums[i]\\n            for(auto it:a){\\n                g[nums[i]].push_back(it); // connect nums[i] with factors\\n                g[it].push_back(nums[i]);\\n            }\\n        }\\n        function<void(int)>dfs=[&](int x){\\n            vis[x]=1;\\n            for(auto it:g[x]){\\n                if(!vis[it]) dfs(it);\\n            }\\n        };\\n        dfs(nums[0]);\\n        for(auto it:nums){\\n            if(vis[it]) continue;\\n            else return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569369,
                "title": "hard-made-easy-using-disjoint-set",
                "content": "# Code\\n```\\nconst int maxn = 1e5+1;\\nint parentof[maxn];\\nint sz[maxn];\\nclass Solution {\\npublic:\\n    int get(int x) {\\n        if(x == parentof[x]) {\\n            return x;\\n        }\\n        return parentof[x] = get(parentof[x]);\\n    }\\n    void merge(int a, int b) {\\n        a = get(a);\\n        b = get(b);\\n        if(a == b) return;\\n         sz[a] += sz[b];\\n         parentof[b] = a;\\n       \\n    }\\n    void saareprimefactors(int x, vector<int> &v) {\\n        for(int i = 2; i <= sqrt(x); i++) {\\n            bool isit = false;\\n            while(x%i == 0){\\n                isit = true;\\n                x /= i;\\n            }\\n            if(isit) v.push_back(i);\\n        }\\n        if(x > 1) v.push_back(x);\\n    }\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        if(nums.size() == 1) {\\n            return true;\\n        }\\n        if(find(nums.begin(), nums.end(), 1) != nums.end()) {\\n            return false;\\n        }\\n        \\n        for(int i = 0; i < maxn; i++) {\\n            parentof[i] = i;\\n            sz[i] = 1;\\n        }\\n        for(int i = 0; i < (int) nums.size(); i++) { \\n            vector<int> v;\\n            saareprimefactors(nums[i], v);   \\n            for(int j = 0; j < v.size(); j++) { \\n                merge(nums[i], v[j]);\\n            } \\n        } \\n        int orig = get(parentof[nums[0]]);\\n        for(int i = 1; i < (int) nums.size(); i++) {\\n            int curr = get(parentof[nums[i]]);\\n            if(curr != orig) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nconst int maxn = 1e5+1;\\nint parentof[maxn];\\nint sz[maxn];\\nclass Solution {\\npublic:\\n    int get(int x) {\\n        if(x == parentof[x]) {\\n            return x;\\n        }\\n        return parentof[x] = get(parentof[x]);\\n    }\\n    void merge(int a, int b) {\\n        a = get(a);\\n        b = get(b);\\n        if(a == b) return;\\n         sz[a] += sz[b];\\n         parentof[b] = a;\\n       \\n    }\\n    void saareprimefactors(int x, vector<int> &v) {\\n        for(int i = 2; i <= sqrt(x); i++) {\\n            bool isit = false;\\n            while(x%i == 0){\\n                isit = true;\\n                x /= i;\\n            }\\n            if(isit) v.push_back(i);\\n        }\\n        if(x > 1) v.push_back(x);\\n    }\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        if(nums.size() == 1) {\\n            return true;\\n        }\\n        if(find(nums.begin(), nums.end(), 1) != nums.end()) {\\n            return false;\\n        }\\n        \\n        for(int i = 0; i < maxn; i++) {\\n            parentof[i] = i;\\n            sz[i] = 1;\\n        }\\n        for(int i = 0; i < (int) nums.size(); i++) { \\n            vector<int> v;\\n            saareprimefactors(nums[i], v);   \\n            for(int j = 0; j < v.size(); j++) { \\n                merge(nums[i], v[j]);\\n            } \\n        } \\n        int orig = get(parentof[nums[0]]);\\n        for(int i = 1; i < (int) nums.size(); i++) {\\n            int curr = get(parentof[nums[i]]);\\n            if(curr != orig) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569336,
                "title": "python-3-union-find",
                "content": "```\\nclass Solution:\\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\\n        \\n        # edge cases\\n        if len(nums) == 1: return True\\n        \\n        cnt = Counter(nums)\\n        if 1 in cnt: return False       \\n\\n        # get all prime numbers\\n        def is_prime(x):\\n            if x == 1:\\n                return False\\n            if x == 2:\\n                return True\\n            for i in range(2, int(x**0.5)+1):\\n                if x % i == 0: return False\\n            return True\\n        \\n        max_num = max(cnt)\\n        primes = [i for i in range(1, max_num+1) if is_prime(i)]\\n        \\n        # factorize each number into primes and assign the index of number to each prime\\n        loc = list(range(len(cnt)))\\n        size = [1] * len(cnt)\\n        maps = {x: i for i, x in enumerate(cnt)}\\n        \\n        p = defaultdict(list)\\n        \\n        def factor(x):\\n            i = 0\\n            y = x\\n            while primes[i] <= int(x ** 0.5):                \\n                if not x % primes[i]:\\n                    p[primes[i]].append(maps[y])\\n                    \\n                while not x % primes[i]:\\n                    x //= primes[i]                \\n                i += 1\\n\\n            if is_prime(x):\\n                p[x].append(maps[y])\\n        \\n        for num in cnt:\\n            factor(num)\\n\\n        \\n        def find(x):\\n            if loc[x] != x:\\n                loc[x] = find(loc[x])\\n            return loc[x]\\n        \\n        def union(x, y):\\n            a, b = find(x), find(y)\\n            if a != b:\\n                loc[b] = a\\n                size[a] += size[b]\\n        \\n        # loop through all the index for each prime and find/union\\n        for k in p:\\n            if len(p[k]) == 1: continue\\n            a = p[k][0]\\n            for b in p[k][1:]:\\n                union(a, b)                     \\n        \\n        # if able to form all into one group\\n        return max(size) == len(cnt)\\n\\t```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\\n        \\n        # edge cases\\n        if len(nums) == 1: return True\\n        \\n        cnt = Counter(nums)\\n        if 1 in cnt: return False       \\n\\n        # get all prime numbers\\n        def is_prime(x):\\n            if x == 1:\\n                return False\\n            if x == 2:\\n                return True\\n            for i in range(2, int(x**0.5)+1):\\n                if x % i == 0: return False\\n            return True\\n        \\n        max_num = max(cnt)\\n        primes = [i for i in range(1, max_num+1) if is_prime(i)]\\n        \\n        # factorize each number into primes and assign the index of number to each prime\\n        loc = list(range(len(cnt)))\\n        size = [1] * len(cnt)\\n        maps = {x: i for i, x in enumerate(cnt)}\\n        \\n        p = defaultdict(list)\\n        \\n        def factor(x):\\n            i = 0\\n            y = x\\n            while primes[i] <= int(x ** 0.5):                \\n                if not x % primes[i]:\\n                    p[primes[i]].append(maps[y])\\n                    \\n                while not x % primes[i]:\\n                    x //= primes[i]                \\n                i += 1\\n\\n            if is_prime(x):\\n                p[x].append(maps[y])\\n        \\n        for num in cnt:\\n            factor(num)\\n\\n        \\n        def find(x):\\n            if loc[x] != x:\\n                loc[x] = find(loc[x])\\n            return loc[x]\\n        \\n        def union(x, y):\\n            a, b = find(x), find(y)\\n            if a != b:\\n                loc[b] = a\\n                size[a] += size[b]\\n        \\n        # loop through all the index for each prime and find/union\\n        for k in p:\\n            if len(p[k]) == 1: continue\\n            a = p[k][0]\\n            for b in p[k][1:]:\\n                union(a, b)                     \\n        \\n        # if able to form all into one group\\n        return max(size) == len(cnt)\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 3569329,
                "title": "easy-solution-c-dfs-only",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N^3/2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> g;\\n    vector<int> vis;\\n    \\n    void dfs(int u,int par){\\n        vis[u] = 1;\\n\\n        for(auto v:g[u]){\\n            if(v==par) continue;\\n            if(vis[v]==0){\\n                dfs(v,u);\\n            }\\n        }\\n    }\\n\\n    bool canTraverseAllPairs(vector<int>& arr) {\\n        int n = arr.size();\\n        int mx = *max_element(arr.begin(),arr.end());\\n        g.assign(3*mx+1,vector<int>());\\n        vis.assign(3*mx+1,0);\\n        //unordered_map<int,int> mp;\\n        int cnt = 0;\\n        for(auto it:arr){\\n                while (it % 2 == 0)\\n                {\\n                    g[n+2].push_back(cnt);\\n                    g[cnt].push_back(n+2);\\n                    it = it/2;\\n                }\\n                for (int i = 3; i <= sqrt(it); i = i + 2)\\n                {\\n                    while (it % i == 0)\\n                    {\\n                        g[n+i].push_back(cnt);\\n                        g[cnt].push_back(n+i);\\n                        it = it/i;\\n                    }\\n                }\\n                if (it > 2){\\n                    g[n+it].push_back(cnt);\\n                    g[cnt].push_back(n+it);\\n                }\\n            cnt++;\\n        }\\n        dfs(0,-1);\\n        for(int i=0;i<n;i++){\\n            if(vis[i]==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> g;\\n    vector<int> vis;\\n    \\n    void dfs(int u,int par){\\n        vis[u] = 1;\\n\\n        for(auto v:g[u]){\\n            if(v==par) continue;\\n            if(vis[v]==0){\\n                dfs(v,u);\\n            }\\n        }\\n    }\\n\\n    bool canTraverseAllPairs(vector<int>& arr) {\\n        int n = arr.size();\\n        int mx = *max_element(arr.begin(),arr.end());\\n        g.assign(3*mx+1,vector<int>());\\n        vis.assign(3*mx+1,0);\\n        //unordered_map<int,int> mp;\\n        int cnt = 0;\\n        for(auto it:arr){\\n                while (it % 2 == 0)\\n                {\\n                    g[n+2].push_back(cnt);\\n                    g[cnt].push_back(n+2);\\n                    it = it/2;\\n                }\\n                for (int i = 3; i <= sqrt(it); i = i + 2)\\n                {\\n                    while (it % i == 0)\\n                    {\\n                        g[n+i].push_back(cnt);\\n                        g[cnt].push_back(n+i);\\n                        it = it/i;\\n                    }\\n                }\\n                if (it > 2){\\n                    g[n+it].push_back(cnt);\\n                    g[cnt].push_back(n+it);\\n                }\\n            cnt++;\\n        }\\n        dfs(0,-1);\\n        for(int i=0;i<n;i++){\\n            if(vis[i]==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569211,
                "title": "c-o-nlogn-solution",
                "content": "# Intuition\\nCalculate the unique prime factors of each number in range [2,...max(nums)]\\nusing sieve. Store occured indices for each unique prime factor\\n# Approach\\n Let\\'s say prime number 2 is present in nums values at index i, j, k then I\\'ll connect i <=> j <=> k using union find data structure. After doing so if my connected component count become 1 then its possible to visit any index from any other since they below to the same single group. \\n# Complexity\\n- Time complexity:\\n O(nlongn)\\n- Space complexity:\\nO(nlongn)\\n# Code\\n```\\nclass Solution {\\n    int sz[100005], par[100005], n, comp, maxsize;\\npublic:\\n    \\n\\n    void init(){\\n       comp = n;\\n       for(int i = 1; i <= n; i++){\\n           sz[i] = 1;\\n           par[i] = i;\\n       }\\n    }\\n\\n    int getParent(int x){\\n       return x == par[x] ? x : par[x] = getParent(par[x]);\\n    }\\n\\n    void Unite(int a, int b){\\n        int pa = getParent(a);\\n        int pb = getParent(b);\\n        if(pa == pb) return;\\n\\n        comp--;\\n\\n        if(sz[pa] < sz[pb]){\\n           swap(pa, pb);\\n        }\\n\\n        sz[pa] += sz[pb];\\n        sz[pb] = 0;\\n        par[pb] = pa;\\n        maxsize = max(maxsize, sz[pa]);\\n    }\\n    \\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        \\n       n = nums.size();\\n       init(); \\n\\n       // sieve of eratosthenes to get all unique prime factors of each nums value\\n       const int MAXN = *max_element(nums.begin(), nums.end());\\n       vector<int> distinctPrimeFactors[MAXN + 1];\\n       vector<bool> isPrime(MAXN + 1, true);\\n       isPrime[0] = isPrime[1] = false;\\n       for(int i = 2; i  <= MAXN; i++){\\n           if(isPrime[i]){\\n               distinctPrimeFactors[i].push_back(i);\\n               for(int j = i + i; j <= MAXN; j += i){\\n                   distinctPrimeFactors[j].push_back(i);\\n                   isPrime[j] = false;\\n               }\\n           }\\n       }\\n\\n       // store indices in which each prime factor present and connect those indices in single component\\n       unordered_map<int, vector<int> > primef;\\n       for(int i = 0; i < n; i++){\\n           for(int val: distinctPrimeFactors[nums[i]]){\\n               primef[val].push_back(i);\\n           }\\n       }\\n      \\n       for(auto  &it : primef){\\n          for(int i = 0; i + 1 < it.second.size(); i++){\\n              Unite(it.second[i], it.second[i + 1]);\\n          }\\n       }\\n\\n       // if all are connected then component count will be 1\\n       return comp == 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int sz[100005], par[100005], n, comp, maxsize;\\npublic:\\n    \\n\\n    void init(){\\n       comp = n;\\n       for(int i = 1; i <= n; i++){\\n           sz[i] = 1;\\n           par[i] = i;\\n       }\\n    }\\n\\n    int getParent(int x){\\n       return x == par[x] ? x : par[x] = getParent(par[x]);\\n    }\\n\\n    void Unite(int a, int b){\\n        int pa = getParent(a);\\n        int pb = getParent(b);\\n        if(pa == pb) return;\\n\\n        comp--;\\n\\n        if(sz[pa] < sz[pb]){\\n           swap(pa, pb);\\n        }\\n\\n        sz[pa] += sz[pb];\\n        sz[pb] = 0;\\n        par[pb] = pa;\\n        maxsize = max(maxsize, sz[pa]);\\n    }\\n    \\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        \\n       n = nums.size();\\n       init(); \\n\\n       // sieve of eratosthenes to get all unique prime factors of each nums value\\n       const int MAXN = *max_element(nums.begin(), nums.end());\\n       vector<int> distinctPrimeFactors[MAXN + 1];\\n       vector<bool> isPrime(MAXN + 1, true);\\n       isPrime[0] = isPrime[1] = false;\\n       for(int i = 2; i  <= MAXN; i++){\\n           if(isPrime[i]){\\n               distinctPrimeFactors[i].push_back(i);\\n               for(int j = i + i; j <= MAXN; j += i){\\n                   distinctPrimeFactors[j].push_back(i);\\n                   isPrime[j] = false;\\n               }\\n           }\\n       }\\n\\n       // store indices in which each prime factor present and connect those indices in single component\\n       unordered_map<int, vector<int> > primef;\\n       for(int i = 0; i < n; i++){\\n           for(int val: distinctPrimeFactors[nums[i]]){\\n               primef[val].push_back(i);\\n           }\\n       }\\n      \\n       for(auto  &it : primef){\\n          for(int i = 0; i + 1 < it.second.size(); i++){\\n              Unite(it.second[i], it.second[i + 1]);\\n          }\\n       }\\n\\n       // if all are connected then component count will be 1\\n       return comp == 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569203,
                "title": "c-dsu-solution",
                "content": "# Intuition\\nin the question it is asked whether we can traverse from each i to j which seems preety similar to whether we can traverse from any vertex i to vertex j in a graph or simply if a graph is connected or not\\n\\n# Approach\\nSo now we have to form edges to check for the connected graph.For this we can find prime divisors of a number and if this prime divisor has appeared already then we can form the edge betwwen these two nodes/index.Basically if a prime number is appearing first time then store this current index and when it will appear again then we will form a edge between that index and our stored index; We can also use DSU for checking the connected thing\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n\\nclass Solution { \\n    private:\\n  \\n     \\npublic:\\n  \\n   \\n    \\n    int find(int i,vector<int>&parent){\\n        if(i==parent[i]) return i;\\n        return parent[i]=find(parent[i],parent);\\n    }\\n    void merge(int i,int j,vector<int>&parent,vector<int>&sizes,int&nodes){\\n        i=find(i,parent);\\n        j=find(j,parent);\\n        if(i==j) return;\\n        if(sizes[j]>sizes[i]) swap(i,j);\\n        sizes[i]+=sizes[j];\\n        parent[j]=i;\\n        nodes=max(nodes,sizes[i]);\\n    }\\n   \\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        int MAX_SIZE =0;\\n        vector<int> sizes(n,1);\\n        vector<int> parent(n);\\n        if(n==1) return true;\\n        int i=0;\\n        for(auto x:nums){\\n            if(x==1) return false;\\n            MAX_SIZE=max(MAX_SIZE,x+1);\\n            parent[i]=i;\\n            i++;\\n        }\\n        vector<bool> isprime(MAX_SIZE,1);\\n        vector<long long> spf(MAX_SIZE,1);\\n         for(long long i=2;i<MAX_SIZE;i+=2) {\\n            isprime[i]=0;\\n            spf[i]=2;\\n        }    \\n        \\n            for(long long i=3;i<MAX_SIZE;i+=2){\\n                 if(isprime[i]){\\n                    spf[i]=i;\\n                    long long j=i;\\n                    while((i*j)<MAX_SIZE){\\n                        spf[i*j]=i;\\n                        isprime[i*j]=0;\\n                        j+=2;\\n                    }\\n                }\\n            }\\n\\n          \\n          \\n       \\n          vector<int> set_node(MAX_SIZE,-1);\\n          int nodes=0;\\n          for(int i=0;i<n;i++){\\n              while(nums[i]!=1){\\n                  int k=spf[nums[i]];\\n                  while(nums[i]%k==0) nums[i]/=k;\\n                  if(set_node[k]==-1){\\n                      set_node[k]=i;\\n                  }\\n                  else{\\n                     merge(set_node[k],i,parent,sizes,nodes);\\n                     \\n                  }\\n              }\\n          }\\n\\n         \\n          return nodes==n;\\n    \\n         \\n          \\n  \\n       \\n    \\n\\n        \\n        \\n   \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\n\\nclass Solution { \\n    private:\\n  \\n     \\npublic:\\n  \\n   \\n    \\n    int find(int i,vector<int>&parent){\\n        if(i==parent[i]) return i;\\n        return parent[i]=find(parent[i],parent);\\n    }\\n    void merge(int i,int j,vector<int>&parent,vector<int>&sizes,int&nodes){\\n        i=find(i,parent);\\n        j=find(j,parent);\\n        if(i==j) return;\\n        if(sizes[j]>sizes[i]) swap(i,j);\\n        sizes[i]+=sizes[j];\\n        parent[j]=i;\\n        nodes=max(nodes,sizes[i]);\\n    }\\n   \\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        int MAX_SIZE =0;\\n        vector<int> sizes(n,1);\\n        vector<int> parent(n);\\n        if(n==1) return true;\\n        int i=0;\\n        for(auto x:nums){\\n            if(x==1) return false;\\n            MAX_SIZE=max(MAX_SIZE,x+1);\\n            parent[i]=i;\\n            i++;\\n        }\\n        vector<bool> isprime(MAX_SIZE,1);\\n        vector<long long> spf(MAX_SIZE,1);\\n         for(long long i=2;i<MAX_SIZE;i+=2) {\\n            isprime[i]=0;\\n            spf[i]=2;\\n        }    \\n        \\n            for(long long i=3;i<MAX_SIZE;i+=2){\\n                 if(isprime[i]){\\n                    spf[i]=i;\\n                    long long j=i;\\n                    while((i*j)<MAX_SIZE){\\n                        spf[i*j]=i;\\n                        isprime[i*j]=0;\\n                        j+=2;\\n                    }\\n                }\\n            }\\n\\n          \\n          \\n       \\n          vector<int> set_node(MAX_SIZE,-1);\\n          int nodes=0;\\n          for(int i=0;i<n;i++){\\n              while(nums[i]!=1){\\n                  int k=spf[nums[i]];\\n                  while(nums[i]%k==0) nums[i]/=k;\\n                  if(set_node[k]==-1){\\n                      set_node[k]=i;\\n                  }\\n                  else{\\n                     merge(set_node[k],i,parent,sizes,nodes);\\n                     \\n                  }\\n              }\\n          }\\n\\n         \\n          return nodes==n;\\n    \\n         \\n          \\n  \\n       \\n    \\n\\n        \\n        \\n   \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569185,
                "title": "leetcode-952-python-union-find-solution",
                "content": "This problem is EXACT the same as [**Leetcode 952 - Largest Component Size by Common Factor**](https://leetcode.com/problems/largest-component-size-by-common-factor/)\\n\\nWe can directly apply the solution for LC 952, and check whether the largest size is the same as input.\\n\\nYou can see this solution is the same as [the previous solution for LC 952](https://leetcode.com/problems/largest-component-size-by-common-factor/discuss/3049395/Python-union-find-solution-or-prime_factor)\\n\\n```\\ndef canTraverseAllPairs(self, nums: List[int]) -> bool:\\n    def primes(x):\\n        factors = set()\\n        for i in range(2, int(sqrt(x))+1):\\n            while(x%i==0):\\n                x//=i\\n                factors.add(i)\\n        return factors|{x} if x>1 else factors\\n\\n    uf, pf = list(range(len(nums))), defaultdict(list)\\n    for i, n in enumerate(nums):\\n\\t\\tfor x in primes(n):\\n\\t\\t\\tpf[x].append(i)\\n\\n    def find(i):\\n        if uf[i]!=i:\\n            uf[i] = find(uf[i])\\n        return uf[i]\\n\\n    def union(i, j):\\n        fi, fj = find(i), find(j)\\n        uf[fj] = fi\\n        return fi\\n\\n    for x in pf:\\n        for i in pf[x]:\\n            union(i, pf[x][0])\\n\\n    return max(Counter([find(i) for i in range(len(nums))]).values())==len(nums)\\n```",
                "solutionTags": [],
                "code": "```\\ndef canTraverseAllPairs(self, nums: List[int]) -> bool:\\n    def primes(x):\\n        factors = set()\\n        for i in range(2, int(sqrt(x))+1):\\n            while(x%i==0):\\n                x//=i\\n                factors.add(i)\\n        return factors|{x} if x>1 else factors\\n\\n    uf, pf = list(range(len(nums))), defaultdict(list)\\n    for i, n in enumerate(nums):\\n\\t\\tfor x in primes(n):\\n\\t\\t\\tpf[x].append(i)\\n\\n    def find(i):\\n        if uf[i]!=i:\\n            uf[i] = find(uf[i])\\n        return uf[i]\\n\\n    def union(i, j):\\n        fi, fj = find(i), find(j)\\n        uf[fj] = fi\\n        return fi\\n\\n    for x in pf:\\n        for i in pf[x]:\\n            union(i, pf[x][0])\\n\\n    return max(Counter([find(i) for i in range(len(nums))]).values())==len(nums)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3569167,
                "title": "python3-union-find-solution-connect-numbers-with-the-same-prime-factor",
                "content": "I figured out this solution 7 minutes after the contest ends......\\n\\n```\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parent = {i:i for i in range(n)}\\n\\n    def find(self, x):\\n        if self.parent[x] != x:\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n\\n    def union(self, x, y):\\n        rootX = self.find(x)\\n        rootY = self.find(y)\\n        if rootX != rootY:\\n            self.parent[rootY] = rootX\\n            \\nclass Solution:\\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\\n        if len(nums) == 1:\\n            return True\\n        \\n        if 1 in nums:\\n            return False\\n\\n        nums = list(set(nums))\\n        \\n        n = len(nums)\\n        uf = UnionFind(n)\\n        factorMap= {}\\n\\n        for i, num in enumerate(nums):\\n            for j in range(2, isqrt(num) + 1):\\n                if num % j == 0:\\n                    if j not in factorMap:\\n                        factorMap[j] = i\\n                    else:\\n                        uf.union(i, factorMap[j])\\n                    while num%j == 0:\\n                        num = num//j\\n            if num == 1:\\n                continue\\n            if num not in factorMap:\\n                factorMap[num] = i\\n            else:\\n                uf.union(i, factorMap[num])\\n                \\n        connected = set()\\n        for i in range(n):\\n            connected.add(uf.find(i))\\n            \\n        return len(connected) == 1\\n```",
                "solutionTags": [],
                "code": "```\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parent = {i:i for i in range(n)}\\n\\n    def find(self, x):\\n        if self.parent[x] != x:\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n\\n    def union(self, x, y):\\n        rootX = self.find(x)\\n        rootY = self.find(y)\\n        if rootX != rootY:\\n            self.parent[rootY] = rootX\\n            \\nclass Solution:\\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\\n        if len(nums) == 1:\\n            return True\\n        \\n        if 1 in nums:\\n            return False\\n\\n        nums = list(set(nums))\\n        \\n        n = len(nums)\\n        uf = UnionFind(n)\\n        factorMap= {}\\n\\n        for i, num in enumerate(nums):\\n            for j in range(2, isqrt(num) + 1):\\n                if num % j == 0:\\n                    if j not in factorMap:\\n                        factorMap[j] = i\\n                    else:\\n                        uf.union(i, factorMap[j])\\n                    while num%j == 0:\\n                        num = num//j\\n            if num == 1:\\n                continue\\n            if num not in factorMap:\\n                factorMap[num] = i\\n            else:\\n                uf.union(i, factorMap[num])\\n                \\n        connected = set()\\n        for i in range(n):\\n            connected.add(uf.find(i))\\n            \\n        return len(connected) == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569093,
                "title": "c-union-find",
                "content": "```\\nusing ll = long long;\\n#define pb push_back\\n#define ve vector\\n#define FOR(i, a, b) for (int i = a; i < b; ++i)\\nusing namespace std;\\n\\nconst int N = 1e5 + 10;\\nint p[N];\\nvector<int> g[N];\\nbool yes = false;\\nint find(int u) {\\n    if(p[u] == u) return u;\\n    return p[u] = find(p[u]);\\n}\\n\\nvoid init() {\\n    if(yes) return;\\n    yes = true;\\n    for(int i = 2; i < N; i++) {\\n        for(int j = i; j < N; j += i) {\\n            g[j].pb(i);\\n        }\\n    }\\n}\\n\\nclass Solution {\\npublic:\\n    bool canTraverseAllPairs(vector<int>& a) {\\n        init();\\n        int mx = 0, n = a.size();\\n        for(int i : a) {\\n            mx = max(mx, i);\\n        }\\n        FOR(i, 0, mx + 1) {\\n            p[i] = i;\\n        }\\n        \\n        FOR(i, 0, n) {\\n            int x = a[i];\\n            for(int d : g[x]) {\\n                int r1 = find(d), r2 = find(x);\\n                if(r1 != r2) {\\n                    p[r2] = r1;\\n                }\\n            }\\n        }\\n        \\n        set<int> s;\\n        for(int x : a) {\\n            s.insert(find(x));\\n            if(x == 1 && n > 1) return false;\\n        }\\n        \\n        return s.size() == 1 || n == 1; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nusing ll = long long;\\n#define pb push_back\\n#define ve vector\\n#define FOR(i, a, b) for (int i = a; i < b; ++i)\\nusing namespace std;\\n\\nconst int N = 1e5 + 10;\\nint p[N];\\nvector<int> g[N];\\nbool yes = false;\\nint find(int u) {\\n    if(p[u] == u) return u;\\n    return p[u] = find(p[u]);\\n}\\n\\nvoid init() {\\n    if(yes) return;\\n    yes = true;\\n    for(int i = 2; i < N; i++) {\\n        for(int j = i; j < N; j += i) {\\n            g[j].pb(i);\\n        }\\n    }\\n}\\n\\nclass Solution {\\npublic:\\n    bool canTraverseAllPairs(vector<int>& a) {\\n        init();\\n        int mx = 0, n = a.size();\\n        for(int i : a) {\\n            mx = max(mx, i);\\n        }\\n        FOR(i, 0, mx + 1) {\\n            p[i] = i;\\n        }\\n        \\n        FOR(i, 0, n) {\\n            int x = a[i];\\n            for(int d : g[x]) {\\n                int r1 = find(d), r2 = find(x);\\n                if(r1 != r2) {\\n                    p[r2] = r1;\\n                }\\n            }\\n        }\\n        \\n        set<int> s;\\n        for(int x : a) {\\n            s.insert(find(x));\\n            if(x == 1 && n > 1) return false;\\n        }\\n        \\n        return s.size() == 1 || n == 1; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569030,
                "title": "python-simple-union-find",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canTraverseAllPairs(self, nums):\\n        n, dict1 = len(nums), defaultdict(int)\\n        \\n        def find(x):\\n            if x not in dict1:\\n                return x\\n            else:\\n                if x != dict1[x]:\\n                    dict1[x] = find(dict1[x])\\n                return dict1[x]\\n            \\n        def union(x,y):\\n            a,b = find(x),find(y)\\n            \\n            if a != b:\\n                dict1[b] = a\\n\\n        res = [-1]*(max(nums)+1)\\n        \\n        for i,x in enumerate(nums):\\n            for p in range(2,x):\\n                if p*p > x: break\\n                if x%p != 0: continue\\n                if res[p] != -1: union(res[p],i)\\n                else: res[p] = i\\n                while x%p == 0: x = x//p\\n\\n            if x > 1:\\n                if res[x] != -1: union(res[x],i)\\n                else: res[x] = i\\n                \\n        dict2 = defaultdict(list)\\n        \\n        for i in range(n):\\n            dict2[find(i)].append(i)\\n            \\n        return len(dict2) == 1\\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canTraverseAllPairs(self, nums):\\n        n, dict1 = len(nums), defaultdict(int)\\n        \\n        def find(x):\\n            if x not in dict1:\\n                return x\\n            else:\\n                if x != dict1[x]:\\n                    dict1[x] = find(dict1[x])\\n                return dict1[x]\\n            \\n        def union(x,y):\\n            a,b = find(x),find(y)\\n            \\n            if a != b:\\n                dict1[b] = a\\n\\n        res = [-1]*(max(nums)+1)\\n        \\n        for i,x in enumerate(nums):\\n            for p in range(2,x):\\n                if p*p > x: break\\n                if x%p != 0: continue\\n                if res[p] != -1: union(res[p],i)\\n                else: res[p] = i\\n                while x%p == 0: x = x//p\\n\\n            if x > 1:\\n                if res[x] != -1: union(res[x],i)\\n                else: res[x] = i\\n                \\n        dict2 = defaultdict(list)\\n        \\n        for i in range(n):\\n            dict2[find(i)].append(i)\\n            \\n        return len(dict2) == 1\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569019,
                "title": "rust-union-join-prime-factorization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nuse std::collections::HashMap;\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn can_traverse_all_pairs(nums: Vec<i32>) -> bool {\\n        let n = nums.len();\\n        let mut parent = (0 .. n).into_iter().collect::<Vec<usize>>();\\n        let mut mp = HashMap::<i32, usize>::new();\\n\\n        for i in 0 .. n {\\n            let mut a = nums[i];\\n            if a == 1 { continue }\\n            \\n            if let Some(j) = mp.get(&a) { Self::union_join(i, *j, &mut parent); }\\n            mp.insert(a, i);\\n\\n            for b in (2 .. a) {\\n                if b as i64 * b as i64 > nums[i] as i64 { break }\\n                if a % b != 0 { continue }\\n\\n                if let Some(j) = mp.get(&b) { Self::union_join(i, *j, &mut parent); }\\n                mp.insert(b, i);\\n                while a % b == 0 { a /= b; }\\n                if a == 1 { break }\\n                if let Some(j) = mp.get(&a) { Self::union_join(i, *j, &mut parent); }\\n                mp.insert(a, i);\\n            }\\n        }\\n\\n        let mut s = HashSet::new();\\n        for i in 0 .. n { s.insert(Self::find(i, &mut parent)); }\\n\\n        s.len() == 1\\n    }\\n\\n    fn find(i: usize, p: &mut Vec<usize>) -> usize {\\n        if p[i] == i { return i }\\n        p[i] = Self::find(p[i], p);\\n        return p[i]; \\n    }\\n\\n    fn union_join(i: usize, j: usize, p: &mut Vec<usize>) {\\n        let (u, v) = (Self::find(i, p), Self::find(j, p));\\n        p[u] = v;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashMap;\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn can_traverse_all_pairs(nums: Vec<i32>) -> bool {\\n        let n = nums.len();\\n        let mut parent = (0 .. n).into_iter().collect::<Vec<usize>>();\\n        let mut mp = HashMap::<i32, usize>::new();\\n\\n        for i in 0 .. n {\\n            let mut a = nums[i];\\n            if a == 1 { continue }\\n            \\n            if let Some(j) = mp.get(&a) { Self::union_join(i, *j, &mut parent); }\\n            mp.insert(a, i);\\n\\n            for b in (2 .. a) {\\n                if b as i64 * b as i64 > nums[i] as i64 { break }\\n                if a % b != 0 { continue }\\n\\n                if let Some(j) = mp.get(&b) { Self::union_join(i, *j, &mut parent); }\\n                mp.insert(b, i);\\n                while a % b == 0 { a /= b; }\\n                if a == 1 { break }\\n                if let Some(j) = mp.get(&a) { Self::union_join(i, *j, &mut parent); }\\n                mp.insert(a, i);\\n            }\\n        }\\n\\n        let mut s = HashSet::new();\\n        for i in 0 .. n { s.insert(Self::find(i, &mut parent)); }\\n\\n        s.len() == 1\\n    }\\n\\n    fn find(i: usize, p: &mut Vec<usize>) -> usize {\\n        if p[i] == i { return i }\\n        p[i] = Self::find(p[i], p);\\n        return p[i]; \\n    }\\n\\n    fn union_join(i: usize, j: usize, p: &mut Vec<usize>) {\\n        let (u, v) = (Self::find(i, p), Self::find(j, p));\\n        p[u] = v;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3569006,
                "title": "dfs-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nsimple BFS approach\\n\\n# Complexity\\n- Time complexity:\\n O(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        map<int,vector<int>> m;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int x=nums[i];\\n            for(int j=2;j*j<=x;j++)\\n            {\\n                if(x%j==0)      m[j].push_back(i);\\n                while(x%j==0)   x/=j;\\n            }\\n            if(x>1)    m[x].push_back(i);\\n        }\\n        map<int,set<int>> adj;\\n        for(auto it:m)\\n        {\\n            vector<int> v=it.second;\\n            for(int i=0;i<v.size()-1;i++)\\n            {\\n                adj[v[i]].insert(v[i+1]);\\n                adj[v[i+1]].insert(v[i]);\\n            }\\n        }\\n        queue<int> q;\\n        vector<int> vis(n);\\n        vis[0]=1;\\n        q.push(0);\\n        while(!q.empty())\\n        {\\n            int n=q.front();\\n            q.pop();\\n            for(auto it:adj[n])\\n            {\\n                if(!vis[it])  vis[it]=1,q.push(it);\\n            }\\n        }\\n        for(auto it:vis)\\n        {\\n            if(it==0)   return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        map<int,vector<int>> m;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int x=nums[i];\\n            for(int j=2;j*j<=x;j++)\\n            {\\n                if(x%j==0)      m[j].push_back(i);\\n                while(x%j==0)   x/=j;\\n            }\\n            if(x>1)    m[x].push_back(i);\\n        }\\n        map<int,set<int>> adj;\\n        for(auto it:m)\\n        {\\n            vector<int> v=it.second;\\n            for(int i=0;i<v.size()-1;i++)\\n            {\\n                adj[v[i]].insert(v[i+1]);\\n                adj[v[i+1]].insert(v[i]);\\n            }\\n        }\\n        queue<int> q;\\n        vector<int> vis(n);\\n        vis[0]=1;\\n        q.push(0);\\n        while(!q.empty())\\n        {\\n            int n=q.front();\\n            q.pop();\\n            for(auto it:adj[n])\\n            {\\n                if(!vis[it])  vis[it]=1,q.push(it);\\n            }\\n        }\\n        for(auto it:vis)\\n        {\\n            if(it==0)   return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568969,
                "title": "prime-divisors-in-o-n-log-n-union-find",
                "content": "# Intuition\\nThis is a graph problem, where indices of the array represent vertices in this graph. There is an edge between two vertices if numbers at corresponding indices in the array are not co-prime ($$gcd(arr[i], arr[j]) > 1$$).\\nTherefore, the question become: if given graph connected or not?\\n\\nThe most complicated part is to determine edges in this graph. We cannot afford to check every pair of neither indices, nor numbers (there might be no duplicates at all).\\nLet\\'s find prime divisors of every number.\\n\\nIf there are several numbers having the same prime divisor `p`, every pair is connected. In such case we don\\'t have to union every pair, it is sufficient to connect every number to the first one.\\n\\n# Approach 1\\nWe can just iterate over the numbers and find its prime divisors. In this case complexity will be $$O(n*sqrt(max(arr)))$$\\n\\n# Approach 2\\nAlternatively we can use Sieve of Eratosthenes idea. But instead of having boolean representing if number is prime or not, we will be calculating list of prime divisors for every number.\\nComplexity: $$O(max(arr) * log(max(arr)))$$\\n(Below is this approach)\\n\\n# Complexity\\n- Time complexity: $$O(n*log(n) + max(arr)*log(max(arr)))$$\\n- Space complexity: $$O(n + max(arr))$$\\n\\n# Code\\n```golang\\nfunc canTraverseAllPairs(nums []int) bool {\\n    n := len(nums)\\n    if n == 1 {\\n        return true\\n    }\\n    // Find minimum and maximum in arr.\\n    // Complexity: time: O(n), space: O(1)\\n    min := nums[0]\\n    max := min\\n    for _, num := range nums {\\n        switch {\\n            case num < min:\\n            min = num\\n            case num > max:\\n            max = num\\n        }\\n    }\\n    switch {\\n        case min == 1:\\n        return false\\n        case min == max:\\n        return true\\n    }\\n    // Find prime divisors for numbers in range 0..max\\n    // Complexity: time: O(max*log(max)), space: O(max)\\n    v := make([][]int, 1 + max)\\n    for i := 2; i <= max; i++ {\\n        if v[i] == nil {\\n            for j := i; j <= max; j += i {\\n                v[j] = append(v[j], i)\\n            }\\n        }\\n    }\\n    // For every prime find first index in the array such that number at this index is divisible by that prime number\\n    idx := make([]int, 1 + max)\\n    for i := range idx {\\n        idx[i] = -1\\n    }\\n    // To solve the problem let\\'s use union find\\n    items := make([]int, n)\\n    ranks := make([]int, n)\\n    for i := range items {\\n        items[i] = i\\n        ranks[i] = 1\\n    }\\n    // and keep tracking of the number of connected components\\n    cnt := n\\n    // Complexity: time: O(n*log(n)), space: O(n)\\n    for i, num := range nums {\\n        for _, p := range v[num] {\\n            switch {\\n                case idx[p] == -1:\\n                idx[p] = i\\n                case union(items, ranks, idx[p], i):\\n                cnt--\\n            }\\n        }\\n    }\\n    return cnt == 1\\n}\\n\\nfunc find(items []int, i int) int {\\n    c, p := i, items[i]\\n    if c != p {\\n        p = find(items, p)\\n        items[i] = p\\n    }\\n    return p\\n}\\n\\nfunc union(items, ranks []int, i, j int) bool {\\n    u := find(items, i)\\n    v := find(items, j)\\n    if u == v {\\n        return false\\n    }\\n    switch q := ranks[u] - ranks[v]; {\\n        case q > 0:\\n        items[v] = u\\n        case q < 0:\\n        items[u] = v\\n        default:\\n        items[u] = v\\n        ranks[v]++\\n    }\\n    return true\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Union Find"
                ],
                "code": "```golang\\nfunc canTraverseAllPairs(nums []int) bool {\\n    n := len(nums)\\n    if n == 1 {\\n        return true\\n    }\\n    // Find minimum and maximum in arr.\\n    // Complexity: time: O(n), space: O(1)\\n    min := nums[0]\\n    max := min\\n    for _, num := range nums {\\n        switch {\\n            case num < min:\\n            min = num\\n            case num > max:\\n            max = num\\n        }\\n    }\\n    switch {\\n        case min == 1:\\n        return false\\n        case min == max:\\n        return true\\n    }\\n    // Find prime divisors for numbers in range 0..max\\n    // Complexity: time: O(max*log(max)), space: O(max)\\n    v := make([][]int, 1 + max)\\n    for i := 2; i <= max; i++ {\\n        if v[i] == nil {\\n            for j := i; j <= max; j += i {\\n                v[j] = append(v[j], i)\\n            }\\n        }\\n    }\\n    // For every prime find first index in the array such that number at this index is divisible by that prime number\\n    idx := make([]int, 1 + max)\\n    for i := range idx {\\n        idx[i] = -1\\n    }\\n    // To solve the problem let\\'s use union find\\n    items := make([]int, n)\\n    ranks := make([]int, n)\\n    for i := range items {\\n        items[i] = i\\n        ranks[i] = 1\\n    }\\n    // and keep tracking of the number of connected components\\n    cnt := n\\n    // Complexity: time: O(n*log(n)), space: O(n)\\n    for i, num := range nums {\\n        for _, p := range v[num] {\\n            switch {\\n                case idx[p] == -1:\\n                idx[p] = i\\n                case union(items, ranks, idx[p], i):\\n                cnt--\\n            }\\n        }\\n    }\\n    return cnt == 1\\n}\\n\\nfunc find(items []int, i int) int {\\n    c, p := i, items[i]\\n    if c != p {\\n        p = find(items, p)\\n        items[i] = p\\n    }\\n    return p\\n}\\n\\nfunc union(items, ranks []int, i, j int) bool {\\n    u := find(items, i)\\n    v := find(items, j)\\n    if u == v {\\n        return false\\n    }\\n    switch q := ranks[u] - ranks[v]; {\\n        case q > 0:\\n        items[v] = u\\n        case q < 0:\\n        items[u] = v\\n        default:\\n        items[u] = v\\n        ranks[v]++\\n    }\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3568967,
                "title": "easy-dsu-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst int mxn=1e6+123;\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n\\nbool is_prime[mxn];\\nll spf[mxn];\\n\\nvoid smallest_prime_factor(int n){\\n    memset(spf,0,sizeof(spf));\\n\\tfor(int i=1;i<=n;i++)is_prime[i]=1;\\n\\tfor(int i=2;i<=n;i++){\\n\\t\\tif(is_prime[i]){\\n\\t\\t\\tspf[i]=i;\\n\\t\\t\\tfor(ll j=(ll)i*i;j<=n;j+=i){\\n\\t\\t\\t\\tis_prime[j]=0;\\n\\t\\t\\t\\tif(spf[j]==0){\\n\\t\\t\\t\\t\\tspf[j]=i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\nvector<int>prime_factorization(int n){\\n\\tvector<int>ans;\\n\\twhile(n>1){\\n\\t\\tans.push_back(spf[n]);\\n\\t\\tn/=spf[n];\\n\\t}\\n\\treturn ans;\\n}\\n  \\n    \\nclass Disjoinset{\\npublic:\\tvector<int>size,par;\\npublic:\\n\\tDisjoinset(int n){\\n\\t\\tpar.resize(n+2,0);\\n\\t\\tsize.resize(n+2,0);\\n\\t\\tfor(int i=0;i<=n;i++){\\n\\t\\t\\tpar[i]=i;\\n\\t\\t\\tsize[i]=1;\\n\\t\\t}\\n\\t}\\n\\tint findPar(int node){\\n\\t\\tif(par[node]==node)return node;\\n\\t\\treturn par[node]=findPar(par[node]);\\n\\t}\\n\\tvoid Union(int u,int v){\\n\\t\\tint p=findPar(u);\\n\\t\\tint q=findPar(v);\\n\\t\\tif(p==q)return;\\n\\t\\tif(size[p]<size[q]){\\n\\t\\t\\tpar[p]=q;\\n\\t\\t\\tsize[q]+=size[p];\\n\\t\\t}else{\\n\\t\\t\\tpar[q]=p;\\n\\t\\t\\tsize[p]+=size[q];\\n\\t\\t}\\n\\t}\\n\\n};\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        \\n        map<int,vector<int>>mp;\\n        smallest_prime_factor(1e5+1);\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            int x=nums[i];\\n            vector<int>v=prime_factorization(x);\\n            for(auto u:v){\\n                mp[u].push_back(i);\\n            }\\n        }\\n        Disjoinset ds(n+1);\\n        for(auto x:mp){\\n            vector<int>v=x.second;\\n            for(int i=1;i<v.size();i++){\\n                ds.Union(v[i],v[i-1]);\\n            }\\n        }\\n        set<int>s;\\n        for(int i=0;i<n;i++){\\n            s.insert(ds.findPar(i));\\n        }\\n        return (s.size()==1);\\n      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nconst int mxn=1e6+123;\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n\\nbool is_prime[mxn];\\nll spf[mxn];\\n\\nvoid smallest_prime_factor(int n){\\n    memset(spf,0,sizeof(spf));\\n\\tfor(int i=1;i<=n;i++)is_prime[i]=1;\\n\\tfor(int i=2;i<=n;i++){\\n\\t\\tif(is_prime[i]){\\n\\t\\t\\tspf[i]=i;\\n\\t\\t\\tfor(ll j=(ll)i*i;j<=n;j+=i){\\n\\t\\t\\t\\tis_prime[j]=0;\\n\\t\\t\\t\\tif(spf[j]==0){\\n\\t\\t\\t\\t\\tspf[j]=i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\nvector<int>prime_factorization(int n){\\n\\tvector<int>ans;\\n\\twhile(n>1){\\n\\t\\tans.push_back(spf[n]);\\n\\t\\tn/=spf[n];\\n\\t}\\n\\treturn ans;\\n}\\n  \\n    \\nclass Disjoinset{\\npublic:\\tvector<int>size,par;\\npublic:\\n\\tDisjoinset(int n){\\n\\t\\tpar.resize(n+2,0);\\n\\t\\tsize.resize(n+2,0);\\n\\t\\tfor(int i=0;i<=n;i++){\\n\\t\\t\\tpar[i]=i;\\n\\t\\t\\tsize[i]=1;\\n\\t\\t}\\n\\t}\\n\\tint findPar(int node){\\n\\t\\tif(par[node]==node)return node;\\n\\t\\treturn par[node]=findPar(par[node]);\\n\\t}\\n\\tvoid Union(int u,int v){\\n\\t\\tint p=findPar(u);\\n\\t\\tint q=findPar(v);\\n\\t\\tif(p==q)return;\\n\\t\\tif(size[p]<size[q]){\\n\\t\\t\\tpar[p]=q;\\n\\t\\t\\tsize[q]+=size[p];\\n\\t\\t}else{\\n\\t\\t\\tpar[q]=p;\\n\\t\\t\\tsize[p]+=size[q];\\n\\t\\t}\\n\\t}\\n\\n};\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        \\n        map<int,vector<int>>mp;\\n        smallest_prime_factor(1e5+1);\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            int x=nums[i];\\n            vector<int>v=prime_factorization(x);\\n            for(auto u:v){\\n                mp[u].push_back(i);\\n            }\\n        }\\n        Disjoinset ds(n+1);\\n        for(auto x:mp){\\n            vector<int>v=x.second;\\n            for(int i=1;i<v.size();i++){\\n                ds.Union(v[i],v[i-1]);\\n            }\\n        }\\n        set<int>s;\\n        for(int i=0;i<n;i++){\\n            s.insert(ds.findPar(i));\\n        }\\n        return (s.size()==1);\\n      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568966,
                "title": "2709-greatest-common-divisor-traversal-union-find-with-prime-factorization-euclidean-algorithm",
                "content": "# Intuition\\nThe problem requires us to determine if there exists a sequence of traversals between all pairs of indices such that the greatest common divisor (gcd) of the numbers at those indices is greater than 1. To solve this, we can utilize the Union-Find algorithm along with prime factorization.\\n\\n# Approach\\n1/ We start by implementing a gcd function to calculate the greatest common divisor between two numbers using the Euclidean algorithm.\\n\\n2/ We initialize a dictionary called \\'factors\\' to store the prime factors of each number in the \\'nums\\' array. The keys in the dictionary will be the prime factors, and the values will be the list of indices in the \\'nums\\' array where those prime factors occur.\\n\\n3/ We iterate over each number in the \\'nums\\' array and calculate its prime factors using a loop from 2 to the square root of the number. For each factor, we check if it divides the number evenly. If it does, we add the current index to the list of indices associated with that prime factor in the \\'factors\\' dictionary. We then divide the number by the factor as long as it is divisible by that factor.\\n\\n4/ If there is any remaining number greater than 1 after the above loop, it is also a prime factor. We add the current index to the list of indices associated with that prime factor in the \\'factors\\' dictionary.\\n\\n5/ We initialize a parent array, \\'parent\\', with indices from 0 to n-1, where n is the length of the nums array. Each index initially represents its own parent.\\n\\n6/ We define the \\'find\\' function to find the parent (representative) of a set. If the parent of a given index is not itself, we recursively find the parent until we reach the representative.\\n\\n7/ We define the \\'union\\' function to merge two sets by updating their parent pointers. It takes two indices, \\'x\\' and \\'y\\', finds their respective representatives using the \\'find\\' function, and assigns the parent of one representative as the parent of the other.\\n\\n8/ Next, we iterate over the prime factors in the \\'factors\\' dictionary. For each factor, if there are more than one index associated with it (indicating multiple occurrences of that factor in the \\'nums\\' array), we perform a union operation on the first index with all the other indices.\\n\\n9/ After the union operations, we find the root (representative) of the set containing index 0 using the \\'find\\' function.\\n\\n10/ Finally, we iterate over the indices from 1 to n-1 and check if their roots (representatives) are the same as the root found in the previous step. If any index has a different root, it means there is no valid sequence of traversals between all pairs of indices, and we return \\'False\\'. Otherwise, we return \\'True\\'.\\n\\n# Complexity\\n- Time complexity:\\n-> O(n * sqrt(max_value)), where n is the length of the \\'nums\\' array and max_value is the maximum element in the array. The prime factorization step contributes to the sqrt(max_value) term.\\n\\n- Space complexity:\\n-> O(n), considering the space used by the \\'factors\\' dictionary and the \\'parent\\' array.\\n\\n---\\n# Code\\n```\\nfrom collections import defaultdict\\n\\nclass Solution(object):\\n    def canTraverseAllPairs(self, nums):\\n        def gcd(a, b):\\n            while b != 0:\\n                a, b = b, a % b\\n            return a\\n\\n        n = len(nums)\\n        factors = defaultdict(list)\\n\\n        for i, num in enumerate(nums):\\n            for factor in range(2, int(num ** 0.5) + 1):\\n                if num % factor == 0:\\n                    factors[factor].append(i)\\n                    while num % factor == 0:\\n                        num //= factor\\n            if num > 1:\\n                factors[num].append(i)\\n\\n        parent = list(range(n))\\n\\n        def find(x):\\n            if parent[x] != x:\\n                parent[x] = find(parent[x])\\n            return parent[x]\\n\\n        def union(x, y):\\n            parent[find(y)] = find(x)\\n\\n        for _, indices in factors.items():\\n            if len(indices) > 1:\\n                for i in range(1, len(indices)):\\n                    union(indices[0], indices[i])\\n\\n        root = find(0)\\n        return all(find(i) == root for i in range(1, n))\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution(object):\\n    def canTraverseAllPairs(self, nums):\\n        def gcd(a, b):\\n            while b != 0:\\n                a, b = b, a % b\\n            return a\\n\\n        n = len(nums)\\n        factors = defaultdict(list)\\n\\n        for i, num in enumerate(nums):\\n            for factor in range(2, int(num ** 0.5) + 1):\\n                if num % factor == 0:\\n                    factors[factor].append(i)\\n                    while num % factor == 0:\\n                        num //= factor\\n            if num > 1:\\n                factors[num].append(i)\\n\\n        parent = list(range(n))\\n\\n        def find(x):\\n            if parent[x] != x:\\n                parent[x] = find(parent[x])\\n            return parent[x]\\n\\n        def union(x, y):\\n            parent[find(y)] = find(x)\\n\\n        for _, indices in factors.items():\\n            if len(indices) > 1:\\n                for i in range(1, len(indices)):\\n                    union(indices[0], indices[i])\\n\\n        root = find(0)\\n        return all(find(i) == root for i in range(1, n))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568953,
                "title": "python-union-find-simple-solution",
                "content": "# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        def factors(n):\\n            factors = set()\\n            while n%2 == 0:\\n                factors.add(2)\\n                n //= 2\\n            i = 3\\n            while i * i <= n:\\n                if n % i:\\n                    i += 2\\n                else:\\n                    n //= i\\n                    factors.add(i)\\n            if n > 1:\\n                factors.add(n)\\n            return factors\\n        primes = defaultdict(list)\\n        for i,num in enumerate(nums):\\n            factorset = factors(num)\\n            for p in factorset:\\n                primes[p].append(i)\\n        par = defaultdict(int)\\n        def find(x):\\n            par.setdefault(x,x)\\n            if par[x] != x:\\n                par[x] = find(par[x])\\n            return par[x]\\n        def union(x, y):\\n            px, py = find(x), find(y)\\n            par[px] = py\\n        for p in primes:\\n            for i, j in zip(primes[p], primes[p][1:]):\\n                union(i, j)\\n        p0 = find(0)\\n        return all([find(i) == p0 for i in range(n)])\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        def factors(n):\\n            factors = set()\\n            while n%2 == 0:\\n                factors.add(2)\\n                n //= 2\\n            i = 3\\n            while i * i <= n:\\n                if n % i:\\n                    i += 2\\n                else:\\n                    n //= i\\n                    factors.add(i)\\n            if n > 1:\\n                factors.add(n)\\n            return factors\\n        primes = defaultdict(list)\\n        for i,num in enumerate(nums):\\n            factorset = factors(num)\\n            for p in factorset:\\n                primes[p].append(i)\\n        par = defaultdict(int)\\n        def find(x):\\n            par.setdefault(x,x)\\n            if par[x] != x:\\n                par[x] = find(par[x])\\n            return par[x]\\n        def union(x, y):\\n            px, py = find(x), find(y)\\n            par[px] = py\\n        for p in primes:\\n            for i, j in zip(primes[p], primes[p][1:]):\\n                union(i, j)\\n        p0 = find(0)\\n        return all([find(i) == p0 for i in range(n)])\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568875,
                "title": "c-14-union-find",
                "content": "```\\nclass Solution {\\npublic:\\n    int mark[100005];\\n    vector<int> par, rank;\\n    void seive(int n) {\\n        mark[0] = 1, mark[1] = 1;\\n        for(int i=2; i*i<=n; i++) {\\n            if(mark[i]==0) {\\n                mark[i] = i;\\n                for(int j=i+i; j<=n; j += i) {\\n                    if(mark[j]==0) mark[j] = i;\\n                }\\n            }\\n        }\\n        \\n        for(int i=2; i<=n; i++) {\\n            if(mark[i]==0) mark[i]=i;\\n        }\\n    }\\n    \\n    int get(int x) {\\n        if(par[x]==x) return x;\\n        return par[x]=get(par[x]);\\n    }\\n    \\n    void Union(int x, int y) {\\n        x = get(x);\\n        y = get(y);\\n        if(x != y) {\\n            if(x > y) swap(x, y); \\n            par[y]=x;\\n        }\\n    }\\n    \\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1) return true;\\n        memset(mark, 0, sizeof(mark));\\n        seive(100004);\\n        unordered_map<int, int> mp;\\n        for(auto i : nums) mp[i] = 1;\\n        int mx = *max_element(nums.begin(), nums.end());\\n        \\n        if(mp.count(1)) {\\n            return false;\\n        }\\n        \\n        par.resize(mx+1, 0);\\n        rank.resize(mx+1, 1);\\n        for(int i=0; i<=mx; i++) {\\n            par[i]=i;\\n        }\\n        \\n        for(auto i : nums) {\\n            int x = i;\\n            while(x > 1) {\\n                //Union(mark[i], mark[x]);\\n                int y = mark[x];\\n                if(x/y != 1) Union(x/y, y);\\n                if(x/mark[x] != 1) Union(x, x/mark[x]);\\n                x /= mark[x];\\n                //Union(mark[i], mark[x]);\\n            }\\n            x = i;\\n            while(x > 1) {\\n                Union(mark[i], mark[x]);\\n                Union(i, mark[x]);\\n                //Union(x, mark[x]);\\n                x /= mark[x];\\n                if(x == 1) break;\\n                Union(mark[i], mark[x]);\\n                Union(i, x);\\n            }\\n        }\\n        \\n        set<int> st;\\n        for(auto &i : nums) {\\n            //cout << i << \\' \\' << par[i] <<\\'\\\\n\\';\\n            st.insert(get(par[i]));\\n        }\\n        //cout << par[35] << \\' \\';\\n        //cout << st.size() << \\'\\\\n\\';\\n        if(st.size()>1) return 0;\\n        return 1;\\n    }\\n};\\n```\\nCode is little bit lengthy but intution is that whenever you\\'ll divide some number (or prime factorize), take the union between all the numbers occuring in  factorization and also be careful that parent of big number should be small number in every Union. The most difficult part to remember or thought of is to carefully Union all the elements and choosing parent of element. Rest of the part is easy to understand",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mark[100005];\\n    vector<int> par, rank;\\n    void seive(int n) {\\n        mark[0] = 1, mark[1] = 1;\\n        for(int i=2; i*i<=n; i++) {\\n            if(mark[i]==0) {\\n                mark[i] = i;\\n                for(int j=i+i; j<=n; j += i) {\\n                    if(mark[j]==0) mark[j] = i;\\n                }\\n            }\\n        }\\n        \\n        for(int i=2; i<=n; i++) {\\n            if(mark[i]==0) mark[i]=i;\\n        }\\n    }\\n    \\n    int get(int x) {\\n        if(par[x]==x) return x;\\n        return par[x]=get(par[x]);\\n    }\\n    \\n    void Union(int x, int y) {\\n        x = get(x);\\n        y = get(y);\\n        if(x != y) {\\n            if(x > y) swap(x, y); \\n            par[y]=x;\\n        }\\n    }\\n    \\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1) return true;\\n        memset(mark, 0, sizeof(mark));\\n        seive(100004);\\n        unordered_map<int, int> mp;\\n        for(auto i : nums) mp[i] = 1;\\n        int mx = *max_element(nums.begin(), nums.end());\\n        \\n        if(mp.count(1)) {\\n            return false;\\n        }\\n        \\n        par.resize(mx+1, 0);\\n        rank.resize(mx+1, 1);\\n        for(int i=0; i<=mx; i++) {\\n            par[i]=i;\\n        }\\n        \\n        for(auto i : nums) {\\n            int x = i;\\n            while(x > 1) {\\n                //Union(mark[i], mark[x]);\\n                int y = mark[x];\\n                if(x/y != 1) Union(x/y, y);\\n                if(x/mark[x] != 1) Union(x, x/mark[x]);\\n                x /= mark[x];\\n                //Union(mark[i], mark[x]);\\n            }\\n            x = i;\\n            while(x > 1) {\\n                Union(mark[i], mark[x]);\\n                Union(i, mark[x]);\\n                //Union(x, mark[x]);\\n                x /= mark[x];\\n                if(x == 1) break;\\n                Union(mark[i], mark[x]);\\n                Union(i, x);\\n            }\\n        }\\n        \\n        set<int> st;\\n        for(auto &i : nums) {\\n            //cout << i << \\' \\' << par[i] <<\\'\\\\n\\';\\n            st.insert(get(par[i]));\\n        }\\n        //cout << par[35] << \\' \\';\\n        //cout << st.size() << \\'\\\\n\\';\\n        if(st.size()>1) return 0;\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3568869,
                "title": "c-union-find-with-respect-to-primes",
                "content": "**Algorithm**\\n* Please be aware that 100000<317x317\\n* If gcd(a,b)=g>1, g shoud be a multiple of some prime p, aka. g=kp\\n* If a is a multiple of a collection of p1, p2, ... pm, p1, ... pm should be merged into one part.\\n* Instead of union find of numbers, we union find on prime factors.\\n\\n**Special Cases/Consideration**\\n* {1} is valid.\\n* {1,1,} is invalid\\n* sorting will not improve the efficient too much but make the consideration much simpler.\\n* It is not a good idea to have a complete list of all primes <100000.\\n* We prefer to only consider primes which are factors of one or more numbers.\\n* For each prime p, we perfer to elimate as much p as possible, i.e. given p=2, let 8->4->2->1 \\n\\n**Performances**\\n```\\nRuntime: 222 ms, faster than 100.00% of C++ online submissions for Greatest Common Divisor Traversal.\\nMemory Usage: 87.8 MB, less than 90.00% of C++ online submissions for Greatest Common Divisor Traversal.\\n```\\n\\n**C++ Codes**\\n```\\nconst int M=66;\\nconst int prime[M]={\\n    2,3,5,7,11,13,17,19,23,29,\\n    31,37,41,43,47,53,59,61,67,71,\\n    73,79,83,89,97,101,103,107,109,113,\\n    127,131,137,139,149,151,157,163,167,173,\\n    179,181,191,193,197,199,211,223,227,229,\\n    233,239,241,251,257,263,269,271,277,281,\\n    283,293,307,311,313,317,\\n};\\nclass Solution {\\npublic:\\n    unordered_map<int,int> par;\\n    int merge(int a, int b) {\\n        return a<b? par[b]=a : par[a]=b;\\n    }\\n    int query(int a) {\\n        for(; a!=par[a]; a=par[a]) {}\\n        return a;\\n    }\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        div_t d;\\n        int n=nums.size();\\n        sort(nums.begin(), nums.end());\\n        if(n==1)\\n            return true;\\n        if(nums[0]==1)\\n            return false;\\n        for(int a=0, b=0, i, k, u, v; a<n; ++b) {\\n            if(b==n || nums[a]!=nums[b]) {\\n                vector<int> ds;\\n                for(v=nums[a], i=0; i<M && v>1; ++i) {\\n                    d=div(v, prime[i]);\\n                    if(!d.rem) {\\n                        for(; !d.rem; v=d.quot, d=div(v, prime[i])) {}\\n                        ds.push_back(prime[i]);\\n                        if(!par.count(prime[i]))\\n                            par[prime[i]]=prime[i];\\n                    }\\n                }\\n                if(v>1) {\\n                    if(!par.count(v))\\n                        par[v]=v;\\n                    ds.push_back(v);\\n                }\\n                for(k=ds.size(), i=1; i<k; ++i) {\\n                    u=query(ds[0]);\\n                    v=query(ds[i]);\\n                    par[ds[0]]=par[ds[i]]=merge(u,v);\\n                }\\n                a=b;\\n            }\\n        }\\n        n=0;\\n        for(auto &p:par) {\\n            n+=p.first==p.second;\\n        }\\n        return n==1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nRuntime: 222 ms, faster than 100.00% of C++ online submissions for Greatest Common Divisor Traversal.\\nMemory Usage: 87.8 MB, less than 90.00% of C++ online submissions for Greatest Common Divisor Traversal.\\n```\n```\\nconst int M=66;\\nconst int prime[M]={\\n    2,3,5,7,11,13,17,19,23,29,\\n    31,37,41,43,47,53,59,61,67,71,\\n    73,79,83,89,97,101,103,107,109,113,\\n    127,131,137,139,149,151,157,163,167,173,\\n    179,181,191,193,197,199,211,223,227,229,\\n    233,239,241,251,257,263,269,271,277,281,\\n    283,293,307,311,313,317,\\n};\\nclass Solution {\\npublic:\\n    unordered_map<int,int> par;\\n    int merge(int a, int b) {\\n        return a<b? par[b]=a : par[a]=b;\\n    }\\n    int query(int a) {\\n        for(; a!=par[a]; a=par[a]) {}\\n        return a;\\n    }\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        div_t d;\\n        int n=nums.size();\\n        sort(nums.begin(), nums.end());\\n        if(n==1)\\n            return true;\\n        if(nums[0]==1)\\n            return false;\\n        for(int a=0, b=0, i, k, u, v; a<n; ++b) {\\n            if(b==n || nums[a]!=nums[b]) {\\n                vector<int> ds;\\n                for(v=nums[a], i=0; i<M && v>1; ++i) {\\n                    d=div(v, prime[i]);\\n                    if(!d.rem) {\\n                        for(; !d.rem; v=d.quot, d=div(v, prime[i])) {}\\n                        ds.push_back(prime[i]);\\n                        if(!par.count(prime[i]))\\n                            par[prime[i]]=prime[i];\\n                    }\\n                }\\n                if(v>1) {\\n                    if(!par.count(v))\\n                        par[v]=v;\\n                    ds.push_back(v);\\n                }\\n                for(k=ds.size(), i=1; i<k; ++i) {\\n                    u=query(ds[0]);\\n                    v=query(ds[i]);\\n                    par[ds[0]]=par[ds[i]]=merge(u,v);\\n                }\\n                a=b;\\n            }\\n        }\\n        n=0;\\n        for(auto &p:par) {\\n            n+=p.first==p.second;\\n        }\\n        return n==1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568848,
                "title": "c-readability-super-clean-prime-factorization-union-find",
                "content": "```cpp\\nclass UnionFind {\\n public:\\n  UnionFind(int n) : id(n), sz(n, 1) {\\n    iota(begin(id), end(id), 0);\\n  }\\n\\n  void unionBySize(int u, int v) {\\n    const int i = find(u);\\n    const int j = find(v);\\n    if (i == j)\\n      return;\\n    if (sz[i] < sz[j]) {\\n      sz[j] += sz[i];\\n      id[i] = j;\\n    } else {\\n      sz[i] += sz[j];\\n      id[j] = i;\\n    }\\n  }\\n\\n  int find(int u) {\\n    return id[u] == u ? u : id[u] = find(id[u]);\\n  }\\n\\n  int getSize(int i) {\\n    return sz[i];\\n  }\\n\\n private:\\n  vector<int> id;\\n  vector<int> sz;\\n};\\n\\nclass Solution {\\n public:\\n  bool canTraverseAllPairs(vector<int>& nums) {\\n    const int n = nums.size();\\n    const int maxNum = *max_element(begin(nums), end(nums));\\n    const vector<int> minPrimeFactor = sieveEratosthenes(maxNum + 1);\\n    unordered_map<int, int> primeToFirstIndex;\\n    UnionFind uf(n);\\n\\n    for (int i = 0; i < n; ++i)\\n      for (const int primeFactor : getPrimeFactors(nums[i], minPrimeFactor))\\n        // `primeFactor` already appeared in the previous indices.\\n        if (const auto it = primeToFirstIndex.find(primeFactor);\\n            it != cend(primeToFirstIndex))\\n          uf.unionBySize(it->second, i);\\n        else\\n          primeToFirstIndex[primeFactor] = i;\\n\\n    for (int i = 0; i < n; ++i)\\n      if (uf.getSize(i) == n)\\n        return true;\\n    return false;\\n  }\\n\\n private:\\n  // Gets min prime factor of i, where 1 < i <= n.\\n  vector<int> sieveEratosthenes(int n) {\\n    vector<int> minPrimeFactor(n + 1);\\n    iota(begin(minPrimeFactor) + 2, end(minPrimeFactor), 2);\\n    for (int i = 2; i * i < n; ++i)\\n      if (minPrimeFactor[i] == i)  // `i` is prime.\\n        for (int j = i * i; j < n; j += i)\\n          minPrimeFactor[j] = min(minPrimeFactor[j], i);\\n    return minPrimeFactor;\\n  }\\n\\n  vector<int> getPrimeFactors(int num, const vector<int>& minPrimeFactor) {\\n    vector<int> primeFactors;\\n    while (num > 1) {\\n      const int divisor = minPrimeFactor[num];\\n      primeFactors.push_back(divisor);\\n      while (num % divisor == 0)\\n        num /= divisor;\\n    }\\n    return primeFactors;\\n  }\\n};\\n```\\n\\nTime: `O(n * sqrt(nums[i]))`, where `0 <= i < n`\\nSpace: `O(n)`",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass UnionFind {\\n public:\\n  UnionFind(int n) : id(n), sz(n, 1) {\\n    iota(begin(id), end(id), 0);\\n  }\\n\\n  void unionBySize(int u, int v) {\\n    const int i = find(u);\\n    const int j = find(v);\\n    if (i == j)\\n      return;\\n    if (sz[i] < sz[j]) {\\n      sz[j] += sz[i];\\n      id[i] = j;\\n    } else {\\n      sz[i] += sz[j];\\n      id[j] = i;\\n    }\\n  }\\n\\n  int find(int u) {\\n    return id[u] == u ? u : id[u] = find(id[u]);\\n  }\\n\\n  int getSize(int i) {\\n    return sz[i];\\n  }\\n\\n private:\\n  vector<int> id;\\n  vector<int> sz;\\n};\\n\\nclass Solution {\\n public:\\n  bool canTraverseAllPairs(vector<int>& nums) {\\n    const int n = nums.size();\\n    const int maxNum = *max_element(begin(nums), end(nums));\\n    const vector<int> minPrimeFactor = sieveEratosthenes(maxNum + 1);\\n    unordered_map<int, int> primeToFirstIndex;\\n    UnionFind uf(n);\\n\\n    for (int i = 0; i < n; ++i)\\n      for (const int primeFactor : getPrimeFactors(nums[i], minPrimeFactor))\\n        // `primeFactor` already appeared in the previous indices.\\n        if (const auto it = primeToFirstIndex.find(primeFactor);\\n            it != cend(primeToFirstIndex))\\n          uf.unionBySize(it->second, i);\\n        else\\n          primeToFirstIndex[primeFactor] = i;\\n\\n    for (int i = 0; i < n; ++i)\\n      if (uf.getSize(i) == n)\\n        return true;\\n    return false;\\n  }\\n\\n private:\\n  // Gets min prime factor of i, where 1 < i <= n.\\n  vector<int> sieveEratosthenes(int n) {\\n    vector<int> minPrimeFactor(n + 1);\\n    iota(begin(minPrimeFactor) + 2, end(minPrimeFactor), 2);\\n    for (int i = 2; i * i < n; ++i)\\n      if (minPrimeFactor[i] == i)  // `i` is prime.\\n        for (int j = i * i; j < n; j += i)\\n          minPrimeFactor[j] = min(minPrimeFactor[j], i);\\n    return minPrimeFactor;\\n  }\\n\\n  vector<int> getPrimeFactors(int num, const vector<int>& minPrimeFactor) {\\n    vector<int> primeFactors;\\n    while (num > 1) {\\n      const int divisor = minPrimeFactor[num];\\n      primeFactors.push_back(divisor);\\n      while (num % divisor == 0)\\n        num /= divisor;\\n    }\\n    return primeFactors;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568841,
                "title": "dsu-prime-factorization-clean-solution",
                "content": "```\\nclass Solution{\\npublic boolean canTraverseAllPairs(int[] nums) { // [4,3,12,8]\\n        int n = nums.length;\\n        if(n == 1) return true;\\n    \\n        DSU dsu = new DSU();\\n        dsu.make(n);\\n        \\n        Map<Integer,Integer> map = new HashMap<>(); // [Divisor] vs [idx]\\n\\n        for(int i=0; i<n; i++){            \\n            if(nums[i] == 1) return false;\\n            \\n            for(int j=2; j*j<=nums[i]; j++){\\n                \\n                if(nums[i] % j == 0){\\n                    \\n                    int a = j;\\n                    int b = nums[i] / j;\\n                    \\n                    if(map.containsKey(a)) dsu.union(i, map.get(a));\\n                    if(map.containsKey(b)) dsu.union(i, map.get(b));\\n                    \\n                    map.put(a, i);\\n                    map.put(b, i);\\n                }\\n            }\\n            \\n            if(map.containsKey(nums[i])) dsu.union(i, map.get(nums[i]));\\n            // also join to it\\'s prev appearance idx\\'s parent if found\\n            map.put(nums[i], i);\\n        }\\n        \\n        return dsu.len == 1;  // Are all in 1 single class or not?\\n    }\\n\\n    class DSU{\\n        int parent[];\\n        int size[];\\n        int len;\\n        \\n        void make(int n){\\n            len = n;\\n            parent = new int[n];\\n            size = new int[n];\\n            \\n            for(int v = 0; v < n; v++){\\n                parent[v] = v;\\n                size[v] = 1;\\n            }\\n        }\\n\\n        void union(int a, int b){\\n            a = find(a);\\n            b = find(b);\\n    \\n            if(a != b){\\n                len--;\\n                if(size[a] > size[b]){                \\n                    parent[b] = a;\\n                    size[a] += size[b];\\n                } else{\\n                    parent[a] = b;\\n                    size[b] += size[a];\\n                }\\n            }\\n        }\\n        \\n        int find(int v){\\n            if(v == parent[v]) return v;\\n    \\n            return parent[v] = find(parent[v]);\\n        }\\n        \\n        public boolean check(int a, int b){\\n            int roota = find(a);\\n            int rootb = find(b);\\n            return roota == rootb;\\n        }\\n    }\\n}\\n\\nTime Complexity: N * sqrt(maxVal)\\n// For DSU, it is in amortized fashion. So we don\\'t need to consider that as at eventually at a certain point it\\'ll be constant.\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution{\\npublic boolean canTraverseAllPairs(int[] nums) { // [4,3,12,8]\\n        int n = nums.length;\\n        if(n == 1) return true;\\n    \\n        DSU dsu = new DSU();\\n        dsu.make(n);\\n        \\n        Map<Integer,Integer> map = new HashMap<>(); // [Divisor] vs [idx]\\n\\n        for(int i=0; i<n; i++){            \\n            if(nums[i] == 1) return false;\\n            \\n            for(int j=2; j*j<=nums[i]; j++){\\n                \\n                if(nums[i] % j == 0){\\n                    \\n                    int a = j;\\n                    int b = nums[i] / j;\\n                    \\n                    if(map.containsKey(a)) dsu.union(i, map.get(a));\\n                    if(map.containsKey(b)) dsu.union(i, map.get(b));\\n                    \\n                    map.put(a, i);\\n                    map.put(b, i);\\n                }\\n            }\\n            \\n            if(map.containsKey(nums[i])) dsu.union(i, map.get(nums[i]));\\n            // also join to it\\'s prev appearance idx\\'s parent if found\\n            map.put(nums[i], i);\\n        }\\n        \\n        return dsu.len == 1;  // Are all in 1 single class or not?\\n    }\\n\\n    class DSU{\\n        int parent[];\\n        int size[];\\n        int len;\\n        \\n        void make(int n){\\n            len = n;\\n            parent = new int[n];\\n            size = new int[n];\\n            \\n            for(int v = 0; v < n; v++){\\n                parent[v] = v;\\n                size[v] = 1;\\n            }\\n        }\\n\\n        void union(int a, int b){\\n            a = find(a);\\n            b = find(b);\\n    \\n            if(a != b){\\n                len--;\\n                if(size[a] > size[b]){                \\n                    parent[b] = a;\\n                    size[a] += size[b];\\n                } else{\\n                    parent[a] = b;\\n                    size[b] += size[a];\\n                }\\n            }\\n        }\\n        \\n        int find(int v){\\n            if(v == parent[v]) return v;\\n    \\n            return parent[v] = find(parent[v]);\\n        }\\n        \\n        public boolean check(int a, int b){\\n            int roota = find(a);\\n            int rootb = find(b);\\n            return roota == rootb;\\n        }\\n    }\\n}\\n\\nTime Complexity: N * sqrt(maxVal)\\n// For DSU, it is in amortized fashion. So we don\\'t need to consider that as at eventually at a certain point it\\'ll be constant.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568833,
                "title": "python-union-find",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\\n        arr=[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, \\n    53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, \\n    137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, \\n    227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313]\\n\\n        mp=defaultdict(int)\\n        p=[i for i in range(len(nums))]\\n\\n        def find(i, p):\\n            if p[i] == i:\\n                return i\\n            return find(p[i], p)\\n\\n        for i in range(len(nums)):\\n            facts=set()\\n            for f in arr:\\n                while nums[i]%f == 0:\\n                    facts.add(f)\\n                    nums[i] = nums[i]//f\\n            if nums[i] > 1:\\n                facts.add(nums[i])\\n            \\n            for f in facts:\\n                if f in mp:\\n                    p1=find(mp[f], p)\\n                    p2=find(i, p)\\n                    if p1 != p2:\\n                       p[max(p1, p2)] = min(p1, p2)\\n                else:\\n                    mp[f] = i\\n        ss=set()\\n        for i in range(len(nums)):\\n            ss.add(find(i, p))\\n        return len(ss) == 1\\n               \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\\n        arr=[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, \\n    53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, \\n    137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, \\n    227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313]\\n\\n        mp=defaultdict(int)\\n        p=[i for i in range(len(nums))]\\n\\n        def find(i, p):\\n            if p[i] == i:\\n                return i\\n            return find(p[i], p)\\n\\n        for i in range(len(nums)):\\n            facts=set()\\n            for f in arr:\\n                while nums[i]%f == 0:\\n                    facts.add(f)\\n                    nums[i] = nums[i]//f\\n            if nums[i] > 1:\\n                facts.add(nums[i])\\n            \\n            for f in facts:\\n                if f in mp:\\n                    p1=find(mp[f], p)\\n                    p2=find(i, p)\\n                    if p1 != p2:\\n                       p[max(p1, p2)] = min(p1, p2)\\n                else:\\n                    mp[f] = i\\n        ss=set()\\n        for i in range(len(nums)):\\n            ss.add(find(i, p))\\n        return len(ss) == 1\\n               \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568813,
                "title": "merging-islands-of-prime-factors-with-union-find-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        if(nums.size()==1) return true;\\n        // first pass: try to merge all the islands\\n        for(int n: nums){\\n            if(n==1) return false;\\n            vector<int> fs = factors(n);\\n            for(int f: fs){\\n                // first initialize each factor to be in its own \"island\"\\n                if(uf_[f]==0) uf_[f] = f;\\n                for(int ff: fs){\\n                    if (f!=ff){\\n                        // every number with factor f can jump to\\n                        // every number with factor ff, via n\\n                        union_(f, ff);\\n                    }\\n                }\\n            }\\n        }\\n        set<int> groups;\\n        for(int n: nums){\\n            for(int f: factors(n)){\\n                int g = find_(f);\\n                groups.insert(g);\\n            }\\n        }\\n        // we should have a single, connected group\\n        // if there is more than one group, there is no jump between them\\n        return groups.size()==1;\\n    }\\n    unordered_map<int, vector<int>> memo_;\\n    \\n    //returns unique factors greater than one\\n    const vector<int> factors(int n){\\n        auto [it, inserted] = memo_.try_emplace(n);\\n        auto& divs = it->second;\\n        if(!inserted) return divs;\\n        for(int i=2;i<=sqrt(n)+1;++i){\\n            if(n%i==0){\\n                divs.push_back(i);\\n                while(n%i==0) n/=i;\\n            }\\n        }\\n        if(n>1){\\n            divs.push_back(n);\\n        }\\n        return divs;\\n    }\\n    \\n    private:\\n    // union-find algorithm\\n    map<int, int> uf_;\\n    int union_(int a, int b){\\n        int g1 = find_(a), g2 = find_(b);\\n        int g = min(g1, g2);\\n        uf_[a] = uf_[b] = uf_[g1] = uf_[g2] = g;\\n        return g;\\n    }\\n    \\n    int find_(int a){\\n        while(uf_[a] != a){\\n            a = uf_[a];\\n        }\\n        return a;\\n    }\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        if(nums.size()==1) return true;\\n        // first pass: try to merge all the islands\\n        for(int n: nums){\\n            if(n==1) return false;\\n            vector<int> fs = factors(n);\\n            for(int f: fs){\\n                // first initialize each factor to be in its own \"island\"\\n                if(uf_[f]==0) uf_[f] = f;\\n                for(int ff: fs){\\n                    if (f!=ff){\\n                        // every number with factor f can jump to\\n                        // every number with factor ff, via n\\n                        union_(f, ff);\\n                    }\\n                }\\n            }\\n        }\\n        set<int> groups;\\n        for(int n: nums){\\n            for(int f: factors(n)){\\n                int g = find_(f);\\n                groups.insert(g);\\n            }\\n        }\\n        // we should have a single, connected group\\n        // if there is more than one group, there is no jump between them\\n        return groups.size()==1;\\n    }\\n    unordered_map<int, vector<int>> memo_;\\n    \\n    //returns unique factors greater than one\\n    const vector<int> factors(int n){\\n        auto [it, inserted] = memo_.try_emplace(n);\\n        auto& divs = it->second;\\n        if(!inserted) return divs;\\n        for(int i=2;i<=sqrt(n)+1;++i){\\n            if(n%i==0){\\n                divs.push_back(i);\\n                while(n%i==0) n/=i;\\n            }\\n        }\\n        if(n>1){\\n            divs.push_back(n);\\n        }\\n        return divs;\\n    }\\n    \\n    private:\\n    // union-find algorithm\\n    map<int, int> uf_;\\n    int union_(int a, int b){\\n        int g1 = find_(a), g2 = find_(b);\\n        int g = min(g1, g2);\\n        uf_[a] = uf_[b] = uf_[g1] = uf_[g2] = g;\\n        return g;\\n    }\\n    \\n    int find_(int a){\\n        while(uf_[a] != a){\\n            a = uf_[a];\\n        }\\n        return a;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568796,
                "title": "simple-understandable-solution-for-beginners-like-me",
                "content": "# Intuition\\n\\n# Approach\\nStart with finding prime factors for each number. If two numbers have any common prime factor then take Union of both. If after traversing all the numbers there remain more than or equal to two parents that mean there are two components which are not connected or we can say we will never reach for any node of one component to any node of another component.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int par[100001];\\n    void add( int n, vector<set<int>>& prime, int index ){\\n        while( n % 2 == 0 ){\\n            prime[index].insert(2);\\n            n = n/2;\\n        }\\n        for( int i = 3; i <= sqrt(n); i += 2 ){\\n            while( n%i == 0 ){\\n                prime[index].insert(i);\\n                n = n/i;\\n            }\\n        }\\n        if( n > 2 ){\\n            prime[index].insert(n);\\n        }\\n    }\\n    int findPar( int a ){\\n        if( par[a] < 0 )\\n            return a;\\n        return par[a] = findPar(par[a]);\\n    }\\n    void Union( int a, int b ){\\n        int u = findPar(a);\\n        int v = findPar(b);\\n        if( u == v )\\n            return;\\n        par[u] = v;\\n    }\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<set<int>> prime(n);\\n        for( int i = 0; i < n; i++ ){\\n            add( nums[i], prime, i );\\n        }\\n        memset( par, -1, sizeof(par) );\\n        unordered_map<int, vector<int>> mp;\\n        vector<int> vis;\\n        for( int i = 0; i < n; i++ ){\\n            for( auto it: prime[i] ){\\n                if( mp.find(it) != mp.end() ){\\n                    for( auto ind: mp[it] ){\\n                        Union( i, ind );\\n                    }\\n                }else\\n                    mp[it].push_back(i);\\n            }\\n        }\\n        int count = 0;\\n        for( int i = 0; i < n; i++ ){\\n            if( par[i] < 0 ) count++;\\n            if( count > 1 )\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int par[100001];\\n    void add( int n, vector<set<int>>& prime, int index ){\\n        while( n % 2 == 0 ){\\n            prime[index].insert(2);\\n            n = n/2;\\n        }\\n        for( int i = 3; i <= sqrt(n); i += 2 ){\\n            while( n%i == 0 ){\\n                prime[index].insert(i);\\n                n = n/i;\\n            }\\n        }\\n        if( n > 2 ){\\n            prime[index].insert(n);\\n        }\\n    }\\n    int findPar( int a ){\\n        if( par[a] < 0 )\\n            return a;\\n        return par[a] = findPar(par[a]);\\n    }\\n    void Union( int a, int b ){\\n        int u = findPar(a);\\n        int v = findPar(b);\\n        if( u == v )\\n            return;\\n        par[u] = v;\\n    }\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<set<int>> prime(n);\\n        for( int i = 0; i < n; i++ ){\\n            add( nums[i], prime, i );\\n        }\\n        memset( par, -1, sizeof(par) );\\n        unordered_map<int, vector<int>> mp;\\n        vector<int> vis;\\n        for( int i = 0; i < n; i++ ){\\n            for( auto it: prime[i] ){\\n                if( mp.find(it) != mp.end() ){\\n                    for( auto ind: mp[it] ){\\n                        Union( i, ind );\\n                    }\\n                }else\\n                    mp[it].push_back(i);\\n            }\\n        }\\n        int count = 0;\\n        for( int i = 0; i < n; i++ ){\\n            if( par[i] < 0 ) count++;\\n            if( count > 1 )\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568794,
                "title": "using-dsu-and-prime-factorisation",
                "content": "# Intuition\\nNumbers having common prime factor greater than 1, will form connected components. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUse DSU to form connected components. Use Prime factorisation to find primes. In DSU join those indexes of numbers which will form connected components. Use map to find whether prime factor has been found before or not.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code\\n```\\n\\nconst int N = 1e5+2;\\n\\nclass DSU{\\npublic:\\n    std::vector<int> f, siz;    \\n    DSU(int n) : f(n), siz(n, 1) {\\n        std::iota(f.begin(), f.end(), 0);\\n    }\\n\\n    int leader(int x) {\\n        while (x != f[x]) x = f[x] = f[f[x]];\\n        return x;\\n    }\\n\\n    bool same(int x, int y) { \\n        return leader(x) == leader(y);\\n    }\\n\\n    bool merge(int x, int y) {\\n        x = leader(x);\\n        y = leader(y);\\n        if (x == y) return false;\\n        siz[x] += siz[y];\\n        f[y] = x;\\n        return true;\\n    }\\n\\n    int size(int x) {\\n        return siz[leader(x)];\\n    }\\n};\\n\\nvoid make_lpf(vector<int> &v){\\n    for(int i = 0; i < N; i++) v[i] = i;\\n    for(int i = 2; i < N; i++){\\n        if(v[i] != i) continue;\\n        for(int j = i; j < N; j += i){\\n            v[j] = i;\\n        }\\n    }\\n}\\n\\nclass Solution {\\npublic:\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        vector<int> lpf(N+1);\\n        make_lpf(lpf);\\n        int n = nums.size();\\n        DSU D(n+1);\\n        map<int,int> mp;\\n        map<int,int> found;\\n        for(int i = 0; i < n; i++){\\n            int x = nums[i];\\n            while(x > 1){\\n                if(found[lpf[x]] == 0){\\n                    mp[lpf[x]] = i;\\n                    found[lpf[x]] = 1;\\n                }\\n                else{\\n                    D.merge(mp[lpf[x]],i);\\n                }\\n\\n                x /= lpf[x];\\n            }\\n        }\\n        bool f = 1;\\n        int prev = D.leader(0);\\n        for(int i = 1; i < n; i++){\\n            int now = D.leader(i);\\n            if(now != prev) return 0;\\n            prev = now;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nconst int N = 1e5+2;\\n\\nclass DSU{\\npublic:\\n    std::vector<int> f, siz;    \\n    DSU(int n) : f(n), siz(n, 1) {\\n        std::iota(f.begin(), f.end(), 0);\\n    }\\n\\n    int leader(int x) {\\n        while (x != f[x]) x = f[x] = f[f[x]];\\n        return x;\\n    }\\n\\n    bool same(int x, int y) { \\n        return leader(x) == leader(y);\\n    }\\n\\n    bool merge(int x, int y) {\\n        x = leader(x);\\n        y = leader(y);\\n        if (x == y) return false;\\n        siz[x] += siz[y];\\n        f[y] = x;\\n        return true;\\n    }\\n\\n    int size(int x) {\\n        return siz[leader(x)];\\n    }\\n};\\n\\nvoid make_lpf(vector<int> &v){\\n    for(int i = 0; i < N; i++) v[i] = i;\\n    for(int i = 2; i < N; i++){\\n        if(v[i] != i) continue;\\n        for(int j = i; j < N; j += i){\\n            v[j] = i;\\n        }\\n    }\\n}\\n\\nclass Solution {\\npublic:\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        vector<int> lpf(N+1);\\n        make_lpf(lpf);\\n        int n = nums.size();\\n        DSU D(n+1);\\n        map<int,int> mp;\\n        map<int,int> found;\\n        for(int i = 0; i < n; i++){\\n            int x = nums[i];\\n            while(x > 1){\\n                if(found[lpf[x]] == 0){\\n                    mp[lpf[x]] = i;\\n                    found[lpf[x]] = 1;\\n                }\\n                else{\\n                    D.merge(mp[lpf[x]],i);\\n                }\\n\\n                x /= lpf[x];\\n            }\\n        }\\n        bool f = 1;\\n        int prev = D.leader(0);\\n        for(int i = 1; i < n; i++){\\n            int now = D.leader(i);\\n            if(now != prev) return 0;\\n            prev = now;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568787,
                "title": "python-union-find-over-prime-factors-clean-solution",
                "content": "# Code\\n```\\ndef prime_factors(n):\\n    factors = set()\\n    while n % 2 == 0:\\n        n >>= 1\\n        factors.add(2)\\n    i = 3\\n    while i * i <= n:\\n        if n % i:\\n            i += 2\\n        else:\\n            n //= i\\n            factors.add(i)\\n    if n > 1:\\n        factors.add(n)\\n    return factors\\n\\n\\nclass UnionFind:\\n    def __init__(self, size):\\n        self.root = [i for i in range(size)]\\n        self.rank = [1] * size\\n        self.count = size\\n\\n    def find(self, x):\\n        if x == self.root[x]:\\n            return x\\n        self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n\\n    def union(self, x, y):\\n        rootX = self.find(x)\\n        rootY = self.find(y)\\n        if rootX != rootY:\\n            if self.rank[rootX] > self.rank[rootY]:\\n                self.root[rootY] = rootX\\n            elif self.rank[rootX] < self.rank[rootY]:\\n                self.root[rootX] = rootY\\n            else:\\n                self.root[rootY] = rootX\\n                self.rank[rootX] += 1\\n            self.count -= 1\\n\\n\\nclass Solution:\\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\\n        uf = UnionFind(len(nums))\\n\\n        primes2pos = {}\\n        for pos, num in enumerate(nums):\\n            for prime in prime_factors(num):\\n                if prime in primes2pos:\\n                    uf.union(pos, primes2pos[prime])\\n                    if uf.count == 1:  # fast exit\\n                        return True\\n                else:\\n                    primes2pos[prime] = pos\\n\\n        return uf.count == 1\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Union Find"
                ],
                "code": "```\\ndef prime_factors(n):\\n    factors = set()\\n    while n % 2 == 0:\\n        n >>= 1\\n        factors.add(2)\\n    i = 3\\n    while i * i <= n:\\n        if n % i:\\n            i += 2\\n        else:\\n            n //= i\\n            factors.add(i)\\n    if n > 1:\\n        factors.add(n)\\n    return factors\\n\\n\\nclass UnionFind:\\n    def __init__(self, size):\\n        self.root = [i for i in range(size)]\\n        self.rank = [1] * size\\n        self.count = size\\n\\n    def find(self, x):\\n        if x == self.root[x]:\\n            return x\\n        self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n\\n    def union(self, x, y):\\n        rootX = self.find(x)\\n        rootY = self.find(y)\\n        if rootX != rootY:\\n            if self.rank[rootX] > self.rank[rootY]:\\n                self.root[rootY] = rootX\\n            elif self.rank[rootX] < self.rank[rootY]:\\n                self.root[rootX] = rootY\\n            else:\\n                self.root[rootY] = rootX\\n                self.rank[rootX] += 1\\n            self.count -= 1\\n\\n\\nclass Solution:\\n    def canTraverseAllPairs(self, nums: List[int]) -> bool:\\n        uf = UnionFind(len(nums))\\n\\n        primes2pos = {}\\n        for pos, num in enumerate(nums):\\n            for prime in prime_factors(num):\\n                if prime in primes2pos:\\n                    uf.union(pos, primes2pos[prime])\\n                    if uf.count == 1:  # fast exit\\n                        return True\\n                else:\\n                    primes2pos[prime] = pos\\n\\n        return uf.count == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568760,
                "title": "bfs-solution-using-prime-factorisation",
                "content": "```\\nclass Solution {\\npublic:\\nunordered_set<int> getFactorization(int num)\\n{\\n    unordered_set<int> ret;\\n    for(int i=2;i*i<=num;i++){\\n        while(num%i==0){\\n            ret.insert(i);\\n            num/=i;\\n        }\\n    }\\n    // Push One prime number, which left if last Number searched is a prime number\\n    if(num>1){\\n        ret.insert(num);\\n    }\\n    return ret;\\n}\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        // sieve();\\n        int n=nums.size();\\n        if(n==1)return true;\\n        vector<unordered_set<int>> pfs(n);\\n        for(int i=0;i<n;i++){\\n            pfs[i]=getFactorization(nums[i]);\\n        }\\n        unordered_map<int,vector<int>>adj;\\n        for(int i=0;i<n;i++){\\n            for(int j:pfs[i]){\\n                adj[j].push_back(i);\\n            }\\n        }\\n        vector<bool> vis(n,0);\\n        queue<int> q;\\n        unordered_set<int> visf;\\n        for(int i:pfs[0]){\\n            visf.insert(i);\\n            q.push(i);\\n            vis[0]=true;\\n        }\\n        while(!q.empty()){\\n            int factor=q.front();q.pop();\\n            queue<int> nodes;\\n            for(int idx:adj[factor]){\\n                if(!vis[idx]){\\n                    vis[idx]=true;\\n                    nodes.push(idx);\\n                }\\n            }\\n            while(!nodes.empty()){\\n                int node=nodes.front();nodes.pop();\\n                for(int i:pfs[node]){\\n                    if(visf.find(i)==visf.end()){\\n                        visf.insert(i);\\n                        q.push(i);\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(!vis[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nunordered_set<int> getFactorization(int num)\\n{\\n    unordered_set<int> ret;\\n    for(int i=2;i*i<=num;i++){\\n        while(num%i==0){\\n            ret.insert(i);\\n            num/=i;\\n        }\\n    }\\n    // Push One prime number, which left if last Number searched is a prime number\\n    if(num>1){\\n        ret.insert(num);\\n    }\\n    return ret;\\n}\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        // sieve();\\n        int n=nums.size();\\n        if(n==1)return true;\\n        vector<unordered_set<int>> pfs(n);\\n        for(int i=0;i<n;i++){\\n            pfs[i]=getFactorization(nums[i]);\\n        }\\n        unordered_map<int,vector<int>>adj;\\n        for(int i=0;i<n;i++){\\n            for(int j:pfs[i]){\\n                adj[j].push_back(i);\\n            }\\n        }\\n        vector<bool> vis(n,0);\\n        queue<int> q;\\n        unordered_set<int> visf;\\n        for(int i:pfs[0]){\\n            visf.insert(i);\\n            q.push(i);\\n            vis[0]=true;\\n        }\\n        while(!q.empty()){\\n            int factor=q.front();q.pop();\\n            queue<int> nodes;\\n            for(int idx:adj[factor]){\\n                if(!vis[idx]){\\n                    vis[idx]=true;\\n                    nodes.push(idx);\\n                }\\n            }\\n            while(!nodes.empty()){\\n                int node=nodes.front();nodes.pop();\\n                for(int i:pfs[node]){\\n                    if(visf.find(i)==visf.end()){\\n                        visf.insert(i);\\n                        q.push(i);\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(!vis[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568717,
                "title": "dfs-o-nlogn",
                "content": "\\n\\n# Code\\n```\\n\\n#define N 10001\\nbool isPrime[N];\\nvector<int> primes;\\nvoid generatePrimes()\\n{\\n    for(int i=2;i<N;++i){\\n        isPrime[i] = true;\\n    }\\n    for(int i=2;i<N;++i){\\n        if(isPrime[i]){\\n            primes.push_back(i);\\n            for(int j=2*i;j<N;j+=i){\\n                isPrime[j] = false;\\n            }\\n        }\\n    }\\n}\\nvector<int> getFactorization(int x)\\n{\\n    vector<int> res;\\n    int i=0;\\n    while (primes[i] <= (int)sqrt(x))\\n    {\\n        if((x%primes[i])==0){\\n            res.push_back(primes[i]);\\n            x/=primes[i];\\n        }\\n        else{\\n            ++i;\\n        }\\n    }\\n    if(x>1){\\n        res.push_back(x);\\n    }\\n    return res;\\n}\\n\\nclass Solution {\\npublic:\\n    unordered_map<int, vector<int>> adj;\\n    unordered_set<int> vis;\\n    void dfs(int n){\\n        if(vis.find(n)!=vis.end()){\\n            return;\\n        }\\n        vis.insert(n);\\n        for(int i:adj[n]){\\n            dfs(i);   \\n        }\\n    }\\n    bool canTraverseAllPairs(vector<int>& v) {\\n        generatePrimes();\\n        int n = v.size();\\n        int offset = 1e6;\\n        for(int i=0;i<n;++i){\\n            vector<int> p = getFactorization(v[i]);\\n            for(int& j:p){\\n                adj[i].push_back(j+offset);\\n                adj[j+offset].push_back(i);\\n            }\\n        }\\n        dfs(0);\\n        for(int i=0;i<n;++i){\\n            if(vis.find(i)==vis.end()) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n#define N 10001\\nbool isPrime[N];\\nvector<int> primes;\\nvoid generatePrimes()\\n{\\n    for(int i=2;i<N;++i){\\n        isPrime[i] = true;\\n    }\\n    for(int i=2;i<N;++i){\\n        if(isPrime[i]){\\n            primes.push_back(i);\\n            for(int j=2*i;j<N;j+=i){\\n                isPrime[j] = false;\\n            }\\n        }\\n    }\\n}\\nvector<int> getFactorization(int x)\\n{\\n    vector<int> res;\\n    int i=0;\\n    while (primes[i] <= (int)sqrt(x))\\n    {\\n        if((x%primes[i])==0){\\n            res.push_back(primes[i]);\\n            x/=primes[i];\\n        }\\n        else{\\n            ++i;\\n        }\\n    }\\n    if(x>1){\\n        res.push_back(x);\\n    }\\n    return res;\\n}\\n\\nclass Solution {\\npublic:\\n    unordered_map<int, vector<int>> adj;\\n    unordered_set<int> vis;\\n    void dfs(int n){\\n        if(vis.find(n)!=vis.end()){\\n            return;\\n        }\\n        vis.insert(n);\\n        for(int i:adj[n]){\\n            dfs(i);   \\n        }\\n    }\\n    bool canTraverseAllPairs(vector<int>& v) {\\n        generatePrimes();\\n        int n = v.size();\\n        int offset = 1e6;\\n        for(int i=0;i<n;++i){\\n            vector<int> p = getFactorization(v[i]);\\n            for(int& j:p){\\n                adj[i].push_back(j+offset);\\n                adj[j+offset].push_back(i);\\n            }\\n        }\\n        dfs(0);\\n        for(int i=0;i<n;++i){\\n            if(vis.find(i)==vis.end()) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568697,
                "title": "union-find-test-the-first-primes-up-to-sqrt-10-5",
                "content": "# Intuition\\nWe can combine the numbers into groups by common prime factors while simultaneously reducing them.  Testing for the primes up to sqrt(10^5) will leave only 1\\'s and prime numbers in the array, we can then unify all elements that reduced to the same prime number. \\n# Code\\n```\\nclass UnionFind {\\nprivate:\\n    std::vector<int> parent;\\n    std::vector<int> rank;\\n    int sz;\\npublic:\\n    UnionFind(int size) {\\n        parent.resize(size);\\n        rank.resize(size, 0);\\n        sz=size;\\n        for (int i = 0; i < size; ++i) {\\n            parent[i] = i;\\n        }\\n    }\\n\\n    int size() { return sz; }\\n    int find(int x) {\\n        if (parent[x] != x) {\\n            parent[x] = find(parent[x]);\\n        }\\n        return parent[x];\\n    }\\n\\n    void unionSets(int x, int y) {\\n        int rootX = find(x);\\n        int rootY = find(y);\\n\\n        if (rootX == rootY) {\\n            return; \\n        }\\n\\n        if (rank[rootX] < rank[rootY]) {\\n            parent[rootX] = rootY;\\n        } else if (rank[rootX] > rank[rootY]) {\\n            parent[rootY] = rootX;\\n        } else {\\n            parent[rootY] = rootX;\\n            rank[rootX]++;\\n        }\\n        --sz;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    bool canTraverseAllPairs(vector<int>& vv) {\\n        sort(vv.begin(),vv.end());\\n        if (vv.size()==1) return true;\\n        if (vv[0]==1) return false;\\n        vector<int> v;  // remove duplicates to speed up\\n        v.push_back(vv[0]);\\n        for (int i=1; i<vv.size(); i++) \\n            if (vv[i]!=vv[i-1]) v.push_back(vv[i]); \\n        vector<int> pr={2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313};\\n        int n=v.size();\\n        UnionFind uf(n);\\n        vector<int> pt(pr.size()+1, -1);\\n        for (int j=0; j<pr.size(); j++) {\\n            for (int i=0; i<n; i++) {\\n                if ((v[i]%pr[j])==0) {\\n                    while ((v[i]%pr[j])==0)\\n                        v[i]/=pr[j];\\n                    if (pt[j]==-1) \\n                        pt[j]=i;\\n                    else\\n                        uf.unionSets(i, pt[j]);\\n                }\\n            }\\n        }\\n        int mx=*max_element(v.begin(),v.end());\\n        if (mx==1) return uf.size()==1;\\n        vector<int> t(mx+1,-1);\\n        for (int i=0; i<n; i++) {\\n            if (v[i]==1) continue;\\n            if (t[v[i]]==-1) \\n                t[v[i]]=i;\\n            else\\n                uf.unionSets(i, t[v[i]]);\\n        }\\n        return uf.size()==1;     \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass UnionFind {\\nprivate:\\n    std::vector<int> parent;\\n    std::vector<int> rank;\\n    int sz;\\npublic:\\n    UnionFind(int size) {\\n        parent.resize(size);\\n        rank.resize(size, 0);\\n        sz=size;\\n        for (int i = 0; i < size; ++i) {\\n            parent[i] = i;\\n        }\\n    }\\n\\n    int size() { return sz; }\\n    int find(int x) {\\n        if (parent[x] != x) {\\n            parent[x] = find(parent[x]);\\n        }\\n        return parent[x];\\n    }\\n\\n    void unionSets(int x, int y) {\\n        int rootX = find(x);\\n        int rootY = find(y);\\n\\n        if (rootX == rootY) {\\n            return; \\n        }\\n\\n        if (rank[rootX] < rank[rootY]) {\\n            parent[rootX] = rootY;\\n        } else if (rank[rootX] > rank[rootY]) {\\n            parent[rootY] = rootX;\\n        } else {\\n            parent[rootY] = rootX;\\n            rank[rootX]++;\\n        }\\n        --sz;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    bool canTraverseAllPairs(vector<int>& vv) {\\n        sort(vv.begin(),vv.end());\\n        if (vv.size()==1) return true;\\n        if (vv[0]==1) return false;\\n        vector<int> v;  // remove duplicates to speed up\\n        v.push_back(vv[0]);\\n        for (int i=1; i<vv.size(); i++) \\n            if (vv[i]!=vv[i-1]) v.push_back(vv[i]); \\n        vector<int> pr={2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313};\\n        int n=v.size();\\n        UnionFind uf(n);\\n        vector<int> pt(pr.size()+1, -1);\\n        for (int j=0; j<pr.size(); j++) {\\n            for (int i=0; i<n; i++) {\\n                if ((v[i]%pr[j])==0) {\\n                    while ((v[i]%pr[j])==0)\\n                        v[i]/=pr[j];\\n                    if (pt[j]==-1) \\n                        pt[j]=i;\\n                    else\\n                        uf.unionSets(i, pt[j]);\\n                }\\n            }\\n        }\\n        int mx=*max_element(v.begin(),v.end());\\n        if (mx==1) return uf.size()==1;\\n        vector<int> t(mx+1,-1);\\n        for (int i=0; i<n; i++) {\\n            if (v[i]==1) continue;\\n            if (t[v[i]]==-1) \\n                t[v[i]]=i;\\n            else\\n                uf.unionSets(i, t[v[i]]);\\n        }\\n        return uf.size()==1;     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568651,
                "title": "c-prime-sieve-then-bfs-with-edge-removal-ufds",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn order to evaluate the n^2 edges, we try to prime factorize each elt, then all nodes can be grouped by their prime factors, significantly reducing the number of edges.\\n\\nAlternatively, we can do a UFDS, where for each prime factor we check its multiples to see if it\\'s in our numbers, and if so we try to union them. We use multiple hash maps to speed this up.\\nNote that N/2 + N/3 + N/4 + ... ~= Nlogn.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPrime sieve to get prime factors\\nStore a revere map from prime factors to indices to represent a collection of edges\\nDo an optimized bfs where you remove an edge associated with a prime after processing\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn) for sorting and prime sieve\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(nlogn) for sorting and prime sieve\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        // corner cases, if there is 1 you can\\'t go to any other index unless there\\'s only one\\n        if(nums[0]==1) return nums.size()==1;\\n\\n        // remove an adversary case where there are a lot of common elts\\n        nums.resize(unique(nums.begin(), nums.end())-nums.begin());\\n        int n = nums.size();\\n\\n        // prime sieve to get distinct prime factors of each element\\n        int lim = *max_element(nums.begin(), nums.end())+1;\\n        vector<int> sieve(lim,0);\\n        vector<vector<int>> primeFactors(lim);\\n        vector<int> primes;\\n        for(int i=2; i<lim; i++){\\n            if(!sieve[i]){\\n                primes.push_back(i);\\n                primeFactors[i].push_back(i);\\n                int j = 2*i;\\n                while(j<lim){\\n                    primeFactors[j].push_back(i);\\n                    sieve[j] = 1;\\n                    j+=i;\\n                }\\n            }\\n        }\\n        \\n        // a reverse map from prime factor to index for our bfs.\\n        unordered_map<int,vector<int>> primeToInd;\\n        for(int i=0; i<nums.size(); i++){\\n            int x = nums[i];\\n            for(auto&p:primeFactors[x]){\\n                primeToInd[p].push_back(i);\\n            }\\n        }\\n        \\n        // bfs, removing the edges represented by a prime number after processing\\n        vector<int> vis(n,0);\\n        queue<int> q;\\n        q.push(0);\\n        vis[0] = 1;\\n        int numLeft = n-1;\\n        while(q.size() && numLeft){\\n            auto u = q.front(); q.pop();\\n            for(auto&p:primeFactors[nums[u]]){\\n                for(auto&v:primeToInd[p]){\\n                    if(!vis[v]) {\\n                        vis[v] = 1;\\n                        numLeft--;\\n                        q.push(v);\\n                    }\\n                }\\n\\n                // remove the edges associated with the prime\\n                primeToInd.erase(p);\\n            }\\n        }\\n        return numLeft==0;\\n    }\\n};\\n```\\n\\nObligatory UFDS code:\\n```\\nclass UFDS {\\npublic:\\n    vector<int> p;\\n    int numSets;\\n\\n    UFDS(int n){\\n        numSets = n;\\n        p.resize(n);\\n        iota(p.begin(), p.end(), 0);\\n    }\\n\\n    int findSet(int x){\\n        if(p[x] == x) return x;\\n        else return p[x] = findSet(p[x]);\\n    }\\n\\n    void unionSet(int x, int y){\\n        int px = findSet(x), py = findSet(y);\\n        if(px!=py){\\n            p[px] = py;\\n            numSets--;\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        if(nums[0]==1) return nums.size()==1;\\n        nums.resize(unique(nums.begin(), nums.end())-nums.begin());\\n        int n = nums.size();\\n        UFDS ufds(n);\\n        int maxElt = nums[n-1];\\n        unordered_map<int,int> numToIndex;\\n        for(int i=0; i<n; i++){\\n            numToIndex[nums[i]] = i;\\n        }\\n\\n        unordered_set<int> s(nums.begin(), nums.end());\\n\\n        for(int i=2; i<=maxElt; i++){\\n            int rep = -1;\\n            for(int j=i; j<=maxElt; j+=i){\\n                if(s.find(j)!=s.end()){\\n                    if(rep==-1) rep = numToIndex[j];\\n                    else ufds.unionSet(rep,numToIndex[j]);\\n                }\\n            }\\n        }\\n        return ufds.numSets==1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        // corner cases, if there is 1 you can\\'t go to any other index unless there\\'s only one\\n        if(nums[0]==1) return nums.size()==1;\\n\\n        // remove an adversary case where there are a lot of common elts\\n        nums.resize(unique(nums.begin(), nums.end())-nums.begin());\\n        int n = nums.size();\\n\\n        // prime sieve to get distinct prime factors of each element\\n        int lim = *max_element(nums.begin(), nums.end())+1;\\n        vector<int> sieve(lim,0);\\n        vector<vector<int>> primeFactors(lim);\\n        vector<int> primes;\\n        for(int i=2; i<lim; i++){\\n            if(!sieve[i]){\\n                primes.push_back(i);\\n                primeFactors[i].push_back(i);\\n                int j = 2*i;\\n                while(j<lim){\\n                    primeFactors[j].push_back(i);\\n                    sieve[j] = 1;\\n                    j+=i;\\n                }\\n            }\\n        }\\n        \\n        // a reverse map from prime factor to index for our bfs.\\n        unordered_map<int,vector<int>> primeToInd;\\n        for(int i=0; i<nums.size(); i++){\\n            int x = nums[i];\\n            for(auto&p:primeFactors[x]){\\n                primeToInd[p].push_back(i);\\n            }\\n        }\\n        \\n        // bfs, removing the edges represented by a prime number after processing\\n        vector<int> vis(n,0);\\n        queue<int> q;\\n        q.push(0);\\n        vis[0] = 1;\\n        int numLeft = n-1;\\n        while(q.size() && numLeft){\\n            auto u = q.front(); q.pop();\\n            for(auto&p:primeFactors[nums[u]]){\\n                for(auto&v:primeToInd[p]){\\n                    if(!vis[v]) {\\n                        vis[v] = 1;\\n                        numLeft--;\\n                        q.push(v);\\n                    }\\n                }\\n\\n                // remove the edges associated with the prime\\n                primeToInd.erase(p);\\n            }\\n        }\\n        return numLeft==0;\\n    }\\n};\\n```\n```\\nclass UFDS {\\npublic:\\n    vector<int> p;\\n    int numSets;\\n\\n    UFDS(int n){\\n        numSets = n;\\n        p.resize(n);\\n        iota(p.begin(), p.end(), 0);\\n    }\\n\\n    int findSet(int x){\\n        if(p[x] == x) return x;\\n        else return p[x] = findSet(p[x]);\\n    }\\n\\n    void unionSet(int x, int y){\\n        int px = findSet(x), py = findSet(y);\\n        if(px!=py){\\n            p[px] = py;\\n            numSets--;\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        if(nums[0]==1) return nums.size()==1;\\n        nums.resize(unique(nums.begin(), nums.end())-nums.begin());\\n        int n = nums.size();\\n        UFDS ufds(n);\\n        int maxElt = nums[n-1];\\n        unordered_map<int,int> numToIndex;\\n        for(int i=0; i<n; i++){\\n            numToIndex[nums[i]] = i;\\n        }\\n\\n        unordered_set<int> s(nums.begin(), nums.end());\\n\\n        for(int i=2; i<=maxElt; i++){\\n            int rep = -1;\\n            for(int j=i; j<=maxElt; j+=i){\\n                if(s.find(j)!=s.end()){\\n                    if(rep==-1) rep = numToIndex[j];\\n                    else ufds.unionSet(rep,numToIndex[j]);\\n                }\\n            }\\n        }\\n        return ufds.numSets==1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568646,
                "title": "union-find",
                "content": "prime factorize and use factors as leverage to join only required edges.\\nO(n*sqrt(n));\\n```\\nclass Solution {\\n    vector<int> primes(int n){\\n        vector<int> ans;\\n        for (int i = 2; i <= sqrt(n); i++){\\n            if (n%i == 0) {\\n                ans.push_back(i);\\n                if(n/i != i) ans.push_back(n/i);\\n            }\\n        }\\n        if(n != 1) ans.push_back(n);\\n        return ans;\\n    }\\n    int find(int i, vector<int> &parent) {\\n        if(parent[i] == i) return i;\\n        else{\\n            parent[i] = find(parent[i], parent);\\n            return parent[i];\\n        }\\n    }\\n    void unionset(vector<int> &parent, vector<int> &size, int i, int j) {\\n        i = find(i, parent);\\n        j = find(j, parent);\\n        if(i == j) return;\\n        if(size[i] > size[j]) {\\n            size[i] += size[j];\\n            size[j] = 0;\\n            parent[j] = i;\\n        }\\n        else {\\n            size[j] += size[i];\\n            size[i] = 0;\\n            parent[i] = j;\\n        }\\n    }\\npublic:\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        unordered_map<int, vector<int> > ump;\\n        for(int i = 0; i < nums.size(); i++){\\n            vector<int> factors = primes(nums[i]);\\n            for(int y: factors){\\n                if(ump.find(y) == ump.end()) ump[y] = vector<int>();\\n                ump[y].push_back(i);\\n            }\\n        }\\n        vector<int> parent(nums.size());\\n        vector<int> size(nums.size(), 1);\\n        for(int i = 0; i < parent.size(); i++) parent[i] = i;\\n        for(auto x: ump){\\n            for(int i = 1; i < x.second.size(); i++){\\n                unionset(parent, size, x.second[0], x.second[i]);\\n            }\\n        }\\n        find(0, parent);\\n        for(int i = 1; i < parent.size(); i++) {\\n            if(find(i, parent) != parent[0]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<int> primes(int n){\\n        vector<int> ans;\\n        for (int i = 2; i <= sqrt(n); i++){\\n            if (n%i == 0) {\\n                ans.push_back(i);\\n                if(n/i != i) ans.push_back(n/i);\\n            }\\n        }\\n        if(n != 1) ans.push_back(n);\\n        return ans;\\n    }\\n    int find(int i, vector<int> &parent) {\\n        if(parent[i] == i) return i;\\n        else{\\n            parent[i] = find(parent[i], parent);\\n            return parent[i];\\n        }\\n    }\\n    void unionset(vector<int> &parent, vector<int> &size, int i, int j) {\\n        i = find(i, parent);\\n        j = find(j, parent);\\n        if(i == j) return;\\n        if(size[i] > size[j]) {\\n            size[i] += size[j];\\n            size[j] = 0;\\n            parent[j] = i;\\n        }\\n        else {\\n            size[j] += size[i];\\n            size[i] = 0;\\n            parent[i] = j;\\n        }\\n    }\\npublic:\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        unordered_map<int, vector<int> > ump;\\n        for(int i = 0; i < nums.size(); i++){\\n            vector<int> factors = primes(nums[i]);\\n            for(int y: factors){\\n                if(ump.find(y) == ump.end()) ump[y] = vector<int>();\\n                ump[y].push_back(i);\\n            }\\n        }\\n        vector<int> parent(nums.size());\\n        vector<int> size(nums.size(), 1);\\n        for(int i = 0; i < parent.size(); i++) parent[i] = i;\\n        for(auto x: ump){\\n            for(int i = 1; i < x.second.size(); i++){\\n                unionset(parent, size, x.second[0], x.second[i]);\\n            }\\n        }\\n        find(0, parent);\\n        for(int i = 1; i < parent.size(); i++) {\\n            if(find(i, parent) != parent[0]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568645,
                "title": "prime-factorization-and-union-find",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canTraverseAllPairs(int[] nums) {\\n        \\n        int max = 0;\\n        if(nums.length == 1) return true;\\n        for(int i : nums) max = Math.max(i, max);\\n\\n        DSU dsu =  new DSU(max);\\n\\n        for(int n: nums){\\n\\n            for(int p = 2; p*p <= n; p++){\\n                if(n%p==0){\\n                    dsu.unionBySize(n, p);\\n                    dsu.unionBySize(n/p, n);\\n                }\\n            }\\n        }\\n        Map<Integer, Long> map = new HashMap<>();\\n\\n        long maxGroup = 0;\\n\\n        for(int n : nums){\\n\\n            if(n == 1) continue;\\n            int parent = dsu.findParent(n);\\n\\n            long count =  map.getOrDefault(parent, 0L)+1L;\\n\\n            map.put(parent, count);\\n\\n            maxGroup = Math.max(count, maxGroup);\\n        }\\n        return maxGroup == nums.length;\\n\\n    }\\n}\\n\\nclass DSU{\\n\\n    int [] parent;\\n    long [] size;\\n\\n    DSU(int n){\\n\\n        parent =  new int[n + 1];\\n        size = new long[n + 1];\\n\\n        for(int i = 0; i < n+1; i++){\\n            parent[i] = i;\\n            size[i] = 1L;\\n        }\\n    }\\n\\n    int findParent(int u){\\n\\n        if(parent[u]== u) return u;\\n        return parent[u] = findParent(parent[u]);\\n    }\\n    void unionBySize(int u, int v){\\n\\n        int from = findParent(u);\\n        int to =   findParent(v);\\n\\n        if(from!= to){\\n\\n            if(size[from] > size[to]){\\n                parent[to] = from;\\n                size[from]+=size[to];\\n            }else{\\n                parent[from] = to;\\n                size[to]+=size[from];\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canTraverseAllPairs(int[] nums) {\\n        \\n        int max = 0;\\n        if(nums.length == 1) return true;\\n        for(int i : nums) max = Math.max(i, max);\\n\\n        DSU dsu =  new DSU(max);\\n\\n        for(int n: nums){\\n\\n            for(int p = 2; p*p <= n; p++){\\n                if(n%p==0){\\n                    dsu.unionBySize(n, p);\\n                    dsu.unionBySize(n/p, n);\\n                }\\n            }\\n        }\\n        Map<Integer, Long> map = new HashMap<>();\\n\\n        long maxGroup = 0;\\n\\n        for(int n : nums){\\n\\n            if(n == 1) continue;\\n            int parent = dsu.findParent(n);\\n\\n            long count =  map.getOrDefault(parent, 0L)+1L;\\n\\n            map.put(parent, count);\\n\\n            maxGroup = Math.max(count, maxGroup);\\n        }\\n        return maxGroup == nums.length;\\n\\n    }\\n}\\n\\nclass DSU{\\n\\n    int [] parent;\\n    long [] size;\\n\\n    DSU(int n){\\n\\n        parent =  new int[n + 1];\\n        size = new long[n + 1];\\n\\n        for(int i = 0; i < n+1; i++){\\n            parent[i] = i;\\n            size[i] = 1L;\\n        }\\n    }\\n\\n    int findParent(int u){\\n\\n        if(parent[u]== u) return u;\\n        return parent[u] = findParent(parent[u]);\\n    }\\n    void unionBySize(int u, int v){\\n\\n        int from = findParent(u);\\n        int to =   findParent(v);\\n\\n        if(from!= to){\\n\\n            if(size[from] > size[to]){\\n                parent[to] = from;\\n                size[from]+=size[to];\\n            }else{\\n                parent[from] = to;\\n                size[to]+=size[from];\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568643,
                "title": "c-dfs-solution",
                "content": "# Code\\n```\\npublic class Solution\\n{\\n    public bool CanTraverseAllPairs(int[] nums)\\n    {\\n        var n = nums.Length;\\n        var graph = BuildGraph(nums);\\n        var visited = new bool[n];\\n        Dfs(0, visited, graph);\\n\\n        return visited.All(v => v);\\n    }\\n\\n    private static List<int>[] BuildGraph(int[] nums)\\n    {\\n        var n = nums.Length;\\n        var graph = InitializeGraph(n);\\n        var map = new Dictionary<int, int>();\\n\\n        for (var i = 0; i < n; i++)\\n        {\\n            var num = nums[i];\\n            AddPrimeFactorsToGraph(num, i, map, graph);\\n        }\\n\\n        return graph;\\n    }\\n\\n    private static List<int>[] InitializeGraph(int n)\\n    {\\n        var graph = new List<int>[n];\\n\\n        for (var i = 0; i < n; i++)\\n            graph[i] = new List<int>();\\n\\n        return graph;\\n    }\\n\\n    private static void AddPrimeFactorsToGraph(int num, int index, Dictionary<int, int> map, List<int>[] graph)\\n    {\\n        for (var j = 2; j * j <= num; j++)\\n            if (num % j == 0)\\n            {\\n                AddFactorToGraph(j, index, map, graph);\\n\\n                while (num % j == 0)\\n                    num /= j;\\n            }\\n\\n        if (num > 1)\\n            AddFactorToGraph(num, index, map, graph);\\n    }\\n\\n    private static void AddFactorToGraph(int factor, int index, Dictionary<int, int> map, List<int>[] graph)\\n    {\\n        if (!map.ContainsKey(factor))\\n            map[factor] = index;\\n        else\\n        {\\n            var node = map[factor];\\n            graph[index].Add(node);\\n            graph[node].Add(index);\\n        }\\n    }\\n\\n    private static void Dfs(int node, bool[] visited, List<int>[] graph)\\n    {\\n        visited[node] = true;\\n\\n        foreach (var neighbor in graph[node].Where(neighbor => !visited[neighbor]))\\n            Dfs(neighbor, visited, graph);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public bool CanTraverseAllPairs(int[] nums)\\n    {\\n        var n = nums.Length;\\n        var graph = BuildGraph(nums);\\n        var visited = new bool[n];\\n        Dfs(0, visited, graph);\\n\\n        return visited.All(v => v);\\n    }\\n\\n    private static List<int>[] BuildGraph(int[] nums)\\n    {\\n        var n = nums.Length;\\n        var graph = InitializeGraph(n);\\n        var map = new Dictionary<int, int>();\\n\\n        for (var i = 0; i < n; i++)\\n        {\\n            var num = nums[i];\\n            AddPrimeFactorsToGraph(num, i, map, graph);\\n        }\\n\\n        return graph;\\n    }\\n\\n    private static List<int>[] InitializeGraph(int n)\\n    {\\n        var graph = new List<int>[n];\\n\\n        for (var i = 0; i < n; i++)\\n            graph[i] = new List<int>();\\n\\n        return graph;\\n    }\\n\\n    private static void AddPrimeFactorsToGraph(int num, int index, Dictionary<int, int> map, List<int>[] graph)\\n    {\\n        for (var j = 2; j * j <= num; j++)\\n            if (num % j == 0)\\n            {\\n                AddFactorToGraph(j, index, map, graph);\\n\\n                while (num % j == 0)\\n                    num /= j;\\n            }\\n\\n        if (num > 1)\\n            AddFactorToGraph(num, index, map, graph);\\n    }\\n\\n    private static void AddFactorToGraph(int factor, int index, Dictionary<int, int> map, List<int>[] graph)\\n    {\\n        if (!map.ContainsKey(factor))\\n            map[factor] = index;\\n        else\\n        {\\n            var node = map[factor];\\n            graph[index].Add(node);\\n            graph[node].Add(index);\\n        }\\n    }\\n\\n    private static void Dfs(int node, bool[] visited, List<int>[] graph)\\n    {\\n        visited[node] = true;\\n\\n        foreach (var neighbor in graph[node].Where(neighbor => !visited[neighbor]))\\n            Dfs(neighbor, visited, graph);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568627,
                "title": "java-union-find",
                "content": "# Intuition\\nUse DSU to group numbers.\\n\\n# Approach\\nGroup numbers(indices) which shares common factor.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canTraverseAllPairs(int[] nums) {\\n        \\n        int n = nums.length;\\n        \\n        if(n == 1) return true;\\n        \\n        DisjointSet dsu = new DisjointSet(n);\\n        Map<Integer,Integer> map = new HashMap<>();\\n        \\n        for(int i = 0 ; i < n ; i++) {\\n            \\n            if(nums[i] == 1) return false;\\n            \\n            for(int j = 2 ; 1l * j * j <= nums[i] ; j++) {\\n                \\n                if(nums[i] % j == 0) {\\n                    \\n                    int f1 = j;\\n                    int f2 = nums[i] / j;\\n                    \\n                    if(map.containsKey(f1)) dsu.union(i, map.get(f1));\\n                    if(map.containsKey(f2)) dsu.union(i, map.get(f2));\\n                    \\n                    map.put(f1, i);\\n                    map.put(f2, i);\\n                }\\n            }\\n            \\n            if(map.containsKey(nums[i])) dsu.union(i, map.get(nums[i]));\\n            map.put(nums[i], i);\\n        }\\n        \\n        //System.out.println(dsu.size);\\n        return dsu.size == 1;\\n    }\\n}\\n\\nclass DisjointSet\\n{\\n    int[] parent;\\n    int[] rank;\\n    int size;\\n\\n    DisjointSet(int n)\\n    {\\n        parent=new int[n];\\n        rank=new int[n];\\n        size = n;\\n\\n        for(int i=0;i<n;i++)\\n            parent[i] = i;\\n        \\n        Arrays.fill(rank,1);\\n    }\\n    \\n    public int find(int x)\\n      {\\n          if(parent[x]==x) return x;\\n          \\n          int temp=find(parent[x]);\\n          parent[x]=temp;\\n          return temp;\\n      }\\n  \\n    public boolean union(int x,int y)\\n      {\\n          int px=find(x);\\n          int py=find(y);\\n          \\n          if(px!=py)\\n          {\\n\\t      size--;\\t\\t\\n              if(rank[px]>rank[py])\\n                parent[py]=px;\\n              else if(rank[px]<rank[py])\\n                parent[px]=py;\\n              else\\n              {\\n                  parent[px]=py;\\n                  rank[py]++;\\n              }\\n              \\n              return true;\\n          }\\n          \\n          return false;\\n      }\\n    \\n    public int[] getMaxSize()\\n    {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        int max = 0;\\n        \\n        for(int i=0;i<parent.length;i++)\\n        {\\n            int ele = find(i);\\n            map.put(ele,map.getOrDefault(ele,0)+1);\\n            \\n            max = Math.max(max,map.get(ele));\\n        }\\n        \\n        return new int[]{map.size(),max};\\n    }\\n        \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canTraverseAllPairs(int[] nums) {\\n        \\n        int n = nums.length;\\n        \\n        if(n == 1) return true;\\n        \\n        DisjointSet dsu = new DisjointSet(n);\\n        Map<Integer,Integer> map = new HashMap<>();\\n        \\n        for(int i = 0 ; i < n ; i++) {\\n            \\n            if(nums[i] == 1) return false;\\n            \\n            for(int j = 2 ; 1l * j * j <= nums[i] ; j++) {\\n                \\n                if(nums[i] % j == 0) {\\n                    \\n                    int f1 = j;\\n                    int f2 = nums[i] / j;\\n                    \\n                    if(map.containsKey(f1)) dsu.union(i, map.get(f1));\\n                    if(map.containsKey(f2)) dsu.union(i, map.get(f2));\\n                    \\n                    map.put(f1, i);\\n                    map.put(f2, i);\\n                }\\n            }\\n            \\n            if(map.containsKey(nums[i])) dsu.union(i, map.get(nums[i]));\\n            map.put(nums[i], i);\\n        }\\n        \\n        //System.out.println(dsu.size);\\n        return dsu.size == 1;\\n    }\\n}\\n\\nclass DisjointSet\\n{\\n    int[] parent;\\n    int[] rank;\\n    int size;\\n\\n    DisjointSet(int n)\\n    {\\n        parent=new int[n];\\n        rank=new int[n];\\n        size = n;\\n\\n        for(int i=0;i<n;i++)\\n            parent[i] = i;\\n        \\n        Arrays.fill(rank,1);\\n    }\\n    \\n    public int find(int x)\\n      {\\n          if(parent[x]==x) return x;\\n          \\n          int temp=find(parent[x]);\\n          parent[x]=temp;\\n          return temp;\\n      }\\n  \\n    public boolean union(int x,int y)\\n      {\\n          int px=find(x);\\n          int py=find(y);\\n          \\n          if(px!=py)\\n          {\\n\\t      size--;\\t\\t\\n              if(rank[px]>rank[py])\\n                parent[py]=px;\\n              else if(rank[px]<rank[py])\\n                parent[px]=py;\\n              else\\n              {\\n                  parent[px]=py;\\n                  rank[py]++;\\n              }\\n              \\n              return true;\\n          }\\n          \\n          return false;\\n      }\\n    \\n    public int[] getMaxSize()\\n    {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        int max = 0;\\n        \\n        for(int i=0;i<parent.length;i++)\\n        {\\n            int ele = find(i);\\n            map.put(ele,map.getOrDefault(ele,0)+1);\\n            \\n            max = Math.max(max,map.get(ele));\\n        }\\n        \\n        return new int[]{map.size(),max};\\n    }\\n        \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568597,
                "title": "c-o-66-nlogn-find-primes-then-dfs",
                "content": "# Approach\\nFirst find all primes factors that appeared. Then, connect edges between each number and its prime factors. Finally, do a dfs from any number. If all number are visited, return `true`.\\n\\n# Complexity\\n- Time complexity: $O(66 nlogn)$\\n66 primes in range $[0, sqrt(1e5)]$.\\n\\n\\n# Code\\n```\\nclass Solution {\\n        \\npublic:\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> primes = {2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317};\\n        map<int, vector<int>> adj_p;\\n        vector<vector<int>> adj_n(n);\\n        map<int, bool> visited_p;\\n        vector<bool> visited_n(n, false);\\n        \\n        for (int i = 0; i != n; ++i){\\n            int num = nums[i];\\n            for (int p: primes){\\n                if (num % p == 0){\\n                    visited_p[p] = false;  // initialize\\n                    adj_p[p].push_back(i);\\n                    adj_n[i].push_back(p);\\n                }\\n                while (num % p == 0) { num /= p; }\\n            }\\n            if (num > 1){\\n                adj_p[num].push_back(i);\\n                adj_n[i].push_back(num);\\n            }\\n        }\\n        \\n        function<void(int, int)> dfs = [&](int x, int is_p){\\n            if (is_p){\\n                int p = x;\\n                if (visited_p[p]) { return; }\\n                visited_p[p] = true;\\n                for (int i: adj_p[p]){\\n                    dfs(i, 0);\\n                }\\n            } else {\\n                int i = x;\\n                if (visited_n[i]) { return; }\\n                visited_n[i] = true;\\n                for (int p: adj_n[i]){\\n                    dfs(p, 1);\\n                }\\n            }\\n        };\\n        dfs(0, 0);\\n        for (int i = 0; i != n; ++i){\\n            if (!visited_n[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n        \\npublic:\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> primes = {2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317};\\n        map<int, vector<int>> adj_p;\\n        vector<vector<int>> adj_n(n);\\n        map<int, bool> visited_p;\\n        vector<bool> visited_n(n, false);\\n        \\n        for (int i = 0; i != n; ++i){\\n            int num = nums[i];\\n            for (int p: primes){\\n                if (num % p == 0){\\n                    visited_p[p] = false;  // initialize\\n                    adj_p[p].push_back(i);\\n                    adj_n[i].push_back(p);\\n                }\\n                while (num % p == 0) { num /= p; }\\n            }\\n            if (num > 1){\\n                adj_p[num].push_back(i);\\n                adj_n[i].push_back(num);\\n            }\\n        }\\n        \\n        function<void(int, int)> dfs = [&](int x, int is_p){\\n            if (is_p){\\n                int p = x;\\n                if (visited_p[p]) { return; }\\n                visited_p[p] = true;\\n                for (int i: adj_p[p]){\\n                    dfs(i, 0);\\n                }\\n            } else {\\n                int i = x;\\n                if (visited_n[i]) { return; }\\n                visited_n[i] = true;\\n                for (int p: adj_n[i]){\\n                    dfs(p, 1);\\n                }\\n            }\\n        };\\n        dfs(0, 0);\\n        for (int i = 0; i != n; ++i){\\n            if (!visited_n[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568586,
                "title": "dsu-sieve-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nfirst we make freq array to all values in array \\nthen merge all indexs to some value to one indxe \\nfor example if array = {1,2,3,1,2,3};\\nthen merge index 0 with index 3,index 1 with index 4,index 2 with index 5\\nif more values of 2 merge indexs with index 1\\nlets make sieve \\nif the value in array then idx = fre[value]\\nand merge Any index coming with idx\\n\\nplease upvote \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public boolean canTraverseAllPairs(int[] nums) {\\n        int fre[] = new int[(int) 1e5 + 1];\\n        Arrays.fill(fre, -1);\\n        for (int i = 0; i < nums.length; i++) {\\n            fre[nums[i]] = i;\\n        }\\n        DSU gr = new DSU(nums.length);\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 1) {\\n                continue;\\n            }\\n            gr.mergeGroups(i, fre[nums[i]]);\\n        }\\n        for (int i = 2; i <= 1e5; i++) {\\n            int idx = -1;\\n            for (int j = i; j <= 1e5; j += i) {\\n                if (idx == -1) {\\n                    if (fre[j] != -1) {\\n                        idx = fre[j];\\n                    }\\n                } else {\\n                    if (fre[j] != -1) {\\n                        gr.mergeGroups(idx, fre[j]);\\n                    }\\n                }\\n            }\\n        }\\n        return gr.numberOFGroubs==1;\\n    }\\n     static class DSU {\\n\\n        int parnet[];\\n        int groupSize[];\\n        int numberOFNodes;\\n        int numberOFGroubs;\\n        int maxGroup;\\n\\n        DSU(int numberOFNodes) {\\n            this.numberOFNodes = numberOFNodes;\\n            parnet = new int[numberOFNodes + 1];\\n            groupSize = new int[numberOFNodes + 1];\\n            numberOFGroubs = numberOFNodes;\\n            maxGroup = 1;\\n            for (int i = 0; i <= numberOFNodes; i++) {\\n                parnet[i] = i;\\n                groupSize[i] = 1;\\n            }\\n        }\\n\\n        int getLeader(int x) {\\n            return parnet[x] = (parnet[x] == x ? x : getLeader(parnet[x]));\\n        }\\n\\n        boolean sameGroup(int x, int y) {\\n            return getLeader(x) == getLeader(y);\\n        }\\n\\n        void mergeGroups(int x, int y) {\\n            int leader1 = getLeader(x);\\n            int leader2 = getLeader(y);\\n            if (leader1 != leader2) {\\n                numberOFGroubs--;\\n                if (groupSize[leader1] < groupSize[leader2]) {\\n                    int swap = leader1;\\n                    leader1 = leader2;\\n                    leader2 = swap;\\n                }\\n                parnet[leader2] = leader1;\\n                groupSize[leader1] += groupSize[leader2];\\n                maxGroup = Math.max(maxGroup, groupSize[leader1]);\\n            }\\n        }\\n\\n        int getSize(int x) {\\n            return groupSize[getLeader(x)];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n public boolean canTraverseAllPairs(int[] nums) {\\n        int fre[] = new int[(int) 1e5 + 1];\\n        Arrays.fill(fre, -1);\\n        for (int i = 0; i < nums.length; i++) {\\n            fre[nums[i]] = i;\\n        }\\n        DSU gr = new DSU(nums.length);\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 1) {\\n                continue;\\n            }\\n            gr.mergeGroups(i, fre[nums[i]]);\\n        }\\n        for (int i = 2; i <= 1e5; i++) {\\n            int idx = -1;\\n            for (int j = i; j <= 1e5; j += i) {\\n                if (idx == -1) {\\n                    if (fre[j] != -1) {\\n                        idx = fre[j];\\n                    }\\n                } else {\\n                    if (fre[j] != -1) {\\n                        gr.mergeGroups(idx, fre[j]);\\n                    }\\n                }\\n            }\\n        }\\n        return gr.numberOFGroubs==1;\\n    }\\n     static class DSU {\\n\\n        int parnet[];\\n        int groupSize[];\\n        int numberOFNodes;\\n        int numberOFGroubs;\\n        int maxGroup;\\n\\n        DSU(int numberOFNodes) {\\n            this.numberOFNodes = numberOFNodes;\\n            parnet = new int[numberOFNodes + 1];\\n            groupSize = new int[numberOFNodes + 1];\\n            numberOFGroubs = numberOFNodes;\\n            maxGroup = 1;\\n            for (int i = 0; i <= numberOFNodes; i++) {\\n                parnet[i] = i;\\n                groupSize[i] = 1;\\n            }\\n        }\\n\\n        int getLeader(int x) {\\n            return parnet[x] = (parnet[x] == x ? x : getLeader(parnet[x]));\\n        }\\n\\n        boolean sameGroup(int x, int y) {\\n            return getLeader(x) == getLeader(y);\\n        }\\n\\n        void mergeGroups(int x, int y) {\\n            int leader1 = getLeader(x);\\n            int leader2 = getLeader(y);\\n            if (leader1 != leader2) {\\n                numberOFGroubs--;\\n                if (groupSize[leader1] < groupSize[leader2]) {\\n                    int swap = leader1;\\n                    leader1 = leader2;\\n                    leader2 = swap;\\n                }\\n                parnet[leader2] = leader1;\\n                groupSize[leader1] += groupSize[leader2];\\n                maxGroup = Math.max(maxGroup, groupSize[leader1]);\\n            }\\n        }\\n\\n        int getSize(int x) {\\n            return groupSize[getLeader(x)];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568578,
                "title": "union-find-thought-process-explained",
                "content": "# Intuition\\n**Thought 1.** There exists a traversal between two numbers if they have a common factor.\\n\\n**Thought 2.** If they don\\'t have common factor maybe we can use intermediate number with which they\\'ve gcd>1.\\ni.e. if gcd(3,4)=1 then we can\\'t go from 3 to 4\\nbut if array is like [3,12,4] then gcd(3,12)>1 and gcd(12,4)>1 hence we can go from 3 to 12 and 12 to 4\\n\\n**Thought 3.** Hence we can traverse from a to b if gcd(a,b)>1 or there exists a sequence of numbers between them such that gcd of each corresponding pair of numbers is greater than 1.\\n\\n# Approach\\n1. We group every set of elements having same common factor using hashmap.\\n2. If one of the element(say x) of certain group is present in another group also, then we can reach every node of other group also by using x as intermediate element.\\n3. So to group elements which are reachable from one another we can use Union Find.\\n4. If there exists only one connected component, we can traverse between every pair of numbers.\\n5. For finding common factors we use sieve.\\n\\n# Complexity\\n- Time complexity:\\n**Sieve Algorithm**: O(n log log n) - It takes this time complexity to calculate the smallest prime factors for numbers up to \\'n\\' using the sieve algorithm.\\n**Hashing**: O(n log n) - We iterate through the array once and find the prime factors for each number, which takes O(log n) time in the worst case for each number.\\n**Union-Find (Path Compression)**: O(n) - We perform the union operation and find the parent of each element in the disjoint set data structure, where the time complexity is nearly constant due to path compression.\\n\\n- **Overall**: O(n log log n) + O(n log n) + O(n) ~ O(n log n)\\n\\n# Code\\n```\\n//SIEVE Preprocessing\\ntypedef long long ll;\\ntypedef priority_queue<int, vector<int>, greater<int>> pq_int;\\n\\nconst ll N = 1e6 + 5;\\n\\nll factors[N];\\n\\nvoid sieve(ll n) {\\n  memset(factors, 0, sizeof(factors));\\n  for (ll i = 2; i <= n; i++) {\\n    factors[i] = i;\\n  }\\n\\n  for (ll i = 2; i <= n; i++) {\\n    if (factors[i] == i) {\\n      for (ll j = i * i; j <= n; j += i) {\\n        if (factors[j] == j) factors[j] = i;\\n      }\\n    }\\n  }\\n}\\n\\nvector<int> find_prime_factors(int n) {\\n    vector <int> prime_factors;\\n    int x = n;\\n    while (x != 1) {\\n        prime_factors.push_back(factors[x]);\\n        x /= factors[x];\\n    }\\n    return prime_factors;\\n}\\n\\n//DSU/Union-Find Template\\nclass DisjointSet {\\npublic: \\n    vector<int> parent, size; \\n    DisjointSet(int n) {\\n        parent.resize(n+1);\\n        size.resize(n+1); \\n        for(int i = 0;i<=n;i++) {\\n            parent[i] = i; \\n            size[i] = 1; \\n        }\\n    }\\n\\n    int find(int node) {\\n        return node==parent[node]?node:parent[node]=find(parent[node]);\\n    }\\n\\n    void unite(int u, int v) {\\n        int ulp_u = find(u); \\n        int ulp_v = find(v); \\n        if(ulp_u == ulp_v) return; \\n        if(size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v; \\n            size[ulp_v] += size[ulp_u]; \\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v]; \\n        }\\n    }\\n}; \\n\\nclass Solution {\\npublic:\\n    Solution(){\\n        sieve(1e5);\\n    }\\npublic:\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int n=nums.size();\\n        map <int,vector<int>> same_prime_factor;\\n        for(int i=0;i<n;i++){\\n            int num=nums[i];\\n            vector <int> prime_factors=find_prime_factors(num);\\n            for(auto factor:prime_factors){\\n                same_prime_factor[factor].push_back(i);\\n            }\\n        }\\n\\n        set <int> groups;\\n        DisjointSet dsu(n);\\n\\n        for(auto [_,sequence]:same_prime_factor){\\n            for(int i=1;i<sequence.size();i++){\\n                dsu.unite(sequence[i],sequence[i-1]);\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            groups.insert(dsu.find(i));\\n        }\\n        \\n        return groups.size()==1;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Math",
                    "Union Find"
                ],
                "code": "```\\n//SIEVE Preprocessing\\ntypedef long long ll;\\ntypedef priority_queue<int, vector<int>, greater<int>> pq_int;\\n\\nconst ll N = 1e6 + 5;\\n\\nll factors[N];\\n\\nvoid sieve(ll n) {\\n  memset(factors, 0, sizeof(factors));\\n  for (ll i = 2; i <= n; i++) {\\n    factors[i] = i;\\n  }\\n\\n  for (ll i = 2; i <= n; i++) {\\n    if (factors[i] == i) {\\n      for (ll j = i * i; j <= n; j += i) {\\n        if (factors[j] == j) factors[j] = i;\\n      }\\n    }\\n  }\\n}\\n\\nvector<int> find_prime_factors(int n) {\\n    vector <int> prime_factors;\\n    int x = n;\\n    while (x != 1) {\\n        prime_factors.push_back(factors[x]);\\n        x /= factors[x];\\n    }\\n    return prime_factors;\\n}\\n\\n//DSU/Union-Find Template\\nclass DisjointSet {\\npublic: \\n    vector<int> parent, size; \\n    DisjointSet(int n) {\\n        parent.resize(n+1);\\n        size.resize(n+1); \\n        for(int i = 0;i<=n;i++) {\\n            parent[i] = i; \\n            size[i] = 1; \\n        }\\n    }\\n\\n    int find(int node) {\\n        return node==parent[node]?node:parent[node]=find(parent[node]);\\n    }\\n\\n    void unite(int u, int v) {\\n        int ulp_u = find(u); \\n        int ulp_v = find(v); \\n        if(ulp_u == ulp_v) return; \\n        if(size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v; \\n            size[ulp_v] += size[ulp_u]; \\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v]; \\n        }\\n    }\\n}; \\n\\nclass Solution {\\npublic:\\n    Solution(){\\n        sieve(1e5);\\n    }\\npublic:\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int n=nums.size();\\n        map <int,vector<int>> same_prime_factor;\\n        for(int i=0;i<n;i++){\\n            int num=nums[i];\\n            vector <int> prime_factors=find_prime_factors(num);\\n            for(auto factor:prime_factors){\\n                same_prime_factor[factor].push_back(i);\\n            }\\n        }\\n\\n        set <int> groups;\\n        DisjointSet dsu(n);\\n\\n        for(auto [_,sequence]:same_prime_factor){\\n            for(int i=1;i<sequence.size();i++){\\n                dsu.unite(sequence[i],sequence[i-1]);\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            groups.insert(dsu.find(i));\\n        }\\n        \\n        return groups.size()==1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568574,
                "title": "java-union-find",
                "content": "This is a graph problem.\\nThere is an edge between node `i` and node `j` if `gcd(i, j) > 1`.\\nThe question is asking if the graph is connected.\\n\\nYou can do that with[ union find. ](https://en.wikipedia.org/wiki/Disjoint-set_data_structure).\\nWe traverse nums, and if there is a common divisor between `num[i]` and any of the previous nums, we link them together. To do that we keep a map of divisor -> num. \\n\\nThen we check that we only have one set.\\n\\n\\n```\\nclass Solution {\\n\\n    private Map<Integer, Integer> divisors;\\n    private DisjointSet[] sets;\\n\\n    public boolean canTraverseAllPairs(int[] nums) {\\n        divisors = new HashMap<>();\\n        int l = nums.length;\\n\\n        sets = new DisjointSet[l];\\n        for (int index = 0; index < l; index++) {\\n            sets[index] = new DisjointSet();\\n            DisjointSet current = sets[index];\\n            int n = nums[index];\\n            for (int i = 1; i <= Math.sqrt(n); i++) {\\n                if (n % i == 0) {\\n                    link(current,i);\\n                    link(current, n/i);\\n                }\\n            }\\n            addDivisors(nums[index], index);\\n        }\\n\\n        Set<DisjointSet> totalSets = new HashSet<>();\\n\\n        for (DisjointSet set : sets) {\\n            totalSets.add(set.findSet());\\n        }\\n\\n        return totalSets.size() == 1;\\n\\n    }\\n\\n    void link(DisjointSet current, int divisor) {\\n        Integer other = divisors.get(divisor);\\n         if(other != null)   DisjointSet.union(current, sets[other]);\\n\\n    }\\n\\n    void addDivisors(int n, int index) {\\n        for (int i = 2; i <= Math.sqrt(n); i++) {\\n            if (n % i == 0) {\\n                add(i, index);\\n                add(n / i, index);\\n            }\\n        }\\n\\n        if(n != 1)add(n, index);\\n    }\\n\\n    private void add(int divisor, int index) {\\n        divisors.put(divisor, index);\\n    }\\n\\n    private static class DisjointSet {\\n        int rank = 0;\\n        DisjointSet p = this;\\n\\n        private static void link(DisjointSet x, DisjointSet y) {\\n            if (x.rank > y.rank) {\\n                y.p = x;\\n            } else {\\n                x.p = y;\\n                if (x.rank == y.rank) y.rank++;\\n            }\\n        }\\n\\n        public static void union(DisjointSet x, DisjointSet y) {\\n            link(x.findSet(), y.findSet());\\n        }\\n\\n        public DisjointSet findSet() {\\n            if (this.p != this) this.p = this.p.findSet();\\n            return this.p;\\n        }\\n\\n        public boolean sameSet(DisjointSet other) {\\n            return findSet() == other.findSet();\\n        }\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n\\n    private Map<Integer, Integer> divisors;\\n    private DisjointSet[] sets;\\n\\n    public boolean canTraverseAllPairs(int[] nums) {\\n        divisors = new HashMap<>();\\n        int l = nums.length;\\n\\n        sets = new DisjointSet[l];\\n        for (int index = 0; index < l; index++) {\\n            sets[index] = new DisjointSet();\\n            DisjointSet current = sets[index];\\n            int n = nums[index];\\n            for (int i = 1; i <= Math.sqrt(n); i++) {\\n                if (n % i == 0) {\\n                    link(current,i);\\n                    link(current, n/i);\\n                }\\n            }\\n            addDivisors(nums[index], index);\\n        }\\n\\n        Set<DisjointSet> totalSets = new HashSet<>();\\n\\n        for (DisjointSet set : sets) {\\n            totalSets.add(set.findSet());\\n        }\\n\\n        return totalSets.size() == 1;\\n\\n    }\\n\\n    void link(DisjointSet current, int divisor) {\\n        Integer other = divisors.get(divisor);\\n         if(other != null)   DisjointSet.union(current, sets[other]);\\n\\n    }\\n\\n    void addDivisors(int n, int index) {\\n        for (int i = 2; i <= Math.sqrt(n); i++) {\\n            if (n % i == 0) {\\n                add(i, index);\\n                add(n / i, index);\\n            }\\n        }\\n\\n        if(n != 1)add(n, index);\\n    }\\n\\n    private void add(int divisor, int index) {\\n        divisors.put(divisor, index);\\n    }\\n\\n    private static class DisjointSet {\\n        int rank = 0;\\n        DisjointSet p = this;\\n\\n        private static void link(DisjointSet x, DisjointSet y) {\\n            if (x.rank > y.rank) {\\n                y.p = x;\\n            } else {\\n                x.p = y;\\n                if (x.rank == y.rank) y.rank++;\\n            }\\n        }\\n\\n        public static void union(DisjointSet x, DisjointSet y) {\\n            link(x.findSet(), y.findSet());\\n        }\\n\\n        public DisjointSet findSet() {\\n            if (this.p != this) this.p = this.p.findSet();\\n            return this.p;\\n        }\\n\\n        public boolean sameSet(DisjointSet other) {\\n            return findSet() == other.findSet();\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568563,
                "title": "c-dsu-sieve-union-find",
                "content": "```\\nclass Solution {\\npublic:\\n    class DSU {\\nprivate:\\n    vector<int> prnt;\\n    vector<int> rank;\\n\\npublic:\\n    DSU(int n) {\\n        prnt.resize(n);\\n        rank.resize(n, 1);\\n        for (int i = 0; i < n; i++) {\\n            prnt[i] = i;\\n        }\\n    }\\n\\n    int find(int x) {\\n        if (prnt[x] != x) {\\n            prnt[x] = find(prnt[x]);\\n        }\\n        return prnt[x];\\n    }\\n\\n    void merge(int x, int y) {\\n        int rX = find(x);\\n        int rY = find(y);\\n\\n        if (rX != rY) {\\n            if (rank[rX] < rank[rY]) {\\n                prnt[rX] = rY;\\n            } else if (rank[rX] > rank[rY]) {\\n                prnt[rY] = rX;\\n            } else {\\n                prnt[rX] = rY;\\n                rank[rY]++;\\n            }\\n        }\\n    }\\n};\\n\\nbool canTraverseAllPairs(vector<int>& nums) {\\n    int n = nums.size();\\n    DSU temp(n);\\n\\n    unordered_map<int, vector<int>> divisor;\\n\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 2; j * j <= nums[i]; j++) {\\n            if (nums[i] % j == 0) {\\n                divisor[j].push_back(i);\\n                while (nums[i] % j == 0) {\\n                    nums[i] /= j;\\n                }\\n            }\\n        }\\n        if (nums[i] > 1) {\\n            divisor[nums[i]].push_back(i);\\n        }\\n    }\\n\\n    for (auto& fac : divisor) {\\n        vector<int>& indices = fac.second;\\n        for (int i = 1; i < indices.size(); i++) {\\n            temp.merge(indices[i - 1], indices[i]);\\n        }\\n    }\\n\\n    int root = temp.find(0);\\n    for (int i = 1; i < n; i++) {\\n        if (temp.find(i) != root) {\\n            return false;\\n        }\\n    }\\n\\n    return true;\\n}\\n   \\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    class DSU {\\nprivate:\\n    vector<int> prnt;\\n    vector<int> rank;\\n\\npublic:\\n    DSU(int n) {\\n        prnt.resize(n);\\n        rank.resize(n, 1);\\n        for (int i = 0; i < n; i++) {\\n            prnt[i] = i;\\n        }\\n    }\\n\\n    int find(int x) {\\n        if (prnt[x] != x) {\\n            prnt[x] = find(prnt[x]);\\n        }\\n        return prnt[x];\\n    }\\n\\n    void merge(int x, int y) {\\n        int rX = find(x);\\n        int rY = find(y);\\n\\n        if (rX != rY) {\\n            if (rank[rX] < rank[rY]) {\\n                prnt[rX] = rY;\\n            } else if (rank[rX] > rank[rY]) {\\n                prnt[rY] = rX;\\n            } else {\\n                prnt[rX] = rY;\\n                rank[rY]++;\\n            }\\n        }\\n    }\\n};\\n\\nbool canTraverseAllPairs(vector<int>& nums) {\\n    int n = nums.size();\\n    DSU temp(n);\\n\\n    unordered_map<int, vector<int>> divisor;\\n\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 2; j * j <= nums[i]; j++) {\\n            if (nums[i] % j == 0) {\\n                divisor[j].push_back(i);\\n                while (nums[i] % j == 0) {\\n                    nums[i] /= j;\\n                }\\n            }\\n        }\\n        if (nums[i] > 1) {\\n            divisor[nums[i]].push_back(i);\\n        }\\n    }\\n\\n    for (auto& fac : divisor) {\\n        vector<int>& indices = fac.second;\\n        for (int i = 1; i < indices.size(); i++) {\\n            temp.merge(indices[i - 1], indices[i]);\\n        }\\n    }\\n\\n    int root = temp.find(0);\\n    for (int i = 1; i < n; i++) {\\n        if (temp.find(i) != root) {\\n            return false;\\n        }\\n    }\\n\\n    return true;\\n}\\n   \\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568558,
                "title": "union-find-prime-factorization",
                "content": "# Intuition\\n\\nThe problem can be rephrased to:\\nGiven an array from which we _can_ construct a graph. In this graph, there\\'s an edge between two nodes (indices `i` and `j`) iff `nums[i]` and `nums[j]` is not coprime. Is this graph connected?\\n\\n# Idea\\n\\nWe can use the disjoint-set union (aka. union-find algorithm) to solve this problem. For every index `i` and its number `nums[i]`, we perform prime factorization. For every prime factor `z` of `nums[i]`, we connect `i` to _any_ other index `j` where `nums[j]`\\'s prime factors also include `z`. We use a map `unordered_map<int, vector<int>>` to keep track of this information of which each key is a prime factor of some number we\\'ve seen and its value is a list of indices where the numbers positioned at them have such prime factor.\\n\\nThen, the problem becomes straight-forward if one knows the standard implementation of the disjoint-set union.\\n\\n# Impl\\n\\n```cpp\\n// Disjoint-set/union-find\\nclass UF\\n{\\n    int n = 0;\\n    vector<int> parent;\\n\\n  public:\\n    UF(vector<int> &nums)\\n    {\\n        n = nums.size();\\n        parent.assign(n, 0);\\n        for (int i = 0; i < n; ++i) { parent[i] = i; }\\n    }\\n\\n    // Find parent/root of the node x.\\n    // With path compression.\\n    int find(int x)\\n    {\\n        if (x != parent[x]) parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n\\n    // Connect p to q.\\n    void connect(int p, int q)\\n    {\\n        int rootp = find(p), rootq = find(q);\\n        if (rootp == rootq) return;\\n\\n        parent[rootq] = rootp;\\n        n--;\\n    }\\n\\n    // Returns the number of connected components.\\n    int count()\\n    {\\n        return n;\\n    }\\n};\\n\\n// Prime factorization.\\nvoid factor(int idx, int num, unordered_map<int, vector<int>> &mp, UF &uf)\\n{\\n    int z = 2;\\n\\n    while (z * z <= num)\\n    {\\n        if (num % z == 0)\\n        {\\n            // Connect idx to any node that has the prime factor z.\\n            if (mp.count(z)) { uf.connect(idx, mp[z][0]); }\\n            mp[z].push_back(idx);\\n            num /= z;\\n        }\\n        else { z++; }\\n    }\\n    // Connect idx to any node that has the prime factor num.\\n    if (num > 1)\\n    {\\n        if (mp.count(num)) { uf.connect(idx, mp[num][0]); }\\n        mp[num].push_back(idx);\\n    }\\n}\\n\\nclass Solution\\n{\\n  public:\\n    bool canTraverseAllPairs(vector<int> &nums)\\n    {\\n        unordered_map<int, vector<int>> mp;\\n\\n        UF uf(nums);\\n        for (int i = 0; i < nums.size(); ++i)\\n        {\\n            int num = nums[i];\\n            factor(i, num, mp, uf);\\n        }\\n\\n        return uf.count() == 1;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```cpp\\n// Disjoint-set/union-find\\nclass UF\\n{\\n    int n = 0;\\n    vector<int> parent;\\n\\n  public:\\n    UF(vector<int> &nums)\\n    {\\n        n = nums.size();\\n        parent.assign(n, 0);\\n        for (int i = 0; i < n; ++i) { parent[i] = i; }\\n    }\\n\\n    // Find parent/root of the node x.\\n    // With path compression.\\n    int find(int x)\\n    {\\n        if (x != parent[x]) parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n\\n    // Connect p to q.\\n    void connect(int p, int q)\\n    {\\n        int rootp = find(p), rootq = find(q);\\n        if (rootp == rootq) return;\\n\\n        parent[rootq] = rootp;\\n        n--;\\n    }\\n\\n    // Returns the number of connected components.\\n    int count()\\n    {\\n        return n;\\n    }\\n};\\n\\n// Prime factorization.\\nvoid factor(int idx, int num, unordered_map<int, vector<int>> &mp, UF &uf)\\n{\\n    int z = 2;\\n\\n    while (z * z <= num)\\n    {\\n        if (num % z == 0)\\n        {\\n            // Connect idx to any node that has the prime factor z.\\n            if (mp.count(z)) { uf.connect(idx, mp[z][0]); }\\n            mp[z].push_back(idx);\\n            num /= z;\\n        }\\n        else { z++; }\\n    }\\n    // Connect idx to any node that has the prime factor num.\\n    if (num > 1)\\n    {\\n        if (mp.count(num)) { uf.connect(idx, mp[num][0]); }\\n        mp[num].push_back(idx);\\n    }\\n}\\n\\nclass Solution\\n{\\n  public:\\n    bool canTraverseAllPairs(vector<int> &nums)\\n    {\\n        unordered_map<int, vector<int>> mp;\\n\\n        UF uf(nums);\\n        for (int i = 0; i < nums.size(); ++i)\\n        {\\n            int num = nums[i];\\n            factor(i, num, mp, uf);\\n        }\\n\\n        return uf.count() == 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1907464,
                "content": [
                    {
                        "username": "Driver12",
                        "content": "Upvote if u thought that looking for all prime divisors for every number is too long for these constraints..."
                    },
                    {
                        "username": "rjanshuman",
                        "content": "i stored/duplicated the input in an arraylist and created a 2D arraylist which has group of arrays divisible by prime numbers onwards 2 such that 1st group is even no.s, 2nd is multiple of 3 (but not 2), third is multiple of 5 (but not 2& 3) and so on..\\n\\nlater if at least one non-coprime no is found among this subarrays, then these are merged and in the end if the final array has same length as nums then it means iterable else not.\\n\\nMy approach/code passes 916/925 tests. However, it says time limit exceeded when an input of 5566 elements of 99991, a prime number is given... which is logical seeing the non-optimality of my code...\\n\\nNow, thinking of optimizing....\\n"
                    },
                    {
                        "username": "Akarshippili",
                        "content": "For me it says: \\nTime Limit Exceeded\\n921 / 921 testcases passed\\n\\n@LeetCode what does it mean ?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hiding the testcase [1,1] during the contest was a nasty, nasty move."
                    },
                    {
                        "username": "cjcoax",
                        "content": "There is a special place in hell for who hid it during the contest!"
                    },
                    {
                        "username": "czjnbb",
                        "content": "I only failed on this case: [1]. Very SAD."
                    },
                    {
                        "username": "czjnbb",
                        "content": "[@ybblkblt](/ybblkblt) If LC didn\\'t hide it during the contest..."
                    },
                    {
                        "username": "ybblkblt",
                        "content": "Me too!!! It would have been the first time I got the last question on the contest!!"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Fuck you 1"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "i wrote the code in n^2 but it got accepted,how?\\n"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "[@cartesPerforees](/cartesPerforees) oh,thanks for this,initially  i was hoping this solution would give tle and then i would have proceeded further with dsu, but it got accepted anyways"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "[@shivangi806](/shivangi806)  gcd of a number with itself is the number itself and we return false only if gcd with every other number is 1(except the number itself)"
                    },
                    {
                        "username": "shivangi806",
                        "content": "what is logic of putting nums[i]!=nums[j] as if it is equal also then there is no issue but it gives me wrong answer for 1 test case"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your code is not n^2. \nI guess you are checking all the multiples? Then you are checking every second numbers, then every third numbers, etc...\n$1/2+1/3+...1/n$ sums as $log(n)$. So your code is nlogn. I do assume that if an interviewr asks this question he will expect the complexity analysis of it tho, otherwise you're just walking into the right solution without knowing why"
                    },
                    {
                        "username": "divii",
                        "content": "` while (n % i == 0) n /= i;`\\nthis is where i lost :("
                    },
                    {
                        "username": "ujwalkv",
                        "content": "if I simply type run a testcase is passing , but when I click on submit the same testcase is giving a wrong answer"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "why testcase nums =[1] (tc917) will expected true ? \"determine if for every pair of indices i and j with i<j\" "
                    },
                    {
                        "username": "janis__",
                        "content": "The given condition states: \"determine if for every pair of indices ii and jj with i<ji<j\". When the list nums contains only one element (like in the testcase nums = [1]), there are no pairs of indices i,ji,j such that i<ji<j. Therefore, there\\'s no condition to violate and the result is True by default. In simpler terms, when there\\'s only one number, there are no other numbers to compare or connect to, so the requirements are inherently met. "
                    },
                    {
                        "username": "Getting_into_form",
                        "content": "Why is this solution giving TLE?\\n\\n```\\ntypedef vector<int> VI;\\ntypedef vector<VI> VVI;\\n\\nclass Solution {\\npublic:\\n    int spf[100000+1];\\n    unordered_map<int, int> primeToIndex;\\n    \\n    void calc(int maxNum){\\n        for(int i=1;i<=maxNum;i++) spf[i]=i;\\n\\n        int index = maxNum;\\n        for(int p = 2;p <= maxNum; p++){\\n            if(spf[p] != p) continue; \\n            \\n            primeToIndex[p] = index++;\\n            \\n            for(int j = 2*p;j <= maxNum;j += p){\\n                if(spf[j] == j) spf[j] = p;\\n            }\\n        }\\n    }\\n\\n    class DSU{\\n        private:\\n        VI parent;\\n        public:\\n        DSU(int n){\\n            for(int i=0;i<n;i++) parent.push_back(-1);\\n            //parent.resize(n, -1);\\n        }\\n        int find_(int x){\\n            if(parent[x] < 0) return x;\\n            // int p = find_(parent[x]);\\n            // parent[x] = p;\\n            parent[x] = find_(parent[x]);\\n            return parent[x];\\n        }\\n        void union_(int x, int y){\\n            int p1=find_(x), p2=find_(y);\\n            if(p1 != p2){\\n                parent[p1] += parent[p2];\\n                parent[p2] = p1;\\n            }\\n        }\\n    };\\n\\n    void factorize(int x, DSU &d, unordered_map<int, int> &m, int &index){\\n        cout<<x<<endl;\\n        while(x > 1){\\n            int p = spf[x];\\n            d.union_(m[p], index);\\n            while(x%p == 0){\\n                x /= p;\\n                //cout<<\"Y0\"<<endl;\\n            }\\n        }\\n    }\\n\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int maxNum = 100000;\\n        DSU d(2*maxNum+1);\\n\\n        int n = nums.size();\\n        calc(maxNum);\\n        \\n        for(int i=0;i<n;i++){\\n            factorize(nums[i], d, primeToIndex, i);\\n        }\\n        set<int> count;\\n        for(int i=0;i<n;i++){\\n            count.insert(d.find_(i));\\n        }\\n        return (int)count.size() == 1;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "janis__",
                        "content": "The solution is TLE due to inefficiencies in the calc function\\'s nested loop for prime factorization and the factorize function. To fix it please optimize prime factorization using a more efficient Sieve of Eratosthenes and Streamline the union-find operations in factorize."
                    },
                    {
                        "username": "Getting_into_form",
                        "content": "Testcases are being accepted in run window but giving TLE on submission."
                    }
                ]
            },
            {
                "id": 1907639,
                "content": [
                    {
                        "username": "Driver12",
                        "content": "Upvote if u thought that looking for all prime divisors for every number is too long for these constraints..."
                    },
                    {
                        "username": "rjanshuman",
                        "content": "i stored/duplicated the input in an arraylist and created a 2D arraylist which has group of arrays divisible by prime numbers onwards 2 such that 1st group is even no.s, 2nd is multiple of 3 (but not 2), third is multiple of 5 (but not 2& 3) and so on..\\n\\nlater if at least one non-coprime no is found among this subarrays, then these are merged and in the end if the final array has same length as nums then it means iterable else not.\\n\\nMy approach/code passes 916/925 tests. However, it says time limit exceeded when an input of 5566 elements of 99991, a prime number is given... which is logical seeing the non-optimality of my code...\\n\\nNow, thinking of optimizing....\\n"
                    },
                    {
                        "username": "Akarshippili",
                        "content": "For me it says: \\nTime Limit Exceeded\\n921 / 921 testcases passed\\n\\n@LeetCode what does it mean ?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hiding the testcase [1,1] during the contest was a nasty, nasty move."
                    },
                    {
                        "username": "cjcoax",
                        "content": "There is a special place in hell for who hid it during the contest!"
                    },
                    {
                        "username": "czjnbb",
                        "content": "I only failed on this case: [1]. Very SAD."
                    },
                    {
                        "username": "czjnbb",
                        "content": "[@ybblkblt](/ybblkblt) If LC didn\\'t hide it during the contest..."
                    },
                    {
                        "username": "ybblkblt",
                        "content": "Me too!!! It would have been the first time I got the last question on the contest!!"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Fuck you 1"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "i wrote the code in n^2 but it got accepted,how?\\n"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "[@cartesPerforees](/cartesPerforees) oh,thanks for this,initially  i was hoping this solution would give tle and then i would have proceeded further with dsu, but it got accepted anyways"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "[@shivangi806](/shivangi806)  gcd of a number with itself is the number itself and we return false only if gcd with every other number is 1(except the number itself)"
                    },
                    {
                        "username": "shivangi806",
                        "content": "what is logic of putting nums[i]!=nums[j] as if it is equal also then there is no issue but it gives me wrong answer for 1 test case"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your code is not n^2. \nI guess you are checking all the multiples? Then you are checking every second numbers, then every third numbers, etc...\n$1/2+1/3+...1/n$ sums as $log(n)$. So your code is nlogn. I do assume that if an interviewr asks this question he will expect the complexity analysis of it tho, otherwise you're just walking into the right solution without knowing why"
                    },
                    {
                        "username": "divii",
                        "content": "` while (n % i == 0) n /= i;`\\nthis is where i lost :("
                    },
                    {
                        "username": "ujwalkv",
                        "content": "if I simply type run a testcase is passing , but when I click on submit the same testcase is giving a wrong answer"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "why testcase nums =[1] (tc917) will expected true ? \"determine if for every pair of indices i and j with i<j\" "
                    },
                    {
                        "username": "janis__",
                        "content": "The given condition states: \"determine if for every pair of indices ii and jj with i<ji<j\". When the list nums contains only one element (like in the testcase nums = [1]), there are no pairs of indices i,ji,j such that i<ji<j. Therefore, there\\'s no condition to violate and the result is True by default. In simpler terms, when there\\'s only one number, there are no other numbers to compare or connect to, so the requirements are inherently met. "
                    },
                    {
                        "username": "Getting_into_form",
                        "content": "Why is this solution giving TLE?\\n\\n```\\ntypedef vector<int> VI;\\ntypedef vector<VI> VVI;\\n\\nclass Solution {\\npublic:\\n    int spf[100000+1];\\n    unordered_map<int, int> primeToIndex;\\n    \\n    void calc(int maxNum){\\n        for(int i=1;i<=maxNum;i++) spf[i]=i;\\n\\n        int index = maxNum;\\n        for(int p = 2;p <= maxNum; p++){\\n            if(spf[p] != p) continue; \\n            \\n            primeToIndex[p] = index++;\\n            \\n            for(int j = 2*p;j <= maxNum;j += p){\\n                if(spf[j] == j) spf[j] = p;\\n            }\\n        }\\n    }\\n\\n    class DSU{\\n        private:\\n        VI parent;\\n        public:\\n        DSU(int n){\\n            for(int i=0;i<n;i++) parent.push_back(-1);\\n            //parent.resize(n, -1);\\n        }\\n        int find_(int x){\\n            if(parent[x] < 0) return x;\\n            // int p = find_(parent[x]);\\n            // parent[x] = p;\\n            parent[x] = find_(parent[x]);\\n            return parent[x];\\n        }\\n        void union_(int x, int y){\\n            int p1=find_(x), p2=find_(y);\\n            if(p1 != p2){\\n                parent[p1] += parent[p2];\\n                parent[p2] = p1;\\n            }\\n        }\\n    };\\n\\n    void factorize(int x, DSU &d, unordered_map<int, int> &m, int &index){\\n        cout<<x<<endl;\\n        while(x > 1){\\n            int p = spf[x];\\n            d.union_(m[p], index);\\n            while(x%p == 0){\\n                x /= p;\\n                //cout<<\"Y0\"<<endl;\\n            }\\n        }\\n    }\\n\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int maxNum = 100000;\\n        DSU d(2*maxNum+1);\\n\\n        int n = nums.size();\\n        calc(maxNum);\\n        \\n        for(int i=0;i<n;i++){\\n            factorize(nums[i], d, primeToIndex, i);\\n        }\\n        set<int> count;\\n        for(int i=0;i<n;i++){\\n            count.insert(d.find_(i));\\n        }\\n        return (int)count.size() == 1;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "janis__",
                        "content": "The solution is TLE due to inefficiencies in the calc function\\'s nested loop for prime factorization and the factorize function. To fix it please optimize prime factorization using a more efficient Sieve of Eratosthenes and Streamline the union-find operations in factorize."
                    },
                    {
                        "username": "Getting_into_form",
                        "content": "Testcases are being accepted in run window but giving TLE on submission."
                    }
                ]
            },
            {
                "id": 1907538,
                "content": [
                    {
                        "username": "Driver12",
                        "content": "Upvote if u thought that looking for all prime divisors for every number is too long for these constraints..."
                    },
                    {
                        "username": "rjanshuman",
                        "content": "i stored/duplicated the input in an arraylist and created a 2D arraylist which has group of arrays divisible by prime numbers onwards 2 such that 1st group is even no.s, 2nd is multiple of 3 (but not 2), third is multiple of 5 (but not 2& 3) and so on..\\n\\nlater if at least one non-coprime no is found among this subarrays, then these are merged and in the end if the final array has same length as nums then it means iterable else not.\\n\\nMy approach/code passes 916/925 tests. However, it says time limit exceeded when an input of 5566 elements of 99991, a prime number is given... which is logical seeing the non-optimality of my code...\\n\\nNow, thinking of optimizing....\\n"
                    },
                    {
                        "username": "Akarshippili",
                        "content": "For me it says: \\nTime Limit Exceeded\\n921 / 921 testcases passed\\n\\n@LeetCode what does it mean ?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hiding the testcase [1,1] during the contest was a nasty, nasty move."
                    },
                    {
                        "username": "cjcoax",
                        "content": "There is a special place in hell for who hid it during the contest!"
                    },
                    {
                        "username": "czjnbb",
                        "content": "I only failed on this case: [1]. Very SAD."
                    },
                    {
                        "username": "czjnbb",
                        "content": "[@ybblkblt](/ybblkblt) If LC didn\\'t hide it during the contest..."
                    },
                    {
                        "username": "ybblkblt",
                        "content": "Me too!!! It would have been the first time I got the last question on the contest!!"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Fuck you 1"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "i wrote the code in n^2 but it got accepted,how?\\n"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "[@cartesPerforees](/cartesPerforees) oh,thanks for this,initially  i was hoping this solution would give tle and then i would have proceeded further with dsu, but it got accepted anyways"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "[@shivangi806](/shivangi806)  gcd of a number with itself is the number itself and we return false only if gcd with every other number is 1(except the number itself)"
                    },
                    {
                        "username": "shivangi806",
                        "content": "what is logic of putting nums[i]!=nums[j] as if it is equal also then there is no issue but it gives me wrong answer for 1 test case"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your code is not n^2. \nI guess you are checking all the multiples? Then you are checking every second numbers, then every third numbers, etc...\n$1/2+1/3+...1/n$ sums as $log(n)$. So your code is nlogn. I do assume that if an interviewr asks this question he will expect the complexity analysis of it tho, otherwise you're just walking into the right solution without knowing why"
                    },
                    {
                        "username": "divii",
                        "content": "` while (n % i == 0) n /= i;`\\nthis is where i lost :("
                    },
                    {
                        "username": "ujwalkv",
                        "content": "if I simply type run a testcase is passing , but when I click on submit the same testcase is giving a wrong answer"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "why testcase nums =[1] (tc917) will expected true ? \"determine if for every pair of indices i and j with i<j\" "
                    },
                    {
                        "username": "janis__",
                        "content": "The given condition states: \"determine if for every pair of indices ii and jj with i<ji<j\". When the list nums contains only one element (like in the testcase nums = [1]), there are no pairs of indices i,ji,j such that i<ji<j. Therefore, there\\'s no condition to violate and the result is True by default. In simpler terms, when there\\'s only one number, there are no other numbers to compare or connect to, so the requirements are inherently met. "
                    },
                    {
                        "username": "Getting_into_form",
                        "content": "Why is this solution giving TLE?\\n\\n```\\ntypedef vector<int> VI;\\ntypedef vector<VI> VVI;\\n\\nclass Solution {\\npublic:\\n    int spf[100000+1];\\n    unordered_map<int, int> primeToIndex;\\n    \\n    void calc(int maxNum){\\n        for(int i=1;i<=maxNum;i++) spf[i]=i;\\n\\n        int index = maxNum;\\n        for(int p = 2;p <= maxNum; p++){\\n            if(spf[p] != p) continue; \\n            \\n            primeToIndex[p] = index++;\\n            \\n            for(int j = 2*p;j <= maxNum;j += p){\\n                if(spf[j] == j) spf[j] = p;\\n            }\\n        }\\n    }\\n\\n    class DSU{\\n        private:\\n        VI parent;\\n        public:\\n        DSU(int n){\\n            for(int i=0;i<n;i++) parent.push_back(-1);\\n            //parent.resize(n, -1);\\n        }\\n        int find_(int x){\\n            if(parent[x] < 0) return x;\\n            // int p = find_(parent[x]);\\n            // parent[x] = p;\\n            parent[x] = find_(parent[x]);\\n            return parent[x];\\n        }\\n        void union_(int x, int y){\\n            int p1=find_(x), p2=find_(y);\\n            if(p1 != p2){\\n                parent[p1] += parent[p2];\\n                parent[p2] = p1;\\n            }\\n        }\\n    };\\n\\n    void factorize(int x, DSU &d, unordered_map<int, int> &m, int &index){\\n        cout<<x<<endl;\\n        while(x > 1){\\n            int p = spf[x];\\n            d.union_(m[p], index);\\n            while(x%p == 0){\\n                x /= p;\\n                //cout<<\"Y0\"<<endl;\\n            }\\n        }\\n    }\\n\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int maxNum = 100000;\\n        DSU d(2*maxNum+1);\\n\\n        int n = nums.size();\\n        calc(maxNum);\\n        \\n        for(int i=0;i<n;i++){\\n            factorize(nums[i], d, primeToIndex, i);\\n        }\\n        set<int> count;\\n        for(int i=0;i<n;i++){\\n            count.insert(d.find_(i));\\n        }\\n        return (int)count.size() == 1;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "janis__",
                        "content": "The solution is TLE due to inefficiencies in the calc function\\'s nested loop for prime factorization and the factorize function. To fix it please optimize prime factorization using a more efficient Sieve of Eratosthenes and Streamline the union-find operations in factorize."
                    },
                    {
                        "username": "Getting_into_form",
                        "content": "Testcases are being accepted in run window but giving TLE on submission."
                    }
                ]
            },
            {
                "id": 1907392,
                "content": [
                    {
                        "username": "Driver12",
                        "content": "Upvote if u thought that looking for all prime divisors for every number is too long for these constraints..."
                    },
                    {
                        "username": "rjanshuman",
                        "content": "i stored/duplicated the input in an arraylist and created a 2D arraylist which has group of arrays divisible by prime numbers onwards 2 such that 1st group is even no.s, 2nd is multiple of 3 (but not 2), third is multiple of 5 (but not 2& 3) and so on..\\n\\nlater if at least one non-coprime no is found among this subarrays, then these are merged and in the end if the final array has same length as nums then it means iterable else not.\\n\\nMy approach/code passes 916/925 tests. However, it says time limit exceeded when an input of 5566 elements of 99991, a prime number is given... which is logical seeing the non-optimality of my code...\\n\\nNow, thinking of optimizing....\\n"
                    },
                    {
                        "username": "Akarshippili",
                        "content": "For me it says: \\nTime Limit Exceeded\\n921 / 921 testcases passed\\n\\n@LeetCode what does it mean ?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hiding the testcase [1,1] during the contest was a nasty, nasty move."
                    },
                    {
                        "username": "cjcoax",
                        "content": "There is a special place in hell for who hid it during the contest!"
                    },
                    {
                        "username": "czjnbb",
                        "content": "I only failed on this case: [1]. Very SAD."
                    },
                    {
                        "username": "czjnbb",
                        "content": "[@ybblkblt](/ybblkblt) If LC didn\\'t hide it during the contest..."
                    },
                    {
                        "username": "ybblkblt",
                        "content": "Me too!!! It would have been the first time I got the last question on the contest!!"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Fuck you 1"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "i wrote the code in n^2 but it got accepted,how?\\n"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "[@cartesPerforees](/cartesPerforees) oh,thanks for this,initially  i was hoping this solution would give tle and then i would have proceeded further with dsu, but it got accepted anyways"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "[@shivangi806](/shivangi806)  gcd of a number with itself is the number itself and we return false only if gcd with every other number is 1(except the number itself)"
                    },
                    {
                        "username": "shivangi806",
                        "content": "what is logic of putting nums[i]!=nums[j] as if it is equal also then there is no issue but it gives me wrong answer for 1 test case"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your code is not n^2. \nI guess you are checking all the multiples? Then you are checking every second numbers, then every third numbers, etc...\n$1/2+1/3+...1/n$ sums as $log(n)$. So your code is nlogn. I do assume that if an interviewr asks this question he will expect the complexity analysis of it tho, otherwise you're just walking into the right solution without knowing why"
                    },
                    {
                        "username": "divii",
                        "content": "` while (n % i == 0) n /= i;`\\nthis is where i lost :("
                    },
                    {
                        "username": "ujwalkv",
                        "content": "if I simply type run a testcase is passing , but when I click on submit the same testcase is giving a wrong answer"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "why testcase nums =[1] (tc917) will expected true ? \"determine if for every pair of indices i and j with i<j\" "
                    },
                    {
                        "username": "janis__",
                        "content": "The given condition states: \"determine if for every pair of indices ii and jj with i<ji<j\". When the list nums contains only one element (like in the testcase nums = [1]), there are no pairs of indices i,ji,j such that i<ji<j. Therefore, there\\'s no condition to violate and the result is True by default. In simpler terms, when there\\'s only one number, there are no other numbers to compare or connect to, so the requirements are inherently met. "
                    },
                    {
                        "username": "Getting_into_form",
                        "content": "Why is this solution giving TLE?\\n\\n```\\ntypedef vector<int> VI;\\ntypedef vector<VI> VVI;\\n\\nclass Solution {\\npublic:\\n    int spf[100000+1];\\n    unordered_map<int, int> primeToIndex;\\n    \\n    void calc(int maxNum){\\n        for(int i=1;i<=maxNum;i++) spf[i]=i;\\n\\n        int index = maxNum;\\n        for(int p = 2;p <= maxNum; p++){\\n            if(spf[p] != p) continue; \\n            \\n            primeToIndex[p] = index++;\\n            \\n            for(int j = 2*p;j <= maxNum;j += p){\\n                if(spf[j] == j) spf[j] = p;\\n            }\\n        }\\n    }\\n\\n    class DSU{\\n        private:\\n        VI parent;\\n        public:\\n        DSU(int n){\\n            for(int i=0;i<n;i++) parent.push_back(-1);\\n            //parent.resize(n, -1);\\n        }\\n        int find_(int x){\\n            if(parent[x] < 0) return x;\\n            // int p = find_(parent[x]);\\n            // parent[x] = p;\\n            parent[x] = find_(parent[x]);\\n            return parent[x];\\n        }\\n        void union_(int x, int y){\\n            int p1=find_(x), p2=find_(y);\\n            if(p1 != p2){\\n                parent[p1] += parent[p2];\\n                parent[p2] = p1;\\n            }\\n        }\\n    };\\n\\n    void factorize(int x, DSU &d, unordered_map<int, int> &m, int &index){\\n        cout<<x<<endl;\\n        while(x > 1){\\n            int p = spf[x];\\n            d.union_(m[p], index);\\n            while(x%p == 0){\\n                x /= p;\\n                //cout<<\"Y0\"<<endl;\\n            }\\n        }\\n    }\\n\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int maxNum = 100000;\\n        DSU d(2*maxNum+1);\\n\\n        int n = nums.size();\\n        calc(maxNum);\\n        \\n        for(int i=0;i<n;i++){\\n            factorize(nums[i], d, primeToIndex, i);\\n        }\\n        set<int> count;\\n        for(int i=0;i<n;i++){\\n            count.insert(d.find_(i));\\n        }\\n        return (int)count.size() == 1;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "janis__",
                        "content": "The solution is TLE due to inefficiencies in the calc function\\'s nested loop for prime factorization and the factorize function. To fix it please optimize prime factorization using a more efficient Sieve of Eratosthenes and Streamline the union-find operations in factorize."
                    },
                    {
                        "username": "Getting_into_form",
                        "content": "Testcases are being accepted in run window but giving TLE on submission."
                    }
                ]
            },
            {
                "id": 1995537,
                "content": [
                    {
                        "username": "Driver12",
                        "content": "Upvote if u thought that looking for all prime divisors for every number is too long for these constraints..."
                    },
                    {
                        "username": "rjanshuman",
                        "content": "i stored/duplicated the input in an arraylist and created a 2D arraylist which has group of arrays divisible by prime numbers onwards 2 such that 1st group is even no.s, 2nd is multiple of 3 (but not 2), third is multiple of 5 (but not 2& 3) and so on..\\n\\nlater if at least one non-coprime no is found among this subarrays, then these are merged and in the end if the final array has same length as nums then it means iterable else not.\\n\\nMy approach/code passes 916/925 tests. However, it says time limit exceeded when an input of 5566 elements of 99991, a prime number is given... which is logical seeing the non-optimality of my code...\\n\\nNow, thinking of optimizing....\\n"
                    },
                    {
                        "username": "Akarshippili",
                        "content": "For me it says: \\nTime Limit Exceeded\\n921 / 921 testcases passed\\n\\n@LeetCode what does it mean ?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hiding the testcase [1,1] during the contest was a nasty, nasty move."
                    },
                    {
                        "username": "cjcoax",
                        "content": "There is a special place in hell for who hid it during the contest!"
                    },
                    {
                        "username": "czjnbb",
                        "content": "I only failed on this case: [1]. Very SAD."
                    },
                    {
                        "username": "czjnbb",
                        "content": "[@ybblkblt](/ybblkblt) If LC didn\\'t hide it during the contest..."
                    },
                    {
                        "username": "ybblkblt",
                        "content": "Me too!!! It would have been the first time I got the last question on the contest!!"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Fuck you 1"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "i wrote the code in n^2 but it got accepted,how?\\n"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "[@cartesPerforees](/cartesPerforees) oh,thanks for this,initially  i was hoping this solution would give tle and then i would have proceeded further with dsu, but it got accepted anyways"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "[@shivangi806](/shivangi806)  gcd of a number with itself is the number itself and we return false only if gcd with every other number is 1(except the number itself)"
                    },
                    {
                        "username": "shivangi806",
                        "content": "what is logic of putting nums[i]!=nums[j] as if it is equal also then there is no issue but it gives me wrong answer for 1 test case"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your code is not n^2. \nI guess you are checking all the multiples? Then you are checking every second numbers, then every third numbers, etc...\n$1/2+1/3+...1/n$ sums as $log(n)$. So your code is nlogn. I do assume that if an interviewr asks this question he will expect the complexity analysis of it tho, otherwise you're just walking into the right solution without knowing why"
                    },
                    {
                        "username": "divii",
                        "content": "` while (n % i == 0) n /= i;`\\nthis is where i lost :("
                    },
                    {
                        "username": "ujwalkv",
                        "content": "if I simply type run a testcase is passing , but when I click on submit the same testcase is giving a wrong answer"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "why testcase nums =[1] (tc917) will expected true ? \"determine if for every pair of indices i and j with i<j\" "
                    },
                    {
                        "username": "janis__",
                        "content": "The given condition states: \"determine if for every pair of indices ii and jj with i<ji<j\". When the list nums contains only one element (like in the testcase nums = [1]), there are no pairs of indices i,ji,j such that i<ji<j. Therefore, there\\'s no condition to violate and the result is True by default. In simpler terms, when there\\'s only one number, there are no other numbers to compare or connect to, so the requirements are inherently met. "
                    },
                    {
                        "username": "Getting_into_form",
                        "content": "Why is this solution giving TLE?\\n\\n```\\ntypedef vector<int> VI;\\ntypedef vector<VI> VVI;\\n\\nclass Solution {\\npublic:\\n    int spf[100000+1];\\n    unordered_map<int, int> primeToIndex;\\n    \\n    void calc(int maxNum){\\n        for(int i=1;i<=maxNum;i++) spf[i]=i;\\n\\n        int index = maxNum;\\n        for(int p = 2;p <= maxNum; p++){\\n            if(spf[p] != p) continue; \\n            \\n            primeToIndex[p] = index++;\\n            \\n            for(int j = 2*p;j <= maxNum;j += p){\\n                if(spf[j] == j) spf[j] = p;\\n            }\\n        }\\n    }\\n\\n    class DSU{\\n        private:\\n        VI parent;\\n        public:\\n        DSU(int n){\\n            for(int i=0;i<n;i++) parent.push_back(-1);\\n            //parent.resize(n, -1);\\n        }\\n        int find_(int x){\\n            if(parent[x] < 0) return x;\\n            // int p = find_(parent[x]);\\n            // parent[x] = p;\\n            parent[x] = find_(parent[x]);\\n            return parent[x];\\n        }\\n        void union_(int x, int y){\\n            int p1=find_(x), p2=find_(y);\\n            if(p1 != p2){\\n                parent[p1] += parent[p2];\\n                parent[p2] = p1;\\n            }\\n        }\\n    };\\n\\n    void factorize(int x, DSU &d, unordered_map<int, int> &m, int &index){\\n        cout<<x<<endl;\\n        while(x > 1){\\n            int p = spf[x];\\n            d.union_(m[p], index);\\n            while(x%p == 0){\\n                x /= p;\\n                //cout<<\"Y0\"<<endl;\\n            }\\n        }\\n    }\\n\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int maxNum = 100000;\\n        DSU d(2*maxNum+1);\\n\\n        int n = nums.size();\\n        calc(maxNum);\\n        \\n        for(int i=0;i<n;i++){\\n            factorize(nums[i], d, primeToIndex, i);\\n        }\\n        set<int> count;\\n        for(int i=0;i<n;i++){\\n            count.insert(d.find_(i));\\n        }\\n        return (int)count.size() == 1;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "janis__",
                        "content": "The solution is TLE due to inefficiencies in the calc function\\'s nested loop for prime factorization and the factorize function. To fix it please optimize prime factorization using a more efficient Sieve of Eratosthenes and Streamline the union-find operations in factorize."
                    },
                    {
                        "username": "Getting_into_form",
                        "content": "Testcases are being accepted in run window but giving TLE on submission."
                    }
                ]
            },
            {
                "id": 1907690,
                "content": [
                    {
                        "username": "Driver12",
                        "content": "Upvote if u thought that looking for all prime divisors for every number is too long for these constraints..."
                    },
                    {
                        "username": "rjanshuman",
                        "content": "i stored/duplicated the input in an arraylist and created a 2D arraylist which has group of arrays divisible by prime numbers onwards 2 such that 1st group is even no.s, 2nd is multiple of 3 (but not 2), third is multiple of 5 (but not 2& 3) and so on..\\n\\nlater if at least one non-coprime no is found among this subarrays, then these are merged and in the end if the final array has same length as nums then it means iterable else not.\\n\\nMy approach/code passes 916/925 tests. However, it says time limit exceeded when an input of 5566 elements of 99991, a prime number is given... which is logical seeing the non-optimality of my code...\\n\\nNow, thinking of optimizing....\\n"
                    },
                    {
                        "username": "Akarshippili",
                        "content": "For me it says: \\nTime Limit Exceeded\\n921 / 921 testcases passed\\n\\n@LeetCode what does it mean ?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hiding the testcase [1,1] during the contest was a nasty, nasty move."
                    },
                    {
                        "username": "cjcoax",
                        "content": "There is a special place in hell for who hid it during the contest!"
                    },
                    {
                        "username": "czjnbb",
                        "content": "I only failed on this case: [1]. Very SAD."
                    },
                    {
                        "username": "czjnbb",
                        "content": "[@ybblkblt](/ybblkblt) If LC didn\\'t hide it during the contest..."
                    },
                    {
                        "username": "ybblkblt",
                        "content": "Me too!!! It would have been the first time I got the last question on the contest!!"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Fuck you 1"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "i wrote the code in n^2 but it got accepted,how?\\n"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "[@cartesPerforees](/cartesPerforees) oh,thanks for this,initially  i was hoping this solution would give tle and then i would have proceeded further with dsu, but it got accepted anyways"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "[@shivangi806](/shivangi806)  gcd of a number with itself is the number itself and we return false only if gcd with every other number is 1(except the number itself)"
                    },
                    {
                        "username": "shivangi806",
                        "content": "what is logic of putting nums[i]!=nums[j] as if it is equal also then there is no issue but it gives me wrong answer for 1 test case"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your code is not n^2. \nI guess you are checking all the multiples? Then you are checking every second numbers, then every third numbers, etc...\n$1/2+1/3+...1/n$ sums as $log(n)$. So your code is nlogn. I do assume that if an interviewr asks this question he will expect the complexity analysis of it tho, otherwise you're just walking into the right solution without knowing why"
                    },
                    {
                        "username": "divii",
                        "content": "` while (n % i == 0) n /= i;`\\nthis is where i lost :("
                    },
                    {
                        "username": "ujwalkv",
                        "content": "if I simply type run a testcase is passing , but when I click on submit the same testcase is giving a wrong answer"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "why testcase nums =[1] (tc917) will expected true ? \"determine if for every pair of indices i and j with i<j\" "
                    },
                    {
                        "username": "janis__",
                        "content": "The given condition states: \"determine if for every pair of indices ii and jj with i<ji<j\". When the list nums contains only one element (like in the testcase nums = [1]), there are no pairs of indices i,ji,j such that i<ji<j. Therefore, there\\'s no condition to violate and the result is True by default. In simpler terms, when there\\'s only one number, there are no other numbers to compare or connect to, so the requirements are inherently met. "
                    },
                    {
                        "username": "Getting_into_form",
                        "content": "Why is this solution giving TLE?\\n\\n```\\ntypedef vector<int> VI;\\ntypedef vector<VI> VVI;\\n\\nclass Solution {\\npublic:\\n    int spf[100000+1];\\n    unordered_map<int, int> primeToIndex;\\n    \\n    void calc(int maxNum){\\n        for(int i=1;i<=maxNum;i++) spf[i]=i;\\n\\n        int index = maxNum;\\n        for(int p = 2;p <= maxNum; p++){\\n            if(spf[p] != p) continue; \\n            \\n            primeToIndex[p] = index++;\\n            \\n            for(int j = 2*p;j <= maxNum;j += p){\\n                if(spf[j] == j) spf[j] = p;\\n            }\\n        }\\n    }\\n\\n    class DSU{\\n        private:\\n        VI parent;\\n        public:\\n        DSU(int n){\\n            for(int i=0;i<n;i++) parent.push_back(-1);\\n            //parent.resize(n, -1);\\n        }\\n        int find_(int x){\\n            if(parent[x] < 0) return x;\\n            // int p = find_(parent[x]);\\n            // parent[x] = p;\\n            parent[x] = find_(parent[x]);\\n            return parent[x];\\n        }\\n        void union_(int x, int y){\\n            int p1=find_(x), p2=find_(y);\\n            if(p1 != p2){\\n                parent[p1] += parent[p2];\\n                parent[p2] = p1;\\n            }\\n        }\\n    };\\n\\n    void factorize(int x, DSU &d, unordered_map<int, int> &m, int &index){\\n        cout<<x<<endl;\\n        while(x > 1){\\n            int p = spf[x];\\n            d.union_(m[p], index);\\n            while(x%p == 0){\\n                x /= p;\\n                //cout<<\"Y0\"<<endl;\\n            }\\n        }\\n    }\\n\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int maxNum = 100000;\\n        DSU d(2*maxNum+1);\\n\\n        int n = nums.size();\\n        calc(maxNum);\\n        \\n        for(int i=0;i<n;i++){\\n            factorize(nums[i], d, primeToIndex, i);\\n        }\\n        set<int> count;\\n        for(int i=0;i<n;i++){\\n            count.insert(d.find_(i));\\n        }\\n        return (int)count.size() == 1;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "janis__",
                        "content": "The solution is TLE due to inefficiencies in the calc function\\'s nested loop for prime factorization and the factorize function. To fix it please optimize prime factorization using a more efficient Sieve of Eratosthenes and Streamline the union-find operations in factorize."
                    },
                    {
                        "username": "Getting_into_form",
                        "content": "Testcases are being accepted in run window but giving TLE on submission."
                    }
                ]
            },
            {
                "id": 1907596,
                "content": [
                    {
                        "username": "Driver12",
                        "content": "Upvote if u thought that looking for all prime divisors for every number is too long for these constraints..."
                    },
                    {
                        "username": "rjanshuman",
                        "content": "i stored/duplicated the input in an arraylist and created a 2D arraylist which has group of arrays divisible by prime numbers onwards 2 such that 1st group is even no.s, 2nd is multiple of 3 (but not 2), third is multiple of 5 (but not 2& 3) and so on..\\n\\nlater if at least one non-coprime no is found among this subarrays, then these are merged and in the end if the final array has same length as nums then it means iterable else not.\\n\\nMy approach/code passes 916/925 tests. However, it says time limit exceeded when an input of 5566 elements of 99991, a prime number is given... which is logical seeing the non-optimality of my code...\\n\\nNow, thinking of optimizing....\\n"
                    },
                    {
                        "username": "Akarshippili",
                        "content": "For me it says: \\nTime Limit Exceeded\\n921 / 921 testcases passed\\n\\n@LeetCode what does it mean ?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hiding the testcase [1,1] during the contest was a nasty, nasty move."
                    },
                    {
                        "username": "cjcoax",
                        "content": "There is a special place in hell for who hid it during the contest!"
                    },
                    {
                        "username": "czjnbb",
                        "content": "I only failed on this case: [1]. Very SAD."
                    },
                    {
                        "username": "czjnbb",
                        "content": "[@ybblkblt](/ybblkblt) If LC didn\\'t hide it during the contest..."
                    },
                    {
                        "username": "ybblkblt",
                        "content": "Me too!!! It would have been the first time I got the last question on the contest!!"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Fuck you 1"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "i wrote the code in n^2 but it got accepted,how?\\n"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "[@cartesPerforees](/cartesPerforees) oh,thanks for this,initially  i was hoping this solution would give tle and then i would have proceeded further with dsu, but it got accepted anyways"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "[@shivangi806](/shivangi806)  gcd of a number with itself is the number itself and we return false only if gcd with every other number is 1(except the number itself)"
                    },
                    {
                        "username": "shivangi806",
                        "content": "what is logic of putting nums[i]!=nums[j] as if it is equal also then there is no issue but it gives me wrong answer for 1 test case"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your code is not n^2. \nI guess you are checking all the multiples? Then you are checking every second numbers, then every third numbers, etc...\n$1/2+1/3+...1/n$ sums as $log(n)$. So your code is nlogn. I do assume that if an interviewr asks this question he will expect the complexity analysis of it tho, otherwise you're just walking into the right solution without knowing why"
                    },
                    {
                        "username": "divii",
                        "content": "` while (n % i == 0) n /= i;`\\nthis is where i lost :("
                    },
                    {
                        "username": "ujwalkv",
                        "content": "if I simply type run a testcase is passing , but when I click on submit the same testcase is giving a wrong answer"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "why testcase nums =[1] (tc917) will expected true ? \"determine if for every pair of indices i and j with i<j\" "
                    },
                    {
                        "username": "janis__",
                        "content": "The given condition states: \"determine if for every pair of indices ii and jj with i<ji<j\". When the list nums contains only one element (like in the testcase nums = [1]), there are no pairs of indices i,ji,j such that i<ji<j. Therefore, there\\'s no condition to violate and the result is True by default. In simpler terms, when there\\'s only one number, there are no other numbers to compare or connect to, so the requirements are inherently met. "
                    },
                    {
                        "username": "Getting_into_form",
                        "content": "Why is this solution giving TLE?\\n\\n```\\ntypedef vector<int> VI;\\ntypedef vector<VI> VVI;\\n\\nclass Solution {\\npublic:\\n    int spf[100000+1];\\n    unordered_map<int, int> primeToIndex;\\n    \\n    void calc(int maxNum){\\n        for(int i=1;i<=maxNum;i++) spf[i]=i;\\n\\n        int index = maxNum;\\n        for(int p = 2;p <= maxNum; p++){\\n            if(spf[p] != p) continue; \\n            \\n            primeToIndex[p] = index++;\\n            \\n            for(int j = 2*p;j <= maxNum;j += p){\\n                if(spf[j] == j) spf[j] = p;\\n            }\\n        }\\n    }\\n\\n    class DSU{\\n        private:\\n        VI parent;\\n        public:\\n        DSU(int n){\\n            for(int i=0;i<n;i++) parent.push_back(-1);\\n            //parent.resize(n, -1);\\n        }\\n        int find_(int x){\\n            if(parent[x] < 0) return x;\\n            // int p = find_(parent[x]);\\n            // parent[x] = p;\\n            parent[x] = find_(parent[x]);\\n            return parent[x];\\n        }\\n        void union_(int x, int y){\\n            int p1=find_(x), p2=find_(y);\\n            if(p1 != p2){\\n                parent[p1] += parent[p2];\\n                parent[p2] = p1;\\n            }\\n        }\\n    };\\n\\n    void factorize(int x, DSU &d, unordered_map<int, int> &m, int &index){\\n        cout<<x<<endl;\\n        while(x > 1){\\n            int p = spf[x];\\n            d.union_(m[p], index);\\n            while(x%p == 0){\\n                x /= p;\\n                //cout<<\"Y0\"<<endl;\\n            }\\n        }\\n    }\\n\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int maxNum = 100000;\\n        DSU d(2*maxNum+1);\\n\\n        int n = nums.size();\\n        calc(maxNum);\\n        \\n        for(int i=0;i<n;i++){\\n            factorize(nums[i], d, primeToIndex, i);\\n        }\\n        set<int> count;\\n        for(int i=0;i<n;i++){\\n            count.insert(d.find_(i));\\n        }\\n        return (int)count.size() == 1;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "janis__",
                        "content": "The solution is TLE due to inefficiencies in the calc function\\'s nested loop for prime factorization and the factorize function. To fix it please optimize prime factorization using a more efficient Sieve of Eratosthenes and Streamline the union-find operations in factorize."
                    },
                    {
                        "username": "Getting_into_form",
                        "content": "Testcases are being accepted in run window but giving TLE on submission."
                    }
                ]
            },
            {
                "id": 1929937,
                "content": [
                    {
                        "username": "Driver12",
                        "content": "Upvote if u thought that looking for all prime divisors for every number is too long for these constraints..."
                    },
                    {
                        "username": "rjanshuman",
                        "content": "i stored/duplicated the input in an arraylist and created a 2D arraylist which has group of arrays divisible by prime numbers onwards 2 such that 1st group is even no.s, 2nd is multiple of 3 (but not 2), third is multiple of 5 (but not 2& 3) and so on..\\n\\nlater if at least one non-coprime no is found among this subarrays, then these are merged and in the end if the final array has same length as nums then it means iterable else not.\\n\\nMy approach/code passes 916/925 tests. However, it says time limit exceeded when an input of 5566 elements of 99991, a prime number is given... which is logical seeing the non-optimality of my code...\\n\\nNow, thinking of optimizing....\\n"
                    },
                    {
                        "username": "Akarshippili",
                        "content": "For me it says: \\nTime Limit Exceeded\\n921 / 921 testcases passed\\n\\n@LeetCode what does it mean ?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hiding the testcase [1,1] during the contest was a nasty, nasty move."
                    },
                    {
                        "username": "cjcoax",
                        "content": "There is a special place in hell for who hid it during the contest!"
                    },
                    {
                        "username": "czjnbb",
                        "content": "I only failed on this case: [1]. Very SAD."
                    },
                    {
                        "username": "czjnbb",
                        "content": "[@ybblkblt](/ybblkblt) If LC didn\\'t hide it during the contest..."
                    },
                    {
                        "username": "ybblkblt",
                        "content": "Me too!!! It would have been the first time I got the last question on the contest!!"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Fuck you 1"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "i wrote the code in n^2 but it got accepted,how?\\n"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "[@cartesPerforees](/cartesPerforees) oh,thanks for this,initially  i was hoping this solution would give tle and then i would have proceeded further with dsu, but it got accepted anyways"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "[@shivangi806](/shivangi806)  gcd of a number with itself is the number itself and we return false only if gcd with every other number is 1(except the number itself)"
                    },
                    {
                        "username": "shivangi806",
                        "content": "what is logic of putting nums[i]!=nums[j] as if it is equal also then there is no issue but it gives me wrong answer for 1 test case"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your code is not n^2. \nI guess you are checking all the multiples? Then you are checking every second numbers, then every third numbers, etc...\n$1/2+1/3+...1/n$ sums as $log(n)$. So your code is nlogn. I do assume that if an interviewr asks this question he will expect the complexity analysis of it tho, otherwise you're just walking into the right solution without knowing why"
                    },
                    {
                        "username": "divii",
                        "content": "` while (n % i == 0) n /= i;`\\nthis is where i lost :("
                    },
                    {
                        "username": "ujwalkv",
                        "content": "if I simply type run a testcase is passing , but when I click on submit the same testcase is giving a wrong answer"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "why testcase nums =[1] (tc917) will expected true ? \"determine if for every pair of indices i and j with i<j\" "
                    },
                    {
                        "username": "janis__",
                        "content": "The given condition states: \"determine if for every pair of indices ii and jj with i<ji<j\". When the list nums contains only one element (like in the testcase nums = [1]), there are no pairs of indices i,ji,j such that i<ji<j. Therefore, there\\'s no condition to violate and the result is True by default. In simpler terms, when there\\'s only one number, there are no other numbers to compare or connect to, so the requirements are inherently met. "
                    },
                    {
                        "username": "Getting_into_form",
                        "content": "Why is this solution giving TLE?\\n\\n```\\ntypedef vector<int> VI;\\ntypedef vector<VI> VVI;\\n\\nclass Solution {\\npublic:\\n    int spf[100000+1];\\n    unordered_map<int, int> primeToIndex;\\n    \\n    void calc(int maxNum){\\n        for(int i=1;i<=maxNum;i++) spf[i]=i;\\n\\n        int index = maxNum;\\n        for(int p = 2;p <= maxNum; p++){\\n            if(spf[p] != p) continue; \\n            \\n            primeToIndex[p] = index++;\\n            \\n            for(int j = 2*p;j <= maxNum;j += p){\\n                if(spf[j] == j) spf[j] = p;\\n            }\\n        }\\n    }\\n\\n    class DSU{\\n        private:\\n        VI parent;\\n        public:\\n        DSU(int n){\\n            for(int i=0;i<n;i++) parent.push_back(-1);\\n            //parent.resize(n, -1);\\n        }\\n        int find_(int x){\\n            if(parent[x] < 0) return x;\\n            // int p = find_(parent[x]);\\n            // parent[x] = p;\\n            parent[x] = find_(parent[x]);\\n            return parent[x];\\n        }\\n        void union_(int x, int y){\\n            int p1=find_(x), p2=find_(y);\\n            if(p1 != p2){\\n                parent[p1] += parent[p2];\\n                parent[p2] = p1;\\n            }\\n        }\\n    };\\n\\n    void factorize(int x, DSU &d, unordered_map<int, int> &m, int &index){\\n        cout<<x<<endl;\\n        while(x > 1){\\n            int p = spf[x];\\n            d.union_(m[p], index);\\n            while(x%p == 0){\\n                x /= p;\\n                //cout<<\"Y0\"<<endl;\\n            }\\n        }\\n    }\\n\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int maxNum = 100000;\\n        DSU d(2*maxNum+1);\\n\\n        int n = nums.size();\\n        calc(maxNum);\\n        \\n        for(int i=0;i<n;i++){\\n            factorize(nums[i], d, primeToIndex, i);\\n        }\\n        set<int> count;\\n        for(int i=0;i<n;i++){\\n            count.insert(d.find_(i));\\n        }\\n        return (int)count.size() == 1;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "janis__",
                        "content": "The solution is TLE due to inefficiencies in the calc function\\'s nested loop for prime factorization and the factorize function. To fix it please optimize prime factorization using a more efficient Sieve of Eratosthenes and Streamline the union-find operations in factorize."
                    },
                    {
                        "username": "Getting_into_form",
                        "content": "Testcases are being accepted in run window but giving TLE on submission."
                    }
                ]
            },
            {
                "id": 1919107,
                "content": [
                    {
                        "username": "Driver12",
                        "content": "Upvote if u thought that looking for all prime divisors for every number is too long for these constraints..."
                    },
                    {
                        "username": "rjanshuman",
                        "content": "i stored/duplicated the input in an arraylist and created a 2D arraylist which has group of arrays divisible by prime numbers onwards 2 such that 1st group is even no.s, 2nd is multiple of 3 (but not 2), third is multiple of 5 (but not 2& 3) and so on..\\n\\nlater if at least one non-coprime no is found among this subarrays, then these are merged and in the end if the final array has same length as nums then it means iterable else not.\\n\\nMy approach/code passes 916/925 tests. However, it says time limit exceeded when an input of 5566 elements of 99991, a prime number is given... which is logical seeing the non-optimality of my code...\\n\\nNow, thinking of optimizing....\\n"
                    },
                    {
                        "username": "Akarshippili",
                        "content": "For me it says: \\nTime Limit Exceeded\\n921 / 921 testcases passed\\n\\n@LeetCode what does it mean ?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hiding the testcase [1,1] during the contest was a nasty, nasty move."
                    },
                    {
                        "username": "cjcoax",
                        "content": "There is a special place in hell for who hid it during the contest!"
                    },
                    {
                        "username": "czjnbb",
                        "content": "I only failed on this case: [1]. Very SAD."
                    },
                    {
                        "username": "czjnbb",
                        "content": "[@ybblkblt](/ybblkblt) If LC didn\\'t hide it during the contest..."
                    },
                    {
                        "username": "ybblkblt",
                        "content": "Me too!!! It would have been the first time I got the last question on the contest!!"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Fuck you 1"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "i wrote the code in n^2 but it got accepted,how?\\n"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "[@cartesPerforees](/cartesPerforees) oh,thanks for this,initially  i was hoping this solution would give tle and then i would have proceeded further with dsu, but it got accepted anyways"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "[@shivangi806](/shivangi806)  gcd of a number with itself is the number itself and we return false only if gcd with every other number is 1(except the number itself)"
                    },
                    {
                        "username": "shivangi806",
                        "content": "what is logic of putting nums[i]!=nums[j] as if it is equal also then there is no issue but it gives me wrong answer for 1 test case"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your code is not n^2. \nI guess you are checking all the multiples? Then you are checking every second numbers, then every third numbers, etc...\n$1/2+1/3+...1/n$ sums as $log(n)$. So your code is nlogn. I do assume that if an interviewr asks this question he will expect the complexity analysis of it tho, otherwise you're just walking into the right solution without knowing why"
                    },
                    {
                        "username": "divii",
                        "content": "` while (n % i == 0) n /= i;`\\nthis is where i lost :("
                    },
                    {
                        "username": "ujwalkv",
                        "content": "if I simply type run a testcase is passing , but when I click on submit the same testcase is giving a wrong answer"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "why testcase nums =[1] (tc917) will expected true ? \"determine if for every pair of indices i and j with i<j\" "
                    },
                    {
                        "username": "janis__",
                        "content": "The given condition states: \"determine if for every pair of indices ii and jj with i<ji<j\". When the list nums contains only one element (like in the testcase nums = [1]), there are no pairs of indices i,ji,j such that i<ji<j. Therefore, there\\'s no condition to violate and the result is True by default. In simpler terms, when there\\'s only one number, there are no other numbers to compare or connect to, so the requirements are inherently met. "
                    },
                    {
                        "username": "Getting_into_form",
                        "content": "Why is this solution giving TLE?\\n\\n```\\ntypedef vector<int> VI;\\ntypedef vector<VI> VVI;\\n\\nclass Solution {\\npublic:\\n    int spf[100000+1];\\n    unordered_map<int, int> primeToIndex;\\n    \\n    void calc(int maxNum){\\n        for(int i=1;i<=maxNum;i++) spf[i]=i;\\n\\n        int index = maxNum;\\n        for(int p = 2;p <= maxNum; p++){\\n            if(spf[p] != p) continue; \\n            \\n            primeToIndex[p] = index++;\\n            \\n            for(int j = 2*p;j <= maxNum;j += p){\\n                if(spf[j] == j) spf[j] = p;\\n            }\\n        }\\n    }\\n\\n    class DSU{\\n        private:\\n        VI parent;\\n        public:\\n        DSU(int n){\\n            for(int i=0;i<n;i++) parent.push_back(-1);\\n            //parent.resize(n, -1);\\n        }\\n        int find_(int x){\\n            if(parent[x] < 0) return x;\\n            // int p = find_(parent[x]);\\n            // parent[x] = p;\\n            parent[x] = find_(parent[x]);\\n            return parent[x];\\n        }\\n        void union_(int x, int y){\\n            int p1=find_(x), p2=find_(y);\\n            if(p1 != p2){\\n                parent[p1] += parent[p2];\\n                parent[p2] = p1;\\n            }\\n        }\\n    };\\n\\n    void factorize(int x, DSU &d, unordered_map<int, int> &m, int &index){\\n        cout<<x<<endl;\\n        while(x > 1){\\n            int p = spf[x];\\n            d.union_(m[p], index);\\n            while(x%p == 0){\\n                x /= p;\\n                //cout<<\"Y0\"<<endl;\\n            }\\n        }\\n    }\\n\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int maxNum = 100000;\\n        DSU d(2*maxNum+1);\\n\\n        int n = nums.size();\\n        calc(maxNum);\\n        \\n        for(int i=0;i<n;i++){\\n            factorize(nums[i], d, primeToIndex, i);\\n        }\\n        set<int> count;\\n        for(int i=0;i<n;i++){\\n            count.insert(d.find_(i));\\n        }\\n        return (int)count.size() == 1;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "janis__",
                        "content": "The solution is TLE due to inefficiencies in the calc function\\'s nested loop for prime factorization and the factorize function. To fix it please optimize prime factorization using a more efficient Sieve of Eratosthenes and Streamline the union-find operations in factorize."
                    },
                    {
                        "username": "Getting_into_form",
                        "content": "Testcases are being accepted in run window but giving TLE on submission."
                    }
                ]
            },
            {
                "id": 1913517,
                "content": [
                    {
                        "username": "Driver12",
                        "content": "Upvote if u thought that looking for all prime divisors for every number is too long for these constraints..."
                    },
                    {
                        "username": "rjanshuman",
                        "content": "i stored/duplicated the input in an arraylist and created a 2D arraylist which has group of arrays divisible by prime numbers onwards 2 such that 1st group is even no.s, 2nd is multiple of 3 (but not 2), third is multiple of 5 (but not 2& 3) and so on..\\n\\nlater if at least one non-coprime no is found among this subarrays, then these are merged and in the end if the final array has same length as nums then it means iterable else not.\\n\\nMy approach/code passes 916/925 tests. However, it says time limit exceeded when an input of 5566 elements of 99991, a prime number is given... which is logical seeing the non-optimality of my code...\\n\\nNow, thinking of optimizing....\\n"
                    },
                    {
                        "username": "Akarshippili",
                        "content": "For me it says: \\nTime Limit Exceeded\\n921 / 921 testcases passed\\n\\n@LeetCode what does it mean ?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hiding the testcase [1,1] during the contest was a nasty, nasty move."
                    },
                    {
                        "username": "cjcoax",
                        "content": "There is a special place in hell for who hid it during the contest!"
                    },
                    {
                        "username": "czjnbb",
                        "content": "I only failed on this case: [1]. Very SAD."
                    },
                    {
                        "username": "czjnbb",
                        "content": "[@ybblkblt](/ybblkblt) If LC didn\\'t hide it during the contest..."
                    },
                    {
                        "username": "ybblkblt",
                        "content": "Me too!!! It would have been the first time I got the last question on the contest!!"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Fuck you 1"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "i wrote the code in n^2 but it got accepted,how?\\n"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "[@cartesPerforees](/cartesPerforees) oh,thanks for this,initially  i was hoping this solution would give tle and then i would have proceeded further with dsu, but it got accepted anyways"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "[@shivangi806](/shivangi806)  gcd of a number with itself is the number itself and we return false only if gcd with every other number is 1(except the number itself)"
                    },
                    {
                        "username": "shivangi806",
                        "content": "what is logic of putting nums[i]!=nums[j] as if it is equal also then there is no issue but it gives me wrong answer for 1 test case"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your code is not n^2. \nI guess you are checking all the multiples? Then you are checking every second numbers, then every third numbers, etc...\n$1/2+1/3+...1/n$ sums as $log(n)$. So your code is nlogn. I do assume that if an interviewr asks this question he will expect the complexity analysis of it tho, otherwise you're just walking into the right solution without knowing why"
                    },
                    {
                        "username": "divii",
                        "content": "` while (n % i == 0) n /= i;`\\nthis is where i lost :("
                    },
                    {
                        "username": "ujwalkv",
                        "content": "if I simply type run a testcase is passing , but when I click on submit the same testcase is giving a wrong answer"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "why testcase nums =[1] (tc917) will expected true ? \"determine if for every pair of indices i and j with i<j\" "
                    },
                    {
                        "username": "janis__",
                        "content": "The given condition states: \"determine if for every pair of indices ii and jj with i<ji<j\". When the list nums contains only one element (like in the testcase nums = [1]), there are no pairs of indices i,ji,j such that i<ji<j. Therefore, there\\'s no condition to violate and the result is True by default. In simpler terms, when there\\'s only one number, there are no other numbers to compare or connect to, so the requirements are inherently met. "
                    },
                    {
                        "username": "Getting_into_form",
                        "content": "Why is this solution giving TLE?\\n\\n```\\ntypedef vector<int> VI;\\ntypedef vector<VI> VVI;\\n\\nclass Solution {\\npublic:\\n    int spf[100000+1];\\n    unordered_map<int, int> primeToIndex;\\n    \\n    void calc(int maxNum){\\n        for(int i=1;i<=maxNum;i++) spf[i]=i;\\n\\n        int index = maxNum;\\n        for(int p = 2;p <= maxNum; p++){\\n            if(spf[p] != p) continue; \\n            \\n            primeToIndex[p] = index++;\\n            \\n            for(int j = 2*p;j <= maxNum;j += p){\\n                if(spf[j] == j) spf[j] = p;\\n            }\\n        }\\n    }\\n\\n    class DSU{\\n        private:\\n        VI parent;\\n        public:\\n        DSU(int n){\\n            for(int i=0;i<n;i++) parent.push_back(-1);\\n            //parent.resize(n, -1);\\n        }\\n        int find_(int x){\\n            if(parent[x] < 0) return x;\\n            // int p = find_(parent[x]);\\n            // parent[x] = p;\\n            parent[x] = find_(parent[x]);\\n            return parent[x];\\n        }\\n        void union_(int x, int y){\\n            int p1=find_(x), p2=find_(y);\\n            if(p1 != p2){\\n                parent[p1] += parent[p2];\\n                parent[p2] = p1;\\n            }\\n        }\\n    };\\n\\n    void factorize(int x, DSU &d, unordered_map<int, int> &m, int &index){\\n        cout<<x<<endl;\\n        while(x > 1){\\n            int p = spf[x];\\n            d.union_(m[p], index);\\n            while(x%p == 0){\\n                x /= p;\\n                //cout<<\"Y0\"<<endl;\\n            }\\n        }\\n    }\\n\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int maxNum = 100000;\\n        DSU d(2*maxNum+1);\\n\\n        int n = nums.size();\\n        calc(maxNum);\\n        \\n        for(int i=0;i<n;i++){\\n            factorize(nums[i], d, primeToIndex, i);\\n        }\\n        set<int> count;\\n        for(int i=0;i<n;i++){\\n            count.insert(d.find_(i));\\n        }\\n        return (int)count.size() == 1;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "janis__",
                        "content": "The solution is TLE due to inefficiencies in the calc function\\'s nested loop for prime factorization and the factorize function. To fix it please optimize prime factorization using a more efficient Sieve of Eratosthenes and Streamline the union-find operations in factorize."
                    },
                    {
                        "username": "Getting_into_form",
                        "content": "Testcases are being accepted in run window but giving TLE on submission."
                    }
                ]
            },
            {
                "id": 1907464,
                "content": [
                    {
                        "username": "Driver12",
                        "content": "Upvote if u thought that looking for all prime divisors for every number is too long for these constraints..."
                    },
                    {
                        "username": "rjanshuman",
                        "content": "i stored/duplicated the input in an arraylist and created a 2D arraylist which has group of arrays divisible by prime numbers onwards 2 such that 1st group is even no.s, 2nd is multiple of 3 (but not 2), third is multiple of 5 (but not 2& 3) and so on..\\n\\nlater if at least one non-coprime no is found among this subarrays, then these are merged and in the end if the final array has same length as nums then it means iterable else not.\\n\\nMy approach/code passes 916/925 tests. However, it says time limit exceeded when an input of 5566 elements of 99991, a prime number is given... which is logical seeing the non-optimality of my code...\\n\\nNow, thinking of optimizing....\\n"
                    },
                    {
                        "username": "Akarshippili",
                        "content": "For me it says: \\nTime Limit Exceeded\\n921 / 921 testcases passed\\n\\n@LeetCode what does it mean ?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hiding the testcase [1,1] during the contest was a nasty, nasty move."
                    },
                    {
                        "username": "cjcoax",
                        "content": "There is a special place in hell for who hid it during the contest!"
                    },
                    {
                        "username": "czjnbb",
                        "content": "I only failed on this case: [1]. Very SAD."
                    },
                    {
                        "username": "czjnbb",
                        "content": "[@ybblkblt](/ybblkblt) If LC didn\\'t hide it during the contest..."
                    },
                    {
                        "username": "ybblkblt",
                        "content": "Me too!!! It would have been the first time I got the last question on the contest!!"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Fuck you 1"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "i wrote the code in n^2 but it got accepted,how?\\n"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "[@cartesPerforees](/cartesPerforees) oh,thanks for this,initially  i was hoping this solution would give tle and then i would have proceeded further with dsu, but it got accepted anyways"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "[@shivangi806](/shivangi806)  gcd of a number with itself is the number itself and we return false only if gcd with every other number is 1(except the number itself)"
                    },
                    {
                        "username": "shivangi806",
                        "content": "what is logic of putting nums[i]!=nums[j] as if it is equal also then there is no issue but it gives me wrong answer for 1 test case"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your code is not n^2. \nI guess you are checking all the multiples? Then you are checking every second numbers, then every third numbers, etc...\n$1/2+1/3+...1/n$ sums as $log(n)$. So your code is nlogn. I do assume that if an interviewr asks this question he will expect the complexity analysis of it tho, otherwise you're just walking into the right solution without knowing why"
                    },
                    {
                        "username": "divii",
                        "content": "` while (n % i == 0) n /= i;`\\nthis is where i lost :("
                    },
                    {
                        "username": "ujwalkv",
                        "content": "if I simply type run a testcase is passing , but when I click on submit the same testcase is giving a wrong answer"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "why testcase nums =[1] (tc917) will expected true ? \"determine if for every pair of indices i and j with i<j\" "
                    },
                    {
                        "username": "janis__",
                        "content": "The given condition states: \"determine if for every pair of indices ii and jj with i<ji<j\". When the list nums contains only one element (like in the testcase nums = [1]), there are no pairs of indices i,ji,j such that i<ji<j. Therefore, there\\'s no condition to violate and the result is True by default. In simpler terms, when there\\'s only one number, there are no other numbers to compare or connect to, so the requirements are inherently met. "
                    },
                    {
                        "username": "Getting_into_form",
                        "content": "Why is this solution giving TLE?\\n\\n```\\ntypedef vector<int> VI;\\ntypedef vector<VI> VVI;\\n\\nclass Solution {\\npublic:\\n    int spf[100000+1];\\n    unordered_map<int, int> primeToIndex;\\n    \\n    void calc(int maxNum){\\n        for(int i=1;i<=maxNum;i++) spf[i]=i;\\n\\n        int index = maxNum;\\n        for(int p = 2;p <= maxNum; p++){\\n            if(spf[p] != p) continue; \\n            \\n            primeToIndex[p] = index++;\\n            \\n            for(int j = 2*p;j <= maxNum;j += p){\\n                if(spf[j] == j) spf[j] = p;\\n            }\\n        }\\n    }\\n\\n    class DSU{\\n        private:\\n        VI parent;\\n        public:\\n        DSU(int n){\\n            for(int i=0;i<n;i++) parent.push_back(-1);\\n            //parent.resize(n, -1);\\n        }\\n        int find_(int x){\\n            if(parent[x] < 0) return x;\\n            // int p = find_(parent[x]);\\n            // parent[x] = p;\\n            parent[x] = find_(parent[x]);\\n            return parent[x];\\n        }\\n        void union_(int x, int y){\\n            int p1=find_(x), p2=find_(y);\\n            if(p1 != p2){\\n                parent[p1] += parent[p2];\\n                parent[p2] = p1;\\n            }\\n        }\\n    };\\n\\n    void factorize(int x, DSU &d, unordered_map<int, int> &m, int &index){\\n        cout<<x<<endl;\\n        while(x > 1){\\n            int p = spf[x];\\n            d.union_(m[p], index);\\n            while(x%p == 0){\\n                x /= p;\\n                //cout<<\"Y0\"<<endl;\\n            }\\n        }\\n    }\\n\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int maxNum = 100000;\\n        DSU d(2*maxNum+1);\\n\\n        int n = nums.size();\\n        calc(maxNum);\\n        \\n        for(int i=0;i<n;i++){\\n            factorize(nums[i], d, primeToIndex, i);\\n        }\\n        set<int> count;\\n        for(int i=0;i<n;i++){\\n            count.insert(d.find_(i));\\n        }\\n        return (int)count.size() == 1;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "janis__",
                        "content": "The solution is TLE due to inefficiencies in the calc function\\'s nested loop for prime factorization and the factorize function. To fix it please optimize prime factorization using a more efficient Sieve of Eratosthenes and Streamline the union-find operations in factorize."
                    },
                    {
                        "username": "Getting_into_form",
                        "content": "Testcases are being accepted in run window but giving TLE on submission."
                    }
                ]
            },
            {
                "id": 1907639,
                "content": [
                    {
                        "username": "Driver12",
                        "content": "Upvote if u thought that looking for all prime divisors for every number is too long for these constraints..."
                    },
                    {
                        "username": "rjanshuman",
                        "content": "i stored/duplicated the input in an arraylist and created a 2D arraylist which has group of arrays divisible by prime numbers onwards 2 such that 1st group is even no.s, 2nd is multiple of 3 (but not 2), third is multiple of 5 (but not 2& 3) and so on..\\n\\nlater if at least one non-coprime no is found among this subarrays, then these are merged and in the end if the final array has same length as nums then it means iterable else not.\\n\\nMy approach/code passes 916/925 tests. However, it says time limit exceeded when an input of 5566 elements of 99991, a prime number is given... which is logical seeing the non-optimality of my code...\\n\\nNow, thinking of optimizing....\\n"
                    },
                    {
                        "username": "Akarshippili",
                        "content": "For me it says: \\nTime Limit Exceeded\\n921 / 921 testcases passed\\n\\n@LeetCode what does it mean ?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hiding the testcase [1,1] during the contest was a nasty, nasty move."
                    },
                    {
                        "username": "cjcoax",
                        "content": "There is a special place in hell for who hid it during the contest!"
                    },
                    {
                        "username": "czjnbb",
                        "content": "I only failed on this case: [1]. Very SAD."
                    },
                    {
                        "username": "czjnbb",
                        "content": "[@ybblkblt](/ybblkblt) If LC didn\\'t hide it during the contest..."
                    },
                    {
                        "username": "ybblkblt",
                        "content": "Me too!!! It would have been the first time I got the last question on the contest!!"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Fuck you 1"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "i wrote the code in n^2 but it got accepted,how?\\n"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "[@cartesPerforees](/cartesPerforees) oh,thanks for this,initially  i was hoping this solution would give tle and then i would have proceeded further with dsu, but it got accepted anyways"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "[@shivangi806](/shivangi806)  gcd of a number with itself is the number itself and we return false only if gcd with every other number is 1(except the number itself)"
                    },
                    {
                        "username": "shivangi806",
                        "content": "what is logic of putting nums[i]!=nums[j] as if it is equal also then there is no issue but it gives me wrong answer for 1 test case"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your code is not n^2. \nI guess you are checking all the multiples? Then you are checking every second numbers, then every third numbers, etc...\n$1/2+1/3+...1/n$ sums as $log(n)$. So your code is nlogn. I do assume that if an interviewr asks this question he will expect the complexity analysis of it tho, otherwise you're just walking into the right solution without knowing why"
                    },
                    {
                        "username": "divii",
                        "content": "` while (n % i == 0) n /= i;`\\nthis is where i lost :("
                    },
                    {
                        "username": "ujwalkv",
                        "content": "if I simply type run a testcase is passing , but when I click on submit the same testcase is giving a wrong answer"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "why testcase nums =[1] (tc917) will expected true ? \"determine if for every pair of indices i and j with i<j\" "
                    },
                    {
                        "username": "janis__",
                        "content": "The given condition states: \"determine if for every pair of indices ii and jj with i<ji<j\". When the list nums contains only one element (like in the testcase nums = [1]), there are no pairs of indices i,ji,j such that i<ji<j. Therefore, there\\'s no condition to violate and the result is True by default. In simpler terms, when there\\'s only one number, there are no other numbers to compare or connect to, so the requirements are inherently met. "
                    },
                    {
                        "username": "Getting_into_form",
                        "content": "Why is this solution giving TLE?\\n\\n```\\ntypedef vector<int> VI;\\ntypedef vector<VI> VVI;\\n\\nclass Solution {\\npublic:\\n    int spf[100000+1];\\n    unordered_map<int, int> primeToIndex;\\n    \\n    void calc(int maxNum){\\n        for(int i=1;i<=maxNum;i++) spf[i]=i;\\n\\n        int index = maxNum;\\n        for(int p = 2;p <= maxNum; p++){\\n            if(spf[p] != p) continue; \\n            \\n            primeToIndex[p] = index++;\\n            \\n            for(int j = 2*p;j <= maxNum;j += p){\\n                if(spf[j] == j) spf[j] = p;\\n            }\\n        }\\n    }\\n\\n    class DSU{\\n        private:\\n        VI parent;\\n        public:\\n        DSU(int n){\\n            for(int i=0;i<n;i++) parent.push_back(-1);\\n            //parent.resize(n, -1);\\n        }\\n        int find_(int x){\\n            if(parent[x] < 0) return x;\\n            // int p = find_(parent[x]);\\n            // parent[x] = p;\\n            parent[x] = find_(parent[x]);\\n            return parent[x];\\n        }\\n        void union_(int x, int y){\\n            int p1=find_(x), p2=find_(y);\\n            if(p1 != p2){\\n                parent[p1] += parent[p2];\\n                parent[p2] = p1;\\n            }\\n        }\\n    };\\n\\n    void factorize(int x, DSU &d, unordered_map<int, int> &m, int &index){\\n        cout<<x<<endl;\\n        while(x > 1){\\n            int p = spf[x];\\n            d.union_(m[p], index);\\n            while(x%p == 0){\\n                x /= p;\\n                //cout<<\"Y0\"<<endl;\\n            }\\n        }\\n    }\\n\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int maxNum = 100000;\\n        DSU d(2*maxNum+1);\\n\\n        int n = nums.size();\\n        calc(maxNum);\\n        \\n        for(int i=0;i<n;i++){\\n            factorize(nums[i], d, primeToIndex, i);\\n        }\\n        set<int> count;\\n        for(int i=0;i<n;i++){\\n            count.insert(d.find_(i));\\n        }\\n        return (int)count.size() == 1;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "janis__",
                        "content": "The solution is TLE due to inefficiencies in the calc function\\'s nested loop for prime factorization and the factorize function. To fix it please optimize prime factorization using a more efficient Sieve of Eratosthenes and Streamline the union-find operations in factorize."
                    },
                    {
                        "username": "Getting_into_form",
                        "content": "Testcases are being accepted in run window but giving TLE on submission."
                    }
                ]
            },
            {
                "id": 1907538,
                "content": [
                    {
                        "username": "Driver12",
                        "content": "Upvote if u thought that looking for all prime divisors for every number is too long for these constraints..."
                    },
                    {
                        "username": "rjanshuman",
                        "content": "i stored/duplicated the input in an arraylist and created a 2D arraylist which has group of arrays divisible by prime numbers onwards 2 such that 1st group is even no.s, 2nd is multiple of 3 (but not 2), third is multiple of 5 (but not 2& 3) and so on..\\n\\nlater if at least one non-coprime no is found among this subarrays, then these are merged and in the end if the final array has same length as nums then it means iterable else not.\\n\\nMy approach/code passes 916/925 tests. However, it says time limit exceeded when an input of 5566 elements of 99991, a prime number is given... which is logical seeing the non-optimality of my code...\\n\\nNow, thinking of optimizing....\\n"
                    },
                    {
                        "username": "Akarshippili",
                        "content": "For me it says: \\nTime Limit Exceeded\\n921 / 921 testcases passed\\n\\n@LeetCode what does it mean ?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hiding the testcase [1,1] during the contest was a nasty, nasty move."
                    },
                    {
                        "username": "cjcoax",
                        "content": "There is a special place in hell for who hid it during the contest!"
                    },
                    {
                        "username": "czjnbb",
                        "content": "I only failed on this case: [1]. Very SAD."
                    },
                    {
                        "username": "czjnbb",
                        "content": "[@ybblkblt](/ybblkblt) If LC didn\\'t hide it during the contest..."
                    },
                    {
                        "username": "ybblkblt",
                        "content": "Me too!!! It would have been the first time I got the last question on the contest!!"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Fuck you 1"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "i wrote the code in n^2 but it got accepted,how?\\n"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "[@cartesPerforees](/cartesPerforees) oh,thanks for this,initially  i was hoping this solution would give tle and then i would have proceeded further with dsu, but it got accepted anyways"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "[@shivangi806](/shivangi806)  gcd of a number with itself is the number itself and we return false only if gcd with every other number is 1(except the number itself)"
                    },
                    {
                        "username": "shivangi806",
                        "content": "what is logic of putting nums[i]!=nums[j] as if it is equal also then there is no issue but it gives me wrong answer for 1 test case"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your code is not n^2. \nI guess you are checking all the multiples? Then you are checking every second numbers, then every third numbers, etc...\n$1/2+1/3+...1/n$ sums as $log(n)$. So your code is nlogn. I do assume that if an interviewr asks this question he will expect the complexity analysis of it tho, otherwise you're just walking into the right solution without knowing why"
                    },
                    {
                        "username": "divii",
                        "content": "` while (n % i == 0) n /= i;`\\nthis is where i lost :("
                    },
                    {
                        "username": "ujwalkv",
                        "content": "if I simply type run a testcase is passing , but when I click on submit the same testcase is giving a wrong answer"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "why testcase nums =[1] (tc917) will expected true ? \"determine if for every pair of indices i and j with i<j\" "
                    },
                    {
                        "username": "janis__",
                        "content": "The given condition states: \"determine if for every pair of indices ii and jj with i<ji<j\". When the list nums contains only one element (like in the testcase nums = [1]), there are no pairs of indices i,ji,j such that i<ji<j. Therefore, there\\'s no condition to violate and the result is True by default. In simpler terms, when there\\'s only one number, there are no other numbers to compare or connect to, so the requirements are inherently met. "
                    },
                    {
                        "username": "Getting_into_form",
                        "content": "Why is this solution giving TLE?\\n\\n```\\ntypedef vector<int> VI;\\ntypedef vector<VI> VVI;\\n\\nclass Solution {\\npublic:\\n    int spf[100000+1];\\n    unordered_map<int, int> primeToIndex;\\n    \\n    void calc(int maxNum){\\n        for(int i=1;i<=maxNum;i++) spf[i]=i;\\n\\n        int index = maxNum;\\n        for(int p = 2;p <= maxNum; p++){\\n            if(spf[p] != p) continue; \\n            \\n            primeToIndex[p] = index++;\\n            \\n            for(int j = 2*p;j <= maxNum;j += p){\\n                if(spf[j] == j) spf[j] = p;\\n            }\\n        }\\n    }\\n\\n    class DSU{\\n        private:\\n        VI parent;\\n        public:\\n        DSU(int n){\\n            for(int i=0;i<n;i++) parent.push_back(-1);\\n            //parent.resize(n, -1);\\n        }\\n        int find_(int x){\\n            if(parent[x] < 0) return x;\\n            // int p = find_(parent[x]);\\n            // parent[x] = p;\\n            parent[x] = find_(parent[x]);\\n            return parent[x];\\n        }\\n        void union_(int x, int y){\\n            int p1=find_(x), p2=find_(y);\\n            if(p1 != p2){\\n                parent[p1] += parent[p2];\\n                parent[p2] = p1;\\n            }\\n        }\\n    };\\n\\n    void factorize(int x, DSU &d, unordered_map<int, int> &m, int &index){\\n        cout<<x<<endl;\\n        while(x > 1){\\n            int p = spf[x];\\n            d.union_(m[p], index);\\n            while(x%p == 0){\\n                x /= p;\\n                //cout<<\"Y0\"<<endl;\\n            }\\n        }\\n    }\\n\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int maxNum = 100000;\\n        DSU d(2*maxNum+1);\\n\\n        int n = nums.size();\\n        calc(maxNum);\\n        \\n        for(int i=0;i<n;i++){\\n            factorize(nums[i], d, primeToIndex, i);\\n        }\\n        set<int> count;\\n        for(int i=0;i<n;i++){\\n            count.insert(d.find_(i));\\n        }\\n        return (int)count.size() == 1;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "janis__",
                        "content": "The solution is TLE due to inefficiencies in the calc function\\'s nested loop for prime factorization and the factorize function. To fix it please optimize prime factorization using a more efficient Sieve of Eratosthenes and Streamline the union-find operations in factorize."
                    },
                    {
                        "username": "Getting_into_form",
                        "content": "Testcases are being accepted in run window but giving TLE on submission."
                    }
                ]
            },
            {
                "id": 1907392,
                "content": [
                    {
                        "username": "Driver12",
                        "content": "Upvote if u thought that looking for all prime divisors for every number is too long for these constraints..."
                    },
                    {
                        "username": "rjanshuman",
                        "content": "i stored/duplicated the input in an arraylist and created a 2D arraylist which has group of arrays divisible by prime numbers onwards 2 such that 1st group is even no.s, 2nd is multiple of 3 (but not 2), third is multiple of 5 (but not 2& 3) and so on..\\n\\nlater if at least one non-coprime no is found among this subarrays, then these are merged and in the end if the final array has same length as nums then it means iterable else not.\\n\\nMy approach/code passes 916/925 tests. However, it says time limit exceeded when an input of 5566 elements of 99991, a prime number is given... which is logical seeing the non-optimality of my code...\\n\\nNow, thinking of optimizing....\\n"
                    },
                    {
                        "username": "Akarshippili",
                        "content": "For me it says: \\nTime Limit Exceeded\\n921 / 921 testcases passed\\n\\n@LeetCode what does it mean ?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hiding the testcase [1,1] during the contest was a nasty, nasty move."
                    },
                    {
                        "username": "cjcoax",
                        "content": "There is a special place in hell for who hid it during the contest!"
                    },
                    {
                        "username": "czjnbb",
                        "content": "I only failed on this case: [1]. Very SAD."
                    },
                    {
                        "username": "czjnbb",
                        "content": "[@ybblkblt](/ybblkblt) If LC didn\\'t hide it during the contest..."
                    },
                    {
                        "username": "ybblkblt",
                        "content": "Me too!!! It would have been the first time I got the last question on the contest!!"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Fuck you 1"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "i wrote the code in n^2 but it got accepted,how?\\n"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "[@cartesPerforees](/cartesPerforees) oh,thanks for this,initially  i was hoping this solution would give tle and then i would have proceeded further with dsu, but it got accepted anyways"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "[@shivangi806](/shivangi806)  gcd of a number with itself is the number itself and we return false only if gcd with every other number is 1(except the number itself)"
                    },
                    {
                        "username": "shivangi806",
                        "content": "what is logic of putting nums[i]!=nums[j] as if it is equal also then there is no issue but it gives me wrong answer for 1 test case"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your code is not n^2. \nI guess you are checking all the multiples? Then you are checking every second numbers, then every third numbers, etc...\n$1/2+1/3+...1/n$ sums as $log(n)$. So your code is nlogn. I do assume that if an interviewr asks this question he will expect the complexity analysis of it tho, otherwise you're just walking into the right solution without knowing why"
                    },
                    {
                        "username": "divii",
                        "content": "` while (n % i == 0) n /= i;`\\nthis is where i lost :("
                    },
                    {
                        "username": "ujwalkv",
                        "content": "if I simply type run a testcase is passing , but when I click on submit the same testcase is giving a wrong answer"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "why testcase nums =[1] (tc917) will expected true ? \"determine if for every pair of indices i and j with i<j\" "
                    },
                    {
                        "username": "janis__",
                        "content": "The given condition states: \"determine if for every pair of indices ii and jj with i<ji<j\". When the list nums contains only one element (like in the testcase nums = [1]), there are no pairs of indices i,ji,j such that i<ji<j. Therefore, there\\'s no condition to violate and the result is True by default. In simpler terms, when there\\'s only one number, there are no other numbers to compare or connect to, so the requirements are inherently met. "
                    },
                    {
                        "username": "Getting_into_form",
                        "content": "Why is this solution giving TLE?\\n\\n```\\ntypedef vector<int> VI;\\ntypedef vector<VI> VVI;\\n\\nclass Solution {\\npublic:\\n    int spf[100000+1];\\n    unordered_map<int, int> primeToIndex;\\n    \\n    void calc(int maxNum){\\n        for(int i=1;i<=maxNum;i++) spf[i]=i;\\n\\n        int index = maxNum;\\n        for(int p = 2;p <= maxNum; p++){\\n            if(spf[p] != p) continue; \\n            \\n            primeToIndex[p] = index++;\\n            \\n            for(int j = 2*p;j <= maxNum;j += p){\\n                if(spf[j] == j) spf[j] = p;\\n            }\\n        }\\n    }\\n\\n    class DSU{\\n        private:\\n        VI parent;\\n        public:\\n        DSU(int n){\\n            for(int i=0;i<n;i++) parent.push_back(-1);\\n            //parent.resize(n, -1);\\n        }\\n        int find_(int x){\\n            if(parent[x] < 0) return x;\\n            // int p = find_(parent[x]);\\n            // parent[x] = p;\\n            parent[x] = find_(parent[x]);\\n            return parent[x];\\n        }\\n        void union_(int x, int y){\\n            int p1=find_(x), p2=find_(y);\\n            if(p1 != p2){\\n                parent[p1] += parent[p2];\\n                parent[p2] = p1;\\n            }\\n        }\\n    };\\n\\n    void factorize(int x, DSU &d, unordered_map<int, int> &m, int &index){\\n        cout<<x<<endl;\\n        while(x > 1){\\n            int p = spf[x];\\n            d.union_(m[p], index);\\n            while(x%p == 0){\\n                x /= p;\\n                //cout<<\"Y0\"<<endl;\\n            }\\n        }\\n    }\\n\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int maxNum = 100000;\\n        DSU d(2*maxNum+1);\\n\\n        int n = nums.size();\\n        calc(maxNum);\\n        \\n        for(int i=0;i<n;i++){\\n            factorize(nums[i], d, primeToIndex, i);\\n        }\\n        set<int> count;\\n        for(int i=0;i<n;i++){\\n            count.insert(d.find_(i));\\n        }\\n        return (int)count.size() == 1;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "janis__",
                        "content": "The solution is TLE due to inefficiencies in the calc function\\'s nested loop for prime factorization and the factorize function. To fix it please optimize prime factorization using a more efficient Sieve of Eratosthenes and Streamline the union-find operations in factorize."
                    },
                    {
                        "username": "Getting_into_form",
                        "content": "Testcases are being accepted in run window but giving TLE on submission."
                    }
                ]
            },
            {
                "id": 1995537,
                "content": [
                    {
                        "username": "Driver12",
                        "content": "Upvote if u thought that looking for all prime divisors for every number is too long for these constraints..."
                    },
                    {
                        "username": "rjanshuman",
                        "content": "i stored/duplicated the input in an arraylist and created a 2D arraylist which has group of arrays divisible by prime numbers onwards 2 such that 1st group is even no.s, 2nd is multiple of 3 (but not 2), third is multiple of 5 (but not 2& 3) and so on..\\n\\nlater if at least one non-coprime no is found among this subarrays, then these are merged and in the end if the final array has same length as nums then it means iterable else not.\\n\\nMy approach/code passes 916/925 tests. However, it says time limit exceeded when an input of 5566 elements of 99991, a prime number is given... which is logical seeing the non-optimality of my code...\\n\\nNow, thinking of optimizing....\\n"
                    },
                    {
                        "username": "Akarshippili",
                        "content": "For me it says: \\nTime Limit Exceeded\\n921 / 921 testcases passed\\n\\n@LeetCode what does it mean ?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hiding the testcase [1,1] during the contest was a nasty, nasty move."
                    },
                    {
                        "username": "cjcoax",
                        "content": "There is a special place in hell for who hid it during the contest!"
                    },
                    {
                        "username": "czjnbb",
                        "content": "I only failed on this case: [1]. Very SAD."
                    },
                    {
                        "username": "czjnbb",
                        "content": "[@ybblkblt](/ybblkblt) If LC didn\\'t hide it during the contest..."
                    },
                    {
                        "username": "ybblkblt",
                        "content": "Me too!!! It would have been the first time I got the last question on the contest!!"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Fuck you 1"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "i wrote the code in n^2 but it got accepted,how?\\n"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "[@cartesPerforees](/cartesPerforees) oh,thanks for this,initially  i was hoping this solution would give tle and then i would have proceeded further with dsu, but it got accepted anyways"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "[@shivangi806](/shivangi806)  gcd of a number with itself is the number itself and we return false only if gcd with every other number is 1(except the number itself)"
                    },
                    {
                        "username": "shivangi806",
                        "content": "what is logic of putting nums[i]!=nums[j] as if it is equal also then there is no issue but it gives me wrong answer for 1 test case"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your code is not n^2. \nI guess you are checking all the multiples? Then you are checking every second numbers, then every third numbers, etc...\n$1/2+1/3+...1/n$ sums as $log(n)$. So your code is nlogn. I do assume that if an interviewr asks this question he will expect the complexity analysis of it tho, otherwise you're just walking into the right solution without knowing why"
                    },
                    {
                        "username": "divii",
                        "content": "` while (n % i == 0) n /= i;`\\nthis is where i lost :("
                    },
                    {
                        "username": "ujwalkv",
                        "content": "if I simply type run a testcase is passing , but when I click on submit the same testcase is giving a wrong answer"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "why testcase nums =[1] (tc917) will expected true ? \"determine if for every pair of indices i and j with i<j\" "
                    },
                    {
                        "username": "janis__",
                        "content": "The given condition states: \"determine if for every pair of indices ii and jj with i<ji<j\". When the list nums contains only one element (like in the testcase nums = [1]), there are no pairs of indices i,ji,j such that i<ji<j. Therefore, there\\'s no condition to violate and the result is True by default. In simpler terms, when there\\'s only one number, there are no other numbers to compare or connect to, so the requirements are inherently met. "
                    },
                    {
                        "username": "Getting_into_form",
                        "content": "Why is this solution giving TLE?\\n\\n```\\ntypedef vector<int> VI;\\ntypedef vector<VI> VVI;\\n\\nclass Solution {\\npublic:\\n    int spf[100000+1];\\n    unordered_map<int, int> primeToIndex;\\n    \\n    void calc(int maxNum){\\n        for(int i=1;i<=maxNum;i++) spf[i]=i;\\n\\n        int index = maxNum;\\n        for(int p = 2;p <= maxNum; p++){\\n            if(spf[p] != p) continue; \\n            \\n            primeToIndex[p] = index++;\\n            \\n            for(int j = 2*p;j <= maxNum;j += p){\\n                if(spf[j] == j) spf[j] = p;\\n            }\\n        }\\n    }\\n\\n    class DSU{\\n        private:\\n        VI parent;\\n        public:\\n        DSU(int n){\\n            for(int i=0;i<n;i++) parent.push_back(-1);\\n            //parent.resize(n, -1);\\n        }\\n        int find_(int x){\\n            if(parent[x] < 0) return x;\\n            // int p = find_(parent[x]);\\n            // parent[x] = p;\\n            parent[x] = find_(parent[x]);\\n            return parent[x];\\n        }\\n        void union_(int x, int y){\\n            int p1=find_(x), p2=find_(y);\\n            if(p1 != p2){\\n                parent[p1] += parent[p2];\\n                parent[p2] = p1;\\n            }\\n        }\\n    };\\n\\n    void factorize(int x, DSU &d, unordered_map<int, int> &m, int &index){\\n        cout<<x<<endl;\\n        while(x > 1){\\n            int p = spf[x];\\n            d.union_(m[p], index);\\n            while(x%p == 0){\\n                x /= p;\\n                //cout<<\"Y0\"<<endl;\\n            }\\n        }\\n    }\\n\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int maxNum = 100000;\\n        DSU d(2*maxNum+1);\\n\\n        int n = nums.size();\\n        calc(maxNum);\\n        \\n        for(int i=0;i<n;i++){\\n            factorize(nums[i], d, primeToIndex, i);\\n        }\\n        set<int> count;\\n        for(int i=0;i<n;i++){\\n            count.insert(d.find_(i));\\n        }\\n        return (int)count.size() == 1;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "janis__",
                        "content": "The solution is TLE due to inefficiencies in the calc function\\'s nested loop for prime factorization and the factorize function. To fix it please optimize prime factorization using a more efficient Sieve of Eratosthenes and Streamline the union-find operations in factorize."
                    },
                    {
                        "username": "Getting_into_form",
                        "content": "Testcases are being accepted in run window but giving TLE on submission."
                    }
                ]
            },
            {
                "id": 1907690,
                "content": [
                    {
                        "username": "Driver12",
                        "content": "Upvote if u thought that looking for all prime divisors for every number is too long for these constraints..."
                    },
                    {
                        "username": "rjanshuman",
                        "content": "i stored/duplicated the input in an arraylist and created a 2D arraylist which has group of arrays divisible by prime numbers onwards 2 such that 1st group is even no.s, 2nd is multiple of 3 (but not 2), third is multiple of 5 (but not 2& 3) and so on..\\n\\nlater if at least one non-coprime no is found among this subarrays, then these are merged and in the end if the final array has same length as nums then it means iterable else not.\\n\\nMy approach/code passes 916/925 tests. However, it says time limit exceeded when an input of 5566 elements of 99991, a prime number is given... which is logical seeing the non-optimality of my code...\\n\\nNow, thinking of optimizing....\\n"
                    },
                    {
                        "username": "Akarshippili",
                        "content": "For me it says: \\nTime Limit Exceeded\\n921 / 921 testcases passed\\n\\n@LeetCode what does it mean ?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hiding the testcase [1,1] during the contest was a nasty, nasty move."
                    },
                    {
                        "username": "cjcoax",
                        "content": "There is a special place in hell for who hid it during the contest!"
                    },
                    {
                        "username": "czjnbb",
                        "content": "I only failed on this case: [1]. Very SAD."
                    },
                    {
                        "username": "czjnbb",
                        "content": "[@ybblkblt](/ybblkblt) If LC didn\\'t hide it during the contest..."
                    },
                    {
                        "username": "ybblkblt",
                        "content": "Me too!!! It would have been the first time I got the last question on the contest!!"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Fuck you 1"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "i wrote the code in n^2 but it got accepted,how?\\n"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "[@cartesPerforees](/cartesPerforees) oh,thanks for this,initially  i was hoping this solution would give tle and then i would have proceeded further with dsu, but it got accepted anyways"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "[@shivangi806](/shivangi806)  gcd of a number with itself is the number itself and we return false only if gcd with every other number is 1(except the number itself)"
                    },
                    {
                        "username": "shivangi806",
                        "content": "what is logic of putting nums[i]!=nums[j] as if it is equal also then there is no issue but it gives me wrong answer for 1 test case"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your code is not n^2. \nI guess you are checking all the multiples? Then you are checking every second numbers, then every third numbers, etc...\n$1/2+1/3+...1/n$ sums as $log(n)$. So your code is nlogn. I do assume that if an interviewr asks this question he will expect the complexity analysis of it tho, otherwise you're just walking into the right solution without knowing why"
                    },
                    {
                        "username": "divii",
                        "content": "` while (n % i == 0) n /= i;`\\nthis is where i lost :("
                    },
                    {
                        "username": "ujwalkv",
                        "content": "if I simply type run a testcase is passing , but when I click on submit the same testcase is giving a wrong answer"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "why testcase nums =[1] (tc917) will expected true ? \"determine if for every pair of indices i and j with i<j\" "
                    },
                    {
                        "username": "janis__",
                        "content": "The given condition states: \"determine if for every pair of indices ii and jj with i<ji<j\". When the list nums contains only one element (like in the testcase nums = [1]), there are no pairs of indices i,ji,j such that i<ji<j. Therefore, there\\'s no condition to violate and the result is True by default. In simpler terms, when there\\'s only one number, there are no other numbers to compare or connect to, so the requirements are inherently met. "
                    },
                    {
                        "username": "Getting_into_form",
                        "content": "Why is this solution giving TLE?\\n\\n```\\ntypedef vector<int> VI;\\ntypedef vector<VI> VVI;\\n\\nclass Solution {\\npublic:\\n    int spf[100000+1];\\n    unordered_map<int, int> primeToIndex;\\n    \\n    void calc(int maxNum){\\n        for(int i=1;i<=maxNum;i++) spf[i]=i;\\n\\n        int index = maxNum;\\n        for(int p = 2;p <= maxNum; p++){\\n            if(spf[p] != p) continue; \\n            \\n            primeToIndex[p] = index++;\\n            \\n            for(int j = 2*p;j <= maxNum;j += p){\\n                if(spf[j] == j) spf[j] = p;\\n            }\\n        }\\n    }\\n\\n    class DSU{\\n        private:\\n        VI parent;\\n        public:\\n        DSU(int n){\\n            for(int i=0;i<n;i++) parent.push_back(-1);\\n            //parent.resize(n, -1);\\n        }\\n        int find_(int x){\\n            if(parent[x] < 0) return x;\\n            // int p = find_(parent[x]);\\n            // parent[x] = p;\\n            parent[x] = find_(parent[x]);\\n            return parent[x];\\n        }\\n        void union_(int x, int y){\\n            int p1=find_(x), p2=find_(y);\\n            if(p1 != p2){\\n                parent[p1] += parent[p2];\\n                parent[p2] = p1;\\n            }\\n        }\\n    };\\n\\n    void factorize(int x, DSU &d, unordered_map<int, int> &m, int &index){\\n        cout<<x<<endl;\\n        while(x > 1){\\n            int p = spf[x];\\n            d.union_(m[p], index);\\n            while(x%p == 0){\\n                x /= p;\\n                //cout<<\"Y0\"<<endl;\\n            }\\n        }\\n    }\\n\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int maxNum = 100000;\\n        DSU d(2*maxNum+1);\\n\\n        int n = nums.size();\\n        calc(maxNum);\\n        \\n        for(int i=0;i<n;i++){\\n            factorize(nums[i], d, primeToIndex, i);\\n        }\\n        set<int> count;\\n        for(int i=0;i<n;i++){\\n            count.insert(d.find_(i));\\n        }\\n        return (int)count.size() == 1;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "janis__",
                        "content": "The solution is TLE due to inefficiencies in the calc function\\'s nested loop for prime factorization and the factorize function. To fix it please optimize prime factorization using a more efficient Sieve of Eratosthenes and Streamline the union-find operations in factorize."
                    },
                    {
                        "username": "Getting_into_form",
                        "content": "Testcases are being accepted in run window but giving TLE on submission."
                    }
                ]
            },
            {
                "id": 1907596,
                "content": [
                    {
                        "username": "Driver12",
                        "content": "Upvote if u thought that looking for all prime divisors for every number is too long for these constraints..."
                    },
                    {
                        "username": "rjanshuman",
                        "content": "i stored/duplicated the input in an arraylist and created a 2D arraylist which has group of arrays divisible by prime numbers onwards 2 such that 1st group is even no.s, 2nd is multiple of 3 (but not 2), third is multiple of 5 (but not 2& 3) and so on..\\n\\nlater if at least one non-coprime no is found among this subarrays, then these are merged and in the end if the final array has same length as nums then it means iterable else not.\\n\\nMy approach/code passes 916/925 tests. However, it says time limit exceeded when an input of 5566 elements of 99991, a prime number is given... which is logical seeing the non-optimality of my code...\\n\\nNow, thinking of optimizing....\\n"
                    },
                    {
                        "username": "Akarshippili",
                        "content": "For me it says: \\nTime Limit Exceeded\\n921 / 921 testcases passed\\n\\n@LeetCode what does it mean ?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hiding the testcase [1,1] during the contest was a nasty, nasty move."
                    },
                    {
                        "username": "cjcoax",
                        "content": "There is a special place in hell for who hid it during the contest!"
                    },
                    {
                        "username": "czjnbb",
                        "content": "I only failed on this case: [1]. Very SAD."
                    },
                    {
                        "username": "czjnbb",
                        "content": "[@ybblkblt](/ybblkblt) If LC didn\\'t hide it during the contest..."
                    },
                    {
                        "username": "ybblkblt",
                        "content": "Me too!!! It would have been the first time I got the last question on the contest!!"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Fuck you 1"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "i wrote the code in n^2 but it got accepted,how?\\n"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "[@cartesPerforees](/cartesPerforees) oh,thanks for this,initially  i was hoping this solution would give tle and then i would have proceeded further with dsu, but it got accepted anyways"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "[@shivangi806](/shivangi806)  gcd of a number with itself is the number itself and we return false only if gcd with every other number is 1(except the number itself)"
                    },
                    {
                        "username": "shivangi806",
                        "content": "what is logic of putting nums[i]!=nums[j] as if it is equal also then there is no issue but it gives me wrong answer for 1 test case"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your code is not n^2. \nI guess you are checking all the multiples? Then you are checking every second numbers, then every third numbers, etc...\n$1/2+1/3+...1/n$ sums as $log(n)$. So your code is nlogn. I do assume that if an interviewr asks this question he will expect the complexity analysis of it tho, otherwise you're just walking into the right solution without knowing why"
                    },
                    {
                        "username": "divii",
                        "content": "` while (n % i == 0) n /= i;`\\nthis is where i lost :("
                    },
                    {
                        "username": "ujwalkv",
                        "content": "if I simply type run a testcase is passing , but when I click on submit the same testcase is giving a wrong answer"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "why testcase nums =[1] (tc917) will expected true ? \"determine if for every pair of indices i and j with i<j\" "
                    },
                    {
                        "username": "janis__",
                        "content": "The given condition states: \"determine if for every pair of indices ii and jj with i<ji<j\". When the list nums contains only one element (like in the testcase nums = [1]), there are no pairs of indices i,ji,j such that i<ji<j. Therefore, there\\'s no condition to violate and the result is True by default. In simpler terms, when there\\'s only one number, there are no other numbers to compare or connect to, so the requirements are inherently met. "
                    },
                    {
                        "username": "Getting_into_form",
                        "content": "Why is this solution giving TLE?\\n\\n```\\ntypedef vector<int> VI;\\ntypedef vector<VI> VVI;\\n\\nclass Solution {\\npublic:\\n    int spf[100000+1];\\n    unordered_map<int, int> primeToIndex;\\n    \\n    void calc(int maxNum){\\n        for(int i=1;i<=maxNum;i++) spf[i]=i;\\n\\n        int index = maxNum;\\n        for(int p = 2;p <= maxNum; p++){\\n            if(spf[p] != p) continue; \\n            \\n            primeToIndex[p] = index++;\\n            \\n            for(int j = 2*p;j <= maxNum;j += p){\\n                if(spf[j] == j) spf[j] = p;\\n            }\\n        }\\n    }\\n\\n    class DSU{\\n        private:\\n        VI parent;\\n        public:\\n        DSU(int n){\\n            for(int i=0;i<n;i++) parent.push_back(-1);\\n            //parent.resize(n, -1);\\n        }\\n        int find_(int x){\\n            if(parent[x] < 0) return x;\\n            // int p = find_(parent[x]);\\n            // parent[x] = p;\\n            parent[x] = find_(parent[x]);\\n            return parent[x];\\n        }\\n        void union_(int x, int y){\\n            int p1=find_(x), p2=find_(y);\\n            if(p1 != p2){\\n                parent[p1] += parent[p2];\\n                parent[p2] = p1;\\n            }\\n        }\\n    };\\n\\n    void factorize(int x, DSU &d, unordered_map<int, int> &m, int &index){\\n        cout<<x<<endl;\\n        while(x > 1){\\n            int p = spf[x];\\n            d.union_(m[p], index);\\n            while(x%p == 0){\\n                x /= p;\\n                //cout<<\"Y0\"<<endl;\\n            }\\n        }\\n    }\\n\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int maxNum = 100000;\\n        DSU d(2*maxNum+1);\\n\\n        int n = nums.size();\\n        calc(maxNum);\\n        \\n        for(int i=0;i<n;i++){\\n            factorize(nums[i], d, primeToIndex, i);\\n        }\\n        set<int> count;\\n        for(int i=0;i<n;i++){\\n            count.insert(d.find_(i));\\n        }\\n        return (int)count.size() == 1;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "janis__",
                        "content": "The solution is TLE due to inefficiencies in the calc function\\'s nested loop for prime factorization and the factorize function. To fix it please optimize prime factorization using a more efficient Sieve of Eratosthenes and Streamline the union-find operations in factorize."
                    },
                    {
                        "username": "Getting_into_form",
                        "content": "Testcases are being accepted in run window but giving TLE on submission."
                    }
                ]
            },
            {
                "id": 1929937,
                "content": [
                    {
                        "username": "Driver12",
                        "content": "Upvote if u thought that looking for all prime divisors for every number is too long for these constraints..."
                    },
                    {
                        "username": "rjanshuman",
                        "content": "i stored/duplicated the input in an arraylist and created a 2D arraylist which has group of arrays divisible by prime numbers onwards 2 such that 1st group is even no.s, 2nd is multiple of 3 (but not 2), third is multiple of 5 (but not 2& 3) and so on..\\n\\nlater if at least one non-coprime no is found among this subarrays, then these are merged and in the end if the final array has same length as nums then it means iterable else not.\\n\\nMy approach/code passes 916/925 tests. However, it says time limit exceeded when an input of 5566 elements of 99991, a prime number is given... which is logical seeing the non-optimality of my code...\\n\\nNow, thinking of optimizing....\\n"
                    },
                    {
                        "username": "Akarshippili",
                        "content": "For me it says: \\nTime Limit Exceeded\\n921 / 921 testcases passed\\n\\n@LeetCode what does it mean ?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hiding the testcase [1,1] during the contest was a nasty, nasty move."
                    },
                    {
                        "username": "cjcoax",
                        "content": "There is a special place in hell for who hid it during the contest!"
                    },
                    {
                        "username": "czjnbb",
                        "content": "I only failed on this case: [1]. Very SAD."
                    },
                    {
                        "username": "czjnbb",
                        "content": "[@ybblkblt](/ybblkblt) If LC didn\\'t hide it during the contest..."
                    },
                    {
                        "username": "ybblkblt",
                        "content": "Me too!!! It would have been the first time I got the last question on the contest!!"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Fuck you 1"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "i wrote the code in n^2 but it got accepted,how?\\n"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "[@cartesPerforees](/cartesPerforees) oh,thanks for this,initially  i was hoping this solution would give tle and then i would have proceeded further with dsu, but it got accepted anyways"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "[@shivangi806](/shivangi806)  gcd of a number with itself is the number itself and we return false only if gcd with every other number is 1(except the number itself)"
                    },
                    {
                        "username": "shivangi806",
                        "content": "what is logic of putting nums[i]!=nums[j] as if it is equal also then there is no issue but it gives me wrong answer for 1 test case"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your code is not n^2. \nI guess you are checking all the multiples? Then you are checking every second numbers, then every third numbers, etc...\n$1/2+1/3+...1/n$ sums as $log(n)$. So your code is nlogn. I do assume that if an interviewr asks this question he will expect the complexity analysis of it tho, otherwise you're just walking into the right solution without knowing why"
                    },
                    {
                        "username": "divii",
                        "content": "` while (n % i == 0) n /= i;`\\nthis is where i lost :("
                    },
                    {
                        "username": "ujwalkv",
                        "content": "if I simply type run a testcase is passing , but when I click on submit the same testcase is giving a wrong answer"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "why testcase nums =[1] (tc917) will expected true ? \"determine if for every pair of indices i and j with i<j\" "
                    },
                    {
                        "username": "janis__",
                        "content": "The given condition states: \"determine if for every pair of indices ii and jj with i<ji<j\". When the list nums contains only one element (like in the testcase nums = [1]), there are no pairs of indices i,ji,j such that i<ji<j. Therefore, there\\'s no condition to violate and the result is True by default. In simpler terms, when there\\'s only one number, there are no other numbers to compare or connect to, so the requirements are inherently met. "
                    },
                    {
                        "username": "Getting_into_form",
                        "content": "Why is this solution giving TLE?\\n\\n```\\ntypedef vector<int> VI;\\ntypedef vector<VI> VVI;\\n\\nclass Solution {\\npublic:\\n    int spf[100000+1];\\n    unordered_map<int, int> primeToIndex;\\n    \\n    void calc(int maxNum){\\n        for(int i=1;i<=maxNum;i++) spf[i]=i;\\n\\n        int index = maxNum;\\n        for(int p = 2;p <= maxNum; p++){\\n            if(spf[p] != p) continue; \\n            \\n            primeToIndex[p] = index++;\\n            \\n            for(int j = 2*p;j <= maxNum;j += p){\\n                if(spf[j] == j) spf[j] = p;\\n            }\\n        }\\n    }\\n\\n    class DSU{\\n        private:\\n        VI parent;\\n        public:\\n        DSU(int n){\\n            for(int i=0;i<n;i++) parent.push_back(-1);\\n            //parent.resize(n, -1);\\n        }\\n        int find_(int x){\\n            if(parent[x] < 0) return x;\\n            // int p = find_(parent[x]);\\n            // parent[x] = p;\\n            parent[x] = find_(parent[x]);\\n            return parent[x];\\n        }\\n        void union_(int x, int y){\\n            int p1=find_(x), p2=find_(y);\\n            if(p1 != p2){\\n                parent[p1] += parent[p2];\\n                parent[p2] = p1;\\n            }\\n        }\\n    };\\n\\n    void factorize(int x, DSU &d, unordered_map<int, int> &m, int &index){\\n        cout<<x<<endl;\\n        while(x > 1){\\n            int p = spf[x];\\n            d.union_(m[p], index);\\n            while(x%p == 0){\\n                x /= p;\\n                //cout<<\"Y0\"<<endl;\\n            }\\n        }\\n    }\\n\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int maxNum = 100000;\\n        DSU d(2*maxNum+1);\\n\\n        int n = nums.size();\\n        calc(maxNum);\\n        \\n        for(int i=0;i<n;i++){\\n            factorize(nums[i], d, primeToIndex, i);\\n        }\\n        set<int> count;\\n        for(int i=0;i<n;i++){\\n            count.insert(d.find_(i));\\n        }\\n        return (int)count.size() == 1;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "janis__",
                        "content": "The solution is TLE due to inefficiencies in the calc function\\'s nested loop for prime factorization and the factorize function. To fix it please optimize prime factorization using a more efficient Sieve of Eratosthenes and Streamline the union-find operations in factorize."
                    },
                    {
                        "username": "Getting_into_form",
                        "content": "Testcases are being accepted in run window but giving TLE on submission."
                    }
                ]
            },
            {
                "id": 1919107,
                "content": [
                    {
                        "username": "Driver12",
                        "content": "Upvote if u thought that looking for all prime divisors for every number is too long for these constraints..."
                    },
                    {
                        "username": "rjanshuman",
                        "content": "i stored/duplicated the input in an arraylist and created a 2D arraylist which has group of arrays divisible by prime numbers onwards 2 such that 1st group is even no.s, 2nd is multiple of 3 (but not 2), third is multiple of 5 (but not 2& 3) and so on..\\n\\nlater if at least one non-coprime no is found among this subarrays, then these are merged and in the end if the final array has same length as nums then it means iterable else not.\\n\\nMy approach/code passes 916/925 tests. However, it says time limit exceeded when an input of 5566 elements of 99991, a prime number is given... which is logical seeing the non-optimality of my code...\\n\\nNow, thinking of optimizing....\\n"
                    },
                    {
                        "username": "Akarshippili",
                        "content": "For me it says: \\nTime Limit Exceeded\\n921 / 921 testcases passed\\n\\n@LeetCode what does it mean ?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hiding the testcase [1,1] during the contest was a nasty, nasty move."
                    },
                    {
                        "username": "cjcoax",
                        "content": "There is a special place in hell for who hid it during the contest!"
                    },
                    {
                        "username": "czjnbb",
                        "content": "I only failed on this case: [1]. Very SAD."
                    },
                    {
                        "username": "czjnbb",
                        "content": "[@ybblkblt](/ybblkblt) If LC didn\\'t hide it during the contest..."
                    },
                    {
                        "username": "ybblkblt",
                        "content": "Me too!!! It would have been the first time I got the last question on the contest!!"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Fuck you 1"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "i wrote the code in n^2 but it got accepted,how?\\n"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "[@cartesPerforees](/cartesPerforees) oh,thanks for this,initially  i was hoping this solution would give tle and then i would have proceeded further with dsu, but it got accepted anyways"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "[@shivangi806](/shivangi806)  gcd of a number with itself is the number itself and we return false only if gcd with every other number is 1(except the number itself)"
                    },
                    {
                        "username": "shivangi806",
                        "content": "what is logic of putting nums[i]!=nums[j] as if it is equal also then there is no issue but it gives me wrong answer for 1 test case"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your code is not n^2. \nI guess you are checking all the multiples? Then you are checking every second numbers, then every third numbers, etc...\n$1/2+1/3+...1/n$ sums as $log(n)$. So your code is nlogn. I do assume that if an interviewr asks this question he will expect the complexity analysis of it tho, otherwise you're just walking into the right solution without knowing why"
                    },
                    {
                        "username": "divii",
                        "content": "` while (n % i == 0) n /= i;`\\nthis is where i lost :("
                    },
                    {
                        "username": "ujwalkv",
                        "content": "if I simply type run a testcase is passing , but when I click on submit the same testcase is giving a wrong answer"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "why testcase nums =[1] (tc917) will expected true ? \"determine if for every pair of indices i and j with i<j\" "
                    },
                    {
                        "username": "janis__",
                        "content": "The given condition states: \"determine if for every pair of indices ii and jj with i<ji<j\". When the list nums contains only one element (like in the testcase nums = [1]), there are no pairs of indices i,ji,j such that i<ji<j. Therefore, there\\'s no condition to violate and the result is True by default. In simpler terms, when there\\'s only one number, there are no other numbers to compare or connect to, so the requirements are inherently met. "
                    },
                    {
                        "username": "Getting_into_form",
                        "content": "Why is this solution giving TLE?\\n\\n```\\ntypedef vector<int> VI;\\ntypedef vector<VI> VVI;\\n\\nclass Solution {\\npublic:\\n    int spf[100000+1];\\n    unordered_map<int, int> primeToIndex;\\n    \\n    void calc(int maxNum){\\n        for(int i=1;i<=maxNum;i++) spf[i]=i;\\n\\n        int index = maxNum;\\n        for(int p = 2;p <= maxNum; p++){\\n            if(spf[p] != p) continue; \\n            \\n            primeToIndex[p] = index++;\\n            \\n            for(int j = 2*p;j <= maxNum;j += p){\\n                if(spf[j] == j) spf[j] = p;\\n            }\\n        }\\n    }\\n\\n    class DSU{\\n        private:\\n        VI parent;\\n        public:\\n        DSU(int n){\\n            for(int i=0;i<n;i++) parent.push_back(-1);\\n            //parent.resize(n, -1);\\n        }\\n        int find_(int x){\\n            if(parent[x] < 0) return x;\\n            // int p = find_(parent[x]);\\n            // parent[x] = p;\\n            parent[x] = find_(parent[x]);\\n            return parent[x];\\n        }\\n        void union_(int x, int y){\\n            int p1=find_(x), p2=find_(y);\\n            if(p1 != p2){\\n                parent[p1] += parent[p2];\\n                parent[p2] = p1;\\n            }\\n        }\\n    };\\n\\n    void factorize(int x, DSU &d, unordered_map<int, int> &m, int &index){\\n        cout<<x<<endl;\\n        while(x > 1){\\n            int p = spf[x];\\n            d.union_(m[p], index);\\n            while(x%p == 0){\\n                x /= p;\\n                //cout<<\"Y0\"<<endl;\\n            }\\n        }\\n    }\\n\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int maxNum = 100000;\\n        DSU d(2*maxNum+1);\\n\\n        int n = nums.size();\\n        calc(maxNum);\\n        \\n        for(int i=0;i<n;i++){\\n            factorize(nums[i], d, primeToIndex, i);\\n        }\\n        set<int> count;\\n        for(int i=0;i<n;i++){\\n            count.insert(d.find_(i));\\n        }\\n        return (int)count.size() == 1;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "janis__",
                        "content": "The solution is TLE due to inefficiencies in the calc function\\'s nested loop for prime factorization and the factorize function. To fix it please optimize prime factorization using a more efficient Sieve of Eratosthenes and Streamline the union-find operations in factorize."
                    },
                    {
                        "username": "Getting_into_form",
                        "content": "Testcases are being accepted in run window but giving TLE on submission."
                    }
                ]
            },
            {
                "id": 1913517,
                "content": [
                    {
                        "username": "Driver12",
                        "content": "Upvote if u thought that looking for all prime divisors for every number is too long for these constraints..."
                    },
                    {
                        "username": "rjanshuman",
                        "content": "i stored/duplicated the input in an arraylist and created a 2D arraylist which has group of arrays divisible by prime numbers onwards 2 such that 1st group is even no.s, 2nd is multiple of 3 (but not 2), third is multiple of 5 (but not 2& 3) and so on..\\n\\nlater if at least one non-coprime no is found among this subarrays, then these are merged and in the end if the final array has same length as nums then it means iterable else not.\\n\\nMy approach/code passes 916/925 tests. However, it says time limit exceeded when an input of 5566 elements of 99991, a prime number is given... which is logical seeing the non-optimality of my code...\\n\\nNow, thinking of optimizing....\\n"
                    },
                    {
                        "username": "Akarshippili",
                        "content": "For me it says: \\nTime Limit Exceeded\\n921 / 921 testcases passed\\n\\n@LeetCode what does it mean ?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hiding the testcase [1,1] during the contest was a nasty, nasty move."
                    },
                    {
                        "username": "cjcoax",
                        "content": "There is a special place in hell for who hid it during the contest!"
                    },
                    {
                        "username": "czjnbb",
                        "content": "I only failed on this case: [1]. Very SAD."
                    },
                    {
                        "username": "czjnbb",
                        "content": "[@ybblkblt](/ybblkblt) If LC didn\\'t hide it during the contest..."
                    },
                    {
                        "username": "ybblkblt",
                        "content": "Me too!!! It would have been the first time I got the last question on the contest!!"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Fuck you 1"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "i wrote the code in n^2 but it got accepted,how?\\n"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "[@cartesPerforees](/cartesPerforees) oh,thanks for this,initially  i was hoping this solution would give tle and then i would have proceeded further with dsu, but it got accepted anyways"
                    },
                    {
                        "username": "vinayaksingh809",
                        "content": "[@shivangi806](/shivangi806)  gcd of a number with itself is the number itself and we return false only if gcd with every other number is 1(except the number itself)"
                    },
                    {
                        "username": "shivangi806",
                        "content": "what is logic of putting nums[i]!=nums[j] as if it is equal also then there is no issue but it gives me wrong answer for 1 test case"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your code is not n^2. \nI guess you are checking all the multiples? Then you are checking every second numbers, then every third numbers, etc...\n$1/2+1/3+...1/n$ sums as $log(n)$. So your code is nlogn. I do assume that if an interviewr asks this question he will expect the complexity analysis of it tho, otherwise you're just walking into the right solution without knowing why"
                    },
                    {
                        "username": "divii",
                        "content": "` while (n % i == 0) n /= i;`\\nthis is where i lost :("
                    },
                    {
                        "username": "ujwalkv",
                        "content": "if I simply type run a testcase is passing , but when I click on submit the same testcase is giving a wrong answer"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "why testcase nums =[1] (tc917) will expected true ? \"determine if for every pair of indices i and j with i<j\" "
                    },
                    {
                        "username": "janis__",
                        "content": "The given condition states: \"determine if for every pair of indices ii and jj with i<ji<j\". When the list nums contains only one element (like in the testcase nums = [1]), there are no pairs of indices i,ji,j such that i<ji<j. Therefore, there\\'s no condition to violate and the result is True by default. In simpler terms, when there\\'s only one number, there are no other numbers to compare or connect to, so the requirements are inherently met. "
                    },
                    {
                        "username": "Getting_into_form",
                        "content": "Why is this solution giving TLE?\\n\\n```\\ntypedef vector<int> VI;\\ntypedef vector<VI> VVI;\\n\\nclass Solution {\\npublic:\\n    int spf[100000+1];\\n    unordered_map<int, int> primeToIndex;\\n    \\n    void calc(int maxNum){\\n        for(int i=1;i<=maxNum;i++) spf[i]=i;\\n\\n        int index = maxNum;\\n        for(int p = 2;p <= maxNum; p++){\\n            if(spf[p] != p) continue; \\n            \\n            primeToIndex[p] = index++;\\n            \\n            for(int j = 2*p;j <= maxNum;j += p){\\n                if(spf[j] == j) spf[j] = p;\\n            }\\n        }\\n    }\\n\\n    class DSU{\\n        private:\\n        VI parent;\\n        public:\\n        DSU(int n){\\n            for(int i=0;i<n;i++) parent.push_back(-1);\\n            //parent.resize(n, -1);\\n        }\\n        int find_(int x){\\n            if(parent[x] < 0) return x;\\n            // int p = find_(parent[x]);\\n            // parent[x] = p;\\n            parent[x] = find_(parent[x]);\\n            return parent[x];\\n        }\\n        void union_(int x, int y){\\n            int p1=find_(x), p2=find_(y);\\n            if(p1 != p2){\\n                parent[p1] += parent[p2];\\n                parent[p2] = p1;\\n            }\\n        }\\n    };\\n\\n    void factorize(int x, DSU &d, unordered_map<int, int> &m, int &index){\\n        cout<<x<<endl;\\n        while(x > 1){\\n            int p = spf[x];\\n            d.union_(m[p], index);\\n            while(x%p == 0){\\n                x /= p;\\n                //cout<<\"Y0\"<<endl;\\n            }\\n        }\\n    }\\n\\n    bool canTraverseAllPairs(vector<int>& nums) {\\n        int maxNum = 100000;\\n        DSU d(2*maxNum+1);\\n\\n        int n = nums.size();\\n        calc(maxNum);\\n        \\n        for(int i=0;i<n;i++){\\n            factorize(nums[i], d, primeToIndex, i);\\n        }\\n        set<int> count;\\n        for(int i=0;i<n;i++){\\n            count.insert(d.find_(i));\\n        }\\n        return (int)count.size() == 1;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "janis__",
                        "content": "The solution is TLE due to inefficiencies in the calc function\\'s nested loop for prime factorization and the factorize function. To fix it please optimize prime factorization using a more efficient Sieve of Eratosthenes and Streamline the union-find operations in factorize."
                    },
                    {
                        "username": "Getting_into_form",
                        "content": "Testcases are being accepted in run window but giving TLE on submission."
                    }
                ]
            }
        ]
    },
    {
        "title": "Calculator with Method Chaining",
        "question_content": "<p>Design a <code>Calculator</code> class. The class should provide the&nbsp;mathematical operations of&nbsp;addition, subtraction, multiplication, division, and exponentiation. It should also allow consecutive operations to be performed using method chaining.&nbsp;The <code>Calculator</code> class constructor should accept a number&nbsp;which serves as the&nbsp;initial value of <code>result</code>.</p>\n\n<p>Your <font face=\"monospace\"><code>Calculator</code>&nbsp;</font>class should have the following methods:</p>\n\n<ul>\n\t<li><code>add</code> - This method adds the given number <code>value</code> to the&nbsp;<code>result</code> and returns the updated <code>Calculator</code>.</li>\n\t<li><code>subtract</code> -&nbsp;This method subtracts the given number <code>value</code>&nbsp;from the&nbsp;<code>result</code> and returns the updated <code>Calculator</code>.</li>\n\t<li><code>multiply</code> -&nbsp;This method multiplies the <code>result</code>&nbsp; by the given number <code>value</code> and returns the updated <code>Calculator</code>.</li>\n\t<li><code>divide</code> -&nbsp;This method divides the <code>result</code> by the given number <code>value</code> and returns the updated <code>Calculator</code>. If the passed value is <code>0</code>, an error <code>&quot;Division by zero is not allowed&quot;</code> should be thrown.</li>\n\t<li><code>power</code> -&nbsp;This method raises the&nbsp;<code>result</code> to the power of the given number <code>value</code> and returns the updated <code>Calculator</code>.</li>\n\t<li><code>getResult</code> -&nbsp;This method returns the <code>result</code>.</li>\n</ul>\n\n<p>Solutions within&nbsp;<code>10<sup>-5</sup></code>&nbsp;of the actual result are considered correct.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nactions = [&quot;Calculator&quot;, &quot;add&quot;, &quot;subtract&quot;, &quot;getResult&quot;], \nvalues = [10, 5, 7]\n<strong>Output:</strong> 8\n<strong>Explanation:</strong> \nnew Calculator(10).add(5).subtract(7).getResult() // 10 + 5 - 7 = 8\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nactions = [&quot;Calculator&quot;, &quot;multiply&quot;, &quot;power&quot;, &quot;getResult&quot;], \nvalues = [2, 5, 2]\n<strong>Output:</strong> 100\n<strong>Explanation:</strong> \nnew Calculator(2).multiply(5).power(2).getResult() // (2 * 5) ^ 2 = 100\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nactions = [&quot;Calculator&quot;, &quot;divide&quot;, &quot;getResult&quot;], \nvalues = [20, 0]\n<strong>Output:</strong> &quot;Division by zero is not allowed&quot;\n<strong>Explanation:</strong> \nnew Calculator(20).divide(0).getResult() // 20 / 0 \n\nThe error should be thrown because we cannot divide by zero.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>actions</code> is a valid JSON array of strings</li>\n\t<li><code>values</code>&nbsp;is a valid JSON array of numbers</li>\n\t<li><code>2 &lt;= actions.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= values.length &lt;= 2 * 10<sup>4</sup>&nbsp;- 1</code></li>\n\t<li><code>actions[i]</code> is one of &quot;Calculator&quot;, &quot;add&quot;, &quot;subtract&quot;, &quot;multiply&quot;, &quot;divide&quot;, &quot;power&quot;, and&nbsp;&quot;getResult&quot;</li>\n\t<li>First action is always &quot;Calculator&quot;</li>\n\t<li>Last action is always &quot;getResult&quot;</li>\n</ul>\n",
        "solutions": [
            {
                "id": 3607740,
                "title": "just-brute-force",
                "content": "\\n# Code\\n```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n      this.result = value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n    this.result += value;\\n    return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n    this.result -= value;\\n    return this;\\n\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n    this.result *= value;\\n    return this;\\n\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n    if (value === 0) {\\n      throw new Error(\"Division by zero is not allowed\");\\n    }\\n    this.result /= value;\\n    return this;\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n    this.result **= value;\\n    return this;\\n\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n      return this.result;\\n   \\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n      this.result = value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n    this.result += value;\\n    return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n    this.result -= value;\\n    return this;\\n\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n    this.result *= value;\\n    return this;\\n\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n    if (value === 0) {\\n      throw new Error(\"Division by zero is not allowed\");\\n    }\\n    this.result /= value;\\n    return this;\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n    this.result **= value;\\n    return this;\\n\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n      return this.result;\\n   \\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613611,
                "title": "javascript-solution",
                "content": "\\n```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n      this.value=value;\\n\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n      this.value+=value;\\n      return this;\\n\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n      this.value-=value;\\n      return this;\\n\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n      this.value*=value;\\n      return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n      if (value==0){\\n          throw new Error(\\'Division by zero is not allowed\\');\\n      }\\n      this.value/=value;\\n      return this;\\n\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n      this.value=Math.pow(this.value,value);\\n      return this;\\n\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n      return this.value;\\n   \\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n      this.value=value;\\n\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n      this.value+=value;\\n      return this;\\n\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n      this.value-=value;\\n      return this;\\n\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n      this.value*=value;\\n      return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n      if (value==0){\\n          throw new Error(\\'Division by zero is not allowed\\');\\n      }\\n      this.value/=value;\\n      return this;\\n\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n      this.value=Math.pow(this.value,value);\\n      return this;\\n\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n      return this.value;\\n   \\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3616545,
                "title": "javascript-easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n      this.sum = value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n      this.sum += value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n      this.sum -= value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n      this.sum *= value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n      if(value==0){\\n          throw new Error(\"Division by zero is not allowed\");\\n      }\\n      this.sum /= value;\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n      this.sum **= value;\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n      return this.sum;\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n      this.sum = value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n      this.sum += value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n      this.sum -= value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n      this.sum *= value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n      if(value==0){\\n          throw new Error(\"Division by zero is not allowed\");\\n      }\\n      this.sum /= value;\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n      this.sum **= value;\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n      return this.sum;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001322,
                "title": "a-simple-class-solution",
                "content": "# Code\\n```\\nclass Calculator {\\n  constructor(value) {\\n    this.result = value;\\n  }\\n  add(value) {\\n    this.result += value;\\n    return this;\\n  }\\n\\n  subtract(value) {\\n    this.result -= value;\\n    return this;\\n  }\\n\\n  multiply(value) {\\n    this.result *= value;\\n    return this;\\n  }\\n\\n  divide(value) {\\n    if (value === 0) {\\n      throw new Error(\\'Division by zero is not allowed\\');\\n    }\\n    this.result /= value;\\n    return this;\\n  }\\n\\n  power(value) {\\n    this.result = Math.pow(this.result, value);\\n    return this;\\n  }\\n\\n  getResult() {\\n    return this.result;\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Calculator {\\n  constructor(value) {\\n    this.result = value;\\n  }\\n  add(value) {\\n    this.result += value;\\n    return this;\\n  }\\n\\n  subtract(value) {\\n    this.result -= value;\\n    return this;\\n  }\\n\\n  multiply(value) {\\n    this.result *= value;\\n    return this;\\n  }\\n\\n  divide(value) {\\n    if (value === 0) {\\n      throw new Error(\\'Division by zero is not allowed\\');\\n    }\\n    this.result /= value;\\n    return this;\\n  }\\n\\n  power(value) {\\n    this.result = Math.pow(this.result, value);\\n    return this;\\n  }\\n\\n  getResult() {\\n    return this.result;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608433,
                "title": "easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Calculator {\\n  constructor(value) {\\n    this.value = value;\\n  }\\n\\n  add = (value) => {\\n    this.value += value;\\n    return this;\\n  };\\n\\n  subtract = (value) => {\\n    this.value -= value;\\n    return this;\\n  };\\n\\n  multiply = (value) => {\\n    this.value *= value;\\n    return this;\\n  };\\n\\n  divide = (value) => {\\n    if (value === 0) {\\n      throw new Error(\\'Division by zero is not allowed\\');\\n    }\\n    this.value /= value;\\n    return this;\\n  };\\n\\n  power = (value) => {\\n    this.value = Math.pow(this.value, value);\\n    return this;\\n  };\\n\\n  getResult = () => {\\n    return this.value;\\n  };\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Calculator {\\n  constructor(value) {\\n    this.value = value;\\n  }\\n\\n  add = (value) => {\\n    this.value += value;\\n    return this;\\n  };\\n\\n  subtract = (value) => {\\n    this.value -= value;\\n    return this;\\n  };\\n\\n  multiply = (value) => {\\n    this.value *= value;\\n    return this;\\n  };\\n\\n  divide = (value) => {\\n    if (value === 0) {\\n      throw new Error(\\'Division by zero is not allowed\\');\\n    }\\n    this.value /= value;\\n    return this;\\n  };\\n\\n  power = (value) => {\\n    this.value = Math.pow(this.value, value);\\n    return this;\\n  };\\n\\n  getResult = () => {\\n    return this.value;\\n  };\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607264,
                "title": "simple-ts-js-implementation",
                "content": "## TypeScript\\n```\\nclass Calculator {\\n  private result: number\\n\\n  constructor(value : number) {\\n      this.result = value\\n  }\\n    \\n  add(value : number) : Calculator {\\n    this.result += value\\n    return this\\n  }\\n    \\n  subtract(value : number) : Calculator {\\n    this.result -= value\\n    return this\\n  }\\n    \\n  multiply(value : number) : Calculator {\\n    this.result *= value\\n    return this\\n  }\\n\\n  divide(value : number) : Calculator {\\n    if (value == 0)\\n      throw new Error(\"Division by zero is not allowed\");\\n      \\n    this.result /= value\\n    return this\\n  }\\n    \\n  power(value : number) : Calculator {\\n    this.result = Math.pow(this.result, value)\\n    return this\\n  }\\n\\n  getResult() : number {\\n    return this.result\\n  }\\n}\\n```\\n\\n## JavaScript\\n```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n    this.result = value\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n    this.result += value\\n    return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n    this.result -= value\\n    return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n    this.result *= value\\n    return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n    if (value == 0)\\n      throw new Error(\"Division by zero is not allowed\");\\n      \\n    this.result /= value\\n    return this\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n    this.result = Math.pow(this.result, value)\\n    return this\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n    return this.result\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nclass Calculator {\\n  private result: number\\n\\n  constructor(value : number) {\\n      this.result = value\\n  }\\n    \\n  add(value : number) : Calculator {\\n    this.result += value\\n    return this\\n  }\\n    \\n  subtract(value : number) : Calculator {\\n    this.result -= value\\n    return this\\n  }\\n    \\n  multiply(value : number) : Calculator {\\n    this.result *= value\\n    return this\\n  }\\n\\n  divide(value : number) : Calculator {\\n    if (value == 0)\\n      throw new Error(\"Division by zero is not allowed\");\\n      \\n    this.result /= value\\n    return this\\n  }\\n    \\n  power(value : number) : Calculator {\\n    this.result = Math.pow(this.result, value)\\n    return this\\n  }\\n\\n  getResult() : number {\\n    return this.result\\n  }\\n}\\n```\n```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n    this.result = value\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n    this.result += value\\n    return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n    this.result -= value\\n    return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n    this.result *= value\\n    return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n    if (value == 0)\\n      throw new Error(\"Division by zero is not allowed\");\\n      \\n    this.result /= value\\n    return this\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n    this.result = Math.pow(this.result, value)\\n    return this\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n    return this.result\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4100318,
                "title": "best-simple-js-ts-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Calculator {\\n\\tprivate result = 0\\n\\n\\tconstructor(value: number) {\\n\\t\\tthis.result = value;\\n\\t}\\n\\n\\tadd = (value: number): Calculator => new Calculator(this.result + value);\\n\\n\\tsubtract = (value: number): Calculator => new Calculator(this.result - value);\\n\\n\\tmultiply = (value: number): Calculator => new Calculator(this.result * value);\\n\\n\\tdivide = (value: number): Calculator => {\\n\\t\\tif (value !== 0) {\\n\\t\\t\\treturn new Calculator(this.result / value)\\n\\t\\t} else {\\n\\t\\t\\tthrow new Error(\"Division by zero is not allowed\");\\n\\t\\t}\\n\\t};\\n\\n\\tpower = (value: number): Calculator => new Calculator(this.result ** value);\\n\\n\\tgetResult = (): number => this.result;\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass Calculator {\\n\\tprivate result = 0\\n\\n\\tconstructor(value: number) {\\n\\t\\tthis.result = value;\\n\\t}\\n\\n\\tadd = (value: number): Calculator => new Calculator(this.result + value);\\n\\n\\tsubtract = (value: number): Calculator => new Calculator(this.result - value);\\n\\n\\tmultiply = (value: number): Calculator => new Calculator(this.result * value);\\n\\n\\tdivide = (value: number): Calculator => {\\n\\t\\tif (value !== 0) {\\n\\t\\t\\treturn new Calculator(this.result / value)\\n\\t\\t} else {\\n\\t\\t\\tthrow new Error(\"Division by zero is not allowed\");\\n\\t\\t}\\n\\t};\\n\\n\\tpower = (value: number): Calculator => new Calculator(this.result ** value);\\n\\n\\tgetResult = (): number => this.result;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4097246,
                "title": "simple-javascript-solution-96",
                "content": "# 2726. Calculator with Method Chaining\\n\\n\\n## Code\\n```\\nclass Calculator {\\n  \\n\\tconstructor(value) {\\n\\t\\tthis.number = value;\\n\\t}\\n\\n\\tadd(value){\\n\\t\\tthis.number += value;\\n\\t    return this;\\n\\t}\\n\\n\\tsubtract(value){\\n\\t\\tthis.number -= value;\\n\\t\\treturn this;\\n\\t}\\n\\n\\tmultiply(value) {\\n\\t\\tthis.number *= value;\\n\\t\\treturn this;\\n\\t}\\n\\n\\tdivide(value) {\\n\\t\\tif (value === 0) {\\n\\t        throw new Error(\\'Division by zero is not allowed\\');\\n\\t    } else {\\n\\t        this.number /= value;\\n\\t\\t    return this;\\n\\t    }\\n\\t}\\n  \\n\\tpower(value) {\\n\\t\\tthis.number **= value;\\n\\t\\treturn this;\\n\\t}\\n    \\n\\tgetResult() {\\n\\t\\treturn this.number;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Calculator {\\n  \\n\\tconstructor(value) {\\n\\t\\tthis.number = value;\\n\\t}\\n\\n\\tadd(value){\\n\\t\\tthis.number += value;\\n\\t    return this;\\n\\t}\\n\\n\\tsubtract(value){\\n\\t\\tthis.number -= value;\\n\\t\\treturn this;\\n\\t}\\n\\n\\tmultiply(value) {\\n\\t\\tthis.number *= value;\\n\\t\\treturn this;\\n\\t}\\n\\n\\tdivide(value) {\\n\\t\\tif (value === 0) {\\n\\t        throw new Error(\\'Division by zero is not allowed\\');\\n\\t    } else {\\n\\t        this.number /= value;\\n\\t\\t    return this;\\n\\t    }\\n\\t}\\n  \\n\\tpower(value) {\\n\\t\\tthis.number **= value;\\n\\t\\treturn this;\\n\\t}\\n    \\n\\tgetResult() {\\n\\t\\treturn this.number;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085136,
                "title": "best-of-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n    this.result = value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n     this.result += value;\\n     return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n    this.result -= value;\\n    return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n    this.result *= value;\\n    return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n    if (value === 0) {\\n      throw new Error(\\'Division by zero is not allowed\\');\\n    }\\n    this.result /= value;\\n    return this;\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n    this.result = Math.pow(this.result, value);\\n    return this;\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n    return this.result;\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n    this.result = value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n     this.result += value;\\n     return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n    this.result -= value;\\n    return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n    this.result *= value;\\n    return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n    if (value === 0) {\\n      throw new Error(\\'Division by zero is not allowed\\');\\n    }\\n    this.result /= value;\\n    return this;\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n    this.result = Math.pow(this.result, value);\\n    return this;\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n    return this.result;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072507,
                "title": "easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\nthis.value = value\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n this.value += value\\nreturn this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n this.value -= value\\nreturn this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\nthis.value *= value\\nreturn this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n    if(value !== 0){\\nthis.value /= value\\n return this\\n  }else{\\n  throw new Error(\\'Division by zero is not allowed\\')\\n  }\\n  }\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\nthis.value **= value\\nreturn this\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n   return this.value\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\nthis.value = value\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n this.value += value\\nreturn this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n this.value -= value\\nreturn this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\nthis.value *= value\\nreturn this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n    if(value !== 0){\\nthis.value /= value\\n return this\\n  }else{\\n  throw new Error(\\'Division by zero is not allowed\\')\\n  }\\n  }\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\nthis.value **= value\\nreturn this\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n   return this.value\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069038,
                "title": "js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n    this.value = value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n    return new Calculator(this.value + value);\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n    return new Calculator(this.value - value);\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n    return new Calculator(this.value * value);\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n    if (value === 0) throw new Error(\\'Division by zero is not allowed\\');\\n    return new Calculator(this.value / value);\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n    return new Calculator(Math.pow(this.value, value));\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n   return this.value;\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n    this.value = value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n    return new Calculator(this.value + value);\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n    return new Calculator(this.value - value);\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n    return new Calculator(this.value * value);\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n    if (value === 0) throw new Error(\\'Division by zero is not allowed\\');\\n    return new Calculator(this.value / value);\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n    return new Calculator(Math.pow(this.value, value));\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n   return this.value;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4064563,
                "title": "javascript-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n      this.value = value  \\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n    this.value += value\\n    return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n     this.value -= value\\n     return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n    this.value *= value\\n    return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n    if(value === 0){\\n        throw \"Division by zero is not allowed\"\\n    }\\n    this.value /= value\\n    return this\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n    this.value = Math.pow(this.value,value)\\n    return this\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n   return this.value\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n      this.value = value  \\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n    this.value += value\\n    return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n     this.value -= value\\n     return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n    this.value *= value\\n    return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n    if(value === 0){\\n        throw \"Division by zero is not allowed\"\\n    }\\n    this.value /= value\\n    return this\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n    this.value = Math.pow(this.value,value)\\n    return this\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n   return this.value\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4061186,
                "title": "2726-calculator-with-method-chaining",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n  class Calculator {\\n     result = 0;\\n\\n  /**\\n   * @param {number} value\\n   */\\n  constructor(value) {\\n    this.result = value;\\n  }\\n\\n  /**\\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value) {\\n    this.result = this.result + value;\\n    return this;\\n  }\\n\\n  /**\\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value) {\\n    this.result = this.result - value;\\n    return this;\\n  }\\n\\n  /**\\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  multiply(value) {\\n    this.result = this.result * value;\\n    return this;\\n  }\\n\\n  /**\\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n    if (value) {\\n      this.result = this.result / value;\\n    } else {\\n      throw new Error(\"Division by zero is not allowed\");\\n    }\\n    return this;\\n  }\\n\\n  /**\\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n    this.result = Math.pow(this.result, value);\\n    return this\\n  }\\n\\n  /**\\n   * @return {number}\\n   */\\n  getResult() {\\n    return this.result;\\n  }\\n  }\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n  class Calculator {\\n     result = 0;\\n\\n  /**\\n   * @param {number} value\\n   */\\n  constructor(value) {\\n    this.result = value;\\n  }\\n\\n  /**\\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value) {\\n    this.result = this.result + value;\\n    return this;\\n  }\\n\\n  /**\\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value) {\\n    this.result = this.result - value;\\n    return this;\\n  }\\n\\n  /**\\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  multiply(value) {\\n    this.result = this.result * value;\\n    return this;\\n  }\\n\\n  /**\\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n    if (value) {\\n      this.result = this.result / value;\\n    } else {\\n      throw new Error(\"Division by zero is not allowed\");\\n    }\\n    return this;\\n  }\\n\\n  /**\\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n    this.result = Math.pow(this.result, value);\\n    return this\\n  }\\n\\n  /**\\n   * @return {number}\\n   */\\n  getResult() {\\n    return this.result;\\n  }\\n  }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4061098,
                "title": "simple-calculator",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n    this.value = value\\n    return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n      this.value += value\\n      return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n     this.value -= value\\n     return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n    this.value = this.value * value\\n    return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n     if(value ==0) throw new Error(\"Division by zero is not allowed\")\\n     this.value = this.value/value\\n     return this\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n      this.value = this.value ** value\\n     return this\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n   return this.value\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n    this.value = value\\n    return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n      this.value += value\\n      return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n     this.value -= value\\n     return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n    this.value = this.value * value\\n    return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n     if(value ==0) throw new Error(\"Division by zero is not allowed\")\\n     this.value = this.value/value\\n     return this\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n      this.value = this.value ** value\\n     return this\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n   return this.value\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037144,
                "title": "work-done",
                "content": "# Intuition\\nthis is easy with one-liners\\n# Approach\\ncreate a property storing the result. Do operations on that property\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n      this.result = value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n      this.result += value;\\n      return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n      this.result -= value;\\n      return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n      this.result *= value;\\n      return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n      if (!value)\\n        throw \"Division by zero is not allowed\";\\n      this.result /= value;\\n      return this\\n\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n      this.result= Math.pow(this.result,value);\\n      return this;\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n   return this.result;\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n      this.result = value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n      this.result += value;\\n      return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n      this.result -= value;\\n      return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n      this.result *= value;\\n      return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n      if (!value)\\n        throw \"Division by zero is not allowed\";\\n      this.result /= value;\\n      return this\\n\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n      this.result= Math.pow(this.result,value);\\n      return this;\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n   return this.result;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016197,
                "title": "calculator-with-method-chaining-in-js",
                "content": "\\n\\n# Code\\n```\\nclass Calculator {\\n  \\n  add(value){\\n      this.value += value;\\n      return this;\\n  }\\n\\n  subtract(value){\\n      this.value -= value;\\n      return this;\\n  }\\n \\n  multiply(value) {\\n      this.value *= value;\\n      return this;\\n  }\\n\\n  divide(value) {\\n      if (value == 0) {\\n          throw new Error(\"Division by zero is not allowed\");\\n      }\\n      this.value /= value;\\n      return this;\\n  }\\n\\n  power(value) {\\n      let v = this.value;\\n      if (value == 0) {\\n          this.value = 1;\\n          return this;\\n      }\\n      else if (value < 0) {\\n          let denom = 1, v = this.value;\\n          for (var i = 0; i < (value * -1); i++) {\\n              denom *= v;\\n          }\\n          this.value = 1 / denom;\\n          return this;\\n      }\\n      for (var i = 1; i < value; i++) {\\n          this.value *= v;\\n      }\\n      return this;\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n      return this.value;\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Calculator {\\n  \\n  add(value){\\n      this.value += value;\\n      return this;\\n  }\\n\\n  subtract(value){\\n      this.value -= value;\\n      return this;\\n  }\\n \\n  multiply(value) {\\n      this.value *= value;\\n      return this;\\n  }\\n\\n  divide(value) {\\n      if (value == 0) {\\n          throw new Error(\"Division by zero is not allowed\");\\n      }\\n      this.value /= value;\\n      return this;\\n  }\\n\\n  power(value) {\\n      let v = this.value;\\n      if (value == 0) {\\n          this.value = 1;\\n          return this;\\n      }\\n      else if (value < 0) {\\n          let denom = 1, v = this.value;\\n          for (var i = 0; i < (value * -1); i++) {\\n              denom *= v;\\n          }\\n          this.value = 1 / denom;\\n          return this;\\n      }\\n      for (var i = 1; i < value; i++) {\\n          this.value *= v;\\n      }\\n      return this;\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n      return this.value;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4009449,
                "title": "the-10x-approach-builder-pattern",
                "content": "# Intuition\\nThe problem is to design a calculator that can perform basic arithmetic operations. The intuitive solution would be to create methods for each operation. \\n\\nHowever, to make the API more fluent and chainable, we can use the [builder pattern](https://www.google.com/search?q=builder+pattern&oq=builder+pattern&aqs=chrome..69i57j69i59.2480j0j1&sourceid=chrome&ie=UTF-8). This pattern allows us to chain method calls, making the code more readable and expressive.\\n\\n# Approach\\nUsing the builder pattern, each method of the calculator (except for `getResult`) returns the calculator object itself. This allows for chaining of method calls. For instance, one can write `calculator.add(5).subtract(3).multiply(2)` to perform a series of operations.\\n\\n# Complexity\\n- Time complexity:\\n  - All operations (`add`, `subtract`, `multiply`, `divide`, `power`) are \\\\(O(1)\\\\) as they perform constant time arithmetic operations.\\n  \\n- Space complexity:\\n  - The space complexity is \\\\(O(1)\\\\) as the calculator only maintains a single number (`value`) irrespective of the number of operations performed.\\n\\n# Code\\n```typescript\\nclass Calculator {\\n    value: number\\n\\n    constructor(value: number) {\\n        this.value = value;\\n    }\\n    \\n    add(value: number): Calculator {\\n        this.value += value;\\n        return this;\\n    }\\n    \\n    subtract(value: number): Calculator {\\n        this.value -= value;\\n        return this;\\n    }\\n    \\n    multiply(value: number): Calculator {\\n        this.value *= value;\\n        return this;\\n    }\\n\\n    divide(value: number): Calculator {\\n        if (value === 0) throw new Error(\"Division by zero is not allowed\");\\n        this.value /= value;\\n        return this;\\n    }\\n    \\n    power(value: number): Calculator {\\n        this.value = Math.pow(this.value, value);\\n        return this;\\n    }\\n\\n    getResult(): number {\\n        return this.value;\\n    }\\n}\\n",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "# Intuition\\nThe problem is to design a calculator that can perform basic arithmetic operations. The intuitive solution would be to create methods for each operation. \\n\\nHowever, to make the API more fluent and chainable, we can use the [builder pattern](https://www.google.com/search?q=builder+pattern&oq=builder+pattern&aqs=chrome..69i57j69i59.2480j0j1&sourceid=chrome&ie=UTF-8). This pattern allows us to chain method calls, making the code more readable and expressive.\\n\\n# Approach\\nUsing the builder pattern, each method of the calculator (except for `getResult`) returns the calculator object itself. This allows for chaining of method calls. For instance, one can write `calculator.add(5).subtract(3).multiply(2)` to perform a series of operations.\\n\\n# Complexity\\n- Time complexity:\\n  - All operations (`add`, `subtract`, `multiply`, `divide`, `power`) are \\\\(O(1)\\\\) as they perform constant time arithmetic operations.\\n  \\n- Space complexity:\\n  - The space complexity is \\\\(O(1)\\\\) as the calculator only maintains a single number (`value`) irrespective of the number of operations performed.\\n\\n# Code\\n```typescript\\nclass Calculator {\\n    value: number\\n\\n    constructor(value: number) {\\n        this.value = value;\\n    }\\n    \\n    add(value: number): Calculator {\\n        this.value += value;\\n        return this;\\n    }\\n    \\n    subtract(value: number): Calculator {\\n        this.value -= value;\\n        return this;\\n    }\\n    \\n    multiply(value: number): Calculator {\\n        this.value *= value;\\n        return this;\\n    }\\n\\n    divide(value: number): Calculator {\\n        if (value === 0) throw new Error(\"Division by zero is not allowed\");\\n        this.value /= value;\\n        return this;\\n    }\\n    \\n    power(value: number): Calculator {\\n        this.value = Math.pow(this.value, value);\\n        return this;\\n    }\\n\\n    getResult(): number {\\n        return this.value;\\n    }\\n}\\n",
                "codeTag": "Java"
            },
            {
                "id": 4008568,
                "title": "typescript-solution",
                "content": "```ts\\nclass Calculator {\\n  private value: number;\\n    \\n  constructor(value : number) {\\n    this.value = value;\\n  }\\n    \\n  add(value : number) : Calculator {\\n    const result = this.value + value;\\n    return new Calculator(result);\\n  }\\n    \\n  subtract(value : number) : Calculator {\\n    const result = this.value - value;\\n    return new Calculator(result);\\n  }\\n    \\n  multiply(value : number) : Calculator {\\n    const result = this.value * value;\\n    return new Calculator(result);\\n  }\\n\\n  divide(value : number) : Calculator {\\n    if(value == 0) throw Error(\\'Division by zero is not allowed\\');\\n    const result = this.value / value;\\n    return new Calculator(result);\\n  }\\n    \\n  power(value : number) : Calculator {\\n    const result = this.value ** value;\\n    return new Calculator(result);\\n  }\\n\\n  getResult() : number {\\n   return this.value;\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```ts\\nclass Calculator {\\n  private value: number;\\n    \\n  constructor(value : number) {\\n    this.value = value;\\n  }\\n    \\n  add(value : number) : Calculator {\\n    const result = this.value + value;\\n    return new Calculator(result);\\n  }\\n    \\n  subtract(value : number) : Calculator {\\n    const result = this.value - value;\\n    return new Calculator(result);\\n  }\\n    \\n  multiply(value : number) : Calculator {\\n    const result = this.value * value;\\n    return new Calculator(result);\\n  }\\n\\n  divide(value : number) : Calculator {\\n    if(value == 0) throw Error(\\'Division by zero is not allowed\\');\\n    const result = this.value / value;\\n    return new Calculator(result);\\n  }\\n    \\n  power(value : number) : Calculator {\\n    const result = this.value ** value;\\n    return new Calculator(result);\\n  }\\n\\n  getResult() : number {\\n   return this.value;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4008062,
                "title": "super-easy-to-understand",
                "content": "# Code\\n```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n      this.result = value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n      this.result += value;\\n      return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n      this.result -= value;\\n      return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n      this.result *= value;\\n      return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n      if(value === 0){\\n          throw new Error( \"Division by zero is not allowed\");\\n      }\\n      this.result /= value;\\n      return this;\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n      this.result = this.result ** value;\\n      return this;\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n      return this.result;\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n      this.result = value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n      this.result += value;\\n      return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n      this.result -= value;\\n      return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n      this.result *= value;\\n      return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n      if(value === 0){\\n          throw new Error( \"Division by zero is not allowed\");\\n      }\\n      this.result /= value;\\n      return this;\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n      this.result = this.result ** value;\\n      return this;\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n      return this.result;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3987321,
                "title": "javascript-simple-solution",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n      this.result = value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n    this.result += value;\\n    return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n    this.result -= value;\\n    return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n    this.result *= value;\\n    return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n    if (value === 0) {\\n      throw new Error(\"Division by zero is not allowed\");\\n    }\\n    this.result /= value;\\n    return this;\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n    this.result **= value;\\n    return this;\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n      return this.result;\\n  }\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n      this.result = value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n    this.result += value;\\n    return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n    this.result -= value;\\n    return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n    this.result *= value;\\n    return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n    if (value === 0) {\\n      throw new Error(\"Division by zero is not allowed\");\\n    }\\n    this.result /= value;\\n    return this;\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n    this.result **= value;\\n    return this;\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n      return this.result;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977727,
                "title": "javascript-runtime-45ms-beats-90-16",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n     this.value=value\\n    }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n       this.value+=value\\n       return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n    this.value-=value\\n    return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n    this.value*=value\\n    return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n\\n    if(value===0) throw \\'Division by zero is not allowed\\'\\n\\n     this.value/=value\\n    return this\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n    this.value**=value\\n    return this\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n   return this.value\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n     this.value=value\\n    }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n       this.value+=value\\n       return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n    this.value-=value\\n    return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n    this.value*=value\\n    return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n\\n    if(value===0) throw \\'Division by zero is not allowed\\'\\n\\n     this.value/=value\\n    return this\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n    this.value**=value\\n    return this\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n   return this.value\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3967913,
                "title": "typescript-solution-above-99-88-runtime",
                "content": "\\n![image.png](https://assets.leetcode.com/users/images/a7511550-32a3-4ff0-b601-4623ae8301d4_1693148419.9230454.png)\\n\\n# Code\\n```\\nclass Calculator {\\n    public result: number\\n    constructor(value: number) {\\n        this.result = value\\n    }\\n\\n    add(value: number): Calculator {\\n        this.result += value\\n        return this\\n    }\\n\\n    subtract(value: number): Calculator {\\n        this.result -= value\\n        return this\\n    }\\n\\n    multiply(value: number): Calculator {\\n        this.result *= value\\n        return this\\n    }\\n\\n    divide(value: number): Calculator {\\n        if (value == 0)\\n            throw new Error(\"Division by zero is not allowed\")\\n        this.result /= value\\n        return this\\n    }\\n\\n    power(value: number): Calculator {\\n        this.result **= value\\n        return this\\n    }\\n\\n    getResult(): number {\\n        return this.result\\n    }\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass Calculator {\\n    public result: number\\n    constructor(value: number) {\\n        this.result = value\\n    }\\n\\n    add(value: number): Calculator {\\n        this.result += value\\n        return this\\n    }\\n\\n    subtract(value: number): Calculator {\\n        this.result -= value\\n        return this\\n    }\\n\\n    multiply(value: number): Calculator {\\n        this.result *= value\\n        return this\\n    }\\n\\n    divide(value: number): Calculator {\\n        if (value == 0)\\n            throw new Error(\"Division by zero is not allowed\")\\n        this.result /= value\\n        return this\\n    }\\n\\n    power(value: number): Calculator {\\n        this.result **= value\\n        return this\\n    }\\n\\n    getResult(): number {\\n        return this.result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962961,
                "title": "simple-solution-with-minimal-code-no-return-this-every-time",
                "content": "# Intuition\\nThese approach emphasizes achieving **performance with minimal code**.\\n\\nPlease **Upvote** if you find helpful.\\n\\n\\n# Code\\n```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n      this.result = value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add = (value) => (this.result += value, this);\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract = (value) => (this.result -= value, this);\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply = (value) => (this.result *= value, this);\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide = (value) => {\\n        if(value == 0) throw \"Division by zero is not allowed\";\\n        return (this.result /= value, this);\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power = (value) => (this.result **= value, this);\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult = () => this.result;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n      this.result = value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add = (value) => (this.result += value, this);\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract = (value) => (this.result -= value, this);\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply = (value) => (this.result *= value, this);\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide = (value) => {\\n        if(value == 0) throw \"Division by zero is not allowed\";\\n        return (this.result /= value, this);\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power = (value) => (this.result **= value, this);\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult = () => this.result;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962880,
                "title": "simple-solution",
                "content": "```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n      this.value = value\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n      this.value += value\\n      return new Calculator(this.value)\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n      this.value -= value\\n      return new Calculator(this.value)\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n       this.value = this.value * value\\n      return new Calculator(this.value)\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n      if (!value) throw new Error(\\'Division by zero is not allowed\\')\\n\\n      this.value = this.value / value\\n      return new Calculator(this.value)\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n      this.value = this.value**value\\n      return new Calculator(this.value)\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n   return this.value\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n      this.value = value\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n      this.value += value\\n      return new Calculator(this.value)\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n      this.value -= value\\n      return new Calculator(this.value)\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n       this.value = this.value * value\\n      return new Calculator(this.value)\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n      if (!value) throw new Error(\\'Division by zero is not allowed\\')\\n\\n      this.value = this.value / value\\n      return new Calculator(this.value)\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n      this.value = this.value**value\\n      return new Calculator(this.value)\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n   return this.value\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3955647,
                "title": "js-basic-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n      this.res=value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n      this.res=this.res+value;\\n      return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n      this.res=this.res-value;\\n      return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n    this.res=this.res*value;\\n    return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n      if(value==0){\\n          throw new Error(\"Division by zero is not allowed\");\\n          return;\\n      }\\n      this.res=this.res/value;\\n      return this;\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n      this.res=this.res**value;\\n      return this;\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n      return this.res;\\n  }\\n\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n      this.res=value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n      this.res=this.res+value;\\n      return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n      this.res=this.res-value;\\n      return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n    this.res=this.res*value;\\n    return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n      if(value==0){\\n          throw new Error(\"Division by zero is not allowed\");\\n          return;\\n      }\\n      this.res=this.res/value;\\n      return this;\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n      this.res=this.res**value;\\n      return this;\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n      return this.res;\\n  }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944876,
                "title": "easy-solution",
                "content": "\\n# Code\\n```\\nclass Calculator {\\n  // The constructor takes a number as the initial value of result\\n  constructor(value) {\\n    // Store the result as a property of the Calculator object\\n    this.result = value;\\n  }\\n\\n  // The add method adds the given value to the result and returns the updated Calculator\\n  add(value) {\\n    this.result += value;\\n    return this;\\n  }\\n\\n  // The subtract method subtracts the given value from the result and returns the updated Calculator\\n  subtract(value) {\\n    this.result -= value;\\n    return this;\\n  }\\n\\n  // The multiply method multiplies the result by the given value and returns the updated Calculator\\n  multiply(value) {\\n    this.result *= value;\\n    return this;\\n  }\\n\\n  // The divide method divides the result by the given value and returns the updated Calculator\\n  divide(value) {\\n    // If the passed value is 0, throw an error\\n    if (value === 0) {\\n      throw new Error(\"Division by zero is not allowed\");\\n    }\\n    this.result /= value;\\n    return this;\\n  }\\n\\n  // The power method raises the result to the power of the given value and returns the updated Calculator\\n  power(value) {\\n    this.result = Math.pow(this.result, value);\\n    return this;\\n  }\\n\\n  // The getResult method returns the result\\n  getResult() {\\n    return this.result;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Calculator {\\n  // The constructor takes a number as the initial value of result\\n  constructor(value) {\\n    // Store the result as a property of the Calculator object\\n    this.result = value;\\n  }\\n\\n  // The add method adds the given value to the result and returns the updated Calculator\\n  add(value) {\\n    this.result += value;\\n    return this;\\n  }\\n\\n  // The subtract method subtracts the given value from the result and returns the updated Calculator\\n  subtract(value) {\\n    this.result -= value;\\n    return this;\\n  }\\n\\n  // The multiply method multiplies the result by the given value and returns the updated Calculator\\n  multiply(value) {\\n    this.result *= value;\\n    return this;\\n  }\\n\\n  // The divide method divides the result by the given value and returns the updated Calculator\\n  divide(value) {\\n    // If the passed value is 0, throw an error\\n    if (value === 0) {\\n      throw new Error(\"Division by zero is not allowed\");\\n    }\\n    this.result /= value;\\n    return this;\\n  }\\n\\n  // The power method raises the result to the power of the given value and returns the updated Calculator\\n  power(value) {\\n    this.result = Math.pow(this.result, value);\\n    return this;\\n  }\\n\\n  // The getResult method returns the result\\n  getResult() {\\n    return this.result;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942591,
                "title": "basic-logic",
                "content": "# Code\\n```\\nclass Calculator {\\n  constructor(value) {\\n    this.result = value;\\n  }\\n  add(value){\\n    this.result += value;\\n    return this;\\n  }\\n  subtract(value){\\n    this.result -= value;\\n    return this;\\n  }  \\n  multiply(value) {\\n    this.result *= value;\\n    return this;\\n  }\\n  divide(value) {\\n    if (value === 0) throw new Error(\"Division by zero is not allowed\") \\n    this.result /= value;\\n    return this;\\n  }\\n  power(value) {\\n    this.result = Math.pow(this.result, value);\\n    return this;\\n  }\\n  getResult() {\\n    return this.result;\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Calculator {\\n  constructor(value) {\\n    this.result = value;\\n  }\\n  add(value){\\n    this.result += value;\\n    return this;\\n  }\\n  subtract(value){\\n    this.result -= value;\\n    return this;\\n  }  \\n  multiply(value) {\\n    this.result *= value;\\n    return this;\\n  }\\n  divide(value) {\\n    if (value === 0) throw new Error(\"Division by zero is not allowed\") \\n    this.result /= value;\\n    return this;\\n  }\\n  power(value) {\\n    this.result = Math.pow(this.result, value);\\n    return this;\\n  }\\n  getResult() {\\n    return this.result;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3932767,
                "title": "typescript-minimalistic-solution",
                "content": "# Complexity\\n- Time complexity: $O(1)$\\n- Space complexity: $O(1)$\\n\\n# Code\\n```\\nclass Calculator {\\n    \\n  constructor( private value : number) {}\\n    \\n  add(value : number) : Calculator {\\n      this.value += value; return this;\\n  }\\n    \\n  subtract(value : number) : Calculator {\\n      this.value -= value; return this;\\n  }\\n    \\n  multiply(value : number) : Calculator {\\n      this.value *= value; return this;\\n  }\\n\\n  divide(value : number) : Calculator {\\n      if ( !value ) throw new Error( \\'Division by zero is not allowed\\' );\\n      this.value /= value; return this;\\n  }\\n    \\n  power(value : number) : Calculator {\\n      this.value **= value; return this;\\n  }\\n\\n  getResult() : number {\\n      return this.value;\\n  }\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass Calculator {\\n    \\n  constructor( private value : number) {}\\n    \\n  add(value : number) : Calculator {\\n      this.value += value; return this;\\n  }\\n    \\n  subtract(value : number) : Calculator {\\n      this.value -= value; return this;\\n  }\\n    \\n  multiply(value : number) : Calculator {\\n      this.value *= value; return this;\\n  }\\n\\n  divide(value : number) : Calculator {\\n      if ( !value ) throw new Error( \\'Division by zero is not allowed\\' );\\n      this.value /= value; return this;\\n  }\\n    \\n  power(value : number) : Calculator {\\n      this.value **= value; return this;\\n  }\\n\\n  getResult() : number {\\n      return this.value;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919111,
                "title": "typescript-solution",
                "content": "# Code\\n```\\nclass Calculator {\\n  val: number\\n  \\n  constructor(value : number) {\\n    this.val = value;\\n  }\\n    \\n  add(value : number) : Calculator {\\n    this.val += value;\\n    return this;\\n  }\\n    \\n  subtract(value : number) : Calculator {\\n    this.val -= value;\\n    return this;\\n  }\\n    \\n  multiply(value : number) : Calculator {\\n    this.val *= value;\\n    return this;\\n  }\\n\\n  divide(value : number) : Calculator {\\n    if (value === 0) throw new Error(\"Division by zero is not allowed\");\\n    this.val /= value;\\n    return this;\\n  }\\n    \\n  power(value : number) : Calculator {\\n    this.val **= value;\\n    return this;\\n  }\\n\\n  getResult() : number {\\n   return this.val;\\n  }\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass Calculator {\\n  val: number\\n  \\n  constructor(value : number) {\\n    this.val = value;\\n  }\\n    \\n  add(value : number) : Calculator {\\n    this.val += value;\\n    return this;\\n  }\\n    \\n  subtract(value : number) : Calculator {\\n    this.val -= value;\\n    return this;\\n  }\\n    \\n  multiply(value : number) : Calculator {\\n    this.val *= value;\\n    return this;\\n  }\\n\\n  divide(value : number) : Calculator {\\n    if (value === 0) throw new Error(\"Division by zero is not allowed\");\\n    this.val /= value;\\n    return this;\\n  }\\n    \\n  power(value : number) : Calculator {\\n    this.val **= value;\\n    return this;\\n  }\\n\\n  getResult() : number {\\n   return this.val;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911353,
                "title": "easy-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n    this.ans=value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n      this.ans+=value;\\n    return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n      this.ans-=value;\\nreturn this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n      this.ans*=value;\\nreturn this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n    if (value === 0) {\\n      throw new Error(\"Division by zero is not allowed\");\\n    }\\n      this.ans/=value;\\nreturn this;\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n      this.ans=this.ans**value;\\nreturn this;\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n   return this.ans;\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n    this.ans=value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n      this.ans+=value;\\n    return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n      this.ans-=value;\\nreturn this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n      this.ans*=value;\\nreturn this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n    if (value === 0) {\\n      throw new Error(\"Division by zero is not allowed\");\\n    }\\n      this.ans/=value;\\nreturn this;\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n      this.ans=this.ans**value;\\nreturn this;\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n   return this.ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3909495,
                "title": "javascript-solution-with-simple-explaination",
                "content": "you may ask why we return the `this` keyword in each function except for the `getResult` function. the reason is because after the computation is done, we want to return the object itself and to refer to the object itself we use the `this` keyword.\\n\\n# Code\\n```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n      this.sum = value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n      this.sum += value;\\n      return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){  \\n    this.sum -= value;\\n    return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n      this.sum *= value;\\n      return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n      if (value == 0) throw new Error(\"Division by zero is not allowed\");\\n      this.sum /= value;\\n      return this;\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n      this.sum **= value;\\n      return this;\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n      return this.sum;\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n      this.sum = value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n      this.sum += value;\\n      return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){  \\n    this.sum -= value;\\n    return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n      this.sum *= value;\\n      return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n      if (value == 0) throw new Error(\"Division by zero is not allowed\");\\n      this.sum /= value;\\n      return this;\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n      this.sum **= value;\\n      return this;\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n      return this.sum;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3909057,
                "title": "javascript-solution-super-easy-to-understand-beats-98-23",
                "content": "```javascript\\nclass Calculator {\\n  #result;\\n\\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n    this.#result = value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n    this.#result += value;\\n    return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n    this.#result -= value;\\n    return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n    this.#result *= value;\\n    return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n    if (value === 0) {\\n        throw new Error(\"Division by zero is not allowed\");\\n    }\\n    this.#result /= value;\\n    return this;\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n    this.#result **= value;\\n    return this;\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n   return this.#result;\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Design"
                ],
                "code": "```javascript\\nclass Calculator {\\n  #result;\\n\\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n    this.#result = value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n    this.#result += value;\\n    return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n    this.#result -= value;\\n    return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n    this.#result *= value;\\n    return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n    if (value === 0) {\\n        throw new Error(\"Division by zero is not allowed\");\\n    }\\n    this.#result /= value;\\n    return this;\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n    this.#result **= value;\\n    return this;\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n   return this.#result;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3907369,
                "title": "js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\nthis.result=value\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\nthis.result=this.result+value\\nreturn this\\n\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\nthis.result=this.result-value\\nreturn this\\n\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\nthis.result=this.result*value\\nreturn this\\n\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n     if(value==0){\\n          throw new Error(\"Division by zero is not allowed\");\\n      }\\nthis.result=this.result/value\\nreturn this\\n\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\nthis.result=this.result**value\\nreturn this\\n\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n   return this.result\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\nthis.result=value\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\nthis.result=this.result+value\\nreturn this\\n\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\nthis.result=this.result-value\\nreturn this\\n\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\nthis.result=this.result*value\\nreturn this\\n\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n     if(value==0){\\n          throw new Error(\"Division by zero is not allowed\");\\n      }\\nthis.result=this.result/value\\nreturn this\\n\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\nthis.result=this.result**value\\nreturn this\\n\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n   return this.result\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889978,
                "title": "2726-calculator-with-method-chaining",
                "content": "# Code\\n```\\nclass Calculator {\\n  _value;\\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n    this._value = value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n    this._value += value;\\n    return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n    this._value -= value\\n    return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n    this._value *= value\\n    return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n    if (value == 0) throw (\"Division by zero is not allowed\");\\n    this._value /= value;\\n    return this;\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n      this._value **= value;\\n      return this;\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n      return this._value;\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Calculator {\\n  _value;\\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n    this._value = value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n    this._value += value;\\n    return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n    this._value -= value\\n    return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n    this._value *= value\\n    return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n    if (value == 0) throw (\"Division by zero is not allowed\");\\n    this._value /= value;\\n    return this;\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n      this._value **= value;\\n      return this;\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n      return this._value;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889020,
                "title": "method-chaining-calculator-with-mathematical-operations",
                "content": "# Intuition and Approach:\\nThe intuition behind the solution is to design a Calculator class with methods that perform different mathematical operations on the result. The methods are designed to return the Calculator instance (this) to allow consecutive operations using method chaining.\\n\\n# Time Complexity:\\nThe time complexity of each operation (add, subtract, multiply, divide, power) is constant (O(1)), as they involve simple arithmetic operations.\\n\\n# Space Complexity:\\nThe space complexity is influenced by the storage of the Calculator instance and the result. Since the class stores a single instance of result, the space complexity remains constant (O(1)).\\n\\n# Code\\n```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n    this.result = value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n    this.result += value;\\n    return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n    this.result -= value;\\n    return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n    this.result *= value;\\n    return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n  if(value === 0){\\n      throw new Error(\"Division by zero is not allowed\");\\n  }\\n  this.result /= value;\\n  return this;\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n      this.result **= value;\\n      return this;\\n\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n   return this.result;\\n  }\\n}\\n```\\n\\nThe Calculator class provides a convenient way to perform mathematical operations on an initial value using method chaining. The solution demonstrates a clear and modular approach to designing a class that encapsulates mathematical calculations while allowing for easy chaining of operations.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n    this.result = value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n    this.result += value;\\n    return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n    this.result -= value;\\n    return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n    this.result *= value;\\n    return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n  if(value === 0){\\n      throw new Error(\"Division by zero is not allowed\");\\n  }\\n  this.result /= value;\\n  return this;\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n      this.result **= value;\\n      return this;\\n\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n   return this.result;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3880786,
                "title": "accepted-javascript",
                "content": "```\\nclass Calculator {\\n\\n  constructor(value) { this.result = value; }\\n  \\n  getResult() { return this.result; }\\n\\n  add(value)      { return new Calculator(this.result + value); }\\n  subtract(value) { return new Calculator(this.result - value); }\\n  multiply(value) { return new Calculator(this.result * value); }\\n  power(value)    { return new Calculator(Math.pow(this.result, value)); }\\n\\n  divide(value) {\\n    if (value == 0) { throw \"Division by zero is not allowed\"; }\\n    else { return new Calculator(this.result / value); }\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Calculator {\\n\\n  constructor(value) { this.result = value; }\\n  \\n  getResult() { return this.result; }\\n\\n  add(value)      { return new Calculator(this.result + value); }\\n  subtract(value) { return new Calculator(this.result - value); }\\n  multiply(value) { return new Calculator(this.result * value); }\\n  power(value)    { return new Calculator(Math.pow(this.result, value)); }\\n\\n  divide(value) {\\n    if (value == 0) { throw \"Division by zero is not allowed\"; }\\n    else { return new Calculator(this.result / value); }\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879537,
                "title": "0-0-1-sorry-not-sorry",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n      this.result = value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n    this.result += value;\\n    return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n    this.result -= value;\\n    return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n    this.result *= value;\\n    return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n      if (value === 0) throw (\"Division by zero is not allowed\");\\n      this.result /= value;\\n      return this;\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n    //if (this.result === 0  && value <= 0) throw (\"Division by zero is not allowed\");\\n    // 0^0=1? #fakemath\\n    this.result **= value;\\n    return this;\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n   return this.result;\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n      this.result = value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n    this.result += value;\\n    return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n    this.result -= value;\\n    return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n    this.result *= value;\\n    return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n      if (value === 0) throw (\"Division by zero is not allowed\");\\n      this.result /= value;\\n      return this;\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n    //if (this.result === 0  && value <= 0) throw (\"Division by zero is not allowed\");\\n    // 0^0=1? #fakemath\\n    this.result **= value;\\n    return this;\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n   return this.result;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860916,
                "title": "simple-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n  this.base =  value\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\nthis.base = this.base + value;\\nreturn new Calculator(this.base);\\n\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\nthis.base = this.base - value;\\nreturn new Calculator(this.base);\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\nthis.base =  this.base * value;\\nreturn new Calculator(this.base);\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n    if(value == 0) throw new Error(\"Division by zero is not allowed\");\\nthis.base = this.base/value;\\nreturn new Calculator(this.base);\\nt\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n      this.base = Math.pow(this.base,value);\\nreturn new Calculator(this.base);\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n   return this.base;\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n  this.base =  value\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\nthis.base = this.base + value;\\nreturn new Calculator(this.base);\\n\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\nthis.base = this.base - value;\\nreturn new Calculator(this.base);\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\nthis.base =  this.base * value;\\nreturn new Calculator(this.base);\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n    if(value == 0) throw new Error(\"Division by zero is not allowed\");\\nthis.base = this.base/value;\\nreturn new Calculator(this.base);\\nt\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n      this.base = Math.pow(this.base,value);\\nreturn new Calculator(this.base);\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n   return this.base;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840572,
                "title": "calculator-with-method-chaining-straightforward-easy",
                "content": "\\n\\n# Code\\n```\\nclass Calculator {\\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n    this.result = value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n    this.result += value;\\n    return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n    this.result -= value;\\n    return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n    this.result *= value;\\n    return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n    if (value === 0) {\\n      throw new Error(\"Division by zero is not allowed\");\\n    }\\n    this.result /= value;\\n    return this;\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n    this.result **= value;\\n    return this;\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n    return this.result;\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Calculator {\\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n    this.result = value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n    this.result += value;\\n    return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n    this.result -= value;\\n    return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n    this.result *= value;\\n    return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n    if (value === 0) {\\n      throw new Error(\"Division by zero is not allowed\");\\n    }\\n    this.result /= value;\\n    return this;\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n    this.result **= value;\\n    return this;\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n    return this.result;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838476,
                "title": "beats-100",
                "content": "\\n```\\nclass Calculator {\\n  constructor(value) {\\n    this.result = value;\\n  }\\n  add(value) {\\n    this.result += value;\\n    return this;\\n  }\\n  subtract(value) {\\n    this.result -= value;\\n    return this;\\n  }\\n  multiply(value) {\\n    this.result *= value;\\n    return this;\\n  }\\n  divide(value) {\\n    if (value === 0) {\\n      throw new Error(\"Division by zero is not allowed\");\\n    }\\n    this.result /= value;\\n    return this;\\n  }\\n  power(value) {\\n    this.result = Math.pow(this.result, value);\\n    return this;\\n  }\\n  getResult() {\\n    return this.result;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Calculator {\\n  constructor(value) {\\n    this.result = value;\\n  }\\n  add(value) {\\n    this.result += value;\\n    return this;\\n  }\\n  subtract(value) {\\n    this.result -= value;\\n    return this;\\n  }\\n  multiply(value) {\\n    this.result *= value;\\n    return this;\\n  }\\n  divide(value) {\\n    if (value === 0) {\\n      throw new Error(\"Division by zero is not allowed\");\\n    }\\n    this.result /= value;\\n    return this;\\n  }\\n  power(value) {\\n    this.result = Math.pow(this.result, value);\\n    return this;\\n  }\\n  getResult() {\\n    return this.result;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3830881,
                "title": "calculator",
                "content": "# Code\\n```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n      this.value = value\\n  }\\n   \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n     this.value = this.value + value\\n     return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n       this.value = this.value - value\\n       return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n    this.value = this.value * value\\n    return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n       if(value==0){\\n          throw new Error(\"Division by zero is not allowed\")\\n       }else{\\n          this.value = this.value / value\\n          return this\\n       }\\n       \\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n       this.value = Math.pow(this.value,value)\\n       return this\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n     return this.value\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n      this.value = value\\n  }\\n   \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n     this.value = this.value + value\\n     return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n       this.value = this.value - value\\n       return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n    this.value = this.value * value\\n    return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n       if(value==0){\\n          throw new Error(\"Division by zero is not allowed\")\\n       }else{\\n          this.value = this.value / value\\n          return this\\n       }\\n       \\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n       this.value = Math.pow(this.value,value)\\n       return this\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n     return this.value\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821950,
                "title": "clean-typescript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Calculator {\\n  constructor(private value : number) {}\\n    \\n  add(value : number) : Calculator {\\n      this.value += value;\\n\\n      return this;\\n  }\\n    \\n  subtract(value : number) : Calculator {\\n      this.value -= value;\\n\\n      return this;\\n  }\\n    \\n  multiply(value : number) : Calculator {\\n      this.value *= value;\\n\\n      return this;\\n  }\\n\\n  divide(value : number) : Calculator {\\n      if (!value) {\\n          throw new Error(\\'Division by zero is not allowed\\');\\n      }\\n      \\n      this.value /= value;\\n\\n      return this;\\n  }\\n    \\n  power(value : number) : Calculator {\\n      this.value **= value;\\n\\n      return this;\\n  }\\n\\n  getResult() : number {\\n      return this.value;\\n  }\\n}\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Math"
                ],
                "code": "```\\nclass Calculator {\\n  constructor(private value : number) {}\\n    \\n  add(value : number) : Calculator {\\n      this.value += value;\\n\\n      return this;\\n  }\\n    \\n  subtract(value : number) : Calculator {\\n      this.value -= value;\\n\\n      return this;\\n  }\\n    \\n  multiply(value : number) : Calculator {\\n      this.value *= value;\\n\\n      return this;\\n  }\\n\\n  divide(value : number) : Calculator {\\n      if (!value) {\\n          throw new Error(\\'Division by zero is not allowed\\');\\n      }\\n      \\n      this.value /= value;\\n\\n      return this;\\n  }\\n    \\n  power(value : number) : Calculator {\\n      this.value **= value;\\n\\n      return this;\\n  }\\n\\n  getResult() : number {\\n      return this.value;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3816126,
                "title": "calculator-class-beginner-friendly-simplified",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n      this.result = value\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n      this.result += value\\n      return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n      this.result -= value\\n      return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n       this.result *= value\\n       return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @ {Calculator}\\n   */\\n  divide(value) {   \\n      if(value==0) throw Error(\"Division by zero is not allowed\") \\n       this.result /= value\\n       return this\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @ {Calculator}\\n   */\\n  power(value) {\\n       this.result = Math.pow(this.result,value)\\n       return this\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n    return this.result\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n      this.result = value\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n      this.result += value\\n      return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n      this.result -= value\\n      return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n       this.result *= value\\n       return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @ {Calculator}\\n   */\\n  divide(value) {   \\n      if(value==0) throw Error(\"Division by zero is not allowed\") \\n       this.result /= value\\n       return this\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @ {Calculator}\\n   */\\n  power(value) {\\n       this.result = Math.pow(this.result,value)\\n       return this\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n    return this.result\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3809054,
                "title": "typescript-o-1",
                "content": "# Code\\n```ts\\nclass Calculator {\\n    private result: number;\\n    \\n    constructor(value: number) {\\n        this.result = value;\\n    }\\n    \\n    add(value : number) : Calculator {\\n        return new Calculator(this.result + value);\\n    }\\n    \\n    subtract(value : number) : Calculator {\\n        return new Calculator(this.result - value);\\n    }\\n    \\n    multiply(value : number) : Calculator {\\n        return new Calculator(this.result * value);\\n    }\\n\\n    divide(value : number) : Calculator {\\n        if (value === 0) throw new Error(\"Division by zero is not allowed\");\\n\\n        return new Calculator(this.result / value);\\n    }\\n    \\n    power(value : number) : Calculator {\\n        return new Calculator(this.result ** value);\\n    }\\n\\n    getResult() : number {\\n        return this.result;\\n    }\\n}\\n```\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n- Space complexity: $$O(1)$$\\n",
                "solutionTags": [
                    "TypeScript",
                    "Math"
                ],
                "code": "```ts\\nclass Calculator {\\n    private result: number;\\n    \\n    constructor(value: number) {\\n        this.result = value;\\n    }\\n    \\n    add(value : number) : Calculator {\\n        return new Calculator(this.result + value);\\n    }\\n    \\n    subtract(value : number) : Calculator {\\n        return new Calculator(this.result - value);\\n    }\\n    \\n    multiply(value : number) : Calculator {\\n        return new Calculator(this.result * value);\\n    }\\n\\n    divide(value : number) : Calculator {\\n        if (value === 0) throw new Error(\"Division by zero is not allowed\");\\n\\n        return new Calculator(this.result / value);\\n    }\\n    \\n    power(value : number) : Calculator {\\n        return new Calculator(this.result ** value);\\n    }\\n\\n    getResult() : number {\\n        return this.result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3764835,
                "title": "easy-js-solution",
                "content": "# Code\\n```\\nclass Calculator {\\n  constructor(value) {\\n    this.value = value;\\n  }\\n\\n  add(value){\\n    this.value += value;\\n    return this;\\n  }\\n\\n  subtract(value){\\n    this.value -= value;\\n    return this;\\n  }\\n \\n  multiply(value) {\\n    this.value *= value;\\n    return this;\\n  }\\n\\n  divide(value) {\\n    if (value === 0) throw \"Division by zero is not allowed\";\\n    this.value /= value;\\n    return this;\\n  }\\n  \\n  power(value) {\\n    this.value = Math.pow(this.value, value);\\n    return this;\\n  }\\n\\n  getResult() {\\n      return this.value;\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Calculator {\\n  constructor(value) {\\n    this.value = value;\\n  }\\n\\n  add(value){\\n    this.value += value;\\n    return this;\\n  }\\n\\n  subtract(value){\\n    this.value -= value;\\n    return this;\\n  }\\n \\n  multiply(value) {\\n    this.value *= value;\\n    return this;\\n  }\\n\\n  divide(value) {\\n    if (value === 0) throw \"Division by zero is not allowed\";\\n    this.value /= value;\\n    return this;\\n  }\\n  \\n  power(value) {\\n    this.value = Math.pow(this.value, value);\\n    return this;\\n  }\\n\\n  getResult() {\\n      return this.value;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3758412,
                "title": "javascript-solution-using-this-keyword",
                "content": "# Code\\n```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n      this.value = value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n      this.value+=value;\\n      return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n      this.value-=value;\\n      return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n      this.value*=value;\\n      return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n      if(value ==0) {\\n          throw new Error(\"Division by zero is not allowed\");\\n      }\\n      this.value/=value;\\n      return this;\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n      this.value**=value;\\n      return this;\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n      return this.value;\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n      this.value = value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n      this.value+=value;\\n      return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n      this.value-=value;\\n      return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n      this.value*=value;\\n      return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n      if(value ==0) {\\n          throw new Error(\"Division by zero is not allowed\");\\n      }\\n      this.value/=value;\\n      return this;\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n      this.value**=value;\\n      return this;\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n      return this.value;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3749391,
                "title": "2726-calculator-with-method-chaining-umarbek-s-solution",
                "content": "# Code\\n```\\nclass Calculator {\\n  constructor(value) {\\n      this.result = value;\\n  }\\n  add(value){\\n    return this.result +=value, this;\\n  }\\n  subtract(value){\\n    return this.result -= value, this\\n  }\\n  multiply(value) {\\n   return this.result *= value, this;\\n  }\\n  divide(value) {\\n     if(value===0) {\\n          throw new Error(\"Division by zero is not allowed\");\\n      }\\n    return this.result /= value, this;\\n  }\\n  power(value) {\\n    return this.result **= value, this;\\n  }\\n  getResult() {\\n    return this.result;\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Calculator {\\n  constructor(value) {\\n      this.result = value;\\n  }\\n  add(value){\\n    return this.result +=value, this;\\n  }\\n  subtract(value){\\n    return this.result -= value, this\\n  }\\n  multiply(value) {\\n   return this.result *= value, this;\\n  }\\n  divide(value) {\\n     if(value===0) {\\n          throw new Error(\"Division by zero is not allowed\");\\n      }\\n    return this.result /= value, this;\\n  }\\n  power(value) {\\n    return this.result **= value, this;\\n  }\\n  getResult() {\\n    return this.result;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3746169,
                "title": "easy-solution-just-using-this",
                "content": "# Code\\n```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n    this.value = value\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n    this.value = this.value + value\\n    return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n    this.value = this.value - value\\n    return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n    this.value = this.value * value\\n    return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n    if (value === 0) {\\n      throw new Error(\\'Division by zero is not allowed\\');\\n    }\\n    this.value = this.value / value\\n    return this\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n    this.value = Math.pow(this.value, value)\\n    return this\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n    return this.value\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n    this.value = value\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n    this.value = this.value + value\\n    return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n    this.value = this.value - value\\n    return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n    this.value = this.value * value\\n    return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n    if (value === 0) {\\n      throw new Error(\\'Division by zero is not allowed\\');\\n    }\\n    this.value = this.value / value\\n    return this\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n    this.value = Math.pow(this.value, value)\\n    return this\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n    return this.value\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736708,
                "title": "mathod-chaining-invoking-multiple-method-calls-in-object-oriented-programming-languages",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n      this.result=value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n      this.result+=value;\\n      return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n       this.result-=value;\\n       return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n    this.result*=value;\\n    return this;\\n  \\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n    if(value===0)\\n     this.result=\"Division by zero is not allowed\";\\n    else\\n       this.result/=value;\\n    return this;\\n\\n}\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n       this.result=Math.pow(this.result,value);\\n       return this;\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n   return this.result;\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n      this.result=value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n      this.result+=value;\\n      return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n       this.result-=value;\\n       return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n    this.result*=value;\\n    return this;\\n  \\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n    if(value===0)\\n     this.result=\"Division by zero is not allowed\";\\n    else\\n       this.result/=value;\\n    return this;\\n\\n}\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n       this.result=Math.pow(this.result,value);\\n       return this;\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n   return this.result;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734258,
                "title": "js-solution",
                "content": "Return `this` object to allow functions to be chained together.\\n\\n---\\n\\n```\\nclass Calculator {\\n  constructor(x) {\\n    this.x = x;\\n  }\\n  add(x) {\\n    this.x += x;\\n    return this;\\n  }\\n  subtract(x) {\\n    this.x -= x;\\n    return this;\\n  }\\n  multiply(x) {\\n    this.x *= x;\\n    return this;\\n  }\\n  divide(x) {\\n    if (!x)\\n        throw \\'Division by zero is not allowed\\';\\n    this.x /= x;\\n    return this;\\n  }\\n  power(x) {\\n    this.x = Math.pow(this.x, x);\\n    return this;\\n  }\\n  getResult = () => this.x;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Calculator {\\n  constructor(x) {\\n    this.x = x;\\n  }\\n  add(x) {\\n    this.x += x;\\n    return this;\\n  }\\n  subtract(x) {\\n    this.x -= x;\\n    return this;\\n  }\\n  multiply(x) {\\n    this.x *= x;\\n    return this;\\n  }\\n  divide(x) {\\n    if (!x)\\n        throw \\'Division by zero is not allowed\\';\\n    this.x /= x;\\n    return this;\\n  }\\n  power(x) {\\n    this.x = Math.pow(this.x, x);\\n    return this;\\n  }\\n  getResult = () => this.x;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730243,
                "title": "js-easy-calculator-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\nthis.value = value\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\nthis.value += value\\nreturn this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\nthis.value-=value\\nreturn this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\nthis.value *= value\\nreturn this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n      if (value ==0){\\nthrow new Error (\\'Division by zero is not allowed\\')\\n      }\\nthis.value /=value\\nreturn this\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\nthis.value = Math.pow(this.value,value)\\nreturn this\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n   return this.value\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\nthis.value = value\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\nthis.value += value\\nreturn this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\nthis.value-=value\\nreturn this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\nthis.value *= value\\nreturn this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n      if (value ==0){\\nthrow new Error (\\'Division by zero is not allowed\\')\\n      }\\nthis.value /=value\\nreturn this\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\nthis.value = Math.pow(this.value,value)\\nreturn this\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n   return this.value\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3726246,
                "title": "calculator-with-method-chaining",
                "content": "\\n# Code\\n```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n    this.result = value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n    this.result += value;\\n    return this;\\n  };\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n    this.result -= value;\\n        return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n    this.result *= value;\\n        return this;\\n\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n      if(value===0) {\\n          throw new Error(\"Division by zero is not allowed\");\\n      }\\n    this.result /= value;\\n        return this;\\n\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n    this.result **= value;\\n        return this;\\n\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n   return this.result;\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n    this.result = value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n    this.result += value;\\n    return this;\\n  };\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n    this.result -= value;\\n        return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n    this.result *= value;\\n        return this;\\n\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n      if(value===0) {\\n          throw new Error(\"Division by zero is not allowed\");\\n      }\\n    this.result /= value;\\n        return this;\\n\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n    this.result **= value;\\n        return this;\\n\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n   return this.result;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3725585,
                "title": "js-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n\\n  constructor(value) {\\n      this.value = value\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n    this.value+=value;\\n    return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n      this.value = this.value-value;\\n        return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n      this.value*=value\\n          return this;\\n\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n    if(value==0){\\n      throw new Error(\"Division by zero is not allowed\");\\n    }\\n      this.value/=value\\n          return this\\n\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n      this.value = Math.pow(this.value,value);\\n          return this;\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n   return this.value\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n\\n  constructor(value) {\\n      this.value = value\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n    this.value+=value;\\n    return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n      this.value = this.value-value;\\n        return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n      this.value*=value\\n          return this;\\n\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n    if(value==0){\\n      throw new Error(\"Division by zero is not allowed\");\\n    }\\n      this.value/=value\\n          return this\\n\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n      this.value = Math.pow(this.value,value);\\n          return this;\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n   return this.value\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3725584,
                "title": "js-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n\\n  constructor(value) {\\n      this.value = value\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n    this.value+=value;\\n    return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n      this.value = this.value-value;\\n        return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n      this.value*=value\\n          return this;\\n\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n    if(value==0){\\n      throw new Error(\"Division by zero is not allowed\");\\n    }\\n      this.value/=value\\n          return this\\n\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n      this.value = Math.pow(this.value,value);\\n          return this;\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n   return this.value\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n\\n  constructor(value) {\\n      this.value = value\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n    this.value+=value;\\n    return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n      this.value = this.value-value;\\n        return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n      this.value*=value\\n          return this;\\n\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n    if(value==0){\\n      throw new Error(\"Division by zero is not allowed\");\\n    }\\n      this.value/=value\\n          return this\\n\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n      this.value = Math.pow(this.value,value);\\n          return this;\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n   return this.value\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716460,
                "title": "solution-of-calculator-using-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n      this.result = value\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n    this.result  = this.result + value\\n    return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n    this.result  = this.result  - value\\n    return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n    this.result  = this.result * value\\n    return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {  \\n    if(!value) throw new Error(\"Division by zero is not allowed\")\\n      this.result  = this.result / value\\n    return this\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n    this.result  = this.result ** value\\n    return this\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n   return this.result\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n      this.result = value\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n    this.result  = this.result + value\\n    return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n    this.result  = this.result  - value\\n    return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n    this.result  = this.result * value\\n    return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {  \\n    if(!value) throw new Error(\"Division by zero is not allowed\")\\n      this.result  = this.result / value\\n    return this\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n    this.result  = this.result ** value\\n    return this\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n   return this.result\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710540,
                "title": "simple-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n    this.result = value\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n    this.result = this.result+value\\n    return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n    this.result = this.result-value\\n    return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n    this.result = this.result*value\\n    return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n    if(value == 0) throw new Error(\"Division by zero is not allowed\");\\n    this.result = this.result/value;\\n    return this\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n    this.result = this.result**value\\n    return this\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n    return this.result\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n    this.result = value\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n    this.result = this.result+value\\n    return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n    this.result = this.result-value\\n    return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n    this.result = this.result*value\\n    return this\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n    if(value == 0) throw new Error(\"Division by zero is not allowed\");\\n    this.result = this.result/value;\\n    return this\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n    this.result = this.result**value\\n    return this\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n    return this.result\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3695335,
                "title": "simple-ts-js-solution",
                "content": "# Code\\n``` Javascript []\\nclass Calculator {\\n  constructor(value) {\\n        this.value = value\\n  }\\n    \\n  add(value){\\n        this.value += value\\n        return this\\n  }\\n    \\n  subtract(value){\\n        this.value -= value\\n        return this\\n  }\\n    \\n  multiply(value){\\n        this.value *= value\\n        return this\\n  }\\n\\n  divide(value){\\n        if(value !== 0){\\n            this.value /= value\\n            return this\\n        }else{\\n            throw new Error(\"Division by zero is not allowed\")\\n        }\\n  }\\n    \\n  power(value){\\n        this.value **= value\\n        return this\\n  }\\n\\n  getResult() {\\n        return this.value\\n  }\\n}\\n```\\n``` TypeScript []\\nclass Calculator {\\n  constructor(private value : number) {\\n\\n  }\\n    \\n  add(value : number) : Calculator {\\n        this.value += value\\n        return this\\n  }\\n    \\n  subtract(value : number) : Calculator {\\n        this.value -= value\\n        return this\\n  }\\n    \\n  multiply(value : number) : Calculator {\\n        this.value *= value\\n        return this\\n  }\\n\\n  divide(value : number) : Calculator {\\n        if(value !== 0){\\n            this.value /= value\\n            return this\\n        }else{\\n            throw new Error(\"Division by zero is not allowed\")\\n        }\\n  }\\n    \\n  power(value : number) : Calculator {\\n        this.value = this.value ** value\\n        return this\\n  }\\n\\n  getResult() : number {\\n        return this.value\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "``` Javascript []\\nclass Calculator {\\n  constructor(value) {\\n        this.value = value\\n  }\\n    \\n  add(value){\\n        this.value += value\\n        return this\\n  }\\n    \\n  subtract(value){\\n        this.value -= value\\n        return this\\n  }\\n    \\n  multiply(value){\\n        this.value *= value\\n        return this\\n  }\\n\\n  divide(value){\\n        if(value !== 0){\\n            this.value /= value\\n            return this\\n        }else{\\n            throw new Error(\"Division by zero is not allowed\")\\n        }\\n  }\\n    \\n  power(value){\\n        this.value **= value\\n        return this\\n  }\\n\\n  getResult() {\\n        return this.value\\n  }\\n}\\n```\n``` TypeScript []\\nclass Calculator {\\n  constructor(private value : number) {\\n\\n  }\\n    \\n  add(value : number) : Calculator {\\n        this.value += value\\n        return this\\n  }\\n    \\n  subtract(value : number) : Calculator {\\n        this.value -= value\\n        return this\\n  }\\n    \\n  multiply(value : number) : Calculator {\\n        this.value *= value\\n        return this\\n  }\\n\\n  divide(value : number) : Calculator {\\n        if(value !== 0){\\n            this.value /= value\\n            return this\\n        }else{\\n            throw new Error(\"Division by zero is not allowed\")\\n        }\\n  }\\n    \\n  power(value : number) : Calculator {\\n        this.value = this.value ** value\\n        return this\\n  }\\n\\n  getResult() : number {\\n        return this.value\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679720,
                "title": "calculator-with-method-chaining",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Calculator {\\n  /**\\n   * @param {number} value\\n   */\\n  constructor(value) {\\n    this.result = value;\\n  }\\n\\n  /**\\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value) {\\n    this.result += value;\\n    return this;\\n  }\\n\\n  /**\\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value) {\\n    this.result -= value;\\n    return this;\\n  }\\n\\n  /**\\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  multiply(value) {\\n    this.result *= value;\\n    return this;\\n  }\\n\\n  /**\\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n    this.result /= value;\\n    if (value === 0) this.result = \"Division by zero is not allowed\";\\n    return this;\\n  }\\n\\n  /**\\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n    this.result = this.result ** value;\\n    return this;\\n  }\\n\\n  /**\\n   * @return {number}\\n   */\\n  getResult() {\\n    return this.result;\\n  }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Calculator {\\n  /**\\n   * @param {number} value\\n   */\\n  constructor(value) {\\n    this.result = value;\\n  }\\n\\n  /**\\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value) {\\n    this.result += value;\\n    return this;\\n  }\\n\\n  /**\\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value) {\\n    this.result -= value;\\n    return this;\\n  }\\n\\n  /**\\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  multiply(value) {\\n    this.result *= value;\\n    return this;\\n  }\\n\\n  /**\\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n    this.result /= value;\\n    if (value === 0) this.result = \"Division by zero is not allowed\";\\n    return this;\\n  }\\n\\n  /**\\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n    this.result = this.result ** value;\\n    return this;\\n  }\\n\\n  /**\\n   * @return {number}\\n   */\\n  getResult() {\\n    return this.result;\\n  }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3672956,
                "title": "simple-ts-solution",
                "content": "\\n# Code\\n```\\nclass Calculator {\\n    private res: number;\\n    constructor(value: number) {\\n        this.res = value;\\n    }\\n\\n    add(value: number): Calculator {\\n        this.res += value;\\n        return this;\\n    }\\n\\n    subtract(value: number): Calculator {\\n        this.res -= value;\\n        return this;\\n    }\\n\\n    multiply(value: number): Calculator {\\n        this.res *= value;\\n        return this;\\n    }\\n\\n    divide(value: number): Calculator {\\n        if (value == 0) {\\n            throw new Error(\"Division by zero is not allowed\");\\n        }\\n        this.res = this.res / value;\\n        return this;\\n    }\\n\\n    power(value: number): Calculator {\\n        this.res = Math.pow(this.res, value);\\n        return this;\\n    }\\n\\n    getResult(): number {\\n        return this.res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass Calculator {\\n    private res: number;\\n    constructor(value: number) {\\n        this.res = value;\\n    }\\n\\n    add(value: number): Calculator {\\n        this.res += value;\\n        return this;\\n    }\\n\\n    subtract(value: number): Calculator {\\n        this.res -= value;\\n        return this;\\n    }\\n\\n    multiply(value: number): Calculator {\\n        this.res *= value;\\n        return this;\\n    }\\n\\n    divide(value: number): Calculator {\\n        if (value == 0) {\\n            throw new Error(\"Division by zero is not allowed\");\\n        }\\n        this.res = this.res / value;\\n        return this;\\n    }\\n\\n    power(value: number): Calculator {\\n        this.res = Math.pow(this.res, value);\\n        return this;\\n    }\\n\\n    getResult(): number {\\n        return this.res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668390,
                "title": "o-1-typescript-solution",
                "content": "# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Calculator {\\n  init: number;\\n  \\n  constructor(value : number) {\\n    this.init = value;\\n  }\\n    \\n  add(value : number) : Calculator {\\n    this.init += value;\\n    return this;\\n  }\\n    \\n  subtract(value : number) : Calculator {\\n    this.init -= value;\\n    return this;\\n  }\\n    \\n  multiply(value : number) : Calculator {\\n    this.init *= value;\\n    return this;\\n  }\\n\\n  divide(value : number) : Calculator {\\n    if (value === 0) throw Error(\"Division by zero is not allowed\");\\n    this.init /= value;\\n    return this;\\n  }\\n    \\n  power(value : number) : Calculator {\\n    this.init = this.init ** value;\\n    return this;\\n  }\\n\\n  getResult() : number {\\n    return this.init;\\n  }\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass Calculator {\\n  init: number;\\n  \\n  constructor(value : number) {\\n    this.init = value;\\n  }\\n    \\n  add(value : number) : Calculator {\\n    this.init += value;\\n    return this;\\n  }\\n    \\n  subtract(value : number) : Calculator {\\n    this.init -= value;\\n    return this;\\n  }\\n    \\n  multiply(value : number) : Calculator {\\n    this.init *= value;\\n    return this;\\n  }\\n\\n  divide(value : number) : Calculator {\\n    if (value === 0) throw Error(\"Division by zero is not allowed\");\\n    this.init /= value;\\n    return this;\\n  }\\n    \\n  power(value : number) : Calculator {\\n    this.init = this.init ** value;\\n    return this;\\n  }\\n\\n  getResult() : number {\\n    return this.init;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663033,
                "title": "calculator-with-method-chaining",
                "content": "# Main functionalities:\\nThe Calculator class provides basic arithmetic operations such as addition, subtraction, multiplication, division, and power. It also allows chaining of operations by returning the instance of the class after each operation.\\n\\n# Methods:\\n- constructor(value): initializes the result field with the given value or 0 if no value is provided\\n- add(value): adds the given value to the result field and returns the instance of the class\\n- subtract(value): subtracts the given value from the result field and returns the instance of the class\\n- multiply(value): multiplies the result field by the given value and returns the instance of the class\\n- divide(divisor): divides the result field by the given divisor and returns the instance of the class. Throws an error if the divisor is 0.\\n- power(exponent): raises the result field to the power of the given exponent and returns the instance of the class\\n- getResult(): returns the current value of the result field\\n\\n# Fields\\n- result: stores the current value of the arithmetic operations performed by the class. It is initialized with the value provided in the constructor or 0 if no value is provided.\\n\\n\\n# Code\\n```\\nclass Calculator {\\n    constructor(initialValue = 0) {\\n        this.result = initialValue\\n    }\\n\\n    add(value){\\n        this.result += value\\n        return this\\n    }\\n\\n    subtract(value){\\n        this.result -= value\\n        return this\\n    }\\n\\n    multiply(value) {\\n        this.result *= value\\n        return this\\n    }\\n\\n    divide(divisor) {\\n        if (divisor === 0) {\\n            throw new Error(\"Division by zero is not allowed\")\\n        } else {\\n            this.result /= divisor\\n            return this   \\n        }\\n    }\\n\\n    power(exponent) {\\n        this.result = Math.pow(this.result, exponent)\\n        return this\\n    }\\n\\n    getResult() {\\n        return this.result\\n    }\\n\\n  }\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Calculator {\\n    constructor(initialValue = 0) {\\n        this.result = initialValue\\n    }\\n\\n    add(value){\\n        this.result += value\\n        return this\\n    }\\n\\n    subtract(value){\\n        this.result -= value\\n        return this\\n    }\\n\\n    multiply(value) {\\n        this.result *= value\\n        return this\\n    }\\n\\n    divide(divisor) {\\n        if (divisor === 0) {\\n            throw new Error(\"Division by zero is not allowed\")\\n        } else {\\n            this.result /= divisor\\n            return this   \\n        }\\n    }\\n\\n    power(exponent) {\\n        this.result = Math.pow(this.result, exponent)\\n        return this\\n    }\\n\\n    getResult() {\\n        return this.result\\n    }\\n\\n  }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663013,
                "title": "simple-typescript-beats-100-memory-42mb",
                "content": "# Intuition\\nCreate a private variable `current`, storing the current calculator value. \\n\\n# Approach\\nIn each method, perform math on `current` and return the `Calculator` itself via `this`\\n\\n# Complexity\\nDisclaimer: I am not an expert on calculating complexity \\uD83D\\uDE43\\n- Time complexity:\\nI believe this is O(n), as there are no loops\\n\\n- Space complexity:\\nI believe this O(1), as there is only 1 layer of variable depth\\n\\n# Code\\n```\\nclass Calculator {\\n    private current: number\\n    constructor(value : number) {\\n        this.current = value\\n    }\\n        \\n    add(value : number) : Calculator {\\n        this.current += value\\n        return this\\n    }\\n        \\n    subtract(value : number) : Calculator {\\n        this.current -= value\\n        return this\\n    }\\n        \\n    multiply(value : number) : Calculator {\\n        this.current *= value\\n        return this\\n    }\\n\\n    divide(value : number) : Calculator {\\n        if (value === 0) {\\n            throw new Error(\"Division by zero is not allowed\")\\n        }\\n\\n        this.current /= value\\n        return this\\n    }\\n        \\n    power(value : number) : Calculator {\\n        this.current = Math.pow(this.current, value)\\n        return this\\n    }\\n\\n    getResult() : number {\\n        return this.current\\n    }\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass Calculator {\\n    private current: number\\n    constructor(value : number) {\\n        this.current = value\\n    }\\n        \\n    add(value : number) : Calculator {\\n        this.current += value\\n        return this\\n    }\\n        \\n    subtract(value : number) : Calculator {\\n        this.current -= value\\n        return this\\n    }\\n        \\n    multiply(value : number) : Calculator {\\n        this.current *= value\\n        return this\\n    }\\n\\n    divide(value : number) : Calculator {\\n        if (value === 0) {\\n            throw new Error(\"Division by zero is not allowed\")\\n        }\\n\\n        this.current /= value\\n        return this\\n    }\\n        \\n    power(value : number) : Calculator {\\n        this.current = Math.pow(this.current, value)\\n        return this\\n    }\\n\\n    getResult() : number {\\n        return this.current\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640547,
                "title": "javascript-and-typescript-solutions",
                "content": "# Intuition\\nEverything is clear here, I will use `Math.pow` for exponentiation \\n\\n# Code\\n\\n__JavaScript__\\n\\n```js\\nclass Calculator {  \\n    /** \\n     * @param {number} value\\n     */\\n    constructor(value) {\\n        this.value = value\\n    }\\n\\n    /** \\n     * @param {number} value\\n     * @return {Calculator}\\n     */\\n    add(value){\\n        this.value += value\\n        return this\\n    }\\n\\n    /** \\n     * @param {number} value\\n     * @return {Calculator}\\n     */\\n    subtract(value){\\n        this.value -= value\\n        return this\\n    }\\n\\n    /** \\n     * @param {number} value\\n     * @return {Calculator}\\n     */  \\n    multiply(value) {\\n        this.value *= value\\n        return this\\n    }\\n\\n    /** \\n     * @param {number} value\\n     * @return {Calculator}\\n     */\\n    divide(value) {\\n        if (value === 0) throw new Error(\\'Division by zero is not allowed\\')\\n        this.value /= value\\n        return this\\n    }\\n    \\n    /** \\n     * @param {number} value\\n     * @return {Calculator}\\n     */\\n    power(value) {\\n        this.value = Math.pow(this.value, value)\\n        return this\\n    }\\n\\n    /** \\n     * @return {number}\\n     */\\n    getResult() {\\n        return this.value\\n    }\\n}   \\n```\\n\\n__TypeScript__\\n```ts\\nclass Calculator {\\n    value: number\\n    \\n    constructor(value : number) {\\n        this.value = value\\n    }\\n\\n    add(value : number) : Calculator {\\n        this.value += value\\n        return this\\n    }\\n\\n    subtract(value : number) : Calculator {\\n        this.value -= value\\n        return this\\n    }\\n\\n    multiply(value : number) : Calculator {\\n        this.value *= value\\n        return this\\n    }\\n\\n    divide(value : number) : Calculator {\\n        if (value === 0) throw new Error(\\'Division by zero is not allowed\\')\\n        this.value /= value\\n        return this\\n    }\\n    \\n    power(value : number) : Calculator {\\n        this.value = Math.pow(this.value, value)\\n        return this\\n    }\\n\\n    getResult() : number {\\n        return this.value\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```js\\nclass Calculator {  \\n    /** \\n     * @param {number} value\\n     */\\n    constructor(value) {\\n        this.value = value\\n    }\\n\\n    /** \\n     * @param {number} value\\n     * @return {Calculator}\\n     */\\n    add(value){\\n        this.value += value\\n        return this\\n    }\\n\\n    /** \\n     * @param {number} value\\n     * @return {Calculator}\\n     */\\n    subtract(value){\\n        this.value -= value\\n        return this\\n    }\\n\\n    /** \\n     * @param {number} value\\n     * @return {Calculator}\\n     */  \\n    multiply(value) {\\n        this.value *= value\\n        return this\\n    }\\n\\n    /** \\n     * @param {number} value\\n     * @return {Calculator}\\n     */\\n    divide(value) {\\n        if (value === 0) throw new Error(\\'Division by zero is not allowed\\')\\n        this.value /= value\\n        return this\\n    }\\n    \\n    /** \\n     * @param {number} value\\n     * @return {Calculator}\\n     */\\n    power(value) {\\n        this.value = Math.pow(this.value, value)\\n        return this\\n    }\\n\\n    /** \\n     * @return {number}\\n     */\\n    getResult() {\\n        return this.value\\n    }\\n}   \\n```\n```ts\\nclass Calculator {\\n    value: number\\n    \\n    constructor(value : number) {\\n        this.value = value\\n    }\\n\\n    add(value : number) : Calculator {\\n        this.value += value\\n        return this\\n    }\\n\\n    subtract(value : number) : Calculator {\\n        this.value -= value\\n        return this\\n    }\\n\\n    multiply(value : number) : Calculator {\\n        this.value *= value\\n        return this\\n    }\\n\\n    divide(value : number) : Calculator {\\n        if (value === 0) throw new Error(\\'Division by zero is not allowed\\')\\n        this.value /= value\\n        return this\\n    }\\n    \\n    power(value : number) : Calculator {\\n        this.value = Math.pow(this.value, value)\\n        return this\\n    }\\n\\n    getResult() : number {\\n        return this.value\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633450,
                "title": "javascript-return-this",
                "content": "```\\nclass Calculator {\\n  constructor(init) {\\n    this.res = init;\\n  }\\n  add(num) {\\n    this.res += num;\\n    return this;\\n  }\\n  subtract(num) {\\n    this.res -= num;\\n    return this;\\n  }\\n  multiply(num) {\\n    this.res *= num;\\n    return this;\\n  }\\n  divide(num) {\\n    if (num === 0) throw new Error(\"Division by zero is not allowed\");\\n    this.res /= num;\\n    return this;\\n  }\\n  power(num) {\\n    this.res = this.res ** num;\\n    return this;\\n  }\\n  getResult() {\\n    return this.res;\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Calculator {\\n  constructor(init) {\\n    this.res = init;\\n  }\\n  add(num) {\\n    this.res += num;\\n    return this;\\n  }\\n  subtract(num) {\\n    this.res -= num;\\n    return this;\\n  }\\n  multiply(num) {\\n    this.res *= num;\\n    return this;\\n  }\\n  divide(num) {\\n    if (num === 0) throw new Error(\"Division by zero is not allowed\");\\n    this.res /= num;\\n    return this;\\n  }\\n  power(num) {\\n    this.res = this.res ** num;\\n    return this;\\n  }\\n  getResult() {\\n    return this.res;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633140,
                "title": "calculator-javascript-method-chaining",
                "content": "```\\nclass Calculator {  \\n  constructor(value) {\\n      this.result = value\\n  }\\n\\n  add(value){    \\n    this.result = this.result + value    \\n  }\\n\\n  subtract(value){        \\n    this.result = this.result - value    \\n  }\\n \\n  multiply(value) {    \\n    this.result = this.result * value \\n  }\\n\\n  divide(value) {    \\n    if (value == 0) \\n      throw new Error(\"Division by zero is not allowed\") \\n    else\\n      this.result = this.result / value  \\n  }\\n  \\n  power(value) {    \\n    this.result = Math.pow(this.result, value)\\n  }\\n    \\n  getResult() {\\n    return this.result\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Calculator {  \\n  constructor(value) {\\n      this.result = value\\n  }\\n\\n  add(value){    \\n    this.result = this.result + value    \\n  }\\n\\n  subtract(value){        \\n    this.result = this.result - value    \\n  }\\n \\n  multiply(value) {    \\n    this.result = this.result * value \\n  }\\n\\n  divide(value) {    \\n    if (value == 0) \\n      throw new Error(\"Division by zero is not allowed\") \\n    else\\n      this.result = this.result / value  \\n  }\\n  \\n  power(value) {    \\n    this.result = Math.pow(this.result, value)\\n  }\\n    \\n  getResult() {\\n    return this.result\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632481,
                "title": "easiest-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Calculator {\\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n      this.val = value;\\n  }\\n  \\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n    this.val += value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n    this.val -= value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n    this.val *= value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n    if(value == 0) throw \"Division by zero is not allowed\";\\n    this.val /= value;\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n    this.val **= value;\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n      return this.val;\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Calculator {\\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n      this.val = value;\\n  }\\n  \\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n    this.val += value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n    this.val -= value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n    this.val *= value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n    if(value == 0) throw \"Division by zero is not allowed\";\\n    this.val /= value;\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n    this.val **= value;\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n      return this.val;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3621848,
                "title": "simple-typescript-solution",
                "content": "\\n# Code\\n```\\nclass Calculator {\\n  result = 0;\\n  constructor(value : number) {\\n      this.result = value\\n  }\\n    \\n  add(value : number) : Calculator {\\n      this.result += value\\n      return this\\n  }\\n    \\n  subtract(value : number): Calculator {\\n      this.result -= value\\n      return this\\n  }\\n    \\n  multiply(value : number): Calculator {\\n    this.result *= value\\n    return this\\n  }\\n\\n  divide(value : number): Calculator {\\n      if(value == 0) throw \"Division by zero is not allowed\"\\n      this.result /= value\\n      return this\\n  }\\n    \\n  power(value : number): Calculator {\\n      this.result **= value\\n      return this\\n  }\\n\\n  getResult() : number {\\n      return this.result\\n  }\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass Calculator {\\n  result = 0;\\n  constructor(value : number) {\\n      this.result = value\\n  }\\n    \\n  add(value : number) : Calculator {\\n      this.result += value\\n      return this\\n  }\\n    \\n  subtract(value : number): Calculator {\\n      this.result -= value\\n      return this\\n  }\\n    \\n  multiply(value : number): Calculator {\\n    this.result *= value\\n    return this\\n  }\\n\\n  divide(value : number): Calculator {\\n      if(value == 0) throw \"Division by zero is not allowed\"\\n      this.result /= value\\n      return this\\n  }\\n    \\n  power(value : number): Calculator {\\n      this.result **= value\\n      return this\\n  }\\n\\n  getResult() : number {\\n      return this.result\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3620419,
                "title": "full-thorough-explanation-simple-beginner-friendly",
                "content": "# Approach\\nIn order to edit the value of any ```Calculator``` object, we need to define the ```Calculator``` class to store its own value. We can do this by declaring a ```val``` variable. More specifically, ```val``` will belong to each ```Calculator``` object, so we should call and set it using ```this.val```.\\n\\nIn order to initialize ```val```, we can define a constructor for the ```Calculator``` class. We do this in the following format:\\n```\\nconstructor(parameters) {\\n    // do some things and set the object\\'s variables here\\n}\\n```\\nAnd so for this problem, we set ```val``` to the input, as follows:\\n```\\nconstructor(value) {\\n    this.val = value;\\n}\\n```\\nFrom here, the rest is simple. We are defining various ```Calculator``` calls. This way, we can do some operations on any ```Calculator``` object. Note, throw error if dividing by 0, and for all other operations, simply do the operation.\\n\\nFor example, if we define ```var calc = new Calculator(10)```, and then make the call ```calc.add(4)```, and finally store the result as ```let result = calc.getResult()```, the value of ```result``` will be 14.\\n\\nNOTE: in the original problem, there were JavaDocs, such as the comments right above the add call in the code below, specifying we return a ```Calculator``` object. For sake of compactness, I have excluded that for all other method calls, but all calls should return a ```Calculator``` object (simply return ```this```), except ```getResult()```, which returns the value of the calculator (```return this.val```).\\n\\n# Code\\n```\\nclass Calculator {\\n    // create data for calculator, this.val\\n    constructor(value) {\\n        this.val = value;\\n    }\\n\\n    /** \\n    * @param {number} value\\n    * @return {Calculator}\\n    */\\n    add(value){\\n        this.val += value;\\n        return this;\\n    }\\n\\n    // ommited JavaDocs from all calls except add\\n    subtract(value){\\n        this.val -= value;\\n        return this;\\n    }\\n\\n    multiply(value) {\\n        this.val *= value;\\n        return this;\\n    }\\n\\n    divide(value) {\\n        if (value === 0) throw new Error(\"Division by zero is not allowed\");\\n        this.val /= value;\\n        return this;\\n    }\\n\\n    power(value) {\\n        this.val **= value;\\n        return this;\\n    }\\n\\n    getResult() {\\n        return this.val;\\n    }\\n}\\n```\\nUPVOTE if this was helpful \\uD83C\\uDF5E\\uD83C\\uDF5E\\uD83C\\uDF5E",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```Calculator```\n```Calculator```\n```val```\n```val```\n```Calculator```\n```this.val```\n```val```\n```Calculator```\n```\\nconstructor(parameters) {\\n    // do some things and set the object\\'s variables here\\n}\\n```\n```val```\n```\\nconstructor(value) {\\n    this.val = value;\\n}\\n```\n```Calculator```\n```Calculator```\n```var calc = new Calculator(10)```\n```calc.add(4)```\n```let result = calc.getResult()```\n```result```\n```Calculator```\n```Calculator```\n```this```\n```getResult()```\n```return this.val```\n```\\nclass Calculator {\\n    // create data for calculator, this.val\\n    constructor(value) {\\n        this.val = value;\\n    }\\n\\n    /** \\n    * @param {number} value\\n    * @return {Calculator}\\n    */\\n    add(value){\\n        this.val += value;\\n        return this;\\n    }\\n\\n    // ommited JavaDocs from all calls except add\\n    subtract(value){\\n        this.val -= value;\\n        return this;\\n    }\\n\\n    multiply(value) {\\n        this.val *= value;\\n        return this;\\n    }\\n\\n    divide(value) {\\n        if (value === 0) throw new Error(\"Division by zero is not allowed\");\\n        this.val /= value;\\n        return this;\\n    }\\n\\n    power(value) {\\n        this.val **= value;\\n        return this;\\n    }\\n\\n    getResult() {\\n        return this.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3620315,
                "title": "ts-update-instance-variable-and-return-this-67ms-42-5mb",
                "content": "Fairly plain problem, in which we will have to have an instance class (`this.value`) initialised in the constructor and properly modified by each operation, before `return`ing `this` in order to have the methods as chainable.\\n\\nThe `divide` method needs just an extra condition when the passed divisor is `0`, while the final call to `getResult` is the only one actually `return`ing `this.value`.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```ts\\nclass Calculator {\\n    value: number\\n    constructor(value : number) {\\n        this.value = value;\\n    }\\n\\n    add(value : number) : Calculator {\\n        this.value += value;\\n        return this;\\n    }\\n\\n    subtract(value : number) : Calculator {\\n        this.value -= value;\\n        return this;\\n    }\\n\\n    multiply(value : number) : Calculator {\\n        this.value *= value;\\n        return this;\\n    }\\n\\n    divide(value : number) : Calculator {\\n        if (!value) throw new Error(\"Division by zero is not allowed\");\\n        this.value /= value;\\n        return this;\\n    }\\n\\n    power(value : number) : Calculator {\\n        this.value **= value;\\n        return this;\\n    }\\n\\n    getResult() : number {\\n        return this.value;\\n    }\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```ts\\nclass Calculator {\\n    value: number\\n    constructor(value : number) {\\n        this.value = value;\\n    }\\n\\n    add(value : number) : Calculator {\\n        this.value += value;\\n        return this;\\n    }\\n\\n    subtract(value : number) : Calculator {\\n        this.value -= value;\\n        return this;\\n    }\\n\\n    multiply(value : number) : Calculator {\\n        this.value *= value;\\n        return this;\\n    }\\n\\n    divide(value : number) : Calculator {\\n        if (!value) throw new Error(\"Division by zero is not allowed\");\\n        this.value /= value;\\n        return this;\\n    }\\n\\n    power(value : number) : Calculator {\\n        this.value **= value;\\n        return this;\\n    }\\n\\n    getResult() : number {\\n        return this.value;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619986,
                "title": "easy-solution",
                "content": "# Complexity\\n- Time complexity: O(1) for each operation\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n      this.result = value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n      this.result += value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n      this.result -= value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n      this.result *= value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n      if(value===0) throw new Error(\"Division by zero is not allowed\");\\n      this.result /= value;\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n      this.result **= value;\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n      return this.result;\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Design"
                ],
                "code": "```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n      this.result = value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n      this.result += value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n      this.result -= value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n      this.result *= value;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n      if(value===0) throw new Error(\"Division by zero is not allowed\");\\n      this.result /= value;\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n      this.result **= value;\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n      return this.result;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618969,
                "title": "54ms-short-typescript-click",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Calculator {\\n    res = 0;\\n  constructor(value : number) {\\n      this.res = value;\\n  }\\n    \\n  add(value : number) : Calculator {\\n      this.res += value;\\n      return new Calculator(this.res);\\n  }\\n    \\n  subtract(value : number) : Calculator {\\n      this.res -= value;\\n      return new Calculator(this.res);\\n  }\\n    \\n  multiply(value : number) : Calculator {\\n      this.res *= value;\\n      return new Calculator(this.res);\\n  }\\n\\n  divide(value : number) : Calculator {\\n      if(value === 0) throw \"Division by zero is not allowed\"\\n      this.res /= value;\\n      return new Calculator(this.res);\\n  }\\n    \\n  power(value : number) : Calculator {\\n      this.res **= value;\\n      return new Calculator(this.res);\\n  }\\n\\n  getResult() : number {\\n      return this.res;\\n  }\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass Calculator {\\n    res = 0;\\n  constructor(value : number) {\\n      this.res = value;\\n  }\\n    \\n  add(value : number) : Calculator {\\n      this.res += value;\\n      return new Calculator(this.res);\\n  }\\n    \\n  subtract(value : number) : Calculator {\\n      this.res -= value;\\n      return new Calculator(this.res);\\n  }\\n    \\n  multiply(value : number) : Calculator {\\n      this.res *= value;\\n      return new Calculator(this.res);\\n  }\\n\\n  divide(value : number) : Calculator {\\n      if(value === 0) throw \"Division by zero is not allowed\"\\n      this.res /= value;\\n      return new Calculator(this.res);\\n  }\\n    \\n  power(value : number) : Calculator {\\n      this.res **= value;\\n      return new Calculator(this.res);\\n  }\\n\\n  getResult() : number {\\n      return this.res;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3616345,
                "title": "javascript-easy-solution",
                "content": "# Code\\n```\\nclass Calculator {\\n  constructor(value) {\\n      this.num = value;\\n  }\\n\\n  add(value){\\n      this.num += value;\\n  }\\n\\n  subtract(value){\\n      this.num -= value;\\n  }\\n\\n  multiply(value) {\\n      this.num *= value;\\n  }\\n\\n  divide(value) {\\n      if(value===0) throw new Error(\"Division by zero is not allowed\") \\n      this.num /= value;\\n  }\\n\\n  power(value) {\\n      this.num = this.num**value;\\n  }\\n\\n  getResult() {\\n      return this.num;\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Calculator {\\n  constructor(value) {\\n      this.num = value;\\n  }\\n\\n  add(value){\\n      this.num += value;\\n  }\\n\\n  subtract(value){\\n      this.num -= value;\\n  }\\n\\n  multiply(value) {\\n      this.num *= value;\\n  }\\n\\n  divide(value) {\\n      if(value===0) throw new Error(\"Division by zero is not allowed\") \\n      this.num /= value;\\n  }\\n\\n  power(value) {\\n      this.num = this.num**value;\\n  }\\n\\n  getResult() {\\n      return this.num;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615636,
                "title": "javascript-simple-solution",
                "content": "```\\nclass Calculator \\n{\\n    constructor(value) \\n    {\\n        this.c=value;\\n    }\\n    add(value)\\n    {\\n        this.c+=value;\\n    }\\n    subtract(value)\\n    {\\n        this.c-=value;\\n    }\\n    multiply(value) \\n    {\\n        this.c*=value;\\n    }\\n    divide(value) \\n    {\\n        if(value===0) throw \"Division by zero is not allowed\";\\n        this.c/=value;\\n    }\\n    power(value) \\n    {\\n        this.c**=value;\\n    }\\n    getResult() \\n    {\\n        return this.c;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Calculator \\n{\\n    constructor(value) \\n    {\\n        this.c=value;\\n    }\\n    add(value)\\n    {\\n        this.c+=value;\\n    }\\n    subtract(value)\\n    {\\n        this.c-=value;\\n    }\\n    multiply(value) \\n    {\\n        this.c*=value;\\n    }\\n    divide(value) \\n    {\\n        if(value===0) throw \"Division by zero is not allowed\";\\n        this.c/=value;\\n    }\\n    power(value) \\n    {\\n        this.c**=value;\\n    }\\n    getResult() \\n    {\\n        return this.c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615575,
                "title": "javascript-good-enough",
                "content": "``` JavaScript []\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n      this.value = value;\\n      return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n      this.value += value;\\n      return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n      this.value -= value;\\n      return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n      this.value *= value;\\n      return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n      if(value===0){\\n          throw new Error(\\'Division by zero is not allowed\\');\\n      }\\n\\n      this.value /= value;\\n      return this;\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n      this.value = Math.pow(this.value, value);\\n      return this;\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n      return this.value;\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` JavaScript []\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n      this.value = value;\\n      return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n      this.value += value;\\n      return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n      this.value -= value;\\n      return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n      this.value *= value;\\n      return this;\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n      if(value===0){\\n          throw new Error(\\'Division by zero is not allowed\\');\\n      }\\n\\n      this.value /= value;\\n      return this;\\n  }\\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n      this.value = Math.pow(this.value, value);\\n      return this;\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n      return this.value;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615375,
                "title": "easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n      this.value=value\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n      this.value+=value\\n  } \\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n      this.value-=value\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n      this.value*=value\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n    if(value!==0) this.value=this.value/value\\n    else throw new Error(\"Division by zero is not allowed\")\\n  } \\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n    this.value=this.value**value\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n      return this.value\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Calculator {\\n  \\n  /** \\n   * @param {number} value\\n   */\\n  constructor(value) {\\n      this.value=value\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  add(value){\\n      this.value+=value\\n  } \\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  subtract(value){\\n      this.value-=value\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */  \\n  multiply(value) {\\n      this.value*=value\\n  }\\n\\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  divide(value) {\\n    if(value!==0) this.value=this.value/value\\n    else throw new Error(\"Division by zero is not allowed\")\\n  } \\n  \\n  /** \\n   * @param {number} value\\n   * @return {Calculator}\\n   */\\n  power(value) {\\n    this.value=this.value**value\\n  }\\n    \\n  /** \\n   * @return {number}\\n   */\\n  getResult() {\\n      return this.value\\n  }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1948640,
                "content": [
                    {
                        "username": "evgeniy-utkin",
                        "content": "Somehow it passes all the tests even without chaining. And it probably shouldn\\'t."
                    },
                    {
                        "username": "newms3450",
                        "content": "Why is the gettter for result `getResult()` and not `get result()` (i.e., an actual JS getter)? This doesn't teach good JS coding practices."
                    },
                    {
                        "username": "Chenbao2021",
                        "content": "Can someone tell me what is the reason we return a new instance of Calculator? Instead of just up to date the value of result ?"
                    },
                    {
                        "username": "newms3450",
                        "content": "Because of the method chaining requirement. For the sake of not spoiling the answer, imagine instead if we\\'re asked to write a sentence-scrambler `SentenceScrambler` that can do three things:\\n1. `addText()`: It can add more text to the sentence.\\n2. `reverse()`: It can reverse the sentence: `hello world` transforms to `dlrow olleh`.\\n3. `pigLatin()` It can Pig-Latin-ify the sentence: `hello world` becomes `ellohay orldway`.\\n\\nWith _chaining_, I want to be able to run multiple methods (or the same method, or some combination of the two) in a _row_. That is, I don\\'t want to have to do:\\n\\n```JavaScript\\nlet sentenceScrambler = new SentenceScrambler();\\nsentenceScrambler.addText(\\'hello world\\');\\nsentenceScrambler.reverse();\\nsentenceScrambler.pigLatin();\\nsentenceScrambler.reverse();\\n```\\n\\nInstead, I wanna be able to do those four method lines in a chain - in one line! - like this:\\n\\n```JavaScript\\nlet sentenceScrambler = new SentenceScrambler();\\nsentenceScrambler.addText(\\'hello world\\').reverse().pigLatin().reverse();\\n```\\n\\nBy returning the same instance (`this`) of the scrambler at the end of each method:\\n```JavaScript\\naddText(value){\\n  this._value += value;\\n  return this;\\n}\\n```\\n\\nwe\\'re allowing the next \"thing\" in line - in this case, the `reverse()` to method to still be operating on a SentenceScrambler instance (with all its methods!)."
                    },
                    {
                        "username": "pemshera",
                        "content": "Line 106 in solution.js\\n            throw err;\\n            ^\\nDivision by zero is not  allowed\\n(Use `nodejs run --trace-uncaught ...` to show where the exception was thrown) `if (value === 0) throw \"Division by zero is not  allowed\";`"
                    },
                    {
                        "username": "an6814249",
                        "content": "BISP New Registration Form 2023 has been launched. Through which you can check your eligibility. And sitting at home can register through the new form of BISP. Chairperson BISP Shazia Murree has started the re-registration of the Benazir income support program. So that ineligible and deserving people can do their registration at home through BISP New Form. \\n\\n<a href=\"https://ehsaasrashan.com/bisp-new-registration-form/8171 Web Portal\\n\\n8171 Ehsaas Program Online Registration 2023 - BISP 8171 Web portal\\n</a"
                    },
                    {
                        "username": "gautam1168",
                        "content": "what is this? The weaker version of the curry question ?"
                    }
                ]
            },
            {
                "id": 1962080,
                "content": [
                    {
                        "username": "evgeniy-utkin",
                        "content": "Somehow it passes all the tests even without chaining. And it probably shouldn\\'t."
                    },
                    {
                        "username": "newms3450",
                        "content": "Why is the gettter for result `getResult()` and not `get result()` (i.e., an actual JS getter)? This doesn't teach good JS coding practices."
                    },
                    {
                        "username": "Chenbao2021",
                        "content": "Can someone tell me what is the reason we return a new instance of Calculator? Instead of just up to date the value of result ?"
                    },
                    {
                        "username": "newms3450",
                        "content": "Because of the method chaining requirement. For the sake of not spoiling the answer, imagine instead if we\\'re asked to write a sentence-scrambler `SentenceScrambler` that can do three things:\\n1. `addText()`: It can add more text to the sentence.\\n2. `reverse()`: It can reverse the sentence: `hello world` transforms to `dlrow olleh`.\\n3. `pigLatin()` It can Pig-Latin-ify the sentence: `hello world` becomes `ellohay orldway`.\\n\\nWith _chaining_, I want to be able to run multiple methods (or the same method, or some combination of the two) in a _row_. That is, I don\\'t want to have to do:\\n\\n```JavaScript\\nlet sentenceScrambler = new SentenceScrambler();\\nsentenceScrambler.addText(\\'hello world\\');\\nsentenceScrambler.reverse();\\nsentenceScrambler.pigLatin();\\nsentenceScrambler.reverse();\\n```\\n\\nInstead, I wanna be able to do those four method lines in a chain - in one line! - like this:\\n\\n```JavaScript\\nlet sentenceScrambler = new SentenceScrambler();\\nsentenceScrambler.addText(\\'hello world\\').reverse().pigLatin().reverse();\\n```\\n\\nBy returning the same instance (`this`) of the scrambler at the end of each method:\\n```JavaScript\\naddText(value){\\n  this._value += value;\\n  return this;\\n}\\n```\\n\\nwe\\'re allowing the next \"thing\" in line - in this case, the `reverse()` to method to still be operating on a SentenceScrambler instance (with all its methods!)."
                    },
                    {
                        "username": "pemshera",
                        "content": "Line 106 in solution.js\\n            throw err;\\n            ^\\nDivision by zero is not  allowed\\n(Use `nodejs run --trace-uncaught ...` to show where the exception was thrown) `if (value === 0) throw \"Division by zero is not  allowed\";`"
                    },
                    {
                        "username": "an6814249",
                        "content": "BISP New Registration Form 2023 has been launched. Through which you can check your eligibility. And sitting at home can register through the new form of BISP. Chairperson BISP Shazia Murree has started the re-registration of the Benazir income support program. So that ineligible and deserving people can do their registration at home through BISP New Form. \\n\\n<a href=\"https://ehsaasrashan.com/bisp-new-registration-form/8171 Web Portal\\n\\n8171 Ehsaas Program Online Registration 2023 - BISP 8171 Web portal\\n</a"
                    },
                    {
                        "username": "gautam1168",
                        "content": "what is this? The weaker version of the curry question ?"
                    }
                ]
            },
            {
                "id": 2011036,
                "content": [
                    {
                        "username": "evgeniy-utkin",
                        "content": "Somehow it passes all the tests even without chaining. And it probably shouldn\\'t."
                    },
                    {
                        "username": "newms3450",
                        "content": "Why is the gettter for result `getResult()` and not `get result()` (i.e., an actual JS getter)? This doesn't teach good JS coding practices."
                    },
                    {
                        "username": "Chenbao2021",
                        "content": "Can someone tell me what is the reason we return a new instance of Calculator? Instead of just up to date the value of result ?"
                    },
                    {
                        "username": "newms3450",
                        "content": "Because of the method chaining requirement. For the sake of not spoiling the answer, imagine instead if we\\'re asked to write a sentence-scrambler `SentenceScrambler` that can do three things:\\n1. `addText()`: It can add more text to the sentence.\\n2. `reverse()`: It can reverse the sentence: `hello world` transforms to `dlrow olleh`.\\n3. `pigLatin()` It can Pig-Latin-ify the sentence: `hello world` becomes `ellohay orldway`.\\n\\nWith _chaining_, I want to be able to run multiple methods (or the same method, or some combination of the two) in a _row_. That is, I don\\'t want to have to do:\\n\\n```JavaScript\\nlet sentenceScrambler = new SentenceScrambler();\\nsentenceScrambler.addText(\\'hello world\\');\\nsentenceScrambler.reverse();\\nsentenceScrambler.pigLatin();\\nsentenceScrambler.reverse();\\n```\\n\\nInstead, I wanna be able to do those four method lines in a chain - in one line! - like this:\\n\\n```JavaScript\\nlet sentenceScrambler = new SentenceScrambler();\\nsentenceScrambler.addText(\\'hello world\\').reverse().pigLatin().reverse();\\n```\\n\\nBy returning the same instance (`this`) of the scrambler at the end of each method:\\n```JavaScript\\naddText(value){\\n  this._value += value;\\n  return this;\\n}\\n```\\n\\nwe\\'re allowing the next \"thing\" in line - in this case, the `reverse()` to method to still be operating on a SentenceScrambler instance (with all its methods!)."
                    },
                    {
                        "username": "pemshera",
                        "content": "Line 106 in solution.js\\n            throw err;\\n            ^\\nDivision by zero is not  allowed\\n(Use `nodejs run --trace-uncaught ...` to show where the exception was thrown) `if (value === 0) throw \"Division by zero is not  allowed\";`"
                    },
                    {
                        "username": "an6814249",
                        "content": "BISP New Registration Form 2023 has been launched. Through which you can check your eligibility. And sitting at home can register through the new form of BISP. Chairperson BISP Shazia Murree has started the re-registration of the Benazir income support program. So that ineligible and deserving people can do their registration at home through BISP New Form. \\n\\n<a href=\"https://ehsaasrashan.com/bisp-new-registration-form/8171 Web Portal\\n\\n8171 Ehsaas Program Online Registration 2023 - BISP 8171 Web portal\\n</a"
                    },
                    {
                        "username": "gautam1168",
                        "content": "what is this? The weaker version of the curry question ?"
                    }
                ]
            },
            {
                "id": 1985825,
                "content": [
                    {
                        "username": "evgeniy-utkin",
                        "content": "Somehow it passes all the tests even without chaining. And it probably shouldn\\'t."
                    },
                    {
                        "username": "newms3450",
                        "content": "Why is the gettter for result `getResult()` and not `get result()` (i.e., an actual JS getter)? This doesn't teach good JS coding practices."
                    },
                    {
                        "username": "Chenbao2021",
                        "content": "Can someone tell me what is the reason we return a new instance of Calculator? Instead of just up to date the value of result ?"
                    },
                    {
                        "username": "newms3450",
                        "content": "Because of the method chaining requirement. For the sake of not spoiling the answer, imagine instead if we\\'re asked to write a sentence-scrambler `SentenceScrambler` that can do three things:\\n1. `addText()`: It can add more text to the sentence.\\n2. `reverse()`: It can reverse the sentence: `hello world` transforms to `dlrow olleh`.\\n3. `pigLatin()` It can Pig-Latin-ify the sentence: `hello world` becomes `ellohay orldway`.\\n\\nWith _chaining_, I want to be able to run multiple methods (or the same method, or some combination of the two) in a _row_. That is, I don\\'t want to have to do:\\n\\n```JavaScript\\nlet sentenceScrambler = new SentenceScrambler();\\nsentenceScrambler.addText(\\'hello world\\');\\nsentenceScrambler.reverse();\\nsentenceScrambler.pigLatin();\\nsentenceScrambler.reverse();\\n```\\n\\nInstead, I wanna be able to do those four method lines in a chain - in one line! - like this:\\n\\n```JavaScript\\nlet sentenceScrambler = new SentenceScrambler();\\nsentenceScrambler.addText(\\'hello world\\').reverse().pigLatin().reverse();\\n```\\n\\nBy returning the same instance (`this`) of the scrambler at the end of each method:\\n```JavaScript\\naddText(value){\\n  this._value += value;\\n  return this;\\n}\\n```\\n\\nwe\\'re allowing the next \"thing\" in line - in this case, the `reverse()` to method to still be operating on a SentenceScrambler instance (with all its methods!)."
                    },
                    {
                        "username": "pemshera",
                        "content": "Line 106 in solution.js\\n            throw err;\\n            ^\\nDivision by zero is not  allowed\\n(Use `nodejs run --trace-uncaught ...` to show where the exception was thrown) `if (value === 0) throw \"Division by zero is not  allowed\";`"
                    },
                    {
                        "username": "an6814249",
                        "content": "BISP New Registration Form 2023 has been launched. Through which you can check your eligibility. And sitting at home can register through the new form of BISP. Chairperson BISP Shazia Murree has started the re-registration of the Benazir income support program. So that ineligible and deserving people can do their registration at home through BISP New Form. \\n\\n<a href=\"https://ehsaasrashan.com/bisp-new-registration-form/8171 Web Portal\\n\\n8171 Ehsaas Program Online Registration 2023 - BISP 8171 Web portal\\n</a"
                    },
                    {
                        "username": "gautam1168",
                        "content": "what is this? The weaker version of the curry question ?"
                    }
                ]
            },
            {
                "id": 1958629,
                "content": [
                    {
                        "username": "evgeniy-utkin",
                        "content": "Somehow it passes all the tests even without chaining. And it probably shouldn\\'t."
                    },
                    {
                        "username": "newms3450",
                        "content": "Why is the gettter for result `getResult()` and not `get result()` (i.e., an actual JS getter)? This doesn't teach good JS coding practices."
                    },
                    {
                        "username": "Chenbao2021",
                        "content": "Can someone tell me what is the reason we return a new instance of Calculator? Instead of just up to date the value of result ?"
                    },
                    {
                        "username": "newms3450",
                        "content": "Because of the method chaining requirement. For the sake of not spoiling the answer, imagine instead if we\\'re asked to write a sentence-scrambler `SentenceScrambler` that can do three things:\\n1. `addText()`: It can add more text to the sentence.\\n2. `reverse()`: It can reverse the sentence: `hello world` transforms to `dlrow olleh`.\\n3. `pigLatin()` It can Pig-Latin-ify the sentence: `hello world` becomes `ellohay orldway`.\\n\\nWith _chaining_, I want to be able to run multiple methods (or the same method, or some combination of the two) in a _row_. That is, I don\\'t want to have to do:\\n\\n```JavaScript\\nlet sentenceScrambler = new SentenceScrambler();\\nsentenceScrambler.addText(\\'hello world\\');\\nsentenceScrambler.reverse();\\nsentenceScrambler.pigLatin();\\nsentenceScrambler.reverse();\\n```\\n\\nInstead, I wanna be able to do those four method lines in a chain - in one line! - like this:\\n\\n```JavaScript\\nlet sentenceScrambler = new SentenceScrambler();\\nsentenceScrambler.addText(\\'hello world\\').reverse().pigLatin().reverse();\\n```\\n\\nBy returning the same instance (`this`) of the scrambler at the end of each method:\\n```JavaScript\\naddText(value){\\n  this._value += value;\\n  return this;\\n}\\n```\\n\\nwe\\'re allowing the next \"thing\" in line - in this case, the `reverse()` to method to still be operating on a SentenceScrambler instance (with all its methods!)."
                    },
                    {
                        "username": "pemshera",
                        "content": "Line 106 in solution.js\\n            throw err;\\n            ^\\nDivision by zero is not  allowed\\n(Use `nodejs run --trace-uncaught ...` to show where the exception was thrown) `if (value === 0) throw \"Division by zero is not  allowed\";`"
                    },
                    {
                        "username": "an6814249",
                        "content": "BISP New Registration Form 2023 has been launched. Through which you can check your eligibility. And sitting at home can register through the new form of BISP. Chairperson BISP Shazia Murree has started the re-registration of the Benazir income support program. So that ineligible and deserving people can do their registration at home through BISP New Form. \\n\\n<a href=\"https://ehsaasrashan.com/bisp-new-registration-form/8171 Web Portal\\n\\n8171 Ehsaas Program Online Registration 2023 - BISP 8171 Web portal\\n</a"
                    },
                    {
                        "username": "gautam1168",
                        "content": "what is this? The weaker version of the curry question ?"
                    }
                ]
            },
            {
                "id": 1921389,
                "content": [
                    {
                        "username": "evgeniy-utkin",
                        "content": "Somehow it passes all the tests even without chaining. And it probably shouldn\\'t."
                    },
                    {
                        "username": "newms3450",
                        "content": "Why is the gettter for result `getResult()` and not `get result()` (i.e., an actual JS getter)? This doesn't teach good JS coding practices."
                    },
                    {
                        "username": "Chenbao2021",
                        "content": "Can someone tell me what is the reason we return a new instance of Calculator? Instead of just up to date the value of result ?"
                    },
                    {
                        "username": "newms3450",
                        "content": "Because of the method chaining requirement. For the sake of not spoiling the answer, imagine instead if we\\'re asked to write a sentence-scrambler `SentenceScrambler` that can do three things:\\n1. `addText()`: It can add more text to the sentence.\\n2. `reverse()`: It can reverse the sentence: `hello world` transforms to `dlrow olleh`.\\n3. `pigLatin()` It can Pig-Latin-ify the sentence: `hello world` becomes `ellohay orldway`.\\n\\nWith _chaining_, I want to be able to run multiple methods (or the same method, or some combination of the two) in a _row_. That is, I don\\'t want to have to do:\\n\\n```JavaScript\\nlet sentenceScrambler = new SentenceScrambler();\\nsentenceScrambler.addText(\\'hello world\\');\\nsentenceScrambler.reverse();\\nsentenceScrambler.pigLatin();\\nsentenceScrambler.reverse();\\n```\\n\\nInstead, I wanna be able to do those four method lines in a chain - in one line! - like this:\\n\\n```JavaScript\\nlet sentenceScrambler = new SentenceScrambler();\\nsentenceScrambler.addText(\\'hello world\\').reverse().pigLatin().reverse();\\n```\\n\\nBy returning the same instance (`this`) of the scrambler at the end of each method:\\n```JavaScript\\naddText(value){\\n  this._value += value;\\n  return this;\\n}\\n```\\n\\nwe\\'re allowing the next \"thing\" in line - in this case, the `reverse()` to method to still be operating on a SentenceScrambler instance (with all its methods!)."
                    },
                    {
                        "username": "pemshera",
                        "content": "Line 106 in solution.js\\n            throw err;\\n            ^\\nDivision by zero is not  allowed\\n(Use `nodejs run --trace-uncaught ...` to show where the exception was thrown) `if (value === 0) throw \"Division by zero is not  allowed\";`"
                    },
                    {
                        "username": "an6814249",
                        "content": "BISP New Registration Form 2023 has been launched. Through which you can check your eligibility. And sitting at home can register through the new form of BISP. Chairperson BISP Shazia Murree has started the re-registration of the Benazir income support program. So that ineligible and deserving people can do their registration at home through BISP New Form. \\n\\n<a href=\"https://ehsaasrashan.com/bisp-new-registration-form/8171 Web Portal\\n\\n8171 Ehsaas Program Online Registration 2023 - BISP 8171 Web portal\\n</a"
                    },
                    {
                        "username": "gautam1168",
                        "content": "what is this? The weaker version of the curry question ?"
                    }
                ]
            }
        ]
    }
]